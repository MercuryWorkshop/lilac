// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chrome_device_policy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chrome_5fdevice_5fpolicy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chrome_5fdevice_5fpolicy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "policy_common_definitions.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chrome_5fdevice_5fpolicy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chrome_5fdevice_5fpolicy_2eproto {
  static const uint32_t offsets[];
};
namespace enterprise_management {
class AccessibilitySettingsProto;
struct AccessibilitySettingsProtoDefaultTypeInternal;
extern AccessibilitySettingsProtoDefaultTypeInternal _AccessibilitySettingsProto_default_instance_;
class AllowBluetoothProto;
struct AllowBluetoothProtoDefaultTypeInternal;
extern AllowBluetoothProtoDefaultTypeInternal _AllowBluetoothProto_default_instance_;
class AllowKioskAppControlChromeVersionProto;
struct AllowKioskAppControlChromeVersionProtoDefaultTypeInternal;
extern AllowKioskAppControlChromeVersionProtoDefaultTypeInternal _AllowKioskAppControlChromeVersionProto_default_instance_;
class AllowNewUsersProto;
struct AllowNewUsersProtoDefaultTypeInternal;
extern AllowNewUsersProtoDefaultTypeInternal _AllowNewUsersProto_default_instance_;
class AllowRedeemChromeOsRegistrationOffersProto;
struct AllowRedeemChromeOsRegistrationOffersProtoDefaultTypeInternal;
extern AllowRedeemChromeOsRegistrationOffersProtoDefaultTypeInternal _AllowRedeemChromeOsRegistrationOffersProto_default_instance_;
class AndroidKioskAppInfoProto;
struct AndroidKioskAppInfoProtoDefaultTypeInternal;
extern AndroidKioskAppInfoProtoDefaultTypeInternal _AndroidKioskAppInfoProto_default_instance_;
class AttestationSettingsProto;
struct AttestationSettingsProtoDefaultTypeInternal;
extern AttestationSettingsProtoDefaultTypeInternal _AttestationSettingsProto_default_instance_;
class AutoCleanupSettigsProto;
struct AutoCleanupSettigsProtoDefaultTypeInternal;
extern AutoCleanupSettigsProtoDefaultTypeInternal _AutoCleanupSettigsProto_default_instance_;
class AutoUpdateSettingsProto;
struct AutoUpdateSettingsProtoDefaultTypeInternal;
extern AutoUpdateSettingsProtoDefaultTypeInternal _AutoUpdateSettingsProto_default_instance_;
class CameraEnabledProto;
struct CameraEnabledProtoDefaultTypeInternal;
extern CameraEnabledProtoDefaultTypeInternal _CameraEnabledProto_default_instance_;
class CastReceiverNameProto;
struct CastReceiverNameProtoDefaultTypeInternal;
extern CastReceiverNameProtoDefaultTypeInternal _CastReceiverNameProto_default_instance_;
class ChromeDeviceSettingsProto;
struct ChromeDeviceSettingsProtoDefaultTypeInternal;
extern ChromeDeviceSettingsProtoDefaultTypeInternal _ChromeDeviceSettingsProto_default_instance_;
class DataRoamingEnabledProto;
struct DataRoamingEnabledProtoDefaultTypeInternal;
extern DataRoamingEnabledProtoDefaultTypeInternal _DataRoamingEnabledProto_default_instance_;
class DeviceAdvancedBatteryChargeModeProto;
struct DeviceAdvancedBatteryChargeModeProtoDefaultTypeInternal;
extern DeviceAdvancedBatteryChargeModeProtoDefaultTypeInternal _DeviceAdvancedBatteryChargeModeProto_default_instance_;
class DeviceAllowedBluetoothServicesProto;
struct DeviceAllowedBluetoothServicesProtoDefaultTypeInternal;
extern DeviceAllowedBluetoothServicesProtoDefaultTypeInternal _DeviceAllowedBluetoothServicesProto_default_instance_;
class DeviceArcDataSnapshotHoursProto;
struct DeviceArcDataSnapshotHoursProtoDefaultTypeInternal;
extern DeviceArcDataSnapshotHoursProtoDefaultTypeInternal _DeviceArcDataSnapshotHoursProto_default_instance_;
class DeviceAuthDataCacheLifetimeProto;
struct DeviceAuthDataCacheLifetimeProtoDefaultTypeInternal;
extern DeviceAuthDataCacheLifetimeProtoDefaultTypeInternal _DeviceAuthDataCacheLifetimeProto_default_instance_;
class DeviceBatteryChargeModeProto;
struct DeviceBatteryChargeModeProtoDefaultTypeInternal;
extern DeviceBatteryChargeModeProtoDefaultTypeInternal _DeviceBatteryChargeModeProto_default_instance_;
class DeviceBootOnAcProto;
struct DeviceBootOnAcProtoDefaultTypeInternal;
extern DeviceBootOnAcProtoDefaultTypeInternal _DeviceBootOnAcProto_default_instance_;
class DeviceCrostiniArcAdbSideloadingAllowedProto;
struct DeviceCrostiniArcAdbSideloadingAllowedProtoDefaultTypeInternal;
extern DeviceCrostiniArcAdbSideloadingAllowedProtoDefaultTypeInternal _DeviceCrostiniArcAdbSideloadingAllowedProto_default_instance_;
class DeviceDebugPacketCaptureAllowedProto;
struct DeviceDebugPacketCaptureAllowedProtoDefaultTypeInternal;
extern DeviceDebugPacketCaptureAllowedProtoDefaultTypeInternal _DeviceDebugPacketCaptureAllowedProto_default_instance_;
class DeviceDisplayResolutionProto;
struct DeviceDisplayResolutionProtoDefaultTypeInternal;
extern DeviceDisplayResolutionProtoDefaultTypeInternal _DeviceDisplayResolutionProto_default_instance_;
class DeviceDockMacAddressSourceProto;
struct DeviceDockMacAddressSourceProtoDefaultTypeInternal;
extern DeviceDockMacAddressSourceProtoDefaultTypeInternal _DeviceDockMacAddressSourceProto_default_instance_;
class DeviceEcryptfsMigrationStrategyProto;
struct DeviceEcryptfsMigrationStrategyProtoDefaultTypeInternal;
extern DeviceEcryptfsMigrationStrategyProtoDefaultTypeInternal _DeviceEcryptfsMigrationStrategyProto_default_instance_;
class DeviceExternalPrintServersAllowlistProto;
struct DeviceExternalPrintServersAllowlistProtoDefaultTypeInternal;
extern DeviceExternalPrintServersAllowlistProtoDefaultTypeInternal _DeviceExternalPrintServersAllowlistProto_default_instance_;
class DeviceExternalPrintServersProto;
struct DeviceExternalPrintServersProtoDefaultTypeInternal;
extern DeviceExternalPrintServersProtoDefaultTypeInternal _DeviceExternalPrintServersProto_default_instance_;
class DeviceFamilyLinkAccountsAllowedProto;
struct DeviceFamilyLinkAccountsAllowedProtoDefaultTypeInternal;
extern DeviceFamilyLinkAccountsAllowedProtoDefaultTypeInternal _DeviceFamilyLinkAccountsAllowedProto_default_instance_;
class DeviceGpoCacheLifetimeProto;
struct DeviceGpoCacheLifetimeProtoDefaultTypeInternal;
extern DeviceGpoCacheLifetimeProtoDefaultTypeInternal _DeviceGpoCacheLifetimeProto_default_instance_;
class DeviceHeartbeatSettingsProto;
struct DeviceHeartbeatSettingsProtoDefaultTypeInternal;
extern DeviceHeartbeatSettingsProtoDefaultTypeInternal _DeviceHeartbeatSettingsProto_default_instance_;
class DeviceHindiInscriptLayoutEnabledProto;
struct DeviceHindiInscriptLayoutEnabledProtoDefaultTypeInternal;
extern DeviceHindiInscriptLayoutEnabledProtoDefaultTypeInternal _DeviceHindiInscriptLayoutEnabledProto_default_instance_;
class DeviceI18nShortcutsEnabledProto;
struct DeviceI18nShortcutsEnabledProtoDefaultTypeInternal;
extern DeviceI18nShortcutsEnabledProtoDefaultTypeInternal _DeviceI18nShortcutsEnabledProto_default_instance_;
class DeviceKerberosEncryptionTypesProto;
struct DeviceKerberosEncryptionTypesProtoDefaultTypeInternal;
extern DeviceKerberosEncryptionTypesProtoDefaultTypeInternal _DeviceKerberosEncryptionTypesProto_default_instance_;
class DeviceKeylockerForStorageEncryptionEnabledProto;
struct DeviceKeylockerForStorageEncryptionEnabledProtoDefaultTypeInternal;
extern DeviceKeylockerForStorageEncryptionEnabledProtoDefaultTypeInternal _DeviceKeylockerForStorageEncryptionEnabledProto_default_instance_;
class DeviceLocalAccountInfoProto;
struct DeviceLocalAccountInfoProtoDefaultTypeInternal;
extern DeviceLocalAccountInfoProtoDefaultTypeInternal _DeviceLocalAccountInfoProto_default_instance_;
class DeviceLocalAccountsProto;
struct DeviceLocalAccountsProtoDefaultTypeInternal;
extern DeviceLocalAccountsProtoDefaultTypeInternal _DeviceLocalAccountsProto_default_instance_;
class DeviceLogUploadSettingsProto;
struct DeviceLogUploadSettingsProtoDefaultTypeInternal;
extern DeviceLogUploadSettingsProtoDefaultTypeInternal _DeviceLogUploadSettingsProto_default_instance_;
class DeviceLoginScreenAutoSelectCertificateForUrls;
struct DeviceLoginScreenAutoSelectCertificateForUrlsDefaultTypeInternal;
extern DeviceLoginScreenAutoSelectCertificateForUrlsDefaultTypeInternal _DeviceLoginScreenAutoSelectCertificateForUrls_default_instance_;
class DeviceLoginScreenExtensionsProto;
struct DeviceLoginScreenExtensionsProtoDefaultTypeInternal;
extern DeviceLoginScreenExtensionsProtoDefaultTypeInternal _DeviceLoginScreenExtensionsProto_default_instance_;
class DeviceLoginScreenPrivacyScreenEnabledProto;
struct DeviceLoginScreenPrivacyScreenEnabledProtoDefaultTypeInternal;
extern DeviceLoginScreenPrivacyScreenEnabledProtoDefaultTypeInternal _DeviceLoginScreenPrivacyScreenEnabledProto_default_instance_;
class DeviceLoginScreenWebUILazyLoadingProto;
struct DeviceLoginScreenWebUILazyLoadingProtoDefaultTypeInternal;
extern DeviceLoginScreenWebUILazyLoadingProtoDefaultTypeInternal _DeviceLoginScreenWebUILazyLoadingProto_default_instance_;
class DeviceLoginScreenWebUsbAllowDevicesForUrlsProto;
struct DeviceLoginScreenWebUsbAllowDevicesForUrlsProtoDefaultTypeInternal;
extern DeviceLoginScreenWebUsbAllowDevicesForUrlsProtoDefaultTypeInternal _DeviceLoginScreenWebUsbAllowDevicesForUrlsProto_default_instance_;
class DeviceMachinePasswordChangeRateProto;
struct DeviceMachinePasswordChangeRateProtoDefaultTypeInternal;
extern DeviceMachinePasswordChangeRateProtoDefaultTypeInternal _DeviceMachinePasswordChangeRateProto_default_instance_;
class DeviceNativePrintersAccessModeProto;
struct DeviceNativePrintersAccessModeProtoDefaultTypeInternal;
extern DeviceNativePrintersAccessModeProtoDefaultTypeInternal _DeviceNativePrintersAccessModeProto_default_instance_;
class DeviceNativePrintersBlacklistProto;
struct DeviceNativePrintersBlacklistProtoDefaultTypeInternal;
extern DeviceNativePrintersBlacklistProtoDefaultTypeInternal _DeviceNativePrintersBlacklistProto_default_instance_;
class DeviceNativePrintersProto;
struct DeviceNativePrintersProtoDefaultTypeInternal;
extern DeviceNativePrintersProtoDefaultTypeInternal _DeviceNativePrintersProto_default_instance_;
class DeviceNativePrintersWhitelistProto;
struct DeviceNativePrintersWhitelistProtoDefaultTypeInternal;
extern DeviceNativePrintersWhitelistProtoDefaultTypeInternal _DeviceNativePrintersWhitelistProto_default_instance_;
class DeviceOffHoursProto;
struct DeviceOffHoursProtoDefaultTypeInternal;
extern DeviceOffHoursProtoDefaultTypeInternal _DeviceOffHoursProto_default_instance_;
class DeviceOpenNetworkConfigurationProto;
struct DeviceOpenNetworkConfigurationProtoDefaultTypeInternal;
extern DeviceOpenNetworkConfigurationProtoDefaultTypeInternal _DeviceOpenNetworkConfigurationProto_default_instance_;
class DevicePciPeripheralDataAccessEnabledProto;
struct DevicePciPeripheralDataAccessEnabledProtoDefaultTypeInternal;
extern DevicePciPeripheralDataAccessEnabledProtoDefaultTypeInternal _DevicePciPeripheralDataAccessEnabledProto_default_instance_;
class DevicePciPeripheralDataAccessEnabledProtoV2;
struct DevicePciPeripheralDataAccessEnabledProtoV2DefaultTypeInternal;
extern DevicePciPeripheralDataAccessEnabledProtoV2DefaultTypeInternal _DevicePciPeripheralDataAccessEnabledProtoV2_default_instance_;
class DevicePolicyRefreshRateProto;
struct DevicePolicyRefreshRateProtoDefaultTypeInternal;
extern DevicePolicyRefreshRateProtoDefaultTypeInternal _DevicePolicyRefreshRateProto_default_instance_;
class DevicePowerPeakShiftProto;
struct DevicePowerPeakShiftProtoDefaultTypeInternal;
extern DevicePowerPeakShiftProtoDefaultTypeInternal _DevicePowerPeakShiftProto_default_instance_;
class DevicePowerwashAllowedProto;
struct DevicePowerwashAllowedProtoDefaultTypeInternal;
extern DevicePowerwashAllowedProtoDefaultTypeInternal _DevicePowerwashAllowedProto_default_instance_;
class DevicePrintersAccessModeProto;
struct DevicePrintersAccessModeProtoDefaultTypeInternal;
extern DevicePrintersAccessModeProtoDefaultTypeInternal _DevicePrintersAccessModeProto_default_instance_;
class DevicePrintersAllowlistProto;
struct DevicePrintersAllowlistProtoDefaultTypeInternal;
extern DevicePrintersAllowlistProtoDefaultTypeInternal _DevicePrintersAllowlistProto_default_instance_;
class DevicePrintersBlocklistProto;
struct DevicePrintersBlocklistProtoDefaultTypeInternal;
extern DevicePrintersBlocklistProtoDefaultTypeInternal _DevicePrintersBlocklistProto_default_instance_;
class DevicePrintersProto;
struct DevicePrintersProtoDefaultTypeInternal;
extern DevicePrintersProtoDefaultTypeInternal _DevicePrintersProto_default_instance_;
class DeviceQuirksDownloadEnabledProto;
struct DeviceQuirksDownloadEnabledProtoDefaultTypeInternal;
extern DeviceQuirksDownloadEnabledProtoDefaultTypeInternal _DeviceQuirksDownloadEnabledProto_default_instance_;
class DeviceRebootOnUserSignoutProto;
struct DeviceRebootOnUserSignoutProtoDefaultTypeInternal;
extern DeviceRebootOnUserSignoutProtoDefaultTypeInternal _DeviceRebootOnUserSignoutProto_default_instance_;
class DeviceReportXDREventsProto;
struct DeviceReportXDREventsProtoDefaultTypeInternal;
extern DeviceReportXDREventsProtoDefaultTypeInternal _DeviceReportXDREventsProto_default_instance_;
class DeviceReportingProto;
struct DeviceReportingProtoDefaultTypeInternal;
extern DeviceReportingProtoDefaultTypeInternal _DeviceReportingProto_default_instance_;
class DeviceRestrictedManagedGuestSessionEnabledProto;
struct DeviceRestrictedManagedGuestSessionEnabledProtoDefaultTypeInternal;
extern DeviceRestrictedManagedGuestSessionEnabledProtoDefaultTypeInternal _DeviceRestrictedManagedGuestSessionEnabledProto_default_instance_;
class DeviceScheduledRebootProto;
struct DeviceScheduledRebootProtoDefaultTypeInternal;
extern DeviceScheduledRebootProtoDefaultTypeInternal _DeviceScheduledRebootProto_default_instance_;
class DeviceScheduledUpdateCheckProto;
struct DeviceScheduledUpdateCheckProtoDefaultTypeInternal;
extern DeviceScheduledUpdateCheckProtoDefaultTypeInternal _DeviceScheduledUpdateCheckProto_default_instance_;
class DeviceScreensaverEnabledProto;
struct DeviceScreensaverEnabledProtoDefaultTypeInternal;
extern DeviceScreensaverEnabledProtoDefaultTypeInternal _DeviceScreensaverEnabledProto_default_instance_;
class DeviceScreensaverIdleTimeoutSecondsProto;
struct DeviceScreensaverIdleTimeoutSecondsProtoDefaultTypeInternal;
extern DeviceScreensaverIdleTimeoutSecondsProtoDefaultTypeInternal _DeviceScreensaverIdleTimeoutSecondsProto_default_instance_;
class DeviceScreensaverImageDisplayIntervalSecondsProto;
struct DeviceScreensaverImageDisplayIntervalSecondsProtoDefaultTypeInternal;
extern DeviceScreensaverImageDisplayIntervalSecondsProtoDefaultTypeInternal _DeviceScreensaverImageDisplayIntervalSecondsProto_default_instance_;
class DeviceScreensaverImagesProto;
struct DeviceScreensaverImagesProtoDefaultTypeInternal;
extern DeviceScreensaverImagesProtoDefaultTypeInternal _DeviceScreensaverImagesProto_default_instance_;
class DeviceSecondFactorAuthenticationProto;
struct DeviceSecondFactorAuthenticationProtoDefaultTypeInternal;
extern DeviceSecondFactorAuthenticationProtoDefaultTypeInternal _DeviceSecondFactorAuthenticationProto_default_instance_;
class DeviceShowLowDiskSpaceNotificationProto;
struct DeviceShowLowDiskSpaceNotificationProtoDefaultTypeInternal;
extern DeviceShowLowDiskSpaceNotificationProtoDefaultTypeInternal _DeviceShowLowDiskSpaceNotificationProto_default_instance_;
class DeviceSystemAecEnabledProto;
struct DeviceSystemAecEnabledProtoDefaultTypeInternal;
extern DeviceSystemAecEnabledProtoDefaultTypeInternal _DeviceSystemAecEnabledProto_default_instance_;
class DeviceSystemWideTracingEnabledProto;
struct DeviceSystemWideTracingEnabledProtoDefaultTypeInternal;
extern DeviceSystemWideTracingEnabledProtoDefaultTypeInternal _DeviceSystemWideTracingEnabledProto_default_instance_;
class DeviceUnaffiliatedCrostiniAllowedProto;
struct DeviceUnaffiliatedCrostiniAllowedProtoDefaultTypeInternal;
extern DeviceUnaffiliatedCrostiniAllowedProtoDefaultTypeInternal _DeviceUnaffiliatedCrostiniAllowedProto_default_instance_;
class DeviceUsbPowerShareProto;
struct DeviceUsbPowerShareProtoDefaultTypeInternal;
extern DeviceUsbPowerShareProtoDefaultTypeInternal _DeviceUsbPowerShareProto_default_instance_;
class DeviceUserPolicyLoopbackProcessingModeProto;
struct DeviceUserPolicyLoopbackProcessingModeProtoDefaultTypeInternal;
extern DeviceUserPolicyLoopbackProcessingModeProtoDefaultTypeInternal _DeviceUserPolicyLoopbackProcessingModeProto_default_instance_;
class DeviceWallpaperImageProto;
struct DeviceWallpaperImageProtoDefaultTypeInternal;
extern DeviceWallpaperImageProtoDefaultTypeInternal _DeviceWallpaperImageProto_default_instance_;
class DeviceWiFiAllowedProto;
struct DeviceWiFiAllowedProtoDefaultTypeInternal;
extern DeviceWiFiAllowedProtoDefaultTypeInternal _DeviceWiFiAllowedProto_default_instance_;
class DeviceWiFiFastTransitionEnabledProto;
struct DeviceWiFiFastTransitionEnabledProtoDefaultTypeInternal;
extern DeviceWiFiFastTransitionEnabledProtoDefaultTypeInternal _DeviceWiFiFastTransitionEnabledProto_default_instance_;
class DeviceWilcoDtcAllowedProto;
struct DeviceWilcoDtcAllowedProtoDefaultTypeInternal;
extern DeviceWilcoDtcAllowedProtoDefaultTypeInternal _DeviceWilcoDtcAllowedProto_default_instance_;
class DeviceWilcoDtcConfigurationProto;
struct DeviceWilcoDtcConfigurationProtoDefaultTypeInternal;
extern DeviceWilcoDtcConfigurationProtoDefaultTypeInternal _DeviceWilcoDtcConfigurationProto_default_instance_;
class DisplayRotationDefaultProto;
struct DisplayRotationDefaultProtoDefaultTypeInternal;
extern DisplayRotationDefaultProtoDefaultTypeInternal _DisplayRotationDefaultProto_default_instance_;
class EncryptedReportingPipelineConfigurationProto;
struct EncryptedReportingPipelineConfigurationProtoDefaultTypeInternal;
extern EncryptedReportingPipelineConfigurationProtoDefaultTypeInternal _EncryptedReportingPipelineConfigurationProto_default_instance_;
class EphemeralUsersEnabledProto;
struct EphemeralUsersEnabledProtoDefaultTypeInternal;
extern EphemeralUsersEnabledProtoDefaultTypeInternal _EphemeralUsersEnabledProto_default_instance_;
class ExtensionCacheSizeProto;
struct ExtensionCacheSizeProtoDefaultTypeInternal;
extern ExtensionCacheSizeProtoDefaultTypeInternal _ExtensionCacheSizeProto_default_instance_;
class FeatureFlagsProto;
struct FeatureFlagsProtoDefaultTypeInternal;
extern FeatureFlagsProtoDefaultTypeInternal _FeatureFlagsProto_default_instance_;
class GuestModeEnabledProto;
struct GuestModeEnabledProtoDefaultTypeInternal;
extern GuestModeEnabledProtoDefaultTypeInternal _GuestModeEnabledProto_default_instance_;
class HostnameUserConfigurableProto;
struct HostnameUserConfigurableProtoDefaultTypeInternal;
extern HostnameUserConfigurableProtoDefaultTypeInternal _HostnameUserConfigurableProto_default_instance_;
class KeyboardBacklightColorProto;
struct KeyboardBacklightColorProtoDefaultTypeInternal;
extern KeyboardBacklightColorProtoDefaultTypeInternal _KeyboardBacklightColorProto_default_instance_;
class KioskAppInfoProto;
struct KioskAppInfoProtoDefaultTypeInternal;
extern KioskAppInfoProtoDefaultTypeInternal _KioskAppInfoProto_default_instance_;
class LoginAuthenticationBehaviorProto;
struct LoginAuthenticationBehaviorProtoDefaultTypeInternal;
extern LoginAuthenticationBehaviorProtoDefaultTypeInternal _LoginAuthenticationBehaviorProto_default_instance_;
class LoginScreenDomainAutoCompleteProto;
struct LoginScreenDomainAutoCompleteProtoDefaultTypeInternal;
extern LoginScreenDomainAutoCompleteProtoDefaultTypeInternal _LoginScreenDomainAutoCompleteProto_default_instance_;
class LoginScreenExtensionManifestV2AvailabilityProto;
struct LoginScreenExtensionManifestV2AvailabilityProtoDefaultTypeInternal;
extern LoginScreenExtensionManifestV2AvailabilityProtoDefaultTypeInternal _LoginScreenExtensionManifestV2AvailabilityProto_default_instance_;
class LoginScreenInputMethodsProto;
struct LoginScreenInputMethodsProtoDefaultTypeInternal;
extern LoginScreenInputMethodsProtoDefaultTypeInternal _LoginScreenInputMethodsProto_default_instance_;
class LoginScreenLocalesProto;
struct LoginScreenLocalesProtoDefaultTypeInternal;
extern LoginScreenLocalesProtoDefaultTypeInternal _LoginScreenLocalesProto_default_instance_;
class LoginScreenPowerManagementProto;
struct LoginScreenPowerManagementProtoDefaultTypeInternal;
extern LoginScreenPowerManagementProtoDefaultTypeInternal _LoginScreenPowerManagementProto_default_instance_;
class LoginVideoCaptureAllowedUrlsProto;
struct LoginVideoCaptureAllowedUrlsProtoDefaultTypeInternal;
extern LoginVideoCaptureAllowedUrlsProtoDefaultTypeInternal _LoginVideoCaptureAllowedUrlsProto_default_instance_;
class ManagedGuestSessionPrivacyWarningsProto;
struct ManagedGuestSessionPrivacyWarningsProtoDefaultTypeInternal;
extern ManagedGuestSessionPrivacyWarningsProtoDefaultTypeInternal _ManagedGuestSessionPrivacyWarningsProto_default_instance_;
class MetricsEnabledProto;
struct MetricsEnabledProtoDefaultTypeInternal;
extern MetricsEnabledProtoDefaultTypeInternal _MetricsEnabledProto_default_instance_;
class NetworkHostnameProto;
struct NetworkHostnameProtoDefaultTypeInternal;
extern NetworkHostnameProtoDefaultTypeInternal _NetworkHostnameProto_default_instance_;
class NetworkThrottlingEnabledProto;
struct NetworkThrottlingEnabledProtoDefaultTypeInternal;
extern NetworkThrottlingEnabledProtoDefaultTypeInternal _NetworkThrottlingEnabledProto_default_instance_;
class OBSOLETE_AppPackEntryProto;
struct OBSOLETE_AppPackEntryProtoDefaultTypeInternal;
extern OBSOLETE_AppPackEntryProtoDefaultTypeInternal _OBSOLETE_AppPackEntryProto_default_instance_;
class OBSOLETE_AppPackProto;
struct OBSOLETE_AppPackProtoDefaultTypeInternal;
extern OBSOLETE_AppPackProtoDefaultTypeInternal _OBSOLETE_AppPackProto_default_instance_;
class OBSOLETE_DeviceBorealisAllowedProto;
struct OBSOLETE_DeviceBorealisAllowedProtoDefaultTypeInternal;
extern OBSOLETE_DeviceBorealisAllowedProtoDefaultTypeInternal _OBSOLETE_DeviceBorealisAllowedProto_default_instance_;
class OBSOLETE_DeviceLoginScreenIsolateOriginsProto;
struct OBSOLETE_DeviceLoginScreenIsolateOriginsProtoDefaultTypeInternal;
extern OBSOLETE_DeviceLoginScreenIsolateOriginsProtoDefaultTypeInternal _OBSOLETE_DeviceLoginScreenIsolateOriginsProto_default_instance_;
class OBSOLETE_DeviceLoginScreenSitePerProcessProto;
struct OBSOLETE_DeviceLoginScreenSitePerProcessProtoDefaultTypeInternal;
extern OBSOLETE_DeviceLoginScreenSitePerProcessProtoDefaultTypeInternal _OBSOLETE_DeviceLoginScreenSitePerProcessProto_default_instance_;
class OBSOLETE_DeviceProxySettingsProto;
struct OBSOLETE_DeviceProxySettingsProtoDefaultTypeInternal;
extern OBSOLETE_DeviceProxySettingsProtoDefaultTypeInternal _OBSOLETE_DeviceProxySettingsProto_default_instance_;
class OBSOLETE_ForcedLogoutTimeoutsProto;
struct OBSOLETE_ForcedLogoutTimeoutsProtoDefaultTypeInternal;
extern OBSOLETE_ForcedLogoutTimeoutsProtoDefaultTypeInternal _OBSOLETE_ForcedLogoutTimeoutsProto_default_instance_;
class OBSOLETE_MinimumRequiredVersionProto;
struct OBSOLETE_MinimumRequiredVersionProtoDefaultTypeInternal;
extern OBSOLETE_MinimumRequiredVersionProtoDefaultTypeInternal _OBSOLETE_MinimumRequiredVersionProto_default_instance_;
class OBSOLETE_PinnedAppsProto;
struct OBSOLETE_PinnedAppsProtoDefaultTypeInternal;
extern OBSOLETE_PinnedAppsProtoDefaultTypeInternal _OBSOLETE_PinnedAppsProto_default_instance_;
class OBSOLETE_ScreenSaverProto;
struct OBSOLETE_ScreenSaverProtoDefaultTypeInternal;
extern OBSOLETE_ScreenSaverProtoDefaultTypeInternal _OBSOLETE_ScreenSaverProto_default_instance_;
class OBSOLETE_StartUpUrlsProto;
struct OBSOLETE_StartUpUrlsProtoDefaultTypeInternal;
extern OBSOLETE_StartUpUrlsProtoDefaultTypeInternal _OBSOLETE_StartUpUrlsProto_default_instance_;
class OBSOLETE_SupervisedUsersSettingsProto;
struct OBSOLETE_SupervisedUsersSettingsProtoDefaultTypeInternal;
extern OBSOLETE_SupervisedUsersSettingsProtoDefaultTypeInternal _OBSOLETE_SupervisedUsersSettingsProto_default_instance_;
class PluginVmAllowedProto;
struct PluginVmAllowedProtoDefaultTypeInternal;
extern PluginVmAllowedProtoDefaultTypeInternal _PluginVmAllowedProto_default_instance_;
class PluginVmLicenseKeyProto;
struct PluginVmLicenseKeyProtoDefaultTypeInternal;
extern PluginVmLicenseKeyProtoDefaultTypeInternal _PluginVmLicenseKeyProto_default_instance_;
class RebootOnShutdownProto;
struct RebootOnShutdownProtoDefaultTypeInternal;
extern RebootOnShutdownProtoDefaultTypeInternal _RebootOnShutdownProto_default_instance_;
class ReleaseChannelProto;
struct ReleaseChannelProtoDefaultTypeInternal;
extern ReleaseChannelProtoDefaultTypeInternal _ReleaseChannelProto_default_instance_;
class RequiredClientCertificateForDeviceProto;
struct RequiredClientCertificateForDeviceProtoDefaultTypeInternal;
extern RequiredClientCertificateForDeviceProtoDefaultTypeInternal _RequiredClientCertificateForDeviceProto_default_instance_;
class RevenDeviceHWDataUsageEnabledProto;
struct RevenDeviceHWDataUsageEnabledProtoDefaultTypeInternal;
extern RevenDeviceHWDataUsageEnabledProtoDefaultTypeInternal _RevenDeviceHWDataUsageEnabledProto_default_instance_;
class SAMLSettingsProto;
struct SAMLSettingsProtoDefaultTypeInternal;
extern SAMLSettingsProtoDefaultTypeInternal _SAMLSettingsProto_default_instance_;
class SAMLUsernameProto;
struct SAMLUsernameProtoDefaultTypeInternal;
extern SAMLUsernameProtoDefaultTypeInternal _SAMLUsernameProto_default_instance_;
class ShowUserNamesOnSigninProto;
struct ShowUserNamesOnSigninProtoDefaultTypeInternal;
extern ShowUserNamesOnSigninProtoDefaultTypeInternal _ShowUserNamesOnSigninProto_default_instance_;
class SystemProxySettingsProto;
struct SystemProxySettingsProtoDefaultTypeInternal;
extern SystemProxySettingsProtoDefaultTypeInternal _SystemProxySettingsProto_default_instance_;
class SystemSettingsProto;
struct SystemSettingsProtoDefaultTypeInternal;
extern SystemSettingsProtoDefaultTypeInternal _SystemSettingsProto_default_instance_;
class SystemTimezoneProto;
struct SystemTimezoneProtoDefaultTypeInternal;
extern SystemTimezoneProtoDefaultTypeInternal _SystemTimezoneProto_default_instance_;
class SystemUse24HourClockProto;
struct SystemUse24HourClockProtoDefaultTypeInternal;
extern SystemUse24HourClockProtoDefaultTypeInternal _SystemUse24HourClockProto_default_instance_;
class TPMFirmwareUpdateSettingsProto;
struct TPMFirmwareUpdateSettingsProtoDefaultTypeInternal;
extern TPMFirmwareUpdateSettingsProtoDefaultTypeInternal _TPMFirmwareUpdateSettingsProto_default_instance_;
class UnaffiliatedArcAllowedProto;
struct UnaffiliatedArcAllowedProtoDefaultTypeInternal;
extern UnaffiliatedArcAllowedProtoDefaultTypeInternal _UnaffiliatedArcAllowedProto_default_instance_;
class UptimeLimitProto;
struct UptimeLimitProtoDefaultTypeInternal;
extern UptimeLimitProtoDefaultTypeInternal _UptimeLimitProto_default_instance_;
class UsbDetachableAllowlistProto;
struct UsbDetachableAllowlistProtoDefaultTypeInternal;
extern UsbDetachableAllowlistProtoDefaultTypeInternal _UsbDetachableAllowlistProto_default_instance_;
class UsbDetachableWhitelistProto;
struct UsbDetachableWhitelistProtoDefaultTypeInternal;
extern UsbDetachableWhitelistProtoDefaultTypeInternal _UsbDetachableWhitelistProto_default_instance_;
class UsbDeviceIdInclusiveProto;
struct UsbDeviceIdInclusiveProtoDefaultTypeInternal;
extern UsbDeviceIdInclusiveProtoDefaultTypeInternal _UsbDeviceIdInclusiveProto_default_instance_;
class UsbDeviceIdProto;
struct UsbDeviceIdProtoDefaultTypeInternal;
extern UsbDeviceIdProtoDefaultTypeInternal _UsbDeviceIdProto_default_instance_;
class UserAllowlistProto;
struct UserAllowlistProtoDefaultTypeInternal;
extern UserAllowlistProtoDefaultTypeInternal _UserAllowlistProto_default_instance_;
class UserWhitelistProto;
struct UserWhitelistProtoDefaultTypeInternal;
extern UserWhitelistProtoDefaultTypeInternal _UserWhitelistProto_default_instance_;
class VariationsParameterProto;
struct VariationsParameterProtoDefaultTypeInternal;
extern VariationsParameterProtoDefaultTypeInternal _VariationsParameterProto_default_instance_;
class VirtualMachinesAllowedProto;
struct VirtualMachinesAllowedProtoDefaultTypeInternal;
extern VirtualMachinesAllowedProtoDefaultTypeInternal _VirtualMachinesAllowedProto_default_instance_;
class WebKioskAppInfoProto;
struct WebKioskAppInfoProtoDefaultTypeInternal;
extern WebKioskAppInfoProtoDefaultTypeInternal _WebKioskAppInfoProto_default_instance_;
class WeeklyTimeIntervalProto;
struct WeeklyTimeIntervalProtoDefaultTypeInternal;
extern WeeklyTimeIntervalProtoDefaultTypeInternal _WeeklyTimeIntervalProto_default_instance_;
class WeeklyTimeProto;
struct WeeklyTimeProtoDefaultTypeInternal;
extern WeeklyTimeProtoDefaultTypeInternal _WeeklyTimeProto_default_instance_;
}  // namespace enterprise_management
PROTOBUF_NAMESPACE_OPEN
template<> ::enterprise_management::AccessibilitySettingsProto* Arena::CreateMaybeMessage<::enterprise_management::AccessibilitySettingsProto>(Arena*);
template<> ::enterprise_management::AllowBluetoothProto* Arena::CreateMaybeMessage<::enterprise_management::AllowBluetoothProto>(Arena*);
template<> ::enterprise_management::AllowKioskAppControlChromeVersionProto* Arena::CreateMaybeMessage<::enterprise_management::AllowKioskAppControlChromeVersionProto>(Arena*);
template<> ::enterprise_management::AllowNewUsersProto* Arena::CreateMaybeMessage<::enterprise_management::AllowNewUsersProto>(Arena*);
template<> ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* Arena::CreateMaybeMessage<::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto>(Arena*);
template<> ::enterprise_management::AndroidKioskAppInfoProto* Arena::CreateMaybeMessage<::enterprise_management::AndroidKioskAppInfoProto>(Arena*);
template<> ::enterprise_management::AttestationSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::AttestationSettingsProto>(Arena*);
template<> ::enterprise_management::AutoCleanupSettigsProto* Arena::CreateMaybeMessage<::enterprise_management::AutoCleanupSettigsProto>(Arena*);
template<> ::enterprise_management::AutoUpdateSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::AutoUpdateSettingsProto>(Arena*);
template<> ::enterprise_management::CameraEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::CameraEnabledProto>(Arena*);
template<> ::enterprise_management::CastReceiverNameProto* Arena::CreateMaybeMessage<::enterprise_management::CastReceiverNameProto>(Arena*);
template<> ::enterprise_management::ChromeDeviceSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::ChromeDeviceSettingsProto>(Arena*);
template<> ::enterprise_management::DataRoamingEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DataRoamingEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceAdvancedBatteryChargeModeProto>(Arena*);
template<> ::enterprise_management::DeviceAllowedBluetoothServicesProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceAllowedBluetoothServicesProto>(Arena*);
template<> ::enterprise_management::DeviceArcDataSnapshotHoursProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceArcDataSnapshotHoursProto>(Arena*);
template<> ::enterprise_management::DeviceAuthDataCacheLifetimeProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceAuthDataCacheLifetimeProto>(Arena*);
template<> ::enterprise_management::DeviceBatteryChargeModeProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceBatteryChargeModeProto>(Arena*);
template<> ::enterprise_management::DeviceBootOnAcProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceBootOnAcProto>(Arena*);
template<> ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto>(Arena*);
template<> ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceDebugPacketCaptureAllowedProto>(Arena*);
template<> ::enterprise_management::DeviceDisplayResolutionProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceDisplayResolutionProto>(Arena*);
template<> ::enterprise_management::DeviceDockMacAddressSourceProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceDockMacAddressSourceProto>(Arena*);
template<> ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceEcryptfsMigrationStrategyProto>(Arena*);
template<> ::enterprise_management::DeviceExternalPrintServersAllowlistProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceExternalPrintServersAllowlistProto>(Arena*);
template<> ::enterprise_management::DeviceExternalPrintServersProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceExternalPrintServersProto>(Arena*);
template<> ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceFamilyLinkAccountsAllowedProto>(Arena*);
template<> ::enterprise_management::DeviceGpoCacheLifetimeProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceGpoCacheLifetimeProto>(Arena*);
template<> ::enterprise_management::DeviceHeartbeatSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceHeartbeatSettingsProto>(Arena*);
template<> ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceHindiInscriptLayoutEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceI18nShortcutsEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceI18nShortcutsEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceKerberosEncryptionTypesProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceKerberosEncryptionTypesProto>(Arena*);
template<> ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceLocalAccountInfoProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceLocalAccountInfoProto>(Arena*);
template<> ::enterprise_management::DeviceLocalAccountsProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceLocalAccountsProto>(Arena*);
template<> ::enterprise_management::DeviceLogUploadSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceLogUploadSettingsProto>(Arena*);
template<> ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* Arena::CreateMaybeMessage<::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls>(Arena*);
template<> ::enterprise_management::DeviceLoginScreenExtensionsProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceLoginScreenExtensionsProto>(Arena*);
template<> ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto>(Arena*);
template<> ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto>(Arena*);
template<> ::enterprise_management::DeviceMachinePasswordChangeRateProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceMachinePasswordChangeRateProto>(Arena*);
template<> ::enterprise_management::DeviceNativePrintersAccessModeProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceNativePrintersAccessModeProto>(Arena*);
template<> ::enterprise_management::DeviceNativePrintersBlacklistProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceNativePrintersBlacklistProto>(Arena*);
template<> ::enterprise_management::DeviceNativePrintersProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceNativePrintersProto>(Arena*);
template<> ::enterprise_management::DeviceNativePrintersWhitelistProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceNativePrintersWhitelistProto>(Arena*);
template<> ::enterprise_management::DeviceOffHoursProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceOffHoursProto>(Arena*);
template<> ::enterprise_management::DeviceOpenNetworkConfigurationProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceOpenNetworkConfigurationProto>(Arena*);
template<> ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DevicePciPeripheralDataAccessEnabledProto>(Arena*);
template<> ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* Arena::CreateMaybeMessage<::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2>(Arena*);
template<> ::enterprise_management::DevicePolicyRefreshRateProto* Arena::CreateMaybeMessage<::enterprise_management::DevicePolicyRefreshRateProto>(Arena*);
template<> ::enterprise_management::DevicePowerPeakShiftProto* Arena::CreateMaybeMessage<::enterprise_management::DevicePowerPeakShiftProto>(Arena*);
template<> ::enterprise_management::DevicePowerwashAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::DevicePowerwashAllowedProto>(Arena*);
template<> ::enterprise_management::DevicePrintersAccessModeProto* Arena::CreateMaybeMessage<::enterprise_management::DevicePrintersAccessModeProto>(Arena*);
template<> ::enterprise_management::DevicePrintersAllowlistProto* Arena::CreateMaybeMessage<::enterprise_management::DevicePrintersAllowlistProto>(Arena*);
template<> ::enterprise_management::DevicePrintersBlocklistProto* Arena::CreateMaybeMessage<::enterprise_management::DevicePrintersBlocklistProto>(Arena*);
template<> ::enterprise_management::DevicePrintersProto* Arena::CreateMaybeMessage<::enterprise_management::DevicePrintersProto>(Arena*);
template<> ::enterprise_management::DeviceQuirksDownloadEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceQuirksDownloadEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceRebootOnUserSignoutProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceRebootOnUserSignoutProto>(Arena*);
template<> ::enterprise_management::DeviceReportXDREventsProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceReportXDREventsProto>(Arena*);
template<> ::enterprise_management::DeviceReportingProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceReportingProto>(Arena*);
template<> ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceScheduledRebootProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceScheduledRebootProto>(Arena*);
template<> ::enterprise_management::DeviceScheduledUpdateCheckProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceScheduledUpdateCheckProto>(Arena*);
template<> ::enterprise_management::DeviceScreensaverEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceScreensaverEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto>(Arena*);
template<> ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto>(Arena*);
template<> ::enterprise_management::DeviceScreensaverImagesProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceScreensaverImagesProto>(Arena*);
template<> ::enterprise_management::DeviceSecondFactorAuthenticationProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceSecondFactorAuthenticationProto>(Arena*);
template<> ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceShowLowDiskSpaceNotificationProto>(Arena*);
template<> ::enterprise_management::DeviceSystemAecEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceSystemAecEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceSystemWideTracingEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceSystemWideTracingEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto>(Arena*);
template<> ::enterprise_management::DeviceUsbPowerShareProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceUsbPowerShareProto>(Arena*);
template<> ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto>(Arena*);
template<> ::enterprise_management::DeviceWallpaperImageProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceWallpaperImageProto>(Arena*);
template<> ::enterprise_management::DeviceWiFiAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceWiFiAllowedProto>(Arena*);
template<> ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceWiFiFastTransitionEnabledProto>(Arena*);
template<> ::enterprise_management::DeviceWilcoDtcAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceWilcoDtcAllowedProto>(Arena*);
template<> ::enterprise_management::DeviceWilcoDtcConfigurationProto* Arena::CreateMaybeMessage<::enterprise_management::DeviceWilcoDtcConfigurationProto>(Arena*);
template<> ::enterprise_management::DisplayRotationDefaultProto* Arena::CreateMaybeMessage<::enterprise_management::DisplayRotationDefaultProto>(Arena*);
template<> ::enterprise_management::EncryptedReportingPipelineConfigurationProto* Arena::CreateMaybeMessage<::enterprise_management::EncryptedReportingPipelineConfigurationProto>(Arena*);
template<> ::enterprise_management::EphemeralUsersEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::EphemeralUsersEnabledProto>(Arena*);
template<> ::enterprise_management::ExtensionCacheSizeProto* Arena::CreateMaybeMessage<::enterprise_management::ExtensionCacheSizeProto>(Arena*);
template<> ::enterprise_management::FeatureFlagsProto* Arena::CreateMaybeMessage<::enterprise_management::FeatureFlagsProto>(Arena*);
template<> ::enterprise_management::GuestModeEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::GuestModeEnabledProto>(Arena*);
template<> ::enterprise_management::HostnameUserConfigurableProto* Arena::CreateMaybeMessage<::enterprise_management::HostnameUserConfigurableProto>(Arena*);
template<> ::enterprise_management::KeyboardBacklightColorProto* Arena::CreateMaybeMessage<::enterprise_management::KeyboardBacklightColorProto>(Arena*);
template<> ::enterprise_management::KioskAppInfoProto* Arena::CreateMaybeMessage<::enterprise_management::KioskAppInfoProto>(Arena*);
template<> ::enterprise_management::LoginAuthenticationBehaviorProto* Arena::CreateMaybeMessage<::enterprise_management::LoginAuthenticationBehaviorProto>(Arena*);
template<> ::enterprise_management::LoginScreenDomainAutoCompleteProto* Arena::CreateMaybeMessage<::enterprise_management::LoginScreenDomainAutoCompleteProto>(Arena*);
template<> ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* Arena::CreateMaybeMessage<::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto>(Arena*);
template<> ::enterprise_management::LoginScreenInputMethodsProto* Arena::CreateMaybeMessage<::enterprise_management::LoginScreenInputMethodsProto>(Arena*);
template<> ::enterprise_management::LoginScreenLocalesProto* Arena::CreateMaybeMessage<::enterprise_management::LoginScreenLocalesProto>(Arena*);
template<> ::enterprise_management::LoginScreenPowerManagementProto* Arena::CreateMaybeMessage<::enterprise_management::LoginScreenPowerManagementProto>(Arena*);
template<> ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* Arena::CreateMaybeMessage<::enterprise_management::LoginVideoCaptureAllowedUrlsProto>(Arena*);
template<> ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* Arena::CreateMaybeMessage<::enterprise_management::ManagedGuestSessionPrivacyWarningsProto>(Arena*);
template<> ::enterprise_management::MetricsEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::MetricsEnabledProto>(Arena*);
template<> ::enterprise_management::NetworkHostnameProto* Arena::CreateMaybeMessage<::enterprise_management::NetworkHostnameProto>(Arena*);
template<> ::enterprise_management::NetworkThrottlingEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::NetworkThrottlingEnabledProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_AppPackEntryProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_AppPackEntryProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_AppPackProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_AppPackProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_DeviceProxySettingsProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_MinimumRequiredVersionProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_PinnedAppsProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_PinnedAppsProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_ScreenSaverProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_ScreenSaverProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_StartUpUrlsProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_StartUpUrlsProto>(Arena*);
template<> ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto>(Arena*);
template<> ::enterprise_management::PluginVmAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::PluginVmAllowedProto>(Arena*);
template<> ::enterprise_management::PluginVmLicenseKeyProto* Arena::CreateMaybeMessage<::enterprise_management::PluginVmLicenseKeyProto>(Arena*);
template<> ::enterprise_management::RebootOnShutdownProto* Arena::CreateMaybeMessage<::enterprise_management::RebootOnShutdownProto>(Arena*);
template<> ::enterprise_management::ReleaseChannelProto* Arena::CreateMaybeMessage<::enterprise_management::ReleaseChannelProto>(Arena*);
template<> ::enterprise_management::RequiredClientCertificateForDeviceProto* Arena::CreateMaybeMessage<::enterprise_management::RequiredClientCertificateForDeviceProto>(Arena*);
template<> ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* Arena::CreateMaybeMessage<::enterprise_management::RevenDeviceHWDataUsageEnabledProto>(Arena*);
template<> ::enterprise_management::SAMLSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::SAMLSettingsProto>(Arena*);
template<> ::enterprise_management::SAMLUsernameProto* Arena::CreateMaybeMessage<::enterprise_management::SAMLUsernameProto>(Arena*);
template<> ::enterprise_management::ShowUserNamesOnSigninProto* Arena::CreateMaybeMessage<::enterprise_management::ShowUserNamesOnSigninProto>(Arena*);
template<> ::enterprise_management::SystemProxySettingsProto* Arena::CreateMaybeMessage<::enterprise_management::SystemProxySettingsProto>(Arena*);
template<> ::enterprise_management::SystemSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::SystemSettingsProto>(Arena*);
template<> ::enterprise_management::SystemTimezoneProto* Arena::CreateMaybeMessage<::enterprise_management::SystemTimezoneProto>(Arena*);
template<> ::enterprise_management::SystemUse24HourClockProto* Arena::CreateMaybeMessage<::enterprise_management::SystemUse24HourClockProto>(Arena*);
template<> ::enterprise_management::TPMFirmwareUpdateSettingsProto* Arena::CreateMaybeMessage<::enterprise_management::TPMFirmwareUpdateSettingsProto>(Arena*);
template<> ::enterprise_management::UnaffiliatedArcAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::UnaffiliatedArcAllowedProto>(Arena*);
template<> ::enterprise_management::UptimeLimitProto* Arena::CreateMaybeMessage<::enterprise_management::UptimeLimitProto>(Arena*);
template<> ::enterprise_management::UsbDetachableAllowlistProto* Arena::CreateMaybeMessage<::enterprise_management::UsbDetachableAllowlistProto>(Arena*);
template<> ::enterprise_management::UsbDetachableWhitelistProto* Arena::CreateMaybeMessage<::enterprise_management::UsbDetachableWhitelistProto>(Arena*);
template<> ::enterprise_management::UsbDeviceIdInclusiveProto* Arena::CreateMaybeMessage<::enterprise_management::UsbDeviceIdInclusiveProto>(Arena*);
template<> ::enterprise_management::UsbDeviceIdProto* Arena::CreateMaybeMessage<::enterprise_management::UsbDeviceIdProto>(Arena*);
template<> ::enterprise_management::UserAllowlistProto* Arena::CreateMaybeMessage<::enterprise_management::UserAllowlistProto>(Arena*);
template<> ::enterprise_management::UserWhitelistProto* Arena::CreateMaybeMessage<::enterprise_management::UserWhitelistProto>(Arena*);
template<> ::enterprise_management::VariationsParameterProto* Arena::CreateMaybeMessage<::enterprise_management::VariationsParameterProto>(Arena*);
template<> ::enterprise_management::VirtualMachinesAllowedProto* Arena::CreateMaybeMessage<::enterprise_management::VirtualMachinesAllowedProto>(Arena*);
template<> ::enterprise_management::WebKioskAppInfoProto* Arena::CreateMaybeMessage<::enterprise_management::WebKioskAppInfoProto>(Arena*);
template<> ::enterprise_management::WeeklyTimeIntervalProto* Arena::CreateMaybeMessage<::enterprise_management::WeeklyTimeIntervalProto>(Arena*);
template<> ::enterprise_management::WeeklyTimeProto* Arena::CreateMaybeMessage<::enterprise_management::WeeklyTimeProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace enterprise_management {

enum AutoUpdateSettingsProto_ConnectionType : int {
  AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_ETHERNET = 0,
  AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_WIFI = 1,
  AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_WIMAX = 2,
  AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_BLUETOOTH = 3,
  AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_CELLULAR = 4
};
bool AutoUpdateSettingsProto_ConnectionType_IsValid(int value);
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto_ConnectionType_ConnectionType_MIN = AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_ETHERNET;
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto_ConnectionType_ConnectionType_MAX = AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_CELLULAR;
constexpr int AutoUpdateSettingsProto_ConnectionType_ConnectionType_ARRAYSIZE = AutoUpdateSettingsProto_ConnectionType_ConnectionType_MAX + 1;

const std::string& AutoUpdateSettingsProto_ConnectionType_Name(AutoUpdateSettingsProto_ConnectionType value);
template<typename T>
inline const std::string& AutoUpdateSettingsProto_ConnectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutoUpdateSettingsProto_ConnectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutoUpdateSettingsProto_ConnectionType_Name.");
  return AutoUpdateSettingsProto_ConnectionType_Name(static_cast<AutoUpdateSettingsProto_ConnectionType>(enum_t_value));
}
bool AutoUpdateSettingsProto_ConnectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoUpdateSettingsProto_ConnectionType* value);
enum AutoUpdateSettingsProto_RollbackToTargetVersion : int {
  AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_UNSPECIFIED = 0,
  AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_DISABLED = 1,
  AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_AND_POWERWASH = 2,
  AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_AND_RESTORE_IF_POSSIBLE = 3
};
bool AutoUpdateSettingsProto_RollbackToTargetVersion_IsValid(int value);
constexpr AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto_RollbackToTargetVersion_RollbackToTargetVersion_MIN = AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_UNSPECIFIED;
constexpr AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto_RollbackToTargetVersion_RollbackToTargetVersion_MAX = AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_AND_RESTORE_IF_POSSIBLE;
constexpr int AutoUpdateSettingsProto_RollbackToTargetVersion_RollbackToTargetVersion_ARRAYSIZE = AutoUpdateSettingsProto_RollbackToTargetVersion_RollbackToTargetVersion_MAX + 1;

const std::string& AutoUpdateSettingsProto_RollbackToTargetVersion_Name(AutoUpdateSettingsProto_RollbackToTargetVersion value);
template<typename T>
inline const std::string& AutoUpdateSettingsProto_RollbackToTargetVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutoUpdateSettingsProto_RollbackToTargetVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutoUpdateSettingsProto_RollbackToTargetVersion_Name.");
  return AutoUpdateSettingsProto_RollbackToTargetVersion_Name(static_cast<AutoUpdateSettingsProto_RollbackToTargetVersion>(enum_t_value));
}
bool AutoUpdateSettingsProto_RollbackToTargetVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoUpdateSettingsProto_RollbackToTargetVersion* value);
enum AutoUpdateSettingsProto_ChannelDowngradeBehavior : int {
  AutoUpdateSettingsProto_ChannelDowngradeBehavior_CHANNEL_DOWNGRADE_BEHAVIOR_UNSPECIFIED = 0,
  AutoUpdateSettingsProto_ChannelDowngradeBehavior_WAIT_FOR_VERSION_CATCH_UP = 1,
  AutoUpdateSettingsProto_ChannelDowngradeBehavior_ROLLBACK = 2,
  AutoUpdateSettingsProto_ChannelDowngradeBehavior_ALLOW_USER_TO_CONFIGURE = 3
};
bool AutoUpdateSettingsProto_ChannelDowngradeBehavior_IsValid(int value);
constexpr AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto_ChannelDowngradeBehavior_ChannelDowngradeBehavior_MIN = AutoUpdateSettingsProto_ChannelDowngradeBehavior_CHANNEL_DOWNGRADE_BEHAVIOR_UNSPECIFIED;
constexpr AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto_ChannelDowngradeBehavior_ChannelDowngradeBehavior_MAX = AutoUpdateSettingsProto_ChannelDowngradeBehavior_ALLOW_USER_TO_CONFIGURE;
constexpr int AutoUpdateSettingsProto_ChannelDowngradeBehavior_ChannelDowngradeBehavior_ARRAYSIZE = AutoUpdateSettingsProto_ChannelDowngradeBehavior_ChannelDowngradeBehavior_MAX + 1;

const std::string& AutoUpdateSettingsProto_ChannelDowngradeBehavior_Name(AutoUpdateSettingsProto_ChannelDowngradeBehavior value);
template<typename T>
inline const std::string& AutoUpdateSettingsProto_ChannelDowngradeBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutoUpdateSettingsProto_ChannelDowngradeBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutoUpdateSettingsProto_ChannelDowngradeBehavior_Name.");
  return AutoUpdateSettingsProto_ChannelDowngradeBehavior_Name(static_cast<AutoUpdateSettingsProto_ChannelDowngradeBehavior>(enum_t_value));
}
bool AutoUpdateSettingsProto_ChannelDowngradeBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoUpdateSettingsProto_ChannelDowngradeBehavior* value);
enum SystemTimezoneProto_AutomaticTimezoneDetectionType : int {
  SystemTimezoneProto_AutomaticTimezoneDetectionType_USERS_DECIDE = 0,
  SystemTimezoneProto_AutomaticTimezoneDetectionType_DISABLED = 1,
  SystemTimezoneProto_AutomaticTimezoneDetectionType_IP_ONLY = 2,
  SystemTimezoneProto_AutomaticTimezoneDetectionType_SEND_WIFI_ACCESS_POINTS = 3,
  SystemTimezoneProto_AutomaticTimezoneDetectionType_SEND_ALL_LOCATION_INFO = 4
};
bool SystemTimezoneProto_AutomaticTimezoneDetectionType_IsValid(int value);
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto_AutomaticTimezoneDetectionType_AutomaticTimezoneDetectionType_MIN = SystemTimezoneProto_AutomaticTimezoneDetectionType_USERS_DECIDE;
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto_AutomaticTimezoneDetectionType_AutomaticTimezoneDetectionType_MAX = SystemTimezoneProto_AutomaticTimezoneDetectionType_SEND_ALL_LOCATION_INFO;
constexpr int SystemTimezoneProto_AutomaticTimezoneDetectionType_AutomaticTimezoneDetectionType_ARRAYSIZE = SystemTimezoneProto_AutomaticTimezoneDetectionType_AutomaticTimezoneDetectionType_MAX + 1;

const std::string& SystemTimezoneProto_AutomaticTimezoneDetectionType_Name(SystemTimezoneProto_AutomaticTimezoneDetectionType value);
template<typename T>
inline const std::string& SystemTimezoneProto_AutomaticTimezoneDetectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemTimezoneProto_AutomaticTimezoneDetectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemTimezoneProto_AutomaticTimezoneDetectionType_Name.");
  return SystemTimezoneProto_AutomaticTimezoneDetectionType_Name(static_cast<SystemTimezoneProto_AutomaticTimezoneDetectionType>(enum_t_value));
}
bool SystemTimezoneProto_AutomaticTimezoneDetectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemTimezoneProto_AutomaticTimezoneDetectionType* value);
enum DeviceLocalAccountInfoProto_AccountType : int {
  DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_PUBLIC_SESSION = 0,
  DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_KIOSK_APP = 1,
  DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_KIOSK_ANDROID_APP = 2,
  DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_SAML_PUBLIC_SESSION = 3,
  DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_WEB_KIOSK_APP = 4
};
bool DeviceLocalAccountInfoProto_AccountType_IsValid(int value);
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto_AccountType_AccountType_MIN = DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_PUBLIC_SESSION;
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto_AccountType_AccountType_MAX = DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_WEB_KIOSK_APP;
constexpr int DeviceLocalAccountInfoProto_AccountType_AccountType_ARRAYSIZE = DeviceLocalAccountInfoProto_AccountType_AccountType_MAX + 1;

const std::string& DeviceLocalAccountInfoProto_AccountType_Name(DeviceLocalAccountInfoProto_AccountType value);
template<typename T>
inline const std::string& DeviceLocalAccountInfoProto_AccountType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceLocalAccountInfoProto_AccountType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceLocalAccountInfoProto_AccountType_Name.");
  return DeviceLocalAccountInfoProto_AccountType_Name(static_cast<DeviceLocalAccountInfoProto_AccountType>(enum_t_value));
}
bool DeviceLocalAccountInfoProto_AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceLocalAccountInfoProto_AccountType* value);
enum AccessibilitySettingsProto_ScreenMagnifierType : int {
  AccessibilitySettingsProto_ScreenMagnifierType_SCREEN_MAGNIFIER_TYPE_NONE = 0,
  AccessibilitySettingsProto_ScreenMagnifierType_SCREEN_MAGNIFIER_TYPE_FULL = 1
};
bool AccessibilitySettingsProto_ScreenMagnifierType_IsValid(int value);
constexpr AccessibilitySettingsProto_ScreenMagnifierType AccessibilitySettingsProto_ScreenMagnifierType_ScreenMagnifierType_MIN = AccessibilitySettingsProto_ScreenMagnifierType_SCREEN_MAGNIFIER_TYPE_NONE;
constexpr AccessibilitySettingsProto_ScreenMagnifierType AccessibilitySettingsProto_ScreenMagnifierType_ScreenMagnifierType_MAX = AccessibilitySettingsProto_ScreenMagnifierType_SCREEN_MAGNIFIER_TYPE_FULL;
constexpr int AccessibilitySettingsProto_ScreenMagnifierType_ScreenMagnifierType_ARRAYSIZE = AccessibilitySettingsProto_ScreenMagnifierType_ScreenMagnifierType_MAX + 1;

const std::string& AccessibilitySettingsProto_ScreenMagnifierType_Name(AccessibilitySettingsProto_ScreenMagnifierType value);
template<typename T>
inline const std::string& AccessibilitySettingsProto_ScreenMagnifierType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccessibilitySettingsProto_ScreenMagnifierType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccessibilitySettingsProto_ScreenMagnifierType_Name.");
  return AccessibilitySettingsProto_ScreenMagnifierType_Name(static_cast<AccessibilitySettingsProto_ScreenMagnifierType>(enum_t_value));
}
bool AccessibilitySettingsProto_ScreenMagnifierType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccessibilitySettingsProto_ScreenMagnifierType* value);
enum DisplayRotationDefaultProto_Rotation : int {
  DisplayRotationDefaultProto_Rotation_ROTATE_0 = 0,
  DisplayRotationDefaultProto_Rotation_ROTATE_90 = 1,
  DisplayRotationDefaultProto_Rotation_ROTATE_180 = 2,
  DisplayRotationDefaultProto_Rotation_ROTATE_270 = 3
};
bool DisplayRotationDefaultProto_Rotation_IsValid(int value);
constexpr DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto_Rotation_Rotation_MIN = DisplayRotationDefaultProto_Rotation_ROTATE_0;
constexpr DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto_Rotation_Rotation_MAX = DisplayRotationDefaultProto_Rotation_ROTATE_270;
constexpr int DisplayRotationDefaultProto_Rotation_Rotation_ARRAYSIZE = DisplayRotationDefaultProto_Rotation_Rotation_MAX + 1;

const std::string& DisplayRotationDefaultProto_Rotation_Name(DisplayRotationDefaultProto_Rotation value);
template<typename T>
inline const std::string& DisplayRotationDefaultProto_Rotation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DisplayRotationDefaultProto_Rotation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DisplayRotationDefaultProto_Rotation_Name.");
  return DisplayRotationDefaultProto_Rotation_Name(static_cast<DisplayRotationDefaultProto_Rotation>(enum_t_value));
}
bool DisplayRotationDefaultProto_Rotation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DisplayRotationDefaultProto_Rotation* value);
enum LoginAuthenticationBehaviorProto_LoginBehavior : int {
  LoginAuthenticationBehaviorProto_LoginBehavior_GAIA = 0,
  LoginAuthenticationBehaviorProto_LoginBehavior_SAML_INTERSTITIAL = 1
};
bool LoginAuthenticationBehaviorProto_LoginBehavior_IsValid(int value);
constexpr LoginAuthenticationBehaviorProto_LoginBehavior LoginAuthenticationBehaviorProto_LoginBehavior_LoginBehavior_MIN = LoginAuthenticationBehaviorProto_LoginBehavior_GAIA;
constexpr LoginAuthenticationBehaviorProto_LoginBehavior LoginAuthenticationBehaviorProto_LoginBehavior_LoginBehavior_MAX = LoginAuthenticationBehaviorProto_LoginBehavior_SAML_INTERSTITIAL;
constexpr int LoginAuthenticationBehaviorProto_LoginBehavior_LoginBehavior_ARRAYSIZE = LoginAuthenticationBehaviorProto_LoginBehavior_LoginBehavior_MAX + 1;

const std::string& LoginAuthenticationBehaviorProto_LoginBehavior_Name(LoginAuthenticationBehaviorProto_LoginBehavior value);
template<typename T>
inline const std::string& LoginAuthenticationBehaviorProto_LoginBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginAuthenticationBehaviorProto_LoginBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginAuthenticationBehaviorProto_LoginBehavior_Name.");
  return LoginAuthenticationBehaviorProto_LoginBehavior_Name(static_cast<LoginAuthenticationBehaviorProto_LoginBehavior>(enum_t_value));
}
bool LoginAuthenticationBehaviorProto_LoginBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginAuthenticationBehaviorProto_LoginBehavior* value);
enum LoginScreenExtensionManifestV2AvailabilityProto_Availability : int {
  LoginScreenExtensionManifestV2AvailabilityProto_Availability_DEFAULT = 0,
  LoginScreenExtensionManifestV2AvailabilityProto_Availability_DISABLE = 1,
  LoginScreenExtensionManifestV2AvailabilityProto_Availability_ENABLE = 2,
  LoginScreenExtensionManifestV2AvailabilityProto_Availability_ENABLE_FOR_FORCED_EXTENSIONS = 3
};
bool LoginScreenExtensionManifestV2AvailabilityProto_Availability_IsValid(int value);
constexpr LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto_Availability_Availability_MIN = LoginScreenExtensionManifestV2AvailabilityProto_Availability_DEFAULT;
constexpr LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto_Availability_Availability_MAX = LoginScreenExtensionManifestV2AvailabilityProto_Availability_ENABLE_FOR_FORCED_EXTENSIONS;
constexpr int LoginScreenExtensionManifestV2AvailabilityProto_Availability_Availability_ARRAYSIZE = LoginScreenExtensionManifestV2AvailabilityProto_Availability_Availability_MAX + 1;

const std::string& LoginScreenExtensionManifestV2AvailabilityProto_Availability_Name(LoginScreenExtensionManifestV2AvailabilityProto_Availability value);
template<typename T>
inline const std::string& LoginScreenExtensionManifestV2AvailabilityProto_Availability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginScreenExtensionManifestV2AvailabilityProto_Availability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginScreenExtensionManifestV2AvailabilityProto_Availability_Name.");
  return LoginScreenExtensionManifestV2AvailabilityProto_Availability_Name(static_cast<LoginScreenExtensionManifestV2AvailabilityProto_Availability>(enum_t_value));
}
bool LoginScreenExtensionManifestV2AvailabilityProto_Availability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginScreenExtensionManifestV2AvailabilityProto_Availability* value);
enum DeviceEcryptfsMigrationStrategyProto_MigrationStrategy : int {
  DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_UNSET = 0,
  DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_DISALLOW_ARC = 1,
  DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_ALLOW_MIGRATION = 2
};
bool DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_IsValid(int value);
constexpr DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_MigrationStrategy_MIN = DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_UNSET;
constexpr DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_MigrationStrategy_MAX = DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_ALLOW_MIGRATION;
constexpr int DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_MigrationStrategy_ARRAYSIZE = DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_MigrationStrategy_MAX + 1;

const std::string& DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Name(DeviceEcryptfsMigrationStrategyProto_MigrationStrategy value);
template<typename T>
inline const std::string& DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceEcryptfsMigrationStrategyProto_MigrationStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Name.");
  return DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Name(static_cast<DeviceEcryptfsMigrationStrategyProto_MigrationStrategy>(enum_t_value));
}
bool DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceEcryptfsMigrationStrategyProto_MigrationStrategy* value);
enum DeviceSecondFactorAuthenticationProto_U2fMode : int {
  DeviceSecondFactorAuthenticationProto_U2fMode_UNSET = 0,
  DeviceSecondFactorAuthenticationProto_U2fMode_DISABLED = 1,
  DeviceSecondFactorAuthenticationProto_U2fMode_U2F = 2,
  DeviceSecondFactorAuthenticationProto_U2fMode_U2F_EXTENDED = 3
};
bool DeviceSecondFactorAuthenticationProto_U2fMode_IsValid(int value);
constexpr DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto_U2fMode_U2fMode_MIN = DeviceSecondFactorAuthenticationProto_U2fMode_UNSET;
constexpr DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto_U2fMode_U2fMode_MAX = DeviceSecondFactorAuthenticationProto_U2fMode_U2F_EXTENDED;
constexpr int DeviceSecondFactorAuthenticationProto_U2fMode_U2fMode_ARRAYSIZE = DeviceSecondFactorAuthenticationProto_U2fMode_U2fMode_MAX + 1;

const std::string& DeviceSecondFactorAuthenticationProto_U2fMode_Name(DeviceSecondFactorAuthenticationProto_U2fMode value);
template<typename T>
inline const std::string& DeviceSecondFactorAuthenticationProto_U2fMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceSecondFactorAuthenticationProto_U2fMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceSecondFactorAuthenticationProto_U2fMode_Name.");
  return DeviceSecondFactorAuthenticationProto_U2fMode_Name(static_cast<DeviceSecondFactorAuthenticationProto_U2fMode>(enum_t_value));
}
bool DeviceSecondFactorAuthenticationProto_U2fMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceSecondFactorAuthenticationProto_U2fMode* value);
enum WeeklyTimeProto_DayOfWeek : int {
  WeeklyTimeProto_DayOfWeek_DAY_OF_WEEK_UNSPECIFIED = 0,
  WeeklyTimeProto_DayOfWeek_MONDAY = 1,
  WeeklyTimeProto_DayOfWeek_TUESDAY = 2,
  WeeklyTimeProto_DayOfWeek_WEDNESDAY = 3,
  WeeklyTimeProto_DayOfWeek_THURSDAY = 4,
  WeeklyTimeProto_DayOfWeek_FRIDAY = 5,
  WeeklyTimeProto_DayOfWeek_SATURDAY = 6,
  WeeklyTimeProto_DayOfWeek_SUNDAY = 7
};
bool WeeklyTimeProto_DayOfWeek_IsValid(int value);
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto_DayOfWeek_DayOfWeek_MIN = WeeklyTimeProto_DayOfWeek_DAY_OF_WEEK_UNSPECIFIED;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto_DayOfWeek_DayOfWeek_MAX = WeeklyTimeProto_DayOfWeek_SUNDAY;
constexpr int WeeklyTimeProto_DayOfWeek_DayOfWeek_ARRAYSIZE = WeeklyTimeProto_DayOfWeek_DayOfWeek_MAX + 1;

const std::string& WeeklyTimeProto_DayOfWeek_Name(WeeklyTimeProto_DayOfWeek value);
template<typename T>
inline const std::string& WeeklyTimeProto_DayOfWeek_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeeklyTimeProto_DayOfWeek>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeeklyTimeProto_DayOfWeek_Name.");
  return WeeklyTimeProto_DayOfWeek_Name(static_cast<WeeklyTimeProto_DayOfWeek>(enum_t_value));
}
bool WeeklyTimeProto_DayOfWeek_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeeklyTimeProto_DayOfWeek* value);
enum DeviceNativePrintersAccessModeProto_AccessMode : int {
  DeviceNativePrintersAccessModeProto_AccessMode_ACCESS_MODE_BLACKLIST = 0,
  DeviceNativePrintersAccessModeProto_AccessMode_ACCESS_MODE_WHITELIST = 1,
  DeviceNativePrintersAccessModeProto_AccessMode_ACCESS_MODE_ALL = 2
};
bool DeviceNativePrintersAccessModeProto_AccessMode_IsValid(int value);
constexpr DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto_AccessMode_AccessMode_MIN = DeviceNativePrintersAccessModeProto_AccessMode_ACCESS_MODE_BLACKLIST;
constexpr DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto_AccessMode_AccessMode_MAX = DeviceNativePrintersAccessModeProto_AccessMode_ACCESS_MODE_ALL;
constexpr int DeviceNativePrintersAccessModeProto_AccessMode_AccessMode_ARRAYSIZE = DeviceNativePrintersAccessModeProto_AccessMode_AccessMode_MAX + 1;

const std::string& DeviceNativePrintersAccessModeProto_AccessMode_Name(DeviceNativePrintersAccessModeProto_AccessMode value);
template<typename T>
inline const std::string& DeviceNativePrintersAccessModeProto_AccessMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceNativePrintersAccessModeProto_AccessMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceNativePrintersAccessModeProto_AccessMode_Name.");
  return DeviceNativePrintersAccessModeProto_AccessMode_Name(static_cast<DeviceNativePrintersAccessModeProto_AccessMode>(enum_t_value));
}
bool DeviceNativePrintersAccessModeProto_AccessMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceNativePrintersAccessModeProto_AccessMode* value);
enum DevicePrintersAccessModeProto_AccessMode : int {
  DevicePrintersAccessModeProto_AccessMode_ACCESS_MODE_BLOCKLIST = 0,
  DevicePrintersAccessModeProto_AccessMode_ACCESS_MODE_ALLOWLIST = 1,
  DevicePrintersAccessModeProto_AccessMode_ACCESS_MODE_ALL = 2
};
bool DevicePrintersAccessModeProto_AccessMode_IsValid(int value);
constexpr DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto_AccessMode_AccessMode_MIN = DevicePrintersAccessModeProto_AccessMode_ACCESS_MODE_BLOCKLIST;
constexpr DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto_AccessMode_AccessMode_MAX = DevicePrintersAccessModeProto_AccessMode_ACCESS_MODE_ALL;
constexpr int DevicePrintersAccessModeProto_AccessMode_AccessMode_ARRAYSIZE = DevicePrintersAccessModeProto_AccessMode_AccessMode_MAX + 1;

const std::string& DevicePrintersAccessModeProto_AccessMode_Name(DevicePrintersAccessModeProto_AccessMode value);
template<typename T>
inline const std::string& DevicePrintersAccessModeProto_AccessMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DevicePrintersAccessModeProto_AccessMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DevicePrintersAccessModeProto_AccessMode_Name.");
  return DevicePrintersAccessModeProto_AccessMode_Name(static_cast<DevicePrintersAccessModeProto_AccessMode>(enum_t_value));
}
bool DevicePrintersAccessModeProto_AccessMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DevicePrintersAccessModeProto_AccessMode* value);
enum TPMFirmwareUpdateSettingsProto_AutoUpdateMode : int {
  TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AUTO_UPDATE_MODE_UNSPECIFIED = 0,
  TPMFirmwareUpdateSettingsProto_AutoUpdateMode_NEVER = 1,
  TPMFirmwareUpdateSettingsProto_AutoUpdateMode_USER_ACKNOWLEDGMENT = 2,
  TPMFirmwareUpdateSettingsProto_AutoUpdateMode_WITHOUT_ACKNOWLEDGMENT = 3,
  TPMFirmwareUpdateSettingsProto_AutoUpdateMode_ENROLLMENT = 4
};
bool TPMFirmwareUpdateSettingsProto_AutoUpdateMode_IsValid(int value);
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AutoUpdateMode_MIN = TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AUTO_UPDATE_MODE_UNSPECIFIED;
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AutoUpdateMode_MAX = TPMFirmwareUpdateSettingsProto_AutoUpdateMode_ENROLLMENT;
constexpr int TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AutoUpdateMode_ARRAYSIZE = TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AutoUpdateMode_MAX + 1;

const std::string& TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Name(TPMFirmwareUpdateSettingsProto_AutoUpdateMode value);
template<typename T>
inline const std::string& TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TPMFirmwareUpdateSettingsProto_AutoUpdateMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Name.");
  return TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Name(static_cast<TPMFirmwareUpdateSettingsProto_AutoUpdateMode>(enum_t_value));
}
bool TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TPMFirmwareUpdateSettingsProto_AutoUpdateMode* value);
enum DeviceKerberosEncryptionTypesProto_Types : int {
  DeviceKerberosEncryptionTypesProto_Types_ENC_TYPES_ALL = 0,
  DeviceKerberosEncryptionTypesProto_Types_ENC_TYPES_STRONG = 1,
  DeviceKerberosEncryptionTypesProto_Types_ENC_TYPES_LEGACY = 2
};
bool DeviceKerberosEncryptionTypesProto_Types_IsValid(int value);
constexpr DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto_Types_Types_MIN = DeviceKerberosEncryptionTypesProto_Types_ENC_TYPES_ALL;
constexpr DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto_Types_Types_MAX = DeviceKerberosEncryptionTypesProto_Types_ENC_TYPES_LEGACY;
constexpr int DeviceKerberosEncryptionTypesProto_Types_Types_ARRAYSIZE = DeviceKerberosEncryptionTypesProto_Types_Types_MAX + 1;

const std::string& DeviceKerberosEncryptionTypesProto_Types_Name(DeviceKerberosEncryptionTypesProto_Types value);
template<typename T>
inline const std::string& DeviceKerberosEncryptionTypesProto_Types_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceKerberosEncryptionTypesProto_Types>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceKerberosEncryptionTypesProto_Types_Name.");
  return DeviceKerberosEncryptionTypesProto_Types_Name(static_cast<DeviceKerberosEncryptionTypesProto_Types>(enum_t_value));
}
bool DeviceKerberosEncryptionTypesProto_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceKerberosEncryptionTypesProto_Types* value);
enum KeyboardBacklightColorProto_BacklightColor : int {
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_UNSPECIFIED = 0,
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_WHITE = 1,
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_RED = 2,
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_YELLOW = 3,
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_GREEN = 4,
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_BLUE = 5,
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_INDIGO = 6,
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_PURPLE = 7,
  KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_RAINBOW = 100
};
bool KeyboardBacklightColorProto_BacklightColor_IsValid(int value);
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto_BacklightColor_BacklightColor_MIN = KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_UNSPECIFIED;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto_BacklightColor_BacklightColor_MAX = KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_RAINBOW;
constexpr int KeyboardBacklightColorProto_BacklightColor_BacklightColor_ARRAYSIZE = KeyboardBacklightColorProto_BacklightColor_BacklightColor_MAX + 1;

const std::string& KeyboardBacklightColorProto_BacklightColor_Name(KeyboardBacklightColorProto_BacklightColor value);
template<typename T>
inline const std::string& KeyboardBacklightColorProto_BacklightColor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyboardBacklightColorProto_BacklightColor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyboardBacklightColorProto_BacklightColor_Name.");
  return KeyboardBacklightColorProto_BacklightColor_Name(static_cast<KeyboardBacklightColorProto_BacklightColor>(enum_t_value));
}
bool KeyboardBacklightColorProto_BacklightColor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyboardBacklightColorProto_BacklightColor* value);
enum DeviceUserPolicyLoopbackProcessingModeProto_Mode : int {
  DeviceUserPolicyLoopbackProcessingModeProto_Mode_USER_POLICY_MODE_DEFAULT = 0,
  DeviceUserPolicyLoopbackProcessingModeProto_Mode_USER_POLICY_MODE_MERGE = 1,
  DeviceUserPolicyLoopbackProcessingModeProto_Mode_USER_POLICY_MODE_REPLACE = 2
};
bool DeviceUserPolicyLoopbackProcessingModeProto_Mode_IsValid(int value);
constexpr DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto_Mode_Mode_MIN = DeviceUserPolicyLoopbackProcessingModeProto_Mode_USER_POLICY_MODE_DEFAULT;
constexpr DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto_Mode_Mode_MAX = DeviceUserPolicyLoopbackProcessingModeProto_Mode_USER_POLICY_MODE_REPLACE;
constexpr int DeviceUserPolicyLoopbackProcessingModeProto_Mode_Mode_ARRAYSIZE = DeviceUserPolicyLoopbackProcessingModeProto_Mode_Mode_MAX + 1;

const std::string& DeviceUserPolicyLoopbackProcessingModeProto_Mode_Name(DeviceUserPolicyLoopbackProcessingModeProto_Mode value);
template<typename T>
inline const std::string& DeviceUserPolicyLoopbackProcessingModeProto_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceUserPolicyLoopbackProcessingModeProto_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceUserPolicyLoopbackProcessingModeProto_Mode_Name.");
  return DeviceUserPolicyLoopbackProcessingModeProto_Mode_Name(static_cast<DeviceUserPolicyLoopbackProcessingModeProto_Mode>(enum_t_value));
}
bool DeviceUserPolicyLoopbackProcessingModeProto_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceUserPolicyLoopbackProcessingModeProto_Mode* value);
enum DeviceRebootOnUserSignoutProto_RebootOnSignoutMode : int {
  DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_REBOOT_ON_SIGNOUT_MODE_UNSPECIFIED = 0,
  DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_NEVER = 1,
  DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_ARC_SESSION = 2,
  DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_ALWAYS = 3,
  DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_VM_STARTED_OR_ARC_SESSION = 4
};
bool DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_IsValid(int value);
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_RebootOnSignoutMode_MIN = DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_REBOOT_ON_SIGNOUT_MODE_UNSPECIFIED;
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_RebootOnSignoutMode_MAX = DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_VM_STARTED_OR_ARC_SESSION;
constexpr int DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_RebootOnSignoutMode_ARRAYSIZE = DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_RebootOnSignoutMode_MAX + 1;

const std::string& DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Name(DeviceRebootOnUserSignoutProto_RebootOnSignoutMode value);
template<typename T>
inline const std::string& DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceRebootOnUserSignoutProto_RebootOnSignoutMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Name.");
  return DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Name(static_cast<DeviceRebootOnUserSignoutProto_RebootOnSignoutMode>(enum_t_value));
}
bool DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRebootOnUserSignoutProto_RebootOnSignoutMode* value);
enum DeviceDockMacAddressSourceProto_Source : int {
  DeviceDockMacAddressSourceProto_Source_SOURCE_UNSPECIFIED = 0,
  DeviceDockMacAddressSourceProto_Source_DEVICE_DOCK_MAC_ADDRESS = 1,
  DeviceDockMacAddressSourceProto_Source_DEVICE_NIC_MAC_ADDRESS = 2,
  DeviceDockMacAddressSourceProto_Source_DOCK_NIC_MAC_ADDRESS = 3
};
bool DeviceDockMacAddressSourceProto_Source_IsValid(int value);
constexpr DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto_Source_Source_MIN = DeviceDockMacAddressSourceProto_Source_SOURCE_UNSPECIFIED;
constexpr DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto_Source_Source_MAX = DeviceDockMacAddressSourceProto_Source_DOCK_NIC_MAC_ADDRESS;
constexpr int DeviceDockMacAddressSourceProto_Source_Source_ARRAYSIZE = DeviceDockMacAddressSourceProto_Source_Source_MAX + 1;

const std::string& DeviceDockMacAddressSourceProto_Source_Name(DeviceDockMacAddressSourceProto_Source value);
template<typename T>
inline const std::string& DeviceDockMacAddressSourceProto_Source_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceDockMacAddressSourceProto_Source>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceDockMacAddressSourceProto_Source_Name.");
  return DeviceDockMacAddressSourceProto_Source_Name(static_cast<DeviceDockMacAddressSourceProto_Source>(enum_t_value));
}
bool DeviceDockMacAddressSourceProto_Source_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceDockMacAddressSourceProto_Source* value);
enum DeviceBatteryChargeModeProto_BatteryChargeMode : int {
  DeviceBatteryChargeModeProto_BatteryChargeMode_MODE_UNSPECIFIED = 0,
  DeviceBatteryChargeModeProto_BatteryChargeMode_STANDARD = 1,
  DeviceBatteryChargeModeProto_BatteryChargeMode_EXPRESS_CHARGE = 2,
  DeviceBatteryChargeModeProto_BatteryChargeMode_PRIMARILY_AC_USE = 3,
  DeviceBatteryChargeModeProto_BatteryChargeMode_ADAPTIVE = 4,
  DeviceBatteryChargeModeProto_BatteryChargeMode_CUSTOM = 5
};
bool DeviceBatteryChargeModeProto_BatteryChargeMode_IsValid(int value);
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto_BatteryChargeMode_BatteryChargeMode_MIN = DeviceBatteryChargeModeProto_BatteryChargeMode_MODE_UNSPECIFIED;
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto_BatteryChargeMode_BatteryChargeMode_MAX = DeviceBatteryChargeModeProto_BatteryChargeMode_CUSTOM;
constexpr int DeviceBatteryChargeModeProto_BatteryChargeMode_BatteryChargeMode_ARRAYSIZE = DeviceBatteryChargeModeProto_BatteryChargeMode_BatteryChargeMode_MAX + 1;

const std::string& DeviceBatteryChargeModeProto_BatteryChargeMode_Name(DeviceBatteryChargeModeProto_BatteryChargeMode value);
template<typename T>
inline const std::string& DeviceBatteryChargeModeProto_BatteryChargeMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceBatteryChargeModeProto_BatteryChargeMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceBatteryChargeModeProto_BatteryChargeMode_Name.");
  return DeviceBatteryChargeModeProto_BatteryChargeMode_Name(static_cast<DeviceBatteryChargeModeProto_BatteryChargeMode>(enum_t_value));
}
bool DeviceBatteryChargeModeProto_BatteryChargeMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceBatteryChargeModeProto_BatteryChargeMode* value);
enum DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode : int {
  DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_DISALLOW = 0,
  DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_DISALLOW_WITH_POWERWASH = 1,
  DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_ALLOW_FOR_AFFILIATED_USERS = 2
};
bool DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_IsValid(int value);
constexpr DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_AllowanceMode_MIN = DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_DISALLOW;
constexpr DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_AllowanceMode_MAX = DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_ALLOW_FOR_AFFILIATED_USERS;
constexpr int DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_AllowanceMode_ARRAYSIZE = DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_AllowanceMode_MAX + 1;

const std::string& DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Name(DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode value);
template<typename T>
inline const std::string& DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Name.");
  return DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Name(static_cast<DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode>(enum_t_value));
}
bool DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode* value);
// ===================================================================

class DevicePolicyRefreshRateProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePolicyRefreshRateProto) */ {
 public:
  inline DevicePolicyRefreshRateProto() : DevicePolicyRefreshRateProto(nullptr) {}
  ~DevicePolicyRefreshRateProto() override;
  explicit PROTOBUF_CONSTEXPR DevicePolicyRefreshRateProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePolicyRefreshRateProto(const DevicePolicyRefreshRateProto& from);
  DevicePolicyRefreshRateProto(DevicePolicyRefreshRateProto&& from) noexcept
    : DevicePolicyRefreshRateProto() {
    *this = ::std::move(from);
  }

  inline DevicePolicyRefreshRateProto& operator=(const DevicePolicyRefreshRateProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePolicyRefreshRateProto& operator=(DevicePolicyRefreshRateProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePolicyRefreshRateProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePolicyRefreshRateProto* internal_default_instance() {
    return reinterpret_cast<const DevicePolicyRefreshRateProto*>(
               &_DevicePolicyRefreshRateProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DevicePolicyRefreshRateProto& a, DevicePolicyRefreshRateProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePolicyRefreshRateProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePolicyRefreshRateProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePolicyRefreshRateProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePolicyRefreshRateProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePolicyRefreshRateProto& from);
  void MergeFrom(const DevicePolicyRefreshRateProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePolicyRefreshRateProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePolicyRefreshRateProto";
  }
  protected:
  explicit DevicePolicyRefreshRateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePolicyRefreshRateFieldNumber = 1,
  };
  // optional int64 device_policy_refresh_rate = 1;
  bool has_device_policy_refresh_rate() const;
  private:
  bool _internal_has_device_policy_refresh_rate() const;
  public:
  void clear_device_policy_refresh_rate();
  int64_t device_policy_refresh_rate() const;
  void set_device_policy_refresh_rate(int64_t value);
  private:
  int64_t _internal_device_policy_refresh_rate() const;
  void _internal_set_device_policy_refresh_rate(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePolicyRefreshRateProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t device_policy_refresh_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class UserWhitelistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UserWhitelistProto) */ {
 public:
  inline UserWhitelistProto() : UserWhitelistProto(nullptr) {}
  ~UserWhitelistProto() override;
  explicit PROTOBUF_CONSTEXPR UserWhitelistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserWhitelistProto(const UserWhitelistProto& from);
  UserWhitelistProto(UserWhitelistProto&& from) noexcept
    : UserWhitelistProto() {
    *this = ::std::move(from);
  }

  inline UserWhitelistProto& operator=(const UserWhitelistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserWhitelistProto& operator=(UserWhitelistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserWhitelistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserWhitelistProto* internal_default_instance() {
    return reinterpret_cast<const UserWhitelistProto*>(
               &_UserWhitelistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserWhitelistProto& a, UserWhitelistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UserWhitelistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserWhitelistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserWhitelistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserWhitelistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserWhitelistProto& from);
  void MergeFrom(const UserWhitelistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserWhitelistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UserWhitelistProto";
  }
  protected:
  explicit UserWhitelistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserWhitelistFieldNumber = 1,
  };
  // repeated string user_whitelist = 1;
  int user_whitelist_size() const;
  private:
  int _internal_user_whitelist_size() const;
  public:
  void clear_user_whitelist();
  const std::string& user_whitelist(int index) const;
  std::string* mutable_user_whitelist(int index);
  void set_user_whitelist(int index, const std::string& value);
  void set_user_whitelist(int index, std::string&& value);
  void set_user_whitelist(int index, const char* value);
  void set_user_whitelist(int index, const char* value, size_t size);
  std::string* add_user_whitelist();
  void add_user_whitelist(const std::string& value);
  void add_user_whitelist(std::string&& value);
  void add_user_whitelist(const char* value);
  void add_user_whitelist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_whitelist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_whitelist();
  private:
  const std::string& _internal_user_whitelist(int index) const;
  std::string* _internal_add_user_whitelist();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.UserWhitelistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_whitelist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class UserAllowlistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UserAllowlistProto) */ {
 public:
  inline UserAllowlistProto() : UserAllowlistProto(nullptr) {}
  ~UserAllowlistProto() override;
  explicit PROTOBUF_CONSTEXPR UserAllowlistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAllowlistProto(const UserAllowlistProto& from);
  UserAllowlistProto(UserAllowlistProto&& from) noexcept
    : UserAllowlistProto() {
    *this = ::std::move(from);
  }

  inline UserAllowlistProto& operator=(const UserAllowlistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAllowlistProto& operator=(UserAllowlistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserAllowlistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAllowlistProto* internal_default_instance() {
    return reinterpret_cast<const UserAllowlistProto*>(
               &_UserAllowlistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserAllowlistProto& a, UserAllowlistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAllowlistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAllowlistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAllowlistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAllowlistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserAllowlistProto& from);
  void MergeFrom(const UserAllowlistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserAllowlistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UserAllowlistProto";
  }
  protected:
  explicit UserAllowlistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserAllowlistFieldNumber = 1,
  };
  // repeated string user_allowlist = 1;
  int user_allowlist_size() const;
  private:
  int _internal_user_allowlist_size() const;
  public:
  void clear_user_allowlist();
  const std::string& user_allowlist(int index) const;
  std::string* mutable_user_allowlist(int index);
  void set_user_allowlist(int index, const std::string& value);
  void set_user_allowlist(int index, std::string&& value);
  void set_user_allowlist(int index, const char* value);
  void set_user_allowlist(int index, const char* value, size_t size);
  std::string* add_user_allowlist();
  void add_user_allowlist(const std::string& value);
  void add_user_allowlist(std::string&& value);
  void add_user_allowlist(const char* value);
  void add_user_allowlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_allowlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_allowlist();
  private:
  const std::string& _internal_user_allowlist(int index) const;
  std::string* _internal_add_user_allowlist();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.UserAllowlistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_allowlist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AllowNewUsersProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AllowNewUsersProto) */ {
 public:
  inline AllowNewUsersProto() : AllowNewUsersProto(nullptr) {}
  ~AllowNewUsersProto() override;
  explicit PROTOBUF_CONSTEXPR AllowNewUsersProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowNewUsersProto(const AllowNewUsersProto& from);
  AllowNewUsersProto(AllowNewUsersProto&& from) noexcept
    : AllowNewUsersProto() {
    *this = ::std::move(from);
  }

  inline AllowNewUsersProto& operator=(const AllowNewUsersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowNewUsersProto& operator=(AllowNewUsersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AllowNewUsersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowNewUsersProto* internal_default_instance() {
    return reinterpret_cast<const AllowNewUsersProto*>(
               &_AllowNewUsersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AllowNewUsersProto& a, AllowNewUsersProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowNewUsersProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowNewUsersProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowNewUsersProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllowNewUsersProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AllowNewUsersProto& from);
  void MergeFrom(const AllowNewUsersProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllowNewUsersProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AllowNewUsersProto";
  }
  protected:
  explicit AllowNewUsersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowNewUsersFieldNumber = 1,
  };
  // optional bool allow_new_users = 1 [default = true];
  bool has_allow_new_users() const;
  private:
  bool _internal_has_allow_new_users() const;
  public:
  void clear_allow_new_users();
  bool allow_new_users() const;
  void set_allow_new_users(bool value);
  private:
  bool _internal_allow_new_users() const;
  void _internal_set_allow_new_users(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AllowNewUsersProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool allow_new_users_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class GuestModeEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GuestModeEnabledProto) */ {
 public:
  inline GuestModeEnabledProto() : GuestModeEnabledProto(nullptr) {}
  ~GuestModeEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR GuestModeEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuestModeEnabledProto(const GuestModeEnabledProto& from);
  GuestModeEnabledProto(GuestModeEnabledProto&& from) noexcept
    : GuestModeEnabledProto() {
    *this = ::std::move(from);
  }

  inline GuestModeEnabledProto& operator=(const GuestModeEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuestModeEnabledProto& operator=(GuestModeEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GuestModeEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuestModeEnabledProto* internal_default_instance() {
    return reinterpret_cast<const GuestModeEnabledProto*>(
               &_GuestModeEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GuestModeEnabledProto& a, GuestModeEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GuestModeEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuestModeEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuestModeEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuestModeEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GuestModeEnabledProto& from);
  void MergeFrom(const GuestModeEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GuestModeEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.GuestModeEnabledProto";
  }
  protected:
  explicit GuestModeEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuestModeEnabledFieldNumber = 1,
  };
  // optional bool guest_mode_enabled = 1 [default = true];
  bool has_guest_mode_enabled() const;
  private:
  bool _internal_has_guest_mode_enabled() const;
  public:
  void clear_guest_mode_enabled();
  bool guest_mode_enabled() const;
  void set_guest_mode_enabled(bool value);
  private:
  bool _internal_guest_mode_enabled() const;
  void _internal_set_guest_mode_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.GuestModeEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool guest_mode_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class ShowUserNamesOnSigninProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ShowUserNamesOnSigninProto) */ {
 public:
  inline ShowUserNamesOnSigninProto() : ShowUserNamesOnSigninProto(nullptr) {}
  ~ShowUserNamesOnSigninProto() override;
  explicit PROTOBUF_CONSTEXPR ShowUserNamesOnSigninProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowUserNamesOnSigninProto(const ShowUserNamesOnSigninProto& from);
  ShowUserNamesOnSigninProto(ShowUserNamesOnSigninProto&& from) noexcept
    : ShowUserNamesOnSigninProto() {
    *this = ::std::move(from);
  }

  inline ShowUserNamesOnSigninProto& operator=(const ShowUserNamesOnSigninProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowUserNamesOnSigninProto& operator=(ShowUserNamesOnSigninProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowUserNamesOnSigninProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowUserNamesOnSigninProto* internal_default_instance() {
    return reinterpret_cast<const ShowUserNamesOnSigninProto*>(
               &_ShowUserNamesOnSigninProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ShowUserNamesOnSigninProto& a, ShowUserNamesOnSigninProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowUserNamesOnSigninProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowUserNamesOnSigninProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowUserNamesOnSigninProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowUserNamesOnSigninProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowUserNamesOnSigninProto& from);
  void MergeFrom(const ShowUserNamesOnSigninProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowUserNamesOnSigninProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ShowUserNamesOnSigninProto";
  }
  protected:
  explicit ShowUserNamesOnSigninProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShowUserNamesFieldNumber = 1,
  };
  // optional bool show_user_names = 1 [default = true];
  bool has_show_user_names() const;
  private:
  bool _internal_has_show_user_names() const;
  public:
  void clear_show_user_names();
  bool show_user_names() const;
  void set_show_user_names(bool value);
  private:
  bool _internal_show_user_names() const;
  void _internal_set_show_user_names(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ShowUserNamesOnSigninProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool show_user_names_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DataRoamingEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DataRoamingEnabledProto) */ {
 public:
  inline DataRoamingEnabledProto() : DataRoamingEnabledProto(nullptr) {}
  ~DataRoamingEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DataRoamingEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataRoamingEnabledProto(const DataRoamingEnabledProto& from);
  DataRoamingEnabledProto(DataRoamingEnabledProto&& from) noexcept
    : DataRoamingEnabledProto() {
    *this = ::std::move(from);
  }

  inline DataRoamingEnabledProto& operator=(const DataRoamingEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataRoamingEnabledProto& operator=(DataRoamingEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataRoamingEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataRoamingEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DataRoamingEnabledProto*>(
               &_DataRoamingEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataRoamingEnabledProto& a, DataRoamingEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DataRoamingEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataRoamingEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataRoamingEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataRoamingEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataRoamingEnabledProto& from);
  void MergeFrom(const DataRoamingEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataRoamingEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DataRoamingEnabledProto";
  }
  protected:
  explicit DataRoamingEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataRoamingEnabledFieldNumber = 1,
  };
  // optional bool data_roaming_enabled = 1 [default = false];
  bool has_data_roaming_enabled() const;
  private:
  bool _internal_has_data_roaming_enabled() const;
  public:
  void clear_data_roaming_enabled();
  bool data_roaming_enabled() const;
  void set_data_roaming_enabled(bool value);
  private:
  bool _internal_data_roaming_enabled() const;
  void _internal_set_data_roaming_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DataRoamingEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool data_roaming_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_DeviceProxySettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_DeviceProxySettingsProto) */ {
 public:
  inline OBSOLETE_DeviceProxySettingsProto() : OBSOLETE_DeviceProxySettingsProto(nullptr) {}
  ~OBSOLETE_DeviceProxySettingsProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_DeviceProxySettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_DeviceProxySettingsProto(const OBSOLETE_DeviceProxySettingsProto& from);
  OBSOLETE_DeviceProxySettingsProto(OBSOLETE_DeviceProxySettingsProto&& from) noexcept
    : OBSOLETE_DeviceProxySettingsProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_DeviceProxySettingsProto& operator=(const OBSOLETE_DeviceProxySettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_DeviceProxySettingsProto& operator=(OBSOLETE_DeviceProxySettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_DeviceProxySettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_DeviceProxySettingsProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_DeviceProxySettingsProto*>(
               &_OBSOLETE_DeviceProxySettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OBSOLETE_DeviceProxySettingsProto& a, OBSOLETE_DeviceProxySettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_DeviceProxySettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_DeviceProxySettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_DeviceProxySettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_DeviceProxySettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_DeviceProxySettingsProto& from);
  void MergeFrom(const OBSOLETE_DeviceProxySettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_DeviceProxySettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_DeviceProxySettingsProto";
  }
  protected:
  explicit OBSOLETE_DeviceProxySettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEProxyModeFieldNumber = 1,
    kOBSOLETEProxyServerFieldNumber = 2,
    kOBSOLETEProxyPacUrlFieldNumber = 3,
    kOBSOLETEProxyBypassListFieldNumber = 4,
  };
  // optional string OBSOLETE_proxy_mode = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_proxy_mode() const;
  private:
  bool _internal_has_obsolete_proxy_mode() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_proxy_mode();
  PROTOBUF_DEPRECATED const std::string& obsolete_proxy_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_proxy_mode(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_proxy_mode();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_proxy_mode();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_proxy_mode(std::string* obsolete_proxy_mode);
  private:
  const std::string& _internal_obsolete_proxy_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_proxy_mode(const std::string& value);
  std::string* _internal_mutable_obsolete_proxy_mode();
  public:

  // optional string OBSOLETE_proxy_server = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_proxy_server() const;
  private:
  bool _internal_has_obsolete_proxy_server() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_proxy_server();
  PROTOBUF_DEPRECATED const std::string& obsolete_proxy_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_proxy_server(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_proxy_server();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_proxy_server();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_proxy_server(std::string* obsolete_proxy_server);
  private:
  const std::string& _internal_obsolete_proxy_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_proxy_server(const std::string& value);
  std::string* _internal_mutable_obsolete_proxy_server();
  public:

  // optional string OBSOLETE_proxy_pac_url = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_proxy_pac_url() const;
  private:
  bool _internal_has_obsolete_proxy_pac_url() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_proxy_pac_url();
  PROTOBUF_DEPRECATED const std::string& obsolete_proxy_pac_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_proxy_pac_url(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_proxy_pac_url();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_proxy_pac_url();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_proxy_pac_url(std::string* obsolete_proxy_pac_url);
  private:
  const std::string& _internal_obsolete_proxy_pac_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_proxy_pac_url(const std::string& value);
  std::string* _internal_mutable_obsolete_proxy_pac_url();
  public:

  // optional string OBSOLETE_proxy_bypass_list = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_proxy_bypass_list() const;
  private:
  bool _internal_has_obsolete_proxy_bypass_list() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_proxy_bypass_list();
  PROTOBUF_DEPRECATED const std::string& obsolete_proxy_bypass_list() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_proxy_bypass_list(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_proxy_bypass_list();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_proxy_bypass_list();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_proxy_bypass_list(std::string* obsolete_proxy_bypass_list);
  private:
  const std::string& _internal_obsolete_proxy_bypass_list() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_proxy_bypass_list(const std::string& value);
  std::string* _internal_mutable_obsolete_proxy_bypass_list();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_proxy_mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_proxy_server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_proxy_pac_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_proxy_bypass_list_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class CameraEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CameraEnabledProto) */ {
 public:
  inline CameraEnabledProto() : CameraEnabledProto(nullptr) {}
  ~CameraEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR CameraEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraEnabledProto(const CameraEnabledProto& from);
  CameraEnabledProto(CameraEnabledProto&& from) noexcept
    : CameraEnabledProto() {
    *this = ::std::move(from);
  }

  inline CameraEnabledProto& operator=(const CameraEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraEnabledProto& operator=(CameraEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CameraEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraEnabledProto* internal_default_instance() {
    return reinterpret_cast<const CameraEnabledProto*>(
               &_CameraEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CameraEnabledProto& a, CameraEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CameraEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CameraEnabledProto& from);
  void MergeFrom(const CameraEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CameraEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CameraEnabledProto";
  }
  protected:
  explicit CameraEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraEnabledFieldNumber = 1,
  };
  // optional bool camera_enabled = 1;
  bool has_camera_enabled() const;
  private:
  bool _internal_has_camera_enabled() const;
  public:
  void clear_camera_enabled();
  bool camera_enabled() const;
  void set_camera_enabled(bool value);
  private:
  bool _internal_camera_enabled() const;
  void _internal_set_camera_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CameraEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool camera_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class MetricsEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.MetricsEnabledProto) */ {
 public:
  inline MetricsEnabledProto() : MetricsEnabledProto(nullptr) {}
  ~MetricsEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR MetricsEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsEnabledProto(const MetricsEnabledProto& from);
  MetricsEnabledProto(MetricsEnabledProto&& from) noexcept
    : MetricsEnabledProto() {
    *this = ::std::move(from);
  }

  inline MetricsEnabledProto& operator=(const MetricsEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsEnabledProto& operator=(MetricsEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MetricsEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsEnabledProto* internal_default_instance() {
    return reinterpret_cast<const MetricsEnabledProto*>(
               &_MetricsEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MetricsEnabledProto& a, MetricsEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MetricsEnabledProto& from);
  void MergeFrom(const MetricsEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetricsEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.MetricsEnabledProto";
  }
  protected:
  explicit MetricsEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsEnabledFieldNumber = 1,
  };
  // optional bool metrics_enabled = 1;
  bool has_metrics_enabled() const;
  private:
  bool _internal_has_metrics_enabled() const;
  public:
  void clear_metrics_enabled();
  bool metrics_enabled() const;
  void set_metrics_enabled(bool value);
  private:
  bool _internal_metrics_enabled() const;
  void _internal_set_metrics_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.MetricsEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool metrics_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class ReleaseChannelProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ReleaseChannelProto) */ {
 public:
  inline ReleaseChannelProto() : ReleaseChannelProto(nullptr) {}
  ~ReleaseChannelProto() override;
  explicit PROTOBUF_CONSTEXPR ReleaseChannelProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReleaseChannelProto(const ReleaseChannelProto& from);
  ReleaseChannelProto(ReleaseChannelProto&& from) noexcept
    : ReleaseChannelProto() {
    *this = ::std::move(from);
  }

  inline ReleaseChannelProto& operator=(const ReleaseChannelProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseChannelProto& operator=(ReleaseChannelProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReleaseChannelProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseChannelProto* internal_default_instance() {
    return reinterpret_cast<const ReleaseChannelProto*>(
               &_ReleaseChannelProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReleaseChannelProto& a, ReleaseChannelProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseChannelProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseChannelProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseChannelProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReleaseChannelProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReleaseChannelProto& from);
  void MergeFrom(const ReleaseChannelProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReleaseChannelProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ReleaseChannelProto";
  }
  protected:
  explicit ReleaseChannelProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReleaseChannelFieldNumber = 1,
    kReleaseLtsTagFieldNumber = 3,
    kReleaseChannelDelegatedFieldNumber = 2,
  };
  // optional string release_channel = 1;
  bool has_release_channel() const;
  private:
  bool _internal_has_release_channel() const;
  public:
  void clear_release_channel();
  const std::string& release_channel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_release_channel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_release_channel();
  PROTOBUF_NODISCARD std::string* release_release_channel();
  void set_allocated_release_channel(std::string* release_channel);
  private:
  const std::string& _internal_release_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_release_channel(const std::string& value);
  std::string* _internal_mutable_release_channel();
  public:

  // optional string release_lts_tag = 3;
  bool has_release_lts_tag() const;
  private:
  bool _internal_has_release_lts_tag() const;
  public:
  void clear_release_lts_tag();
  const std::string& release_lts_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_release_lts_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_release_lts_tag();
  PROTOBUF_NODISCARD std::string* release_release_lts_tag();
  void set_allocated_release_lts_tag(std::string* release_lts_tag);
  private:
  const std::string& _internal_release_lts_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_release_lts_tag(const std::string& value);
  std::string* _internal_mutable_release_lts_tag();
  public:

  // optional bool release_channel_delegated = 2;
  bool has_release_channel_delegated() const;
  private:
  bool _internal_has_release_channel_delegated() const;
  public:
  void clear_release_channel_delegated();
  bool release_channel_delegated() const;
  void set_release_channel_delegated(bool value);
  private:
  bool _internal_release_channel_delegated() const;
  void _internal_set_release_channel_delegated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ReleaseChannelProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr release_channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr release_lts_tag_;
    bool release_channel_delegated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceOpenNetworkConfigurationProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceOpenNetworkConfigurationProto) */ {
 public:
  inline DeviceOpenNetworkConfigurationProto() : DeviceOpenNetworkConfigurationProto(nullptr) {}
  ~DeviceOpenNetworkConfigurationProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceOpenNetworkConfigurationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceOpenNetworkConfigurationProto(const DeviceOpenNetworkConfigurationProto& from);
  DeviceOpenNetworkConfigurationProto(DeviceOpenNetworkConfigurationProto&& from) noexcept
    : DeviceOpenNetworkConfigurationProto() {
    *this = ::std::move(from);
  }

  inline DeviceOpenNetworkConfigurationProto& operator=(const DeviceOpenNetworkConfigurationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceOpenNetworkConfigurationProto& operator=(DeviceOpenNetworkConfigurationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceOpenNetworkConfigurationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceOpenNetworkConfigurationProto* internal_default_instance() {
    return reinterpret_cast<const DeviceOpenNetworkConfigurationProto*>(
               &_DeviceOpenNetworkConfigurationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeviceOpenNetworkConfigurationProto& a, DeviceOpenNetworkConfigurationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceOpenNetworkConfigurationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceOpenNetworkConfigurationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceOpenNetworkConfigurationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceOpenNetworkConfigurationProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceOpenNetworkConfigurationProto& from);
  void MergeFrom(const DeviceOpenNetworkConfigurationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceOpenNetworkConfigurationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceOpenNetworkConfigurationProto";
  }
  protected:
  explicit DeviceOpenNetworkConfigurationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenNetworkConfigurationFieldNumber = 1,
  };
  // optional string open_network_configuration = 1;
  bool has_open_network_configuration() const;
  private:
  bool _internal_has_open_network_configuration() const;
  public:
  void clear_open_network_configuration();
  const std::string& open_network_configuration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_open_network_configuration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_open_network_configuration();
  PROTOBUF_NODISCARD std::string* release_open_network_configuration();
  void set_allocated_open_network_configuration(std::string* open_network_configuration);
  private:
  const std::string& _internal_open_network_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_open_network_configuration(const std::string& value);
  std::string* _internal_mutable_open_network_configuration();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceOpenNetworkConfigurationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr open_network_configuration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class NetworkHostnameProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.NetworkHostnameProto) */ {
 public:
  inline NetworkHostnameProto() : NetworkHostnameProto(nullptr) {}
  ~NetworkHostnameProto() override;
  explicit PROTOBUF_CONSTEXPR NetworkHostnameProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkHostnameProto(const NetworkHostnameProto& from);
  NetworkHostnameProto(NetworkHostnameProto&& from) noexcept
    : NetworkHostnameProto() {
    *this = ::std::move(from);
  }

  inline NetworkHostnameProto& operator=(const NetworkHostnameProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkHostnameProto& operator=(NetworkHostnameProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NetworkHostnameProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkHostnameProto* internal_default_instance() {
    return reinterpret_cast<const NetworkHostnameProto*>(
               &_NetworkHostnameProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NetworkHostnameProto& a, NetworkHostnameProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkHostnameProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkHostnameProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkHostnameProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkHostnameProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkHostnameProto& from);
  void MergeFrom(const NetworkHostnameProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkHostnameProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.NetworkHostnameProto";
  }
  protected:
  explicit NetworkHostnameProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceHostnameTemplateFieldNumber = 1,
  };
  // optional string device_hostname_template = 1;
  bool has_device_hostname_template() const;
  private:
  bool _internal_has_device_hostname_template() const;
  public:
  void clear_device_hostname_template();
  const std::string& device_hostname_template() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_hostname_template(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_hostname_template();
  PROTOBUF_NODISCARD std::string* release_device_hostname_template();
  void set_allocated_device_hostname_template(std::string* device_hostname_template);
  private:
  const std::string& _internal_device_hostname_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_hostname_template(const std::string& value);
  std::string* _internal_mutable_device_hostname_template();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.NetworkHostnameProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_hostname_template_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceHindiInscriptLayoutEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceHindiInscriptLayoutEnabledProto) */ {
 public:
  inline DeviceHindiInscriptLayoutEnabledProto() : DeviceHindiInscriptLayoutEnabledProto(nullptr) {}
  ~DeviceHindiInscriptLayoutEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceHindiInscriptLayoutEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceHindiInscriptLayoutEnabledProto(const DeviceHindiInscriptLayoutEnabledProto& from);
  DeviceHindiInscriptLayoutEnabledProto(DeviceHindiInscriptLayoutEnabledProto&& from) noexcept
    : DeviceHindiInscriptLayoutEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceHindiInscriptLayoutEnabledProto& operator=(const DeviceHindiInscriptLayoutEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceHindiInscriptLayoutEnabledProto& operator=(DeviceHindiInscriptLayoutEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceHindiInscriptLayoutEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceHindiInscriptLayoutEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceHindiInscriptLayoutEnabledProto*>(
               &_DeviceHindiInscriptLayoutEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeviceHindiInscriptLayoutEnabledProto& a, DeviceHindiInscriptLayoutEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceHindiInscriptLayoutEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceHindiInscriptLayoutEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceHindiInscriptLayoutEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceHindiInscriptLayoutEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceHindiInscriptLayoutEnabledProto& from);
  void MergeFrom(const DeviceHindiInscriptLayoutEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceHindiInscriptLayoutEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceHindiInscriptLayoutEnabledProto";
  }
  protected:
  explicit DeviceHindiInscriptLayoutEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class HostnameUserConfigurableProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.HostnameUserConfigurableProto) */ {
 public:
  inline HostnameUserConfigurableProto() : HostnameUserConfigurableProto(nullptr) {}
  ~HostnameUserConfigurableProto() override;
  explicit PROTOBUF_CONSTEXPR HostnameUserConfigurableProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostnameUserConfigurableProto(const HostnameUserConfigurableProto& from);
  HostnameUserConfigurableProto(HostnameUserConfigurableProto&& from) noexcept
    : HostnameUserConfigurableProto() {
    *this = ::std::move(from);
  }

  inline HostnameUserConfigurableProto& operator=(const HostnameUserConfigurableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostnameUserConfigurableProto& operator=(HostnameUserConfigurableProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HostnameUserConfigurableProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostnameUserConfigurableProto* internal_default_instance() {
    return reinterpret_cast<const HostnameUserConfigurableProto*>(
               &_HostnameUserConfigurableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HostnameUserConfigurableProto& a, HostnameUserConfigurableProto& b) {
    a.Swap(&b);
  }
  inline void Swap(HostnameUserConfigurableProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostnameUserConfigurableProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostnameUserConfigurableProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostnameUserConfigurableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostnameUserConfigurableProto& from);
  void MergeFrom(const HostnameUserConfigurableProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostnameUserConfigurableProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.HostnameUserConfigurableProto";
  }
  protected:
  explicit HostnameUserConfigurableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceHostnameUserConfigurableFieldNumber = 1,
  };
  // optional bool device_hostname_user_configurable = 1 [default = false];
  bool has_device_hostname_user_configurable() const;
  private:
  bool _internal_has_device_hostname_user_configurable() const;
  public:
  void clear_device_hostname_user_configurable();
  bool device_hostname_user_configurable() const;
  void set_device_hostname_user_configurable(bool value);
  private:
  bool _internal_device_hostname_user_configurable() const;
  void _internal_set_device_hostname_user_configurable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.HostnameUserConfigurableProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_hostname_user_configurable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceReportingProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceReportingProto) */ {
 public:
  inline DeviceReportingProto() : DeviceReportingProto(nullptr) {}
  ~DeviceReportingProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceReportingProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceReportingProto(const DeviceReportingProto& from);
  DeviceReportingProto(DeviceReportingProto&& from) noexcept
    : DeviceReportingProto() {
    *this = ::std::move(from);
  }

  inline DeviceReportingProto& operator=(const DeviceReportingProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceReportingProto& operator=(DeviceReportingProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceReportingProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceReportingProto* internal_default_instance() {
    return reinterpret_cast<const DeviceReportingProto*>(
               &_DeviceReportingProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DeviceReportingProto& a, DeviceReportingProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceReportingProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceReportingProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceReportingProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceReportingProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceReportingProto& from);
  void MergeFrom(const DeviceReportingProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceReportingProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceReportingProto";
  }
  protected:
  explicit DeviceReportingProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportSignalStrengthEventDrivenTelemetryFieldNumber = 38,
    kReportLocationFieldNumber = 4,
    kReportOsUpdateStatusFieldNumber = 10,
    kReportRunningKioskAppFieldNumber = 11,
    kReportPowerStatusFieldNumber = 12,
    kReportStorageStatusFieldNumber = 13,
    kReportBoardStatusFieldNumber = 14,
    kReportCpuInfoFieldNumber = 15,
    kReportGraphicsStatusFieldNumber = 16,
    kReportCrashReportInfoFieldNumber = 17,
    kReportTimezoneInfoFieldNumber = 18,
    kReportMemoryInfoFieldNumber = 19,
    kReportBacklightInfoFieldNumber = 20,
    kReportAppInfoFieldNumber = 21,
    kReportBluetoothInfoFieldNumber = 22,
    kReportFanInfoFieldNumber = 23,
    kReportVpdInfoFieldNumber = 24,
    kReportSystemInfoFieldNumber = 25,
    kReportPrintJobsFieldNumber = 26,
    kReportLoginLogoutFieldNumber = 27,
    kReportSecurityStatusFieldNumber = 31,
    kReportCrdSessionsFieldNumber = 36,
    kReportPeripheralsFieldNumber = 37,
    kDeviceActivityHeartbeatEnabledFieldNumber = 39,
    kReportNetworkConfigurationFieldNumber = 29,
    kReportNetworkStatusFieldNumber = 30,
    kEnableGranularReportingFieldNumber = 32,
    kReportVersionInfoFieldNumber = 1,
    kReportActivityTimesFieldNumber = 2,
    kReportBootModeFieldNumber = 3,
    kReportNetworkInterfacesFieldNumber = 5,
    kReportUsersFieldNumber = 6,
    kReportHardwareStatusFieldNumber = 7,
    kReportSessionStatusFieldNumber = 8,
    kReportAudioStatusFieldNumber = 28,
    kDeviceStatusFrequencyFieldNumber = 9,
    kReportNetworkTelemetryCollectionRateMsFieldNumber = 33,
    kReportNetworkTelemetryEventCheckingRateMsFieldNumber = 34,
    kReportDeviceAudioStatusCheckingRateMsFieldNumber = 35,
    kDeviceActivityHeartbeatCollectionRateMsFieldNumber = 40,
  };
  // optional .enterprise_management.StringList report_signal_strength_event_driven_telemetry = 38;
  bool has_report_signal_strength_event_driven_telemetry() const;
  private:
  bool _internal_has_report_signal_strength_event_driven_telemetry() const;
  public:
  void clear_report_signal_strength_event_driven_telemetry();
  const ::enterprise_management::StringList& report_signal_strength_event_driven_telemetry() const;
  PROTOBUF_NODISCARD ::enterprise_management::StringList* release_report_signal_strength_event_driven_telemetry();
  ::enterprise_management::StringList* mutable_report_signal_strength_event_driven_telemetry();
  void set_allocated_report_signal_strength_event_driven_telemetry(::enterprise_management::StringList* report_signal_strength_event_driven_telemetry);
  private:
  const ::enterprise_management::StringList& _internal_report_signal_strength_event_driven_telemetry() const;
  ::enterprise_management::StringList* _internal_mutable_report_signal_strength_event_driven_telemetry();
  public:
  void unsafe_arena_set_allocated_report_signal_strength_event_driven_telemetry(
      ::enterprise_management::StringList* report_signal_strength_event_driven_telemetry);
  ::enterprise_management::StringList* unsafe_arena_release_report_signal_strength_event_driven_telemetry();

  // optional bool report_location = 4 [default = false];
  bool has_report_location() const;
  private:
  bool _internal_has_report_location() const;
  public:
  void clear_report_location();
  bool report_location() const;
  void set_report_location(bool value);
  private:
  bool _internal_report_location() const;
  void _internal_set_report_location(bool value);
  public:

  // optional bool report_os_update_status = 10 [default = false];
  bool has_report_os_update_status() const;
  private:
  bool _internal_has_report_os_update_status() const;
  public:
  void clear_report_os_update_status();
  bool report_os_update_status() const;
  void set_report_os_update_status(bool value);
  private:
  bool _internal_report_os_update_status() const;
  void _internal_set_report_os_update_status(bool value);
  public:

  // optional bool report_running_kiosk_app = 11 [default = false];
  bool has_report_running_kiosk_app() const;
  private:
  bool _internal_has_report_running_kiosk_app() const;
  public:
  void clear_report_running_kiosk_app();
  bool report_running_kiosk_app() const;
  void set_report_running_kiosk_app(bool value);
  private:
  bool _internal_report_running_kiosk_app() const;
  void _internal_set_report_running_kiosk_app(bool value);
  public:

  // optional bool report_power_status = 12 [default = false];
  bool has_report_power_status() const;
  private:
  bool _internal_has_report_power_status() const;
  public:
  void clear_report_power_status();
  bool report_power_status() const;
  void set_report_power_status(bool value);
  private:
  bool _internal_report_power_status() const;
  void _internal_set_report_power_status(bool value);
  public:

  // optional bool report_storage_status = 13 [default = false];
  bool has_report_storage_status() const;
  private:
  bool _internal_has_report_storage_status() const;
  public:
  void clear_report_storage_status();
  bool report_storage_status() const;
  void set_report_storage_status(bool value);
  private:
  bool _internal_report_storage_status() const;
  void _internal_set_report_storage_status(bool value);
  public:

  // optional bool report_board_status = 14 [default = false];
  bool has_report_board_status() const;
  private:
  bool _internal_has_report_board_status() const;
  public:
  void clear_report_board_status();
  bool report_board_status() const;
  void set_report_board_status(bool value);
  private:
  bool _internal_report_board_status() const;
  void _internal_set_report_board_status(bool value);
  public:

  // optional bool report_cpu_info = 15 [default = false];
  bool has_report_cpu_info() const;
  private:
  bool _internal_has_report_cpu_info() const;
  public:
  void clear_report_cpu_info();
  bool report_cpu_info() const;
  void set_report_cpu_info(bool value);
  private:
  bool _internal_report_cpu_info() const;
  void _internal_set_report_cpu_info(bool value);
  public:

  // optional bool report_graphics_status = 16 [default = false];
  bool has_report_graphics_status() const;
  private:
  bool _internal_has_report_graphics_status() const;
  public:
  void clear_report_graphics_status();
  bool report_graphics_status() const;
  void set_report_graphics_status(bool value);
  private:
  bool _internal_report_graphics_status() const;
  void _internal_set_report_graphics_status(bool value);
  public:

  // optional bool report_crash_report_info = 17 [default = false];
  bool has_report_crash_report_info() const;
  private:
  bool _internal_has_report_crash_report_info() const;
  public:
  void clear_report_crash_report_info();
  bool report_crash_report_info() const;
  void set_report_crash_report_info(bool value);
  private:
  bool _internal_report_crash_report_info() const;
  void _internal_set_report_crash_report_info(bool value);
  public:

  // optional bool report_timezone_info = 18 [default = false];
  bool has_report_timezone_info() const;
  private:
  bool _internal_has_report_timezone_info() const;
  public:
  void clear_report_timezone_info();
  bool report_timezone_info() const;
  void set_report_timezone_info(bool value);
  private:
  bool _internal_report_timezone_info() const;
  void _internal_set_report_timezone_info(bool value);
  public:

  // optional bool report_memory_info = 19 [default = false];
  bool has_report_memory_info() const;
  private:
  bool _internal_has_report_memory_info() const;
  public:
  void clear_report_memory_info();
  bool report_memory_info() const;
  void set_report_memory_info(bool value);
  private:
  bool _internal_report_memory_info() const;
  void _internal_set_report_memory_info(bool value);
  public:

  // optional bool report_backlight_info = 20 [default = false];
  bool has_report_backlight_info() const;
  private:
  bool _internal_has_report_backlight_info() const;
  public:
  void clear_report_backlight_info();
  bool report_backlight_info() const;
  void set_report_backlight_info(bool value);
  private:
  bool _internal_report_backlight_info() const;
  void _internal_set_report_backlight_info(bool value);
  public:

  // optional bool report_app_info = 21 [default = false];
  bool has_report_app_info() const;
  private:
  bool _internal_has_report_app_info() const;
  public:
  void clear_report_app_info();
  bool report_app_info() const;
  void set_report_app_info(bool value);
  private:
  bool _internal_report_app_info() const;
  void _internal_set_report_app_info(bool value);
  public:

  // optional bool report_bluetooth_info = 22 [default = false];
  bool has_report_bluetooth_info() const;
  private:
  bool _internal_has_report_bluetooth_info() const;
  public:
  void clear_report_bluetooth_info();
  bool report_bluetooth_info() const;
  void set_report_bluetooth_info(bool value);
  private:
  bool _internal_report_bluetooth_info() const;
  void _internal_set_report_bluetooth_info(bool value);
  public:

  // optional bool report_fan_info = 23 [default = false];
  bool has_report_fan_info() const;
  private:
  bool _internal_has_report_fan_info() const;
  public:
  void clear_report_fan_info();
  bool report_fan_info() const;
  void set_report_fan_info(bool value);
  private:
  bool _internal_report_fan_info() const;
  void _internal_set_report_fan_info(bool value);
  public:

  // optional bool report_vpd_info = 24 [default = false];
  bool has_report_vpd_info() const;
  private:
  bool _internal_has_report_vpd_info() const;
  public:
  void clear_report_vpd_info();
  bool report_vpd_info() const;
  void set_report_vpd_info(bool value);
  private:
  bool _internal_report_vpd_info() const;
  void _internal_set_report_vpd_info(bool value);
  public:

  // optional bool report_system_info = 25 [default = false];
  bool has_report_system_info() const;
  private:
  bool _internal_has_report_system_info() const;
  public:
  void clear_report_system_info();
  bool report_system_info() const;
  void set_report_system_info(bool value);
  private:
  bool _internal_report_system_info() const;
  void _internal_set_report_system_info(bool value);
  public:

  // optional bool report_print_jobs = 26 [default = false];
  bool has_report_print_jobs() const;
  private:
  bool _internal_has_report_print_jobs() const;
  public:
  void clear_report_print_jobs();
  bool report_print_jobs() const;
  void set_report_print_jobs(bool value);
  private:
  bool _internal_report_print_jobs() const;
  void _internal_set_report_print_jobs(bool value);
  public:

  // optional bool report_login_logout = 27 [default = false];
  bool has_report_login_logout() const;
  private:
  bool _internal_has_report_login_logout() const;
  public:
  void clear_report_login_logout();
  bool report_login_logout() const;
  void set_report_login_logout(bool value);
  private:
  bool _internal_report_login_logout() const;
  void _internal_set_report_login_logout(bool value);
  public:

  // optional bool report_security_status = 31 [default = false];
  bool has_report_security_status() const;
  private:
  bool _internal_has_report_security_status() const;
  public:
  void clear_report_security_status();
  bool report_security_status() const;
  void set_report_security_status(bool value);
  private:
  bool _internal_report_security_status() const;
  void _internal_set_report_security_status(bool value);
  public:

  // optional bool report_crd_sessions = 36 [default = false];
  bool has_report_crd_sessions() const;
  private:
  bool _internal_has_report_crd_sessions() const;
  public:
  void clear_report_crd_sessions();
  bool report_crd_sessions() const;
  void set_report_crd_sessions(bool value);
  private:
  bool _internal_report_crd_sessions() const;
  void _internal_set_report_crd_sessions(bool value);
  public:

  // optional bool report_peripherals = 37 [default = false];
  bool has_report_peripherals() const;
  private:
  bool _internal_has_report_peripherals() const;
  public:
  void clear_report_peripherals();
  bool report_peripherals() const;
  void set_report_peripherals(bool value);
  private:
  bool _internal_report_peripherals() const;
  void _internal_set_report_peripherals(bool value);
  public:

  // optional bool device_activity_heartbeat_enabled = 39 [default = false];
  bool has_device_activity_heartbeat_enabled() const;
  private:
  bool _internal_has_device_activity_heartbeat_enabled() const;
  public:
  void clear_device_activity_heartbeat_enabled();
  bool device_activity_heartbeat_enabled() const;
  void set_device_activity_heartbeat_enabled(bool value);
  private:
  bool _internal_device_activity_heartbeat_enabled() const;
  void _internal_set_device_activity_heartbeat_enabled(bool value);
  public:

  // optional bool report_network_configuration = 29 [default = true];
  bool has_report_network_configuration() const;
  private:
  bool _internal_has_report_network_configuration() const;
  public:
  void clear_report_network_configuration();
  bool report_network_configuration() const;
  void set_report_network_configuration(bool value);
  private:
  bool _internal_report_network_configuration() const;
  void _internal_set_report_network_configuration(bool value);
  public:

  // optional bool report_network_status = 30 [default = true];
  bool has_report_network_status() const;
  private:
  bool _internal_has_report_network_status() const;
  public:
  void clear_report_network_status();
  bool report_network_status() const;
  void set_report_network_status(bool value);
  private:
  bool _internal_report_network_status() const;
  void _internal_set_report_network_status(bool value);
  public:

  // optional bool enable_granular_reporting = 32 [default = true, deprecated = true];
  PROTOBUF_DEPRECATED bool has_enable_granular_reporting() const;
  private:
  bool _internal_has_enable_granular_reporting() const;
  public:
  PROTOBUF_DEPRECATED void clear_enable_granular_reporting();
  PROTOBUF_DEPRECATED bool enable_granular_reporting() const;
  PROTOBUF_DEPRECATED void set_enable_granular_reporting(bool value);
  private:
  bool _internal_enable_granular_reporting() const;
  void _internal_set_enable_granular_reporting(bool value);
  public:

  // optional bool report_version_info = 1 [default = true];
  bool has_report_version_info() const;
  private:
  bool _internal_has_report_version_info() const;
  public:
  void clear_report_version_info();
  bool report_version_info() const;
  void set_report_version_info(bool value);
  private:
  bool _internal_report_version_info() const;
  void _internal_set_report_version_info(bool value);
  public:

  // optional bool report_activity_times = 2 [default = true];
  bool has_report_activity_times() const;
  private:
  bool _internal_has_report_activity_times() const;
  public:
  void clear_report_activity_times();
  bool report_activity_times() const;
  void set_report_activity_times(bool value);
  private:
  bool _internal_report_activity_times() const;
  void _internal_set_report_activity_times(bool value);
  public:

  // optional bool report_boot_mode = 3 [default = true];
  bool has_report_boot_mode() const;
  private:
  bool _internal_has_report_boot_mode() const;
  public:
  void clear_report_boot_mode();
  bool report_boot_mode() const;
  void set_report_boot_mode(bool value);
  private:
  bool _internal_report_boot_mode() const;
  void _internal_set_report_boot_mode(bool value);
  public:

  // optional bool report_network_interfaces = 5 [default = true, deprecated = true];
  PROTOBUF_DEPRECATED bool has_report_network_interfaces() const;
  private:
  bool _internal_has_report_network_interfaces() const;
  public:
  PROTOBUF_DEPRECATED void clear_report_network_interfaces();
  PROTOBUF_DEPRECATED bool report_network_interfaces() const;
  PROTOBUF_DEPRECATED void set_report_network_interfaces(bool value);
  private:
  bool _internal_report_network_interfaces() const;
  void _internal_set_report_network_interfaces(bool value);
  public:

  // optional bool report_users = 6 [default = true];
  bool has_report_users() const;
  private:
  bool _internal_has_report_users() const;
  public:
  void clear_report_users();
  bool report_users() const;
  void set_report_users(bool value);
  private:
  bool _internal_report_users() const;
  void _internal_set_report_users(bool value);
  public:

  // optional bool report_hardware_status = 7 [default = true, deprecated = true];
  PROTOBUF_DEPRECATED bool has_report_hardware_status() const;
  private:
  bool _internal_has_report_hardware_status() const;
  public:
  PROTOBUF_DEPRECATED void clear_report_hardware_status();
  PROTOBUF_DEPRECATED bool report_hardware_status() const;
  PROTOBUF_DEPRECATED void set_report_hardware_status(bool value);
  private:
  bool _internal_report_hardware_status() const;
  void _internal_set_report_hardware_status(bool value);
  public:

  // optional bool report_session_status = 8 [default = true];
  bool has_report_session_status() const;
  private:
  bool _internal_has_report_session_status() const;
  public:
  void clear_report_session_status();
  bool report_session_status() const;
  void set_report_session_status(bool value);
  private:
  bool _internal_report_session_status() const;
  void _internal_set_report_session_status(bool value);
  public:

  // optional bool report_audio_status = 28 [default = true];
  bool has_report_audio_status() const;
  private:
  bool _internal_has_report_audio_status() const;
  public:
  void clear_report_audio_status();
  bool report_audio_status() const;
  void set_report_audio_status(bool value);
  private:
  bool _internal_report_audio_status() const;
  void _internal_set_report_audio_status(bool value);
  public:

  // optional int64 device_status_frequency = 9 [default = 10800000];
  bool has_device_status_frequency() const;
  private:
  bool _internal_has_device_status_frequency() const;
  public:
  void clear_device_status_frequency();
  int64_t device_status_frequency() const;
  void set_device_status_frequency(int64_t value);
  private:
  int64_t _internal_device_status_frequency() const;
  void _internal_set_device_status_frequency(int64_t value);
  public:

  // optional int64 report_network_telemetry_collection_rate_ms = 33 [default = 3600000];
  bool has_report_network_telemetry_collection_rate_ms() const;
  private:
  bool _internal_has_report_network_telemetry_collection_rate_ms() const;
  public:
  void clear_report_network_telemetry_collection_rate_ms();
  int64_t report_network_telemetry_collection_rate_ms() const;
  void set_report_network_telemetry_collection_rate_ms(int64_t value);
  private:
  int64_t _internal_report_network_telemetry_collection_rate_ms() const;
  void _internal_set_report_network_telemetry_collection_rate_ms(int64_t value);
  public:

  // optional int64 report_network_telemetry_event_checking_rate_ms = 34 [default = 600000];
  bool has_report_network_telemetry_event_checking_rate_ms() const;
  private:
  bool _internal_has_report_network_telemetry_event_checking_rate_ms() const;
  public:
  void clear_report_network_telemetry_event_checking_rate_ms();
  int64_t report_network_telemetry_event_checking_rate_ms() const;
  void set_report_network_telemetry_event_checking_rate_ms(int64_t value);
  private:
  int64_t _internal_report_network_telemetry_event_checking_rate_ms() const;
  void _internal_set_report_network_telemetry_event_checking_rate_ms(int64_t value);
  public:

  // optional int64 report_device_audio_status_checking_rate_ms = 35 [default = 600000];
  bool has_report_device_audio_status_checking_rate_ms() const;
  private:
  bool _internal_has_report_device_audio_status_checking_rate_ms() const;
  public:
  void clear_report_device_audio_status_checking_rate_ms();
  int64_t report_device_audio_status_checking_rate_ms() const;
  void set_report_device_audio_status_checking_rate_ms(int64_t value);
  private:
  int64_t _internal_report_device_audio_status_checking_rate_ms() const;
  void _internal_set_report_device_audio_status_checking_rate_ms(int64_t value);
  public:

  // optional int64 device_activity_heartbeat_collection_rate_ms = 40 [default = 900000];
  bool has_device_activity_heartbeat_collection_rate_ms() const;
  private:
  bool _internal_has_device_activity_heartbeat_collection_rate_ms() const;
  public:
  void clear_device_activity_heartbeat_collection_rate_ms();
  int64_t device_activity_heartbeat_collection_rate_ms() const;
  void set_device_activity_heartbeat_collection_rate_ms(int64_t value);
  private:
  int64_t _internal_device_activity_heartbeat_collection_rate_ms() const;
  void _internal_set_device_activity_heartbeat_collection_rate_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceReportingProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::StringList* report_signal_strength_event_driven_telemetry_;
    bool report_location_;
    bool report_os_update_status_;
    bool report_running_kiosk_app_;
    bool report_power_status_;
    bool report_storage_status_;
    bool report_board_status_;
    bool report_cpu_info_;
    bool report_graphics_status_;
    bool report_crash_report_info_;
    bool report_timezone_info_;
    bool report_memory_info_;
    bool report_backlight_info_;
    bool report_app_info_;
    bool report_bluetooth_info_;
    bool report_fan_info_;
    bool report_vpd_info_;
    bool report_system_info_;
    bool report_print_jobs_;
    bool report_login_logout_;
    bool report_security_status_;
    bool report_crd_sessions_;
    bool report_peripherals_;
    bool device_activity_heartbeat_enabled_;
    bool report_network_configuration_;
    bool report_network_status_;
    bool enable_granular_reporting_;
    bool report_version_info_;
    bool report_activity_times_;
    bool report_boot_mode_;
    bool report_network_interfaces_;
    bool report_users_;
    bool report_hardware_status_;
    bool report_session_status_;
    bool report_audio_status_;
    int64_t device_status_frequency_;
    int64_t report_network_telemetry_collection_rate_ms_;
    int64_t report_network_telemetry_event_checking_rate_ms_;
    int64_t report_device_audio_status_checking_rate_ms_;
    int64_t device_activity_heartbeat_collection_rate_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class EphemeralUsersEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.EphemeralUsersEnabledProto) */ {
 public:
  inline EphemeralUsersEnabledProto() : EphemeralUsersEnabledProto(nullptr) {}
  ~EphemeralUsersEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR EphemeralUsersEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EphemeralUsersEnabledProto(const EphemeralUsersEnabledProto& from);
  EphemeralUsersEnabledProto(EphemeralUsersEnabledProto&& from) noexcept
    : EphemeralUsersEnabledProto() {
    *this = ::std::move(from);
  }

  inline EphemeralUsersEnabledProto& operator=(const EphemeralUsersEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline EphemeralUsersEnabledProto& operator=(EphemeralUsersEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EphemeralUsersEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const EphemeralUsersEnabledProto* internal_default_instance() {
    return reinterpret_cast<const EphemeralUsersEnabledProto*>(
               &_EphemeralUsersEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EphemeralUsersEnabledProto& a, EphemeralUsersEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(EphemeralUsersEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EphemeralUsersEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EphemeralUsersEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EphemeralUsersEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EphemeralUsersEnabledProto& from);
  void MergeFrom(const EphemeralUsersEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EphemeralUsersEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.EphemeralUsersEnabledProto";
  }
  protected:
  explicit EphemeralUsersEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEphemeralUsersEnabledFieldNumber = 1,
  };
  // optional bool ephemeral_users_enabled = 1;
  bool has_ephemeral_users_enabled() const;
  private:
  bool _internal_has_ephemeral_users_enabled() const;
  public:
  void clear_ephemeral_users_enabled();
  bool ephemeral_users_enabled() const;
  void set_ephemeral_users_enabled(bool value);
  private:
  bool _internal_ephemeral_users_enabled() const;
  void _internal_set_ephemeral_users_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.EphemeralUsersEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ephemeral_users_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceKeylockerForStorageEncryptionEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto) */ {
 public:
  inline DeviceKeylockerForStorageEncryptionEnabledProto() : DeviceKeylockerForStorageEncryptionEnabledProto(nullptr) {}
  ~DeviceKeylockerForStorageEncryptionEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceKeylockerForStorageEncryptionEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceKeylockerForStorageEncryptionEnabledProto(const DeviceKeylockerForStorageEncryptionEnabledProto& from);
  DeviceKeylockerForStorageEncryptionEnabledProto(DeviceKeylockerForStorageEncryptionEnabledProto&& from) noexcept
    : DeviceKeylockerForStorageEncryptionEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceKeylockerForStorageEncryptionEnabledProto& operator=(const DeviceKeylockerForStorageEncryptionEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceKeylockerForStorageEncryptionEnabledProto& operator=(DeviceKeylockerForStorageEncryptionEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceKeylockerForStorageEncryptionEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceKeylockerForStorageEncryptionEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceKeylockerForStorageEncryptionEnabledProto*>(
               &_DeviceKeylockerForStorageEncryptionEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeviceKeylockerForStorageEncryptionEnabledProto& a, DeviceKeylockerForStorageEncryptionEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceKeylockerForStorageEncryptionEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceKeylockerForStorageEncryptionEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceKeylockerForStorageEncryptionEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceKeylockerForStorageEncryptionEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceKeylockerForStorageEncryptionEnabledProto& from);
  void MergeFrom(const DeviceKeylockerForStorageEncryptionEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceKeylockerForStorageEncryptionEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto";
  }
  protected:
  explicit DeviceKeylockerForStorageEncryptionEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_AppPackEntryProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_AppPackEntryProto) */ {
 public:
  inline OBSOLETE_AppPackEntryProto() : OBSOLETE_AppPackEntryProto(nullptr) {}
  ~OBSOLETE_AppPackEntryProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_AppPackEntryProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_AppPackEntryProto(const OBSOLETE_AppPackEntryProto& from);
  OBSOLETE_AppPackEntryProto(OBSOLETE_AppPackEntryProto&& from) noexcept
    : OBSOLETE_AppPackEntryProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_AppPackEntryProto& operator=(const OBSOLETE_AppPackEntryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_AppPackEntryProto& operator=(OBSOLETE_AppPackEntryProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_AppPackEntryProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_AppPackEntryProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_AppPackEntryProto*>(
               &_OBSOLETE_AppPackEntryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OBSOLETE_AppPackEntryProto& a, OBSOLETE_AppPackEntryProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_AppPackEntryProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_AppPackEntryProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_AppPackEntryProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_AppPackEntryProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_AppPackEntryProto& from);
  void MergeFrom(const OBSOLETE_AppPackEntryProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_AppPackEntryProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_AppPackEntryProto";
  }
  protected:
  explicit OBSOLETE_AppPackEntryProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEExtensionIdFieldNumber = 1,
    kOBSOLETEUpdateUrlFieldNumber = 2,
    kOBSOLETEOnlineOnlyFieldNumber = 3,
  };
  // optional string OBSOLETE_extension_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_extension_id() const;
  private:
  bool _internal_has_obsolete_extension_id() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_extension_id();
  PROTOBUF_DEPRECATED const std::string& obsolete_extension_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_extension_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_extension_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_extension_id();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_extension_id(std::string* obsolete_extension_id);
  private:
  const std::string& _internal_obsolete_extension_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_extension_id(const std::string& value);
  std::string* _internal_mutable_obsolete_extension_id();
  public:

  // optional string OBSOLETE_update_url = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_update_url() const;
  private:
  bool _internal_has_obsolete_update_url() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_update_url();
  PROTOBUF_DEPRECATED const std::string& obsolete_update_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_update_url(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_update_url();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_update_url();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_update_url(std::string* obsolete_update_url);
  private:
  const std::string& _internal_obsolete_update_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_update_url(const std::string& value);
  std::string* _internal_mutable_obsolete_update_url();
  public:

  // optional bool OBSOLETE_online_only = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_online_only() const;
  private:
  bool _internal_has_obsolete_online_only() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_online_only();
  PROTOBUF_DEPRECATED bool obsolete_online_only() const;
  PROTOBUF_DEPRECATED void set_obsolete_online_only(bool value);
  private:
  bool _internal_obsolete_online_only() const;
  void _internal_set_obsolete_online_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_AppPackEntryProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_extension_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_update_url_;
    bool obsolete_online_only_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_AppPackProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_AppPackProto) */ {
 public:
  inline OBSOLETE_AppPackProto() : OBSOLETE_AppPackProto(nullptr) {}
  ~OBSOLETE_AppPackProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_AppPackProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_AppPackProto(const OBSOLETE_AppPackProto& from);
  OBSOLETE_AppPackProto(OBSOLETE_AppPackProto&& from) noexcept
    : OBSOLETE_AppPackProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_AppPackProto& operator=(const OBSOLETE_AppPackProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_AppPackProto& operator=(OBSOLETE_AppPackProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_AppPackProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_AppPackProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_AppPackProto*>(
               &_OBSOLETE_AppPackProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(OBSOLETE_AppPackProto& a, OBSOLETE_AppPackProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_AppPackProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_AppPackProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_AppPackProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_AppPackProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_AppPackProto& from);
  void MergeFrom(const OBSOLETE_AppPackProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_AppPackProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_AppPackProto";
  }
  protected:
  explicit OBSOLETE_AppPackProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppPackFieldNumber = 1,
  };
  // repeated .enterprise_management.OBSOLETE_AppPackEntryProto app_pack = 1 [deprecated = true];
  PROTOBUF_DEPRECATED int app_pack_size() const;
  private:
  int _internal_app_pack_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_app_pack();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_AppPackEntryProto* mutable_app_pack(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::OBSOLETE_AppPackEntryProto >*
      mutable_app_pack();
  private:
  const ::enterprise_management::OBSOLETE_AppPackEntryProto& _internal_app_pack(int index) const;
  ::enterprise_management::OBSOLETE_AppPackEntryProto* _internal_add_app_pack();
  public:
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_AppPackEntryProto& app_pack(int index) const;
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_AppPackEntryProto* add_app_pack();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::OBSOLETE_AppPackEntryProto >&
      app_pack() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_AppPackProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::OBSOLETE_AppPackEntryProto > app_pack_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_PinnedAppsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_PinnedAppsProto) */ {
 public:
  inline OBSOLETE_PinnedAppsProto() : OBSOLETE_PinnedAppsProto(nullptr) {}
  ~OBSOLETE_PinnedAppsProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_PinnedAppsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_PinnedAppsProto(const OBSOLETE_PinnedAppsProto& from);
  OBSOLETE_PinnedAppsProto(OBSOLETE_PinnedAppsProto&& from) noexcept
    : OBSOLETE_PinnedAppsProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_PinnedAppsProto& operator=(const OBSOLETE_PinnedAppsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_PinnedAppsProto& operator=(OBSOLETE_PinnedAppsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_PinnedAppsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_PinnedAppsProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_PinnedAppsProto*>(
               &_OBSOLETE_PinnedAppsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(OBSOLETE_PinnedAppsProto& a, OBSOLETE_PinnedAppsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_PinnedAppsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_PinnedAppsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_PinnedAppsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_PinnedAppsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_PinnedAppsProto& from);
  void MergeFrom(const OBSOLETE_PinnedAppsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_PinnedAppsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_PinnedAppsProto";
  }
  protected:
  explicit OBSOLETE_PinnedAppsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEAppIdFieldNumber = 1,
  };
  // repeated string OBSOLETE_app_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED int obsolete_app_id_size() const;
  private:
  int _internal_obsolete_app_id_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_app_id();
  PROTOBUF_DEPRECATED const std::string& obsolete_app_id(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_app_id(int index);
  PROTOBUF_DEPRECATED void set_obsolete_app_id(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_obsolete_app_id(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_obsolete_app_id(int index, const char* value);
  PROTOBUF_DEPRECATED void set_obsolete_app_id(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_obsolete_app_id();
  PROTOBUF_DEPRECATED void add_obsolete_app_id(const std::string& value);
  PROTOBUF_DEPRECATED void add_obsolete_app_id(std::string&& value);
  PROTOBUF_DEPRECATED void add_obsolete_app_id(const char* value);
  PROTOBUF_DEPRECATED void add_obsolete_app_id(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& obsolete_app_id() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_obsolete_app_id();
  private:
  const std::string& _internal_obsolete_app_id(int index) const;
  std::string* _internal_add_obsolete_app_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_PinnedAppsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> obsolete_app_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_ForcedLogoutTimeoutsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto) */ {
 public:
  inline OBSOLETE_ForcedLogoutTimeoutsProto() : OBSOLETE_ForcedLogoutTimeoutsProto(nullptr) {}
  ~OBSOLETE_ForcedLogoutTimeoutsProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_ForcedLogoutTimeoutsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_ForcedLogoutTimeoutsProto(const OBSOLETE_ForcedLogoutTimeoutsProto& from);
  OBSOLETE_ForcedLogoutTimeoutsProto(OBSOLETE_ForcedLogoutTimeoutsProto&& from) noexcept
    : OBSOLETE_ForcedLogoutTimeoutsProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_ForcedLogoutTimeoutsProto& operator=(const OBSOLETE_ForcedLogoutTimeoutsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_ForcedLogoutTimeoutsProto& operator=(OBSOLETE_ForcedLogoutTimeoutsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_ForcedLogoutTimeoutsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_ForcedLogoutTimeoutsProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_ForcedLogoutTimeoutsProto*>(
               &_OBSOLETE_ForcedLogoutTimeoutsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(OBSOLETE_ForcedLogoutTimeoutsProto& a, OBSOLETE_ForcedLogoutTimeoutsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_ForcedLogoutTimeoutsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_ForcedLogoutTimeoutsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_ForcedLogoutTimeoutsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_ForcedLogoutTimeoutsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_ForcedLogoutTimeoutsProto& from);
  void MergeFrom(const OBSOLETE_ForcedLogoutTimeoutsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_ForcedLogoutTimeoutsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto";
  }
  protected:
  explicit OBSOLETE_ForcedLogoutTimeoutsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEIdleLogoutTimeoutFieldNumber = 1,
    kOBSOLETEIdleLogoutWarningDurationFieldNumber = 2,
  };
  // optional int64 OBSOLETE_idle_logout_timeout = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_idle_logout_timeout() const;
  private:
  bool _internal_has_obsolete_idle_logout_timeout() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_idle_logout_timeout();
  PROTOBUF_DEPRECATED int64_t obsolete_idle_logout_timeout() const;
  PROTOBUF_DEPRECATED void set_obsolete_idle_logout_timeout(int64_t value);
  private:
  int64_t _internal_obsolete_idle_logout_timeout() const;
  void _internal_set_obsolete_idle_logout_timeout(int64_t value);
  public:

  // optional int64 OBSOLETE_idle_logout_warning_duration = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_idle_logout_warning_duration() const;
  private:
  bool _internal_has_obsolete_idle_logout_warning_duration() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_idle_logout_warning_duration();
  PROTOBUF_DEPRECATED int64_t obsolete_idle_logout_warning_duration() const;
  PROTOBUF_DEPRECATED void set_obsolete_idle_logout_warning_duration(int64_t value);
  private:
  int64_t _internal_obsolete_idle_logout_warning_duration() const;
  void _internal_set_obsolete_idle_logout_warning_duration(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t obsolete_idle_logout_timeout_;
    int64_t obsolete_idle_logout_warning_duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_ScreenSaverProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_ScreenSaverProto) */ {
 public:
  inline OBSOLETE_ScreenSaverProto() : OBSOLETE_ScreenSaverProto(nullptr) {}
  ~OBSOLETE_ScreenSaverProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_ScreenSaverProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_ScreenSaverProto(const OBSOLETE_ScreenSaverProto& from);
  OBSOLETE_ScreenSaverProto(OBSOLETE_ScreenSaverProto&& from) noexcept
    : OBSOLETE_ScreenSaverProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_ScreenSaverProto& operator=(const OBSOLETE_ScreenSaverProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_ScreenSaverProto& operator=(OBSOLETE_ScreenSaverProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_ScreenSaverProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_ScreenSaverProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_ScreenSaverProto*>(
               &_OBSOLETE_ScreenSaverProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(OBSOLETE_ScreenSaverProto& a, OBSOLETE_ScreenSaverProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_ScreenSaverProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_ScreenSaverProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_ScreenSaverProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_ScreenSaverProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_ScreenSaverProto& from);
  void MergeFrom(const OBSOLETE_ScreenSaverProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_ScreenSaverProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_ScreenSaverProto";
  }
  protected:
  explicit OBSOLETE_ScreenSaverProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEScreenSaverExtensionIdFieldNumber = 1,
    kOBSOLETEScreenSaverTimeoutFieldNumber = 2,
  };
  // optional string OBSOLETE_screen_saver_extension_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_screen_saver_extension_id() const;
  private:
  bool _internal_has_obsolete_screen_saver_extension_id() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_screen_saver_extension_id();
  PROTOBUF_DEPRECATED const std::string& obsolete_screen_saver_extension_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_screen_saver_extension_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_screen_saver_extension_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_screen_saver_extension_id();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_screen_saver_extension_id(std::string* obsolete_screen_saver_extension_id);
  private:
  const std::string& _internal_obsolete_screen_saver_extension_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_screen_saver_extension_id(const std::string& value);
  std::string* _internal_mutable_obsolete_screen_saver_extension_id();
  public:

  // optional int64 OBSOLETE_screen_saver_timeout = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_screen_saver_timeout() const;
  private:
  bool _internal_has_obsolete_screen_saver_timeout() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_screen_saver_timeout();
  PROTOBUF_DEPRECATED int64_t obsolete_screen_saver_timeout() const;
  PROTOBUF_DEPRECATED void set_obsolete_screen_saver_timeout(int64_t value);
  private:
  int64_t _internal_obsolete_screen_saver_timeout() const;
  void _internal_set_obsolete_screen_saver_timeout(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_ScreenSaverProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_screen_saver_extension_id_;
    int64_t obsolete_screen_saver_timeout_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AutoUpdateSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AutoUpdateSettingsProto) */ {
 public:
  inline AutoUpdateSettingsProto() : AutoUpdateSettingsProto(nullptr) {}
  ~AutoUpdateSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR AutoUpdateSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoUpdateSettingsProto(const AutoUpdateSettingsProto& from);
  AutoUpdateSettingsProto(AutoUpdateSettingsProto&& from) noexcept
    : AutoUpdateSettingsProto() {
    *this = ::std::move(from);
  }

  inline AutoUpdateSettingsProto& operator=(const AutoUpdateSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoUpdateSettingsProto& operator=(AutoUpdateSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutoUpdateSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoUpdateSettingsProto* internal_default_instance() {
    return reinterpret_cast<const AutoUpdateSettingsProto*>(
               &_AutoUpdateSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AutoUpdateSettingsProto& a, AutoUpdateSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoUpdateSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoUpdateSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoUpdateSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoUpdateSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutoUpdateSettingsProto& from);
  void MergeFrom(const AutoUpdateSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutoUpdateSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AutoUpdateSettingsProto";
  }
  protected:
  explicit AutoUpdateSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutoUpdateSettingsProto_ConnectionType ConnectionType;
  static constexpr ConnectionType CONNECTION_TYPE_ETHERNET =
    AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_ETHERNET;
  static constexpr ConnectionType CONNECTION_TYPE_WIFI =
    AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_WIFI;
  static constexpr ConnectionType CONNECTION_TYPE_WIMAX =
    AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_WIMAX;
  static constexpr ConnectionType CONNECTION_TYPE_BLUETOOTH =
    AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_BLUETOOTH;
  static constexpr ConnectionType CONNECTION_TYPE_CELLULAR =
    AutoUpdateSettingsProto_ConnectionType_CONNECTION_TYPE_CELLULAR;
  static inline bool ConnectionType_IsValid(int value) {
    return AutoUpdateSettingsProto_ConnectionType_IsValid(value);
  }
  static constexpr ConnectionType ConnectionType_MIN =
    AutoUpdateSettingsProto_ConnectionType_ConnectionType_MIN;
  static constexpr ConnectionType ConnectionType_MAX =
    AutoUpdateSettingsProto_ConnectionType_ConnectionType_MAX;
  static constexpr int ConnectionType_ARRAYSIZE =
    AutoUpdateSettingsProto_ConnectionType_ConnectionType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ConnectionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionType_Name.");
    return AutoUpdateSettingsProto_ConnectionType_Name(enum_t_value);
  }
  static inline bool ConnectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionType* value) {
    return AutoUpdateSettingsProto_ConnectionType_Parse(name, value);
  }

  typedef AutoUpdateSettingsProto_RollbackToTargetVersion RollbackToTargetVersion;
  static constexpr RollbackToTargetVersion ROLLBACK_UNSPECIFIED =
    AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_UNSPECIFIED;
  static constexpr RollbackToTargetVersion ROLLBACK_DISABLED =
    AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_DISABLED;
  static constexpr RollbackToTargetVersion ROLLBACK_AND_POWERWASH =
    AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_AND_POWERWASH;
  static constexpr RollbackToTargetVersion ROLLBACK_AND_RESTORE_IF_POSSIBLE =
    AutoUpdateSettingsProto_RollbackToTargetVersion_ROLLBACK_AND_RESTORE_IF_POSSIBLE;
  static inline bool RollbackToTargetVersion_IsValid(int value) {
    return AutoUpdateSettingsProto_RollbackToTargetVersion_IsValid(value);
  }
  static constexpr RollbackToTargetVersion RollbackToTargetVersion_MIN =
    AutoUpdateSettingsProto_RollbackToTargetVersion_RollbackToTargetVersion_MIN;
  static constexpr RollbackToTargetVersion RollbackToTargetVersion_MAX =
    AutoUpdateSettingsProto_RollbackToTargetVersion_RollbackToTargetVersion_MAX;
  static constexpr int RollbackToTargetVersion_ARRAYSIZE =
    AutoUpdateSettingsProto_RollbackToTargetVersion_RollbackToTargetVersion_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RollbackToTargetVersion_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RollbackToTargetVersion>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RollbackToTargetVersion_Name.");
    return AutoUpdateSettingsProto_RollbackToTargetVersion_Name(enum_t_value);
  }
  static inline bool RollbackToTargetVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RollbackToTargetVersion* value) {
    return AutoUpdateSettingsProto_RollbackToTargetVersion_Parse(name, value);
  }

  typedef AutoUpdateSettingsProto_ChannelDowngradeBehavior ChannelDowngradeBehavior;
  static constexpr ChannelDowngradeBehavior CHANNEL_DOWNGRADE_BEHAVIOR_UNSPECIFIED =
    AutoUpdateSettingsProto_ChannelDowngradeBehavior_CHANNEL_DOWNGRADE_BEHAVIOR_UNSPECIFIED;
  static constexpr ChannelDowngradeBehavior WAIT_FOR_VERSION_CATCH_UP =
    AutoUpdateSettingsProto_ChannelDowngradeBehavior_WAIT_FOR_VERSION_CATCH_UP;
  static constexpr ChannelDowngradeBehavior ROLLBACK =
    AutoUpdateSettingsProto_ChannelDowngradeBehavior_ROLLBACK;
  static constexpr ChannelDowngradeBehavior ALLOW_USER_TO_CONFIGURE =
    AutoUpdateSettingsProto_ChannelDowngradeBehavior_ALLOW_USER_TO_CONFIGURE;
  static inline bool ChannelDowngradeBehavior_IsValid(int value) {
    return AutoUpdateSettingsProto_ChannelDowngradeBehavior_IsValid(value);
  }
  static constexpr ChannelDowngradeBehavior ChannelDowngradeBehavior_MIN =
    AutoUpdateSettingsProto_ChannelDowngradeBehavior_ChannelDowngradeBehavior_MIN;
  static constexpr ChannelDowngradeBehavior ChannelDowngradeBehavior_MAX =
    AutoUpdateSettingsProto_ChannelDowngradeBehavior_ChannelDowngradeBehavior_MAX;
  static constexpr int ChannelDowngradeBehavior_ARRAYSIZE =
    AutoUpdateSettingsProto_ChannelDowngradeBehavior_ChannelDowngradeBehavior_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ChannelDowngradeBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChannelDowngradeBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChannelDowngradeBehavior_Name.");
    return AutoUpdateSettingsProto_ChannelDowngradeBehavior_Name(enum_t_value);
  }
  static inline bool ChannelDowngradeBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChannelDowngradeBehavior* value) {
    return AutoUpdateSettingsProto_ChannelDowngradeBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedConnectionTypesFieldNumber = 5,
    kTargetVersionPrefixFieldNumber = 2,
    kTargetVersionDisplayNameFieldNumber = 3,
    kDisallowedTimeIntervalsFieldNumber = 12,
    kStagingScheduleFieldNumber = 14,
    kDeviceQuickFixBuildTokenFieldNumber = 15,
    kTargetVersionSelectorFieldNumber = 17,
    kScatterFactorInSecondsFieldNumber = 4,
    kUpdateDisabledFieldNumber = 1,
    kOBSOLETERebootAfterUpdateFieldNumber = 6,
    kHttpDownloadsEnabledFieldNumber = 7,
    kRebootAfterUpdateFieldNumber = 8,
    kP2PEnabledFieldNumber = 9,
    kRollbackAllowedMilestonesFieldNumber = 11,
    kRollbackToTargetVersionFieldNumber = 10,
    kChannelDowngradeBehaviorFieldNumber = 16,
  };
  // repeated .enterprise_management.AutoUpdateSettingsProto.ConnectionType allowed_connection_types = 5;
  int allowed_connection_types_size() const;
  private:
  int _internal_allowed_connection_types_size() const;
  public:
  void clear_allowed_connection_types();
  private:
  ::enterprise_management::AutoUpdateSettingsProto_ConnectionType _internal_allowed_connection_types(int index) const;
  void _internal_add_allowed_connection_types(::enterprise_management::AutoUpdateSettingsProto_ConnectionType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_allowed_connection_types();
  public:
  ::enterprise_management::AutoUpdateSettingsProto_ConnectionType allowed_connection_types(int index) const;
  void set_allowed_connection_types(int index, ::enterprise_management::AutoUpdateSettingsProto_ConnectionType value);
  void add_allowed_connection_types(::enterprise_management::AutoUpdateSettingsProto_ConnectionType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& allowed_connection_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_allowed_connection_types();

  // optional string target_version_prefix = 2;
  bool has_target_version_prefix() const;
  private:
  bool _internal_has_target_version_prefix() const;
  public:
  void clear_target_version_prefix();
  const std::string& target_version_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_version_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_version_prefix();
  PROTOBUF_NODISCARD std::string* release_target_version_prefix();
  void set_allocated_target_version_prefix(std::string* target_version_prefix);
  private:
  const std::string& _internal_target_version_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_version_prefix(const std::string& value);
  std::string* _internal_mutable_target_version_prefix();
  public:

  // optional string target_version_display_name = 3;
  bool has_target_version_display_name() const;
  private:
  bool _internal_has_target_version_display_name() const;
  public:
  void clear_target_version_display_name();
  const std::string& target_version_display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_version_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_version_display_name();
  PROTOBUF_NODISCARD std::string* release_target_version_display_name();
  void set_allocated_target_version_display_name(std::string* target_version_display_name);
  private:
  const std::string& _internal_target_version_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_version_display_name(const std::string& value);
  std::string* _internal_mutable_target_version_display_name();
  public:

  // optional string disallowed_time_intervals = 12;
  bool has_disallowed_time_intervals() const;
  private:
  bool _internal_has_disallowed_time_intervals() const;
  public:
  void clear_disallowed_time_intervals();
  const std::string& disallowed_time_intervals() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_disallowed_time_intervals(ArgT0&& arg0, ArgT... args);
  std::string* mutable_disallowed_time_intervals();
  PROTOBUF_NODISCARD std::string* release_disallowed_time_intervals();
  void set_allocated_disallowed_time_intervals(std::string* disallowed_time_intervals);
  private:
  const std::string& _internal_disallowed_time_intervals() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_disallowed_time_intervals(const std::string& value);
  std::string* _internal_mutable_disallowed_time_intervals();
  public:

  // optional string staging_schedule = 14;
  bool has_staging_schedule() const;
  private:
  bool _internal_has_staging_schedule() const;
  public:
  void clear_staging_schedule();
  const std::string& staging_schedule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_staging_schedule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_staging_schedule();
  PROTOBUF_NODISCARD std::string* release_staging_schedule();
  void set_allocated_staging_schedule(std::string* staging_schedule);
  private:
  const std::string& _internal_staging_schedule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staging_schedule(const std::string& value);
  std::string* _internal_mutable_staging_schedule();
  public:

  // optional string device_quick_fix_build_token = 15;
  bool has_device_quick_fix_build_token() const;
  private:
  bool _internal_has_device_quick_fix_build_token() const;
  public:
  void clear_device_quick_fix_build_token();
  const std::string& device_quick_fix_build_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_quick_fix_build_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_quick_fix_build_token();
  PROTOBUF_NODISCARD std::string* release_device_quick_fix_build_token();
  void set_allocated_device_quick_fix_build_token(std::string* device_quick_fix_build_token);
  private:
  const std::string& _internal_device_quick_fix_build_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_quick_fix_build_token(const std::string& value);
  std::string* _internal_mutable_device_quick_fix_build_token();
  public:

  // optional string target_version_selector = 17;
  bool has_target_version_selector() const;
  private:
  bool _internal_has_target_version_selector() const;
  public:
  void clear_target_version_selector();
  const std::string& target_version_selector() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_version_selector(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_version_selector();
  PROTOBUF_NODISCARD std::string* release_target_version_selector();
  void set_allocated_target_version_selector(std::string* target_version_selector);
  private:
  const std::string& _internal_target_version_selector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_version_selector(const std::string& value);
  std::string* _internal_mutable_target_version_selector();
  public:

  // optional int64 scatter_factor_in_seconds = 4;
  bool has_scatter_factor_in_seconds() const;
  private:
  bool _internal_has_scatter_factor_in_seconds() const;
  public:
  void clear_scatter_factor_in_seconds();
  int64_t scatter_factor_in_seconds() const;
  void set_scatter_factor_in_seconds(int64_t value);
  private:
  int64_t _internal_scatter_factor_in_seconds() const;
  void _internal_set_scatter_factor_in_seconds(int64_t value);
  public:

  // optional bool update_disabled = 1;
  bool has_update_disabled() const;
  private:
  bool _internal_has_update_disabled() const;
  public:
  void clear_update_disabled();
  bool update_disabled() const;
  void set_update_disabled(bool value);
  private:
  bool _internal_update_disabled() const;
  void _internal_set_update_disabled(bool value);
  public:

  // optional bool OBSOLETE_reboot_after_update = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_reboot_after_update() const;
  private:
  bool _internal_has_obsolete_reboot_after_update() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_reboot_after_update();
  PROTOBUF_DEPRECATED bool obsolete_reboot_after_update() const;
  PROTOBUF_DEPRECATED void set_obsolete_reboot_after_update(bool value);
  private:
  bool _internal_obsolete_reboot_after_update() const;
  void _internal_set_obsolete_reboot_after_update(bool value);
  public:

  // optional bool http_downloads_enabled = 7 [default = false];
  bool has_http_downloads_enabled() const;
  private:
  bool _internal_has_http_downloads_enabled() const;
  public:
  void clear_http_downloads_enabled();
  bool http_downloads_enabled() const;
  void set_http_downloads_enabled(bool value);
  private:
  bool _internal_http_downloads_enabled() const;
  void _internal_set_http_downloads_enabled(bool value);
  public:

  // optional bool reboot_after_update = 8;
  bool has_reboot_after_update() const;
  private:
  bool _internal_has_reboot_after_update() const;
  public:
  void clear_reboot_after_update();
  bool reboot_after_update() const;
  void set_reboot_after_update(bool value);
  private:
  bool _internal_reboot_after_update() const;
  void _internal_set_reboot_after_update(bool value);
  public:

  // optional bool p2p_enabled = 9 [default = false];
  bool has_p2p_enabled() const;
  private:
  bool _internal_has_p2p_enabled() const;
  public:
  void clear_p2p_enabled();
  bool p2p_enabled() const;
  void set_p2p_enabled(bool value);
  private:
  bool _internal_p2p_enabled() const;
  void _internal_set_p2p_enabled(bool value);
  public:

  // optional int32 rollback_allowed_milestones = 11 [default = 0];
  bool has_rollback_allowed_milestones() const;
  private:
  bool _internal_has_rollback_allowed_milestones() const;
  public:
  void clear_rollback_allowed_milestones();
  int32_t rollback_allowed_milestones() const;
  void set_rollback_allowed_milestones(int32_t value);
  private:
  int32_t _internal_rollback_allowed_milestones() const;
  void _internal_set_rollback_allowed_milestones(int32_t value);
  public:

  // optional .enterprise_management.AutoUpdateSettingsProto.RollbackToTargetVersion rollback_to_target_version = 10 [default = ROLLBACK_DISABLED];
  bool has_rollback_to_target_version() const;
  private:
  bool _internal_has_rollback_to_target_version() const;
  public:
  void clear_rollback_to_target_version();
  ::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion rollback_to_target_version() const;
  void set_rollback_to_target_version(::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion value);
  private:
  ::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion _internal_rollback_to_target_version() const;
  void _internal_set_rollback_to_target_version(::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion value);
  public:

  // optional .enterprise_management.AutoUpdateSettingsProto.ChannelDowngradeBehavior channel_downgrade_behavior = 16 [default = WAIT_FOR_VERSION_CATCH_UP];
  bool has_channel_downgrade_behavior() const;
  private:
  bool _internal_has_channel_downgrade_behavior() const;
  public:
  void clear_channel_downgrade_behavior();
  ::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior channel_downgrade_behavior() const;
  void set_channel_downgrade_behavior(::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior value);
  private:
  ::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior _internal_channel_downgrade_behavior() const;
  void _internal_set_channel_downgrade_behavior(::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AutoUpdateSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> allowed_connection_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_version_prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_version_display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr disallowed_time_intervals_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staging_schedule_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_quick_fix_build_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_version_selector_;
    int64_t scatter_factor_in_seconds_;
    bool update_disabled_;
    bool obsolete_reboot_after_update_;
    bool http_downloads_enabled_;
    bool reboot_after_update_;
    bool p2p_enabled_;
    int32_t rollback_allowed_milestones_;
    int rollback_to_target_version_;
    int channel_downgrade_behavior_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_StartUpUrlsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_StartUpUrlsProto) */ {
 public:
  inline OBSOLETE_StartUpUrlsProto() : OBSOLETE_StartUpUrlsProto(nullptr) {}
  ~OBSOLETE_StartUpUrlsProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_StartUpUrlsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_StartUpUrlsProto(const OBSOLETE_StartUpUrlsProto& from);
  OBSOLETE_StartUpUrlsProto(OBSOLETE_StartUpUrlsProto&& from) noexcept
    : OBSOLETE_StartUpUrlsProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_StartUpUrlsProto& operator=(const OBSOLETE_StartUpUrlsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_StartUpUrlsProto& operator=(OBSOLETE_StartUpUrlsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_StartUpUrlsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_StartUpUrlsProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_StartUpUrlsProto*>(
               &_OBSOLETE_StartUpUrlsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(OBSOLETE_StartUpUrlsProto& a, OBSOLETE_StartUpUrlsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_StartUpUrlsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_StartUpUrlsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_StartUpUrlsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_StartUpUrlsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_StartUpUrlsProto& from);
  void MergeFrom(const OBSOLETE_StartUpUrlsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_StartUpUrlsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_StartUpUrlsProto";
  }
  protected:
  explicit OBSOLETE_StartUpUrlsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEStartUpUrlsFieldNumber = 1,
  };
  // repeated string OBSOLETE_start_up_urls = 1 [deprecated = true];
  PROTOBUF_DEPRECATED int obsolete_start_up_urls_size() const;
  private:
  int _internal_obsolete_start_up_urls_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_start_up_urls();
  PROTOBUF_DEPRECATED const std::string& obsolete_start_up_urls(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_start_up_urls(int index);
  PROTOBUF_DEPRECATED void set_obsolete_start_up_urls(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_obsolete_start_up_urls(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_obsolete_start_up_urls(int index, const char* value);
  PROTOBUF_DEPRECATED void set_obsolete_start_up_urls(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_obsolete_start_up_urls();
  PROTOBUF_DEPRECATED void add_obsolete_start_up_urls(const std::string& value);
  PROTOBUF_DEPRECATED void add_obsolete_start_up_urls(std::string&& value);
  PROTOBUF_DEPRECATED void add_obsolete_start_up_urls(const char* value);
  PROTOBUF_DEPRECATED void add_obsolete_start_up_urls(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& obsolete_start_up_urls() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_obsolete_start_up_urls();
  private:
  const std::string& _internal_obsolete_start_up_urls(int index) const;
  std::string* _internal_add_obsolete_start_up_urls();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_StartUpUrlsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> obsolete_start_up_urls_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SystemTimezoneProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemTimezoneProto) */ {
 public:
  inline SystemTimezoneProto() : SystemTimezoneProto(nullptr) {}
  ~SystemTimezoneProto() override;
  explicit PROTOBUF_CONSTEXPR SystemTimezoneProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemTimezoneProto(const SystemTimezoneProto& from);
  SystemTimezoneProto(SystemTimezoneProto&& from) noexcept
    : SystemTimezoneProto() {
    *this = ::std::move(from);
  }

  inline SystemTimezoneProto& operator=(const SystemTimezoneProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemTimezoneProto& operator=(SystemTimezoneProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SystemTimezoneProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemTimezoneProto* internal_default_instance() {
    return reinterpret_cast<const SystemTimezoneProto*>(
               &_SystemTimezoneProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SystemTimezoneProto& a, SystemTimezoneProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemTimezoneProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemTimezoneProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemTimezoneProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemTimezoneProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemTimezoneProto& from);
  void MergeFrom(const SystemTimezoneProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemTimezoneProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SystemTimezoneProto";
  }
  protected:
  explicit SystemTimezoneProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SystemTimezoneProto_AutomaticTimezoneDetectionType AutomaticTimezoneDetectionType;
  static constexpr AutomaticTimezoneDetectionType USERS_DECIDE =
    SystemTimezoneProto_AutomaticTimezoneDetectionType_USERS_DECIDE;
  static constexpr AutomaticTimezoneDetectionType DISABLED =
    SystemTimezoneProto_AutomaticTimezoneDetectionType_DISABLED;
  static constexpr AutomaticTimezoneDetectionType IP_ONLY =
    SystemTimezoneProto_AutomaticTimezoneDetectionType_IP_ONLY;
  static constexpr AutomaticTimezoneDetectionType SEND_WIFI_ACCESS_POINTS =
    SystemTimezoneProto_AutomaticTimezoneDetectionType_SEND_WIFI_ACCESS_POINTS;
  static constexpr AutomaticTimezoneDetectionType SEND_ALL_LOCATION_INFO =
    SystemTimezoneProto_AutomaticTimezoneDetectionType_SEND_ALL_LOCATION_INFO;
  static inline bool AutomaticTimezoneDetectionType_IsValid(int value) {
    return SystemTimezoneProto_AutomaticTimezoneDetectionType_IsValid(value);
  }
  static constexpr AutomaticTimezoneDetectionType AutomaticTimezoneDetectionType_MIN =
    SystemTimezoneProto_AutomaticTimezoneDetectionType_AutomaticTimezoneDetectionType_MIN;
  static constexpr AutomaticTimezoneDetectionType AutomaticTimezoneDetectionType_MAX =
    SystemTimezoneProto_AutomaticTimezoneDetectionType_AutomaticTimezoneDetectionType_MAX;
  static constexpr int AutomaticTimezoneDetectionType_ARRAYSIZE =
    SystemTimezoneProto_AutomaticTimezoneDetectionType_AutomaticTimezoneDetectionType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AutomaticTimezoneDetectionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AutomaticTimezoneDetectionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AutomaticTimezoneDetectionType_Name.");
    return SystemTimezoneProto_AutomaticTimezoneDetectionType_Name(enum_t_value);
  }
  static inline bool AutomaticTimezoneDetectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AutomaticTimezoneDetectionType* value) {
    return SystemTimezoneProto_AutomaticTimezoneDetectionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimezoneFieldNumber = 1,
    kTimezoneDetectionTypeFieldNumber = 2,
  };
  // optional string timezone = 1;
  bool has_timezone() const;
  private:
  bool _internal_has_timezone() const;
  public:
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // optional .enterprise_management.SystemTimezoneProto.AutomaticTimezoneDetectionType timezone_detection_type = 2;
  bool has_timezone_detection_type() const;
  private:
  bool _internal_has_timezone_detection_type() const;
  public:
  void clear_timezone_detection_type();
  ::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType timezone_detection_type() const;
  void set_timezone_detection_type(::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType value);
  private:
  ::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType _internal_timezone_detection_type() const;
  void _internal_set_timezone_detection_type(::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SystemTimezoneProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
    int timezone_detection_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SystemUse24HourClockProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemUse24HourClockProto) */ {
 public:
  inline SystemUse24HourClockProto() : SystemUse24HourClockProto(nullptr) {}
  ~SystemUse24HourClockProto() override;
  explicit PROTOBUF_CONSTEXPR SystemUse24HourClockProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemUse24HourClockProto(const SystemUse24HourClockProto& from);
  SystemUse24HourClockProto(SystemUse24HourClockProto&& from) noexcept
    : SystemUse24HourClockProto() {
    *this = ::std::move(from);
  }

  inline SystemUse24HourClockProto& operator=(const SystemUse24HourClockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemUse24HourClockProto& operator=(SystemUse24HourClockProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SystemUse24HourClockProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemUse24HourClockProto* internal_default_instance() {
    return reinterpret_cast<const SystemUse24HourClockProto*>(
               &_SystemUse24HourClockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SystemUse24HourClockProto& a, SystemUse24HourClockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemUse24HourClockProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemUse24HourClockProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemUse24HourClockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemUse24HourClockProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemUse24HourClockProto& from);
  void MergeFrom(const SystemUse24HourClockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemUse24HourClockProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SystemUse24HourClockProto";
  }
  protected:
  explicit SystemUse24HourClockProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUse24HourClockFieldNumber = 1,
  };
  // optional bool use_24hour_clock = 1;
  bool has_use_24hour_clock() const;
  private:
  bool _internal_has_use_24hour_clock() const;
  public:
  void clear_use_24hour_clock();
  bool use_24hour_clock() const;
  void set_use_24hour_clock(bool value);
  private:
  bool _internal_use_24hour_clock() const;
  void _internal_set_use_24hour_clock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SystemUse24HourClockProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool use_24hour_clock_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class KioskAppInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.KioskAppInfoProto) */ {
 public:
  inline KioskAppInfoProto() : KioskAppInfoProto(nullptr) {}
  ~KioskAppInfoProto() override;
  explicit PROTOBUF_CONSTEXPR KioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KioskAppInfoProto(const KioskAppInfoProto& from);
  KioskAppInfoProto(KioskAppInfoProto&& from) noexcept
    : KioskAppInfoProto() {
    *this = ::std::move(from);
  }

  inline KioskAppInfoProto& operator=(const KioskAppInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline KioskAppInfoProto& operator=(KioskAppInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KioskAppInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const KioskAppInfoProto* internal_default_instance() {
    return reinterpret_cast<const KioskAppInfoProto*>(
               &_KioskAppInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(KioskAppInfoProto& a, KioskAppInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(KioskAppInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KioskAppInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KioskAppInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KioskAppInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KioskAppInfoProto& from);
  void MergeFrom(const KioskAppInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KioskAppInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.KioskAppInfoProto";
  }
  protected:
  explicit KioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kUpdateUrlFieldNumber = 2,
  };
  // optional string app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // optional string update_url = 2;
  bool has_update_url() const;
  private:
  bool _internal_has_update_url() const;
  public:
  void clear_update_url();
  const std::string& update_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_url();
  PROTOBUF_NODISCARD std::string* release_update_url();
  void set_allocated_update_url(std::string* update_url);
  private:
  const std::string& _internal_update_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_url(const std::string& value);
  std::string* _internal_mutable_update_url();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.KioskAppInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_url_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AndroidKioskAppInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AndroidKioskAppInfoProto) */ {
 public:
  inline AndroidKioskAppInfoProto() : AndroidKioskAppInfoProto(nullptr) {}
  ~AndroidKioskAppInfoProto() override;
  explicit PROTOBUF_CONSTEXPR AndroidKioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AndroidKioskAppInfoProto(const AndroidKioskAppInfoProto& from);
  AndroidKioskAppInfoProto(AndroidKioskAppInfoProto&& from) noexcept
    : AndroidKioskAppInfoProto() {
    *this = ::std::move(from);
  }

  inline AndroidKioskAppInfoProto& operator=(const AndroidKioskAppInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndroidKioskAppInfoProto& operator=(AndroidKioskAppInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AndroidKioskAppInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndroidKioskAppInfoProto* internal_default_instance() {
    return reinterpret_cast<const AndroidKioskAppInfoProto*>(
               &_AndroidKioskAppInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AndroidKioskAppInfoProto& a, AndroidKioskAppInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AndroidKioskAppInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndroidKioskAppInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndroidKioskAppInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AndroidKioskAppInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AndroidKioskAppInfoProto& from);
  void MergeFrom(const AndroidKioskAppInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidKioskAppInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AndroidKioskAppInfoProto";
  }
  protected:
  explicit AndroidKioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kClassNameFieldNumber = 2,
    kActionFieldNumber = 3,
    kDisplayNameFieldNumber = 4,
  };
  // optional string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // optional string class_name = 2;
  bool has_class_name() const;
  private:
  bool _internal_has_class_name() const;
  public:
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // optional string action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // optional string display_name = 4;
  bool has_display_name() const;
  private:
  bool _internal_has_display_name() const;
  public:
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AndroidKioskAppInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class WebKioskAppInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.WebKioskAppInfoProto) */ {
 public:
  inline WebKioskAppInfoProto() : WebKioskAppInfoProto(nullptr) {}
  ~WebKioskAppInfoProto() override;
  explicit PROTOBUF_CONSTEXPR WebKioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebKioskAppInfoProto(const WebKioskAppInfoProto& from);
  WebKioskAppInfoProto(WebKioskAppInfoProto&& from) noexcept
    : WebKioskAppInfoProto() {
    *this = ::std::move(from);
  }

  inline WebKioskAppInfoProto& operator=(const WebKioskAppInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebKioskAppInfoProto& operator=(WebKioskAppInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WebKioskAppInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebKioskAppInfoProto* internal_default_instance() {
    return reinterpret_cast<const WebKioskAppInfoProto*>(
               &_WebKioskAppInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(WebKioskAppInfoProto& a, WebKioskAppInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(WebKioskAppInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebKioskAppInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebKioskAppInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebKioskAppInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WebKioskAppInfoProto& from);
  void MergeFrom(const WebKioskAppInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WebKioskAppInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.WebKioskAppInfoProto";
  }
  protected:
  explicit WebKioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kTitleFieldNumber = 2,
    kIconUrlFieldNumber = 3,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string icon_url = 3;
  bool has_icon_url() const;
  private:
  bool _internal_has_icon_url() const;
  public:
  void clear_icon_url();
  const std::string& icon_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon_url();
  PROTOBUF_NODISCARD std::string* release_icon_url();
  void set_allocated_icon_url(std::string* icon_url);
  private:
  const std::string& _internal_icon_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon_url(const std::string& value);
  std::string* _internal_mutable_icon_url();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.WebKioskAppInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_url_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceLocalAccountInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceLocalAccountInfoProto) */ {
 public:
  inline DeviceLocalAccountInfoProto() : DeviceLocalAccountInfoProto(nullptr) {}
  ~DeviceLocalAccountInfoProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceLocalAccountInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLocalAccountInfoProto(const DeviceLocalAccountInfoProto& from);
  DeviceLocalAccountInfoProto(DeviceLocalAccountInfoProto&& from) noexcept
    : DeviceLocalAccountInfoProto() {
    *this = ::std::move(from);
  }

  inline DeviceLocalAccountInfoProto& operator=(const DeviceLocalAccountInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLocalAccountInfoProto& operator=(DeviceLocalAccountInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceLocalAccountInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLocalAccountInfoProto* internal_default_instance() {
    return reinterpret_cast<const DeviceLocalAccountInfoProto*>(
               &_DeviceLocalAccountInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DeviceLocalAccountInfoProto& a, DeviceLocalAccountInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLocalAccountInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLocalAccountInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLocalAccountInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLocalAccountInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceLocalAccountInfoProto& from);
  void MergeFrom(const DeviceLocalAccountInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceLocalAccountInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceLocalAccountInfoProto";
  }
  protected:
  explicit DeviceLocalAccountInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceLocalAccountInfoProto_AccountType AccountType;
  static constexpr AccountType ACCOUNT_TYPE_PUBLIC_SESSION =
    DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_PUBLIC_SESSION;
  static constexpr AccountType ACCOUNT_TYPE_KIOSK_APP =
    DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_KIOSK_APP;
  static constexpr AccountType ACCOUNT_TYPE_KIOSK_ANDROID_APP =
    DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_KIOSK_ANDROID_APP;
  static constexpr AccountType ACCOUNT_TYPE_SAML_PUBLIC_SESSION =
    DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_SAML_PUBLIC_SESSION;
  static constexpr AccountType ACCOUNT_TYPE_WEB_KIOSK_APP =
    DeviceLocalAccountInfoProto_AccountType_ACCOUNT_TYPE_WEB_KIOSK_APP;
  static inline bool AccountType_IsValid(int value) {
    return DeviceLocalAccountInfoProto_AccountType_IsValid(value);
  }
  static constexpr AccountType AccountType_MIN =
    DeviceLocalAccountInfoProto_AccountType_AccountType_MIN;
  static constexpr AccountType AccountType_MAX =
    DeviceLocalAccountInfoProto_AccountType_AccountType_MAX;
  static constexpr int AccountType_ARRAYSIZE =
    DeviceLocalAccountInfoProto_AccountType_AccountType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AccountType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AccountType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AccountType_Name.");
    return DeviceLocalAccountInfoProto_AccountType_Name(enum_t_value);
  }
  static inline bool AccountType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AccountType* value) {
    return DeviceLocalAccountInfoProto_AccountType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeprecatedPublicSessionIdFieldNumber = 1,
    kAccountIdFieldNumber = 2,
    kKioskAppFieldNumber = 4,
    kAndroidKioskAppFieldNumber = 5,
    kWebKioskAppFieldNumber = 6,
    kTypeFieldNumber = 3,
  };
  // optional string deprecated_public_session_id = 1;
  bool has_deprecated_public_session_id() const;
  private:
  bool _internal_has_deprecated_public_session_id() const;
  public:
  void clear_deprecated_public_session_id();
  const std::string& deprecated_public_session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deprecated_public_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deprecated_public_session_id();
  PROTOBUF_NODISCARD std::string* release_deprecated_public_session_id();
  void set_allocated_deprecated_public_session_id(std::string* deprecated_public_session_id);
  private:
  const std::string& _internal_deprecated_public_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecated_public_session_id(const std::string& value);
  std::string* _internal_mutable_deprecated_public_session_id();
  public:

  // optional string account_id = 2;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // optional .enterprise_management.KioskAppInfoProto kiosk_app = 4;
  bool has_kiosk_app() const;
  private:
  bool _internal_has_kiosk_app() const;
  public:
  void clear_kiosk_app();
  const ::enterprise_management::KioskAppInfoProto& kiosk_app() const;
  PROTOBUF_NODISCARD ::enterprise_management::KioskAppInfoProto* release_kiosk_app();
  ::enterprise_management::KioskAppInfoProto* mutable_kiosk_app();
  void set_allocated_kiosk_app(::enterprise_management::KioskAppInfoProto* kiosk_app);
  private:
  const ::enterprise_management::KioskAppInfoProto& _internal_kiosk_app() const;
  ::enterprise_management::KioskAppInfoProto* _internal_mutable_kiosk_app();
  public:
  void unsafe_arena_set_allocated_kiosk_app(
      ::enterprise_management::KioskAppInfoProto* kiosk_app);
  ::enterprise_management::KioskAppInfoProto* unsafe_arena_release_kiosk_app();

  // optional .enterprise_management.AndroidKioskAppInfoProto android_kiosk_app = 5;
  bool has_android_kiosk_app() const;
  private:
  bool _internal_has_android_kiosk_app() const;
  public:
  void clear_android_kiosk_app();
  const ::enterprise_management::AndroidKioskAppInfoProto& android_kiosk_app() const;
  PROTOBUF_NODISCARD ::enterprise_management::AndroidKioskAppInfoProto* release_android_kiosk_app();
  ::enterprise_management::AndroidKioskAppInfoProto* mutable_android_kiosk_app();
  void set_allocated_android_kiosk_app(::enterprise_management::AndroidKioskAppInfoProto* android_kiosk_app);
  private:
  const ::enterprise_management::AndroidKioskAppInfoProto& _internal_android_kiosk_app() const;
  ::enterprise_management::AndroidKioskAppInfoProto* _internal_mutable_android_kiosk_app();
  public:
  void unsafe_arena_set_allocated_android_kiosk_app(
      ::enterprise_management::AndroidKioskAppInfoProto* android_kiosk_app);
  ::enterprise_management::AndroidKioskAppInfoProto* unsafe_arena_release_android_kiosk_app();

  // optional .enterprise_management.WebKioskAppInfoProto web_kiosk_app = 6;
  bool has_web_kiosk_app() const;
  private:
  bool _internal_has_web_kiosk_app() const;
  public:
  void clear_web_kiosk_app();
  const ::enterprise_management::WebKioskAppInfoProto& web_kiosk_app() const;
  PROTOBUF_NODISCARD ::enterprise_management::WebKioskAppInfoProto* release_web_kiosk_app();
  ::enterprise_management::WebKioskAppInfoProto* mutable_web_kiosk_app();
  void set_allocated_web_kiosk_app(::enterprise_management::WebKioskAppInfoProto* web_kiosk_app);
  private:
  const ::enterprise_management::WebKioskAppInfoProto& _internal_web_kiosk_app() const;
  ::enterprise_management::WebKioskAppInfoProto* _internal_mutable_web_kiosk_app();
  public:
  void unsafe_arena_set_allocated_web_kiosk_app(
      ::enterprise_management::WebKioskAppInfoProto* web_kiosk_app);
  ::enterprise_management::WebKioskAppInfoProto* unsafe_arena_release_web_kiosk_app();

  // optional .enterprise_management.DeviceLocalAccountInfoProto.AccountType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::enterprise_management::DeviceLocalAccountInfoProto_AccountType type() const;
  void set_type(::enterprise_management::DeviceLocalAccountInfoProto_AccountType value);
  private:
  ::enterprise_management::DeviceLocalAccountInfoProto_AccountType _internal_type() const;
  void _internal_set_type(::enterprise_management::DeviceLocalAccountInfoProto_AccountType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceLocalAccountInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecated_public_session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::enterprise_management::KioskAppInfoProto* kiosk_app_;
    ::enterprise_management::AndroidKioskAppInfoProto* android_kiosk_app_;
    ::enterprise_management::WebKioskAppInfoProto* web_kiosk_app_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceLocalAccountsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceLocalAccountsProto) */ {
 public:
  inline DeviceLocalAccountsProto() : DeviceLocalAccountsProto(nullptr) {}
  ~DeviceLocalAccountsProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceLocalAccountsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLocalAccountsProto(const DeviceLocalAccountsProto& from);
  DeviceLocalAccountsProto(DeviceLocalAccountsProto&& from) noexcept
    : DeviceLocalAccountsProto() {
    *this = ::std::move(from);
  }

  inline DeviceLocalAccountsProto& operator=(const DeviceLocalAccountsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLocalAccountsProto& operator=(DeviceLocalAccountsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceLocalAccountsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLocalAccountsProto* internal_default_instance() {
    return reinterpret_cast<const DeviceLocalAccountsProto*>(
               &_DeviceLocalAccountsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DeviceLocalAccountsProto& a, DeviceLocalAccountsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLocalAccountsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLocalAccountsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLocalAccountsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLocalAccountsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceLocalAccountsProto& from);
  void MergeFrom(const DeviceLocalAccountsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceLocalAccountsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceLocalAccountsProto";
  }
  protected:
  explicit DeviceLocalAccountsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kAutoLoginIdFieldNumber = 2,
    kAutoLoginDelayFieldNumber = 3,
    kEnableAutoLoginBailoutFieldNumber = 4,
    kPromptForNetworkWhenOfflineFieldNumber = 5,
  };
  // repeated .enterprise_management.DeviceLocalAccountInfoProto account = 1;
  int account_size() const;
  private:
  int _internal_account_size() const;
  public:
  void clear_account();
  ::enterprise_management::DeviceLocalAccountInfoProto* mutable_account(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceLocalAccountInfoProto >*
      mutable_account();
  private:
  const ::enterprise_management::DeviceLocalAccountInfoProto& _internal_account(int index) const;
  ::enterprise_management::DeviceLocalAccountInfoProto* _internal_add_account();
  public:
  const ::enterprise_management::DeviceLocalAccountInfoProto& account(int index) const;
  ::enterprise_management::DeviceLocalAccountInfoProto* add_account();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceLocalAccountInfoProto >&
      account() const;

  // optional string auto_login_id = 2;
  bool has_auto_login_id() const;
  private:
  bool _internal_has_auto_login_id() const;
  public:
  void clear_auto_login_id();
  const std::string& auto_login_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auto_login_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auto_login_id();
  PROTOBUF_NODISCARD std::string* release_auto_login_id();
  void set_allocated_auto_login_id(std::string* auto_login_id);
  private:
  const std::string& _internal_auto_login_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auto_login_id(const std::string& value);
  std::string* _internal_mutable_auto_login_id();
  public:

  // optional int64 auto_login_delay = 3;
  bool has_auto_login_delay() const;
  private:
  bool _internal_has_auto_login_delay() const;
  public:
  void clear_auto_login_delay();
  int64_t auto_login_delay() const;
  void set_auto_login_delay(int64_t value);
  private:
  int64_t _internal_auto_login_delay() const;
  void _internal_set_auto_login_delay(int64_t value);
  public:

  // optional bool enable_auto_login_bailout = 4 [default = true];
  bool has_enable_auto_login_bailout() const;
  private:
  bool _internal_has_enable_auto_login_bailout() const;
  public:
  void clear_enable_auto_login_bailout();
  bool enable_auto_login_bailout() const;
  void set_enable_auto_login_bailout(bool value);
  private:
  bool _internal_enable_auto_login_bailout() const;
  void _internal_set_enable_auto_login_bailout(bool value);
  public:

  // optional bool prompt_for_network_when_offline = 5 [default = true];
  bool has_prompt_for_network_when_offline() const;
  private:
  bool _internal_has_prompt_for_network_when_offline() const;
  public:
  void clear_prompt_for_network_when_offline();
  bool prompt_for_network_when_offline() const;
  void set_prompt_for_network_when_offline(bool value);
  private:
  bool _internal_prompt_for_network_when_offline() const;
  void _internal_set_prompt_for_network_when_offline(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceLocalAccountsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceLocalAccountInfoProto > account_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auto_login_id_;
    int64_t auto_login_delay_;
    bool enable_auto_login_bailout_;
    bool prompt_for_network_when_offline_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class ManagedGuestSessionPrivacyWarningsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ManagedGuestSessionPrivacyWarningsProto) */ {
 public:
  inline ManagedGuestSessionPrivacyWarningsProto() : ManagedGuestSessionPrivacyWarningsProto(nullptr) {}
  ~ManagedGuestSessionPrivacyWarningsProto() override;
  explicit PROTOBUF_CONSTEXPR ManagedGuestSessionPrivacyWarningsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManagedGuestSessionPrivacyWarningsProto(const ManagedGuestSessionPrivacyWarningsProto& from);
  ManagedGuestSessionPrivacyWarningsProto(ManagedGuestSessionPrivacyWarningsProto&& from) noexcept
    : ManagedGuestSessionPrivacyWarningsProto() {
    *this = ::std::move(from);
  }

  inline ManagedGuestSessionPrivacyWarningsProto& operator=(const ManagedGuestSessionPrivacyWarningsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManagedGuestSessionPrivacyWarningsProto& operator=(ManagedGuestSessionPrivacyWarningsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ManagedGuestSessionPrivacyWarningsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManagedGuestSessionPrivacyWarningsProto* internal_default_instance() {
    return reinterpret_cast<const ManagedGuestSessionPrivacyWarningsProto*>(
               &_ManagedGuestSessionPrivacyWarningsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ManagedGuestSessionPrivacyWarningsProto& a, ManagedGuestSessionPrivacyWarningsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ManagedGuestSessionPrivacyWarningsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManagedGuestSessionPrivacyWarningsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManagedGuestSessionPrivacyWarningsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManagedGuestSessionPrivacyWarningsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ManagedGuestSessionPrivacyWarningsProto& from);
  void MergeFrom(const ManagedGuestSessionPrivacyWarningsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ManagedGuestSessionPrivacyWarningsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ManagedGuestSessionPrivacyWarningsProto";
  }
  protected:
  explicit ManagedGuestSessionPrivacyWarningsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AllowRedeemChromeOsRegistrationOffersProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto) */ {
 public:
  inline AllowRedeemChromeOsRegistrationOffersProto() : AllowRedeemChromeOsRegistrationOffersProto(nullptr) {}
  ~AllowRedeemChromeOsRegistrationOffersProto() override;
  explicit PROTOBUF_CONSTEXPR AllowRedeemChromeOsRegistrationOffersProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowRedeemChromeOsRegistrationOffersProto(const AllowRedeemChromeOsRegistrationOffersProto& from);
  AllowRedeemChromeOsRegistrationOffersProto(AllowRedeemChromeOsRegistrationOffersProto&& from) noexcept
    : AllowRedeemChromeOsRegistrationOffersProto() {
    *this = ::std::move(from);
  }

  inline AllowRedeemChromeOsRegistrationOffersProto& operator=(const AllowRedeemChromeOsRegistrationOffersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowRedeemChromeOsRegistrationOffersProto& operator=(AllowRedeemChromeOsRegistrationOffersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AllowRedeemChromeOsRegistrationOffersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowRedeemChromeOsRegistrationOffersProto* internal_default_instance() {
    return reinterpret_cast<const AllowRedeemChromeOsRegistrationOffersProto*>(
               &_AllowRedeemChromeOsRegistrationOffersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AllowRedeemChromeOsRegistrationOffersProto& a, AllowRedeemChromeOsRegistrationOffersProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowRedeemChromeOsRegistrationOffersProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowRedeemChromeOsRegistrationOffersProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowRedeemChromeOsRegistrationOffersProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllowRedeemChromeOsRegistrationOffersProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AllowRedeemChromeOsRegistrationOffersProto& from);
  void MergeFrom(const AllowRedeemChromeOsRegistrationOffersProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllowRedeemChromeOsRegistrationOffersProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AllowRedeemChromeOsRegistrationOffersProto";
  }
  protected:
  explicit AllowRedeemChromeOsRegistrationOffersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowRedeemOffersFieldNumber = 1,
  };
  // optional bool allow_redeem_offers = 1 [default = true];
  bool has_allow_redeem_offers() const;
  private:
  bool _internal_has_allow_redeem_offers() const;
  public:
  void clear_allow_redeem_offers();
  bool allow_redeem_offers() const;
  void set_allow_redeem_offers(bool value);
  private:
  bool _internal_allow_redeem_offers() const;
  void _internal_set_allow_redeem_offers(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool allow_redeem_offers_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class FeatureFlagsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.FeatureFlagsProto) */ {
 public:
  inline FeatureFlagsProto() : FeatureFlagsProto(nullptr) {}
  ~FeatureFlagsProto() override;
  explicit PROTOBUF_CONSTEXPR FeatureFlagsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeatureFlagsProto(const FeatureFlagsProto& from);
  FeatureFlagsProto(FeatureFlagsProto&& from) noexcept
    : FeatureFlagsProto() {
    *this = ::std::move(from);
  }

  inline FeatureFlagsProto& operator=(const FeatureFlagsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureFlagsProto& operator=(FeatureFlagsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FeatureFlagsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureFlagsProto* internal_default_instance() {
    return reinterpret_cast<const FeatureFlagsProto*>(
               &_FeatureFlagsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(FeatureFlagsProto& a, FeatureFlagsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureFlagsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureFlagsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureFlagsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeatureFlagsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FeatureFlagsProto& from);
  void MergeFrom(const FeatureFlagsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureFlagsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.FeatureFlagsProto";
  }
  protected:
  explicit FeatureFlagsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSwitchesFieldNumber = 1,
    kFeatureFlagsFieldNumber = 2,
  };
  // repeated string switches = 1 [deprecated = true];
  PROTOBUF_DEPRECATED int switches_size() const;
  private:
  int _internal_switches_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_switches();
  PROTOBUF_DEPRECATED const std::string& switches(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_switches(int index);
  PROTOBUF_DEPRECATED void set_switches(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_switches(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_switches(int index, const char* value);
  PROTOBUF_DEPRECATED void set_switches(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_switches();
  PROTOBUF_DEPRECATED void add_switches(const std::string& value);
  PROTOBUF_DEPRECATED void add_switches(std::string&& value);
  PROTOBUF_DEPRECATED void add_switches(const char* value);
  PROTOBUF_DEPRECATED void add_switches(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& switches() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_switches();
  private:
  const std::string& _internal_switches(int index) const;
  std::string* _internal_add_switches();
  public:

  // repeated string feature_flags = 2;
  int feature_flags_size() const;
  private:
  int _internal_feature_flags_size() const;
  public:
  void clear_feature_flags();
  const std::string& feature_flags(int index) const;
  std::string* mutable_feature_flags(int index);
  void set_feature_flags(int index, const std::string& value);
  void set_feature_flags(int index, std::string&& value);
  void set_feature_flags(int index, const char* value);
  void set_feature_flags(int index, const char* value, size_t size);
  std::string* add_feature_flags();
  void add_feature_flags(const std::string& value);
  void add_feature_flags(std::string&& value);
  void add_feature_flags(const char* value);
  void add_feature_flags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& feature_flags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_feature_flags();
  private:
  const std::string& _internal_feature_flags(int index) const;
  std::string* _internal_add_feature_flags();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.FeatureFlagsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> switches_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> feature_flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class UptimeLimitProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UptimeLimitProto) */ {
 public:
  inline UptimeLimitProto() : UptimeLimitProto(nullptr) {}
  ~UptimeLimitProto() override;
  explicit PROTOBUF_CONSTEXPR UptimeLimitProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeLimitProto(const UptimeLimitProto& from);
  UptimeLimitProto(UptimeLimitProto&& from) noexcept
    : UptimeLimitProto() {
    *this = ::std::move(from);
  }

  inline UptimeLimitProto& operator=(const UptimeLimitProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeLimitProto& operator=(UptimeLimitProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UptimeLimitProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UptimeLimitProto* internal_default_instance() {
    return reinterpret_cast<const UptimeLimitProto*>(
               &_UptimeLimitProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UptimeLimitProto& a, UptimeLimitProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeLimitProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeLimitProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeLimitProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeLimitProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UptimeLimitProto& from);
  void MergeFrom(const UptimeLimitProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UptimeLimitProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UptimeLimitProto";
  }
  protected:
  explicit UptimeLimitProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEUptimeLimitFieldNumber = 1,
    kUptimeLimitFieldNumber = 2,
  };
  // optional int64 OBSOLETE_uptime_limit = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_uptime_limit() const;
  private:
  bool _internal_has_obsolete_uptime_limit() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_uptime_limit();
  PROTOBUF_DEPRECATED int64_t obsolete_uptime_limit() const;
  PROTOBUF_DEPRECATED void set_obsolete_uptime_limit(int64_t value);
  private:
  int64_t _internal_obsolete_uptime_limit() const;
  void _internal_set_obsolete_uptime_limit(int64_t value);
  public:

  // optional int64 uptime_limit = 2;
  bool has_uptime_limit() const;
  private:
  bool _internal_has_uptime_limit() const;
  public:
  void clear_uptime_limit();
  int64_t uptime_limit() const;
  void set_uptime_limit(int64_t value);
  private:
  int64_t _internal_uptime_limit() const;
  void _internal_set_uptime_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.UptimeLimitProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t obsolete_uptime_limit_;
    int64_t uptime_limit_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class VariationsParameterProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.VariationsParameterProto) */ {
 public:
  inline VariationsParameterProto() : VariationsParameterProto(nullptr) {}
  ~VariationsParameterProto() override;
  explicit PROTOBUF_CONSTEXPR VariationsParameterProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VariationsParameterProto(const VariationsParameterProto& from);
  VariationsParameterProto(VariationsParameterProto&& from) noexcept
    : VariationsParameterProto() {
    *this = ::std::move(from);
  }

  inline VariationsParameterProto& operator=(const VariationsParameterProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline VariationsParameterProto& operator=(VariationsParameterProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VariationsParameterProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const VariationsParameterProto* internal_default_instance() {
    return reinterpret_cast<const VariationsParameterProto*>(
               &_VariationsParameterProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(VariationsParameterProto& a, VariationsParameterProto& b) {
    a.Swap(&b);
  }
  inline void Swap(VariationsParameterProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VariationsParameterProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VariationsParameterProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VariationsParameterProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VariationsParameterProto& from);
  void MergeFrom(const VariationsParameterProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VariationsParameterProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.VariationsParameterProto";
  }
  protected:
  explicit VariationsParameterProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParameterFieldNumber = 1,
  };
  // optional string parameter = 1;
  bool has_parameter() const;
  private:
  bool _internal_has_parameter() const;
  public:
  void clear_parameter();
  const std::string& parameter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parameter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parameter();
  PROTOBUF_NODISCARD std::string* release_parameter();
  void set_allocated_parameter(std::string* parameter);
  private:
  const std::string& _internal_parameter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter(const std::string& value);
  std::string* _internal_mutable_parameter();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.VariationsParameterProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AttestationSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AttestationSettingsProto) */ {
 public:
  inline AttestationSettingsProto() : AttestationSettingsProto(nullptr) {}
  ~AttestationSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR AttestationSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttestationSettingsProto(const AttestationSettingsProto& from);
  AttestationSettingsProto(AttestationSettingsProto&& from) noexcept
    : AttestationSettingsProto() {
    *this = ::std::move(from);
  }

  inline AttestationSettingsProto& operator=(const AttestationSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttestationSettingsProto& operator=(AttestationSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AttestationSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttestationSettingsProto* internal_default_instance() {
    return reinterpret_cast<const AttestationSettingsProto*>(
               &_AttestationSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(AttestationSettingsProto& a, AttestationSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AttestationSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttestationSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttestationSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttestationSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AttestationSettingsProto& from);
  void MergeFrom(const AttestationSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttestationSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AttestationSettingsProto";
  }
  protected:
  explicit AttestationSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttestationEnabledFieldNumber = 1,
    kContentProtectionEnabledFieldNumber = 2,
  };
  // optional bool attestation_enabled = 1 [default = false];
  bool has_attestation_enabled() const;
  private:
  bool _internal_has_attestation_enabled() const;
  public:
  void clear_attestation_enabled();
  bool attestation_enabled() const;
  void set_attestation_enabled(bool value);
  private:
  bool _internal_attestation_enabled() const;
  void _internal_set_attestation_enabled(bool value);
  public:

  // optional bool content_protection_enabled = 2 [default = true];
  bool has_content_protection_enabled() const;
  private:
  bool _internal_has_content_protection_enabled() const;
  public:
  void clear_content_protection_enabled();
  bool content_protection_enabled() const;
  void set_content_protection_enabled(bool value);
  private:
  bool _internal_content_protection_enabled() const;
  void _internal_set_content_protection_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AttestationSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool attestation_enabled_;
    bool content_protection_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AccessibilitySettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AccessibilitySettingsProto) */ {
 public:
  inline AccessibilitySettingsProto() : AccessibilitySettingsProto(nullptr) {}
  ~AccessibilitySettingsProto() override;
  explicit PROTOBUF_CONSTEXPR AccessibilitySettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccessibilitySettingsProto(const AccessibilitySettingsProto& from);
  AccessibilitySettingsProto(AccessibilitySettingsProto&& from) noexcept
    : AccessibilitySettingsProto() {
    *this = ::std::move(from);
  }

  inline AccessibilitySettingsProto& operator=(const AccessibilitySettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessibilitySettingsProto& operator=(AccessibilitySettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AccessibilitySettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessibilitySettingsProto* internal_default_instance() {
    return reinterpret_cast<const AccessibilitySettingsProto*>(
               &_AccessibilitySettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(AccessibilitySettingsProto& a, AccessibilitySettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AccessibilitySettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessibilitySettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessibilitySettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccessibilitySettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AccessibilitySettingsProto& from);
  void MergeFrom(const AccessibilitySettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AccessibilitySettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AccessibilitySettingsProto";
  }
  protected:
  explicit AccessibilitySettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AccessibilitySettingsProto_ScreenMagnifierType ScreenMagnifierType;
  static constexpr ScreenMagnifierType SCREEN_MAGNIFIER_TYPE_NONE =
    AccessibilitySettingsProto_ScreenMagnifierType_SCREEN_MAGNIFIER_TYPE_NONE;
  static constexpr ScreenMagnifierType SCREEN_MAGNIFIER_TYPE_FULL =
    AccessibilitySettingsProto_ScreenMagnifierType_SCREEN_MAGNIFIER_TYPE_FULL;
  static inline bool ScreenMagnifierType_IsValid(int value) {
    return AccessibilitySettingsProto_ScreenMagnifierType_IsValid(value);
  }
  static constexpr ScreenMagnifierType ScreenMagnifierType_MIN =
    AccessibilitySettingsProto_ScreenMagnifierType_ScreenMagnifierType_MIN;
  static constexpr ScreenMagnifierType ScreenMagnifierType_MAX =
    AccessibilitySettingsProto_ScreenMagnifierType_ScreenMagnifierType_MAX;
  static constexpr int ScreenMagnifierType_ARRAYSIZE =
    AccessibilitySettingsProto_ScreenMagnifierType_ScreenMagnifierType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ScreenMagnifierType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenMagnifierType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenMagnifierType_Name.");
    return AccessibilitySettingsProto_ScreenMagnifierType_Name(enum_t_value);
  }
  static inline bool ScreenMagnifierType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScreenMagnifierType* value) {
    return AccessibilitySettingsProto_ScreenMagnifierType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLoginScreenLargeCursorEnabledOptionsFieldNumber = 7,
    kLoginScreenSpokenFeedbackEnabledOptionsFieldNumber = 9,
    kLoginScreenHighContrastEnabledOptionsFieldNumber = 11,
    kLoginScreenVirtualKeyboardEnabledOptionsFieldNumber = 13,
    kLoginScreenDictationEnabledOptionsFieldNumber = 15,
    kLoginScreenSelectToSpeakEnabledOptionsFieldNumber = 17,
    kLoginScreenCursorHighlightEnabledOptionsFieldNumber = 19,
    kLoginScreenCaretHighlightEnabledOptionsFieldNumber = 21,
    kLoginScreenMonoAudioEnabledOptionsFieldNumber = 23,
    kLoginScreenAutoclickEnabledOptionsFieldNumber = 25,
    kLoginScreenStickyKeysEnabledOptionsFieldNumber = 27,
    kLoginScreenKeyboardFocusHighlightEnabledOptionsFieldNumber = 29,
    kLoginScreenScreenMagnifierTypeOptionsFieldNumber = 31,
    kLoginScreenShowOptionsInSystemTrayMenuEnabledOptionsFieldNumber = 33,
    kLoginScreenShortcutsEnabledOptionsFieldNumber = 35,
    kLoginScreenDefaultLargeCursorEnabledFieldNumber = 1,
    kLoginScreenDefaultSpokenFeedbackEnabledFieldNumber = 2,
    kLoginScreenDefaultHighContrastEnabledFieldNumber = 3,
    kLoginScreenDefaultVirtualKeyboardEnabledFieldNumber = 5,
    kLoginScreenDefaultScreenMagnifierTypeFieldNumber = 4,
    kLoginScreenLargeCursorEnabledFieldNumber = 6,
    kLoginScreenSpokenFeedbackEnabledFieldNumber = 8,
    kLoginScreenHighContrastEnabledFieldNumber = 10,
    kLoginScreenVirtualKeyboardEnabledFieldNumber = 12,
    kLoginScreenDictationEnabledFieldNumber = 14,
    kLoginScreenSelectToSpeakEnabledFieldNumber = 16,
    kLoginScreenCursorHighlightEnabledFieldNumber = 18,
    kLoginScreenCaretHighlightEnabledFieldNumber = 20,
    kLoginScreenMonoAudioEnabledFieldNumber = 22,
    kLoginScreenAutoclickEnabledFieldNumber = 24,
    kLoginScreenStickyKeysEnabledFieldNumber = 26,
    kLoginScreenKeyboardFocusHighlightEnabledFieldNumber = 28,
    kLoginScreenShowOptionsInSystemTrayMenuEnabledFieldNumber = 32,
    kLoginScreenShortcutsEnabledFieldNumber = 34,
    kLoginScreenScreenMagnifierTypeFieldNumber = 30,
  };
  // optional .enterprise_management.PolicyOptions login_screen_large_cursor_enabled_options = 7;
  bool has_login_screen_large_cursor_enabled_options() const;
  private:
  bool _internal_has_login_screen_large_cursor_enabled_options() const;
  public:
  void clear_login_screen_large_cursor_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_large_cursor_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_large_cursor_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_large_cursor_enabled_options();
  void set_allocated_login_screen_large_cursor_enabled_options(::enterprise_management::PolicyOptions* login_screen_large_cursor_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_large_cursor_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_large_cursor_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_large_cursor_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_large_cursor_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_large_cursor_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_spoken_feedback_enabled_options = 9;
  bool has_login_screen_spoken_feedback_enabled_options() const;
  private:
  bool _internal_has_login_screen_spoken_feedback_enabled_options() const;
  public:
  void clear_login_screen_spoken_feedback_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_spoken_feedback_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_spoken_feedback_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_spoken_feedback_enabled_options();
  void set_allocated_login_screen_spoken_feedback_enabled_options(::enterprise_management::PolicyOptions* login_screen_spoken_feedback_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_spoken_feedback_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_spoken_feedback_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_spoken_feedback_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_spoken_feedback_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_spoken_feedback_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_high_contrast_enabled_options = 11;
  bool has_login_screen_high_contrast_enabled_options() const;
  private:
  bool _internal_has_login_screen_high_contrast_enabled_options() const;
  public:
  void clear_login_screen_high_contrast_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_high_contrast_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_high_contrast_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_high_contrast_enabled_options();
  void set_allocated_login_screen_high_contrast_enabled_options(::enterprise_management::PolicyOptions* login_screen_high_contrast_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_high_contrast_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_high_contrast_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_high_contrast_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_high_contrast_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_high_contrast_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_virtual_keyboard_enabled_options = 13;
  bool has_login_screen_virtual_keyboard_enabled_options() const;
  private:
  bool _internal_has_login_screen_virtual_keyboard_enabled_options() const;
  public:
  void clear_login_screen_virtual_keyboard_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_virtual_keyboard_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_virtual_keyboard_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_virtual_keyboard_enabled_options();
  void set_allocated_login_screen_virtual_keyboard_enabled_options(::enterprise_management::PolicyOptions* login_screen_virtual_keyboard_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_virtual_keyboard_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_virtual_keyboard_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_virtual_keyboard_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_virtual_keyboard_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_virtual_keyboard_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_dictation_enabled_options = 15;
  bool has_login_screen_dictation_enabled_options() const;
  private:
  bool _internal_has_login_screen_dictation_enabled_options() const;
  public:
  void clear_login_screen_dictation_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_dictation_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_dictation_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_dictation_enabled_options();
  void set_allocated_login_screen_dictation_enabled_options(::enterprise_management::PolicyOptions* login_screen_dictation_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_dictation_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_dictation_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_dictation_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_dictation_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_dictation_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_select_to_speak_enabled_options = 17;
  bool has_login_screen_select_to_speak_enabled_options() const;
  private:
  bool _internal_has_login_screen_select_to_speak_enabled_options() const;
  public:
  void clear_login_screen_select_to_speak_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_select_to_speak_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_select_to_speak_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_select_to_speak_enabled_options();
  void set_allocated_login_screen_select_to_speak_enabled_options(::enterprise_management::PolicyOptions* login_screen_select_to_speak_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_select_to_speak_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_select_to_speak_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_select_to_speak_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_select_to_speak_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_select_to_speak_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_cursor_highlight_enabled_options = 19;
  bool has_login_screen_cursor_highlight_enabled_options() const;
  private:
  bool _internal_has_login_screen_cursor_highlight_enabled_options() const;
  public:
  void clear_login_screen_cursor_highlight_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_cursor_highlight_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_cursor_highlight_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_cursor_highlight_enabled_options();
  void set_allocated_login_screen_cursor_highlight_enabled_options(::enterprise_management::PolicyOptions* login_screen_cursor_highlight_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_cursor_highlight_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_cursor_highlight_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_cursor_highlight_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_cursor_highlight_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_cursor_highlight_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_caret_highlight_enabled_options = 21;
  bool has_login_screen_caret_highlight_enabled_options() const;
  private:
  bool _internal_has_login_screen_caret_highlight_enabled_options() const;
  public:
  void clear_login_screen_caret_highlight_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_caret_highlight_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_caret_highlight_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_caret_highlight_enabled_options();
  void set_allocated_login_screen_caret_highlight_enabled_options(::enterprise_management::PolicyOptions* login_screen_caret_highlight_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_caret_highlight_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_caret_highlight_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_caret_highlight_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_caret_highlight_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_caret_highlight_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_mono_audio_enabled_options = 23;
  bool has_login_screen_mono_audio_enabled_options() const;
  private:
  bool _internal_has_login_screen_mono_audio_enabled_options() const;
  public:
  void clear_login_screen_mono_audio_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_mono_audio_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_mono_audio_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_mono_audio_enabled_options();
  void set_allocated_login_screen_mono_audio_enabled_options(::enterprise_management::PolicyOptions* login_screen_mono_audio_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_mono_audio_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_mono_audio_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_mono_audio_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_mono_audio_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_mono_audio_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_autoclick_enabled_options = 25;
  bool has_login_screen_autoclick_enabled_options() const;
  private:
  bool _internal_has_login_screen_autoclick_enabled_options() const;
  public:
  void clear_login_screen_autoclick_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_autoclick_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_autoclick_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_autoclick_enabled_options();
  void set_allocated_login_screen_autoclick_enabled_options(::enterprise_management::PolicyOptions* login_screen_autoclick_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_autoclick_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_autoclick_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_autoclick_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_autoclick_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_autoclick_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_sticky_keys_enabled_options = 27;
  bool has_login_screen_sticky_keys_enabled_options() const;
  private:
  bool _internal_has_login_screen_sticky_keys_enabled_options() const;
  public:
  void clear_login_screen_sticky_keys_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_sticky_keys_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_sticky_keys_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_sticky_keys_enabled_options();
  void set_allocated_login_screen_sticky_keys_enabled_options(::enterprise_management::PolicyOptions* login_screen_sticky_keys_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_sticky_keys_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_sticky_keys_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_sticky_keys_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_sticky_keys_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_sticky_keys_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_keyboard_focus_highlight_enabled_options = 29;
  bool has_login_screen_keyboard_focus_highlight_enabled_options() const;
  private:
  bool _internal_has_login_screen_keyboard_focus_highlight_enabled_options() const;
  public:
  void clear_login_screen_keyboard_focus_highlight_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_keyboard_focus_highlight_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_keyboard_focus_highlight_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_keyboard_focus_highlight_enabled_options();
  void set_allocated_login_screen_keyboard_focus_highlight_enabled_options(::enterprise_management::PolicyOptions* login_screen_keyboard_focus_highlight_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_keyboard_focus_highlight_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_keyboard_focus_highlight_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_keyboard_focus_highlight_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_keyboard_focus_highlight_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_keyboard_focus_highlight_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_screen_magnifier_type_options = 31;
  bool has_login_screen_screen_magnifier_type_options() const;
  private:
  bool _internal_has_login_screen_screen_magnifier_type_options() const;
  public:
  void clear_login_screen_screen_magnifier_type_options();
  const ::enterprise_management::PolicyOptions& login_screen_screen_magnifier_type_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_screen_magnifier_type_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_screen_magnifier_type_options();
  void set_allocated_login_screen_screen_magnifier_type_options(::enterprise_management::PolicyOptions* login_screen_screen_magnifier_type_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_screen_magnifier_type_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_screen_magnifier_type_options();
  public:
  void unsafe_arena_set_allocated_login_screen_screen_magnifier_type_options(
      ::enterprise_management::PolicyOptions* login_screen_screen_magnifier_type_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_screen_magnifier_type_options();

  // optional .enterprise_management.PolicyOptions login_screen_show_options_in_system_tray_menu_enabled_options = 33;
  bool has_login_screen_show_options_in_system_tray_menu_enabled_options() const;
  private:
  bool _internal_has_login_screen_show_options_in_system_tray_menu_enabled_options() const;
  public:
  void clear_login_screen_show_options_in_system_tray_menu_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_show_options_in_system_tray_menu_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_show_options_in_system_tray_menu_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_show_options_in_system_tray_menu_enabled_options();
  void set_allocated_login_screen_show_options_in_system_tray_menu_enabled_options(::enterprise_management::PolicyOptions* login_screen_show_options_in_system_tray_menu_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_show_options_in_system_tray_menu_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_show_options_in_system_tray_menu_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_show_options_in_system_tray_menu_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_show_options_in_system_tray_menu_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_show_options_in_system_tray_menu_enabled_options();

  // optional .enterprise_management.PolicyOptions login_screen_shortcuts_enabled_options = 35;
  bool has_login_screen_shortcuts_enabled_options() const;
  private:
  bool _internal_has_login_screen_shortcuts_enabled_options() const;
  public:
  void clear_login_screen_shortcuts_enabled_options();
  const ::enterprise_management::PolicyOptions& login_screen_shortcuts_enabled_options() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyOptions* release_login_screen_shortcuts_enabled_options();
  ::enterprise_management::PolicyOptions* mutable_login_screen_shortcuts_enabled_options();
  void set_allocated_login_screen_shortcuts_enabled_options(::enterprise_management::PolicyOptions* login_screen_shortcuts_enabled_options);
  private:
  const ::enterprise_management::PolicyOptions& _internal_login_screen_shortcuts_enabled_options() const;
  ::enterprise_management::PolicyOptions* _internal_mutable_login_screen_shortcuts_enabled_options();
  public:
  void unsafe_arena_set_allocated_login_screen_shortcuts_enabled_options(
      ::enterprise_management::PolicyOptions* login_screen_shortcuts_enabled_options);
  ::enterprise_management::PolicyOptions* unsafe_arena_release_login_screen_shortcuts_enabled_options();

  // optional bool login_screen_default_large_cursor_enabled = 1;
  bool has_login_screen_default_large_cursor_enabled() const;
  private:
  bool _internal_has_login_screen_default_large_cursor_enabled() const;
  public:
  void clear_login_screen_default_large_cursor_enabled();
  bool login_screen_default_large_cursor_enabled() const;
  void set_login_screen_default_large_cursor_enabled(bool value);
  private:
  bool _internal_login_screen_default_large_cursor_enabled() const;
  void _internal_set_login_screen_default_large_cursor_enabled(bool value);
  public:

  // optional bool login_screen_default_spoken_feedback_enabled = 2;
  bool has_login_screen_default_spoken_feedback_enabled() const;
  private:
  bool _internal_has_login_screen_default_spoken_feedback_enabled() const;
  public:
  void clear_login_screen_default_spoken_feedback_enabled();
  bool login_screen_default_spoken_feedback_enabled() const;
  void set_login_screen_default_spoken_feedback_enabled(bool value);
  private:
  bool _internal_login_screen_default_spoken_feedback_enabled() const;
  void _internal_set_login_screen_default_spoken_feedback_enabled(bool value);
  public:

  // optional bool login_screen_default_high_contrast_enabled = 3;
  bool has_login_screen_default_high_contrast_enabled() const;
  private:
  bool _internal_has_login_screen_default_high_contrast_enabled() const;
  public:
  void clear_login_screen_default_high_contrast_enabled();
  bool login_screen_default_high_contrast_enabled() const;
  void set_login_screen_default_high_contrast_enabled(bool value);
  private:
  bool _internal_login_screen_default_high_contrast_enabled() const;
  void _internal_set_login_screen_default_high_contrast_enabled(bool value);
  public:

  // optional bool login_screen_default_virtual_keyboard_enabled = 5;
  bool has_login_screen_default_virtual_keyboard_enabled() const;
  private:
  bool _internal_has_login_screen_default_virtual_keyboard_enabled() const;
  public:
  void clear_login_screen_default_virtual_keyboard_enabled();
  bool login_screen_default_virtual_keyboard_enabled() const;
  void set_login_screen_default_virtual_keyboard_enabled(bool value);
  private:
  bool _internal_login_screen_default_virtual_keyboard_enabled() const;
  void _internal_set_login_screen_default_virtual_keyboard_enabled(bool value);
  public:

  // optional .enterprise_management.AccessibilitySettingsProto.ScreenMagnifierType login_screen_default_screen_magnifier_type = 4;
  bool has_login_screen_default_screen_magnifier_type() const;
  private:
  bool _internal_has_login_screen_default_screen_magnifier_type() const;
  public:
  void clear_login_screen_default_screen_magnifier_type();
  ::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType login_screen_default_screen_magnifier_type() const;
  void set_login_screen_default_screen_magnifier_type(::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType value);
  private:
  ::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType _internal_login_screen_default_screen_magnifier_type() const;
  void _internal_set_login_screen_default_screen_magnifier_type(::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType value);
  public:

  // optional bool login_screen_large_cursor_enabled = 6;
  bool has_login_screen_large_cursor_enabled() const;
  private:
  bool _internal_has_login_screen_large_cursor_enabled() const;
  public:
  void clear_login_screen_large_cursor_enabled();
  bool login_screen_large_cursor_enabled() const;
  void set_login_screen_large_cursor_enabled(bool value);
  private:
  bool _internal_login_screen_large_cursor_enabled() const;
  void _internal_set_login_screen_large_cursor_enabled(bool value);
  public:

  // optional bool login_screen_spoken_feedback_enabled = 8;
  bool has_login_screen_spoken_feedback_enabled() const;
  private:
  bool _internal_has_login_screen_spoken_feedback_enabled() const;
  public:
  void clear_login_screen_spoken_feedback_enabled();
  bool login_screen_spoken_feedback_enabled() const;
  void set_login_screen_spoken_feedback_enabled(bool value);
  private:
  bool _internal_login_screen_spoken_feedback_enabled() const;
  void _internal_set_login_screen_spoken_feedback_enabled(bool value);
  public:

  // optional bool login_screen_high_contrast_enabled = 10;
  bool has_login_screen_high_contrast_enabled() const;
  private:
  bool _internal_has_login_screen_high_contrast_enabled() const;
  public:
  void clear_login_screen_high_contrast_enabled();
  bool login_screen_high_contrast_enabled() const;
  void set_login_screen_high_contrast_enabled(bool value);
  private:
  bool _internal_login_screen_high_contrast_enabled() const;
  void _internal_set_login_screen_high_contrast_enabled(bool value);
  public:

  // optional bool login_screen_virtual_keyboard_enabled = 12;
  bool has_login_screen_virtual_keyboard_enabled() const;
  private:
  bool _internal_has_login_screen_virtual_keyboard_enabled() const;
  public:
  void clear_login_screen_virtual_keyboard_enabled();
  bool login_screen_virtual_keyboard_enabled() const;
  void set_login_screen_virtual_keyboard_enabled(bool value);
  private:
  bool _internal_login_screen_virtual_keyboard_enabled() const;
  void _internal_set_login_screen_virtual_keyboard_enabled(bool value);
  public:

  // optional bool login_screen_dictation_enabled = 14;
  bool has_login_screen_dictation_enabled() const;
  private:
  bool _internal_has_login_screen_dictation_enabled() const;
  public:
  void clear_login_screen_dictation_enabled();
  bool login_screen_dictation_enabled() const;
  void set_login_screen_dictation_enabled(bool value);
  private:
  bool _internal_login_screen_dictation_enabled() const;
  void _internal_set_login_screen_dictation_enabled(bool value);
  public:

  // optional bool login_screen_select_to_speak_enabled = 16;
  bool has_login_screen_select_to_speak_enabled() const;
  private:
  bool _internal_has_login_screen_select_to_speak_enabled() const;
  public:
  void clear_login_screen_select_to_speak_enabled();
  bool login_screen_select_to_speak_enabled() const;
  void set_login_screen_select_to_speak_enabled(bool value);
  private:
  bool _internal_login_screen_select_to_speak_enabled() const;
  void _internal_set_login_screen_select_to_speak_enabled(bool value);
  public:

  // optional bool login_screen_cursor_highlight_enabled = 18;
  bool has_login_screen_cursor_highlight_enabled() const;
  private:
  bool _internal_has_login_screen_cursor_highlight_enabled() const;
  public:
  void clear_login_screen_cursor_highlight_enabled();
  bool login_screen_cursor_highlight_enabled() const;
  void set_login_screen_cursor_highlight_enabled(bool value);
  private:
  bool _internal_login_screen_cursor_highlight_enabled() const;
  void _internal_set_login_screen_cursor_highlight_enabled(bool value);
  public:

  // optional bool login_screen_caret_highlight_enabled = 20;
  bool has_login_screen_caret_highlight_enabled() const;
  private:
  bool _internal_has_login_screen_caret_highlight_enabled() const;
  public:
  void clear_login_screen_caret_highlight_enabled();
  bool login_screen_caret_highlight_enabled() const;
  void set_login_screen_caret_highlight_enabled(bool value);
  private:
  bool _internal_login_screen_caret_highlight_enabled() const;
  void _internal_set_login_screen_caret_highlight_enabled(bool value);
  public:

  // optional bool login_screen_mono_audio_enabled = 22;
  bool has_login_screen_mono_audio_enabled() const;
  private:
  bool _internal_has_login_screen_mono_audio_enabled() const;
  public:
  void clear_login_screen_mono_audio_enabled();
  bool login_screen_mono_audio_enabled() const;
  void set_login_screen_mono_audio_enabled(bool value);
  private:
  bool _internal_login_screen_mono_audio_enabled() const;
  void _internal_set_login_screen_mono_audio_enabled(bool value);
  public:

  // optional bool login_screen_autoclick_enabled = 24;
  bool has_login_screen_autoclick_enabled() const;
  private:
  bool _internal_has_login_screen_autoclick_enabled() const;
  public:
  void clear_login_screen_autoclick_enabled();
  bool login_screen_autoclick_enabled() const;
  void set_login_screen_autoclick_enabled(bool value);
  private:
  bool _internal_login_screen_autoclick_enabled() const;
  void _internal_set_login_screen_autoclick_enabled(bool value);
  public:

  // optional bool login_screen_sticky_keys_enabled = 26;
  bool has_login_screen_sticky_keys_enabled() const;
  private:
  bool _internal_has_login_screen_sticky_keys_enabled() const;
  public:
  void clear_login_screen_sticky_keys_enabled();
  bool login_screen_sticky_keys_enabled() const;
  void set_login_screen_sticky_keys_enabled(bool value);
  private:
  bool _internal_login_screen_sticky_keys_enabled() const;
  void _internal_set_login_screen_sticky_keys_enabled(bool value);
  public:

  // optional bool login_screen_keyboard_focus_highlight_enabled = 28;
  bool has_login_screen_keyboard_focus_highlight_enabled() const;
  private:
  bool _internal_has_login_screen_keyboard_focus_highlight_enabled() const;
  public:
  void clear_login_screen_keyboard_focus_highlight_enabled();
  bool login_screen_keyboard_focus_highlight_enabled() const;
  void set_login_screen_keyboard_focus_highlight_enabled(bool value);
  private:
  bool _internal_login_screen_keyboard_focus_highlight_enabled() const;
  void _internal_set_login_screen_keyboard_focus_highlight_enabled(bool value);
  public:

  // optional bool login_screen_show_options_in_system_tray_menu_enabled = 32;
  bool has_login_screen_show_options_in_system_tray_menu_enabled() const;
  private:
  bool _internal_has_login_screen_show_options_in_system_tray_menu_enabled() const;
  public:
  void clear_login_screen_show_options_in_system_tray_menu_enabled();
  bool login_screen_show_options_in_system_tray_menu_enabled() const;
  void set_login_screen_show_options_in_system_tray_menu_enabled(bool value);
  private:
  bool _internal_login_screen_show_options_in_system_tray_menu_enabled() const;
  void _internal_set_login_screen_show_options_in_system_tray_menu_enabled(bool value);
  public:

  // optional bool login_screen_shortcuts_enabled = 34;
  bool has_login_screen_shortcuts_enabled() const;
  private:
  bool _internal_has_login_screen_shortcuts_enabled() const;
  public:
  void clear_login_screen_shortcuts_enabled();
  bool login_screen_shortcuts_enabled() const;
  void set_login_screen_shortcuts_enabled(bool value);
  private:
  bool _internal_login_screen_shortcuts_enabled() const;
  void _internal_set_login_screen_shortcuts_enabled(bool value);
  public:

  // optional int64 login_screen_screen_magnifier_type = 30;
  bool has_login_screen_screen_magnifier_type() const;
  private:
  bool _internal_has_login_screen_screen_magnifier_type() const;
  public:
  void clear_login_screen_screen_magnifier_type();
  int64_t login_screen_screen_magnifier_type() const;
  void set_login_screen_screen_magnifier_type(int64_t value);
  private:
  int64_t _internal_login_screen_screen_magnifier_type() const;
  void _internal_set_login_screen_screen_magnifier_type(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AccessibilitySettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::PolicyOptions* login_screen_large_cursor_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_spoken_feedback_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_high_contrast_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_virtual_keyboard_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_dictation_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_select_to_speak_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_cursor_highlight_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_caret_highlight_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_mono_audio_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_autoclick_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_sticky_keys_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_keyboard_focus_highlight_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_screen_magnifier_type_options_;
    ::enterprise_management::PolicyOptions* login_screen_show_options_in_system_tray_menu_enabled_options_;
    ::enterprise_management::PolicyOptions* login_screen_shortcuts_enabled_options_;
    bool login_screen_default_large_cursor_enabled_;
    bool login_screen_default_spoken_feedback_enabled_;
    bool login_screen_default_high_contrast_enabled_;
    bool login_screen_default_virtual_keyboard_enabled_;
    int login_screen_default_screen_magnifier_type_;
    bool login_screen_large_cursor_enabled_;
    bool login_screen_spoken_feedback_enabled_;
    bool login_screen_high_contrast_enabled_;
    bool login_screen_virtual_keyboard_enabled_;
    bool login_screen_dictation_enabled_;
    bool login_screen_select_to_speak_enabled_;
    bool login_screen_cursor_highlight_enabled_;
    bool login_screen_caret_highlight_enabled_;
    bool login_screen_mono_audio_enabled_;
    bool login_screen_autoclick_enabled_;
    bool login_screen_sticky_keys_enabled_;
    bool login_screen_keyboard_focus_highlight_enabled_;
    bool login_screen_show_options_in_system_tray_menu_enabled_;
    bool login_screen_shortcuts_enabled_;
    int64_t login_screen_screen_magnifier_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_SupervisedUsersSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto) */ {
 public:
  inline OBSOLETE_SupervisedUsersSettingsProto() : OBSOLETE_SupervisedUsersSettingsProto(nullptr) {}
  ~OBSOLETE_SupervisedUsersSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_SupervisedUsersSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_SupervisedUsersSettingsProto(const OBSOLETE_SupervisedUsersSettingsProto& from);
  OBSOLETE_SupervisedUsersSettingsProto(OBSOLETE_SupervisedUsersSettingsProto&& from) noexcept
    : OBSOLETE_SupervisedUsersSettingsProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_SupervisedUsersSettingsProto& operator=(const OBSOLETE_SupervisedUsersSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_SupervisedUsersSettingsProto& operator=(OBSOLETE_SupervisedUsersSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_SupervisedUsersSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_SupervisedUsersSettingsProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_SupervisedUsersSettingsProto*>(
               &_OBSOLETE_SupervisedUsersSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(OBSOLETE_SupervisedUsersSettingsProto& a, OBSOLETE_SupervisedUsersSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_SupervisedUsersSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_SupervisedUsersSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_SupervisedUsersSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_SupervisedUsersSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_SupervisedUsersSettingsProto& from);
  void MergeFrom(const OBSOLETE_SupervisedUsersSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_SupervisedUsersSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_SupervisedUsersSettingsProto";
  }
  protected:
  explicit OBSOLETE_SupervisedUsersSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETESupervisedUsersEnabledFieldNumber = 1,
  };
  // optional bool OBSOLETE_supervised_users_enabled = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_supervised_users_enabled() const;
  private:
  bool _internal_has_obsolete_supervised_users_enabled() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_supervised_users_enabled();
  PROTOBUF_DEPRECATED bool obsolete_supervised_users_enabled() const;
  PROTOBUF_DEPRECATED void set_obsolete_supervised_users_enabled(bool value);
  private:
  bool _internal_obsolete_supervised_users_enabled() const;
  void _internal_set_obsolete_supervised_users_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool obsolete_supervised_users_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class LoginScreenPowerManagementProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LoginScreenPowerManagementProto) */ {
 public:
  inline LoginScreenPowerManagementProto() : LoginScreenPowerManagementProto(nullptr) {}
  ~LoginScreenPowerManagementProto() override;
  explicit PROTOBUF_CONSTEXPR LoginScreenPowerManagementProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginScreenPowerManagementProto(const LoginScreenPowerManagementProto& from);
  LoginScreenPowerManagementProto(LoginScreenPowerManagementProto&& from) noexcept
    : LoginScreenPowerManagementProto() {
    *this = ::std::move(from);
  }

  inline LoginScreenPowerManagementProto& operator=(const LoginScreenPowerManagementProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginScreenPowerManagementProto& operator=(LoginScreenPowerManagementProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginScreenPowerManagementProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginScreenPowerManagementProto* internal_default_instance() {
    return reinterpret_cast<const LoginScreenPowerManagementProto*>(
               &_LoginScreenPowerManagementProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(LoginScreenPowerManagementProto& a, LoginScreenPowerManagementProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginScreenPowerManagementProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginScreenPowerManagementProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginScreenPowerManagementProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginScreenPowerManagementProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginScreenPowerManagementProto& from);
  void MergeFrom(const LoginScreenPowerManagementProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginScreenPowerManagementProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LoginScreenPowerManagementProto";
  }
  protected:
  explicit LoginScreenPowerManagementProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginScreenPowerManagementFieldNumber = 1,
  };
  // optional string login_screen_power_management = 1;
  bool has_login_screen_power_management() const;
  private:
  bool _internal_has_login_screen_power_management() const;
  public:
  void clear_login_screen_power_management();
  const std::string& login_screen_power_management() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_screen_power_management(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_screen_power_management();
  PROTOBUF_NODISCARD std::string* release_login_screen_power_management();
  void set_allocated_login_screen_power_management(std::string* login_screen_power_management);
  private:
  const std::string& _internal_login_screen_power_management() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_screen_power_management(const std::string& value);
  std::string* _internal_mutable_login_screen_power_management();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LoginScreenPowerManagementProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_screen_power_management_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AutoCleanupSettigsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AutoCleanupSettigsProto) */ {
 public:
  inline AutoCleanupSettigsProto() : AutoCleanupSettigsProto(nullptr) {}
  ~AutoCleanupSettigsProto() override;
  explicit PROTOBUF_CONSTEXPR AutoCleanupSettigsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoCleanupSettigsProto(const AutoCleanupSettigsProto& from);
  AutoCleanupSettigsProto(AutoCleanupSettigsProto&& from) noexcept
    : AutoCleanupSettigsProto() {
    *this = ::std::move(from);
  }

  inline AutoCleanupSettigsProto& operator=(const AutoCleanupSettigsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoCleanupSettigsProto& operator=(AutoCleanupSettigsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutoCleanupSettigsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoCleanupSettigsProto* internal_default_instance() {
    return reinterpret_cast<const AutoCleanupSettigsProto*>(
               &_AutoCleanupSettigsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(AutoCleanupSettigsProto& a, AutoCleanupSettigsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoCleanupSettigsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoCleanupSettigsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoCleanupSettigsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoCleanupSettigsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutoCleanupSettigsProto& from);
  void MergeFrom(const AutoCleanupSettigsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutoCleanupSettigsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AutoCleanupSettigsProto";
  }
  protected:
  explicit AutoCleanupSettigsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCleanUpStrategyFieldNumber = 1,
  };
  // optional string clean_up_strategy = 1;
  bool has_clean_up_strategy() const;
  private:
  bool _internal_has_clean_up_strategy() const;
  public:
  void clear_clean_up_strategy();
  const std::string& clean_up_strategy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clean_up_strategy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clean_up_strategy();
  PROTOBUF_NODISCARD std::string* release_clean_up_strategy();
  void set_allocated_clean_up_strategy(std::string* clean_up_strategy);
  private:
  const std::string& _internal_clean_up_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clean_up_strategy(const std::string& value);
  std::string* _internal_mutable_clean_up_strategy();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AutoCleanupSettigsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clean_up_strategy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SystemSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemSettingsProto) */ {
 public:
  inline SystemSettingsProto() : SystemSettingsProto(nullptr) {}
  ~SystemSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR SystemSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSettingsProto(const SystemSettingsProto& from);
  SystemSettingsProto(SystemSettingsProto&& from) noexcept
    : SystemSettingsProto() {
    *this = ::std::move(from);
  }

  inline SystemSettingsProto& operator=(const SystemSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSettingsProto& operator=(SystemSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SystemSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSettingsProto* internal_default_instance() {
    return reinterpret_cast<const SystemSettingsProto*>(
               &_SystemSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SystemSettingsProto& a, SystemSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemSettingsProto& from);
  void MergeFrom(const SystemSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SystemSettingsProto";
  }
  protected:
  explicit SystemSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockDevmodeFieldNumber = 1,
  };
  // optional bool block_devmode = 1;
  bool has_block_devmode() const;
  private:
  bool _internal_has_block_devmode() const;
  public:
  void clear_block_devmode();
  bool block_devmode() const;
  void set_block_devmode(bool value);
  private:
  bool _internal_block_devmode() const;
  void _internal_set_block_devmode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SystemSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool block_devmode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SAMLSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SAMLSettingsProto) */ {
 public:
  inline SAMLSettingsProto() : SAMLSettingsProto(nullptr) {}
  ~SAMLSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR SAMLSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SAMLSettingsProto(const SAMLSettingsProto& from);
  SAMLSettingsProto(SAMLSettingsProto&& from) noexcept
    : SAMLSettingsProto() {
    *this = ::std::move(from);
  }

  inline SAMLSettingsProto& operator=(const SAMLSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SAMLSettingsProto& operator=(SAMLSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SAMLSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SAMLSettingsProto* internal_default_instance() {
    return reinterpret_cast<const SAMLSettingsProto*>(
               &_SAMLSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SAMLSettingsProto& a, SAMLSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SAMLSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SAMLSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SAMLSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SAMLSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SAMLSettingsProto& from);
  void MergeFrom(const SAMLSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SAMLSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SAMLSettingsProto";
  }
  protected:
  explicit SAMLSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEUrlParameterToAutofillSamlUsernameFieldNumber = 2,
    kTransferSamlCookiesFieldNumber = 1,
  };
  // optional string OBSOLETE_url_parameter_to_autofill_saml_username = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_url_parameter_to_autofill_saml_username() const;
  private:
  bool _internal_has_obsolete_url_parameter_to_autofill_saml_username() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_url_parameter_to_autofill_saml_username();
  PROTOBUF_DEPRECATED const std::string& obsolete_url_parameter_to_autofill_saml_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_url_parameter_to_autofill_saml_username(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_url_parameter_to_autofill_saml_username();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_url_parameter_to_autofill_saml_username();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_url_parameter_to_autofill_saml_username(std::string* obsolete_url_parameter_to_autofill_saml_username);
  private:
  const std::string& _internal_obsolete_url_parameter_to_autofill_saml_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_url_parameter_to_autofill_saml_username(const std::string& value);
  std::string* _internal_mutable_obsolete_url_parameter_to_autofill_saml_username();
  public:

  // optional bool transfer_saml_cookies = 1;
  bool has_transfer_saml_cookies() const;
  private:
  bool _internal_has_transfer_saml_cookies() const;
  public:
  void clear_transfer_saml_cookies();
  bool transfer_saml_cookies() const;
  void set_transfer_saml_cookies(bool value);
  private:
  bool _internal_transfer_saml_cookies() const;
  void _internal_set_transfer_saml_cookies(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SAMLSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_url_parameter_to_autofill_saml_username_;
    bool transfer_saml_cookies_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SAMLUsernameProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SAMLUsernameProto) */ {
 public:
  inline SAMLUsernameProto() : SAMLUsernameProto(nullptr) {}
  ~SAMLUsernameProto() override;
  explicit PROTOBUF_CONSTEXPR SAMLUsernameProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SAMLUsernameProto(const SAMLUsernameProto& from);
  SAMLUsernameProto(SAMLUsernameProto&& from) noexcept
    : SAMLUsernameProto() {
    *this = ::std::move(from);
  }

  inline SAMLUsernameProto& operator=(const SAMLUsernameProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SAMLUsernameProto& operator=(SAMLUsernameProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SAMLUsernameProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SAMLUsernameProto* internal_default_instance() {
    return reinterpret_cast<const SAMLUsernameProto*>(
               &_SAMLUsernameProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(SAMLUsernameProto& a, SAMLUsernameProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SAMLUsernameProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SAMLUsernameProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SAMLUsernameProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SAMLUsernameProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SAMLUsernameProto& from);
  void MergeFrom(const SAMLUsernameProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SAMLUsernameProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SAMLUsernameProto";
  }
  protected:
  explicit SAMLUsernameProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlParameterToAutofillSamlUsernameFieldNumber = 1,
  };
  // optional string url_parameter_to_autofill_saml_username = 1;
  bool has_url_parameter_to_autofill_saml_username() const;
  private:
  bool _internal_has_url_parameter_to_autofill_saml_username() const;
  public:
  void clear_url_parameter_to_autofill_saml_username();
  const std::string& url_parameter_to_autofill_saml_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url_parameter_to_autofill_saml_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url_parameter_to_autofill_saml_username();
  PROTOBUF_NODISCARD std::string* release_url_parameter_to_autofill_saml_username();
  void set_allocated_url_parameter_to_autofill_saml_username(std::string* url_parameter_to_autofill_saml_username);
  private:
  const std::string& _internal_url_parameter_to_autofill_saml_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_parameter_to_autofill_saml_username(const std::string& value);
  std::string* _internal_mutable_url_parameter_to_autofill_saml_username();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SAMLUsernameProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_parameter_to_autofill_saml_username_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class RebootOnShutdownProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RebootOnShutdownProto) */ {
 public:
  inline RebootOnShutdownProto() : RebootOnShutdownProto(nullptr) {}
  ~RebootOnShutdownProto() override;
  explicit PROTOBUF_CONSTEXPR RebootOnShutdownProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RebootOnShutdownProto(const RebootOnShutdownProto& from);
  RebootOnShutdownProto(RebootOnShutdownProto&& from) noexcept
    : RebootOnShutdownProto() {
    *this = ::std::move(from);
  }

  inline RebootOnShutdownProto& operator=(const RebootOnShutdownProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RebootOnShutdownProto& operator=(RebootOnShutdownProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RebootOnShutdownProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const RebootOnShutdownProto* internal_default_instance() {
    return reinterpret_cast<const RebootOnShutdownProto*>(
               &_RebootOnShutdownProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(RebootOnShutdownProto& a, RebootOnShutdownProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RebootOnShutdownProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RebootOnShutdownProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RebootOnShutdownProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RebootOnShutdownProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RebootOnShutdownProto& from);
  void MergeFrom(const RebootOnShutdownProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RebootOnShutdownProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RebootOnShutdownProto";
  }
  protected:
  explicit RebootOnShutdownProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRebootOnShutdownFieldNumber = 1,
  };
  // optional bool reboot_on_shutdown = 1 [default = false];
  bool has_reboot_on_shutdown() const;
  private:
  bool _internal_has_reboot_on_shutdown() const;
  public:
  void clear_reboot_on_shutdown();
  bool reboot_on_shutdown() const;
  void set_reboot_on_shutdown(bool value);
  private:
  bool _internal_reboot_on_shutdown() const;
  void _internal_set_reboot_on_shutdown(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.RebootOnShutdownProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool reboot_on_shutdown_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceHeartbeatSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceHeartbeatSettingsProto) */ {
 public:
  inline DeviceHeartbeatSettingsProto() : DeviceHeartbeatSettingsProto(nullptr) {}
  ~DeviceHeartbeatSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceHeartbeatSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceHeartbeatSettingsProto(const DeviceHeartbeatSettingsProto& from);
  DeviceHeartbeatSettingsProto(DeviceHeartbeatSettingsProto&& from) noexcept
    : DeviceHeartbeatSettingsProto() {
    *this = ::std::move(from);
  }

  inline DeviceHeartbeatSettingsProto& operator=(const DeviceHeartbeatSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceHeartbeatSettingsProto& operator=(DeviceHeartbeatSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceHeartbeatSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceHeartbeatSettingsProto* internal_default_instance() {
    return reinterpret_cast<const DeviceHeartbeatSettingsProto*>(
               &_DeviceHeartbeatSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(DeviceHeartbeatSettingsProto& a, DeviceHeartbeatSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceHeartbeatSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceHeartbeatSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceHeartbeatSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceHeartbeatSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceHeartbeatSettingsProto& from);
  void MergeFrom(const DeviceHeartbeatSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceHeartbeatSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceHeartbeatSettingsProto";
  }
  protected:
  explicit DeviceHeartbeatSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartbeatEnabledFieldNumber = 1,
    kHeartbeatFrequencyFieldNumber = 2,
  };
  // optional bool heartbeat_enabled = 1 [default = false];
  bool has_heartbeat_enabled() const;
  private:
  bool _internal_has_heartbeat_enabled() const;
  public:
  void clear_heartbeat_enabled();
  bool heartbeat_enabled() const;
  void set_heartbeat_enabled(bool value);
  private:
  bool _internal_heartbeat_enabled() const;
  void _internal_set_heartbeat_enabled(bool value);
  public:

  // optional int64 heartbeat_frequency = 2 [default = 120000];
  bool has_heartbeat_frequency() const;
  private:
  bool _internal_has_heartbeat_frequency() const;
  public:
  void clear_heartbeat_frequency();
  int64_t heartbeat_frequency() const;
  void set_heartbeat_frequency(int64_t value);
  private:
  int64_t _internal_heartbeat_frequency() const;
  void _internal_set_heartbeat_frequency(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceHeartbeatSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool heartbeat_enabled_;
    int64_t heartbeat_frequency_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class ExtensionCacheSizeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionCacheSizeProto) */ {
 public:
  inline ExtensionCacheSizeProto() : ExtensionCacheSizeProto(nullptr) {}
  ~ExtensionCacheSizeProto() override;
  explicit PROTOBUF_CONSTEXPR ExtensionCacheSizeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionCacheSizeProto(const ExtensionCacheSizeProto& from);
  ExtensionCacheSizeProto(ExtensionCacheSizeProto&& from) noexcept
    : ExtensionCacheSizeProto() {
    *this = ::std::move(from);
  }

  inline ExtensionCacheSizeProto& operator=(const ExtensionCacheSizeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionCacheSizeProto& operator=(ExtensionCacheSizeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionCacheSizeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionCacheSizeProto* internal_default_instance() {
    return reinterpret_cast<const ExtensionCacheSizeProto*>(
               &_ExtensionCacheSizeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ExtensionCacheSizeProto& a, ExtensionCacheSizeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtensionCacheSizeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionCacheSizeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionCacheSizeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionCacheSizeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionCacheSizeProto& from);
  void MergeFrom(const ExtensionCacheSizeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionCacheSizeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ExtensionCacheSizeProto";
  }
  protected:
  explicit ExtensionCacheSizeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionCacheSizeFieldNumber = 1,
  };
  // optional int64 extension_cache_size = 1;
  bool has_extension_cache_size() const;
  private:
  bool _internal_has_extension_cache_size() const;
  public:
  void clear_extension_cache_size();
  int64_t extension_cache_size() const;
  void set_extension_cache_size(int64_t value);
  private:
  int64_t _internal_extension_cache_size() const;
  void _internal_set_extension_cache_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ExtensionCacheSizeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t extension_cache_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class LoginScreenDomainAutoCompleteProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LoginScreenDomainAutoCompleteProto) */ {
 public:
  inline LoginScreenDomainAutoCompleteProto() : LoginScreenDomainAutoCompleteProto(nullptr) {}
  ~LoginScreenDomainAutoCompleteProto() override;
  explicit PROTOBUF_CONSTEXPR LoginScreenDomainAutoCompleteProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginScreenDomainAutoCompleteProto(const LoginScreenDomainAutoCompleteProto& from);
  LoginScreenDomainAutoCompleteProto(LoginScreenDomainAutoCompleteProto&& from) noexcept
    : LoginScreenDomainAutoCompleteProto() {
    *this = ::std::move(from);
  }

  inline LoginScreenDomainAutoCompleteProto& operator=(const LoginScreenDomainAutoCompleteProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginScreenDomainAutoCompleteProto& operator=(LoginScreenDomainAutoCompleteProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginScreenDomainAutoCompleteProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginScreenDomainAutoCompleteProto* internal_default_instance() {
    return reinterpret_cast<const LoginScreenDomainAutoCompleteProto*>(
               &_LoginScreenDomainAutoCompleteProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(LoginScreenDomainAutoCompleteProto& a, LoginScreenDomainAutoCompleteProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginScreenDomainAutoCompleteProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginScreenDomainAutoCompleteProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginScreenDomainAutoCompleteProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginScreenDomainAutoCompleteProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginScreenDomainAutoCompleteProto& from);
  void MergeFrom(const LoginScreenDomainAutoCompleteProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginScreenDomainAutoCompleteProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LoginScreenDomainAutoCompleteProto";
  }
  protected:
  explicit LoginScreenDomainAutoCompleteProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginScreenDomainAutoCompleteFieldNumber = 1,
  };
  // optional string login_screen_domain_auto_complete = 1;
  bool has_login_screen_domain_auto_complete() const;
  private:
  bool _internal_has_login_screen_domain_auto_complete() const;
  public:
  void clear_login_screen_domain_auto_complete();
  const std::string& login_screen_domain_auto_complete() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_screen_domain_auto_complete(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_screen_domain_auto_complete();
  PROTOBUF_NODISCARD std::string* release_login_screen_domain_auto_complete();
  void set_allocated_login_screen_domain_auto_complete(std::string* login_screen_domain_auto_complete);
  private:
  const std::string& _internal_login_screen_domain_auto_complete() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_screen_domain_auto_complete(const std::string& value);
  std::string* _internal_mutable_login_screen_domain_auto_complete();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LoginScreenDomainAutoCompleteProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_screen_domain_auto_complete_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceLogUploadSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceLogUploadSettingsProto) */ {
 public:
  inline DeviceLogUploadSettingsProto() : DeviceLogUploadSettingsProto(nullptr) {}
  ~DeviceLogUploadSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceLogUploadSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLogUploadSettingsProto(const DeviceLogUploadSettingsProto& from);
  DeviceLogUploadSettingsProto(DeviceLogUploadSettingsProto&& from) noexcept
    : DeviceLogUploadSettingsProto() {
    *this = ::std::move(from);
  }

  inline DeviceLogUploadSettingsProto& operator=(const DeviceLogUploadSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLogUploadSettingsProto& operator=(DeviceLogUploadSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceLogUploadSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLogUploadSettingsProto* internal_default_instance() {
    return reinterpret_cast<const DeviceLogUploadSettingsProto*>(
               &_DeviceLogUploadSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(DeviceLogUploadSettingsProto& a, DeviceLogUploadSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLogUploadSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLogUploadSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLogUploadSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLogUploadSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceLogUploadSettingsProto& from);
  void MergeFrom(const DeviceLogUploadSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceLogUploadSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceLogUploadSettingsProto";
  }
  protected:
  explicit DeviceLogUploadSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemLogUploadEnabledFieldNumber = 1,
  };
  // optional bool system_log_upload_enabled = 1 [default = false];
  bool has_system_log_upload_enabled() const;
  private:
  bool _internal_has_system_log_upload_enabled() const;
  public:
  void clear_system_log_upload_enabled();
  bool system_log_upload_enabled() const;
  void set_system_log_upload_enabled(bool value);
  private:
  bool _internal_system_log_upload_enabled() const;
  void _internal_set_system_log_upload_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceLogUploadSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool system_log_upload_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DisplayRotationDefaultProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DisplayRotationDefaultProto) */ {
 public:
  inline DisplayRotationDefaultProto() : DisplayRotationDefaultProto(nullptr) {}
  ~DisplayRotationDefaultProto() override;
  explicit PROTOBUF_CONSTEXPR DisplayRotationDefaultProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisplayRotationDefaultProto(const DisplayRotationDefaultProto& from);
  DisplayRotationDefaultProto(DisplayRotationDefaultProto&& from) noexcept
    : DisplayRotationDefaultProto() {
    *this = ::std::move(from);
  }

  inline DisplayRotationDefaultProto& operator=(const DisplayRotationDefaultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisplayRotationDefaultProto& operator=(DisplayRotationDefaultProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisplayRotationDefaultProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisplayRotationDefaultProto* internal_default_instance() {
    return reinterpret_cast<const DisplayRotationDefaultProto*>(
               &_DisplayRotationDefaultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(DisplayRotationDefaultProto& a, DisplayRotationDefaultProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DisplayRotationDefaultProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisplayRotationDefaultProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisplayRotationDefaultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisplayRotationDefaultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DisplayRotationDefaultProto& from);
  void MergeFrom(const DisplayRotationDefaultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisplayRotationDefaultProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DisplayRotationDefaultProto";
  }
  protected:
  explicit DisplayRotationDefaultProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DisplayRotationDefaultProto_Rotation Rotation;
  static constexpr Rotation ROTATE_0 =
    DisplayRotationDefaultProto_Rotation_ROTATE_0;
  static constexpr Rotation ROTATE_90 =
    DisplayRotationDefaultProto_Rotation_ROTATE_90;
  static constexpr Rotation ROTATE_180 =
    DisplayRotationDefaultProto_Rotation_ROTATE_180;
  static constexpr Rotation ROTATE_270 =
    DisplayRotationDefaultProto_Rotation_ROTATE_270;
  static inline bool Rotation_IsValid(int value) {
    return DisplayRotationDefaultProto_Rotation_IsValid(value);
  }
  static constexpr Rotation Rotation_MIN =
    DisplayRotationDefaultProto_Rotation_Rotation_MIN;
  static constexpr Rotation Rotation_MAX =
    DisplayRotationDefaultProto_Rotation_Rotation_MAX;
  static constexpr int Rotation_ARRAYSIZE =
    DisplayRotationDefaultProto_Rotation_Rotation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Rotation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Rotation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Rotation_Name.");
    return DisplayRotationDefaultProto_Rotation_Name(enum_t_value);
  }
  static inline bool Rotation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Rotation* value) {
    return DisplayRotationDefaultProto_Rotation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayRotationDefaultFieldNumber = 1,
  };
  // optional .enterprise_management.DisplayRotationDefaultProto.Rotation display_rotation_default = 1;
  bool has_display_rotation_default() const;
  private:
  bool _internal_has_display_rotation_default() const;
  public:
  void clear_display_rotation_default();
  ::enterprise_management::DisplayRotationDefaultProto_Rotation display_rotation_default() const;
  void set_display_rotation_default(::enterprise_management::DisplayRotationDefaultProto_Rotation value);
  private:
  ::enterprise_management::DisplayRotationDefaultProto_Rotation _internal_display_rotation_default() const;
  void _internal_set_display_rotation_default(::enterprise_management::DisplayRotationDefaultProto_Rotation value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DisplayRotationDefaultProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int display_rotation_default_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceLoginScreenPrivacyScreenEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto) */ {
 public:
  inline DeviceLoginScreenPrivacyScreenEnabledProto() : DeviceLoginScreenPrivacyScreenEnabledProto(nullptr) {}
  ~DeviceLoginScreenPrivacyScreenEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceLoginScreenPrivacyScreenEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLoginScreenPrivacyScreenEnabledProto(const DeviceLoginScreenPrivacyScreenEnabledProto& from);
  DeviceLoginScreenPrivacyScreenEnabledProto(DeviceLoginScreenPrivacyScreenEnabledProto&& from) noexcept
    : DeviceLoginScreenPrivacyScreenEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceLoginScreenPrivacyScreenEnabledProto& operator=(const DeviceLoginScreenPrivacyScreenEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLoginScreenPrivacyScreenEnabledProto& operator=(DeviceLoginScreenPrivacyScreenEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceLoginScreenPrivacyScreenEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLoginScreenPrivacyScreenEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceLoginScreenPrivacyScreenEnabledProto*>(
               &_DeviceLoginScreenPrivacyScreenEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(DeviceLoginScreenPrivacyScreenEnabledProto& a, DeviceLoginScreenPrivacyScreenEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLoginScreenPrivacyScreenEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLoginScreenPrivacyScreenEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLoginScreenPrivacyScreenEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLoginScreenPrivacyScreenEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceLoginScreenPrivacyScreenEnabledProto& from);
  void MergeFrom(const DeviceLoginScreenPrivacyScreenEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceLoginScreenPrivacyScreenEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto";
  }
  protected:
  explicit DeviceLoginScreenPrivacyScreenEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceDisplayResolutionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceDisplayResolutionProto) */ {
 public:
  inline DeviceDisplayResolutionProto() : DeviceDisplayResolutionProto(nullptr) {}
  ~DeviceDisplayResolutionProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceDisplayResolutionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceDisplayResolutionProto(const DeviceDisplayResolutionProto& from);
  DeviceDisplayResolutionProto(DeviceDisplayResolutionProto&& from) noexcept
    : DeviceDisplayResolutionProto() {
    *this = ::std::move(from);
  }

  inline DeviceDisplayResolutionProto& operator=(const DeviceDisplayResolutionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceDisplayResolutionProto& operator=(DeviceDisplayResolutionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceDisplayResolutionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceDisplayResolutionProto* internal_default_instance() {
    return reinterpret_cast<const DeviceDisplayResolutionProto*>(
               &_DeviceDisplayResolutionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(DeviceDisplayResolutionProto& a, DeviceDisplayResolutionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceDisplayResolutionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceDisplayResolutionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceDisplayResolutionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceDisplayResolutionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceDisplayResolutionProto& from);
  void MergeFrom(const DeviceDisplayResolutionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceDisplayResolutionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceDisplayResolutionProto";
  }
  protected:
  explicit DeviceDisplayResolutionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceDisplayResolutionFieldNumber = 1,
  };
  // optional string device_display_resolution = 1;
  bool has_device_display_resolution() const;
  private:
  bool _internal_has_device_display_resolution() const;
  public:
  void clear_device_display_resolution();
  const std::string& device_display_resolution() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_display_resolution(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_display_resolution();
  PROTOBUF_NODISCARD std::string* release_device_display_resolution();
  void set_allocated_device_display_resolution(std::string* device_display_resolution);
  private:
  const std::string& _internal_device_display_resolution() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_display_resolution(const std::string& value);
  std::string* _internal_mutable_device_display_resolution();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceDisplayResolutionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_display_resolution_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AllowKioskAppControlChromeVersionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AllowKioskAppControlChromeVersionProto) */ {
 public:
  inline AllowKioskAppControlChromeVersionProto() : AllowKioskAppControlChromeVersionProto(nullptr) {}
  ~AllowKioskAppControlChromeVersionProto() override;
  explicit PROTOBUF_CONSTEXPR AllowKioskAppControlChromeVersionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowKioskAppControlChromeVersionProto(const AllowKioskAppControlChromeVersionProto& from);
  AllowKioskAppControlChromeVersionProto(AllowKioskAppControlChromeVersionProto&& from) noexcept
    : AllowKioskAppControlChromeVersionProto() {
    *this = ::std::move(from);
  }

  inline AllowKioskAppControlChromeVersionProto& operator=(const AllowKioskAppControlChromeVersionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowKioskAppControlChromeVersionProto& operator=(AllowKioskAppControlChromeVersionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AllowKioskAppControlChromeVersionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowKioskAppControlChromeVersionProto* internal_default_instance() {
    return reinterpret_cast<const AllowKioskAppControlChromeVersionProto*>(
               &_AllowKioskAppControlChromeVersionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(AllowKioskAppControlChromeVersionProto& a, AllowKioskAppControlChromeVersionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowKioskAppControlChromeVersionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowKioskAppControlChromeVersionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowKioskAppControlChromeVersionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllowKioskAppControlChromeVersionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AllowKioskAppControlChromeVersionProto& from);
  void MergeFrom(const AllowKioskAppControlChromeVersionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllowKioskAppControlChromeVersionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AllowKioskAppControlChromeVersionProto";
  }
  protected:
  explicit AllowKioskAppControlChromeVersionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowKioskAppControlChromeVersionFieldNumber = 1,
  };
  // optional bool allow_kiosk_app_control_chrome_version = 1 [default = false];
  bool has_allow_kiosk_app_control_chrome_version() const;
  private:
  bool _internal_has_allow_kiosk_app_control_chrome_version() const;
  public:
  void clear_allow_kiosk_app_control_chrome_version();
  bool allow_kiosk_app_control_chrome_version() const;
  void set_allow_kiosk_app_control_chrome_version(bool value);
  private:
  bool _internal_allow_kiosk_app_control_chrome_version() const;
  void _internal_set_allow_kiosk_app_control_chrome_version(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AllowKioskAppControlChromeVersionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool allow_kiosk_app_control_chrome_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class LoginAuthenticationBehaviorProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LoginAuthenticationBehaviorProto) */ {
 public:
  inline LoginAuthenticationBehaviorProto() : LoginAuthenticationBehaviorProto(nullptr) {}
  ~LoginAuthenticationBehaviorProto() override;
  explicit PROTOBUF_CONSTEXPR LoginAuthenticationBehaviorProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginAuthenticationBehaviorProto(const LoginAuthenticationBehaviorProto& from);
  LoginAuthenticationBehaviorProto(LoginAuthenticationBehaviorProto&& from) noexcept
    : LoginAuthenticationBehaviorProto() {
    *this = ::std::move(from);
  }

  inline LoginAuthenticationBehaviorProto& operator=(const LoginAuthenticationBehaviorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAuthenticationBehaviorProto& operator=(LoginAuthenticationBehaviorProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginAuthenticationBehaviorProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginAuthenticationBehaviorProto* internal_default_instance() {
    return reinterpret_cast<const LoginAuthenticationBehaviorProto*>(
               &_LoginAuthenticationBehaviorProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(LoginAuthenticationBehaviorProto& a, LoginAuthenticationBehaviorProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAuthenticationBehaviorProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginAuthenticationBehaviorProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginAuthenticationBehaviorProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginAuthenticationBehaviorProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginAuthenticationBehaviorProto& from);
  void MergeFrom(const LoginAuthenticationBehaviorProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginAuthenticationBehaviorProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LoginAuthenticationBehaviorProto";
  }
  protected:
  explicit LoginAuthenticationBehaviorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LoginAuthenticationBehaviorProto_LoginBehavior LoginBehavior;
  static constexpr LoginBehavior GAIA =
    LoginAuthenticationBehaviorProto_LoginBehavior_GAIA;
  static constexpr LoginBehavior SAML_INTERSTITIAL =
    LoginAuthenticationBehaviorProto_LoginBehavior_SAML_INTERSTITIAL;
  static inline bool LoginBehavior_IsValid(int value) {
    return LoginAuthenticationBehaviorProto_LoginBehavior_IsValid(value);
  }
  static constexpr LoginBehavior LoginBehavior_MIN =
    LoginAuthenticationBehaviorProto_LoginBehavior_LoginBehavior_MIN;
  static constexpr LoginBehavior LoginBehavior_MAX =
    LoginAuthenticationBehaviorProto_LoginBehavior_LoginBehavior_MAX;
  static constexpr int LoginBehavior_ARRAYSIZE =
    LoginAuthenticationBehaviorProto_LoginBehavior_LoginBehavior_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LoginBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LoginBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LoginBehavior_Name.");
    return LoginAuthenticationBehaviorProto_LoginBehavior_Name(enum_t_value);
  }
  static inline bool LoginBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LoginBehavior* value) {
    return LoginAuthenticationBehaviorProto_LoginBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLoginAuthenticationBehaviorFieldNumber = 1,
  };
  // optional .enterprise_management.LoginAuthenticationBehaviorProto.LoginBehavior login_authentication_behavior = 1 [default = GAIA];
  bool has_login_authentication_behavior() const;
  private:
  bool _internal_has_login_authentication_behavior() const;
  public:
  void clear_login_authentication_behavior();
  ::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior login_authentication_behavior() const;
  void set_login_authentication_behavior(::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior value);
  private:
  ::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior _internal_login_authentication_behavior() const;
  void _internal_set_login_authentication_behavior(::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LoginAuthenticationBehaviorProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int login_authentication_behavior_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class UsbDeviceIdProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UsbDeviceIdProto) */ {
 public:
  inline UsbDeviceIdProto() : UsbDeviceIdProto(nullptr) {}
  ~UsbDeviceIdProto() override;
  explicit PROTOBUF_CONSTEXPR UsbDeviceIdProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsbDeviceIdProto(const UsbDeviceIdProto& from);
  UsbDeviceIdProto(UsbDeviceIdProto&& from) noexcept
    : UsbDeviceIdProto() {
    *this = ::std::move(from);
  }

  inline UsbDeviceIdProto& operator=(const UsbDeviceIdProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDeviceIdProto& operator=(UsbDeviceIdProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UsbDeviceIdProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsbDeviceIdProto* internal_default_instance() {
    return reinterpret_cast<const UsbDeviceIdProto*>(
               &_UsbDeviceIdProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(UsbDeviceIdProto& a, UsbDeviceIdProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDeviceIdProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsbDeviceIdProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsbDeviceIdProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsbDeviceIdProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UsbDeviceIdProto& from);
  void MergeFrom(const UsbDeviceIdProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UsbDeviceIdProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UsbDeviceIdProto";
  }
  protected:
  explicit UsbDeviceIdProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorIdFieldNumber = 1,
    kProductIdFieldNumber = 2,
  };
  // optional int32 vendor_id = 1;
  bool has_vendor_id() const;
  private:
  bool _internal_has_vendor_id() const;
  public:
  void clear_vendor_id();
  int32_t vendor_id() const;
  void set_vendor_id(int32_t value);
  private:
  int32_t _internal_vendor_id() const;
  void _internal_set_vendor_id(int32_t value);
  public:

  // optional int32 product_id = 2;
  bool has_product_id() const;
  private:
  bool _internal_has_product_id() const;
  public:
  void clear_product_id();
  int32_t product_id() const;
  void set_product_id(int32_t value);
  private:
  int32_t _internal_product_id() const;
  void _internal_set_product_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.UsbDeviceIdProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t vendor_id_;
    int32_t product_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class UsbDetachableWhitelistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UsbDetachableWhitelistProto) */ {
 public:
  inline UsbDetachableWhitelistProto() : UsbDetachableWhitelistProto(nullptr) {}
  ~UsbDetachableWhitelistProto() override;
  explicit PROTOBUF_CONSTEXPR UsbDetachableWhitelistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsbDetachableWhitelistProto(const UsbDetachableWhitelistProto& from);
  UsbDetachableWhitelistProto(UsbDetachableWhitelistProto&& from) noexcept
    : UsbDetachableWhitelistProto() {
    *this = ::std::move(from);
  }

  inline UsbDetachableWhitelistProto& operator=(const UsbDetachableWhitelistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDetachableWhitelistProto& operator=(UsbDetachableWhitelistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UsbDetachableWhitelistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsbDetachableWhitelistProto* internal_default_instance() {
    return reinterpret_cast<const UsbDetachableWhitelistProto*>(
               &_UsbDetachableWhitelistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(UsbDetachableWhitelistProto& a, UsbDetachableWhitelistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDetachableWhitelistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsbDetachableWhitelistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsbDetachableWhitelistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsbDetachableWhitelistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UsbDetachableWhitelistProto& from);
  void MergeFrom(const UsbDetachableWhitelistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UsbDetachableWhitelistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UsbDetachableWhitelistProto";
  }
  protected:
  explicit UsbDetachableWhitelistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated .enterprise_management.UsbDeviceIdProto id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  ::enterprise_management::UsbDeviceIdProto* mutable_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdProto >*
      mutable_id();
  private:
  const ::enterprise_management::UsbDeviceIdProto& _internal_id(int index) const;
  ::enterprise_management::UsbDeviceIdProto* _internal_add_id();
  public:
  const ::enterprise_management::UsbDeviceIdProto& id(int index) const;
  ::enterprise_management::UsbDeviceIdProto* add_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdProto >&
      id() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.UsbDetachableWhitelistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdProto > id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class UsbDeviceIdInclusiveProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UsbDeviceIdInclusiveProto) */ {
 public:
  inline UsbDeviceIdInclusiveProto() : UsbDeviceIdInclusiveProto(nullptr) {}
  ~UsbDeviceIdInclusiveProto() override;
  explicit PROTOBUF_CONSTEXPR UsbDeviceIdInclusiveProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsbDeviceIdInclusiveProto(const UsbDeviceIdInclusiveProto& from);
  UsbDeviceIdInclusiveProto(UsbDeviceIdInclusiveProto&& from) noexcept
    : UsbDeviceIdInclusiveProto() {
    *this = ::std::move(from);
  }

  inline UsbDeviceIdInclusiveProto& operator=(const UsbDeviceIdInclusiveProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDeviceIdInclusiveProto& operator=(UsbDeviceIdInclusiveProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UsbDeviceIdInclusiveProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsbDeviceIdInclusiveProto* internal_default_instance() {
    return reinterpret_cast<const UsbDeviceIdInclusiveProto*>(
               &_UsbDeviceIdInclusiveProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(UsbDeviceIdInclusiveProto& a, UsbDeviceIdInclusiveProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDeviceIdInclusiveProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsbDeviceIdInclusiveProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsbDeviceIdInclusiveProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsbDeviceIdInclusiveProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UsbDeviceIdInclusiveProto& from);
  void MergeFrom(const UsbDeviceIdInclusiveProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UsbDeviceIdInclusiveProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UsbDeviceIdInclusiveProto";
  }
  protected:
  explicit UsbDeviceIdInclusiveProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorIdFieldNumber = 1,
    kProductIdFieldNumber = 2,
  };
  // optional int32 vendor_id = 1;
  bool has_vendor_id() const;
  private:
  bool _internal_has_vendor_id() const;
  public:
  void clear_vendor_id();
  int32_t vendor_id() const;
  void set_vendor_id(int32_t value);
  private:
  int32_t _internal_vendor_id() const;
  void _internal_set_vendor_id(int32_t value);
  public:

  // optional int32 product_id = 2;
  bool has_product_id() const;
  private:
  bool _internal_has_product_id() const;
  public:
  void clear_product_id();
  int32_t product_id() const;
  void set_product_id(int32_t value);
  private:
  int32_t _internal_product_id() const;
  void _internal_set_product_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.UsbDeviceIdInclusiveProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t vendor_id_;
    int32_t product_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class UsbDetachableAllowlistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UsbDetachableAllowlistProto) */ {
 public:
  inline UsbDetachableAllowlistProto() : UsbDetachableAllowlistProto(nullptr) {}
  ~UsbDetachableAllowlistProto() override;
  explicit PROTOBUF_CONSTEXPR UsbDetachableAllowlistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsbDetachableAllowlistProto(const UsbDetachableAllowlistProto& from);
  UsbDetachableAllowlistProto(UsbDetachableAllowlistProto&& from) noexcept
    : UsbDetachableAllowlistProto() {
    *this = ::std::move(from);
  }

  inline UsbDetachableAllowlistProto& operator=(const UsbDetachableAllowlistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsbDetachableAllowlistProto& operator=(UsbDetachableAllowlistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UsbDetachableAllowlistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsbDetachableAllowlistProto* internal_default_instance() {
    return reinterpret_cast<const UsbDetachableAllowlistProto*>(
               &_UsbDetachableAllowlistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(UsbDetachableAllowlistProto& a, UsbDetachableAllowlistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UsbDetachableAllowlistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsbDetachableAllowlistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsbDetachableAllowlistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsbDetachableAllowlistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UsbDetachableAllowlistProto& from);
  void MergeFrom(const UsbDetachableAllowlistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UsbDetachableAllowlistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UsbDetachableAllowlistProto";
  }
  protected:
  explicit UsbDetachableAllowlistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated .enterprise_management.UsbDeviceIdInclusiveProto id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  ::enterprise_management::UsbDeviceIdInclusiveProto* mutable_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdInclusiveProto >*
      mutable_id();
  private:
  const ::enterprise_management::UsbDeviceIdInclusiveProto& _internal_id(int index) const;
  ::enterprise_management::UsbDeviceIdInclusiveProto* _internal_add_id();
  public:
  const ::enterprise_management::UsbDeviceIdInclusiveProto& id(int index) const;
  ::enterprise_management::UsbDeviceIdInclusiveProto* add_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdInclusiveProto >&
      id() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.UsbDetachableAllowlistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdInclusiveProto > id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class AllowBluetoothProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AllowBluetoothProto) */ {
 public:
  inline AllowBluetoothProto() : AllowBluetoothProto(nullptr) {}
  ~AllowBluetoothProto() override;
  explicit PROTOBUF_CONSTEXPR AllowBluetoothProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowBluetoothProto(const AllowBluetoothProto& from);
  AllowBluetoothProto(AllowBluetoothProto&& from) noexcept
    : AllowBluetoothProto() {
    *this = ::std::move(from);
  }

  inline AllowBluetoothProto& operator=(const AllowBluetoothProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowBluetoothProto& operator=(AllowBluetoothProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AllowBluetoothProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowBluetoothProto* internal_default_instance() {
    return reinterpret_cast<const AllowBluetoothProto*>(
               &_AllowBluetoothProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(AllowBluetoothProto& a, AllowBluetoothProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowBluetoothProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowBluetoothProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowBluetoothProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllowBluetoothProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AllowBluetoothProto& from);
  void MergeFrom(const AllowBluetoothProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllowBluetoothProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AllowBluetoothProto";
  }
  protected:
  explicit AllowBluetoothProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowBluetoothFieldNumber = 1,
  };
  // optional bool allow_bluetooth = 1 [default = true];
  bool has_allow_bluetooth() const;
  private:
  bool _internal_has_allow_bluetooth() const;
  public:
  void clear_allow_bluetooth();
  bool allow_bluetooth() const;
  void set_allow_bluetooth(bool value);
  private:
  bool _internal_allow_bluetooth() const;
  void _internal_set_allow_bluetooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AllowBluetoothProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool allow_bluetooth_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceWiFiAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceWiFiAllowedProto) */ {
 public:
  inline DeviceWiFiAllowedProto() : DeviceWiFiAllowedProto(nullptr) {}
  ~DeviceWiFiAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceWiFiAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceWiFiAllowedProto(const DeviceWiFiAllowedProto& from);
  DeviceWiFiAllowedProto(DeviceWiFiAllowedProto&& from) noexcept
    : DeviceWiFiAllowedProto() {
    *this = ::std::move(from);
  }

  inline DeviceWiFiAllowedProto& operator=(const DeviceWiFiAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceWiFiAllowedProto& operator=(DeviceWiFiAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceWiFiAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceWiFiAllowedProto* internal_default_instance() {
    return reinterpret_cast<const DeviceWiFiAllowedProto*>(
               &_DeviceWiFiAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(DeviceWiFiAllowedProto& a, DeviceWiFiAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceWiFiAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceWiFiAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceWiFiAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceWiFiAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceWiFiAllowedProto& from);
  void MergeFrom(const DeviceWiFiAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceWiFiAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceWiFiAllowedProto";
  }
  protected:
  explicit DeviceWiFiAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceWifiAllowedFieldNumber = 1,
  };
  // optional bool device_wifi_allowed = 1 [default = true];
  bool has_device_wifi_allowed() const;
  private:
  bool _internal_has_device_wifi_allowed() const;
  public:
  void clear_device_wifi_allowed();
  bool device_wifi_allowed() const;
  void set_device_wifi_allowed(bool value);
  private:
  bool _internal_device_wifi_allowed() const;
  void _internal_set_device_wifi_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceWiFiAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_wifi_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceQuirksDownloadEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceQuirksDownloadEnabledProto) */ {
 public:
  inline DeviceQuirksDownloadEnabledProto() : DeviceQuirksDownloadEnabledProto(nullptr) {}
  ~DeviceQuirksDownloadEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceQuirksDownloadEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceQuirksDownloadEnabledProto(const DeviceQuirksDownloadEnabledProto& from);
  DeviceQuirksDownloadEnabledProto(DeviceQuirksDownloadEnabledProto&& from) noexcept
    : DeviceQuirksDownloadEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceQuirksDownloadEnabledProto& operator=(const DeviceQuirksDownloadEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceQuirksDownloadEnabledProto& operator=(DeviceQuirksDownloadEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceQuirksDownloadEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceQuirksDownloadEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceQuirksDownloadEnabledProto*>(
               &_DeviceQuirksDownloadEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(DeviceQuirksDownloadEnabledProto& a, DeviceQuirksDownloadEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceQuirksDownloadEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceQuirksDownloadEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceQuirksDownloadEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceQuirksDownloadEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceQuirksDownloadEnabledProto& from);
  void MergeFrom(const DeviceQuirksDownloadEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceQuirksDownloadEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceQuirksDownloadEnabledProto";
  }
  protected:
  explicit DeviceQuirksDownloadEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuirksDownloadEnabledFieldNumber = 1,
  };
  // optional bool quirks_download_enabled = 1;
  bool has_quirks_download_enabled() const;
  private:
  bool _internal_has_quirks_download_enabled() const;
  public:
  void clear_quirks_download_enabled();
  bool quirks_download_enabled() const;
  void set_quirks_download_enabled(bool value);
  private:
  bool _internal_quirks_download_enabled() const;
  void _internal_set_quirks_download_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceQuirksDownloadEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool quirks_download_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class LoginVideoCaptureAllowedUrlsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LoginVideoCaptureAllowedUrlsProto) */ {
 public:
  inline LoginVideoCaptureAllowedUrlsProto() : LoginVideoCaptureAllowedUrlsProto(nullptr) {}
  ~LoginVideoCaptureAllowedUrlsProto() override;
  explicit PROTOBUF_CONSTEXPR LoginVideoCaptureAllowedUrlsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginVideoCaptureAllowedUrlsProto(const LoginVideoCaptureAllowedUrlsProto& from);
  LoginVideoCaptureAllowedUrlsProto(LoginVideoCaptureAllowedUrlsProto&& from) noexcept
    : LoginVideoCaptureAllowedUrlsProto() {
    *this = ::std::move(from);
  }

  inline LoginVideoCaptureAllowedUrlsProto& operator=(const LoginVideoCaptureAllowedUrlsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginVideoCaptureAllowedUrlsProto& operator=(LoginVideoCaptureAllowedUrlsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginVideoCaptureAllowedUrlsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginVideoCaptureAllowedUrlsProto* internal_default_instance() {
    return reinterpret_cast<const LoginVideoCaptureAllowedUrlsProto*>(
               &_LoginVideoCaptureAllowedUrlsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(LoginVideoCaptureAllowedUrlsProto& a, LoginVideoCaptureAllowedUrlsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginVideoCaptureAllowedUrlsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginVideoCaptureAllowedUrlsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginVideoCaptureAllowedUrlsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginVideoCaptureAllowedUrlsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginVideoCaptureAllowedUrlsProto& from);
  void MergeFrom(const LoginVideoCaptureAllowedUrlsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginVideoCaptureAllowedUrlsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LoginVideoCaptureAllowedUrlsProto";
  }
  protected:
  explicit LoginVideoCaptureAllowedUrlsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 1,
  };
  // repeated string urls = 1;
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceWiFiFastTransitionEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceWiFiFastTransitionEnabledProto) */ {
 public:
  inline DeviceWiFiFastTransitionEnabledProto() : DeviceWiFiFastTransitionEnabledProto(nullptr) {}
  ~DeviceWiFiFastTransitionEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceWiFiFastTransitionEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceWiFiFastTransitionEnabledProto(const DeviceWiFiFastTransitionEnabledProto& from);
  DeviceWiFiFastTransitionEnabledProto(DeviceWiFiFastTransitionEnabledProto&& from) noexcept
    : DeviceWiFiFastTransitionEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceWiFiFastTransitionEnabledProto& operator=(const DeviceWiFiFastTransitionEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceWiFiFastTransitionEnabledProto& operator=(DeviceWiFiFastTransitionEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceWiFiFastTransitionEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceWiFiFastTransitionEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceWiFiFastTransitionEnabledProto*>(
               &_DeviceWiFiFastTransitionEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(DeviceWiFiFastTransitionEnabledProto& a, DeviceWiFiFastTransitionEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceWiFiFastTransitionEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceWiFiFastTransitionEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceWiFiFastTransitionEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceWiFiFastTransitionEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceWiFiFastTransitionEnabledProto& from);
  void MergeFrom(const DeviceWiFiFastTransitionEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceWiFiFastTransitionEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceWiFiFastTransitionEnabledProto";
  }
  protected:
  explicit DeviceWiFiFastTransitionEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceWifiFastTransitionEnabledFieldNumber = 1,
  };
  // optional bool device_wifi_fast_transition_enabled = 1;
  bool has_device_wifi_fast_transition_enabled() const;
  private:
  bool _internal_has_device_wifi_fast_transition_enabled() const;
  public:
  void clear_device_wifi_fast_transition_enabled();
  bool device_wifi_fast_transition_enabled() const;
  void set_device_wifi_fast_transition_enabled(bool value);
  private:
  bool _internal_device_wifi_fast_transition_enabled() const;
  void _internal_set_device_wifi_fast_transition_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_wifi_fast_transition_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class NetworkThrottlingEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.NetworkThrottlingEnabledProto) */ {
 public:
  inline NetworkThrottlingEnabledProto() : NetworkThrottlingEnabledProto(nullptr) {}
  ~NetworkThrottlingEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR NetworkThrottlingEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkThrottlingEnabledProto(const NetworkThrottlingEnabledProto& from);
  NetworkThrottlingEnabledProto(NetworkThrottlingEnabledProto&& from) noexcept
    : NetworkThrottlingEnabledProto() {
    *this = ::std::move(from);
  }

  inline NetworkThrottlingEnabledProto& operator=(const NetworkThrottlingEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkThrottlingEnabledProto& operator=(NetworkThrottlingEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NetworkThrottlingEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkThrottlingEnabledProto* internal_default_instance() {
    return reinterpret_cast<const NetworkThrottlingEnabledProto*>(
               &_NetworkThrottlingEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(NetworkThrottlingEnabledProto& a, NetworkThrottlingEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkThrottlingEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkThrottlingEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkThrottlingEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkThrottlingEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkThrottlingEnabledProto& from);
  void MergeFrom(const NetworkThrottlingEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkThrottlingEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.NetworkThrottlingEnabledProto";
  }
  protected:
  explicit NetworkThrottlingEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kUploadRateKbitsFieldNumber = 2,
    kDownloadRateKbitsFieldNumber = 3,
  };
  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional int32 upload_rate_kbits = 2 [default = 0];
  bool has_upload_rate_kbits() const;
  private:
  bool _internal_has_upload_rate_kbits() const;
  public:
  void clear_upload_rate_kbits();
  int32_t upload_rate_kbits() const;
  void set_upload_rate_kbits(int32_t value);
  private:
  int32_t _internal_upload_rate_kbits() const;
  void _internal_set_upload_rate_kbits(int32_t value);
  public:

  // optional int32 download_rate_kbits = 3 [default = 0];
  bool has_download_rate_kbits() const;
  private:
  bool _internal_has_download_rate_kbits() const;
  public:
  void clear_download_rate_kbits();
  int32_t download_rate_kbits() const;
  void set_download_rate_kbits(int32_t value);
  private:
  int32_t _internal_download_rate_kbits() const;
  void _internal_set_download_rate_kbits(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.NetworkThrottlingEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
    int32_t upload_rate_kbits_;
    int32_t download_rate_kbits_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceLoginScreenExtensionsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceLoginScreenExtensionsProto) */ {
 public:
  inline DeviceLoginScreenExtensionsProto() : DeviceLoginScreenExtensionsProto(nullptr) {}
  ~DeviceLoginScreenExtensionsProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceLoginScreenExtensionsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLoginScreenExtensionsProto(const DeviceLoginScreenExtensionsProto& from);
  DeviceLoginScreenExtensionsProto(DeviceLoginScreenExtensionsProto&& from) noexcept
    : DeviceLoginScreenExtensionsProto() {
    *this = ::std::move(from);
  }

  inline DeviceLoginScreenExtensionsProto& operator=(const DeviceLoginScreenExtensionsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLoginScreenExtensionsProto& operator=(DeviceLoginScreenExtensionsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceLoginScreenExtensionsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLoginScreenExtensionsProto* internal_default_instance() {
    return reinterpret_cast<const DeviceLoginScreenExtensionsProto*>(
               &_DeviceLoginScreenExtensionsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(DeviceLoginScreenExtensionsProto& a, DeviceLoginScreenExtensionsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLoginScreenExtensionsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLoginScreenExtensionsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLoginScreenExtensionsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLoginScreenExtensionsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceLoginScreenExtensionsProto& from);
  void MergeFrom(const DeviceLoginScreenExtensionsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceLoginScreenExtensionsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceLoginScreenExtensionsProto";
  }
  protected:
  explicit DeviceLoginScreenExtensionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceLoginScreenExtensionsFieldNumber = 1,
  };
  // repeated string device_login_screen_extensions = 1;
  int device_login_screen_extensions_size() const;
  private:
  int _internal_device_login_screen_extensions_size() const;
  public:
  void clear_device_login_screen_extensions();
  const std::string& device_login_screen_extensions(int index) const;
  std::string* mutable_device_login_screen_extensions(int index);
  void set_device_login_screen_extensions(int index, const std::string& value);
  void set_device_login_screen_extensions(int index, std::string&& value);
  void set_device_login_screen_extensions(int index, const char* value);
  void set_device_login_screen_extensions(int index, const char* value, size_t size);
  std::string* add_device_login_screen_extensions();
  void add_device_login_screen_extensions(const std::string& value);
  void add_device_login_screen_extensions(std::string&& value);
  void add_device_login_screen_extensions(const char* value);
  void add_device_login_screen_extensions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& device_login_screen_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_device_login_screen_extensions();
  private:
  const std::string& _internal_device_login_screen_extensions(int index) const;
  std::string* _internal_add_device_login_screen_extensions();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceLoginScreenExtensionsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> device_login_screen_extensions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class LoginScreenExtensionManifestV2AvailabilityProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto) */ {
 public:
  inline LoginScreenExtensionManifestV2AvailabilityProto() : LoginScreenExtensionManifestV2AvailabilityProto(nullptr) {}
  ~LoginScreenExtensionManifestV2AvailabilityProto() override;
  explicit PROTOBUF_CONSTEXPR LoginScreenExtensionManifestV2AvailabilityProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginScreenExtensionManifestV2AvailabilityProto(const LoginScreenExtensionManifestV2AvailabilityProto& from);
  LoginScreenExtensionManifestV2AvailabilityProto(LoginScreenExtensionManifestV2AvailabilityProto&& from) noexcept
    : LoginScreenExtensionManifestV2AvailabilityProto() {
    *this = ::std::move(from);
  }

  inline LoginScreenExtensionManifestV2AvailabilityProto& operator=(const LoginScreenExtensionManifestV2AvailabilityProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginScreenExtensionManifestV2AvailabilityProto& operator=(LoginScreenExtensionManifestV2AvailabilityProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginScreenExtensionManifestV2AvailabilityProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginScreenExtensionManifestV2AvailabilityProto* internal_default_instance() {
    return reinterpret_cast<const LoginScreenExtensionManifestV2AvailabilityProto*>(
               &_LoginScreenExtensionManifestV2AvailabilityProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(LoginScreenExtensionManifestV2AvailabilityProto& a, LoginScreenExtensionManifestV2AvailabilityProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginScreenExtensionManifestV2AvailabilityProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginScreenExtensionManifestV2AvailabilityProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginScreenExtensionManifestV2AvailabilityProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginScreenExtensionManifestV2AvailabilityProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginScreenExtensionManifestV2AvailabilityProto& from);
  void MergeFrom(const LoginScreenExtensionManifestV2AvailabilityProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginScreenExtensionManifestV2AvailabilityProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto";
  }
  protected:
  explicit LoginScreenExtensionManifestV2AvailabilityProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LoginScreenExtensionManifestV2AvailabilityProto_Availability Availability;
  static constexpr Availability DEFAULT =
    LoginScreenExtensionManifestV2AvailabilityProto_Availability_DEFAULT;
  static constexpr Availability DISABLE =
    LoginScreenExtensionManifestV2AvailabilityProto_Availability_DISABLE;
  static constexpr Availability ENABLE =
    LoginScreenExtensionManifestV2AvailabilityProto_Availability_ENABLE;
  static constexpr Availability ENABLE_FOR_FORCED_EXTENSIONS =
    LoginScreenExtensionManifestV2AvailabilityProto_Availability_ENABLE_FOR_FORCED_EXTENSIONS;
  static inline bool Availability_IsValid(int value) {
    return LoginScreenExtensionManifestV2AvailabilityProto_Availability_IsValid(value);
  }
  static constexpr Availability Availability_MIN =
    LoginScreenExtensionManifestV2AvailabilityProto_Availability_Availability_MIN;
  static constexpr Availability Availability_MAX =
    LoginScreenExtensionManifestV2AvailabilityProto_Availability_Availability_MAX;
  static constexpr int Availability_ARRAYSIZE =
    LoginScreenExtensionManifestV2AvailabilityProto_Availability_Availability_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Availability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Availability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Availability_Name.");
    return LoginScreenExtensionManifestV2AvailabilityProto_Availability_Name(enum_t_value);
  }
  static inline bool Availability_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Availability* value) {
    return LoginScreenExtensionManifestV2AvailabilityProto_Availability_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLoginScreenExtensionManifestV2AvailabilityFieldNumber = 1,
  };
  // optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto.Availability login_screen_extension_manifest_v2_availability = 1;
  bool has_login_screen_extension_manifest_v2_availability() const;
  private:
  bool _internal_has_login_screen_extension_manifest_v2_availability() const;
  public:
  void clear_login_screen_extension_manifest_v2_availability();
  ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability login_screen_extension_manifest_v2_availability() const;
  void set_login_screen_extension_manifest_v2_availability(::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability value);
  private:
  ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability _internal_login_screen_extension_manifest_v2_availability() const;
  void _internal_set_login_screen_extension_manifest_v2_availability(::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int login_screen_extension_manifest_v2_availability_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class LoginScreenLocalesProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LoginScreenLocalesProto) */ {
 public:
  inline LoginScreenLocalesProto() : LoginScreenLocalesProto(nullptr) {}
  ~LoginScreenLocalesProto() override;
  explicit PROTOBUF_CONSTEXPR LoginScreenLocalesProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginScreenLocalesProto(const LoginScreenLocalesProto& from);
  LoginScreenLocalesProto(LoginScreenLocalesProto&& from) noexcept
    : LoginScreenLocalesProto() {
    *this = ::std::move(from);
  }

  inline LoginScreenLocalesProto& operator=(const LoginScreenLocalesProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginScreenLocalesProto& operator=(LoginScreenLocalesProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginScreenLocalesProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginScreenLocalesProto* internal_default_instance() {
    return reinterpret_cast<const LoginScreenLocalesProto*>(
               &_LoginScreenLocalesProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(LoginScreenLocalesProto& a, LoginScreenLocalesProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginScreenLocalesProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginScreenLocalesProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginScreenLocalesProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginScreenLocalesProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginScreenLocalesProto& from);
  void MergeFrom(const LoginScreenLocalesProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginScreenLocalesProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LoginScreenLocalesProto";
  }
  protected:
  explicit LoginScreenLocalesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginScreenLocalesFieldNumber = 1,
  };
  // repeated string login_screen_locales = 1;
  int login_screen_locales_size() const;
  private:
  int _internal_login_screen_locales_size() const;
  public:
  void clear_login_screen_locales();
  const std::string& login_screen_locales(int index) const;
  std::string* mutable_login_screen_locales(int index);
  void set_login_screen_locales(int index, const std::string& value);
  void set_login_screen_locales(int index, std::string&& value);
  void set_login_screen_locales(int index, const char* value);
  void set_login_screen_locales(int index, const char* value, size_t size);
  std::string* add_login_screen_locales();
  void add_login_screen_locales(const std::string& value);
  void add_login_screen_locales(std::string&& value);
  void add_login_screen_locales(const char* value);
  void add_login_screen_locales(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& login_screen_locales() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_login_screen_locales();
  private:
  const std::string& _internal_login_screen_locales(int index) const;
  std::string* _internal_add_login_screen_locales();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LoginScreenLocalesProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> login_screen_locales_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class LoginScreenInputMethodsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LoginScreenInputMethodsProto) */ {
 public:
  inline LoginScreenInputMethodsProto() : LoginScreenInputMethodsProto(nullptr) {}
  ~LoginScreenInputMethodsProto() override;
  explicit PROTOBUF_CONSTEXPR LoginScreenInputMethodsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginScreenInputMethodsProto(const LoginScreenInputMethodsProto& from);
  LoginScreenInputMethodsProto(LoginScreenInputMethodsProto&& from) noexcept
    : LoginScreenInputMethodsProto() {
    *this = ::std::move(from);
  }

  inline LoginScreenInputMethodsProto& operator=(const LoginScreenInputMethodsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginScreenInputMethodsProto& operator=(LoginScreenInputMethodsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginScreenInputMethodsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginScreenInputMethodsProto* internal_default_instance() {
    return reinterpret_cast<const LoginScreenInputMethodsProto*>(
               &_LoginScreenInputMethodsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(LoginScreenInputMethodsProto& a, LoginScreenInputMethodsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginScreenInputMethodsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginScreenInputMethodsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginScreenInputMethodsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginScreenInputMethodsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginScreenInputMethodsProto& from);
  void MergeFrom(const LoginScreenInputMethodsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginScreenInputMethodsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LoginScreenInputMethodsProto";
  }
  protected:
  explicit LoginScreenInputMethodsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginScreenInputMethodsFieldNumber = 1,
  };
  // repeated string login_screen_input_methods = 1;
  int login_screen_input_methods_size() const;
  private:
  int _internal_login_screen_input_methods_size() const;
  public:
  void clear_login_screen_input_methods();
  const std::string& login_screen_input_methods(int index) const;
  std::string* mutable_login_screen_input_methods(int index);
  void set_login_screen_input_methods(int index, const std::string& value);
  void set_login_screen_input_methods(int index, std::string&& value);
  void set_login_screen_input_methods(int index, const char* value);
  void set_login_screen_input_methods(int index, const char* value, size_t size);
  std::string* add_login_screen_input_methods();
  void add_login_screen_input_methods(const std::string& value);
  void add_login_screen_input_methods(std::string&& value);
  void add_login_screen_input_methods(const char* value);
  void add_login_screen_input_methods(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& login_screen_input_methods() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_login_screen_input_methods();
  private:
  const std::string& _internal_login_screen_input_methods(int index) const;
  std::string* _internal_add_login_screen_input_methods();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LoginScreenInputMethodsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> login_screen_input_methods_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceWallpaperImageProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceWallpaperImageProto) */ {
 public:
  inline DeviceWallpaperImageProto() : DeviceWallpaperImageProto(nullptr) {}
  ~DeviceWallpaperImageProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceWallpaperImageProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceWallpaperImageProto(const DeviceWallpaperImageProto& from);
  DeviceWallpaperImageProto(DeviceWallpaperImageProto&& from) noexcept
    : DeviceWallpaperImageProto() {
    *this = ::std::move(from);
  }

  inline DeviceWallpaperImageProto& operator=(const DeviceWallpaperImageProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceWallpaperImageProto& operator=(DeviceWallpaperImageProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceWallpaperImageProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceWallpaperImageProto* internal_default_instance() {
    return reinterpret_cast<const DeviceWallpaperImageProto*>(
               &_DeviceWallpaperImageProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(DeviceWallpaperImageProto& a, DeviceWallpaperImageProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceWallpaperImageProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceWallpaperImageProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceWallpaperImageProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceWallpaperImageProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceWallpaperImageProto& from);
  void MergeFrom(const DeviceWallpaperImageProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceWallpaperImageProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceWallpaperImageProto";
  }
  protected:
  explicit DeviceWallpaperImageProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceWallpaperImageFieldNumber = 1,
  };
  // optional string device_wallpaper_image = 1;
  bool has_device_wallpaper_image() const;
  private:
  bool _internal_has_device_wallpaper_image() const;
  public:
  void clear_device_wallpaper_image();
  const std::string& device_wallpaper_image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_wallpaper_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_wallpaper_image();
  PROTOBUF_NODISCARD std::string* release_device_wallpaper_image();
  void set_allocated_device_wallpaper_image(std::string* device_wallpaper_image);
  private:
  const std::string& _internal_device_wallpaper_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_wallpaper_image(const std::string& value);
  std::string* _internal_mutable_device_wallpaper_image();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceWallpaperImageProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_wallpaper_image_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceScreensaverIdleTimeoutSecondsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto) */ {
 public:
  inline DeviceScreensaverIdleTimeoutSecondsProto() : DeviceScreensaverIdleTimeoutSecondsProto(nullptr) {}
  ~DeviceScreensaverIdleTimeoutSecondsProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceScreensaverIdleTimeoutSecondsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceScreensaverIdleTimeoutSecondsProto(const DeviceScreensaverIdleTimeoutSecondsProto& from);
  DeviceScreensaverIdleTimeoutSecondsProto(DeviceScreensaverIdleTimeoutSecondsProto&& from) noexcept
    : DeviceScreensaverIdleTimeoutSecondsProto() {
    *this = ::std::move(from);
  }

  inline DeviceScreensaverIdleTimeoutSecondsProto& operator=(const DeviceScreensaverIdleTimeoutSecondsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceScreensaverIdleTimeoutSecondsProto& operator=(DeviceScreensaverIdleTimeoutSecondsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceScreensaverIdleTimeoutSecondsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceScreensaverIdleTimeoutSecondsProto* internal_default_instance() {
    return reinterpret_cast<const DeviceScreensaverIdleTimeoutSecondsProto*>(
               &_DeviceScreensaverIdleTimeoutSecondsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(DeviceScreensaverIdleTimeoutSecondsProto& a, DeviceScreensaverIdleTimeoutSecondsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceScreensaverIdleTimeoutSecondsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceScreensaverIdleTimeoutSecondsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceScreensaverIdleTimeoutSecondsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceScreensaverIdleTimeoutSecondsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceScreensaverIdleTimeoutSecondsProto& from);
  void MergeFrom(const DeviceScreensaverIdleTimeoutSecondsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceScreensaverIdleTimeoutSecondsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto";
  }
  protected:
  explicit DeviceScreensaverIdleTimeoutSecondsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceScreensaverIdleTimeoutSecondsFieldNumber = 1,
  };
  // optional int64 device_screensaver_idle_timeout_seconds = 1;
  bool has_device_screensaver_idle_timeout_seconds() const;
  private:
  bool _internal_has_device_screensaver_idle_timeout_seconds() const;
  public:
  void clear_device_screensaver_idle_timeout_seconds();
  int64_t device_screensaver_idle_timeout_seconds() const;
  void set_device_screensaver_idle_timeout_seconds(int64_t value);
  private:
  int64_t _internal_device_screensaver_idle_timeout_seconds() const;
  void _internal_set_device_screensaver_idle_timeout_seconds(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t device_screensaver_idle_timeout_seconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceScreensaverImageDisplayIntervalSecondsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto) */ {
 public:
  inline DeviceScreensaverImageDisplayIntervalSecondsProto() : DeviceScreensaverImageDisplayIntervalSecondsProto(nullptr) {}
  ~DeviceScreensaverImageDisplayIntervalSecondsProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceScreensaverImageDisplayIntervalSecondsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceScreensaverImageDisplayIntervalSecondsProto(const DeviceScreensaverImageDisplayIntervalSecondsProto& from);
  DeviceScreensaverImageDisplayIntervalSecondsProto(DeviceScreensaverImageDisplayIntervalSecondsProto&& from) noexcept
    : DeviceScreensaverImageDisplayIntervalSecondsProto() {
    *this = ::std::move(from);
  }

  inline DeviceScreensaverImageDisplayIntervalSecondsProto& operator=(const DeviceScreensaverImageDisplayIntervalSecondsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceScreensaverImageDisplayIntervalSecondsProto& operator=(DeviceScreensaverImageDisplayIntervalSecondsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceScreensaverImageDisplayIntervalSecondsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceScreensaverImageDisplayIntervalSecondsProto* internal_default_instance() {
    return reinterpret_cast<const DeviceScreensaverImageDisplayIntervalSecondsProto*>(
               &_DeviceScreensaverImageDisplayIntervalSecondsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(DeviceScreensaverImageDisplayIntervalSecondsProto& a, DeviceScreensaverImageDisplayIntervalSecondsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceScreensaverImageDisplayIntervalSecondsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceScreensaverImageDisplayIntervalSecondsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceScreensaverImageDisplayIntervalSecondsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceScreensaverImageDisplayIntervalSecondsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceScreensaverImageDisplayIntervalSecondsProto& from);
  void MergeFrom(const DeviceScreensaverImageDisplayIntervalSecondsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceScreensaverImageDisplayIntervalSecondsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto";
  }
  protected:
  explicit DeviceScreensaverImageDisplayIntervalSecondsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceScreensaverImageDisplayIntervalSecondsFieldNumber = 1,
  };
  // optional int64 device_screensaver_image_display_interval_seconds = 1;
  bool has_device_screensaver_image_display_interval_seconds() const;
  private:
  bool _internal_has_device_screensaver_image_display_interval_seconds() const;
  public:
  void clear_device_screensaver_image_display_interval_seconds();
  int64_t device_screensaver_image_display_interval_seconds() const;
  void set_device_screensaver_image_display_interval_seconds(int64_t value);
  private:
  int64_t _internal_device_screensaver_image_display_interval_seconds() const;
  void _internal_set_device_screensaver_image_display_interval_seconds(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t device_screensaver_image_display_interval_seconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceScreensaverImagesProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceScreensaverImagesProto) */ {
 public:
  inline DeviceScreensaverImagesProto() : DeviceScreensaverImagesProto(nullptr) {}
  ~DeviceScreensaverImagesProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceScreensaverImagesProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceScreensaverImagesProto(const DeviceScreensaverImagesProto& from);
  DeviceScreensaverImagesProto(DeviceScreensaverImagesProto&& from) noexcept
    : DeviceScreensaverImagesProto() {
    *this = ::std::move(from);
  }

  inline DeviceScreensaverImagesProto& operator=(const DeviceScreensaverImagesProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceScreensaverImagesProto& operator=(DeviceScreensaverImagesProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceScreensaverImagesProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceScreensaverImagesProto* internal_default_instance() {
    return reinterpret_cast<const DeviceScreensaverImagesProto*>(
               &_DeviceScreensaverImagesProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(DeviceScreensaverImagesProto& a, DeviceScreensaverImagesProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceScreensaverImagesProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceScreensaverImagesProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceScreensaverImagesProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceScreensaverImagesProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceScreensaverImagesProto& from);
  void MergeFrom(const DeviceScreensaverImagesProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceScreensaverImagesProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceScreensaverImagesProto";
  }
  protected:
  explicit DeviceScreensaverImagesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceScreensaverImagesFieldNumber = 1,
  };
  // repeated string device_screensaver_images = 1;
  int device_screensaver_images_size() const;
  private:
  int _internal_device_screensaver_images_size() const;
  public:
  void clear_device_screensaver_images();
  const std::string& device_screensaver_images(int index) const;
  std::string* mutable_device_screensaver_images(int index);
  void set_device_screensaver_images(int index, const std::string& value);
  void set_device_screensaver_images(int index, std::string&& value);
  void set_device_screensaver_images(int index, const char* value);
  void set_device_screensaver_images(int index, const char* value, size_t size);
  std::string* add_device_screensaver_images();
  void add_device_screensaver_images(const std::string& value);
  void add_device_screensaver_images(std::string&& value);
  void add_device_screensaver_images(const char* value);
  void add_device_screensaver_images(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& device_screensaver_images() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_device_screensaver_images();
  private:
  const std::string& _internal_device_screensaver_images(int index) const;
  std::string* _internal_add_device_screensaver_images();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceScreensaverImagesProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> device_screensaver_images_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceSystemAecEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceSystemAecEnabledProto) */ {
 public:
  inline DeviceSystemAecEnabledProto() : DeviceSystemAecEnabledProto(nullptr) {}
  ~DeviceSystemAecEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceSystemAecEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceSystemAecEnabledProto(const DeviceSystemAecEnabledProto& from);
  DeviceSystemAecEnabledProto(DeviceSystemAecEnabledProto&& from) noexcept
    : DeviceSystemAecEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceSystemAecEnabledProto& operator=(const DeviceSystemAecEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceSystemAecEnabledProto& operator=(DeviceSystemAecEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceSystemAecEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceSystemAecEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceSystemAecEnabledProto*>(
               &_DeviceSystemAecEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(DeviceSystemAecEnabledProto& a, DeviceSystemAecEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceSystemAecEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceSystemAecEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceSystemAecEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceSystemAecEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceSystemAecEnabledProto& from);
  void MergeFrom(const DeviceSystemAecEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceSystemAecEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceSystemAecEnabledProto";
  }
  protected:
  explicit DeviceSystemAecEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceSystemAecEnabledFieldNumber = 1,
  };
  // optional bool device_system_aec_enabled = 1;
  bool has_device_system_aec_enabled() const;
  private:
  bool _internal_has_device_system_aec_enabled() const;
  public:
  void clear_device_system_aec_enabled();
  bool device_system_aec_enabled() const;
  void set_device_system_aec_enabled(bool value);
  private:
  bool _internal_device_system_aec_enabled() const;
  void _internal_set_device_system_aec_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceSystemAecEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_system_aec_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceScreensaverEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceScreensaverEnabledProto) */ {
 public:
  inline DeviceScreensaverEnabledProto() : DeviceScreensaverEnabledProto(nullptr) {}
  ~DeviceScreensaverEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceScreensaverEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceScreensaverEnabledProto(const DeviceScreensaverEnabledProto& from);
  DeviceScreensaverEnabledProto(DeviceScreensaverEnabledProto&& from) noexcept
    : DeviceScreensaverEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceScreensaverEnabledProto& operator=(const DeviceScreensaverEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceScreensaverEnabledProto& operator=(DeviceScreensaverEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceScreensaverEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceScreensaverEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceScreensaverEnabledProto*>(
               &_DeviceScreensaverEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(DeviceScreensaverEnabledProto& a, DeviceScreensaverEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceScreensaverEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceScreensaverEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceScreensaverEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceScreensaverEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceScreensaverEnabledProto& from);
  void MergeFrom(const DeviceScreensaverEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceScreensaverEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceScreensaverEnabledProto";
  }
  protected:
  explicit DeviceScreensaverEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceScreensaverEnabledFieldNumber = 1,
  };
  // optional bool device_screensaver_enabled = 1;
  bool has_device_screensaver_enabled() const;
  private:
  bool _internal_has_device_screensaver_enabled() const;
  public:
  void clear_device_screensaver_enabled();
  bool device_screensaver_enabled() const;
  void set_device_screensaver_enabled(bool value);
  private:
  bool _internal_device_screensaver_enabled() const;
  void _internal_set_device_screensaver_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceScreensaverEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_screensaver_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceEcryptfsMigrationStrategyProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceEcryptfsMigrationStrategyProto) */ {
 public:
  inline DeviceEcryptfsMigrationStrategyProto() : DeviceEcryptfsMigrationStrategyProto(nullptr) {}
  ~DeviceEcryptfsMigrationStrategyProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceEcryptfsMigrationStrategyProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceEcryptfsMigrationStrategyProto(const DeviceEcryptfsMigrationStrategyProto& from);
  DeviceEcryptfsMigrationStrategyProto(DeviceEcryptfsMigrationStrategyProto&& from) noexcept
    : DeviceEcryptfsMigrationStrategyProto() {
    *this = ::std::move(from);
  }

  inline DeviceEcryptfsMigrationStrategyProto& operator=(const DeviceEcryptfsMigrationStrategyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceEcryptfsMigrationStrategyProto& operator=(DeviceEcryptfsMigrationStrategyProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceEcryptfsMigrationStrategyProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceEcryptfsMigrationStrategyProto* internal_default_instance() {
    return reinterpret_cast<const DeviceEcryptfsMigrationStrategyProto*>(
               &_DeviceEcryptfsMigrationStrategyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(DeviceEcryptfsMigrationStrategyProto& a, DeviceEcryptfsMigrationStrategyProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceEcryptfsMigrationStrategyProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceEcryptfsMigrationStrategyProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceEcryptfsMigrationStrategyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceEcryptfsMigrationStrategyProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceEcryptfsMigrationStrategyProto& from);
  void MergeFrom(const DeviceEcryptfsMigrationStrategyProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceEcryptfsMigrationStrategyProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceEcryptfsMigrationStrategyProto";
  }
  protected:
  explicit DeviceEcryptfsMigrationStrategyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceEcryptfsMigrationStrategyProto_MigrationStrategy MigrationStrategy;
  static constexpr MigrationStrategy UNSET =
    DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_UNSET;
  static constexpr MigrationStrategy DISALLOW_ARC =
    DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_DISALLOW_ARC;
  static constexpr MigrationStrategy ALLOW_MIGRATION =
    DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_ALLOW_MIGRATION;
  static inline bool MigrationStrategy_IsValid(int value) {
    return DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_IsValid(value);
  }
  static constexpr MigrationStrategy MigrationStrategy_MIN =
    DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_MigrationStrategy_MIN;
  static constexpr MigrationStrategy MigrationStrategy_MAX =
    DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_MigrationStrategy_MAX;
  static constexpr int MigrationStrategy_ARRAYSIZE =
    DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_MigrationStrategy_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MigrationStrategy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MigrationStrategy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MigrationStrategy_Name.");
    return DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Name(enum_t_value);
  }
  static inline bool MigrationStrategy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MigrationStrategy* value) {
    return DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMigrationStrategyFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto.MigrationStrategy migration_strategy = 1;
  bool has_migration_strategy() const;
  private:
  bool _internal_has_migration_strategy() const;
  public:
  void clear_migration_strategy();
  ::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy migration_strategy() const;
  void set_migration_strategy(::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy value);
  private:
  ::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy _internal_migration_strategy() const;
  void _internal_set_migration_strategy(::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int migration_strategy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceSecondFactorAuthenticationProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceSecondFactorAuthenticationProto) */ {
 public:
  inline DeviceSecondFactorAuthenticationProto() : DeviceSecondFactorAuthenticationProto(nullptr) {}
  ~DeviceSecondFactorAuthenticationProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceSecondFactorAuthenticationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceSecondFactorAuthenticationProto(const DeviceSecondFactorAuthenticationProto& from);
  DeviceSecondFactorAuthenticationProto(DeviceSecondFactorAuthenticationProto&& from) noexcept
    : DeviceSecondFactorAuthenticationProto() {
    *this = ::std::move(from);
  }

  inline DeviceSecondFactorAuthenticationProto& operator=(const DeviceSecondFactorAuthenticationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceSecondFactorAuthenticationProto& operator=(DeviceSecondFactorAuthenticationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceSecondFactorAuthenticationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceSecondFactorAuthenticationProto* internal_default_instance() {
    return reinterpret_cast<const DeviceSecondFactorAuthenticationProto*>(
               &_DeviceSecondFactorAuthenticationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(DeviceSecondFactorAuthenticationProto& a, DeviceSecondFactorAuthenticationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceSecondFactorAuthenticationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceSecondFactorAuthenticationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceSecondFactorAuthenticationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceSecondFactorAuthenticationProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceSecondFactorAuthenticationProto& from);
  void MergeFrom(const DeviceSecondFactorAuthenticationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceSecondFactorAuthenticationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceSecondFactorAuthenticationProto";
  }
  protected:
  explicit DeviceSecondFactorAuthenticationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceSecondFactorAuthenticationProto_U2fMode U2fMode;
  static constexpr U2fMode UNSET =
    DeviceSecondFactorAuthenticationProto_U2fMode_UNSET;
  static constexpr U2fMode DISABLED =
    DeviceSecondFactorAuthenticationProto_U2fMode_DISABLED;
  static constexpr U2fMode U2F =
    DeviceSecondFactorAuthenticationProto_U2fMode_U2F;
  static constexpr U2fMode U2F_EXTENDED =
    DeviceSecondFactorAuthenticationProto_U2fMode_U2F_EXTENDED;
  static inline bool U2fMode_IsValid(int value) {
    return DeviceSecondFactorAuthenticationProto_U2fMode_IsValid(value);
  }
  static constexpr U2fMode U2fMode_MIN =
    DeviceSecondFactorAuthenticationProto_U2fMode_U2fMode_MIN;
  static constexpr U2fMode U2fMode_MAX =
    DeviceSecondFactorAuthenticationProto_U2fMode_U2fMode_MAX;
  static constexpr int U2fMode_ARRAYSIZE =
    DeviceSecondFactorAuthenticationProto_U2fMode_U2fMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& U2fMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, U2fMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function U2fMode_Name.");
    return DeviceSecondFactorAuthenticationProto_U2fMode_Name(enum_t_value);
  }
  static inline bool U2fMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      U2fMode* value) {
    return DeviceSecondFactorAuthenticationProto_U2fMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceSecondFactorAuthenticationProto.U2fMode mode = 1;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode mode() const;
  void set_mode(::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode value);
  private:
  ::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode _internal_mode() const;
  void _internal_set_mode(::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceSecondFactorAuthenticationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class CastReceiverNameProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CastReceiverNameProto) */ {
 public:
  inline CastReceiverNameProto() : CastReceiverNameProto(nullptr) {}
  ~CastReceiverNameProto() override;
  explicit PROTOBUF_CONSTEXPR CastReceiverNameProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastReceiverNameProto(const CastReceiverNameProto& from);
  CastReceiverNameProto(CastReceiverNameProto&& from) noexcept
    : CastReceiverNameProto() {
    *this = ::std::move(from);
  }

  inline CastReceiverNameProto& operator=(const CastReceiverNameProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastReceiverNameProto& operator=(CastReceiverNameProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastReceiverNameProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastReceiverNameProto* internal_default_instance() {
    return reinterpret_cast<const CastReceiverNameProto*>(
               &_CastReceiverNameProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(CastReceiverNameProto& a, CastReceiverNameProto& b) {
    a.Swap(&b);
  }
  inline void Swap(CastReceiverNameProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastReceiverNameProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastReceiverNameProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastReceiverNameProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastReceiverNameProto& from);
  void MergeFrom(const CastReceiverNameProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastReceiverNameProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CastReceiverNameProto";
  }
  protected:
  explicit CastReceiverNameProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CastReceiverNameProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class WeeklyTimeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.WeeklyTimeProto) */ {
 public:
  inline WeeklyTimeProto() : WeeklyTimeProto(nullptr) {}
  ~WeeklyTimeProto() override;
  explicit PROTOBUF_CONSTEXPR WeeklyTimeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WeeklyTimeProto(const WeeklyTimeProto& from);
  WeeklyTimeProto(WeeklyTimeProto&& from) noexcept
    : WeeklyTimeProto() {
    *this = ::std::move(from);
  }

  inline WeeklyTimeProto& operator=(const WeeklyTimeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeeklyTimeProto& operator=(WeeklyTimeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WeeklyTimeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeeklyTimeProto* internal_default_instance() {
    return reinterpret_cast<const WeeklyTimeProto*>(
               &_WeeklyTimeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(WeeklyTimeProto& a, WeeklyTimeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(WeeklyTimeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeeklyTimeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeeklyTimeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeeklyTimeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WeeklyTimeProto& from);
  void MergeFrom(const WeeklyTimeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WeeklyTimeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.WeeklyTimeProto";
  }
  protected:
  explicit WeeklyTimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WeeklyTimeProto_DayOfWeek DayOfWeek;
  static constexpr DayOfWeek DAY_OF_WEEK_UNSPECIFIED =
    WeeklyTimeProto_DayOfWeek_DAY_OF_WEEK_UNSPECIFIED;
  static constexpr DayOfWeek MONDAY =
    WeeklyTimeProto_DayOfWeek_MONDAY;
  static constexpr DayOfWeek TUESDAY =
    WeeklyTimeProto_DayOfWeek_TUESDAY;
  static constexpr DayOfWeek WEDNESDAY =
    WeeklyTimeProto_DayOfWeek_WEDNESDAY;
  static constexpr DayOfWeek THURSDAY =
    WeeklyTimeProto_DayOfWeek_THURSDAY;
  static constexpr DayOfWeek FRIDAY =
    WeeklyTimeProto_DayOfWeek_FRIDAY;
  static constexpr DayOfWeek SATURDAY =
    WeeklyTimeProto_DayOfWeek_SATURDAY;
  static constexpr DayOfWeek SUNDAY =
    WeeklyTimeProto_DayOfWeek_SUNDAY;
  static inline bool DayOfWeek_IsValid(int value) {
    return WeeklyTimeProto_DayOfWeek_IsValid(value);
  }
  static constexpr DayOfWeek DayOfWeek_MIN =
    WeeklyTimeProto_DayOfWeek_DayOfWeek_MIN;
  static constexpr DayOfWeek DayOfWeek_MAX =
    WeeklyTimeProto_DayOfWeek_DayOfWeek_MAX;
  static constexpr int DayOfWeek_ARRAYSIZE =
    WeeklyTimeProto_DayOfWeek_DayOfWeek_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DayOfWeek_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DayOfWeek>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DayOfWeek_Name.");
    return WeeklyTimeProto_DayOfWeek_Name(enum_t_value);
  }
  static inline bool DayOfWeek_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DayOfWeek* value) {
    return WeeklyTimeProto_DayOfWeek_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDayOfWeekFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // optional .enterprise_management.WeeklyTimeProto.DayOfWeek day_of_week = 1;
  bool has_day_of_week() const;
  private:
  bool _internal_has_day_of_week() const;
  public:
  void clear_day_of_week();
  ::enterprise_management::WeeklyTimeProto_DayOfWeek day_of_week() const;
  void set_day_of_week(::enterprise_management::WeeklyTimeProto_DayOfWeek value);
  private:
  ::enterprise_management::WeeklyTimeProto_DayOfWeek _internal_day_of_week() const;
  void _internal_set_day_of_week(::enterprise_management::WeeklyTimeProto_DayOfWeek value);
  public:

  // optional int32 time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  int32_t time() const;
  void set_time(int32_t value);
  private:
  int32_t _internal_time() const;
  void _internal_set_time(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.WeeklyTimeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int day_of_week_;
    int32_t time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class WeeklyTimeIntervalProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.WeeklyTimeIntervalProto) */ {
 public:
  inline WeeklyTimeIntervalProto() : WeeklyTimeIntervalProto(nullptr) {}
  ~WeeklyTimeIntervalProto() override;
  explicit PROTOBUF_CONSTEXPR WeeklyTimeIntervalProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WeeklyTimeIntervalProto(const WeeklyTimeIntervalProto& from);
  WeeklyTimeIntervalProto(WeeklyTimeIntervalProto&& from) noexcept
    : WeeklyTimeIntervalProto() {
    *this = ::std::move(from);
  }

  inline WeeklyTimeIntervalProto& operator=(const WeeklyTimeIntervalProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeeklyTimeIntervalProto& operator=(WeeklyTimeIntervalProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WeeklyTimeIntervalProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeeklyTimeIntervalProto* internal_default_instance() {
    return reinterpret_cast<const WeeklyTimeIntervalProto*>(
               &_WeeklyTimeIntervalProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(WeeklyTimeIntervalProto& a, WeeklyTimeIntervalProto& b) {
    a.Swap(&b);
  }
  inline void Swap(WeeklyTimeIntervalProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeeklyTimeIntervalProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeeklyTimeIntervalProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeeklyTimeIntervalProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WeeklyTimeIntervalProto& from);
  void MergeFrom(const WeeklyTimeIntervalProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WeeklyTimeIntervalProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.WeeklyTimeIntervalProto";
  }
  protected:
  explicit WeeklyTimeIntervalProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // optional .enterprise_management.WeeklyTimeProto start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::enterprise_management::WeeklyTimeProto& start() const;
  PROTOBUF_NODISCARD ::enterprise_management::WeeklyTimeProto* release_start();
  ::enterprise_management::WeeklyTimeProto* mutable_start();
  void set_allocated_start(::enterprise_management::WeeklyTimeProto* start);
  private:
  const ::enterprise_management::WeeklyTimeProto& _internal_start() const;
  ::enterprise_management::WeeklyTimeProto* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::enterprise_management::WeeklyTimeProto* start);
  ::enterprise_management::WeeklyTimeProto* unsafe_arena_release_start();

  // optional .enterprise_management.WeeklyTimeProto end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::enterprise_management::WeeklyTimeProto& end() const;
  PROTOBUF_NODISCARD ::enterprise_management::WeeklyTimeProto* release_end();
  ::enterprise_management::WeeklyTimeProto* mutable_end();
  void set_allocated_end(::enterprise_management::WeeklyTimeProto* end);
  private:
  const ::enterprise_management::WeeklyTimeProto& _internal_end() const;
  ::enterprise_management::WeeklyTimeProto* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::enterprise_management::WeeklyTimeProto* end);
  ::enterprise_management::WeeklyTimeProto* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:enterprise_management.WeeklyTimeIntervalProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::WeeklyTimeProto* start_;
    ::enterprise_management::WeeklyTimeProto* end_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceOffHoursProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceOffHoursProto) */ {
 public:
  inline DeviceOffHoursProto() : DeviceOffHoursProto(nullptr) {}
  ~DeviceOffHoursProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceOffHoursProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceOffHoursProto(const DeviceOffHoursProto& from);
  DeviceOffHoursProto(DeviceOffHoursProto&& from) noexcept
    : DeviceOffHoursProto() {
    *this = ::std::move(from);
  }

  inline DeviceOffHoursProto& operator=(const DeviceOffHoursProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceOffHoursProto& operator=(DeviceOffHoursProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceOffHoursProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceOffHoursProto* internal_default_instance() {
    return reinterpret_cast<const DeviceOffHoursProto*>(
               &_DeviceOffHoursProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(DeviceOffHoursProto& a, DeviceOffHoursProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceOffHoursProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceOffHoursProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceOffHoursProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceOffHoursProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceOffHoursProto& from);
  void MergeFrom(const DeviceOffHoursProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceOffHoursProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceOffHoursProto";
  }
  protected:
  explicit DeviceOffHoursProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalsFieldNumber = 1,
    kIgnoredPolicyProtoTagsFieldNumber = 3,
    kTimezoneFieldNumber = 2,
  };
  // repeated .enterprise_management.WeeklyTimeIntervalProto intervals = 1;
  int intervals_size() const;
  private:
  int _internal_intervals_size() const;
  public:
  void clear_intervals();
  ::enterprise_management::WeeklyTimeIntervalProto* mutable_intervals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::WeeklyTimeIntervalProto >*
      mutable_intervals();
  private:
  const ::enterprise_management::WeeklyTimeIntervalProto& _internal_intervals(int index) const;
  ::enterprise_management::WeeklyTimeIntervalProto* _internal_add_intervals();
  public:
  const ::enterprise_management::WeeklyTimeIntervalProto& intervals(int index) const;
  ::enterprise_management::WeeklyTimeIntervalProto* add_intervals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::WeeklyTimeIntervalProto >&
      intervals() const;

  // repeated int32 ignored_policy_proto_tags = 3;
  int ignored_policy_proto_tags_size() const;
  private:
  int _internal_ignored_policy_proto_tags_size() const;
  public:
  void clear_ignored_policy_proto_tags();
  private:
  int32_t _internal_ignored_policy_proto_tags(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_ignored_policy_proto_tags() const;
  void _internal_add_ignored_policy_proto_tags(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_ignored_policy_proto_tags();
  public:
  int32_t ignored_policy_proto_tags(int index) const;
  void set_ignored_policy_proto_tags(int index, int32_t value);
  void add_ignored_policy_proto_tags(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      ignored_policy_proto_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_ignored_policy_proto_tags();

  // optional string timezone = 2;
  bool has_timezone() const;
  private:
  bool _internal_has_timezone() const;
  public:
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceOffHoursProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::WeeklyTimeIntervalProto > intervals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > ignored_policy_proto_tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceNativePrintersProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceNativePrintersProto) */ {
 public:
  inline DeviceNativePrintersProto() : DeviceNativePrintersProto(nullptr) {}
  ~DeviceNativePrintersProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceNativePrintersProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceNativePrintersProto(const DeviceNativePrintersProto& from);
  DeviceNativePrintersProto(DeviceNativePrintersProto&& from) noexcept
    : DeviceNativePrintersProto() {
    *this = ::std::move(from);
  }

  inline DeviceNativePrintersProto& operator=(const DeviceNativePrintersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceNativePrintersProto& operator=(DeviceNativePrintersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceNativePrintersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceNativePrintersProto* internal_default_instance() {
    return reinterpret_cast<const DeviceNativePrintersProto*>(
               &_DeviceNativePrintersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(DeviceNativePrintersProto& a, DeviceNativePrintersProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceNativePrintersProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceNativePrintersProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceNativePrintersProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceNativePrintersProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceNativePrintersProto& from);
  void MergeFrom(const DeviceNativePrintersProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceNativePrintersProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceNativePrintersProto";
  }
  protected:
  explicit DeviceNativePrintersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalPolicyFieldNumber = 1,
  };
  // optional string external_policy = 1;
  bool has_external_policy() const;
  private:
  bool _internal_has_external_policy() const;
  public:
  void clear_external_policy();
  const std::string& external_policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_policy();
  PROTOBUF_NODISCARD std::string* release_external_policy();
  void set_allocated_external_policy(std::string* external_policy);
  private:
  const std::string& _internal_external_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_policy(const std::string& value);
  std::string* _internal_mutable_external_policy();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceNativePrintersProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceNativePrintersAccessModeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceNativePrintersAccessModeProto) */ {
 public:
  inline DeviceNativePrintersAccessModeProto() : DeviceNativePrintersAccessModeProto(nullptr) {}
  ~DeviceNativePrintersAccessModeProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceNativePrintersAccessModeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceNativePrintersAccessModeProto(const DeviceNativePrintersAccessModeProto& from);
  DeviceNativePrintersAccessModeProto(DeviceNativePrintersAccessModeProto&& from) noexcept
    : DeviceNativePrintersAccessModeProto() {
    *this = ::std::move(from);
  }

  inline DeviceNativePrintersAccessModeProto& operator=(const DeviceNativePrintersAccessModeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceNativePrintersAccessModeProto& operator=(DeviceNativePrintersAccessModeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceNativePrintersAccessModeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceNativePrintersAccessModeProto* internal_default_instance() {
    return reinterpret_cast<const DeviceNativePrintersAccessModeProto*>(
               &_DeviceNativePrintersAccessModeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(DeviceNativePrintersAccessModeProto& a, DeviceNativePrintersAccessModeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceNativePrintersAccessModeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceNativePrintersAccessModeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceNativePrintersAccessModeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceNativePrintersAccessModeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceNativePrintersAccessModeProto& from);
  void MergeFrom(const DeviceNativePrintersAccessModeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceNativePrintersAccessModeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceNativePrintersAccessModeProto";
  }
  protected:
  explicit DeviceNativePrintersAccessModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceNativePrintersAccessModeProto_AccessMode AccessMode;
  static constexpr AccessMode ACCESS_MODE_BLACKLIST =
    DeviceNativePrintersAccessModeProto_AccessMode_ACCESS_MODE_BLACKLIST;
  static constexpr AccessMode ACCESS_MODE_WHITELIST =
    DeviceNativePrintersAccessModeProto_AccessMode_ACCESS_MODE_WHITELIST;
  static constexpr AccessMode ACCESS_MODE_ALL =
    DeviceNativePrintersAccessModeProto_AccessMode_ACCESS_MODE_ALL;
  static inline bool AccessMode_IsValid(int value) {
    return DeviceNativePrintersAccessModeProto_AccessMode_IsValid(value);
  }
  static constexpr AccessMode AccessMode_MIN =
    DeviceNativePrintersAccessModeProto_AccessMode_AccessMode_MIN;
  static constexpr AccessMode AccessMode_MAX =
    DeviceNativePrintersAccessModeProto_AccessMode_AccessMode_MAX;
  static constexpr int AccessMode_ARRAYSIZE =
    DeviceNativePrintersAccessModeProto_AccessMode_AccessMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AccessMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AccessMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AccessMode_Name.");
    return DeviceNativePrintersAccessModeProto_AccessMode_Name(enum_t_value);
  }
  static inline bool AccessMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AccessMode* value) {
    return DeviceNativePrintersAccessModeProto_AccessMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAccessModeFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceNativePrintersAccessModeProto.AccessMode access_mode = 1;
  bool has_access_mode() const;
  private:
  bool _internal_has_access_mode() const;
  public:
  void clear_access_mode();
  ::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode access_mode() const;
  void set_access_mode(::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode value);
  private:
  ::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode _internal_access_mode() const;
  void _internal_set_access_mode(::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceNativePrintersAccessModeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int access_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceNativePrintersBlacklistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceNativePrintersBlacklistProto) */ {
 public:
  inline DeviceNativePrintersBlacklistProto() : DeviceNativePrintersBlacklistProto(nullptr) {}
  ~DeviceNativePrintersBlacklistProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceNativePrintersBlacklistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceNativePrintersBlacklistProto(const DeviceNativePrintersBlacklistProto& from);
  DeviceNativePrintersBlacklistProto(DeviceNativePrintersBlacklistProto&& from) noexcept
    : DeviceNativePrintersBlacklistProto() {
    *this = ::std::move(from);
  }

  inline DeviceNativePrintersBlacklistProto& operator=(const DeviceNativePrintersBlacklistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceNativePrintersBlacklistProto& operator=(DeviceNativePrintersBlacklistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceNativePrintersBlacklistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceNativePrintersBlacklistProto* internal_default_instance() {
    return reinterpret_cast<const DeviceNativePrintersBlacklistProto*>(
               &_DeviceNativePrintersBlacklistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(DeviceNativePrintersBlacklistProto& a, DeviceNativePrintersBlacklistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceNativePrintersBlacklistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceNativePrintersBlacklistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceNativePrintersBlacklistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceNativePrintersBlacklistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceNativePrintersBlacklistProto& from);
  void MergeFrom(const DeviceNativePrintersBlacklistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceNativePrintersBlacklistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceNativePrintersBlacklistProto";
  }
  protected:
  explicit DeviceNativePrintersBlacklistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlacklistFieldNumber = 1,
  };
  // repeated string blacklist = 1;
  int blacklist_size() const;
  private:
  int _internal_blacklist_size() const;
  public:
  void clear_blacklist();
  const std::string& blacklist(int index) const;
  std::string* mutable_blacklist(int index);
  void set_blacklist(int index, const std::string& value);
  void set_blacklist(int index, std::string&& value);
  void set_blacklist(int index, const char* value);
  void set_blacklist(int index, const char* value, size_t size);
  std::string* add_blacklist();
  void add_blacklist(const std::string& value);
  void add_blacklist(std::string&& value);
  void add_blacklist(const char* value);
  void add_blacklist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blacklist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blacklist();
  private:
  const std::string& _internal_blacklist(int index) const;
  std::string* _internal_add_blacklist();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceNativePrintersBlacklistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blacklist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceNativePrintersWhitelistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceNativePrintersWhitelistProto) */ {
 public:
  inline DeviceNativePrintersWhitelistProto() : DeviceNativePrintersWhitelistProto(nullptr) {}
  ~DeviceNativePrintersWhitelistProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceNativePrintersWhitelistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceNativePrintersWhitelistProto(const DeviceNativePrintersWhitelistProto& from);
  DeviceNativePrintersWhitelistProto(DeviceNativePrintersWhitelistProto&& from) noexcept
    : DeviceNativePrintersWhitelistProto() {
    *this = ::std::move(from);
  }

  inline DeviceNativePrintersWhitelistProto& operator=(const DeviceNativePrintersWhitelistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceNativePrintersWhitelistProto& operator=(DeviceNativePrintersWhitelistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceNativePrintersWhitelistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceNativePrintersWhitelistProto* internal_default_instance() {
    return reinterpret_cast<const DeviceNativePrintersWhitelistProto*>(
               &_DeviceNativePrintersWhitelistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(DeviceNativePrintersWhitelistProto& a, DeviceNativePrintersWhitelistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceNativePrintersWhitelistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceNativePrintersWhitelistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceNativePrintersWhitelistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceNativePrintersWhitelistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceNativePrintersWhitelistProto& from);
  void MergeFrom(const DeviceNativePrintersWhitelistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceNativePrintersWhitelistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceNativePrintersWhitelistProto";
  }
  protected:
  explicit DeviceNativePrintersWhitelistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhitelistFieldNumber = 1,
  };
  // repeated string whitelist = 1;
  int whitelist_size() const;
  private:
  int _internal_whitelist_size() const;
  public:
  void clear_whitelist();
  const std::string& whitelist(int index) const;
  std::string* mutable_whitelist(int index);
  void set_whitelist(int index, const std::string& value);
  void set_whitelist(int index, std::string&& value);
  void set_whitelist(int index, const char* value);
  void set_whitelist(int index, const char* value, size_t size);
  std::string* add_whitelist();
  void add_whitelist(const std::string& value);
  void add_whitelist(std::string&& value);
  void add_whitelist(const char* value);
  void add_whitelist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& whitelist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_whitelist();
  private:
  const std::string& _internal_whitelist(int index) const;
  std::string* _internal_add_whitelist();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceNativePrintersWhitelistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> whitelist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DevicePrintersProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePrintersProto) */ {
 public:
  inline DevicePrintersProto() : DevicePrintersProto(nullptr) {}
  ~DevicePrintersProto() override;
  explicit PROTOBUF_CONSTEXPR DevicePrintersProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePrintersProto(const DevicePrintersProto& from);
  DevicePrintersProto(DevicePrintersProto&& from) noexcept
    : DevicePrintersProto() {
    *this = ::std::move(from);
  }

  inline DevicePrintersProto& operator=(const DevicePrintersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePrintersProto& operator=(DevicePrintersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePrintersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePrintersProto* internal_default_instance() {
    return reinterpret_cast<const DevicePrintersProto*>(
               &_DevicePrintersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(DevicePrintersProto& a, DevicePrintersProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePrintersProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePrintersProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePrintersProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePrintersProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePrintersProto& from);
  void MergeFrom(const DevicePrintersProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePrintersProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePrintersProto";
  }
  protected:
  explicit DevicePrintersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalPolicyFieldNumber = 1,
  };
  // optional string external_policy = 1;
  bool has_external_policy() const;
  private:
  bool _internal_has_external_policy() const;
  public:
  void clear_external_policy();
  const std::string& external_policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_policy();
  PROTOBUF_NODISCARD std::string* release_external_policy();
  void set_allocated_external_policy(std::string* external_policy);
  private:
  const std::string& _internal_external_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_policy(const std::string& value);
  std::string* _internal_mutable_external_policy();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePrintersProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DevicePrintersAccessModeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePrintersAccessModeProto) */ {
 public:
  inline DevicePrintersAccessModeProto() : DevicePrintersAccessModeProto(nullptr) {}
  ~DevicePrintersAccessModeProto() override;
  explicit PROTOBUF_CONSTEXPR DevicePrintersAccessModeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePrintersAccessModeProto(const DevicePrintersAccessModeProto& from);
  DevicePrintersAccessModeProto(DevicePrintersAccessModeProto&& from) noexcept
    : DevicePrintersAccessModeProto() {
    *this = ::std::move(from);
  }

  inline DevicePrintersAccessModeProto& operator=(const DevicePrintersAccessModeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePrintersAccessModeProto& operator=(DevicePrintersAccessModeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePrintersAccessModeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePrintersAccessModeProto* internal_default_instance() {
    return reinterpret_cast<const DevicePrintersAccessModeProto*>(
               &_DevicePrintersAccessModeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(DevicePrintersAccessModeProto& a, DevicePrintersAccessModeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePrintersAccessModeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePrintersAccessModeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePrintersAccessModeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePrintersAccessModeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePrintersAccessModeProto& from);
  void MergeFrom(const DevicePrintersAccessModeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePrintersAccessModeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePrintersAccessModeProto";
  }
  protected:
  explicit DevicePrintersAccessModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DevicePrintersAccessModeProto_AccessMode AccessMode;
  static constexpr AccessMode ACCESS_MODE_BLOCKLIST =
    DevicePrintersAccessModeProto_AccessMode_ACCESS_MODE_BLOCKLIST;
  static constexpr AccessMode ACCESS_MODE_ALLOWLIST =
    DevicePrintersAccessModeProto_AccessMode_ACCESS_MODE_ALLOWLIST;
  static constexpr AccessMode ACCESS_MODE_ALL =
    DevicePrintersAccessModeProto_AccessMode_ACCESS_MODE_ALL;
  static inline bool AccessMode_IsValid(int value) {
    return DevicePrintersAccessModeProto_AccessMode_IsValid(value);
  }
  static constexpr AccessMode AccessMode_MIN =
    DevicePrintersAccessModeProto_AccessMode_AccessMode_MIN;
  static constexpr AccessMode AccessMode_MAX =
    DevicePrintersAccessModeProto_AccessMode_AccessMode_MAX;
  static constexpr int AccessMode_ARRAYSIZE =
    DevicePrintersAccessModeProto_AccessMode_AccessMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AccessMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AccessMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AccessMode_Name.");
    return DevicePrintersAccessModeProto_AccessMode_Name(enum_t_value);
  }
  static inline bool AccessMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AccessMode* value) {
    return DevicePrintersAccessModeProto_AccessMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAccessModeFieldNumber = 1,
  };
  // optional .enterprise_management.DevicePrintersAccessModeProto.AccessMode access_mode = 1;
  bool has_access_mode() const;
  private:
  bool _internal_has_access_mode() const;
  public:
  void clear_access_mode();
  ::enterprise_management::DevicePrintersAccessModeProto_AccessMode access_mode() const;
  void set_access_mode(::enterprise_management::DevicePrintersAccessModeProto_AccessMode value);
  private:
  ::enterprise_management::DevicePrintersAccessModeProto_AccessMode _internal_access_mode() const;
  void _internal_set_access_mode(::enterprise_management::DevicePrintersAccessModeProto_AccessMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePrintersAccessModeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int access_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DevicePrintersBlocklistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePrintersBlocklistProto) */ {
 public:
  inline DevicePrintersBlocklistProto() : DevicePrintersBlocklistProto(nullptr) {}
  ~DevicePrintersBlocklistProto() override;
  explicit PROTOBUF_CONSTEXPR DevicePrintersBlocklistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePrintersBlocklistProto(const DevicePrintersBlocklistProto& from);
  DevicePrintersBlocklistProto(DevicePrintersBlocklistProto&& from) noexcept
    : DevicePrintersBlocklistProto() {
    *this = ::std::move(from);
  }

  inline DevicePrintersBlocklistProto& operator=(const DevicePrintersBlocklistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePrintersBlocklistProto& operator=(DevicePrintersBlocklistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePrintersBlocklistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePrintersBlocklistProto* internal_default_instance() {
    return reinterpret_cast<const DevicePrintersBlocklistProto*>(
               &_DevicePrintersBlocklistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(DevicePrintersBlocklistProto& a, DevicePrintersBlocklistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePrintersBlocklistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePrintersBlocklistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePrintersBlocklistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePrintersBlocklistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePrintersBlocklistProto& from);
  void MergeFrom(const DevicePrintersBlocklistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePrintersBlocklistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePrintersBlocklistProto";
  }
  protected:
  explicit DevicePrintersBlocklistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocklistFieldNumber = 1,
  };
  // repeated string blocklist = 1;
  int blocklist_size() const;
  private:
  int _internal_blocklist_size() const;
  public:
  void clear_blocklist();
  const std::string& blocklist(int index) const;
  std::string* mutable_blocklist(int index);
  void set_blocklist(int index, const std::string& value);
  void set_blocklist(int index, std::string&& value);
  void set_blocklist(int index, const char* value);
  void set_blocklist(int index, const char* value, size_t size);
  std::string* add_blocklist();
  void add_blocklist(const std::string& value);
  void add_blocklist(std::string&& value);
  void add_blocklist(const char* value);
  void add_blocklist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blocklist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blocklist();
  private:
  const std::string& _internal_blocklist(int index) const;
  std::string* _internal_add_blocklist();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePrintersBlocklistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blocklist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DevicePrintersAllowlistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePrintersAllowlistProto) */ {
 public:
  inline DevicePrintersAllowlistProto() : DevicePrintersAllowlistProto(nullptr) {}
  ~DevicePrintersAllowlistProto() override;
  explicit PROTOBUF_CONSTEXPR DevicePrintersAllowlistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePrintersAllowlistProto(const DevicePrintersAllowlistProto& from);
  DevicePrintersAllowlistProto(DevicePrintersAllowlistProto&& from) noexcept
    : DevicePrintersAllowlistProto() {
    *this = ::std::move(from);
  }

  inline DevicePrintersAllowlistProto& operator=(const DevicePrintersAllowlistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePrintersAllowlistProto& operator=(DevicePrintersAllowlistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePrintersAllowlistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePrintersAllowlistProto* internal_default_instance() {
    return reinterpret_cast<const DevicePrintersAllowlistProto*>(
               &_DevicePrintersAllowlistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(DevicePrintersAllowlistProto& a, DevicePrintersAllowlistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePrintersAllowlistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePrintersAllowlistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePrintersAllowlistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePrintersAllowlistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePrintersAllowlistProto& from);
  void MergeFrom(const DevicePrintersAllowlistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePrintersAllowlistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePrintersAllowlistProto";
  }
  protected:
  explicit DevicePrintersAllowlistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowlistFieldNumber = 1,
  };
  // repeated string allowlist = 1;
  int allowlist_size() const;
  private:
  int _internal_allowlist_size() const;
  public:
  void clear_allowlist();
  const std::string& allowlist(int index) const;
  std::string* mutable_allowlist(int index);
  void set_allowlist(int index, const std::string& value);
  void set_allowlist(int index, std::string&& value);
  void set_allowlist(int index, const char* value);
  void set_allowlist(int index, const char* value, size_t size);
  std::string* add_allowlist();
  void add_allowlist(const std::string& value);
  void add_allowlist(std::string&& value);
  void add_allowlist(const char* value);
  void add_allowlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowlist();
  private:
  const std::string& _internal_allowlist(int index) const;
  std::string* _internal_add_allowlist();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePrintersAllowlistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowlist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceExternalPrintServersProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceExternalPrintServersProto) */ {
 public:
  inline DeviceExternalPrintServersProto() : DeviceExternalPrintServersProto(nullptr) {}
  ~DeviceExternalPrintServersProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceExternalPrintServersProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceExternalPrintServersProto(const DeviceExternalPrintServersProto& from);
  DeviceExternalPrintServersProto(DeviceExternalPrintServersProto&& from) noexcept
    : DeviceExternalPrintServersProto() {
    *this = ::std::move(from);
  }

  inline DeviceExternalPrintServersProto& operator=(const DeviceExternalPrintServersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceExternalPrintServersProto& operator=(DeviceExternalPrintServersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceExternalPrintServersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceExternalPrintServersProto* internal_default_instance() {
    return reinterpret_cast<const DeviceExternalPrintServersProto*>(
               &_DeviceExternalPrintServersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(DeviceExternalPrintServersProto& a, DeviceExternalPrintServersProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceExternalPrintServersProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceExternalPrintServersProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceExternalPrintServersProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceExternalPrintServersProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceExternalPrintServersProto& from);
  void MergeFrom(const DeviceExternalPrintServersProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceExternalPrintServersProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceExternalPrintServersProto";
  }
  protected:
  explicit DeviceExternalPrintServersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalPolicyFieldNumber = 1,
  };
  // optional string external_policy = 1;
  bool has_external_policy() const;
  private:
  bool _internal_has_external_policy() const;
  public:
  void clear_external_policy();
  const std::string& external_policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_policy();
  PROTOBUF_NODISCARD std::string* release_external_policy();
  void set_allocated_external_policy(std::string* external_policy);
  private:
  const std::string& _internal_external_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_policy(const std::string& value);
  std::string* _internal_mutable_external_policy();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceExternalPrintServersProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceExternalPrintServersAllowlistProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceExternalPrintServersAllowlistProto) */ {
 public:
  inline DeviceExternalPrintServersAllowlistProto() : DeviceExternalPrintServersAllowlistProto(nullptr) {}
  ~DeviceExternalPrintServersAllowlistProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceExternalPrintServersAllowlistProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceExternalPrintServersAllowlistProto(const DeviceExternalPrintServersAllowlistProto& from);
  DeviceExternalPrintServersAllowlistProto(DeviceExternalPrintServersAllowlistProto&& from) noexcept
    : DeviceExternalPrintServersAllowlistProto() {
    *this = ::std::move(from);
  }

  inline DeviceExternalPrintServersAllowlistProto& operator=(const DeviceExternalPrintServersAllowlistProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceExternalPrintServersAllowlistProto& operator=(DeviceExternalPrintServersAllowlistProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceExternalPrintServersAllowlistProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceExternalPrintServersAllowlistProto* internal_default_instance() {
    return reinterpret_cast<const DeviceExternalPrintServersAllowlistProto*>(
               &_DeviceExternalPrintServersAllowlistProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(DeviceExternalPrintServersAllowlistProto& a, DeviceExternalPrintServersAllowlistProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceExternalPrintServersAllowlistProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceExternalPrintServersAllowlistProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceExternalPrintServersAllowlistProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceExternalPrintServersAllowlistProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceExternalPrintServersAllowlistProto& from);
  void MergeFrom(const DeviceExternalPrintServersAllowlistProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceExternalPrintServersAllowlistProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceExternalPrintServersAllowlistProto";
  }
  protected:
  explicit DeviceExternalPrintServersAllowlistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowlistFieldNumber = 1,
  };
  // repeated string allowlist = 1;
  int allowlist_size() const;
  private:
  int _internal_allowlist_size() const;
  public:
  void clear_allowlist();
  const std::string& allowlist(int index) const;
  std::string* mutable_allowlist(int index);
  void set_allowlist(int index, const std::string& value);
  void set_allowlist(int index, std::string&& value);
  void set_allowlist(int index, const char* value);
  void set_allowlist(int index, const char* value, size_t size);
  std::string* add_allowlist();
  void add_allowlist(const std::string& value);
  void add_allowlist(std::string&& value);
  void add_allowlist(const char* value);
  void add_allowlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowlist();
  private:
  const std::string& _internal_allowlist(int index) const;
  std::string* _internal_add_allowlist();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceExternalPrintServersAllowlistProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowlist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class TPMFirmwareUpdateSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TPMFirmwareUpdateSettingsProto) */ {
 public:
  inline TPMFirmwareUpdateSettingsProto() : TPMFirmwareUpdateSettingsProto(nullptr) {}
  ~TPMFirmwareUpdateSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR TPMFirmwareUpdateSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TPMFirmwareUpdateSettingsProto(const TPMFirmwareUpdateSettingsProto& from);
  TPMFirmwareUpdateSettingsProto(TPMFirmwareUpdateSettingsProto&& from) noexcept
    : TPMFirmwareUpdateSettingsProto() {
    *this = ::std::move(from);
  }

  inline TPMFirmwareUpdateSettingsProto& operator=(const TPMFirmwareUpdateSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TPMFirmwareUpdateSettingsProto& operator=(TPMFirmwareUpdateSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TPMFirmwareUpdateSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TPMFirmwareUpdateSettingsProto* internal_default_instance() {
    return reinterpret_cast<const TPMFirmwareUpdateSettingsProto*>(
               &_TPMFirmwareUpdateSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(TPMFirmwareUpdateSettingsProto& a, TPMFirmwareUpdateSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TPMFirmwareUpdateSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TPMFirmwareUpdateSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TPMFirmwareUpdateSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TPMFirmwareUpdateSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TPMFirmwareUpdateSettingsProto& from);
  void MergeFrom(const TPMFirmwareUpdateSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TPMFirmwareUpdateSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.TPMFirmwareUpdateSettingsProto";
  }
  protected:
  explicit TPMFirmwareUpdateSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TPMFirmwareUpdateSettingsProto_AutoUpdateMode AutoUpdateMode;
  static constexpr AutoUpdateMode AUTO_UPDATE_MODE_UNSPECIFIED =
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AUTO_UPDATE_MODE_UNSPECIFIED;
  static constexpr AutoUpdateMode NEVER =
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode_NEVER;
  static constexpr AutoUpdateMode USER_ACKNOWLEDGMENT =
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode_USER_ACKNOWLEDGMENT;
  static constexpr AutoUpdateMode WITHOUT_ACKNOWLEDGMENT =
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode_WITHOUT_ACKNOWLEDGMENT;
  static constexpr AutoUpdateMode ENROLLMENT =
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode_ENROLLMENT;
  static inline bool AutoUpdateMode_IsValid(int value) {
    return TPMFirmwareUpdateSettingsProto_AutoUpdateMode_IsValid(value);
  }
  static constexpr AutoUpdateMode AutoUpdateMode_MIN =
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AutoUpdateMode_MIN;
  static constexpr AutoUpdateMode AutoUpdateMode_MAX =
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AutoUpdateMode_MAX;
  static constexpr int AutoUpdateMode_ARRAYSIZE =
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode_AutoUpdateMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AutoUpdateMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AutoUpdateMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AutoUpdateMode_Name.");
    return TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Name(enum_t_value);
  }
  static inline bool AutoUpdateMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AutoUpdateMode* value) {
    return TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAllowUserInitiatedPowerwashFieldNumber = 1,
    kAllowUserInitiatedPreserveDeviceStateFieldNumber = 2,
    kAutoUpdateModeFieldNumber = 3,
  };
  // optional bool allow_user_initiated_powerwash = 1;
  bool has_allow_user_initiated_powerwash() const;
  private:
  bool _internal_has_allow_user_initiated_powerwash() const;
  public:
  void clear_allow_user_initiated_powerwash();
  bool allow_user_initiated_powerwash() const;
  void set_allow_user_initiated_powerwash(bool value);
  private:
  bool _internal_allow_user_initiated_powerwash() const;
  void _internal_set_allow_user_initiated_powerwash(bool value);
  public:

  // optional bool allow_user_initiated_preserve_device_state = 2;
  bool has_allow_user_initiated_preserve_device_state() const;
  private:
  bool _internal_has_allow_user_initiated_preserve_device_state() const;
  public:
  void clear_allow_user_initiated_preserve_device_state();
  bool allow_user_initiated_preserve_device_state() const;
  void set_allow_user_initiated_preserve_device_state(bool value);
  private:
  bool _internal_allow_user_initiated_preserve_device_state() const;
  void _internal_set_allow_user_initiated_preserve_device_state(bool value);
  public:

  // optional .enterprise_management.TPMFirmwareUpdateSettingsProto.AutoUpdateMode auto_update_mode = 3 [default = NEVER];
  bool has_auto_update_mode() const;
  private:
  bool _internal_has_auto_update_mode() const;
  public:
  void clear_auto_update_mode();
  ::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode auto_update_mode() const;
  void set_auto_update_mode(::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode value);
  private:
  ::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode _internal_auto_update_mode() const;
  void _internal_set_auto_update_mode(::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.TPMFirmwareUpdateSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool allow_user_initiated_powerwash_;
    bool allow_user_initiated_preserve_device_state_;
    int auto_update_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_MinimumRequiredVersionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_MinimumRequiredVersionProto) */ {
 public:
  inline OBSOLETE_MinimumRequiredVersionProto() : OBSOLETE_MinimumRequiredVersionProto(nullptr) {}
  ~OBSOLETE_MinimumRequiredVersionProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_MinimumRequiredVersionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_MinimumRequiredVersionProto(const OBSOLETE_MinimumRequiredVersionProto& from);
  OBSOLETE_MinimumRequiredVersionProto(OBSOLETE_MinimumRequiredVersionProto&& from) noexcept
    : OBSOLETE_MinimumRequiredVersionProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_MinimumRequiredVersionProto& operator=(const OBSOLETE_MinimumRequiredVersionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_MinimumRequiredVersionProto& operator=(OBSOLETE_MinimumRequiredVersionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_MinimumRequiredVersionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_MinimumRequiredVersionProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_MinimumRequiredVersionProto*>(
               &_OBSOLETE_MinimumRequiredVersionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(OBSOLETE_MinimumRequiredVersionProto& a, OBSOLETE_MinimumRequiredVersionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_MinimumRequiredVersionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_MinimumRequiredVersionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_MinimumRequiredVersionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_MinimumRequiredVersionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_MinimumRequiredVersionProto& from);
  void MergeFrom(const OBSOLETE_MinimumRequiredVersionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_MinimumRequiredVersionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_MinimumRequiredVersionProto";
  }
  protected:
  explicit OBSOLETE_MinimumRequiredVersionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEChromeVersionFieldNumber = 1,
  };
  // optional string OBSOLETE_chrome_version = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_chrome_version() const;
  private:
  bool _internal_has_obsolete_chrome_version() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_chrome_version();
  PROTOBUF_DEPRECATED const std::string& obsolete_chrome_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_chrome_version(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_chrome_version();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_chrome_version();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_chrome_version(std::string* obsolete_chrome_version);
  private:
  const std::string& _internal_obsolete_chrome_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_chrome_version(const std::string& value);
  std::string* _internal_mutable_obsolete_chrome_version();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_chrome_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceLoginScreenAutoSelectCertificateForUrls final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls) */ {
 public:
  inline DeviceLoginScreenAutoSelectCertificateForUrls() : DeviceLoginScreenAutoSelectCertificateForUrls(nullptr) {}
  ~DeviceLoginScreenAutoSelectCertificateForUrls() override;
  explicit PROTOBUF_CONSTEXPR DeviceLoginScreenAutoSelectCertificateForUrls(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLoginScreenAutoSelectCertificateForUrls(const DeviceLoginScreenAutoSelectCertificateForUrls& from);
  DeviceLoginScreenAutoSelectCertificateForUrls(DeviceLoginScreenAutoSelectCertificateForUrls&& from) noexcept
    : DeviceLoginScreenAutoSelectCertificateForUrls() {
    *this = ::std::move(from);
  }

  inline DeviceLoginScreenAutoSelectCertificateForUrls& operator=(const DeviceLoginScreenAutoSelectCertificateForUrls& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLoginScreenAutoSelectCertificateForUrls& operator=(DeviceLoginScreenAutoSelectCertificateForUrls&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceLoginScreenAutoSelectCertificateForUrls& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLoginScreenAutoSelectCertificateForUrls* internal_default_instance() {
    return reinterpret_cast<const DeviceLoginScreenAutoSelectCertificateForUrls*>(
               &_DeviceLoginScreenAutoSelectCertificateForUrls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(DeviceLoginScreenAutoSelectCertificateForUrls& a, DeviceLoginScreenAutoSelectCertificateForUrls& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLoginScreenAutoSelectCertificateForUrls* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLoginScreenAutoSelectCertificateForUrls* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLoginScreenAutoSelectCertificateForUrls* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLoginScreenAutoSelectCertificateForUrls>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceLoginScreenAutoSelectCertificateForUrls& from);
  void MergeFrom(const DeviceLoginScreenAutoSelectCertificateForUrls& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceLoginScreenAutoSelectCertificateForUrls* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls";
  }
  protected:
  explicit DeviceLoginScreenAutoSelectCertificateForUrls(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginScreenAutoSelectCertificateRulesFieldNumber = 1,
  };
  // repeated string login_screen_auto_select_certificate_rules = 1;
  int login_screen_auto_select_certificate_rules_size() const;
  private:
  int _internal_login_screen_auto_select_certificate_rules_size() const;
  public:
  void clear_login_screen_auto_select_certificate_rules();
  const std::string& login_screen_auto_select_certificate_rules(int index) const;
  std::string* mutable_login_screen_auto_select_certificate_rules(int index);
  void set_login_screen_auto_select_certificate_rules(int index, const std::string& value);
  void set_login_screen_auto_select_certificate_rules(int index, std::string&& value);
  void set_login_screen_auto_select_certificate_rules(int index, const char* value);
  void set_login_screen_auto_select_certificate_rules(int index, const char* value, size_t size);
  std::string* add_login_screen_auto_select_certificate_rules();
  void add_login_screen_auto_select_certificate_rules(const std::string& value);
  void add_login_screen_auto_select_certificate_rules(std::string&& value);
  void add_login_screen_auto_select_certificate_rules(const char* value);
  void add_login_screen_auto_select_certificate_rules(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& login_screen_auto_select_certificate_rules() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_login_screen_auto_select_certificate_rules();
  private:
  const std::string& _internal_login_screen_auto_select_certificate_rules(int index) const;
  std::string* _internal_add_login_screen_auto_select_certificate_rules();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> login_screen_auto_select_certificate_rules_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class UnaffiliatedArcAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UnaffiliatedArcAllowedProto) */ {
 public:
  inline UnaffiliatedArcAllowedProto() : UnaffiliatedArcAllowedProto(nullptr) {}
  ~UnaffiliatedArcAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR UnaffiliatedArcAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnaffiliatedArcAllowedProto(const UnaffiliatedArcAllowedProto& from);
  UnaffiliatedArcAllowedProto(UnaffiliatedArcAllowedProto&& from) noexcept
    : UnaffiliatedArcAllowedProto() {
    *this = ::std::move(from);
  }

  inline UnaffiliatedArcAllowedProto& operator=(const UnaffiliatedArcAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaffiliatedArcAllowedProto& operator=(UnaffiliatedArcAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UnaffiliatedArcAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnaffiliatedArcAllowedProto* internal_default_instance() {
    return reinterpret_cast<const UnaffiliatedArcAllowedProto*>(
               &_UnaffiliatedArcAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(UnaffiliatedArcAllowedProto& a, UnaffiliatedArcAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaffiliatedArcAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnaffiliatedArcAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnaffiliatedArcAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnaffiliatedArcAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UnaffiliatedArcAllowedProto& from);
  void MergeFrom(const UnaffiliatedArcAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnaffiliatedArcAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UnaffiliatedArcAllowedProto";
  }
  protected:
  explicit UnaffiliatedArcAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnaffiliatedArcAllowedFieldNumber = 1,
  };
  // optional bool unaffiliated_arc_allowed = 1;
  bool has_unaffiliated_arc_allowed() const;
  private:
  bool _internal_has_unaffiliated_arc_allowed() const;
  public:
  void clear_unaffiliated_arc_allowed();
  bool unaffiliated_arc_allowed() const;
  void set_unaffiliated_arc_allowed(bool value);
  private:
  bool _internal_unaffiliated_arc_allowed() const;
  void _internal_set_unaffiliated_arc_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.UnaffiliatedArcAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool unaffiliated_arc_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceKerberosEncryptionTypesProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceKerberosEncryptionTypesProto) */ {
 public:
  inline DeviceKerberosEncryptionTypesProto() : DeviceKerberosEncryptionTypesProto(nullptr) {}
  ~DeviceKerberosEncryptionTypesProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceKerberosEncryptionTypesProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceKerberosEncryptionTypesProto(const DeviceKerberosEncryptionTypesProto& from);
  DeviceKerberosEncryptionTypesProto(DeviceKerberosEncryptionTypesProto&& from) noexcept
    : DeviceKerberosEncryptionTypesProto() {
    *this = ::std::move(from);
  }

  inline DeviceKerberosEncryptionTypesProto& operator=(const DeviceKerberosEncryptionTypesProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceKerberosEncryptionTypesProto& operator=(DeviceKerberosEncryptionTypesProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceKerberosEncryptionTypesProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceKerberosEncryptionTypesProto* internal_default_instance() {
    return reinterpret_cast<const DeviceKerberosEncryptionTypesProto*>(
               &_DeviceKerberosEncryptionTypesProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(DeviceKerberosEncryptionTypesProto& a, DeviceKerberosEncryptionTypesProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceKerberosEncryptionTypesProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceKerberosEncryptionTypesProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceKerberosEncryptionTypesProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceKerberosEncryptionTypesProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceKerberosEncryptionTypesProto& from);
  void MergeFrom(const DeviceKerberosEncryptionTypesProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceKerberosEncryptionTypesProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceKerberosEncryptionTypesProto";
  }
  protected:
  explicit DeviceKerberosEncryptionTypesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceKerberosEncryptionTypesProto_Types Types;
  static constexpr Types ENC_TYPES_ALL =
    DeviceKerberosEncryptionTypesProto_Types_ENC_TYPES_ALL;
  static constexpr Types ENC_TYPES_STRONG =
    DeviceKerberosEncryptionTypesProto_Types_ENC_TYPES_STRONG;
  static constexpr Types ENC_TYPES_LEGACY =
    DeviceKerberosEncryptionTypesProto_Types_ENC_TYPES_LEGACY;
  static inline bool Types_IsValid(int value) {
    return DeviceKerberosEncryptionTypesProto_Types_IsValid(value);
  }
  static constexpr Types Types_MIN =
    DeviceKerberosEncryptionTypesProto_Types_Types_MIN;
  static constexpr Types Types_MAX =
    DeviceKerberosEncryptionTypesProto_Types_Types_MAX;
  static constexpr int Types_ARRAYSIZE =
    DeviceKerberosEncryptionTypesProto_Types_Types_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Types_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Types>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Types_Name.");
    return DeviceKerberosEncryptionTypesProto_Types_Name(enum_t_value);
  }
  static inline bool Types_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Types* value) {
    return DeviceKerberosEncryptionTypesProto_Types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceKerberosEncryptionTypesProto.Types types = 1 [default = ENC_TYPES_STRONG];
  bool has_types() const;
  private:
  bool _internal_has_types() const;
  public:
  void clear_types();
  ::enterprise_management::DeviceKerberosEncryptionTypesProto_Types types() const;
  void set_types(::enterprise_management::DeviceKerberosEncryptionTypesProto_Types value);
  private:
  ::enterprise_management::DeviceKerberosEncryptionTypesProto_Types _internal_types() const;
  void _internal_set_types(::enterprise_management::DeviceKerberosEncryptionTypesProto_Types value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceKerberosEncryptionTypesProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int types_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class KeyboardBacklightColorProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.KeyboardBacklightColorProto) */ {
 public:
  inline KeyboardBacklightColorProto() : KeyboardBacklightColorProto(nullptr) {}
  ~KeyboardBacklightColorProto() override;
  explicit PROTOBUF_CONSTEXPR KeyboardBacklightColorProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyboardBacklightColorProto(const KeyboardBacklightColorProto& from);
  KeyboardBacklightColorProto(KeyboardBacklightColorProto&& from) noexcept
    : KeyboardBacklightColorProto() {
    *this = ::std::move(from);
  }

  inline KeyboardBacklightColorProto& operator=(const KeyboardBacklightColorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyboardBacklightColorProto& operator=(KeyboardBacklightColorProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeyboardBacklightColorProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyboardBacklightColorProto* internal_default_instance() {
    return reinterpret_cast<const KeyboardBacklightColorProto*>(
               &_KeyboardBacklightColorProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(KeyboardBacklightColorProto& a, KeyboardBacklightColorProto& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyboardBacklightColorProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyboardBacklightColorProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyboardBacklightColorProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyboardBacklightColorProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeyboardBacklightColorProto& from);
  void MergeFrom(const KeyboardBacklightColorProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyboardBacklightColorProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.KeyboardBacklightColorProto";
  }
  protected:
  explicit KeyboardBacklightColorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef KeyboardBacklightColorProto_BacklightColor BacklightColor;
  static constexpr BacklightColor BACKLIGHT_UNSPECIFIED =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_UNSPECIFIED;
  static constexpr BacklightColor BACKLIGHT_WHITE =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_WHITE;
  static constexpr BacklightColor BACKLIGHT_RED =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_RED;
  static constexpr BacklightColor BACKLIGHT_YELLOW =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_YELLOW;
  static constexpr BacklightColor BACKLIGHT_GREEN =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_GREEN;
  static constexpr BacklightColor BACKLIGHT_BLUE =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_BLUE;
  static constexpr BacklightColor BACKLIGHT_INDIGO =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_INDIGO;
  static constexpr BacklightColor BACKLIGHT_PURPLE =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_PURPLE;
  static constexpr BacklightColor BACKLIGHT_RAINBOW =
    KeyboardBacklightColorProto_BacklightColor_BACKLIGHT_RAINBOW;
  static inline bool BacklightColor_IsValid(int value) {
    return KeyboardBacklightColorProto_BacklightColor_IsValid(value);
  }
  static constexpr BacklightColor BacklightColor_MIN =
    KeyboardBacklightColorProto_BacklightColor_BacklightColor_MIN;
  static constexpr BacklightColor BacklightColor_MAX =
    KeyboardBacklightColorProto_BacklightColor_BacklightColor_MAX;
  static constexpr int BacklightColor_ARRAYSIZE =
    KeyboardBacklightColorProto_BacklightColor_BacklightColor_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BacklightColor_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BacklightColor>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BacklightColor_Name.");
    return KeyboardBacklightColorProto_BacklightColor_Name(enum_t_value);
  }
  static inline bool BacklightColor_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BacklightColor* value) {
    return KeyboardBacklightColorProto_BacklightColor_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // optional .enterprise_management.KeyboardBacklightColorProto.BacklightColor color = 1 [default = BACKLIGHT_UNSPECIFIED];
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::enterprise_management::KeyboardBacklightColorProto_BacklightColor color() const;
  void set_color(::enterprise_management::KeyboardBacklightColorProto_BacklightColor value);
  private:
  ::enterprise_management::KeyboardBacklightColorProto_BacklightColor _internal_color() const;
  void _internal_set_color(::enterprise_management::KeyboardBacklightColorProto_BacklightColor value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.KeyboardBacklightColorProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int color_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceUserPolicyLoopbackProcessingModeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto) */ {
 public:
  inline DeviceUserPolicyLoopbackProcessingModeProto() : DeviceUserPolicyLoopbackProcessingModeProto(nullptr) {}
  ~DeviceUserPolicyLoopbackProcessingModeProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceUserPolicyLoopbackProcessingModeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceUserPolicyLoopbackProcessingModeProto(const DeviceUserPolicyLoopbackProcessingModeProto& from);
  DeviceUserPolicyLoopbackProcessingModeProto(DeviceUserPolicyLoopbackProcessingModeProto&& from) noexcept
    : DeviceUserPolicyLoopbackProcessingModeProto() {
    *this = ::std::move(from);
  }

  inline DeviceUserPolicyLoopbackProcessingModeProto& operator=(const DeviceUserPolicyLoopbackProcessingModeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceUserPolicyLoopbackProcessingModeProto& operator=(DeviceUserPolicyLoopbackProcessingModeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceUserPolicyLoopbackProcessingModeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceUserPolicyLoopbackProcessingModeProto* internal_default_instance() {
    return reinterpret_cast<const DeviceUserPolicyLoopbackProcessingModeProto*>(
               &_DeviceUserPolicyLoopbackProcessingModeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(DeviceUserPolicyLoopbackProcessingModeProto& a, DeviceUserPolicyLoopbackProcessingModeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceUserPolicyLoopbackProcessingModeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceUserPolicyLoopbackProcessingModeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceUserPolicyLoopbackProcessingModeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceUserPolicyLoopbackProcessingModeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceUserPolicyLoopbackProcessingModeProto& from);
  void MergeFrom(const DeviceUserPolicyLoopbackProcessingModeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceUserPolicyLoopbackProcessingModeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto";
  }
  protected:
  explicit DeviceUserPolicyLoopbackProcessingModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceUserPolicyLoopbackProcessingModeProto_Mode Mode;
  static constexpr Mode USER_POLICY_MODE_DEFAULT =
    DeviceUserPolicyLoopbackProcessingModeProto_Mode_USER_POLICY_MODE_DEFAULT;
  static constexpr Mode USER_POLICY_MODE_MERGE =
    DeviceUserPolicyLoopbackProcessingModeProto_Mode_USER_POLICY_MODE_MERGE;
  static constexpr Mode USER_POLICY_MODE_REPLACE =
    DeviceUserPolicyLoopbackProcessingModeProto_Mode_USER_POLICY_MODE_REPLACE;
  static inline bool Mode_IsValid(int value) {
    return DeviceUserPolicyLoopbackProcessingModeProto_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    DeviceUserPolicyLoopbackProcessingModeProto_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    DeviceUserPolicyLoopbackProcessingModeProto_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    DeviceUserPolicyLoopbackProcessingModeProto_Mode_Mode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return DeviceUserPolicyLoopbackProcessingModeProto_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return DeviceUserPolicyLoopbackProcessingModeProto_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto.Mode mode = 1 [default = USER_POLICY_MODE_DEFAULT];
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode mode() const;
  void set_mode(::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode value);
  private:
  ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode _internal_mode() const;
  void _internal_set_mode(::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_DeviceLoginScreenIsolateOriginsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto) */ {
 public:
  inline OBSOLETE_DeviceLoginScreenIsolateOriginsProto() : OBSOLETE_DeviceLoginScreenIsolateOriginsProto(nullptr) {}
  ~OBSOLETE_DeviceLoginScreenIsolateOriginsProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_DeviceLoginScreenIsolateOriginsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_DeviceLoginScreenIsolateOriginsProto(const OBSOLETE_DeviceLoginScreenIsolateOriginsProto& from);
  OBSOLETE_DeviceLoginScreenIsolateOriginsProto(OBSOLETE_DeviceLoginScreenIsolateOriginsProto&& from) noexcept
    : OBSOLETE_DeviceLoginScreenIsolateOriginsProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_DeviceLoginScreenIsolateOriginsProto& operator=(const OBSOLETE_DeviceLoginScreenIsolateOriginsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_DeviceLoginScreenIsolateOriginsProto& operator=(OBSOLETE_DeviceLoginScreenIsolateOriginsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_DeviceLoginScreenIsolateOriginsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_DeviceLoginScreenIsolateOriginsProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_DeviceLoginScreenIsolateOriginsProto*>(
               &_OBSOLETE_DeviceLoginScreenIsolateOriginsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(OBSOLETE_DeviceLoginScreenIsolateOriginsProto& a, OBSOLETE_DeviceLoginScreenIsolateOriginsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_DeviceLoginScreenIsolateOriginsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_DeviceLoginScreenIsolateOriginsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_DeviceLoginScreenIsolateOriginsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_DeviceLoginScreenIsolateOriginsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_DeviceLoginScreenIsolateOriginsProto& from);
  void MergeFrom(const OBSOLETE_DeviceLoginScreenIsolateOriginsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_DeviceLoginScreenIsolateOriginsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto";
  }
  protected:
  explicit OBSOLETE_DeviceLoginScreenIsolateOriginsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETEIsolateOriginsFieldNumber = 1,
  };
  // optional string OBSOLETE_isolate_origins = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_isolate_origins() const;
  private:
  bool _internal_has_obsolete_isolate_origins() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_isolate_origins();
  PROTOBUF_DEPRECATED const std::string& obsolete_isolate_origins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_obsolete_isolate_origins(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_obsolete_isolate_origins();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_obsolete_isolate_origins();
  PROTOBUF_DEPRECATED void set_allocated_obsolete_isolate_origins(std::string* obsolete_isolate_origins);
  private:
  const std::string& _internal_obsolete_isolate_origins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsolete_isolate_origins(const std::string& value);
  std::string* _internal_mutable_obsolete_isolate_origins();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsolete_isolate_origins_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_DeviceLoginScreenSitePerProcessProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto) */ {
 public:
  inline OBSOLETE_DeviceLoginScreenSitePerProcessProto() : OBSOLETE_DeviceLoginScreenSitePerProcessProto(nullptr) {}
  ~OBSOLETE_DeviceLoginScreenSitePerProcessProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_DeviceLoginScreenSitePerProcessProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_DeviceLoginScreenSitePerProcessProto(const OBSOLETE_DeviceLoginScreenSitePerProcessProto& from);
  OBSOLETE_DeviceLoginScreenSitePerProcessProto(OBSOLETE_DeviceLoginScreenSitePerProcessProto&& from) noexcept
    : OBSOLETE_DeviceLoginScreenSitePerProcessProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_DeviceLoginScreenSitePerProcessProto& operator=(const OBSOLETE_DeviceLoginScreenSitePerProcessProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_DeviceLoginScreenSitePerProcessProto& operator=(OBSOLETE_DeviceLoginScreenSitePerProcessProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_DeviceLoginScreenSitePerProcessProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_DeviceLoginScreenSitePerProcessProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_DeviceLoginScreenSitePerProcessProto*>(
               &_OBSOLETE_DeviceLoginScreenSitePerProcessProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(OBSOLETE_DeviceLoginScreenSitePerProcessProto& a, OBSOLETE_DeviceLoginScreenSitePerProcessProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_DeviceLoginScreenSitePerProcessProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_DeviceLoginScreenSitePerProcessProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_DeviceLoginScreenSitePerProcessProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_DeviceLoginScreenSitePerProcessProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_DeviceLoginScreenSitePerProcessProto& from);
  void MergeFrom(const OBSOLETE_DeviceLoginScreenSitePerProcessProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_DeviceLoginScreenSitePerProcessProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto";
  }
  protected:
  explicit OBSOLETE_DeviceLoginScreenSitePerProcessProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETESitePerProcessFieldNumber = 1,
  };
  // optional bool OBSOLETE_site_per_process = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_site_per_process() const;
  private:
  bool _internal_has_obsolete_site_per_process() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_site_per_process();
  PROTOBUF_DEPRECATED bool obsolete_site_per_process() const;
  PROTOBUF_DEPRECATED void set_obsolete_site_per_process(bool value);
  private:
  bool _internal_obsolete_site_per_process() const;
  void _internal_set_obsolete_site_per_process(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool obsolete_site_per_process_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachinesAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.VirtualMachinesAllowedProto) */ {
 public:
  inline VirtualMachinesAllowedProto() : VirtualMachinesAllowedProto(nullptr) {}
  ~VirtualMachinesAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR VirtualMachinesAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachinesAllowedProto(const VirtualMachinesAllowedProto& from);
  VirtualMachinesAllowedProto(VirtualMachinesAllowedProto&& from) noexcept
    : VirtualMachinesAllowedProto() {
    *this = ::std::move(from);
  }

  inline VirtualMachinesAllowedProto& operator=(const VirtualMachinesAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachinesAllowedProto& operator=(VirtualMachinesAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VirtualMachinesAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachinesAllowedProto* internal_default_instance() {
    return reinterpret_cast<const VirtualMachinesAllowedProto*>(
               &_VirtualMachinesAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(VirtualMachinesAllowedProto& a, VirtualMachinesAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachinesAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachinesAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirtualMachinesAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirtualMachinesAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VirtualMachinesAllowedProto& from);
  void MergeFrom(const VirtualMachinesAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VirtualMachinesAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.VirtualMachinesAllowedProto";
  }
  protected:
  explicit VirtualMachinesAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualMachinesAllowedFieldNumber = 1,
  };
  // optional bool virtual_machines_allowed = 1;
  bool has_virtual_machines_allowed() const;
  private:
  bool _internal_has_virtual_machines_allowed() const;
  public:
  void clear_virtual_machines_allowed();
  bool virtual_machines_allowed() const;
  void set_virtual_machines_allowed(bool value);
  private:
  bool _internal_virtual_machines_allowed() const;
  void _internal_set_virtual_machines_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.VirtualMachinesAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool virtual_machines_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceMachinePasswordChangeRateProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceMachinePasswordChangeRateProto) */ {
 public:
  inline DeviceMachinePasswordChangeRateProto() : DeviceMachinePasswordChangeRateProto(nullptr) {}
  ~DeviceMachinePasswordChangeRateProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceMachinePasswordChangeRateProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceMachinePasswordChangeRateProto(const DeviceMachinePasswordChangeRateProto& from);
  DeviceMachinePasswordChangeRateProto(DeviceMachinePasswordChangeRateProto&& from) noexcept
    : DeviceMachinePasswordChangeRateProto() {
    *this = ::std::move(from);
  }

  inline DeviceMachinePasswordChangeRateProto& operator=(const DeviceMachinePasswordChangeRateProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMachinePasswordChangeRateProto& operator=(DeviceMachinePasswordChangeRateProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceMachinePasswordChangeRateProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceMachinePasswordChangeRateProto* internal_default_instance() {
    return reinterpret_cast<const DeviceMachinePasswordChangeRateProto*>(
               &_DeviceMachinePasswordChangeRateProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(DeviceMachinePasswordChangeRateProto& a, DeviceMachinePasswordChangeRateProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMachinePasswordChangeRateProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMachinePasswordChangeRateProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceMachinePasswordChangeRateProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceMachinePasswordChangeRateProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceMachinePasswordChangeRateProto& from);
  void MergeFrom(const DeviceMachinePasswordChangeRateProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceMachinePasswordChangeRateProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceMachinePasswordChangeRateProto";
  }
  protected:
  explicit DeviceMachinePasswordChangeRateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRateDaysFieldNumber = 1,
  };
  // optional int32 rate_days = 1;
  bool has_rate_days() const;
  private:
  bool _internal_has_rate_days() const;
  public:
  void clear_rate_days();
  int32_t rate_days() const;
  void set_rate_days(int32_t value);
  private:
  int32_t _internal_rate_days() const;
  void _internal_set_rate_days(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceMachinePasswordChangeRateProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t rate_days_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceGpoCacheLifetimeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceGpoCacheLifetimeProto) */ {
 public:
  inline DeviceGpoCacheLifetimeProto() : DeviceGpoCacheLifetimeProto(nullptr) {}
  ~DeviceGpoCacheLifetimeProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceGpoCacheLifetimeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceGpoCacheLifetimeProto(const DeviceGpoCacheLifetimeProto& from);
  DeviceGpoCacheLifetimeProto(DeviceGpoCacheLifetimeProto&& from) noexcept
    : DeviceGpoCacheLifetimeProto() {
    *this = ::std::move(from);
  }

  inline DeviceGpoCacheLifetimeProto& operator=(const DeviceGpoCacheLifetimeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceGpoCacheLifetimeProto& operator=(DeviceGpoCacheLifetimeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceGpoCacheLifetimeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceGpoCacheLifetimeProto* internal_default_instance() {
    return reinterpret_cast<const DeviceGpoCacheLifetimeProto*>(
               &_DeviceGpoCacheLifetimeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(DeviceGpoCacheLifetimeProto& a, DeviceGpoCacheLifetimeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceGpoCacheLifetimeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceGpoCacheLifetimeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceGpoCacheLifetimeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceGpoCacheLifetimeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceGpoCacheLifetimeProto& from);
  void MergeFrom(const DeviceGpoCacheLifetimeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceGpoCacheLifetimeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceGpoCacheLifetimeProto";
  }
  protected:
  explicit DeviceGpoCacheLifetimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLifetimeHoursFieldNumber = 1,
  };
  // optional int32 lifetime_hours = 1;
  bool has_lifetime_hours() const;
  private:
  bool _internal_has_lifetime_hours() const;
  public:
  void clear_lifetime_hours();
  int32_t lifetime_hours() const;
  void set_lifetime_hours(int32_t value);
  private:
  int32_t _internal_lifetime_hours() const;
  void _internal_set_lifetime_hours(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceGpoCacheLifetimeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t lifetime_hours_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceAuthDataCacheLifetimeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAuthDataCacheLifetimeProto) */ {
 public:
  inline DeviceAuthDataCacheLifetimeProto() : DeviceAuthDataCacheLifetimeProto(nullptr) {}
  ~DeviceAuthDataCacheLifetimeProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceAuthDataCacheLifetimeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAuthDataCacheLifetimeProto(const DeviceAuthDataCacheLifetimeProto& from);
  DeviceAuthDataCacheLifetimeProto(DeviceAuthDataCacheLifetimeProto&& from) noexcept
    : DeviceAuthDataCacheLifetimeProto() {
    *this = ::std::move(from);
  }

  inline DeviceAuthDataCacheLifetimeProto& operator=(const DeviceAuthDataCacheLifetimeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAuthDataCacheLifetimeProto& operator=(DeviceAuthDataCacheLifetimeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAuthDataCacheLifetimeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAuthDataCacheLifetimeProto* internal_default_instance() {
    return reinterpret_cast<const DeviceAuthDataCacheLifetimeProto*>(
               &_DeviceAuthDataCacheLifetimeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(DeviceAuthDataCacheLifetimeProto& a, DeviceAuthDataCacheLifetimeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAuthDataCacheLifetimeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAuthDataCacheLifetimeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAuthDataCacheLifetimeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAuthDataCacheLifetimeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAuthDataCacheLifetimeProto& from);
  void MergeFrom(const DeviceAuthDataCacheLifetimeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAuthDataCacheLifetimeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAuthDataCacheLifetimeProto";
  }
  protected:
  explicit DeviceAuthDataCacheLifetimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLifetimeHoursFieldNumber = 1,
  };
  // optional int32 lifetime_hours = 1;
  bool has_lifetime_hours() const;
  private:
  bool _internal_has_lifetime_hours() const;
  public:
  void clear_lifetime_hours();
  int32_t lifetime_hours() const;
  void set_lifetime_hours(int32_t value);
  private:
  int32_t _internal_lifetime_hours() const;
  void _internal_set_lifetime_hours(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAuthDataCacheLifetimeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t lifetime_hours_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceUnaffiliatedCrostiniAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto) */ {
 public:
  inline DeviceUnaffiliatedCrostiniAllowedProto() : DeviceUnaffiliatedCrostiniAllowedProto(nullptr) {}
  ~DeviceUnaffiliatedCrostiniAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceUnaffiliatedCrostiniAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceUnaffiliatedCrostiniAllowedProto(const DeviceUnaffiliatedCrostiniAllowedProto& from);
  DeviceUnaffiliatedCrostiniAllowedProto(DeviceUnaffiliatedCrostiniAllowedProto&& from) noexcept
    : DeviceUnaffiliatedCrostiniAllowedProto() {
    *this = ::std::move(from);
  }

  inline DeviceUnaffiliatedCrostiniAllowedProto& operator=(const DeviceUnaffiliatedCrostiniAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceUnaffiliatedCrostiniAllowedProto& operator=(DeviceUnaffiliatedCrostiniAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceUnaffiliatedCrostiniAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceUnaffiliatedCrostiniAllowedProto* internal_default_instance() {
    return reinterpret_cast<const DeviceUnaffiliatedCrostiniAllowedProto*>(
               &_DeviceUnaffiliatedCrostiniAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(DeviceUnaffiliatedCrostiniAllowedProto& a, DeviceUnaffiliatedCrostiniAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceUnaffiliatedCrostiniAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceUnaffiliatedCrostiniAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceUnaffiliatedCrostiniAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceUnaffiliatedCrostiniAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceUnaffiliatedCrostiniAllowedProto& from);
  void MergeFrom(const DeviceUnaffiliatedCrostiniAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceUnaffiliatedCrostiniAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto";
  }
  protected:
  explicit DeviceUnaffiliatedCrostiniAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceUnaffiliatedCrostiniAllowedFieldNumber = 1,
  };
  // optional bool device_unaffiliated_crostini_allowed = 1;
  bool has_device_unaffiliated_crostini_allowed() const;
  private:
  bool _internal_has_device_unaffiliated_crostini_allowed() const;
  public:
  void clear_device_unaffiliated_crostini_allowed();
  bool device_unaffiliated_crostini_allowed() const;
  void set_device_unaffiliated_crostini_allowed(bool value);
  private:
  bool _internal_device_unaffiliated_crostini_allowed() const;
  void _internal_set_device_unaffiliated_crostini_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_unaffiliated_crostini_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class PluginVmAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PluginVmAllowedProto) */ {
 public:
  inline PluginVmAllowedProto() : PluginVmAllowedProto(nullptr) {}
  ~PluginVmAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR PluginVmAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginVmAllowedProto(const PluginVmAllowedProto& from);
  PluginVmAllowedProto(PluginVmAllowedProto&& from) noexcept
    : PluginVmAllowedProto() {
    *this = ::std::move(from);
  }

  inline PluginVmAllowedProto& operator=(const PluginVmAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginVmAllowedProto& operator=(PluginVmAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PluginVmAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginVmAllowedProto* internal_default_instance() {
    return reinterpret_cast<const PluginVmAllowedProto*>(
               &_PluginVmAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(PluginVmAllowedProto& a, PluginVmAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginVmAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginVmAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginVmAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginVmAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PluginVmAllowedProto& from);
  void MergeFrom(const PluginVmAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PluginVmAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PluginVmAllowedProto";
  }
  protected:
  explicit PluginVmAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginVmAllowedFieldNumber = 1,
  };
  // optional bool plugin_vm_allowed = 1;
  bool has_plugin_vm_allowed() const;
  private:
  bool _internal_has_plugin_vm_allowed() const;
  public:
  void clear_plugin_vm_allowed();
  bool plugin_vm_allowed() const;
  void set_plugin_vm_allowed(bool value);
  private:
  bool _internal_plugin_vm_allowed() const;
  void _internal_set_plugin_vm_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PluginVmAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool plugin_vm_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class PluginVmLicenseKeyProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PluginVmLicenseKeyProto) */ {
 public:
  inline PluginVmLicenseKeyProto() : PluginVmLicenseKeyProto(nullptr) {}
  ~PluginVmLicenseKeyProto() override;
  explicit PROTOBUF_CONSTEXPR PluginVmLicenseKeyProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginVmLicenseKeyProto(const PluginVmLicenseKeyProto& from);
  PluginVmLicenseKeyProto(PluginVmLicenseKeyProto&& from) noexcept
    : PluginVmLicenseKeyProto() {
    *this = ::std::move(from);
  }

  inline PluginVmLicenseKeyProto& operator=(const PluginVmLicenseKeyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginVmLicenseKeyProto& operator=(PluginVmLicenseKeyProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PluginVmLicenseKeyProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginVmLicenseKeyProto* internal_default_instance() {
    return reinterpret_cast<const PluginVmLicenseKeyProto*>(
               &_PluginVmLicenseKeyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(PluginVmLicenseKeyProto& a, PluginVmLicenseKeyProto& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginVmLicenseKeyProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginVmLicenseKeyProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginVmLicenseKeyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginVmLicenseKeyProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PluginVmLicenseKeyProto& from);
  void MergeFrom(const PluginVmLicenseKeyProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PluginVmLicenseKeyProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PluginVmLicenseKeyProto";
  }
  protected:
  explicit PluginVmLicenseKeyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginVmLicenseKeyFieldNumber = 1,
  };
  // optional string plugin_vm_license_key = 1;
  bool has_plugin_vm_license_key() const;
  private:
  bool _internal_has_plugin_vm_license_key() const;
  public:
  void clear_plugin_vm_license_key();
  const std::string& plugin_vm_license_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_vm_license_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_vm_license_key();
  PROTOBUF_NODISCARD std::string* release_plugin_vm_license_key();
  void set_allocated_plugin_vm_license_key(std::string* plugin_vm_license_key);
  private:
  const std::string& _internal_plugin_vm_license_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_vm_license_key(const std::string& value);
  std::string* _internal_mutable_plugin_vm_license_key();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PluginVmLicenseKeyProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_vm_license_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceRebootOnUserSignoutProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRebootOnUserSignoutProto) */ {
 public:
  inline DeviceRebootOnUserSignoutProto() : DeviceRebootOnUserSignoutProto(nullptr) {}
  ~DeviceRebootOnUserSignoutProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceRebootOnUserSignoutProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRebootOnUserSignoutProto(const DeviceRebootOnUserSignoutProto& from);
  DeviceRebootOnUserSignoutProto(DeviceRebootOnUserSignoutProto&& from) noexcept
    : DeviceRebootOnUserSignoutProto() {
    *this = ::std::move(from);
  }

  inline DeviceRebootOnUserSignoutProto& operator=(const DeviceRebootOnUserSignoutProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRebootOnUserSignoutProto& operator=(DeviceRebootOnUserSignoutProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceRebootOnUserSignoutProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRebootOnUserSignoutProto* internal_default_instance() {
    return reinterpret_cast<const DeviceRebootOnUserSignoutProto*>(
               &_DeviceRebootOnUserSignoutProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(DeviceRebootOnUserSignoutProto& a, DeviceRebootOnUserSignoutProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRebootOnUserSignoutProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRebootOnUserSignoutProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRebootOnUserSignoutProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRebootOnUserSignoutProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceRebootOnUserSignoutProto& from);
  void MergeFrom(const DeviceRebootOnUserSignoutProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRebootOnUserSignoutProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceRebootOnUserSignoutProto";
  }
  protected:
  explicit DeviceRebootOnUserSignoutProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceRebootOnUserSignoutProto_RebootOnSignoutMode RebootOnSignoutMode;
  static constexpr RebootOnSignoutMode REBOOT_ON_SIGNOUT_MODE_UNSPECIFIED =
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_REBOOT_ON_SIGNOUT_MODE_UNSPECIFIED;
  static constexpr RebootOnSignoutMode NEVER =
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_NEVER;
  static constexpr RebootOnSignoutMode ARC_SESSION =
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_ARC_SESSION;
  static constexpr RebootOnSignoutMode ALWAYS =
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_ALWAYS;
  static constexpr RebootOnSignoutMode VM_STARTED_OR_ARC_SESSION =
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_VM_STARTED_OR_ARC_SESSION;
  static inline bool RebootOnSignoutMode_IsValid(int value) {
    return DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_IsValid(value);
  }
  static constexpr RebootOnSignoutMode RebootOnSignoutMode_MIN =
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_RebootOnSignoutMode_MIN;
  static constexpr RebootOnSignoutMode RebootOnSignoutMode_MAX =
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_RebootOnSignoutMode_MAX;
  static constexpr int RebootOnSignoutMode_ARRAYSIZE =
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_RebootOnSignoutMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RebootOnSignoutMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RebootOnSignoutMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RebootOnSignoutMode_Name.");
    return DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Name(enum_t_value);
  }
  static inline bool RebootOnSignoutMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RebootOnSignoutMode* value) {
    return DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRebootOnSignoutModeFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceRebootOnUserSignoutProto.RebootOnSignoutMode reboot_on_signout_mode = 1 [default = NEVER];
  bool has_reboot_on_signout_mode() const;
  private:
  bool _internal_has_reboot_on_signout_mode() const;
  public:
  void clear_reboot_on_signout_mode();
  ::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode reboot_on_signout_mode() const;
  void set_reboot_on_signout_mode(::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode value);
  private:
  ::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode _internal_reboot_on_signout_mode() const;
  void _internal_set_reboot_on_signout_mode(::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRebootOnUserSignoutProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int reboot_on_signout_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceWilcoDtcAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceWilcoDtcAllowedProto) */ {
 public:
  inline DeviceWilcoDtcAllowedProto() : DeviceWilcoDtcAllowedProto(nullptr) {}
  ~DeviceWilcoDtcAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceWilcoDtcAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceWilcoDtcAllowedProto(const DeviceWilcoDtcAllowedProto& from);
  DeviceWilcoDtcAllowedProto(DeviceWilcoDtcAllowedProto&& from) noexcept
    : DeviceWilcoDtcAllowedProto() {
    *this = ::std::move(from);
  }

  inline DeviceWilcoDtcAllowedProto& operator=(const DeviceWilcoDtcAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceWilcoDtcAllowedProto& operator=(DeviceWilcoDtcAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceWilcoDtcAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceWilcoDtcAllowedProto* internal_default_instance() {
    return reinterpret_cast<const DeviceWilcoDtcAllowedProto*>(
               &_DeviceWilcoDtcAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(DeviceWilcoDtcAllowedProto& a, DeviceWilcoDtcAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceWilcoDtcAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceWilcoDtcAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceWilcoDtcAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceWilcoDtcAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceWilcoDtcAllowedProto& from);
  void MergeFrom(const DeviceWilcoDtcAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceWilcoDtcAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceWilcoDtcAllowedProto";
  }
  protected:
  explicit DeviceWilcoDtcAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceWilcoDtcAllowedFieldNumber = 1,
  };
  // optional bool device_wilco_dtc_allowed = 1;
  bool has_device_wilco_dtc_allowed() const;
  private:
  bool _internal_has_device_wilco_dtc_allowed() const;
  public:
  void clear_device_wilco_dtc_allowed();
  bool device_wilco_dtc_allowed() const;
  void set_device_wilco_dtc_allowed(bool value);
  private:
  bool _internal_device_wilco_dtc_allowed() const;
  void _internal_set_device_wilco_dtc_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceWilcoDtcAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_wilco_dtc_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceWilcoDtcConfigurationProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceWilcoDtcConfigurationProto) */ {
 public:
  inline DeviceWilcoDtcConfigurationProto() : DeviceWilcoDtcConfigurationProto(nullptr) {}
  ~DeviceWilcoDtcConfigurationProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceWilcoDtcConfigurationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceWilcoDtcConfigurationProto(const DeviceWilcoDtcConfigurationProto& from);
  DeviceWilcoDtcConfigurationProto(DeviceWilcoDtcConfigurationProto&& from) noexcept
    : DeviceWilcoDtcConfigurationProto() {
    *this = ::std::move(from);
  }

  inline DeviceWilcoDtcConfigurationProto& operator=(const DeviceWilcoDtcConfigurationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceWilcoDtcConfigurationProto& operator=(DeviceWilcoDtcConfigurationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceWilcoDtcConfigurationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceWilcoDtcConfigurationProto* internal_default_instance() {
    return reinterpret_cast<const DeviceWilcoDtcConfigurationProto*>(
               &_DeviceWilcoDtcConfigurationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(DeviceWilcoDtcConfigurationProto& a, DeviceWilcoDtcConfigurationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceWilcoDtcConfigurationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceWilcoDtcConfigurationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceWilcoDtcConfigurationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceWilcoDtcConfigurationProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceWilcoDtcConfigurationProto& from);
  void MergeFrom(const DeviceWilcoDtcConfigurationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceWilcoDtcConfigurationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceWilcoDtcConfigurationProto";
  }
  protected:
  explicit DeviceWilcoDtcConfigurationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceWilcoDtcConfigurationFieldNumber = 1,
  };
  // optional string device_wilco_dtc_configuration = 1;
  bool has_device_wilco_dtc_configuration() const;
  private:
  bool _internal_has_device_wilco_dtc_configuration() const;
  public:
  void clear_device_wilco_dtc_configuration();
  const std::string& device_wilco_dtc_configuration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_wilco_dtc_configuration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_wilco_dtc_configuration();
  PROTOBUF_NODISCARD std::string* release_device_wilco_dtc_configuration();
  void set_allocated_device_wilco_dtc_configuration(std::string* device_wilco_dtc_configuration);
  private:
  const std::string& _internal_device_wilco_dtc_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_wilco_dtc_configuration(const std::string& value);
  std::string* _internal_mutable_device_wilco_dtc_configuration();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceWilcoDtcConfigurationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_wilco_dtc_configuration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DevicePowerPeakShiftProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePowerPeakShiftProto) */ {
 public:
  inline DevicePowerPeakShiftProto() : DevicePowerPeakShiftProto(nullptr) {}
  ~DevicePowerPeakShiftProto() override;
  explicit PROTOBUF_CONSTEXPR DevicePowerPeakShiftProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePowerPeakShiftProto(const DevicePowerPeakShiftProto& from);
  DevicePowerPeakShiftProto(DevicePowerPeakShiftProto&& from) noexcept
    : DevicePowerPeakShiftProto() {
    *this = ::std::move(from);
  }

  inline DevicePowerPeakShiftProto& operator=(const DevicePowerPeakShiftProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePowerPeakShiftProto& operator=(DevicePowerPeakShiftProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePowerPeakShiftProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePowerPeakShiftProto* internal_default_instance() {
    return reinterpret_cast<const DevicePowerPeakShiftProto*>(
               &_DevicePowerPeakShiftProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(DevicePowerPeakShiftProto& a, DevicePowerPeakShiftProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePowerPeakShiftProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePowerPeakShiftProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePowerPeakShiftProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePowerPeakShiftProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePowerPeakShiftProto& from);
  void MergeFrom(const DevicePowerPeakShiftProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePowerPeakShiftProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePowerPeakShiftProto";
  }
  protected:
  explicit DevicePowerPeakShiftProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDayConfigsFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kBatteryThresholdFieldNumber = 2,
  };
  // optional string day_configs = 3;
  bool has_day_configs() const;
  private:
  bool _internal_has_day_configs() const;
  public:
  void clear_day_configs();
  const std::string& day_configs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_day_configs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_day_configs();
  PROTOBUF_NODISCARD std::string* release_day_configs();
  void set_allocated_day_configs(std::string* day_configs);
  private:
  const std::string& _internal_day_configs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_day_configs(const std::string& value);
  std::string* _internal_mutable_day_configs();
  public:

  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional int32 battery_threshold = 2;
  bool has_battery_threshold() const;
  private:
  bool _internal_has_battery_threshold() const;
  public:
  void clear_battery_threshold();
  int32_t battery_threshold() const;
  void set_battery_threshold(int32_t value);
  private:
  int32_t _internal_battery_threshold() const;
  void _internal_set_battery_threshold(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePowerPeakShiftProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr day_configs_;
    bool enabled_;
    int32_t battery_threshold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceBootOnAcProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceBootOnAcProto) */ {
 public:
  inline DeviceBootOnAcProto() : DeviceBootOnAcProto(nullptr) {}
  ~DeviceBootOnAcProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceBootOnAcProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceBootOnAcProto(const DeviceBootOnAcProto& from);
  DeviceBootOnAcProto(DeviceBootOnAcProto&& from) noexcept
    : DeviceBootOnAcProto() {
    *this = ::std::move(from);
  }

  inline DeviceBootOnAcProto& operator=(const DeviceBootOnAcProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceBootOnAcProto& operator=(DeviceBootOnAcProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceBootOnAcProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceBootOnAcProto* internal_default_instance() {
    return reinterpret_cast<const DeviceBootOnAcProto*>(
               &_DeviceBootOnAcProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(DeviceBootOnAcProto& a, DeviceBootOnAcProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceBootOnAcProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceBootOnAcProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceBootOnAcProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceBootOnAcProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceBootOnAcProto& from);
  void MergeFrom(const DeviceBootOnAcProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceBootOnAcProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceBootOnAcProto";
  }
  protected:
  explicit DeviceBootOnAcProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceBootOnAcProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceDockMacAddressSourceProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceDockMacAddressSourceProto) */ {
 public:
  inline DeviceDockMacAddressSourceProto() : DeviceDockMacAddressSourceProto(nullptr) {}
  ~DeviceDockMacAddressSourceProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceDockMacAddressSourceProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceDockMacAddressSourceProto(const DeviceDockMacAddressSourceProto& from);
  DeviceDockMacAddressSourceProto(DeviceDockMacAddressSourceProto&& from) noexcept
    : DeviceDockMacAddressSourceProto() {
    *this = ::std::move(from);
  }

  inline DeviceDockMacAddressSourceProto& operator=(const DeviceDockMacAddressSourceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceDockMacAddressSourceProto& operator=(DeviceDockMacAddressSourceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceDockMacAddressSourceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceDockMacAddressSourceProto* internal_default_instance() {
    return reinterpret_cast<const DeviceDockMacAddressSourceProto*>(
               &_DeviceDockMacAddressSourceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(DeviceDockMacAddressSourceProto& a, DeviceDockMacAddressSourceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceDockMacAddressSourceProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceDockMacAddressSourceProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceDockMacAddressSourceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceDockMacAddressSourceProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceDockMacAddressSourceProto& from);
  void MergeFrom(const DeviceDockMacAddressSourceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceDockMacAddressSourceProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceDockMacAddressSourceProto";
  }
  protected:
  explicit DeviceDockMacAddressSourceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceDockMacAddressSourceProto_Source Source;
  static constexpr Source SOURCE_UNSPECIFIED =
    DeviceDockMacAddressSourceProto_Source_SOURCE_UNSPECIFIED;
  static constexpr Source DEVICE_DOCK_MAC_ADDRESS =
    DeviceDockMacAddressSourceProto_Source_DEVICE_DOCK_MAC_ADDRESS;
  static constexpr Source DEVICE_NIC_MAC_ADDRESS =
    DeviceDockMacAddressSourceProto_Source_DEVICE_NIC_MAC_ADDRESS;
  static constexpr Source DOCK_NIC_MAC_ADDRESS =
    DeviceDockMacAddressSourceProto_Source_DOCK_NIC_MAC_ADDRESS;
  static inline bool Source_IsValid(int value) {
    return DeviceDockMacAddressSourceProto_Source_IsValid(value);
  }
  static constexpr Source Source_MIN =
    DeviceDockMacAddressSourceProto_Source_Source_MIN;
  static constexpr Source Source_MAX =
    DeviceDockMacAddressSourceProto_Source_Source_MAX;
  static constexpr int Source_ARRAYSIZE =
    DeviceDockMacAddressSourceProto_Source_Source_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Source_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Source>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Source_Name.");
    return DeviceDockMacAddressSourceProto_Source_Name(enum_t_value);
  }
  static inline bool Source_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Source* value) {
    return DeviceDockMacAddressSourceProto_Source_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceDockMacAddressSourceProto.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  ::enterprise_management::DeviceDockMacAddressSourceProto_Source source() const;
  void set_source(::enterprise_management::DeviceDockMacAddressSourceProto_Source value);
  private:
  ::enterprise_management::DeviceDockMacAddressSourceProto_Source _internal_source() const;
  void _internal_set_source(::enterprise_management::DeviceDockMacAddressSourceProto_Source value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceDockMacAddressSourceProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int source_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceAdvancedBatteryChargeModeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAdvancedBatteryChargeModeProto) */ {
 public:
  inline DeviceAdvancedBatteryChargeModeProto() : DeviceAdvancedBatteryChargeModeProto(nullptr) {}
  ~DeviceAdvancedBatteryChargeModeProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceAdvancedBatteryChargeModeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAdvancedBatteryChargeModeProto(const DeviceAdvancedBatteryChargeModeProto& from);
  DeviceAdvancedBatteryChargeModeProto(DeviceAdvancedBatteryChargeModeProto&& from) noexcept
    : DeviceAdvancedBatteryChargeModeProto() {
    *this = ::std::move(from);
  }

  inline DeviceAdvancedBatteryChargeModeProto& operator=(const DeviceAdvancedBatteryChargeModeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAdvancedBatteryChargeModeProto& operator=(DeviceAdvancedBatteryChargeModeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAdvancedBatteryChargeModeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAdvancedBatteryChargeModeProto* internal_default_instance() {
    return reinterpret_cast<const DeviceAdvancedBatteryChargeModeProto*>(
               &_DeviceAdvancedBatteryChargeModeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(DeviceAdvancedBatteryChargeModeProto& a, DeviceAdvancedBatteryChargeModeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAdvancedBatteryChargeModeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAdvancedBatteryChargeModeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAdvancedBatteryChargeModeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAdvancedBatteryChargeModeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAdvancedBatteryChargeModeProto& from);
  void MergeFrom(const DeviceAdvancedBatteryChargeModeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAdvancedBatteryChargeModeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAdvancedBatteryChargeModeProto";
  }
  protected:
  explicit DeviceAdvancedBatteryChargeModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDayConfigsFieldNumber = 2,
    kEnabledFieldNumber = 1,
  };
  // optional string day_configs = 2;
  bool has_day_configs() const;
  private:
  bool _internal_has_day_configs() const;
  public:
  void clear_day_configs();
  const std::string& day_configs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_day_configs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_day_configs();
  PROTOBUF_NODISCARD std::string* release_day_configs();
  void set_allocated_day_configs(std::string* day_configs);
  private:
  const std::string& _internal_day_configs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_day_configs(const std::string& value);
  std::string* _internal_mutable_day_configs();
  public:

  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr day_configs_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceBatteryChargeModeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceBatteryChargeModeProto) */ {
 public:
  inline DeviceBatteryChargeModeProto() : DeviceBatteryChargeModeProto(nullptr) {}
  ~DeviceBatteryChargeModeProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceBatteryChargeModeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceBatteryChargeModeProto(const DeviceBatteryChargeModeProto& from);
  DeviceBatteryChargeModeProto(DeviceBatteryChargeModeProto&& from) noexcept
    : DeviceBatteryChargeModeProto() {
    *this = ::std::move(from);
  }

  inline DeviceBatteryChargeModeProto& operator=(const DeviceBatteryChargeModeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceBatteryChargeModeProto& operator=(DeviceBatteryChargeModeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceBatteryChargeModeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceBatteryChargeModeProto* internal_default_instance() {
    return reinterpret_cast<const DeviceBatteryChargeModeProto*>(
               &_DeviceBatteryChargeModeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(DeviceBatteryChargeModeProto& a, DeviceBatteryChargeModeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceBatteryChargeModeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceBatteryChargeModeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceBatteryChargeModeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceBatteryChargeModeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceBatteryChargeModeProto& from);
  void MergeFrom(const DeviceBatteryChargeModeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceBatteryChargeModeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceBatteryChargeModeProto";
  }
  protected:
  explicit DeviceBatteryChargeModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceBatteryChargeModeProto_BatteryChargeMode BatteryChargeMode;
  static constexpr BatteryChargeMode MODE_UNSPECIFIED =
    DeviceBatteryChargeModeProto_BatteryChargeMode_MODE_UNSPECIFIED;
  static constexpr BatteryChargeMode STANDARD =
    DeviceBatteryChargeModeProto_BatteryChargeMode_STANDARD;
  static constexpr BatteryChargeMode EXPRESS_CHARGE =
    DeviceBatteryChargeModeProto_BatteryChargeMode_EXPRESS_CHARGE;
  static constexpr BatteryChargeMode PRIMARILY_AC_USE =
    DeviceBatteryChargeModeProto_BatteryChargeMode_PRIMARILY_AC_USE;
  static constexpr BatteryChargeMode ADAPTIVE =
    DeviceBatteryChargeModeProto_BatteryChargeMode_ADAPTIVE;
  static constexpr BatteryChargeMode CUSTOM =
    DeviceBatteryChargeModeProto_BatteryChargeMode_CUSTOM;
  static inline bool BatteryChargeMode_IsValid(int value) {
    return DeviceBatteryChargeModeProto_BatteryChargeMode_IsValid(value);
  }
  static constexpr BatteryChargeMode BatteryChargeMode_MIN =
    DeviceBatteryChargeModeProto_BatteryChargeMode_BatteryChargeMode_MIN;
  static constexpr BatteryChargeMode BatteryChargeMode_MAX =
    DeviceBatteryChargeModeProto_BatteryChargeMode_BatteryChargeMode_MAX;
  static constexpr int BatteryChargeMode_ARRAYSIZE =
    DeviceBatteryChargeModeProto_BatteryChargeMode_BatteryChargeMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BatteryChargeMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BatteryChargeMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BatteryChargeMode_Name.");
    return DeviceBatteryChargeModeProto_BatteryChargeMode_Name(enum_t_value);
  }
  static inline bool BatteryChargeMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BatteryChargeMode* value) {
    return DeviceBatteryChargeModeProto_BatteryChargeMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryChargeModeFieldNumber = 1,
    kCustomChargeStartFieldNumber = 2,
    kCustomChargeStopFieldNumber = 3,
  };
  // optional .enterprise_management.DeviceBatteryChargeModeProto.BatteryChargeMode battery_charge_mode = 1;
  bool has_battery_charge_mode() const;
  private:
  bool _internal_has_battery_charge_mode() const;
  public:
  void clear_battery_charge_mode();
  ::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode battery_charge_mode() const;
  void set_battery_charge_mode(::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode value);
  private:
  ::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode _internal_battery_charge_mode() const;
  void _internal_set_battery_charge_mode(::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode value);
  public:

  // optional int32 custom_charge_start = 2;
  bool has_custom_charge_start() const;
  private:
  bool _internal_has_custom_charge_start() const;
  public:
  void clear_custom_charge_start();
  int32_t custom_charge_start() const;
  void set_custom_charge_start(int32_t value);
  private:
  int32_t _internal_custom_charge_start() const;
  void _internal_set_custom_charge_start(int32_t value);
  public:

  // optional int32 custom_charge_stop = 3;
  bool has_custom_charge_stop() const;
  private:
  bool _internal_has_custom_charge_stop() const;
  public:
  void clear_custom_charge_stop();
  int32_t custom_charge_stop() const;
  void set_custom_charge_stop(int32_t value);
  private:
  int32_t _internal_custom_charge_stop() const;
  void _internal_set_custom_charge_stop(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceBatteryChargeModeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int battery_charge_mode_;
    int32_t custom_charge_start_;
    int32_t custom_charge_stop_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceUsbPowerShareProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUsbPowerShareProto) */ {
 public:
  inline DeviceUsbPowerShareProto() : DeviceUsbPowerShareProto(nullptr) {}
  ~DeviceUsbPowerShareProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceUsbPowerShareProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceUsbPowerShareProto(const DeviceUsbPowerShareProto& from);
  DeviceUsbPowerShareProto(DeviceUsbPowerShareProto&& from) noexcept
    : DeviceUsbPowerShareProto() {
    *this = ::std::move(from);
  }

  inline DeviceUsbPowerShareProto& operator=(const DeviceUsbPowerShareProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceUsbPowerShareProto& operator=(DeviceUsbPowerShareProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceUsbPowerShareProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceUsbPowerShareProto* internal_default_instance() {
    return reinterpret_cast<const DeviceUsbPowerShareProto*>(
               &_DeviceUsbPowerShareProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(DeviceUsbPowerShareProto& a, DeviceUsbPowerShareProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceUsbPowerShareProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceUsbPowerShareProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceUsbPowerShareProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceUsbPowerShareProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceUsbPowerShareProto& from);
  void MergeFrom(const DeviceUsbPowerShareProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceUsbPowerShareProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceUsbPowerShareProto";
  }
  protected:
  explicit DeviceUsbPowerShareProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUsbPowerShareProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceScheduledUpdateCheckProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceScheduledUpdateCheckProto) */ {
 public:
  inline DeviceScheduledUpdateCheckProto() : DeviceScheduledUpdateCheckProto(nullptr) {}
  ~DeviceScheduledUpdateCheckProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceScheduledUpdateCheckProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceScheduledUpdateCheckProto(const DeviceScheduledUpdateCheckProto& from);
  DeviceScheduledUpdateCheckProto(DeviceScheduledUpdateCheckProto&& from) noexcept
    : DeviceScheduledUpdateCheckProto() {
    *this = ::std::move(from);
  }

  inline DeviceScheduledUpdateCheckProto& operator=(const DeviceScheduledUpdateCheckProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceScheduledUpdateCheckProto& operator=(DeviceScheduledUpdateCheckProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceScheduledUpdateCheckProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceScheduledUpdateCheckProto* internal_default_instance() {
    return reinterpret_cast<const DeviceScheduledUpdateCheckProto*>(
               &_DeviceScheduledUpdateCheckProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(DeviceScheduledUpdateCheckProto& a, DeviceScheduledUpdateCheckProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceScheduledUpdateCheckProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceScheduledUpdateCheckProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceScheduledUpdateCheckProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceScheduledUpdateCheckProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceScheduledUpdateCheckProto& from);
  void MergeFrom(const DeviceScheduledUpdateCheckProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceScheduledUpdateCheckProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceScheduledUpdateCheckProto";
  }
  protected:
  explicit DeviceScheduledUpdateCheckProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceScheduledUpdateCheckSettingsFieldNumber = 1,
  };
  // optional string device_scheduled_update_check_settings = 1;
  bool has_device_scheduled_update_check_settings() const;
  private:
  bool _internal_has_device_scheduled_update_check_settings() const;
  public:
  void clear_device_scheduled_update_check_settings();
  const std::string& device_scheduled_update_check_settings() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_scheduled_update_check_settings(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_scheduled_update_check_settings();
  PROTOBUF_NODISCARD std::string* release_device_scheduled_update_check_settings();
  void set_allocated_device_scheduled_update_check_settings(std::string* device_scheduled_update_check_settings);
  private:
  const std::string& _internal_device_scheduled_update_check_settings() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_scheduled_update_check_settings(const std::string& value);
  std::string* _internal_mutable_device_scheduled_update_check_settings();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceScheduledUpdateCheckProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_scheduled_update_check_settings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DevicePowerwashAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePowerwashAllowedProto) */ {
 public:
  inline DevicePowerwashAllowedProto() : DevicePowerwashAllowedProto(nullptr) {}
  ~DevicePowerwashAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR DevicePowerwashAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePowerwashAllowedProto(const DevicePowerwashAllowedProto& from);
  DevicePowerwashAllowedProto(DevicePowerwashAllowedProto&& from) noexcept
    : DevicePowerwashAllowedProto() {
    *this = ::std::move(from);
  }

  inline DevicePowerwashAllowedProto& operator=(const DevicePowerwashAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePowerwashAllowedProto& operator=(DevicePowerwashAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePowerwashAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePowerwashAllowedProto* internal_default_instance() {
    return reinterpret_cast<const DevicePowerwashAllowedProto*>(
               &_DevicePowerwashAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(DevicePowerwashAllowedProto& a, DevicePowerwashAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePowerwashAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePowerwashAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePowerwashAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePowerwashAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePowerwashAllowedProto& from);
  void MergeFrom(const DevicePowerwashAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePowerwashAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePowerwashAllowedProto";
  }
  protected:
  explicit DevicePowerwashAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePowerwashAllowedFieldNumber = 1,
  };
  // optional bool device_powerwash_allowed = 1;
  bool has_device_powerwash_allowed() const;
  private:
  bool _internal_has_device_powerwash_allowed() const;
  public:
  void clear_device_powerwash_allowed();
  bool device_powerwash_allowed() const;
  void set_device_powerwash_allowed(bool value);
  private:
  bool _internal_device_powerwash_allowed() const;
  void _internal_set_device_powerwash_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePowerwashAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_powerwash_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceLoginScreenWebUsbAllowDevicesForUrlsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto) */ {
 public:
  inline DeviceLoginScreenWebUsbAllowDevicesForUrlsProto() : DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(nullptr) {}
  ~DeviceLoginScreenWebUsbAllowDevicesForUrlsProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& from);
  DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(DeviceLoginScreenWebUsbAllowDevicesForUrlsProto&& from) noexcept
    : DeviceLoginScreenWebUsbAllowDevicesForUrlsProto() {
    *this = ::std::move(from);
  }

  inline DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& operator=(const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& operator=(DeviceLoginScreenWebUsbAllowDevicesForUrlsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* internal_default_instance() {
    return reinterpret_cast<const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto*>(
               &_DeviceLoginScreenWebUsbAllowDevicesForUrlsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& a, DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLoginScreenWebUsbAllowDevicesForUrlsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& from);
  void MergeFrom(const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto";
  }
  protected:
  explicit DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceLoginScreenWebusbAllowDevicesForUrlsFieldNumber = 1,
  };
  // optional string device_login_screen_webusb_allow_devices_for_urls = 1;
  bool has_device_login_screen_webusb_allow_devices_for_urls() const;
  private:
  bool _internal_has_device_login_screen_webusb_allow_devices_for_urls() const;
  public:
  void clear_device_login_screen_webusb_allow_devices_for_urls();
  const std::string& device_login_screen_webusb_allow_devices_for_urls() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_login_screen_webusb_allow_devices_for_urls(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_login_screen_webusb_allow_devices_for_urls();
  PROTOBUF_NODISCARD std::string* release_device_login_screen_webusb_allow_devices_for_urls();
  void set_allocated_device_login_screen_webusb_allow_devices_for_urls(std::string* device_login_screen_webusb_allow_devices_for_urls);
  private:
  const std::string& _internal_device_login_screen_webusb_allow_devices_for_urls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_login_screen_webusb_allow_devices_for_urls(const std::string& value);
  std::string* _internal_mutable_device_login_screen_webusb_allow_devices_for_urls();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_login_screen_webusb_allow_devices_for_urls_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class SystemProxySettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemProxySettingsProto) */ {
 public:
  inline SystemProxySettingsProto() : SystemProxySettingsProto(nullptr) {}
  ~SystemProxySettingsProto() override;
  explicit PROTOBUF_CONSTEXPR SystemProxySettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemProxySettingsProto(const SystemProxySettingsProto& from);
  SystemProxySettingsProto(SystemProxySettingsProto&& from) noexcept
    : SystemProxySettingsProto() {
    *this = ::std::move(from);
  }

  inline SystemProxySettingsProto& operator=(const SystemProxySettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemProxySettingsProto& operator=(SystemProxySettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SystemProxySettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemProxySettingsProto* internal_default_instance() {
    return reinterpret_cast<const SystemProxySettingsProto*>(
               &_SystemProxySettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(SystemProxySettingsProto& a, SystemProxySettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemProxySettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemProxySettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemProxySettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemProxySettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemProxySettingsProto& from);
  void MergeFrom(const SystemProxySettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemProxySettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SystemProxySettingsProto";
  }
  protected:
  explicit SystemProxySettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemProxySettingsFieldNumber = 1,
  };
  // optional string system_proxy_settings = 1;
  bool has_system_proxy_settings() const;
  private:
  bool _internal_has_system_proxy_settings() const;
  public:
  void clear_system_proxy_settings();
  const std::string& system_proxy_settings() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_proxy_settings(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_proxy_settings();
  PROTOBUF_NODISCARD std::string* release_system_proxy_settings();
  void set_allocated_system_proxy_settings(std::string* system_proxy_settings);
  private:
  const std::string& _internal_system_proxy_settings() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_proxy_settings(const std::string& value);
  std::string* _internal_mutable_system_proxy_settings();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SystemProxySettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_proxy_settings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class RequiredClientCertificateForDeviceProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RequiredClientCertificateForDeviceProto) */ {
 public:
  inline RequiredClientCertificateForDeviceProto() : RequiredClientCertificateForDeviceProto(nullptr) {}
  ~RequiredClientCertificateForDeviceProto() override;
  explicit PROTOBUF_CONSTEXPR RequiredClientCertificateForDeviceProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequiredClientCertificateForDeviceProto(const RequiredClientCertificateForDeviceProto& from);
  RequiredClientCertificateForDeviceProto(RequiredClientCertificateForDeviceProto&& from) noexcept
    : RequiredClientCertificateForDeviceProto() {
    *this = ::std::move(from);
  }

  inline RequiredClientCertificateForDeviceProto& operator=(const RequiredClientCertificateForDeviceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequiredClientCertificateForDeviceProto& operator=(RequiredClientCertificateForDeviceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RequiredClientCertificateForDeviceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequiredClientCertificateForDeviceProto* internal_default_instance() {
    return reinterpret_cast<const RequiredClientCertificateForDeviceProto*>(
               &_RequiredClientCertificateForDeviceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(RequiredClientCertificateForDeviceProto& a, RequiredClientCertificateForDeviceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RequiredClientCertificateForDeviceProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequiredClientCertificateForDeviceProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequiredClientCertificateForDeviceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequiredClientCertificateForDeviceProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RequiredClientCertificateForDeviceProto& from);
  void MergeFrom(const RequiredClientCertificateForDeviceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequiredClientCertificateForDeviceProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RequiredClientCertificateForDeviceProto";
  }
  protected:
  explicit RequiredClientCertificateForDeviceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredClientCertificateForDeviceFieldNumber = 1,
  };
  // optional string required_client_certificate_for_device = 1;
  bool has_required_client_certificate_for_device() const;
  private:
  bool _internal_has_required_client_certificate_for_device() const;
  public:
  void clear_required_client_certificate_for_device();
  const std::string& required_client_certificate_for_device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_required_client_certificate_for_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_required_client_certificate_for_device();
  PROTOBUF_NODISCARD std::string* release_required_client_certificate_for_device();
  void set_allocated_required_client_certificate_for_device(std::string* required_client_certificate_for_device);
  private:
  const std::string& _internal_required_client_certificate_for_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_required_client_certificate_for_device(const std::string& value);
  std::string* _internal_mutable_required_client_certificate_for_device();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.RequiredClientCertificateForDeviceProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_client_certificate_for_device_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceCrostiniArcAdbSideloadingAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto) */ {
 public:
  inline DeviceCrostiniArcAdbSideloadingAllowedProto() : DeviceCrostiniArcAdbSideloadingAllowedProto(nullptr) {}
  ~DeviceCrostiniArcAdbSideloadingAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceCrostiniArcAdbSideloadingAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceCrostiniArcAdbSideloadingAllowedProto(const DeviceCrostiniArcAdbSideloadingAllowedProto& from);
  DeviceCrostiniArcAdbSideloadingAllowedProto(DeviceCrostiniArcAdbSideloadingAllowedProto&& from) noexcept
    : DeviceCrostiniArcAdbSideloadingAllowedProto() {
    *this = ::std::move(from);
  }

  inline DeviceCrostiniArcAdbSideloadingAllowedProto& operator=(const DeviceCrostiniArcAdbSideloadingAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceCrostiniArcAdbSideloadingAllowedProto& operator=(DeviceCrostiniArcAdbSideloadingAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceCrostiniArcAdbSideloadingAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceCrostiniArcAdbSideloadingAllowedProto* internal_default_instance() {
    return reinterpret_cast<const DeviceCrostiniArcAdbSideloadingAllowedProto*>(
               &_DeviceCrostiniArcAdbSideloadingAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(DeviceCrostiniArcAdbSideloadingAllowedProto& a, DeviceCrostiniArcAdbSideloadingAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceCrostiniArcAdbSideloadingAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceCrostiniArcAdbSideloadingAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceCrostiniArcAdbSideloadingAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceCrostiniArcAdbSideloadingAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceCrostiniArcAdbSideloadingAllowedProto& from);
  void MergeFrom(const DeviceCrostiniArcAdbSideloadingAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceCrostiniArcAdbSideloadingAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto";
  }
  protected:
  explicit DeviceCrostiniArcAdbSideloadingAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode AllowanceMode;
  static constexpr AllowanceMode DISALLOW =
    DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_DISALLOW;
  static constexpr AllowanceMode DISALLOW_WITH_POWERWASH =
    DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_DISALLOW_WITH_POWERWASH;
  static constexpr AllowanceMode ALLOW_FOR_AFFILIATED_USERS =
    DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_ALLOW_FOR_AFFILIATED_USERS;
  static inline bool AllowanceMode_IsValid(int value) {
    return DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_IsValid(value);
  }
  static constexpr AllowanceMode AllowanceMode_MIN =
    DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_AllowanceMode_MIN;
  static constexpr AllowanceMode AllowanceMode_MAX =
    DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_AllowanceMode_MAX;
  static constexpr int AllowanceMode_ARRAYSIZE =
    DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_AllowanceMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AllowanceMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AllowanceMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AllowanceMode_Name.");
    return DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Name(enum_t_value);
  }
  static inline bool AllowanceMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AllowanceMode* value) {
    return DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto.AllowanceMode mode = 1 [default = DISALLOW];
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode mode() const;
  void set_mode(::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode value);
  private:
  ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode _internal_mode() const;
  void _internal_set_mode(::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceShowLowDiskSpaceNotificationProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceShowLowDiskSpaceNotificationProto) */ {
 public:
  inline DeviceShowLowDiskSpaceNotificationProto() : DeviceShowLowDiskSpaceNotificationProto(nullptr) {}
  ~DeviceShowLowDiskSpaceNotificationProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceShowLowDiskSpaceNotificationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceShowLowDiskSpaceNotificationProto(const DeviceShowLowDiskSpaceNotificationProto& from);
  DeviceShowLowDiskSpaceNotificationProto(DeviceShowLowDiskSpaceNotificationProto&& from) noexcept
    : DeviceShowLowDiskSpaceNotificationProto() {
    *this = ::std::move(from);
  }

  inline DeviceShowLowDiskSpaceNotificationProto& operator=(const DeviceShowLowDiskSpaceNotificationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceShowLowDiskSpaceNotificationProto& operator=(DeviceShowLowDiskSpaceNotificationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceShowLowDiskSpaceNotificationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceShowLowDiskSpaceNotificationProto* internal_default_instance() {
    return reinterpret_cast<const DeviceShowLowDiskSpaceNotificationProto*>(
               &_DeviceShowLowDiskSpaceNotificationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(DeviceShowLowDiskSpaceNotificationProto& a, DeviceShowLowDiskSpaceNotificationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceShowLowDiskSpaceNotificationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceShowLowDiskSpaceNotificationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceShowLowDiskSpaceNotificationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceShowLowDiskSpaceNotificationProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceShowLowDiskSpaceNotificationProto& from);
  void MergeFrom(const DeviceShowLowDiskSpaceNotificationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceShowLowDiskSpaceNotificationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceShowLowDiskSpaceNotificationProto";
  }
  protected:
  explicit DeviceShowLowDiskSpaceNotificationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceShowLowDiskSpaceNotificationFieldNumber = 1,
  };
  // optional bool device_show_low_disk_space_notification = 1;
  bool has_device_show_low_disk_space_notification() const;
  private:
  bool _internal_has_device_show_low_disk_space_notification() const;
  public:
  void clear_device_show_low_disk_space_notification();
  bool device_show_low_disk_space_notification() const;
  void set_device_show_low_disk_space_notification(bool value);
  private:
  bool _internal_device_show_low_disk_space_notification() const;
  void _internal_set_device_show_low_disk_space_notification(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool device_show_low_disk_space_notification_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceFamilyLinkAccountsAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceFamilyLinkAccountsAllowedProto) */ {
 public:
  inline DeviceFamilyLinkAccountsAllowedProto() : DeviceFamilyLinkAccountsAllowedProto(nullptr) {}
  ~DeviceFamilyLinkAccountsAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceFamilyLinkAccountsAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceFamilyLinkAccountsAllowedProto(const DeviceFamilyLinkAccountsAllowedProto& from);
  DeviceFamilyLinkAccountsAllowedProto(DeviceFamilyLinkAccountsAllowedProto&& from) noexcept
    : DeviceFamilyLinkAccountsAllowedProto() {
    *this = ::std::move(from);
  }

  inline DeviceFamilyLinkAccountsAllowedProto& operator=(const DeviceFamilyLinkAccountsAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceFamilyLinkAccountsAllowedProto& operator=(DeviceFamilyLinkAccountsAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceFamilyLinkAccountsAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceFamilyLinkAccountsAllowedProto* internal_default_instance() {
    return reinterpret_cast<const DeviceFamilyLinkAccountsAllowedProto*>(
               &_DeviceFamilyLinkAccountsAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(DeviceFamilyLinkAccountsAllowedProto& a, DeviceFamilyLinkAccountsAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceFamilyLinkAccountsAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceFamilyLinkAccountsAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceFamilyLinkAccountsAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceFamilyLinkAccountsAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceFamilyLinkAccountsAllowedProto& from);
  void MergeFrom(const DeviceFamilyLinkAccountsAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceFamilyLinkAccountsAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceFamilyLinkAccountsAllowedProto";
  }
  protected:
  explicit DeviceFamilyLinkAccountsAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyLinkAccountsAllowedFieldNumber = 1,
  };
  // optional bool family_link_accounts_allowed = 1 [default = false];
  bool has_family_link_accounts_allowed() const;
  private:
  bool _internal_has_family_link_accounts_allowed() const;
  public:
  void clear_family_link_accounts_allowed();
  bool family_link_accounts_allowed() const;
  void set_family_link_accounts_allowed(bool value);
  private:
  bool _internal_family_link_accounts_allowed() const;
  void _internal_set_family_link_accounts_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool family_link_accounts_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceArcDataSnapshotHoursProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceArcDataSnapshotHoursProto) */ {
 public:
  inline DeviceArcDataSnapshotHoursProto() : DeviceArcDataSnapshotHoursProto(nullptr) {}
  ~DeviceArcDataSnapshotHoursProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceArcDataSnapshotHoursProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceArcDataSnapshotHoursProto(const DeviceArcDataSnapshotHoursProto& from);
  DeviceArcDataSnapshotHoursProto(DeviceArcDataSnapshotHoursProto&& from) noexcept
    : DeviceArcDataSnapshotHoursProto() {
    *this = ::std::move(from);
  }

  inline DeviceArcDataSnapshotHoursProto& operator=(const DeviceArcDataSnapshotHoursProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceArcDataSnapshotHoursProto& operator=(DeviceArcDataSnapshotHoursProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceArcDataSnapshotHoursProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceArcDataSnapshotHoursProto* internal_default_instance() {
    return reinterpret_cast<const DeviceArcDataSnapshotHoursProto*>(
               &_DeviceArcDataSnapshotHoursProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(DeviceArcDataSnapshotHoursProto& a, DeviceArcDataSnapshotHoursProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceArcDataSnapshotHoursProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceArcDataSnapshotHoursProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceArcDataSnapshotHoursProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceArcDataSnapshotHoursProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceArcDataSnapshotHoursProto& from);
  void MergeFrom(const DeviceArcDataSnapshotHoursProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceArcDataSnapshotHoursProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceArcDataSnapshotHoursProto";
  }
  protected:
  explicit DeviceArcDataSnapshotHoursProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArcDataSnapshotHoursFieldNumber = 1,
  };
  // optional string arc_data_snapshot_hours = 1;
  bool has_arc_data_snapshot_hours() const;
  private:
  bool _internal_has_arc_data_snapshot_hours() const;
  public:
  void clear_arc_data_snapshot_hours();
  const std::string& arc_data_snapshot_hours() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arc_data_snapshot_hours(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arc_data_snapshot_hours();
  PROTOBUF_NODISCARD std::string* release_arc_data_snapshot_hours();
  void set_allocated_arc_data_snapshot_hours(std::string* arc_data_snapshot_hours);
  private:
  const std::string& _internal_arc_data_snapshot_hours() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arc_data_snapshot_hours(const std::string& value);
  std::string* _internal_mutable_arc_data_snapshot_hours();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceArcDataSnapshotHoursProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arc_data_snapshot_hours_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceSystemWideTracingEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceSystemWideTracingEnabledProto) */ {
 public:
  inline DeviceSystemWideTracingEnabledProto() : DeviceSystemWideTracingEnabledProto(nullptr) {}
  ~DeviceSystemWideTracingEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceSystemWideTracingEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceSystemWideTracingEnabledProto(const DeviceSystemWideTracingEnabledProto& from);
  DeviceSystemWideTracingEnabledProto(DeviceSystemWideTracingEnabledProto&& from) noexcept
    : DeviceSystemWideTracingEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceSystemWideTracingEnabledProto& operator=(const DeviceSystemWideTracingEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceSystemWideTracingEnabledProto& operator=(DeviceSystemWideTracingEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceSystemWideTracingEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceSystemWideTracingEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceSystemWideTracingEnabledProto*>(
               &_DeviceSystemWideTracingEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(DeviceSystemWideTracingEnabledProto& a, DeviceSystemWideTracingEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceSystemWideTracingEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceSystemWideTracingEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceSystemWideTracingEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceSystemWideTracingEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceSystemWideTracingEnabledProto& from);
  void MergeFrom(const DeviceSystemWideTracingEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceSystemWideTracingEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceSystemWideTracingEnabledProto";
  }
  protected:
  explicit DeviceSystemWideTracingEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceSystemWideTracingEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DevicePciPeripheralDataAccessEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePciPeripheralDataAccessEnabledProto) */ {
 public:
  inline DevicePciPeripheralDataAccessEnabledProto() : DevicePciPeripheralDataAccessEnabledProto(nullptr) {}
  ~DevicePciPeripheralDataAccessEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DevicePciPeripheralDataAccessEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePciPeripheralDataAccessEnabledProto(const DevicePciPeripheralDataAccessEnabledProto& from);
  DevicePciPeripheralDataAccessEnabledProto(DevicePciPeripheralDataAccessEnabledProto&& from) noexcept
    : DevicePciPeripheralDataAccessEnabledProto() {
    *this = ::std::move(from);
  }

  inline DevicePciPeripheralDataAccessEnabledProto& operator=(const DevicePciPeripheralDataAccessEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePciPeripheralDataAccessEnabledProto& operator=(DevicePciPeripheralDataAccessEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePciPeripheralDataAccessEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePciPeripheralDataAccessEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DevicePciPeripheralDataAccessEnabledProto*>(
               &_DevicePciPeripheralDataAccessEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(DevicePciPeripheralDataAccessEnabledProto& a, DevicePciPeripheralDataAccessEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePciPeripheralDataAccessEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePciPeripheralDataAccessEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePciPeripheralDataAccessEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePciPeripheralDataAccessEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePciPeripheralDataAccessEnabledProto& from);
  void MergeFrom(const DevicePciPeripheralDataAccessEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePciPeripheralDataAccessEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePciPeripheralDataAccessEnabledProto";
  }
  protected:
  explicit DevicePciPeripheralDataAccessEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DevicePciPeripheralDataAccessEnabledProtoV2 final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2) */ {
 public:
  inline DevicePciPeripheralDataAccessEnabledProtoV2() : DevicePciPeripheralDataAccessEnabledProtoV2(nullptr) {}
  ~DevicePciPeripheralDataAccessEnabledProtoV2() override;
  explicit PROTOBUF_CONSTEXPR DevicePciPeripheralDataAccessEnabledProtoV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePciPeripheralDataAccessEnabledProtoV2(const DevicePciPeripheralDataAccessEnabledProtoV2& from);
  DevicePciPeripheralDataAccessEnabledProtoV2(DevicePciPeripheralDataAccessEnabledProtoV2&& from) noexcept
    : DevicePciPeripheralDataAccessEnabledProtoV2() {
    *this = ::std::move(from);
  }

  inline DevicePciPeripheralDataAccessEnabledProtoV2& operator=(const DevicePciPeripheralDataAccessEnabledProtoV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePciPeripheralDataAccessEnabledProtoV2& operator=(DevicePciPeripheralDataAccessEnabledProtoV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePciPeripheralDataAccessEnabledProtoV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePciPeripheralDataAccessEnabledProtoV2* internal_default_instance() {
    return reinterpret_cast<const DevicePciPeripheralDataAccessEnabledProtoV2*>(
               &_DevicePciPeripheralDataAccessEnabledProtoV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(DevicePciPeripheralDataAccessEnabledProtoV2& a, DevicePciPeripheralDataAccessEnabledProtoV2& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePciPeripheralDataAccessEnabledProtoV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePciPeripheralDataAccessEnabledProtoV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePciPeripheralDataAccessEnabledProtoV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePciPeripheralDataAccessEnabledProtoV2>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePciPeripheralDataAccessEnabledProtoV2& from);
  void MergeFrom(const DevicePciPeripheralDataAccessEnabledProtoV2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePciPeripheralDataAccessEnabledProtoV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2";
  }
  protected:
  explicit DevicePciPeripheralDataAccessEnabledProtoV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_DeviceBorealisAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto) */ {
 public:
  inline OBSOLETE_DeviceBorealisAllowedProto() : OBSOLETE_DeviceBorealisAllowedProto(nullptr) {}
  ~OBSOLETE_DeviceBorealisAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_DeviceBorealisAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_DeviceBorealisAllowedProto(const OBSOLETE_DeviceBorealisAllowedProto& from);
  OBSOLETE_DeviceBorealisAllowedProto(OBSOLETE_DeviceBorealisAllowedProto&& from) noexcept
    : OBSOLETE_DeviceBorealisAllowedProto() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_DeviceBorealisAllowedProto& operator=(const OBSOLETE_DeviceBorealisAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_DeviceBorealisAllowedProto& operator=(OBSOLETE_DeviceBorealisAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OBSOLETE_DeviceBorealisAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_DeviceBorealisAllowedProto* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_DeviceBorealisAllowedProto*>(
               &_OBSOLETE_DeviceBorealisAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(OBSOLETE_DeviceBorealisAllowedProto& a, OBSOLETE_DeviceBorealisAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_DeviceBorealisAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_DeviceBorealisAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_DeviceBorealisAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_DeviceBorealisAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OBSOLETE_DeviceBorealisAllowedProto& from);
  void MergeFrom(const OBSOLETE_DeviceBorealisAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OBSOLETE_DeviceBorealisAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OBSOLETE_DeviceBorealisAllowedProto";
  }
  protected:
  explicit OBSOLETE_DeviceBorealisAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedFieldNumber = 1,
  };
  // optional bool allowed = 1 [default = true];
  bool has_allowed() const;
  private:
  bool _internal_has_allowed() const;
  public:
  void clear_allowed();
  bool allowed() const;
  void set_allowed(bool value);
  private:
  bool _internal_allowed() const;
  void _internal_set_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceAllowedBluetoothServicesProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAllowedBluetoothServicesProto) */ {
 public:
  inline DeviceAllowedBluetoothServicesProto() : DeviceAllowedBluetoothServicesProto(nullptr) {}
  ~DeviceAllowedBluetoothServicesProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceAllowedBluetoothServicesProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAllowedBluetoothServicesProto(const DeviceAllowedBluetoothServicesProto& from);
  DeviceAllowedBluetoothServicesProto(DeviceAllowedBluetoothServicesProto&& from) noexcept
    : DeviceAllowedBluetoothServicesProto() {
    *this = ::std::move(from);
  }

  inline DeviceAllowedBluetoothServicesProto& operator=(const DeviceAllowedBluetoothServicesProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAllowedBluetoothServicesProto& operator=(DeviceAllowedBluetoothServicesProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAllowedBluetoothServicesProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAllowedBluetoothServicesProto* internal_default_instance() {
    return reinterpret_cast<const DeviceAllowedBluetoothServicesProto*>(
               &_DeviceAllowedBluetoothServicesProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(DeviceAllowedBluetoothServicesProto& a, DeviceAllowedBluetoothServicesProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAllowedBluetoothServicesProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAllowedBluetoothServicesProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAllowedBluetoothServicesProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAllowedBluetoothServicesProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAllowedBluetoothServicesProto& from);
  void MergeFrom(const DeviceAllowedBluetoothServicesProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAllowedBluetoothServicesProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAllowedBluetoothServicesProto";
  }
  protected:
  explicit DeviceAllowedBluetoothServicesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowlistFieldNumber = 1,
  };
  // repeated string allowlist = 1;
  int allowlist_size() const;
  private:
  int _internal_allowlist_size() const;
  public:
  void clear_allowlist();
  const std::string& allowlist(int index) const;
  std::string* mutable_allowlist(int index);
  void set_allowlist(int index, const std::string& value);
  void set_allowlist(int index, std::string&& value);
  void set_allowlist(int index, const char* value);
  void set_allowlist(int index, const char* value, size_t size);
  std::string* add_allowlist();
  void add_allowlist(const std::string& value);
  void add_allowlist(std::string&& value);
  void add_allowlist(const char* value);
  void add_allowlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowlist();
  private:
  const std::string& _internal_allowlist(int index) const;
  std::string* _internal_add_allowlist();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAllowedBluetoothServicesProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowlist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceDebugPacketCaptureAllowedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceDebugPacketCaptureAllowedProto) */ {
 public:
  inline DeviceDebugPacketCaptureAllowedProto() : DeviceDebugPacketCaptureAllowedProto(nullptr) {}
  ~DeviceDebugPacketCaptureAllowedProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceDebugPacketCaptureAllowedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceDebugPacketCaptureAllowedProto(const DeviceDebugPacketCaptureAllowedProto& from);
  DeviceDebugPacketCaptureAllowedProto(DeviceDebugPacketCaptureAllowedProto&& from) noexcept
    : DeviceDebugPacketCaptureAllowedProto() {
    *this = ::std::move(from);
  }

  inline DeviceDebugPacketCaptureAllowedProto& operator=(const DeviceDebugPacketCaptureAllowedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceDebugPacketCaptureAllowedProto& operator=(DeviceDebugPacketCaptureAllowedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceDebugPacketCaptureAllowedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceDebugPacketCaptureAllowedProto* internal_default_instance() {
    return reinterpret_cast<const DeviceDebugPacketCaptureAllowedProto*>(
               &_DeviceDebugPacketCaptureAllowedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(DeviceDebugPacketCaptureAllowedProto& a, DeviceDebugPacketCaptureAllowedProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceDebugPacketCaptureAllowedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceDebugPacketCaptureAllowedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceDebugPacketCaptureAllowedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceDebugPacketCaptureAllowedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceDebugPacketCaptureAllowedProto& from);
  void MergeFrom(const DeviceDebugPacketCaptureAllowedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceDebugPacketCaptureAllowedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceDebugPacketCaptureAllowedProto";
  }
  protected:
  explicit DeviceDebugPacketCaptureAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedFieldNumber = 1,
  };
  // optional bool allowed = 1;
  bool has_allowed() const;
  private:
  bool _internal_has_allowed() const;
  public:
  void clear_allowed();
  bool allowed() const;
  void set_allowed(bool value);
  private:
  bool _internal_allowed() const;
  void _internal_set_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceScheduledRebootProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceScheduledRebootProto) */ {
 public:
  inline DeviceScheduledRebootProto() : DeviceScheduledRebootProto(nullptr) {}
  ~DeviceScheduledRebootProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceScheduledRebootProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceScheduledRebootProto(const DeviceScheduledRebootProto& from);
  DeviceScheduledRebootProto(DeviceScheduledRebootProto&& from) noexcept
    : DeviceScheduledRebootProto() {
    *this = ::std::move(from);
  }

  inline DeviceScheduledRebootProto& operator=(const DeviceScheduledRebootProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceScheduledRebootProto& operator=(DeviceScheduledRebootProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceScheduledRebootProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceScheduledRebootProto* internal_default_instance() {
    return reinterpret_cast<const DeviceScheduledRebootProto*>(
               &_DeviceScheduledRebootProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(DeviceScheduledRebootProto& a, DeviceScheduledRebootProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceScheduledRebootProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceScheduledRebootProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceScheduledRebootProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceScheduledRebootProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceScheduledRebootProto& from);
  void MergeFrom(const DeviceScheduledRebootProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceScheduledRebootProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceScheduledRebootProto";
  }
  protected:
  explicit DeviceScheduledRebootProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceScheduledRebootSettingsFieldNumber = 1,
  };
  // optional string device_scheduled_reboot_settings = 1;
  bool has_device_scheduled_reboot_settings() const;
  private:
  bool _internal_has_device_scheduled_reboot_settings() const;
  public:
  void clear_device_scheduled_reboot_settings();
  const std::string& device_scheduled_reboot_settings() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_scheduled_reboot_settings(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_scheduled_reboot_settings();
  PROTOBUF_NODISCARD std::string* release_device_scheduled_reboot_settings();
  void set_allocated_device_scheduled_reboot_settings(std::string* device_scheduled_reboot_settings);
  private:
  const std::string& _internal_device_scheduled_reboot_settings() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_scheduled_reboot_settings(const std::string& value);
  std::string* _internal_mutable_device_scheduled_reboot_settings();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceScheduledRebootProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_scheduled_reboot_settings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceRestrictedManagedGuestSessionEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto) */ {
 public:
  inline DeviceRestrictedManagedGuestSessionEnabledProto() : DeviceRestrictedManagedGuestSessionEnabledProto(nullptr) {}
  ~DeviceRestrictedManagedGuestSessionEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceRestrictedManagedGuestSessionEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRestrictedManagedGuestSessionEnabledProto(const DeviceRestrictedManagedGuestSessionEnabledProto& from);
  DeviceRestrictedManagedGuestSessionEnabledProto(DeviceRestrictedManagedGuestSessionEnabledProto&& from) noexcept
    : DeviceRestrictedManagedGuestSessionEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceRestrictedManagedGuestSessionEnabledProto& operator=(const DeviceRestrictedManagedGuestSessionEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRestrictedManagedGuestSessionEnabledProto& operator=(DeviceRestrictedManagedGuestSessionEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceRestrictedManagedGuestSessionEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRestrictedManagedGuestSessionEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceRestrictedManagedGuestSessionEnabledProto*>(
               &_DeviceRestrictedManagedGuestSessionEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(DeviceRestrictedManagedGuestSessionEnabledProto& a, DeviceRestrictedManagedGuestSessionEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRestrictedManagedGuestSessionEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRestrictedManagedGuestSessionEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRestrictedManagedGuestSessionEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRestrictedManagedGuestSessionEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceRestrictedManagedGuestSessionEnabledProto& from);
  void MergeFrom(const DeviceRestrictedManagedGuestSessionEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRestrictedManagedGuestSessionEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto";
  }
  protected:
  explicit DeviceRestrictedManagedGuestSessionEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceI18nShortcutsEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceI18nShortcutsEnabledProto) */ {
 public:
  inline DeviceI18nShortcutsEnabledProto() : DeviceI18nShortcutsEnabledProto(nullptr) {}
  ~DeviceI18nShortcutsEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceI18nShortcutsEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceI18nShortcutsEnabledProto(const DeviceI18nShortcutsEnabledProto& from);
  DeviceI18nShortcutsEnabledProto(DeviceI18nShortcutsEnabledProto&& from) noexcept
    : DeviceI18nShortcutsEnabledProto() {
    *this = ::std::move(from);
  }

  inline DeviceI18nShortcutsEnabledProto& operator=(const DeviceI18nShortcutsEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceI18nShortcutsEnabledProto& operator=(DeviceI18nShortcutsEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceI18nShortcutsEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceI18nShortcutsEnabledProto* internal_default_instance() {
    return reinterpret_cast<const DeviceI18nShortcutsEnabledProto*>(
               &_DeviceI18nShortcutsEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(DeviceI18nShortcutsEnabledProto& a, DeviceI18nShortcutsEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceI18nShortcutsEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceI18nShortcutsEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceI18nShortcutsEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceI18nShortcutsEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceI18nShortcutsEnabledProto& from);
  void MergeFrom(const DeviceI18nShortcutsEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceI18nShortcutsEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceI18nShortcutsEnabledProto";
  }
  protected:
  explicit DeviceI18nShortcutsEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceI18nShortcutsEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class RevenDeviceHWDataUsageEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RevenDeviceHWDataUsageEnabledProto) */ {
 public:
  inline RevenDeviceHWDataUsageEnabledProto() : RevenDeviceHWDataUsageEnabledProto(nullptr) {}
  ~RevenDeviceHWDataUsageEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR RevenDeviceHWDataUsageEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevenDeviceHWDataUsageEnabledProto(const RevenDeviceHWDataUsageEnabledProto& from);
  RevenDeviceHWDataUsageEnabledProto(RevenDeviceHWDataUsageEnabledProto&& from) noexcept
    : RevenDeviceHWDataUsageEnabledProto() {
    *this = ::std::move(from);
  }

  inline RevenDeviceHWDataUsageEnabledProto& operator=(const RevenDeviceHWDataUsageEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevenDeviceHWDataUsageEnabledProto& operator=(RevenDeviceHWDataUsageEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RevenDeviceHWDataUsageEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevenDeviceHWDataUsageEnabledProto* internal_default_instance() {
    return reinterpret_cast<const RevenDeviceHWDataUsageEnabledProto*>(
               &_RevenDeviceHWDataUsageEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(RevenDeviceHWDataUsageEnabledProto& a, RevenDeviceHWDataUsageEnabledProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RevenDeviceHWDataUsageEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevenDeviceHWDataUsageEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevenDeviceHWDataUsageEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevenDeviceHWDataUsageEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RevenDeviceHWDataUsageEnabledProto& from);
  void MergeFrom(const RevenDeviceHWDataUsageEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RevenDeviceHWDataUsageEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RevenDeviceHWDataUsageEnabledProto";
  }
  protected:
  explicit RevenDeviceHWDataUsageEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHardwareDataUsageEnabledFieldNumber = 1,
  };
  // optional bool hardware_data_usage_enabled = 1 [default = false];
  bool has_hardware_data_usage_enabled() const;
  private:
  bool _internal_has_hardware_data_usage_enabled() const;
  public:
  void clear_hardware_data_usage_enabled();
  bool hardware_data_usage_enabled() const;
  void set_hardware_data_usage_enabled(bool value);
  private:
  bool _internal_hardware_data_usage_enabled() const;
  void _internal_set_hardware_data_usage_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool hardware_data_usage_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceLoginScreenWebUILazyLoadingProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto) */ {
 public:
  inline DeviceLoginScreenWebUILazyLoadingProto() : DeviceLoginScreenWebUILazyLoadingProto(nullptr) {}
  ~DeviceLoginScreenWebUILazyLoadingProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceLoginScreenWebUILazyLoadingProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLoginScreenWebUILazyLoadingProto(const DeviceLoginScreenWebUILazyLoadingProto& from);
  DeviceLoginScreenWebUILazyLoadingProto(DeviceLoginScreenWebUILazyLoadingProto&& from) noexcept
    : DeviceLoginScreenWebUILazyLoadingProto() {
    *this = ::std::move(from);
  }

  inline DeviceLoginScreenWebUILazyLoadingProto& operator=(const DeviceLoginScreenWebUILazyLoadingProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLoginScreenWebUILazyLoadingProto& operator=(DeviceLoginScreenWebUILazyLoadingProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceLoginScreenWebUILazyLoadingProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLoginScreenWebUILazyLoadingProto* internal_default_instance() {
    return reinterpret_cast<const DeviceLoginScreenWebUILazyLoadingProto*>(
               &_DeviceLoginScreenWebUILazyLoadingProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(DeviceLoginScreenWebUILazyLoadingProto& a, DeviceLoginScreenWebUILazyLoadingProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLoginScreenWebUILazyLoadingProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLoginScreenWebUILazyLoadingProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLoginScreenWebUILazyLoadingProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLoginScreenWebUILazyLoadingProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceLoginScreenWebUILazyLoadingProto& from);
  void MergeFrom(const DeviceLoginScreenWebUILazyLoadingProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceLoginScreenWebUILazyLoadingProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceLoginScreenWebUILazyLoadingProto";
  }
  protected:
  explicit DeviceLoginScreenWebUILazyLoadingProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class EncryptedReportingPipelineConfigurationProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.EncryptedReportingPipelineConfigurationProto) */ {
 public:
  inline EncryptedReportingPipelineConfigurationProto() : EncryptedReportingPipelineConfigurationProto(nullptr) {}
  ~EncryptedReportingPipelineConfigurationProto() override;
  explicit PROTOBUF_CONSTEXPR EncryptedReportingPipelineConfigurationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncryptedReportingPipelineConfigurationProto(const EncryptedReportingPipelineConfigurationProto& from);
  EncryptedReportingPipelineConfigurationProto(EncryptedReportingPipelineConfigurationProto&& from) noexcept
    : EncryptedReportingPipelineConfigurationProto() {
    *this = ::std::move(from);
  }

  inline EncryptedReportingPipelineConfigurationProto& operator=(const EncryptedReportingPipelineConfigurationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptedReportingPipelineConfigurationProto& operator=(EncryptedReportingPipelineConfigurationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EncryptedReportingPipelineConfigurationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptedReportingPipelineConfigurationProto* internal_default_instance() {
    return reinterpret_cast<const EncryptedReportingPipelineConfigurationProto*>(
               &_EncryptedReportingPipelineConfigurationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(EncryptedReportingPipelineConfigurationProto& a, EncryptedReportingPipelineConfigurationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptedReportingPipelineConfigurationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptedReportingPipelineConfigurationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncryptedReportingPipelineConfigurationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncryptedReportingPipelineConfigurationProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EncryptedReportingPipelineConfigurationProto& from);
  void MergeFrom(const EncryptedReportingPipelineConfigurationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EncryptedReportingPipelineConfigurationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.EncryptedReportingPipelineConfigurationProto";
  }
  protected:
  explicit EncryptedReportingPipelineConfigurationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.EncryptedReportingPipelineConfigurationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class DeviceReportXDREventsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceReportXDREventsProto) */ {
 public:
  inline DeviceReportXDREventsProto() : DeviceReportXDREventsProto(nullptr) {}
  ~DeviceReportXDREventsProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceReportXDREventsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceReportXDREventsProto(const DeviceReportXDREventsProto& from);
  DeviceReportXDREventsProto(DeviceReportXDREventsProto&& from) noexcept
    : DeviceReportXDREventsProto() {
    *this = ::std::move(from);
  }

  inline DeviceReportXDREventsProto& operator=(const DeviceReportXDREventsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceReportXDREventsProto& operator=(DeviceReportXDREventsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceReportXDREventsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceReportXDREventsProto* internal_default_instance() {
    return reinterpret_cast<const DeviceReportXDREventsProto*>(
               &_DeviceReportXDREventsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(DeviceReportXDREventsProto& a, DeviceReportXDREventsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceReportXDREventsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceReportXDREventsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceReportXDREventsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceReportXDREventsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceReportXDREventsProto& from);
  void MergeFrom(const DeviceReportXDREventsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceReportXDREventsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceReportXDREventsProto";
  }
  protected:
  explicit DeviceReportXDREventsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceReportXDREventsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class ChromeDeviceSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeDeviceSettingsProto) */ {
 public:
  inline ChromeDeviceSettingsProto() : ChromeDeviceSettingsProto(nullptr) {}
  ~ChromeDeviceSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR ChromeDeviceSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeDeviceSettingsProto(const ChromeDeviceSettingsProto& from);
  ChromeDeviceSettingsProto(ChromeDeviceSettingsProto&& from) noexcept
    : ChromeDeviceSettingsProto() {
    *this = ::std::move(from);
  }

  inline ChromeDeviceSettingsProto& operator=(const ChromeDeviceSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeDeviceSettingsProto& operator=(ChromeDeviceSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeDeviceSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeDeviceSettingsProto* internal_default_instance() {
    return reinterpret_cast<const ChromeDeviceSettingsProto*>(
               &_ChromeDeviceSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(ChromeDeviceSettingsProto& a, ChromeDeviceSettingsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeDeviceSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeDeviceSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeDeviceSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeDeviceSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeDeviceSettingsProto& from);
  void MergeFrom(const ChromeDeviceSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeDeviceSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeDeviceSettingsProto";
  }
  protected:
  explicit ChromeDeviceSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePolicyRefreshRateFieldNumber = 1,
    kUserWhitelistFieldNumber = 2,
    kGuestModeEnabledFieldNumber = 3,
    kDeviceProxySettingsFieldNumber = 4,
    kCameraEnabledFieldNumber = 5,
    kShowUserNamesFieldNumber = 6,
    kDataRoamingEnabledFieldNumber = 7,
    kAllowNewUsersFieldNumber = 8,
    kMetricsEnabledFieldNumber = 9,
    kReleaseChannelFieldNumber = 10,
    kOpenNetworkConfigurationFieldNumber = 11,
    kDeviceReportingFieldNumber = 12,
    kEphemeralUsersEnabledFieldNumber = 13,
    kAppPackFieldNumber = 14,
    kForcedLogoutTimeoutsFieldNumber = 15,
    kLoginScreenSaverFieldNumber = 16,
    kAutoUpdateSettingsFieldNumber = 17,
    kStartUpUrlsFieldNumber = 18,
    kPinnedAppsFieldNumber = 19,
    kSystemTimezoneFieldNumber = 20,
    kDeviceLocalAccountsFieldNumber = 21,
    kAllowRedeemOffersFieldNumber = 22,
    kFeatureFlagsFieldNumber = 23,
    kUptimeLimitFieldNumber = 24,
    kVariationsParameterFieldNumber = 25,
    kAttestationSettingsFieldNumber = 26,
    kAccessibilitySettingsFieldNumber = 27,
    kSupervisedUsersSettingsFieldNumber = 28,
    kLoginScreenPowerManagementFieldNumber = 29,
    kUse24HourClockFieldNumber = 30,
    kAutoCleanUpSettingsFieldNumber = 31,
    kSystemSettingsFieldNumber = 32,
    kSamlSettingsFieldNumber = 33,
    kRebootOnShutdownFieldNumber = 34,
    kDeviceHeartbeatSettingsFieldNumber = 35,
    kExtensionCacheSizeFieldNumber = 36,
    kLoginScreenDomainAutoCompleteFieldNumber = 37,
    kDeviceLogUploadSettingsFieldNumber = 38,
    kDisplayRotationDefaultFieldNumber = 39,
    kAllowKioskAppControlChromeVersionFieldNumber = 40,
    kLoginAuthenticationBehaviorFieldNumber = 41,
    kUsbDetachableWhitelistFieldNumber = 42,
    kAllowBluetoothFieldNumber = 43,
    kQuirksDownloadEnabledFieldNumber = 44,
    kLoginVideoCaptureAllowedUrlsFieldNumber = 45,
    kDeviceLoginScreenExtensionsFieldNumber = 46,
    kNetworkThrottlingFieldNumber = 47,
    kDeviceWallpaperImageFieldNumber = 48,
    kLoginScreenLocalesFieldNumber = 49,
    kLoginScreenInputMethodsFieldNumber = 50,
    kDeviceEcryptfsMigrationStrategyFieldNumber = 51,
    kDeviceSecondFactorAuthenticationFieldNumber = 52,
    kCastReceiverNameFieldNumber = 53,
    kDeviceOffHoursFieldNumber = 54,
    kNativeDevicePrintersFieldNumber = 55,
    kNativeDevicePrintersAccessModeFieldNumber = 56,
    kNativeDevicePrintersBlacklistFieldNumber = 57,
    kNativeDevicePrintersWhitelistFieldNumber = 58,
    kTpmFirmwareUpdateSettingsFieldNumber = 59,
    kMinimumRequiredVersionFieldNumber = 60,
    kDeviceLoginScreenAutoSelectCertificateForUrlsFieldNumber = 62,
    kUnaffiliatedArcAllowedFieldNumber = 63,
    kNetworkHostnameFieldNumber = 64,
    kDeviceKerberosEncryptionTypesFieldNumber = 65,
    kDeviceUserPolicyLoopbackProcessingModeFieldNumber = 66,
    kDeviceLoginScreenIsolateOriginsFieldNumber = 67,
    kDeviceLoginScreenSitePerProcessFieldNumber = 68,
    kVirtualMachinesAllowedFieldNumber = 69,
    kDeviceMachinePasswordChangeRateFieldNumber = 70,
    kDeviceUnaffiliatedCrostiniAllowedFieldNumber = 72,
    kDeviceWifiFastTransitionEnabledFieldNumber = 73,
    kDeviceDisplayResolutionFieldNumber = 74,
    kPluginVmAllowedFieldNumber = 75,
    kDeviceGpoCacheLifetimeFieldNumber = 76,
    kDeviceAuthDataCacheLifetimeFieldNumber = 77,
    kPluginVmLicenseKeyFieldNumber = 78,
    kDeviceRebootOnUserSignoutFieldNumber = 79,
    kDeviceWilcoDtcAllowedFieldNumber = 80,
    kDeviceWilcoDtcConfigurationFieldNumber = 81,
    kDeviceWifiAllowedFieldNumber = 82,
    kDevicePowerPeakShiftFieldNumber = 83,
    kDeviceBootOnAcFieldNumber = 84,
    kDeviceDockMacAddressSourceFieldNumber = 85,
    kDeviceAdvancedBatteryChargeModeFieldNumber = 86,
    kDeviceBatteryChargeModeFieldNumber = 87,
    kDeviceUsbPowerShareFieldNumber = 88,
    kDeviceScheduledUpdateCheckFieldNumber = 89,
    kDevicePowerwashAllowedFieldNumber = 91,
    kDeviceLoginScreenWebusbAllowDevicesForUrlsFieldNumber = 92,
    kDeviceLoginScreenSystemInfoEnforcedFieldNumber = 93,
    kDeviceWebBasedAttestationAllowedUrlsFieldNumber = 94,
    kDeviceShowNumericKeyboardForPasswordFieldNumber = 95,
    kLoginScreenPrimaryMouseButtonSwitchFieldNumber = 96,
    kDeviceMinimumVersionFieldNumber = 97,
    kSystemProxySettingsFieldNumber = 98,
    kDeviceChromeVariationsTypeFieldNumber = 99,
    kDeviceLoginScreenPrivacyScreenEnabledFieldNumber = 100,
    kRequiredClientCertificateForDeviceFieldNumber = 101,
    kDeviceCrostiniArcAdbSideloadingAllowedFieldNumber = 102,
    kDeviceMinimumVersionAueMessageFieldNumber = 103,
    kManagedGuestSessionPrivacyWarningsFieldNumber = 104,
    kExternalPrintServersFieldNumber = 105,
    kExternalPrintServersAllowlistFieldNumber = 106,
    kDevicePrintersAccessModeFieldNumber = 107,
    kDevicePrintersBlocklistFieldNumber = 108,
    kDevicePrintersAllowlistFieldNumber = 109,
    kDevicePrintersFieldNumber = 110,
    kDeviceShowLowDiskSpaceNotificationFieldNumber = 111,
    kUserAllowlistFieldNumber = 112,
    kUsbDetachableAllowlistFieldNumber = 113,
    kFamilyLinkAccountsAllowedFieldNumber = 114,
    kArcDataSnapshotHoursFieldNumber = 115,
    kDeviceAllowMgsToStoreDisplayPropertiesFieldNumber = 116,
    kDeviceSystemWideTracingEnabledFieldNumber = 117,
    kDevicePciPeripheralDataAccessEnabledFieldNumber = 118,
    kDeviceBorealisAllowedFieldNumber = 119,
    kDeviceAllowedBluetoothServicesFieldNumber = 120,
    kDeviceDebugPacketCaptureAllowedFieldNumber = 121,
    kDeviceScheduledRebootFieldNumber = 122,
    kDevicePciPeripheralDataAccessEnabledV2FieldNumber = 123,
    kDeviceRestrictedManagedGuestSessionEnabledFieldNumber = 124,
    kHostnameUserConfigurableFieldNumber = 125,
    kLoginScreenPromptOnMultipleMatchingCertificatesFieldNumber = 126,
    kKioskCrxManifestUpdateUrlIgnoredFieldNumber = 127,
    kDeviceI18NShortcutsEnabledFieldNumber = 128,
    kChromadToCloudMigrationEnabledFieldNumber = 129,
    kHardwareDataUsageEnabledFieldNumber = 130,
    kLoginWebUiLazyLoadingFieldNumber = 131,
    kKeylockerForStorageEncryptionEnabledFieldNumber = 132,
    kDeviceRunAutomaticCleanupOnLoginFieldNumber = 133,
    kDeviceEncryptedReportingPipelineEnabledFieldNumber = 134,
    kSamlUsernameFieldNumber = 135,
    kDeviceLoginScreenContextAwareAccessSignalsAllowlistFieldNumber = 136,
    kDevicePrintingClientNameTemplateFieldNumber = 137,
    kDeviceReportXdrEventsFieldNumber = 138,
    kKeyboardBacklightColorFieldNumber = 139,
    kDeviceHindiInscriptLayoutEnabledFieldNumber = 140,
    kLoginScreenExtensionManifestV2AvailabilityFieldNumber = 141,
    kDeviceScreensaverEnabledFieldNumber = 142,
    kDeviceScreensaverIdleTimeoutSecondsFieldNumber = 143,
    kDeviceScreensaverImageDisplayIntervalSecondsFieldNumber = 144,
    kDeviceScreensaverImagesFieldNumber = 145,
    kDeviceSystemAecEnabledFieldNumber = 146,
  };
  // optional .enterprise_management.DevicePolicyRefreshRateProto device_policy_refresh_rate = 1;
  bool has_device_policy_refresh_rate() const;
  private:
  bool _internal_has_device_policy_refresh_rate() const;
  public:
  void clear_device_policy_refresh_rate();
  const ::enterprise_management::DevicePolicyRefreshRateProto& device_policy_refresh_rate() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePolicyRefreshRateProto* release_device_policy_refresh_rate();
  ::enterprise_management::DevicePolicyRefreshRateProto* mutable_device_policy_refresh_rate();
  void set_allocated_device_policy_refresh_rate(::enterprise_management::DevicePolicyRefreshRateProto* device_policy_refresh_rate);
  private:
  const ::enterprise_management::DevicePolicyRefreshRateProto& _internal_device_policy_refresh_rate() const;
  ::enterprise_management::DevicePolicyRefreshRateProto* _internal_mutable_device_policy_refresh_rate();
  public:
  void unsafe_arena_set_allocated_device_policy_refresh_rate(
      ::enterprise_management::DevicePolicyRefreshRateProto* device_policy_refresh_rate);
  ::enterprise_management::DevicePolicyRefreshRateProto* unsafe_arena_release_device_policy_refresh_rate();

  // optional .enterprise_management.UserWhitelistProto user_whitelist = 2;
  bool has_user_whitelist() const;
  private:
  bool _internal_has_user_whitelist() const;
  public:
  void clear_user_whitelist();
  const ::enterprise_management::UserWhitelistProto& user_whitelist() const;
  PROTOBUF_NODISCARD ::enterprise_management::UserWhitelistProto* release_user_whitelist();
  ::enterprise_management::UserWhitelistProto* mutable_user_whitelist();
  void set_allocated_user_whitelist(::enterprise_management::UserWhitelistProto* user_whitelist);
  private:
  const ::enterprise_management::UserWhitelistProto& _internal_user_whitelist() const;
  ::enterprise_management::UserWhitelistProto* _internal_mutable_user_whitelist();
  public:
  void unsafe_arena_set_allocated_user_whitelist(
      ::enterprise_management::UserWhitelistProto* user_whitelist);
  ::enterprise_management::UserWhitelistProto* unsafe_arena_release_user_whitelist();

  // optional .enterprise_management.GuestModeEnabledProto guest_mode_enabled = 3;
  bool has_guest_mode_enabled() const;
  private:
  bool _internal_has_guest_mode_enabled() const;
  public:
  void clear_guest_mode_enabled();
  const ::enterprise_management::GuestModeEnabledProto& guest_mode_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::GuestModeEnabledProto* release_guest_mode_enabled();
  ::enterprise_management::GuestModeEnabledProto* mutable_guest_mode_enabled();
  void set_allocated_guest_mode_enabled(::enterprise_management::GuestModeEnabledProto* guest_mode_enabled);
  private:
  const ::enterprise_management::GuestModeEnabledProto& _internal_guest_mode_enabled() const;
  ::enterprise_management::GuestModeEnabledProto* _internal_mutable_guest_mode_enabled();
  public:
  void unsafe_arena_set_allocated_guest_mode_enabled(
      ::enterprise_management::GuestModeEnabledProto* guest_mode_enabled);
  ::enterprise_management::GuestModeEnabledProto* unsafe_arena_release_guest_mode_enabled();

  // optional .enterprise_management.OBSOLETE_DeviceProxySettingsProto device_proxy_settings = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_device_proxy_settings() const;
  private:
  bool _internal_has_device_proxy_settings() const;
  public:
  PROTOBUF_DEPRECATED void clear_device_proxy_settings();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_DeviceProxySettingsProto& device_proxy_settings() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* release_device_proxy_settings();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* mutable_device_proxy_settings();
  PROTOBUF_DEPRECATED void set_allocated_device_proxy_settings(::enterprise_management::OBSOLETE_DeviceProxySettingsProto* device_proxy_settings);
  private:
  const ::enterprise_management::OBSOLETE_DeviceProxySettingsProto& _internal_device_proxy_settings() const;
  ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* _internal_mutable_device_proxy_settings();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_device_proxy_settings(
      ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* device_proxy_settings);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* unsafe_arena_release_device_proxy_settings();

  // optional .enterprise_management.CameraEnabledProto camera_enabled = 5;
  bool has_camera_enabled() const;
  private:
  bool _internal_has_camera_enabled() const;
  public:
  void clear_camera_enabled();
  const ::enterprise_management::CameraEnabledProto& camera_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::CameraEnabledProto* release_camera_enabled();
  ::enterprise_management::CameraEnabledProto* mutable_camera_enabled();
  void set_allocated_camera_enabled(::enterprise_management::CameraEnabledProto* camera_enabled);
  private:
  const ::enterprise_management::CameraEnabledProto& _internal_camera_enabled() const;
  ::enterprise_management::CameraEnabledProto* _internal_mutable_camera_enabled();
  public:
  void unsafe_arena_set_allocated_camera_enabled(
      ::enterprise_management::CameraEnabledProto* camera_enabled);
  ::enterprise_management::CameraEnabledProto* unsafe_arena_release_camera_enabled();

  // optional .enterprise_management.ShowUserNamesOnSigninProto show_user_names = 6;
  bool has_show_user_names() const;
  private:
  bool _internal_has_show_user_names() const;
  public:
  void clear_show_user_names();
  const ::enterprise_management::ShowUserNamesOnSigninProto& show_user_names() const;
  PROTOBUF_NODISCARD ::enterprise_management::ShowUserNamesOnSigninProto* release_show_user_names();
  ::enterprise_management::ShowUserNamesOnSigninProto* mutable_show_user_names();
  void set_allocated_show_user_names(::enterprise_management::ShowUserNamesOnSigninProto* show_user_names);
  private:
  const ::enterprise_management::ShowUserNamesOnSigninProto& _internal_show_user_names() const;
  ::enterprise_management::ShowUserNamesOnSigninProto* _internal_mutable_show_user_names();
  public:
  void unsafe_arena_set_allocated_show_user_names(
      ::enterprise_management::ShowUserNamesOnSigninProto* show_user_names);
  ::enterprise_management::ShowUserNamesOnSigninProto* unsafe_arena_release_show_user_names();

  // optional .enterprise_management.DataRoamingEnabledProto data_roaming_enabled = 7;
  bool has_data_roaming_enabled() const;
  private:
  bool _internal_has_data_roaming_enabled() const;
  public:
  void clear_data_roaming_enabled();
  const ::enterprise_management::DataRoamingEnabledProto& data_roaming_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DataRoamingEnabledProto* release_data_roaming_enabled();
  ::enterprise_management::DataRoamingEnabledProto* mutable_data_roaming_enabled();
  void set_allocated_data_roaming_enabled(::enterprise_management::DataRoamingEnabledProto* data_roaming_enabled);
  private:
  const ::enterprise_management::DataRoamingEnabledProto& _internal_data_roaming_enabled() const;
  ::enterprise_management::DataRoamingEnabledProto* _internal_mutable_data_roaming_enabled();
  public:
  void unsafe_arena_set_allocated_data_roaming_enabled(
      ::enterprise_management::DataRoamingEnabledProto* data_roaming_enabled);
  ::enterprise_management::DataRoamingEnabledProto* unsafe_arena_release_data_roaming_enabled();

  // optional .enterprise_management.AllowNewUsersProto allow_new_users = 8;
  bool has_allow_new_users() const;
  private:
  bool _internal_has_allow_new_users() const;
  public:
  void clear_allow_new_users();
  const ::enterprise_management::AllowNewUsersProto& allow_new_users() const;
  PROTOBUF_NODISCARD ::enterprise_management::AllowNewUsersProto* release_allow_new_users();
  ::enterprise_management::AllowNewUsersProto* mutable_allow_new_users();
  void set_allocated_allow_new_users(::enterprise_management::AllowNewUsersProto* allow_new_users);
  private:
  const ::enterprise_management::AllowNewUsersProto& _internal_allow_new_users() const;
  ::enterprise_management::AllowNewUsersProto* _internal_mutable_allow_new_users();
  public:
  void unsafe_arena_set_allocated_allow_new_users(
      ::enterprise_management::AllowNewUsersProto* allow_new_users);
  ::enterprise_management::AllowNewUsersProto* unsafe_arena_release_allow_new_users();

  // optional .enterprise_management.MetricsEnabledProto metrics_enabled = 9;
  bool has_metrics_enabled() const;
  private:
  bool _internal_has_metrics_enabled() const;
  public:
  void clear_metrics_enabled();
  const ::enterprise_management::MetricsEnabledProto& metrics_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::MetricsEnabledProto* release_metrics_enabled();
  ::enterprise_management::MetricsEnabledProto* mutable_metrics_enabled();
  void set_allocated_metrics_enabled(::enterprise_management::MetricsEnabledProto* metrics_enabled);
  private:
  const ::enterprise_management::MetricsEnabledProto& _internal_metrics_enabled() const;
  ::enterprise_management::MetricsEnabledProto* _internal_mutable_metrics_enabled();
  public:
  void unsafe_arena_set_allocated_metrics_enabled(
      ::enterprise_management::MetricsEnabledProto* metrics_enabled);
  ::enterprise_management::MetricsEnabledProto* unsafe_arena_release_metrics_enabled();

  // optional .enterprise_management.ReleaseChannelProto release_channel = 10;
  bool has_release_channel() const;
  private:
  bool _internal_has_release_channel() const;
  public:
  void clear_release_channel();
  const ::enterprise_management::ReleaseChannelProto& release_channel() const;
  PROTOBUF_NODISCARD ::enterprise_management::ReleaseChannelProto* release_release_channel();
  ::enterprise_management::ReleaseChannelProto* mutable_release_channel();
  void set_allocated_release_channel(::enterprise_management::ReleaseChannelProto* release_channel);
  private:
  const ::enterprise_management::ReleaseChannelProto& _internal_release_channel() const;
  ::enterprise_management::ReleaseChannelProto* _internal_mutable_release_channel();
  public:
  void unsafe_arena_set_allocated_release_channel(
      ::enterprise_management::ReleaseChannelProto* release_channel);
  ::enterprise_management::ReleaseChannelProto* unsafe_arena_release_release_channel();

  // optional .enterprise_management.DeviceOpenNetworkConfigurationProto open_network_configuration = 11;
  bool has_open_network_configuration() const;
  private:
  bool _internal_has_open_network_configuration() const;
  public:
  void clear_open_network_configuration();
  const ::enterprise_management::DeviceOpenNetworkConfigurationProto& open_network_configuration() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceOpenNetworkConfigurationProto* release_open_network_configuration();
  ::enterprise_management::DeviceOpenNetworkConfigurationProto* mutable_open_network_configuration();
  void set_allocated_open_network_configuration(::enterprise_management::DeviceOpenNetworkConfigurationProto* open_network_configuration);
  private:
  const ::enterprise_management::DeviceOpenNetworkConfigurationProto& _internal_open_network_configuration() const;
  ::enterprise_management::DeviceOpenNetworkConfigurationProto* _internal_mutable_open_network_configuration();
  public:
  void unsafe_arena_set_allocated_open_network_configuration(
      ::enterprise_management::DeviceOpenNetworkConfigurationProto* open_network_configuration);
  ::enterprise_management::DeviceOpenNetworkConfigurationProto* unsafe_arena_release_open_network_configuration();

  // optional .enterprise_management.DeviceReportingProto device_reporting = 12;
  bool has_device_reporting() const;
  private:
  bool _internal_has_device_reporting() const;
  public:
  void clear_device_reporting();
  const ::enterprise_management::DeviceReportingProto& device_reporting() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceReportingProto* release_device_reporting();
  ::enterprise_management::DeviceReportingProto* mutable_device_reporting();
  void set_allocated_device_reporting(::enterprise_management::DeviceReportingProto* device_reporting);
  private:
  const ::enterprise_management::DeviceReportingProto& _internal_device_reporting() const;
  ::enterprise_management::DeviceReportingProto* _internal_mutable_device_reporting();
  public:
  void unsafe_arena_set_allocated_device_reporting(
      ::enterprise_management::DeviceReportingProto* device_reporting);
  ::enterprise_management::DeviceReportingProto* unsafe_arena_release_device_reporting();

  // optional .enterprise_management.EphemeralUsersEnabledProto ephemeral_users_enabled = 13;
  bool has_ephemeral_users_enabled() const;
  private:
  bool _internal_has_ephemeral_users_enabled() const;
  public:
  void clear_ephemeral_users_enabled();
  const ::enterprise_management::EphemeralUsersEnabledProto& ephemeral_users_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::EphemeralUsersEnabledProto* release_ephemeral_users_enabled();
  ::enterprise_management::EphemeralUsersEnabledProto* mutable_ephemeral_users_enabled();
  void set_allocated_ephemeral_users_enabled(::enterprise_management::EphemeralUsersEnabledProto* ephemeral_users_enabled);
  private:
  const ::enterprise_management::EphemeralUsersEnabledProto& _internal_ephemeral_users_enabled() const;
  ::enterprise_management::EphemeralUsersEnabledProto* _internal_mutable_ephemeral_users_enabled();
  public:
  void unsafe_arena_set_allocated_ephemeral_users_enabled(
      ::enterprise_management::EphemeralUsersEnabledProto* ephemeral_users_enabled);
  ::enterprise_management::EphemeralUsersEnabledProto* unsafe_arena_release_ephemeral_users_enabled();

  // optional .enterprise_management.OBSOLETE_AppPackProto app_pack = 14 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_app_pack() const;
  private:
  bool _internal_has_app_pack() const;
  public:
  PROTOBUF_DEPRECATED void clear_app_pack();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_AppPackProto& app_pack() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_AppPackProto* release_app_pack();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_AppPackProto* mutable_app_pack();
  PROTOBUF_DEPRECATED void set_allocated_app_pack(::enterprise_management::OBSOLETE_AppPackProto* app_pack);
  private:
  const ::enterprise_management::OBSOLETE_AppPackProto& _internal_app_pack() const;
  ::enterprise_management::OBSOLETE_AppPackProto* _internal_mutable_app_pack();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_app_pack(
      ::enterprise_management::OBSOLETE_AppPackProto* app_pack);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_AppPackProto* unsafe_arena_release_app_pack();

  // optional .enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto forced_logout_timeouts = 15 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_forced_logout_timeouts() const;
  private:
  bool _internal_has_forced_logout_timeouts() const;
  public:
  PROTOBUF_DEPRECATED void clear_forced_logout_timeouts();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto& forced_logout_timeouts() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* release_forced_logout_timeouts();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* mutable_forced_logout_timeouts();
  PROTOBUF_DEPRECATED void set_allocated_forced_logout_timeouts(::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* forced_logout_timeouts);
  private:
  const ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto& _internal_forced_logout_timeouts() const;
  ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* _internal_mutable_forced_logout_timeouts();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_forced_logout_timeouts(
      ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* forced_logout_timeouts);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* unsafe_arena_release_forced_logout_timeouts();

  // optional .enterprise_management.OBSOLETE_ScreenSaverProto login_screen_saver = 16 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_login_screen_saver() const;
  private:
  bool _internal_has_login_screen_saver() const;
  public:
  PROTOBUF_DEPRECATED void clear_login_screen_saver();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_ScreenSaverProto& login_screen_saver() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_ScreenSaverProto* release_login_screen_saver();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_ScreenSaverProto* mutable_login_screen_saver();
  PROTOBUF_DEPRECATED void set_allocated_login_screen_saver(::enterprise_management::OBSOLETE_ScreenSaverProto* login_screen_saver);
  private:
  const ::enterprise_management::OBSOLETE_ScreenSaverProto& _internal_login_screen_saver() const;
  ::enterprise_management::OBSOLETE_ScreenSaverProto* _internal_mutable_login_screen_saver();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_login_screen_saver(
      ::enterprise_management::OBSOLETE_ScreenSaverProto* login_screen_saver);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_ScreenSaverProto* unsafe_arena_release_login_screen_saver();

  // optional .enterprise_management.AutoUpdateSettingsProto auto_update_settings = 17;
  bool has_auto_update_settings() const;
  private:
  bool _internal_has_auto_update_settings() const;
  public:
  void clear_auto_update_settings();
  const ::enterprise_management::AutoUpdateSettingsProto& auto_update_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::AutoUpdateSettingsProto* release_auto_update_settings();
  ::enterprise_management::AutoUpdateSettingsProto* mutable_auto_update_settings();
  void set_allocated_auto_update_settings(::enterprise_management::AutoUpdateSettingsProto* auto_update_settings);
  private:
  const ::enterprise_management::AutoUpdateSettingsProto& _internal_auto_update_settings() const;
  ::enterprise_management::AutoUpdateSettingsProto* _internal_mutable_auto_update_settings();
  public:
  void unsafe_arena_set_allocated_auto_update_settings(
      ::enterprise_management::AutoUpdateSettingsProto* auto_update_settings);
  ::enterprise_management::AutoUpdateSettingsProto* unsafe_arena_release_auto_update_settings();

  // optional .enterprise_management.OBSOLETE_StartUpUrlsProto start_up_urls = 18 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_start_up_urls() const;
  private:
  bool _internal_has_start_up_urls() const;
  public:
  PROTOBUF_DEPRECATED void clear_start_up_urls();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_StartUpUrlsProto& start_up_urls() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_StartUpUrlsProto* release_start_up_urls();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_StartUpUrlsProto* mutable_start_up_urls();
  PROTOBUF_DEPRECATED void set_allocated_start_up_urls(::enterprise_management::OBSOLETE_StartUpUrlsProto* start_up_urls);
  private:
  const ::enterprise_management::OBSOLETE_StartUpUrlsProto& _internal_start_up_urls() const;
  ::enterprise_management::OBSOLETE_StartUpUrlsProto* _internal_mutable_start_up_urls();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_start_up_urls(
      ::enterprise_management::OBSOLETE_StartUpUrlsProto* start_up_urls);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_StartUpUrlsProto* unsafe_arena_release_start_up_urls();

  // optional .enterprise_management.OBSOLETE_PinnedAppsProto pinned_apps = 19 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_pinned_apps() const;
  private:
  bool _internal_has_pinned_apps() const;
  public:
  PROTOBUF_DEPRECATED void clear_pinned_apps();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_PinnedAppsProto& pinned_apps() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_PinnedAppsProto* release_pinned_apps();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_PinnedAppsProto* mutable_pinned_apps();
  PROTOBUF_DEPRECATED void set_allocated_pinned_apps(::enterprise_management::OBSOLETE_PinnedAppsProto* pinned_apps);
  private:
  const ::enterprise_management::OBSOLETE_PinnedAppsProto& _internal_pinned_apps() const;
  ::enterprise_management::OBSOLETE_PinnedAppsProto* _internal_mutable_pinned_apps();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_pinned_apps(
      ::enterprise_management::OBSOLETE_PinnedAppsProto* pinned_apps);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_PinnedAppsProto* unsafe_arena_release_pinned_apps();

  // optional .enterprise_management.SystemTimezoneProto system_timezone = 20;
  bool has_system_timezone() const;
  private:
  bool _internal_has_system_timezone() const;
  public:
  void clear_system_timezone();
  const ::enterprise_management::SystemTimezoneProto& system_timezone() const;
  PROTOBUF_NODISCARD ::enterprise_management::SystemTimezoneProto* release_system_timezone();
  ::enterprise_management::SystemTimezoneProto* mutable_system_timezone();
  void set_allocated_system_timezone(::enterprise_management::SystemTimezoneProto* system_timezone);
  private:
  const ::enterprise_management::SystemTimezoneProto& _internal_system_timezone() const;
  ::enterprise_management::SystemTimezoneProto* _internal_mutable_system_timezone();
  public:
  void unsafe_arena_set_allocated_system_timezone(
      ::enterprise_management::SystemTimezoneProto* system_timezone);
  ::enterprise_management::SystemTimezoneProto* unsafe_arena_release_system_timezone();

  // optional .enterprise_management.DeviceLocalAccountsProto device_local_accounts = 21;
  bool has_device_local_accounts() const;
  private:
  bool _internal_has_device_local_accounts() const;
  public:
  void clear_device_local_accounts();
  const ::enterprise_management::DeviceLocalAccountsProto& device_local_accounts() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceLocalAccountsProto* release_device_local_accounts();
  ::enterprise_management::DeviceLocalAccountsProto* mutable_device_local_accounts();
  void set_allocated_device_local_accounts(::enterprise_management::DeviceLocalAccountsProto* device_local_accounts);
  private:
  const ::enterprise_management::DeviceLocalAccountsProto& _internal_device_local_accounts() const;
  ::enterprise_management::DeviceLocalAccountsProto* _internal_mutable_device_local_accounts();
  public:
  void unsafe_arena_set_allocated_device_local_accounts(
      ::enterprise_management::DeviceLocalAccountsProto* device_local_accounts);
  ::enterprise_management::DeviceLocalAccountsProto* unsafe_arena_release_device_local_accounts();

  // optional .enterprise_management.AllowRedeemChromeOsRegistrationOffersProto allow_redeem_offers = 22;
  bool has_allow_redeem_offers() const;
  private:
  bool _internal_has_allow_redeem_offers() const;
  public:
  void clear_allow_redeem_offers();
  const ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto& allow_redeem_offers() const;
  PROTOBUF_NODISCARD ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* release_allow_redeem_offers();
  ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* mutable_allow_redeem_offers();
  void set_allocated_allow_redeem_offers(::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* allow_redeem_offers);
  private:
  const ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto& _internal_allow_redeem_offers() const;
  ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* _internal_mutable_allow_redeem_offers();
  public:
  void unsafe_arena_set_allocated_allow_redeem_offers(
      ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* allow_redeem_offers);
  ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* unsafe_arena_release_allow_redeem_offers();

  // optional .enterprise_management.FeatureFlagsProto feature_flags = 23;
  bool has_feature_flags() const;
  private:
  bool _internal_has_feature_flags() const;
  public:
  void clear_feature_flags();
  const ::enterprise_management::FeatureFlagsProto& feature_flags() const;
  PROTOBUF_NODISCARD ::enterprise_management::FeatureFlagsProto* release_feature_flags();
  ::enterprise_management::FeatureFlagsProto* mutable_feature_flags();
  void set_allocated_feature_flags(::enterprise_management::FeatureFlagsProto* feature_flags);
  private:
  const ::enterprise_management::FeatureFlagsProto& _internal_feature_flags() const;
  ::enterprise_management::FeatureFlagsProto* _internal_mutable_feature_flags();
  public:
  void unsafe_arena_set_allocated_feature_flags(
      ::enterprise_management::FeatureFlagsProto* feature_flags);
  ::enterprise_management::FeatureFlagsProto* unsafe_arena_release_feature_flags();

  // optional .enterprise_management.UptimeLimitProto uptime_limit = 24;
  bool has_uptime_limit() const;
  private:
  bool _internal_has_uptime_limit() const;
  public:
  void clear_uptime_limit();
  const ::enterprise_management::UptimeLimitProto& uptime_limit() const;
  PROTOBUF_NODISCARD ::enterprise_management::UptimeLimitProto* release_uptime_limit();
  ::enterprise_management::UptimeLimitProto* mutable_uptime_limit();
  void set_allocated_uptime_limit(::enterprise_management::UptimeLimitProto* uptime_limit);
  private:
  const ::enterprise_management::UptimeLimitProto& _internal_uptime_limit() const;
  ::enterprise_management::UptimeLimitProto* _internal_mutable_uptime_limit();
  public:
  void unsafe_arena_set_allocated_uptime_limit(
      ::enterprise_management::UptimeLimitProto* uptime_limit);
  ::enterprise_management::UptimeLimitProto* unsafe_arena_release_uptime_limit();

  // optional .enterprise_management.VariationsParameterProto variations_parameter = 25;
  bool has_variations_parameter() const;
  private:
  bool _internal_has_variations_parameter() const;
  public:
  void clear_variations_parameter();
  const ::enterprise_management::VariationsParameterProto& variations_parameter() const;
  PROTOBUF_NODISCARD ::enterprise_management::VariationsParameterProto* release_variations_parameter();
  ::enterprise_management::VariationsParameterProto* mutable_variations_parameter();
  void set_allocated_variations_parameter(::enterprise_management::VariationsParameterProto* variations_parameter);
  private:
  const ::enterprise_management::VariationsParameterProto& _internal_variations_parameter() const;
  ::enterprise_management::VariationsParameterProto* _internal_mutable_variations_parameter();
  public:
  void unsafe_arena_set_allocated_variations_parameter(
      ::enterprise_management::VariationsParameterProto* variations_parameter);
  ::enterprise_management::VariationsParameterProto* unsafe_arena_release_variations_parameter();

  // optional .enterprise_management.AttestationSettingsProto attestation_settings = 26;
  bool has_attestation_settings() const;
  private:
  bool _internal_has_attestation_settings() const;
  public:
  void clear_attestation_settings();
  const ::enterprise_management::AttestationSettingsProto& attestation_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::AttestationSettingsProto* release_attestation_settings();
  ::enterprise_management::AttestationSettingsProto* mutable_attestation_settings();
  void set_allocated_attestation_settings(::enterprise_management::AttestationSettingsProto* attestation_settings);
  private:
  const ::enterprise_management::AttestationSettingsProto& _internal_attestation_settings() const;
  ::enterprise_management::AttestationSettingsProto* _internal_mutable_attestation_settings();
  public:
  void unsafe_arena_set_allocated_attestation_settings(
      ::enterprise_management::AttestationSettingsProto* attestation_settings);
  ::enterprise_management::AttestationSettingsProto* unsafe_arena_release_attestation_settings();

  // optional .enterprise_management.AccessibilitySettingsProto accessibility_settings = 27;
  bool has_accessibility_settings() const;
  private:
  bool _internal_has_accessibility_settings() const;
  public:
  void clear_accessibility_settings();
  const ::enterprise_management::AccessibilitySettingsProto& accessibility_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::AccessibilitySettingsProto* release_accessibility_settings();
  ::enterprise_management::AccessibilitySettingsProto* mutable_accessibility_settings();
  void set_allocated_accessibility_settings(::enterprise_management::AccessibilitySettingsProto* accessibility_settings);
  private:
  const ::enterprise_management::AccessibilitySettingsProto& _internal_accessibility_settings() const;
  ::enterprise_management::AccessibilitySettingsProto* _internal_mutable_accessibility_settings();
  public:
  void unsafe_arena_set_allocated_accessibility_settings(
      ::enterprise_management::AccessibilitySettingsProto* accessibility_settings);
  ::enterprise_management::AccessibilitySettingsProto* unsafe_arena_release_accessibility_settings();

  // optional .enterprise_management.OBSOLETE_SupervisedUsersSettingsProto supervised_users_settings = 28 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_supervised_users_settings() const;
  private:
  bool _internal_has_supervised_users_settings() const;
  public:
  PROTOBUF_DEPRECATED void clear_supervised_users_settings();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto& supervised_users_settings() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* release_supervised_users_settings();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* mutable_supervised_users_settings();
  PROTOBUF_DEPRECATED void set_allocated_supervised_users_settings(::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* supervised_users_settings);
  private:
  const ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto& _internal_supervised_users_settings() const;
  ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* _internal_mutable_supervised_users_settings();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_supervised_users_settings(
      ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* supervised_users_settings);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* unsafe_arena_release_supervised_users_settings();

  // optional .enterprise_management.LoginScreenPowerManagementProto login_screen_power_management = 29;
  bool has_login_screen_power_management() const;
  private:
  bool _internal_has_login_screen_power_management() const;
  public:
  void clear_login_screen_power_management();
  const ::enterprise_management::LoginScreenPowerManagementProto& login_screen_power_management() const;
  PROTOBUF_NODISCARD ::enterprise_management::LoginScreenPowerManagementProto* release_login_screen_power_management();
  ::enterprise_management::LoginScreenPowerManagementProto* mutable_login_screen_power_management();
  void set_allocated_login_screen_power_management(::enterprise_management::LoginScreenPowerManagementProto* login_screen_power_management);
  private:
  const ::enterprise_management::LoginScreenPowerManagementProto& _internal_login_screen_power_management() const;
  ::enterprise_management::LoginScreenPowerManagementProto* _internal_mutable_login_screen_power_management();
  public:
  void unsafe_arena_set_allocated_login_screen_power_management(
      ::enterprise_management::LoginScreenPowerManagementProto* login_screen_power_management);
  ::enterprise_management::LoginScreenPowerManagementProto* unsafe_arena_release_login_screen_power_management();

  // optional .enterprise_management.SystemUse24HourClockProto use_24hour_clock = 30;
  bool has_use_24hour_clock() const;
  private:
  bool _internal_has_use_24hour_clock() const;
  public:
  void clear_use_24hour_clock();
  const ::enterprise_management::SystemUse24HourClockProto& use_24hour_clock() const;
  PROTOBUF_NODISCARD ::enterprise_management::SystemUse24HourClockProto* release_use_24hour_clock();
  ::enterprise_management::SystemUse24HourClockProto* mutable_use_24hour_clock();
  void set_allocated_use_24hour_clock(::enterprise_management::SystemUse24HourClockProto* use_24hour_clock);
  private:
  const ::enterprise_management::SystemUse24HourClockProto& _internal_use_24hour_clock() const;
  ::enterprise_management::SystemUse24HourClockProto* _internal_mutable_use_24hour_clock();
  public:
  void unsafe_arena_set_allocated_use_24hour_clock(
      ::enterprise_management::SystemUse24HourClockProto* use_24hour_clock);
  ::enterprise_management::SystemUse24HourClockProto* unsafe_arena_release_use_24hour_clock();

  // optional .enterprise_management.AutoCleanupSettigsProto auto_clean_up_settings = 31;
  bool has_auto_clean_up_settings() const;
  private:
  bool _internal_has_auto_clean_up_settings() const;
  public:
  void clear_auto_clean_up_settings();
  const ::enterprise_management::AutoCleanupSettigsProto& auto_clean_up_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::AutoCleanupSettigsProto* release_auto_clean_up_settings();
  ::enterprise_management::AutoCleanupSettigsProto* mutable_auto_clean_up_settings();
  void set_allocated_auto_clean_up_settings(::enterprise_management::AutoCleanupSettigsProto* auto_clean_up_settings);
  private:
  const ::enterprise_management::AutoCleanupSettigsProto& _internal_auto_clean_up_settings() const;
  ::enterprise_management::AutoCleanupSettigsProto* _internal_mutable_auto_clean_up_settings();
  public:
  void unsafe_arena_set_allocated_auto_clean_up_settings(
      ::enterprise_management::AutoCleanupSettigsProto* auto_clean_up_settings);
  ::enterprise_management::AutoCleanupSettigsProto* unsafe_arena_release_auto_clean_up_settings();

  // optional .enterprise_management.SystemSettingsProto system_settings = 32;
  bool has_system_settings() const;
  private:
  bool _internal_has_system_settings() const;
  public:
  void clear_system_settings();
  const ::enterprise_management::SystemSettingsProto& system_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::SystemSettingsProto* release_system_settings();
  ::enterprise_management::SystemSettingsProto* mutable_system_settings();
  void set_allocated_system_settings(::enterprise_management::SystemSettingsProto* system_settings);
  private:
  const ::enterprise_management::SystemSettingsProto& _internal_system_settings() const;
  ::enterprise_management::SystemSettingsProto* _internal_mutable_system_settings();
  public:
  void unsafe_arena_set_allocated_system_settings(
      ::enterprise_management::SystemSettingsProto* system_settings);
  ::enterprise_management::SystemSettingsProto* unsafe_arena_release_system_settings();

  // optional .enterprise_management.SAMLSettingsProto saml_settings = 33;
  bool has_saml_settings() const;
  private:
  bool _internal_has_saml_settings() const;
  public:
  void clear_saml_settings();
  const ::enterprise_management::SAMLSettingsProto& saml_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::SAMLSettingsProto* release_saml_settings();
  ::enterprise_management::SAMLSettingsProto* mutable_saml_settings();
  void set_allocated_saml_settings(::enterprise_management::SAMLSettingsProto* saml_settings);
  private:
  const ::enterprise_management::SAMLSettingsProto& _internal_saml_settings() const;
  ::enterprise_management::SAMLSettingsProto* _internal_mutable_saml_settings();
  public:
  void unsafe_arena_set_allocated_saml_settings(
      ::enterprise_management::SAMLSettingsProto* saml_settings);
  ::enterprise_management::SAMLSettingsProto* unsafe_arena_release_saml_settings();

  // optional .enterprise_management.RebootOnShutdownProto reboot_on_shutdown = 34;
  bool has_reboot_on_shutdown() const;
  private:
  bool _internal_has_reboot_on_shutdown() const;
  public:
  void clear_reboot_on_shutdown();
  const ::enterprise_management::RebootOnShutdownProto& reboot_on_shutdown() const;
  PROTOBUF_NODISCARD ::enterprise_management::RebootOnShutdownProto* release_reboot_on_shutdown();
  ::enterprise_management::RebootOnShutdownProto* mutable_reboot_on_shutdown();
  void set_allocated_reboot_on_shutdown(::enterprise_management::RebootOnShutdownProto* reboot_on_shutdown);
  private:
  const ::enterprise_management::RebootOnShutdownProto& _internal_reboot_on_shutdown() const;
  ::enterprise_management::RebootOnShutdownProto* _internal_mutable_reboot_on_shutdown();
  public:
  void unsafe_arena_set_allocated_reboot_on_shutdown(
      ::enterprise_management::RebootOnShutdownProto* reboot_on_shutdown);
  ::enterprise_management::RebootOnShutdownProto* unsafe_arena_release_reboot_on_shutdown();

  // optional .enterprise_management.DeviceHeartbeatSettingsProto device_heartbeat_settings = 35;
  bool has_device_heartbeat_settings() const;
  private:
  bool _internal_has_device_heartbeat_settings() const;
  public:
  void clear_device_heartbeat_settings();
  const ::enterprise_management::DeviceHeartbeatSettingsProto& device_heartbeat_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceHeartbeatSettingsProto* release_device_heartbeat_settings();
  ::enterprise_management::DeviceHeartbeatSettingsProto* mutable_device_heartbeat_settings();
  void set_allocated_device_heartbeat_settings(::enterprise_management::DeviceHeartbeatSettingsProto* device_heartbeat_settings);
  private:
  const ::enterprise_management::DeviceHeartbeatSettingsProto& _internal_device_heartbeat_settings() const;
  ::enterprise_management::DeviceHeartbeatSettingsProto* _internal_mutable_device_heartbeat_settings();
  public:
  void unsafe_arena_set_allocated_device_heartbeat_settings(
      ::enterprise_management::DeviceHeartbeatSettingsProto* device_heartbeat_settings);
  ::enterprise_management::DeviceHeartbeatSettingsProto* unsafe_arena_release_device_heartbeat_settings();

  // optional .enterprise_management.ExtensionCacheSizeProto extension_cache_size = 36;
  bool has_extension_cache_size() const;
  private:
  bool _internal_has_extension_cache_size() const;
  public:
  void clear_extension_cache_size();
  const ::enterprise_management::ExtensionCacheSizeProto& extension_cache_size() const;
  PROTOBUF_NODISCARD ::enterprise_management::ExtensionCacheSizeProto* release_extension_cache_size();
  ::enterprise_management::ExtensionCacheSizeProto* mutable_extension_cache_size();
  void set_allocated_extension_cache_size(::enterprise_management::ExtensionCacheSizeProto* extension_cache_size);
  private:
  const ::enterprise_management::ExtensionCacheSizeProto& _internal_extension_cache_size() const;
  ::enterprise_management::ExtensionCacheSizeProto* _internal_mutable_extension_cache_size();
  public:
  void unsafe_arena_set_allocated_extension_cache_size(
      ::enterprise_management::ExtensionCacheSizeProto* extension_cache_size);
  ::enterprise_management::ExtensionCacheSizeProto* unsafe_arena_release_extension_cache_size();

  // optional .enterprise_management.LoginScreenDomainAutoCompleteProto login_screen_domain_auto_complete = 37;
  bool has_login_screen_domain_auto_complete() const;
  private:
  bool _internal_has_login_screen_domain_auto_complete() const;
  public:
  void clear_login_screen_domain_auto_complete();
  const ::enterprise_management::LoginScreenDomainAutoCompleteProto& login_screen_domain_auto_complete() const;
  PROTOBUF_NODISCARD ::enterprise_management::LoginScreenDomainAutoCompleteProto* release_login_screen_domain_auto_complete();
  ::enterprise_management::LoginScreenDomainAutoCompleteProto* mutable_login_screen_domain_auto_complete();
  void set_allocated_login_screen_domain_auto_complete(::enterprise_management::LoginScreenDomainAutoCompleteProto* login_screen_domain_auto_complete);
  private:
  const ::enterprise_management::LoginScreenDomainAutoCompleteProto& _internal_login_screen_domain_auto_complete() const;
  ::enterprise_management::LoginScreenDomainAutoCompleteProto* _internal_mutable_login_screen_domain_auto_complete();
  public:
  void unsafe_arena_set_allocated_login_screen_domain_auto_complete(
      ::enterprise_management::LoginScreenDomainAutoCompleteProto* login_screen_domain_auto_complete);
  ::enterprise_management::LoginScreenDomainAutoCompleteProto* unsafe_arena_release_login_screen_domain_auto_complete();

  // optional .enterprise_management.DeviceLogUploadSettingsProto device_log_upload_settings = 38;
  bool has_device_log_upload_settings() const;
  private:
  bool _internal_has_device_log_upload_settings() const;
  public:
  void clear_device_log_upload_settings();
  const ::enterprise_management::DeviceLogUploadSettingsProto& device_log_upload_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceLogUploadSettingsProto* release_device_log_upload_settings();
  ::enterprise_management::DeviceLogUploadSettingsProto* mutable_device_log_upload_settings();
  void set_allocated_device_log_upload_settings(::enterprise_management::DeviceLogUploadSettingsProto* device_log_upload_settings);
  private:
  const ::enterprise_management::DeviceLogUploadSettingsProto& _internal_device_log_upload_settings() const;
  ::enterprise_management::DeviceLogUploadSettingsProto* _internal_mutable_device_log_upload_settings();
  public:
  void unsafe_arena_set_allocated_device_log_upload_settings(
      ::enterprise_management::DeviceLogUploadSettingsProto* device_log_upload_settings);
  ::enterprise_management::DeviceLogUploadSettingsProto* unsafe_arena_release_device_log_upload_settings();

  // optional .enterprise_management.DisplayRotationDefaultProto display_rotation_default = 39;
  bool has_display_rotation_default() const;
  private:
  bool _internal_has_display_rotation_default() const;
  public:
  void clear_display_rotation_default();
  const ::enterprise_management::DisplayRotationDefaultProto& display_rotation_default() const;
  PROTOBUF_NODISCARD ::enterprise_management::DisplayRotationDefaultProto* release_display_rotation_default();
  ::enterprise_management::DisplayRotationDefaultProto* mutable_display_rotation_default();
  void set_allocated_display_rotation_default(::enterprise_management::DisplayRotationDefaultProto* display_rotation_default);
  private:
  const ::enterprise_management::DisplayRotationDefaultProto& _internal_display_rotation_default() const;
  ::enterprise_management::DisplayRotationDefaultProto* _internal_mutable_display_rotation_default();
  public:
  void unsafe_arena_set_allocated_display_rotation_default(
      ::enterprise_management::DisplayRotationDefaultProto* display_rotation_default);
  ::enterprise_management::DisplayRotationDefaultProto* unsafe_arena_release_display_rotation_default();

  // optional .enterprise_management.AllowKioskAppControlChromeVersionProto allow_kiosk_app_control_chrome_version = 40;
  bool has_allow_kiosk_app_control_chrome_version() const;
  private:
  bool _internal_has_allow_kiosk_app_control_chrome_version() const;
  public:
  void clear_allow_kiosk_app_control_chrome_version();
  const ::enterprise_management::AllowKioskAppControlChromeVersionProto& allow_kiosk_app_control_chrome_version() const;
  PROTOBUF_NODISCARD ::enterprise_management::AllowKioskAppControlChromeVersionProto* release_allow_kiosk_app_control_chrome_version();
  ::enterprise_management::AllowKioskAppControlChromeVersionProto* mutable_allow_kiosk_app_control_chrome_version();
  void set_allocated_allow_kiosk_app_control_chrome_version(::enterprise_management::AllowKioskAppControlChromeVersionProto* allow_kiosk_app_control_chrome_version);
  private:
  const ::enterprise_management::AllowKioskAppControlChromeVersionProto& _internal_allow_kiosk_app_control_chrome_version() const;
  ::enterprise_management::AllowKioskAppControlChromeVersionProto* _internal_mutable_allow_kiosk_app_control_chrome_version();
  public:
  void unsafe_arena_set_allocated_allow_kiosk_app_control_chrome_version(
      ::enterprise_management::AllowKioskAppControlChromeVersionProto* allow_kiosk_app_control_chrome_version);
  ::enterprise_management::AllowKioskAppControlChromeVersionProto* unsafe_arena_release_allow_kiosk_app_control_chrome_version();

  // optional .enterprise_management.LoginAuthenticationBehaviorProto login_authentication_behavior = 41;
  bool has_login_authentication_behavior() const;
  private:
  bool _internal_has_login_authentication_behavior() const;
  public:
  void clear_login_authentication_behavior();
  const ::enterprise_management::LoginAuthenticationBehaviorProto& login_authentication_behavior() const;
  PROTOBUF_NODISCARD ::enterprise_management::LoginAuthenticationBehaviorProto* release_login_authentication_behavior();
  ::enterprise_management::LoginAuthenticationBehaviorProto* mutable_login_authentication_behavior();
  void set_allocated_login_authentication_behavior(::enterprise_management::LoginAuthenticationBehaviorProto* login_authentication_behavior);
  private:
  const ::enterprise_management::LoginAuthenticationBehaviorProto& _internal_login_authentication_behavior() const;
  ::enterprise_management::LoginAuthenticationBehaviorProto* _internal_mutable_login_authentication_behavior();
  public:
  void unsafe_arena_set_allocated_login_authentication_behavior(
      ::enterprise_management::LoginAuthenticationBehaviorProto* login_authentication_behavior);
  ::enterprise_management::LoginAuthenticationBehaviorProto* unsafe_arena_release_login_authentication_behavior();

  // optional .enterprise_management.UsbDetachableWhitelistProto usb_detachable_whitelist = 42;
  bool has_usb_detachable_whitelist() const;
  private:
  bool _internal_has_usb_detachable_whitelist() const;
  public:
  void clear_usb_detachable_whitelist();
  const ::enterprise_management::UsbDetachableWhitelistProto& usb_detachable_whitelist() const;
  PROTOBUF_NODISCARD ::enterprise_management::UsbDetachableWhitelistProto* release_usb_detachable_whitelist();
  ::enterprise_management::UsbDetachableWhitelistProto* mutable_usb_detachable_whitelist();
  void set_allocated_usb_detachable_whitelist(::enterprise_management::UsbDetachableWhitelistProto* usb_detachable_whitelist);
  private:
  const ::enterprise_management::UsbDetachableWhitelistProto& _internal_usb_detachable_whitelist() const;
  ::enterprise_management::UsbDetachableWhitelistProto* _internal_mutable_usb_detachable_whitelist();
  public:
  void unsafe_arena_set_allocated_usb_detachable_whitelist(
      ::enterprise_management::UsbDetachableWhitelistProto* usb_detachable_whitelist);
  ::enterprise_management::UsbDetachableWhitelistProto* unsafe_arena_release_usb_detachable_whitelist();

  // optional .enterprise_management.AllowBluetoothProto allow_bluetooth = 43;
  bool has_allow_bluetooth() const;
  private:
  bool _internal_has_allow_bluetooth() const;
  public:
  void clear_allow_bluetooth();
  const ::enterprise_management::AllowBluetoothProto& allow_bluetooth() const;
  PROTOBUF_NODISCARD ::enterprise_management::AllowBluetoothProto* release_allow_bluetooth();
  ::enterprise_management::AllowBluetoothProto* mutable_allow_bluetooth();
  void set_allocated_allow_bluetooth(::enterprise_management::AllowBluetoothProto* allow_bluetooth);
  private:
  const ::enterprise_management::AllowBluetoothProto& _internal_allow_bluetooth() const;
  ::enterprise_management::AllowBluetoothProto* _internal_mutable_allow_bluetooth();
  public:
  void unsafe_arena_set_allocated_allow_bluetooth(
      ::enterprise_management::AllowBluetoothProto* allow_bluetooth);
  ::enterprise_management::AllowBluetoothProto* unsafe_arena_release_allow_bluetooth();

  // optional .enterprise_management.DeviceQuirksDownloadEnabledProto quirks_download_enabled = 44;
  bool has_quirks_download_enabled() const;
  private:
  bool _internal_has_quirks_download_enabled() const;
  public:
  void clear_quirks_download_enabled();
  const ::enterprise_management::DeviceQuirksDownloadEnabledProto& quirks_download_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceQuirksDownloadEnabledProto* release_quirks_download_enabled();
  ::enterprise_management::DeviceQuirksDownloadEnabledProto* mutable_quirks_download_enabled();
  void set_allocated_quirks_download_enabled(::enterprise_management::DeviceQuirksDownloadEnabledProto* quirks_download_enabled);
  private:
  const ::enterprise_management::DeviceQuirksDownloadEnabledProto& _internal_quirks_download_enabled() const;
  ::enterprise_management::DeviceQuirksDownloadEnabledProto* _internal_mutable_quirks_download_enabled();
  public:
  void unsafe_arena_set_allocated_quirks_download_enabled(
      ::enterprise_management::DeviceQuirksDownloadEnabledProto* quirks_download_enabled);
  ::enterprise_management::DeviceQuirksDownloadEnabledProto* unsafe_arena_release_quirks_download_enabled();

  // optional .enterprise_management.LoginVideoCaptureAllowedUrlsProto login_video_capture_allowed_urls = 45;
  bool has_login_video_capture_allowed_urls() const;
  private:
  bool _internal_has_login_video_capture_allowed_urls() const;
  public:
  void clear_login_video_capture_allowed_urls();
  const ::enterprise_management::LoginVideoCaptureAllowedUrlsProto& login_video_capture_allowed_urls() const;
  PROTOBUF_NODISCARD ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* release_login_video_capture_allowed_urls();
  ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* mutable_login_video_capture_allowed_urls();
  void set_allocated_login_video_capture_allowed_urls(::enterprise_management::LoginVideoCaptureAllowedUrlsProto* login_video_capture_allowed_urls);
  private:
  const ::enterprise_management::LoginVideoCaptureAllowedUrlsProto& _internal_login_video_capture_allowed_urls() const;
  ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* _internal_mutable_login_video_capture_allowed_urls();
  public:
  void unsafe_arena_set_allocated_login_video_capture_allowed_urls(
      ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* login_video_capture_allowed_urls);
  ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* unsafe_arena_release_login_video_capture_allowed_urls();

  // optional .enterprise_management.DeviceLoginScreenExtensionsProto device_login_screen_extensions = 46;
  bool has_device_login_screen_extensions() const;
  private:
  bool _internal_has_device_login_screen_extensions() const;
  public:
  void clear_device_login_screen_extensions();
  const ::enterprise_management::DeviceLoginScreenExtensionsProto& device_login_screen_extensions() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceLoginScreenExtensionsProto* release_device_login_screen_extensions();
  ::enterprise_management::DeviceLoginScreenExtensionsProto* mutable_device_login_screen_extensions();
  void set_allocated_device_login_screen_extensions(::enterprise_management::DeviceLoginScreenExtensionsProto* device_login_screen_extensions);
  private:
  const ::enterprise_management::DeviceLoginScreenExtensionsProto& _internal_device_login_screen_extensions() const;
  ::enterprise_management::DeviceLoginScreenExtensionsProto* _internal_mutable_device_login_screen_extensions();
  public:
  void unsafe_arena_set_allocated_device_login_screen_extensions(
      ::enterprise_management::DeviceLoginScreenExtensionsProto* device_login_screen_extensions);
  ::enterprise_management::DeviceLoginScreenExtensionsProto* unsafe_arena_release_device_login_screen_extensions();

  // optional .enterprise_management.NetworkThrottlingEnabledProto network_throttling = 47;
  bool has_network_throttling() const;
  private:
  bool _internal_has_network_throttling() const;
  public:
  void clear_network_throttling();
  const ::enterprise_management::NetworkThrottlingEnabledProto& network_throttling() const;
  PROTOBUF_NODISCARD ::enterprise_management::NetworkThrottlingEnabledProto* release_network_throttling();
  ::enterprise_management::NetworkThrottlingEnabledProto* mutable_network_throttling();
  void set_allocated_network_throttling(::enterprise_management::NetworkThrottlingEnabledProto* network_throttling);
  private:
  const ::enterprise_management::NetworkThrottlingEnabledProto& _internal_network_throttling() const;
  ::enterprise_management::NetworkThrottlingEnabledProto* _internal_mutable_network_throttling();
  public:
  void unsafe_arena_set_allocated_network_throttling(
      ::enterprise_management::NetworkThrottlingEnabledProto* network_throttling);
  ::enterprise_management::NetworkThrottlingEnabledProto* unsafe_arena_release_network_throttling();

  // optional .enterprise_management.DeviceWallpaperImageProto device_wallpaper_image = 48;
  bool has_device_wallpaper_image() const;
  private:
  bool _internal_has_device_wallpaper_image() const;
  public:
  void clear_device_wallpaper_image();
  const ::enterprise_management::DeviceWallpaperImageProto& device_wallpaper_image() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceWallpaperImageProto* release_device_wallpaper_image();
  ::enterprise_management::DeviceWallpaperImageProto* mutable_device_wallpaper_image();
  void set_allocated_device_wallpaper_image(::enterprise_management::DeviceWallpaperImageProto* device_wallpaper_image);
  private:
  const ::enterprise_management::DeviceWallpaperImageProto& _internal_device_wallpaper_image() const;
  ::enterprise_management::DeviceWallpaperImageProto* _internal_mutable_device_wallpaper_image();
  public:
  void unsafe_arena_set_allocated_device_wallpaper_image(
      ::enterprise_management::DeviceWallpaperImageProto* device_wallpaper_image);
  ::enterprise_management::DeviceWallpaperImageProto* unsafe_arena_release_device_wallpaper_image();

  // optional .enterprise_management.LoginScreenLocalesProto login_screen_locales = 49;
  bool has_login_screen_locales() const;
  private:
  bool _internal_has_login_screen_locales() const;
  public:
  void clear_login_screen_locales();
  const ::enterprise_management::LoginScreenLocalesProto& login_screen_locales() const;
  PROTOBUF_NODISCARD ::enterprise_management::LoginScreenLocalesProto* release_login_screen_locales();
  ::enterprise_management::LoginScreenLocalesProto* mutable_login_screen_locales();
  void set_allocated_login_screen_locales(::enterprise_management::LoginScreenLocalesProto* login_screen_locales);
  private:
  const ::enterprise_management::LoginScreenLocalesProto& _internal_login_screen_locales() const;
  ::enterprise_management::LoginScreenLocalesProto* _internal_mutable_login_screen_locales();
  public:
  void unsafe_arena_set_allocated_login_screen_locales(
      ::enterprise_management::LoginScreenLocalesProto* login_screen_locales);
  ::enterprise_management::LoginScreenLocalesProto* unsafe_arena_release_login_screen_locales();

  // optional .enterprise_management.LoginScreenInputMethodsProto login_screen_input_methods = 50;
  bool has_login_screen_input_methods() const;
  private:
  bool _internal_has_login_screen_input_methods() const;
  public:
  void clear_login_screen_input_methods();
  const ::enterprise_management::LoginScreenInputMethodsProto& login_screen_input_methods() const;
  PROTOBUF_NODISCARD ::enterprise_management::LoginScreenInputMethodsProto* release_login_screen_input_methods();
  ::enterprise_management::LoginScreenInputMethodsProto* mutable_login_screen_input_methods();
  void set_allocated_login_screen_input_methods(::enterprise_management::LoginScreenInputMethodsProto* login_screen_input_methods);
  private:
  const ::enterprise_management::LoginScreenInputMethodsProto& _internal_login_screen_input_methods() const;
  ::enterprise_management::LoginScreenInputMethodsProto* _internal_mutable_login_screen_input_methods();
  public:
  void unsafe_arena_set_allocated_login_screen_input_methods(
      ::enterprise_management::LoginScreenInputMethodsProto* login_screen_input_methods);
  ::enterprise_management::LoginScreenInputMethodsProto* unsafe_arena_release_login_screen_input_methods();

  // optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto device_ecryptfs_migration_strategy = 51 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_device_ecryptfs_migration_strategy() const;
  private:
  bool _internal_has_device_ecryptfs_migration_strategy() const;
  public:
  PROTOBUF_DEPRECATED void clear_device_ecryptfs_migration_strategy();
  PROTOBUF_DEPRECATED const ::enterprise_management::DeviceEcryptfsMigrationStrategyProto& device_ecryptfs_migration_strategy() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* release_device_ecryptfs_migration_strategy();
  PROTOBUF_DEPRECATED ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* mutable_device_ecryptfs_migration_strategy();
  PROTOBUF_DEPRECATED void set_allocated_device_ecryptfs_migration_strategy(::enterprise_management::DeviceEcryptfsMigrationStrategyProto* device_ecryptfs_migration_strategy);
  private:
  const ::enterprise_management::DeviceEcryptfsMigrationStrategyProto& _internal_device_ecryptfs_migration_strategy() const;
  ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* _internal_mutable_device_ecryptfs_migration_strategy();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_device_ecryptfs_migration_strategy(
      ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* device_ecryptfs_migration_strategy);
  PROTOBUF_DEPRECATED ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* unsafe_arena_release_device_ecryptfs_migration_strategy();

  // optional .enterprise_management.DeviceSecondFactorAuthenticationProto device_second_factor_authentication = 52;
  bool has_device_second_factor_authentication() const;
  private:
  bool _internal_has_device_second_factor_authentication() const;
  public:
  void clear_device_second_factor_authentication();
  const ::enterprise_management::DeviceSecondFactorAuthenticationProto& device_second_factor_authentication() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceSecondFactorAuthenticationProto* release_device_second_factor_authentication();
  ::enterprise_management::DeviceSecondFactorAuthenticationProto* mutable_device_second_factor_authentication();
  void set_allocated_device_second_factor_authentication(::enterprise_management::DeviceSecondFactorAuthenticationProto* device_second_factor_authentication);
  private:
  const ::enterprise_management::DeviceSecondFactorAuthenticationProto& _internal_device_second_factor_authentication() const;
  ::enterprise_management::DeviceSecondFactorAuthenticationProto* _internal_mutable_device_second_factor_authentication();
  public:
  void unsafe_arena_set_allocated_device_second_factor_authentication(
      ::enterprise_management::DeviceSecondFactorAuthenticationProto* device_second_factor_authentication);
  ::enterprise_management::DeviceSecondFactorAuthenticationProto* unsafe_arena_release_device_second_factor_authentication();

  // optional .enterprise_management.CastReceiverNameProto cast_receiver_name = 53;
  bool has_cast_receiver_name() const;
  private:
  bool _internal_has_cast_receiver_name() const;
  public:
  void clear_cast_receiver_name();
  const ::enterprise_management::CastReceiverNameProto& cast_receiver_name() const;
  PROTOBUF_NODISCARD ::enterprise_management::CastReceiverNameProto* release_cast_receiver_name();
  ::enterprise_management::CastReceiverNameProto* mutable_cast_receiver_name();
  void set_allocated_cast_receiver_name(::enterprise_management::CastReceiverNameProto* cast_receiver_name);
  private:
  const ::enterprise_management::CastReceiverNameProto& _internal_cast_receiver_name() const;
  ::enterprise_management::CastReceiverNameProto* _internal_mutable_cast_receiver_name();
  public:
  void unsafe_arena_set_allocated_cast_receiver_name(
      ::enterprise_management::CastReceiverNameProto* cast_receiver_name);
  ::enterprise_management::CastReceiverNameProto* unsafe_arena_release_cast_receiver_name();

  // optional .enterprise_management.DeviceOffHoursProto device_off_hours = 54;
  bool has_device_off_hours() const;
  private:
  bool _internal_has_device_off_hours() const;
  public:
  void clear_device_off_hours();
  const ::enterprise_management::DeviceOffHoursProto& device_off_hours() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceOffHoursProto* release_device_off_hours();
  ::enterprise_management::DeviceOffHoursProto* mutable_device_off_hours();
  void set_allocated_device_off_hours(::enterprise_management::DeviceOffHoursProto* device_off_hours);
  private:
  const ::enterprise_management::DeviceOffHoursProto& _internal_device_off_hours() const;
  ::enterprise_management::DeviceOffHoursProto* _internal_mutable_device_off_hours();
  public:
  void unsafe_arena_set_allocated_device_off_hours(
      ::enterprise_management::DeviceOffHoursProto* device_off_hours);
  ::enterprise_management::DeviceOffHoursProto* unsafe_arena_release_device_off_hours();

  // optional .enterprise_management.DeviceNativePrintersProto native_device_printers = 55;
  bool has_native_device_printers() const;
  private:
  bool _internal_has_native_device_printers() const;
  public:
  void clear_native_device_printers();
  const ::enterprise_management::DeviceNativePrintersProto& native_device_printers() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceNativePrintersProto* release_native_device_printers();
  ::enterprise_management::DeviceNativePrintersProto* mutable_native_device_printers();
  void set_allocated_native_device_printers(::enterprise_management::DeviceNativePrintersProto* native_device_printers);
  private:
  const ::enterprise_management::DeviceNativePrintersProto& _internal_native_device_printers() const;
  ::enterprise_management::DeviceNativePrintersProto* _internal_mutable_native_device_printers();
  public:
  void unsafe_arena_set_allocated_native_device_printers(
      ::enterprise_management::DeviceNativePrintersProto* native_device_printers);
  ::enterprise_management::DeviceNativePrintersProto* unsafe_arena_release_native_device_printers();

  // optional .enterprise_management.DeviceNativePrintersAccessModeProto native_device_printers_access_mode = 56;
  bool has_native_device_printers_access_mode() const;
  private:
  bool _internal_has_native_device_printers_access_mode() const;
  public:
  void clear_native_device_printers_access_mode();
  const ::enterprise_management::DeviceNativePrintersAccessModeProto& native_device_printers_access_mode() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceNativePrintersAccessModeProto* release_native_device_printers_access_mode();
  ::enterprise_management::DeviceNativePrintersAccessModeProto* mutable_native_device_printers_access_mode();
  void set_allocated_native_device_printers_access_mode(::enterprise_management::DeviceNativePrintersAccessModeProto* native_device_printers_access_mode);
  private:
  const ::enterprise_management::DeviceNativePrintersAccessModeProto& _internal_native_device_printers_access_mode() const;
  ::enterprise_management::DeviceNativePrintersAccessModeProto* _internal_mutable_native_device_printers_access_mode();
  public:
  void unsafe_arena_set_allocated_native_device_printers_access_mode(
      ::enterprise_management::DeviceNativePrintersAccessModeProto* native_device_printers_access_mode);
  ::enterprise_management::DeviceNativePrintersAccessModeProto* unsafe_arena_release_native_device_printers_access_mode();

  // optional .enterprise_management.DeviceNativePrintersBlacklistProto native_device_printers_blacklist = 57;
  bool has_native_device_printers_blacklist() const;
  private:
  bool _internal_has_native_device_printers_blacklist() const;
  public:
  void clear_native_device_printers_blacklist();
  const ::enterprise_management::DeviceNativePrintersBlacklistProto& native_device_printers_blacklist() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceNativePrintersBlacklistProto* release_native_device_printers_blacklist();
  ::enterprise_management::DeviceNativePrintersBlacklistProto* mutable_native_device_printers_blacklist();
  void set_allocated_native_device_printers_blacklist(::enterprise_management::DeviceNativePrintersBlacklistProto* native_device_printers_blacklist);
  private:
  const ::enterprise_management::DeviceNativePrintersBlacklistProto& _internal_native_device_printers_blacklist() const;
  ::enterprise_management::DeviceNativePrintersBlacklistProto* _internal_mutable_native_device_printers_blacklist();
  public:
  void unsafe_arena_set_allocated_native_device_printers_blacklist(
      ::enterprise_management::DeviceNativePrintersBlacklistProto* native_device_printers_blacklist);
  ::enterprise_management::DeviceNativePrintersBlacklistProto* unsafe_arena_release_native_device_printers_blacklist();

  // optional .enterprise_management.DeviceNativePrintersWhitelistProto native_device_printers_whitelist = 58;
  bool has_native_device_printers_whitelist() const;
  private:
  bool _internal_has_native_device_printers_whitelist() const;
  public:
  void clear_native_device_printers_whitelist();
  const ::enterprise_management::DeviceNativePrintersWhitelistProto& native_device_printers_whitelist() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceNativePrintersWhitelistProto* release_native_device_printers_whitelist();
  ::enterprise_management::DeviceNativePrintersWhitelistProto* mutable_native_device_printers_whitelist();
  void set_allocated_native_device_printers_whitelist(::enterprise_management::DeviceNativePrintersWhitelistProto* native_device_printers_whitelist);
  private:
  const ::enterprise_management::DeviceNativePrintersWhitelistProto& _internal_native_device_printers_whitelist() const;
  ::enterprise_management::DeviceNativePrintersWhitelistProto* _internal_mutable_native_device_printers_whitelist();
  public:
  void unsafe_arena_set_allocated_native_device_printers_whitelist(
      ::enterprise_management::DeviceNativePrintersWhitelistProto* native_device_printers_whitelist);
  ::enterprise_management::DeviceNativePrintersWhitelistProto* unsafe_arena_release_native_device_printers_whitelist();

  // optional .enterprise_management.TPMFirmwareUpdateSettingsProto tpm_firmware_update_settings = 59;
  bool has_tpm_firmware_update_settings() const;
  private:
  bool _internal_has_tpm_firmware_update_settings() const;
  public:
  void clear_tpm_firmware_update_settings();
  const ::enterprise_management::TPMFirmwareUpdateSettingsProto& tpm_firmware_update_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::TPMFirmwareUpdateSettingsProto* release_tpm_firmware_update_settings();
  ::enterprise_management::TPMFirmwareUpdateSettingsProto* mutable_tpm_firmware_update_settings();
  void set_allocated_tpm_firmware_update_settings(::enterprise_management::TPMFirmwareUpdateSettingsProto* tpm_firmware_update_settings);
  private:
  const ::enterprise_management::TPMFirmwareUpdateSettingsProto& _internal_tpm_firmware_update_settings() const;
  ::enterprise_management::TPMFirmwareUpdateSettingsProto* _internal_mutable_tpm_firmware_update_settings();
  public:
  void unsafe_arena_set_allocated_tpm_firmware_update_settings(
      ::enterprise_management::TPMFirmwareUpdateSettingsProto* tpm_firmware_update_settings);
  ::enterprise_management::TPMFirmwareUpdateSettingsProto* unsafe_arena_release_tpm_firmware_update_settings();

  // optional .enterprise_management.OBSOLETE_MinimumRequiredVersionProto minimum_required_version = 60 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_minimum_required_version() const;
  private:
  bool _internal_has_minimum_required_version() const;
  public:
  PROTOBUF_DEPRECATED void clear_minimum_required_version();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto& minimum_required_version() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* release_minimum_required_version();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* mutable_minimum_required_version();
  PROTOBUF_DEPRECATED void set_allocated_minimum_required_version(::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* minimum_required_version);
  private:
  const ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto& _internal_minimum_required_version() const;
  ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* _internal_mutable_minimum_required_version();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_minimum_required_version(
      ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* minimum_required_version);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* unsafe_arena_release_minimum_required_version();

  // optional .enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls device_login_screen_auto_select_certificate_for_urls = 62;
  bool has_device_login_screen_auto_select_certificate_for_urls() const;
  private:
  bool _internal_has_device_login_screen_auto_select_certificate_for_urls() const;
  public:
  void clear_device_login_screen_auto_select_certificate_for_urls();
  const ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls& device_login_screen_auto_select_certificate_for_urls() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* release_device_login_screen_auto_select_certificate_for_urls();
  ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* mutable_device_login_screen_auto_select_certificate_for_urls();
  void set_allocated_device_login_screen_auto_select_certificate_for_urls(::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* device_login_screen_auto_select_certificate_for_urls);
  private:
  const ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls& _internal_device_login_screen_auto_select_certificate_for_urls() const;
  ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* _internal_mutable_device_login_screen_auto_select_certificate_for_urls();
  public:
  void unsafe_arena_set_allocated_device_login_screen_auto_select_certificate_for_urls(
      ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* device_login_screen_auto_select_certificate_for_urls);
  ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* unsafe_arena_release_device_login_screen_auto_select_certificate_for_urls();

  // optional .enterprise_management.UnaffiliatedArcAllowedProto unaffiliated_arc_allowed = 63;
  bool has_unaffiliated_arc_allowed() const;
  private:
  bool _internal_has_unaffiliated_arc_allowed() const;
  public:
  void clear_unaffiliated_arc_allowed();
  const ::enterprise_management::UnaffiliatedArcAllowedProto& unaffiliated_arc_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::UnaffiliatedArcAllowedProto* release_unaffiliated_arc_allowed();
  ::enterprise_management::UnaffiliatedArcAllowedProto* mutable_unaffiliated_arc_allowed();
  void set_allocated_unaffiliated_arc_allowed(::enterprise_management::UnaffiliatedArcAllowedProto* unaffiliated_arc_allowed);
  private:
  const ::enterprise_management::UnaffiliatedArcAllowedProto& _internal_unaffiliated_arc_allowed() const;
  ::enterprise_management::UnaffiliatedArcAllowedProto* _internal_mutable_unaffiliated_arc_allowed();
  public:
  void unsafe_arena_set_allocated_unaffiliated_arc_allowed(
      ::enterprise_management::UnaffiliatedArcAllowedProto* unaffiliated_arc_allowed);
  ::enterprise_management::UnaffiliatedArcAllowedProto* unsafe_arena_release_unaffiliated_arc_allowed();

  // optional .enterprise_management.NetworkHostnameProto network_hostname = 64;
  bool has_network_hostname() const;
  private:
  bool _internal_has_network_hostname() const;
  public:
  void clear_network_hostname();
  const ::enterprise_management::NetworkHostnameProto& network_hostname() const;
  PROTOBUF_NODISCARD ::enterprise_management::NetworkHostnameProto* release_network_hostname();
  ::enterprise_management::NetworkHostnameProto* mutable_network_hostname();
  void set_allocated_network_hostname(::enterprise_management::NetworkHostnameProto* network_hostname);
  private:
  const ::enterprise_management::NetworkHostnameProto& _internal_network_hostname() const;
  ::enterprise_management::NetworkHostnameProto* _internal_mutable_network_hostname();
  public:
  void unsafe_arena_set_allocated_network_hostname(
      ::enterprise_management::NetworkHostnameProto* network_hostname);
  ::enterprise_management::NetworkHostnameProto* unsafe_arena_release_network_hostname();

  // optional .enterprise_management.DeviceKerberosEncryptionTypesProto device_kerberos_encryption_types = 65;
  bool has_device_kerberos_encryption_types() const;
  private:
  bool _internal_has_device_kerberos_encryption_types() const;
  public:
  void clear_device_kerberos_encryption_types();
  const ::enterprise_management::DeviceKerberosEncryptionTypesProto& device_kerberos_encryption_types() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceKerberosEncryptionTypesProto* release_device_kerberos_encryption_types();
  ::enterprise_management::DeviceKerberosEncryptionTypesProto* mutable_device_kerberos_encryption_types();
  void set_allocated_device_kerberos_encryption_types(::enterprise_management::DeviceKerberosEncryptionTypesProto* device_kerberos_encryption_types);
  private:
  const ::enterprise_management::DeviceKerberosEncryptionTypesProto& _internal_device_kerberos_encryption_types() const;
  ::enterprise_management::DeviceKerberosEncryptionTypesProto* _internal_mutable_device_kerberos_encryption_types();
  public:
  void unsafe_arena_set_allocated_device_kerberos_encryption_types(
      ::enterprise_management::DeviceKerberosEncryptionTypesProto* device_kerberos_encryption_types);
  ::enterprise_management::DeviceKerberosEncryptionTypesProto* unsafe_arena_release_device_kerberos_encryption_types();

  // optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto device_user_policy_loopback_processing_mode = 66;
  bool has_device_user_policy_loopback_processing_mode() const;
  private:
  bool _internal_has_device_user_policy_loopback_processing_mode() const;
  public:
  void clear_device_user_policy_loopback_processing_mode();
  const ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto& device_user_policy_loopback_processing_mode() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* release_device_user_policy_loopback_processing_mode();
  ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* mutable_device_user_policy_loopback_processing_mode();
  void set_allocated_device_user_policy_loopback_processing_mode(::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* device_user_policy_loopback_processing_mode);
  private:
  const ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto& _internal_device_user_policy_loopback_processing_mode() const;
  ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* _internal_mutable_device_user_policy_loopback_processing_mode();
  public:
  void unsafe_arena_set_allocated_device_user_policy_loopback_processing_mode(
      ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* device_user_policy_loopback_processing_mode);
  ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* unsafe_arena_release_device_user_policy_loopback_processing_mode();

  // optional .enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto device_login_screen_isolate_origins = 67 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_device_login_screen_isolate_origins() const;
  private:
  bool _internal_has_device_login_screen_isolate_origins() const;
  public:
  PROTOBUF_DEPRECATED void clear_device_login_screen_isolate_origins();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto& device_login_screen_isolate_origins() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* release_device_login_screen_isolate_origins();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* mutable_device_login_screen_isolate_origins();
  PROTOBUF_DEPRECATED void set_allocated_device_login_screen_isolate_origins(::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* device_login_screen_isolate_origins);
  private:
  const ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto& _internal_device_login_screen_isolate_origins() const;
  ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* _internal_mutable_device_login_screen_isolate_origins();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_device_login_screen_isolate_origins(
      ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* device_login_screen_isolate_origins);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* unsafe_arena_release_device_login_screen_isolate_origins();

  // optional .enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto device_login_screen_site_per_process = 68 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_device_login_screen_site_per_process() const;
  private:
  bool _internal_has_device_login_screen_site_per_process() const;
  public:
  PROTOBUF_DEPRECATED void clear_device_login_screen_site_per_process();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto& device_login_screen_site_per_process() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* release_device_login_screen_site_per_process();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* mutable_device_login_screen_site_per_process();
  PROTOBUF_DEPRECATED void set_allocated_device_login_screen_site_per_process(::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* device_login_screen_site_per_process);
  private:
  const ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto& _internal_device_login_screen_site_per_process() const;
  ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* _internal_mutable_device_login_screen_site_per_process();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_device_login_screen_site_per_process(
      ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* device_login_screen_site_per_process);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* unsafe_arena_release_device_login_screen_site_per_process();

  // optional .enterprise_management.VirtualMachinesAllowedProto virtual_machines_allowed = 69;
  bool has_virtual_machines_allowed() const;
  private:
  bool _internal_has_virtual_machines_allowed() const;
  public:
  void clear_virtual_machines_allowed();
  const ::enterprise_management::VirtualMachinesAllowedProto& virtual_machines_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::VirtualMachinesAllowedProto* release_virtual_machines_allowed();
  ::enterprise_management::VirtualMachinesAllowedProto* mutable_virtual_machines_allowed();
  void set_allocated_virtual_machines_allowed(::enterprise_management::VirtualMachinesAllowedProto* virtual_machines_allowed);
  private:
  const ::enterprise_management::VirtualMachinesAllowedProto& _internal_virtual_machines_allowed() const;
  ::enterprise_management::VirtualMachinesAllowedProto* _internal_mutable_virtual_machines_allowed();
  public:
  void unsafe_arena_set_allocated_virtual_machines_allowed(
      ::enterprise_management::VirtualMachinesAllowedProto* virtual_machines_allowed);
  ::enterprise_management::VirtualMachinesAllowedProto* unsafe_arena_release_virtual_machines_allowed();

  // optional .enterprise_management.DeviceMachinePasswordChangeRateProto device_machine_password_change_rate = 70;
  bool has_device_machine_password_change_rate() const;
  private:
  bool _internal_has_device_machine_password_change_rate() const;
  public:
  void clear_device_machine_password_change_rate();
  const ::enterprise_management::DeviceMachinePasswordChangeRateProto& device_machine_password_change_rate() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceMachinePasswordChangeRateProto* release_device_machine_password_change_rate();
  ::enterprise_management::DeviceMachinePasswordChangeRateProto* mutable_device_machine_password_change_rate();
  void set_allocated_device_machine_password_change_rate(::enterprise_management::DeviceMachinePasswordChangeRateProto* device_machine_password_change_rate);
  private:
  const ::enterprise_management::DeviceMachinePasswordChangeRateProto& _internal_device_machine_password_change_rate() const;
  ::enterprise_management::DeviceMachinePasswordChangeRateProto* _internal_mutable_device_machine_password_change_rate();
  public:
  void unsafe_arena_set_allocated_device_machine_password_change_rate(
      ::enterprise_management::DeviceMachinePasswordChangeRateProto* device_machine_password_change_rate);
  ::enterprise_management::DeviceMachinePasswordChangeRateProto* unsafe_arena_release_device_machine_password_change_rate();

  // optional .enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto device_unaffiliated_crostini_allowed = 72;
  bool has_device_unaffiliated_crostini_allowed() const;
  private:
  bool _internal_has_device_unaffiliated_crostini_allowed() const;
  public:
  void clear_device_unaffiliated_crostini_allowed();
  const ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto& device_unaffiliated_crostini_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* release_device_unaffiliated_crostini_allowed();
  ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* mutable_device_unaffiliated_crostini_allowed();
  void set_allocated_device_unaffiliated_crostini_allowed(::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* device_unaffiliated_crostini_allowed);
  private:
  const ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto& _internal_device_unaffiliated_crostini_allowed() const;
  ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* _internal_mutable_device_unaffiliated_crostini_allowed();
  public:
  void unsafe_arena_set_allocated_device_unaffiliated_crostini_allowed(
      ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* device_unaffiliated_crostini_allowed);
  ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* unsafe_arena_release_device_unaffiliated_crostini_allowed();

  // optional .enterprise_management.DeviceWiFiFastTransitionEnabledProto device_wifi_fast_transition_enabled = 73;
  bool has_device_wifi_fast_transition_enabled() const;
  private:
  bool _internal_has_device_wifi_fast_transition_enabled() const;
  public:
  void clear_device_wifi_fast_transition_enabled();
  const ::enterprise_management::DeviceWiFiFastTransitionEnabledProto& device_wifi_fast_transition_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* release_device_wifi_fast_transition_enabled();
  ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* mutable_device_wifi_fast_transition_enabled();
  void set_allocated_device_wifi_fast_transition_enabled(::enterprise_management::DeviceWiFiFastTransitionEnabledProto* device_wifi_fast_transition_enabled);
  private:
  const ::enterprise_management::DeviceWiFiFastTransitionEnabledProto& _internal_device_wifi_fast_transition_enabled() const;
  ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* _internal_mutable_device_wifi_fast_transition_enabled();
  public:
  void unsafe_arena_set_allocated_device_wifi_fast_transition_enabled(
      ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* device_wifi_fast_transition_enabled);
  ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* unsafe_arena_release_device_wifi_fast_transition_enabled();

  // optional .enterprise_management.DeviceDisplayResolutionProto device_display_resolution = 74;
  bool has_device_display_resolution() const;
  private:
  bool _internal_has_device_display_resolution() const;
  public:
  void clear_device_display_resolution();
  const ::enterprise_management::DeviceDisplayResolutionProto& device_display_resolution() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceDisplayResolutionProto* release_device_display_resolution();
  ::enterprise_management::DeviceDisplayResolutionProto* mutable_device_display_resolution();
  void set_allocated_device_display_resolution(::enterprise_management::DeviceDisplayResolutionProto* device_display_resolution);
  private:
  const ::enterprise_management::DeviceDisplayResolutionProto& _internal_device_display_resolution() const;
  ::enterprise_management::DeviceDisplayResolutionProto* _internal_mutable_device_display_resolution();
  public:
  void unsafe_arena_set_allocated_device_display_resolution(
      ::enterprise_management::DeviceDisplayResolutionProto* device_display_resolution);
  ::enterprise_management::DeviceDisplayResolutionProto* unsafe_arena_release_device_display_resolution();

  // optional .enterprise_management.PluginVmAllowedProto plugin_vm_allowed = 75;
  bool has_plugin_vm_allowed() const;
  private:
  bool _internal_has_plugin_vm_allowed() const;
  public:
  void clear_plugin_vm_allowed();
  const ::enterprise_management::PluginVmAllowedProto& plugin_vm_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::PluginVmAllowedProto* release_plugin_vm_allowed();
  ::enterprise_management::PluginVmAllowedProto* mutable_plugin_vm_allowed();
  void set_allocated_plugin_vm_allowed(::enterprise_management::PluginVmAllowedProto* plugin_vm_allowed);
  private:
  const ::enterprise_management::PluginVmAllowedProto& _internal_plugin_vm_allowed() const;
  ::enterprise_management::PluginVmAllowedProto* _internal_mutable_plugin_vm_allowed();
  public:
  void unsafe_arena_set_allocated_plugin_vm_allowed(
      ::enterprise_management::PluginVmAllowedProto* plugin_vm_allowed);
  ::enterprise_management::PluginVmAllowedProto* unsafe_arena_release_plugin_vm_allowed();

  // optional .enterprise_management.DeviceGpoCacheLifetimeProto device_gpo_cache_lifetime = 76;
  bool has_device_gpo_cache_lifetime() const;
  private:
  bool _internal_has_device_gpo_cache_lifetime() const;
  public:
  void clear_device_gpo_cache_lifetime();
  const ::enterprise_management::DeviceGpoCacheLifetimeProto& device_gpo_cache_lifetime() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceGpoCacheLifetimeProto* release_device_gpo_cache_lifetime();
  ::enterprise_management::DeviceGpoCacheLifetimeProto* mutable_device_gpo_cache_lifetime();
  void set_allocated_device_gpo_cache_lifetime(::enterprise_management::DeviceGpoCacheLifetimeProto* device_gpo_cache_lifetime);
  private:
  const ::enterprise_management::DeviceGpoCacheLifetimeProto& _internal_device_gpo_cache_lifetime() const;
  ::enterprise_management::DeviceGpoCacheLifetimeProto* _internal_mutable_device_gpo_cache_lifetime();
  public:
  void unsafe_arena_set_allocated_device_gpo_cache_lifetime(
      ::enterprise_management::DeviceGpoCacheLifetimeProto* device_gpo_cache_lifetime);
  ::enterprise_management::DeviceGpoCacheLifetimeProto* unsafe_arena_release_device_gpo_cache_lifetime();

  // optional .enterprise_management.DeviceAuthDataCacheLifetimeProto device_auth_data_cache_lifetime = 77;
  bool has_device_auth_data_cache_lifetime() const;
  private:
  bool _internal_has_device_auth_data_cache_lifetime() const;
  public:
  void clear_device_auth_data_cache_lifetime();
  const ::enterprise_management::DeviceAuthDataCacheLifetimeProto& device_auth_data_cache_lifetime() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAuthDataCacheLifetimeProto* release_device_auth_data_cache_lifetime();
  ::enterprise_management::DeviceAuthDataCacheLifetimeProto* mutable_device_auth_data_cache_lifetime();
  void set_allocated_device_auth_data_cache_lifetime(::enterprise_management::DeviceAuthDataCacheLifetimeProto* device_auth_data_cache_lifetime);
  private:
  const ::enterprise_management::DeviceAuthDataCacheLifetimeProto& _internal_device_auth_data_cache_lifetime() const;
  ::enterprise_management::DeviceAuthDataCacheLifetimeProto* _internal_mutable_device_auth_data_cache_lifetime();
  public:
  void unsafe_arena_set_allocated_device_auth_data_cache_lifetime(
      ::enterprise_management::DeviceAuthDataCacheLifetimeProto* device_auth_data_cache_lifetime);
  ::enterprise_management::DeviceAuthDataCacheLifetimeProto* unsafe_arena_release_device_auth_data_cache_lifetime();

  // optional .enterprise_management.PluginVmLicenseKeyProto plugin_vm_license_key = 78;
  bool has_plugin_vm_license_key() const;
  private:
  bool _internal_has_plugin_vm_license_key() const;
  public:
  void clear_plugin_vm_license_key();
  const ::enterprise_management::PluginVmLicenseKeyProto& plugin_vm_license_key() const;
  PROTOBUF_NODISCARD ::enterprise_management::PluginVmLicenseKeyProto* release_plugin_vm_license_key();
  ::enterprise_management::PluginVmLicenseKeyProto* mutable_plugin_vm_license_key();
  void set_allocated_plugin_vm_license_key(::enterprise_management::PluginVmLicenseKeyProto* plugin_vm_license_key);
  private:
  const ::enterprise_management::PluginVmLicenseKeyProto& _internal_plugin_vm_license_key() const;
  ::enterprise_management::PluginVmLicenseKeyProto* _internal_mutable_plugin_vm_license_key();
  public:
  void unsafe_arena_set_allocated_plugin_vm_license_key(
      ::enterprise_management::PluginVmLicenseKeyProto* plugin_vm_license_key);
  ::enterprise_management::PluginVmLicenseKeyProto* unsafe_arena_release_plugin_vm_license_key();

  // optional .enterprise_management.DeviceRebootOnUserSignoutProto device_reboot_on_user_signout = 79;
  bool has_device_reboot_on_user_signout() const;
  private:
  bool _internal_has_device_reboot_on_user_signout() const;
  public:
  void clear_device_reboot_on_user_signout();
  const ::enterprise_management::DeviceRebootOnUserSignoutProto& device_reboot_on_user_signout() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRebootOnUserSignoutProto* release_device_reboot_on_user_signout();
  ::enterprise_management::DeviceRebootOnUserSignoutProto* mutable_device_reboot_on_user_signout();
  void set_allocated_device_reboot_on_user_signout(::enterprise_management::DeviceRebootOnUserSignoutProto* device_reboot_on_user_signout);
  private:
  const ::enterprise_management::DeviceRebootOnUserSignoutProto& _internal_device_reboot_on_user_signout() const;
  ::enterprise_management::DeviceRebootOnUserSignoutProto* _internal_mutable_device_reboot_on_user_signout();
  public:
  void unsafe_arena_set_allocated_device_reboot_on_user_signout(
      ::enterprise_management::DeviceRebootOnUserSignoutProto* device_reboot_on_user_signout);
  ::enterprise_management::DeviceRebootOnUserSignoutProto* unsafe_arena_release_device_reboot_on_user_signout();

  // optional .enterprise_management.DeviceWilcoDtcAllowedProto device_wilco_dtc_allowed = 80;
  bool has_device_wilco_dtc_allowed() const;
  private:
  bool _internal_has_device_wilco_dtc_allowed() const;
  public:
  void clear_device_wilco_dtc_allowed();
  const ::enterprise_management::DeviceWilcoDtcAllowedProto& device_wilco_dtc_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceWilcoDtcAllowedProto* release_device_wilco_dtc_allowed();
  ::enterprise_management::DeviceWilcoDtcAllowedProto* mutable_device_wilco_dtc_allowed();
  void set_allocated_device_wilco_dtc_allowed(::enterprise_management::DeviceWilcoDtcAllowedProto* device_wilco_dtc_allowed);
  private:
  const ::enterprise_management::DeviceWilcoDtcAllowedProto& _internal_device_wilco_dtc_allowed() const;
  ::enterprise_management::DeviceWilcoDtcAllowedProto* _internal_mutable_device_wilco_dtc_allowed();
  public:
  void unsafe_arena_set_allocated_device_wilco_dtc_allowed(
      ::enterprise_management::DeviceWilcoDtcAllowedProto* device_wilco_dtc_allowed);
  ::enterprise_management::DeviceWilcoDtcAllowedProto* unsafe_arena_release_device_wilco_dtc_allowed();

  // optional .enterprise_management.DeviceWilcoDtcConfigurationProto device_wilco_dtc_configuration = 81;
  bool has_device_wilco_dtc_configuration() const;
  private:
  bool _internal_has_device_wilco_dtc_configuration() const;
  public:
  void clear_device_wilco_dtc_configuration();
  const ::enterprise_management::DeviceWilcoDtcConfigurationProto& device_wilco_dtc_configuration() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceWilcoDtcConfigurationProto* release_device_wilco_dtc_configuration();
  ::enterprise_management::DeviceWilcoDtcConfigurationProto* mutable_device_wilco_dtc_configuration();
  void set_allocated_device_wilco_dtc_configuration(::enterprise_management::DeviceWilcoDtcConfigurationProto* device_wilco_dtc_configuration);
  private:
  const ::enterprise_management::DeviceWilcoDtcConfigurationProto& _internal_device_wilco_dtc_configuration() const;
  ::enterprise_management::DeviceWilcoDtcConfigurationProto* _internal_mutable_device_wilco_dtc_configuration();
  public:
  void unsafe_arena_set_allocated_device_wilco_dtc_configuration(
      ::enterprise_management::DeviceWilcoDtcConfigurationProto* device_wilco_dtc_configuration);
  ::enterprise_management::DeviceWilcoDtcConfigurationProto* unsafe_arena_release_device_wilco_dtc_configuration();

  // optional .enterprise_management.DeviceWiFiAllowedProto device_wifi_allowed = 82;
  bool has_device_wifi_allowed() const;
  private:
  bool _internal_has_device_wifi_allowed() const;
  public:
  void clear_device_wifi_allowed();
  const ::enterprise_management::DeviceWiFiAllowedProto& device_wifi_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceWiFiAllowedProto* release_device_wifi_allowed();
  ::enterprise_management::DeviceWiFiAllowedProto* mutable_device_wifi_allowed();
  void set_allocated_device_wifi_allowed(::enterprise_management::DeviceWiFiAllowedProto* device_wifi_allowed);
  private:
  const ::enterprise_management::DeviceWiFiAllowedProto& _internal_device_wifi_allowed() const;
  ::enterprise_management::DeviceWiFiAllowedProto* _internal_mutable_device_wifi_allowed();
  public:
  void unsafe_arena_set_allocated_device_wifi_allowed(
      ::enterprise_management::DeviceWiFiAllowedProto* device_wifi_allowed);
  ::enterprise_management::DeviceWiFiAllowedProto* unsafe_arena_release_device_wifi_allowed();

  // optional .enterprise_management.DevicePowerPeakShiftProto device_power_peak_shift = 83;
  bool has_device_power_peak_shift() const;
  private:
  bool _internal_has_device_power_peak_shift() const;
  public:
  void clear_device_power_peak_shift();
  const ::enterprise_management::DevicePowerPeakShiftProto& device_power_peak_shift() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePowerPeakShiftProto* release_device_power_peak_shift();
  ::enterprise_management::DevicePowerPeakShiftProto* mutable_device_power_peak_shift();
  void set_allocated_device_power_peak_shift(::enterprise_management::DevicePowerPeakShiftProto* device_power_peak_shift);
  private:
  const ::enterprise_management::DevicePowerPeakShiftProto& _internal_device_power_peak_shift() const;
  ::enterprise_management::DevicePowerPeakShiftProto* _internal_mutable_device_power_peak_shift();
  public:
  void unsafe_arena_set_allocated_device_power_peak_shift(
      ::enterprise_management::DevicePowerPeakShiftProto* device_power_peak_shift);
  ::enterprise_management::DevicePowerPeakShiftProto* unsafe_arena_release_device_power_peak_shift();

  // optional .enterprise_management.DeviceBootOnAcProto device_boot_on_ac = 84;
  bool has_device_boot_on_ac() const;
  private:
  bool _internal_has_device_boot_on_ac() const;
  public:
  void clear_device_boot_on_ac();
  const ::enterprise_management::DeviceBootOnAcProto& device_boot_on_ac() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceBootOnAcProto* release_device_boot_on_ac();
  ::enterprise_management::DeviceBootOnAcProto* mutable_device_boot_on_ac();
  void set_allocated_device_boot_on_ac(::enterprise_management::DeviceBootOnAcProto* device_boot_on_ac);
  private:
  const ::enterprise_management::DeviceBootOnAcProto& _internal_device_boot_on_ac() const;
  ::enterprise_management::DeviceBootOnAcProto* _internal_mutable_device_boot_on_ac();
  public:
  void unsafe_arena_set_allocated_device_boot_on_ac(
      ::enterprise_management::DeviceBootOnAcProto* device_boot_on_ac);
  ::enterprise_management::DeviceBootOnAcProto* unsafe_arena_release_device_boot_on_ac();

  // optional .enterprise_management.DeviceDockMacAddressSourceProto device_dock_mac_address_source = 85;
  bool has_device_dock_mac_address_source() const;
  private:
  bool _internal_has_device_dock_mac_address_source() const;
  public:
  void clear_device_dock_mac_address_source();
  const ::enterprise_management::DeviceDockMacAddressSourceProto& device_dock_mac_address_source() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceDockMacAddressSourceProto* release_device_dock_mac_address_source();
  ::enterprise_management::DeviceDockMacAddressSourceProto* mutable_device_dock_mac_address_source();
  void set_allocated_device_dock_mac_address_source(::enterprise_management::DeviceDockMacAddressSourceProto* device_dock_mac_address_source);
  private:
  const ::enterprise_management::DeviceDockMacAddressSourceProto& _internal_device_dock_mac_address_source() const;
  ::enterprise_management::DeviceDockMacAddressSourceProto* _internal_mutable_device_dock_mac_address_source();
  public:
  void unsafe_arena_set_allocated_device_dock_mac_address_source(
      ::enterprise_management::DeviceDockMacAddressSourceProto* device_dock_mac_address_source);
  ::enterprise_management::DeviceDockMacAddressSourceProto* unsafe_arena_release_device_dock_mac_address_source();

  // optional .enterprise_management.DeviceAdvancedBatteryChargeModeProto device_advanced_battery_charge_mode = 86;
  bool has_device_advanced_battery_charge_mode() const;
  private:
  bool _internal_has_device_advanced_battery_charge_mode() const;
  public:
  void clear_device_advanced_battery_charge_mode();
  const ::enterprise_management::DeviceAdvancedBatteryChargeModeProto& device_advanced_battery_charge_mode() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* release_device_advanced_battery_charge_mode();
  ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* mutable_device_advanced_battery_charge_mode();
  void set_allocated_device_advanced_battery_charge_mode(::enterprise_management::DeviceAdvancedBatteryChargeModeProto* device_advanced_battery_charge_mode);
  private:
  const ::enterprise_management::DeviceAdvancedBatteryChargeModeProto& _internal_device_advanced_battery_charge_mode() const;
  ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* _internal_mutable_device_advanced_battery_charge_mode();
  public:
  void unsafe_arena_set_allocated_device_advanced_battery_charge_mode(
      ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* device_advanced_battery_charge_mode);
  ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* unsafe_arena_release_device_advanced_battery_charge_mode();

  // optional .enterprise_management.DeviceBatteryChargeModeProto device_battery_charge_mode = 87;
  bool has_device_battery_charge_mode() const;
  private:
  bool _internal_has_device_battery_charge_mode() const;
  public:
  void clear_device_battery_charge_mode();
  const ::enterprise_management::DeviceBatteryChargeModeProto& device_battery_charge_mode() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceBatteryChargeModeProto* release_device_battery_charge_mode();
  ::enterprise_management::DeviceBatteryChargeModeProto* mutable_device_battery_charge_mode();
  void set_allocated_device_battery_charge_mode(::enterprise_management::DeviceBatteryChargeModeProto* device_battery_charge_mode);
  private:
  const ::enterprise_management::DeviceBatteryChargeModeProto& _internal_device_battery_charge_mode() const;
  ::enterprise_management::DeviceBatteryChargeModeProto* _internal_mutable_device_battery_charge_mode();
  public:
  void unsafe_arena_set_allocated_device_battery_charge_mode(
      ::enterprise_management::DeviceBatteryChargeModeProto* device_battery_charge_mode);
  ::enterprise_management::DeviceBatteryChargeModeProto* unsafe_arena_release_device_battery_charge_mode();

  // optional .enterprise_management.DeviceUsbPowerShareProto device_usb_power_share = 88;
  bool has_device_usb_power_share() const;
  private:
  bool _internal_has_device_usb_power_share() const;
  public:
  void clear_device_usb_power_share();
  const ::enterprise_management::DeviceUsbPowerShareProto& device_usb_power_share() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceUsbPowerShareProto* release_device_usb_power_share();
  ::enterprise_management::DeviceUsbPowerShareProto* mutable_device_usb_power_share();
  void set_allocated_device_usb_power_share(::enterprise_management::DeviceUsbPowerShareProto* device_usb_power_share);
  private:
  const ::enterprise_management::DeviceUsbPowerShareProto& _internal_device_usb_power_share() const;
  ::enterprise_management::DeviceUsbPowerShareProto* _internal_mutable_device_usb_power_share();
  public:
  void unsafe_arena_set_allocated_device_usb_power_share(
      ::enterprise_management::DeviceUsbPowerShareProto* device_usb_power_share);
  ::enterprise_management::DeviceUsbPowerShareProto* unsafe_arena_release_device_usb_power_share();

  // optional .enterprise_management.DeviceScheduledUpdateCheckProto device_scheduled_update_check = 89;
  bool has_device_scheduled_update_check() const;
  private:
  bool _internal_has_device_scheduled_update_check() const;
  public:
  void clear_device_scheduled_update_check();
  const ::enterprise_management::DeviceScheduledUpdateCheckProto& device_scheduled_update_check() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceScheduledUpdateCheckProto* release_device_scheduled_update_check();
  ::enterprise_management::DeviceScheduledUpdateCheckProto* mutable_device_scheduled_update_check();
  void set_allocated_device_scheduled_update_check(::enterprise_management::DeviceScheduledUpdateCheckProto* device_scheduled_update_check);
  private:
  const ::enterprise_management::DeviceScheduledUpdateCheckProto& _internal_device_scheduled_update_check() const;
  ::enterprise_management::DeviceScheduledUpdateCheckProto* _internal_mutable_device_scheduled_update_check();
  public:
  void unsafe_arena_set_allocated_device_scheduled_update_check(
      ::enterprise_management::DeviceScheduledUpdateCheckProto* device_scheduled_update_check);
  ::enterprise_management::DeviceScheduledUpdateCheckProto* unsafe_arena_release_device_scheduled_update_check();

  // optional .enterprise_management.DevicePowerwashAllowedProto device_powerwash_allowed = 91;
  bool has_device_powerwash_allowed() const;
  private:
  bool _internal_has_device_powerwash_allowed() const;
  public:
  void clear_device_powerwash_allowed();
  const ::enterprise_management::DevicePowerwashAllowedProto& device_powerwash_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePowerwashAllowedProto* release_device_powerwash_allowed();
  ::enterprise_management::DevicePowerwashAllowedProto* mutable_device_powerwash_allowed();
  void set_allocated_device_powerwash_allowed(::enterprise_management::DevicePowerwashAllowedProto* device_powerwash_allowed);
  private:
  const ::enterprise_management::DevicePowerwashAllowedProto& _internal_device_powerwash_allowed() const;
  ::enterprise_management::DevicePowerwashAllowedProto* _internal_mutable_device_powerwash_allowed();
  public:
  void unsafe_arena_set_allocated_device_powerwash_allowed(
      ::enterprise_management::DevicePowerwashAllowedProto* device_powerwash_allowed);
  ::enterprise_management::DevicePowerwashAllowedProto* unsafe_arena_release_device_powerwash_allowed();

  // optional .enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto device_login_screen_webusb_allow_devices_for_urls = 92;
  bool has_device_login_screen_webusb_allow_devices_for_urls() const;
  private:
  bool _internal_has_device_login_screen_webusb_allow_devices_for_urls() const;
  public:
  void clear_device_login_screen_webusb_allow_devices_for_urls();
  const ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& device_login_screen_webusb_allow_devices_for_urls() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* release_device_login_screen_webusb_allow_devices_for_urls();
  ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* mutable_device_login_screen_webusb_allow_devices_for_urls();
  void set_allocated_device_login_screen_webusb_allow_devices_for_urls(::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* device_login_screen_webusb_allow_devices_for_urls);
  private:
  const ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& _internal_device_login_screen_webusb_allow_devices_for_urls() const;
  ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* _internal_mutable_device_login_screen_webusb_allow_devices_for_urls();
  public:
  void unsafe_arena_set_allocated_device_login_screen_webusb_allow_devices_for_urls(
      ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* device_login_screen_webusb_allow_devices_for_urls);
  ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* unsafe_arena_release_device_login_screen_webusb_allow_devices_for_urls();

  // optional .enterprise_management.BooleanPolicyProto device_login_screen_system_info_enforced = 93;
  bool has_device_login_screen_system_info_enforced() const;
  private:
  bool _internal_has_device_login_screen_system_info_enforced() const;
  public:
  void clear_device_login_screen_system_info_enforced();
  const ::enterprise_management::BooleanPolicyProto& device_login_screen_system_info_enforced() const;
  PROTOBUF_NODISCARD ::enterprise_management::BooleanPolicyProto* release_device_login_screen_system_info_enforced();
  ::enterprise_management::BooleanPolicyProto* mutable_device_login_screen_system_info_enforced();
  void set_allocated_device_login_screen_system_info_enforced(::enterprise_management::BooleanPolicyProto* device_login_screen_system_info_enforced);
  private:
  const ::enterprise_management::BooleanPolicyProto& _internal_device_login_screen_system_info_enforced() const;
  ::enterprise_management::BooleanPolicyProto* _internal_mutable_device_login_screen_system_info_enforced();
  public:
  void unsafe_arena_set_allocated_device_login_screen_system_info_enforced(
      ::enterprise_management::BooleanPolicyProto* device_login_screen_system_info_enforced);
  ::enterprise_management::BooleanPolicyProto* unsafe_arena_release_device_login_screen_system_info_enforced();

  // optional .enterprise_management.StringListPolicyProto device_web_based_attestation_allowed_urls = 94;
  bool has_device_web_based_attestation_allowed_urls() const;
  private:
  bool _internal_has_device_web_based_attestation_allowed_urls() const;
  public:
  void clear_device_web_based_attestation_allowed_urls();
  const ::enterprise_management::StringListPolicyProto& device_web_based_attestation_allowed_urls() const;
  PROTOBUF_NODISCARD ::enterprise_management::StringListPolicyProto* release_device_web_based_attestation_allowed_urls();
  ::enterprise_management::StringListPolicyProto* mutable_device_web_based_attestation_allowed_urls();
  void set_allocated_device_web_based_attestation_allowed_urls(::enterprise_management::StringListPolicyProto* device_web_based_attestation_allowed_urls);
  private:
  const ::enterprise_management::StringListPolicyProto& _internal_device_web_based_attestation_allowed_urls() const;
  ::enterprise_management::StringListPolicyProto* _internal_mutable_device_web_based_attestation_allowed_urls();
  public:
  void unsafe_arena_set_allocated_device_web_based_attestation_allowed_urls(
      ::enterprise_management::StringListPolicyProto* device_web_based_attestation_allowed_urls);
  ::enterprise_management::StringListPolicyProto* unsafe_arena_release_device_web_based_attestation_allowed_urls();

  // optional .enterprise_management.BooleanPolicyProto device_show_numeric_keyboard_for_password = 95;
  bool has_device_show_numeric_keyboard_for_password() const;
  private:
  bool _internal_has_device_show_numeric_keyboard_for_password() const;
  public:
  void clear_device_show_numeric_keyboard_for_password();
  const ::enterprise_management::BooleanPolicyProto& device_show_numeric_keyboard_for_password() const;
  PROTOBUF_NODISCARD ::enterprise_management::BooleanPolicyProto* release_device_show_numeric_keyboard_for_password();
  ::enterprise_management::BooleanPolicyProto* mutable_device_show_numeric_keyboard_for_password();
  void set_allocated_device_show_numeric_keyboard_for_password(::enterprise_management::BooleanPolicyProto* device_show_numeric_keyboard_for_password);
  private:
  const ::enterprise_management::BooleanPolicyProto& _internal_device_show_numeric_keyboard_for_password() const;
  ::enterprise_management::BooleanPolicyProto* _internal_mutable_device_show_numeric_keyboard_for_password();
  public:
  void unsafe_arena_set_allocated_device_show_numeric_keyboard_for_password(
      ::enterprise_management::BooleanPolicyProto* device_show_numeric_keyboard_for_password);
  ::enterprise_management::BooleanPolicyProto* unsafe_arena_release_device_show_numeric_keyboard_for_password();

  // optional .enterprise_management.BooleanPolicyProto login_screen_primary_mouse_button_switch = 96;
  bool has_login_screen_primary_mouse_button_switch() const;
  private:
  bool _internal_has_login_screen_primary_mouse_button_switch() const;
  public:
  void clear_login_screen_primary_mouse_button_switch();
  const ::enterprise_management::BooleanPolicyProto& login_screen_primary_mouse_button_switch() const;
  PROTOBUF_NODISCARD ::enterprise_management::BooleanPolicyProto* release_login_screen_primary_mouse_button_switch();
  ::enterprise_management::BooleanPolicyProto* mutable_login_screen_primary_mouse_button_switch();
  void set_allocated_login_screen_primary_mouse_button_switch(::enterprise_management::BooleanPolicyProto* login_screen_primary_mouse_button_switch);
  private:
  const ::enterprise_management::BooleanPolicyProto& _internal_login_screen_primary_mouse_button_switch() const;
  ::enterprise_management::BooleanPolicyProto* _internal_mutable_login_screen_primary_mouse_button_switch();
  public:
  void unsafe_arena_set_allocated_login_screen_primary_mouse_button_switch(
      ::enterprise_management::BooleanPolicyProto* login_screen_primary_mouse_button_switch);
  ::enterprise_management::BooleanPolicyProto* unsafe_arena_release_login_screen_primary_mouse_button_switch();

  // optional .enterprise_management.StringPolicyProto device_minimum_version = 97;
  bool has_device_minimum_version() const;
  private:
  bool _internal_has_device_minimum_version() const;
  public:
  void clear_device_minimum_version();
  const ::enterprise_management::StringPolicyProto& device_minimum_version() const;
  PROTOBUF_NODISCARD ::enterprise_management::StringPolicyProto* release_device_minimum_version();
  ::enterprise_management::StringPolicyProto* mutable_device_minimum_version();
  void set_allocated_device_minimum_version(::enterprise_management::StringPolicyProto* device_minimum_version);
  private:
  const ::enterprise_management::StringPolicyProto& _internal_device_minimum_version() const;
  ::enterprise_management::StringPolicyProto* _internal_mutable_device_minimum_version();
  public:
  void unsafe_arena_set_allocated_device_minimum_version(
      ::enterprise_management::StringPolicyProto* device_minimum_version);
  ::enterprise_management::StringPolicyProto* unsafe_arena_release_device_minimum_version();

  // optional .enterprise_management.SystemProxySettingsProto system_proxy_settings = 98;
  bool has_system_proxy_settings() const;
  private:
  bool _internal_has_system_proxy_settings() const;
  public:
  void clear_system_proxy_settings();
  const ::enterprise_management::SystemProxySettingsProto& system_proxy_settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::SystemProxySettingsProto* release_system_proxy_settings();
  ::enterprise_management::SystemProxySettingsProto* mutable_system_proxy_settings();
  void set_allocated_system_proxy_settings(::enterprise_management::SystemProxySettingsProto* system_proxy_settings);
  private:
  const ::enterprise_management::SystemProxySettingsProto& _internal_system_proxy_settings() const;
  ::enterprise_management::SystemProxySettingsProto* _internal_mutable_system_proxy_settings();
  public:
  void unsafe_arena_set_allocated_system_proxy_settings(
      ::enterprise_management::SystemProxySettingsProto* system_proxy_settings);
  ::enterprise_management::SystemProxySettingsProto* unsafe_arena_release_system_proxy_settings();

  // optional .enterprise_management.IntegerPolicyProto device_chrome_variations_type = 99;
  bool has_device_chrome_variations_type() const;
  private:
  bool _internal_has_device_chrome_variations_type() const;
  public:
  void clear_device_chrome_variations_type();
  const ::enterprise_management::IntegerPolicyProto& device_chrome_variations_type() const;
  PROTOBUF_NODISCARD ::enterprise_management::IntegerPolicyProto* release_device_chrome_variations_type();
  ::enterprise_management::IntegerPolicyProto* mutable_device_chrome_variations_type();
  void set_allocated_device_chrome_variations_type(::enterprise_management::IntegerPolicyProto* device_chrome_variations_type);
  private:
  const ::enterprise_management::IntegerPolicyProto& _internal_device_chrome_variations_type() const;
  ::enterprise_management::IntegerPolicyProto* _internal_mutable_device_chrome_variations_type();
  public:
  void unsafe_arena_set_allocated_device_chrome_variations_type(
      ::enterprise_management::IntegerPolicyProto* device_chrome_variations_type);
  ::enterprise_management::IntegerPolicyProto* unsafe_arena_release_device_chrome_variations_type();

  // optional .enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto device_login_screen_privacy_screen_enabled = 100;
  bool has_device_login_screen_privacy_screen_enabled() const;
  private:
  bool _internal_has_device_login_screen_privacy_screen_enabled() const;
  public:
  void clear_device_login_screen_privacy_screen_enabled();
  const ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto& device_login_screen_privacy_screen_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* release_device_login_screen_privacy_screen_enabled();
  ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* mutable_device_login_screen_privacy_screen_enabled();
  void set_allocated_device_login_screen_privacy_screen_enabled(::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* device_login_screen_privacy_screen_enabled);
  private:
  const ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto& _internal_device_login_screen_privacy_screen_enabled() const;
  ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* _internal_mutable_device_login_screen_privacy_screen_enabled();
  public:
  void unsafe_arena_set_allocated_device_login_screen_privacy_screen_enabled(
      ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* device_login_screen_privacy_screen_enabled);
  ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* unsafe_arena_release_device_login_screen_privacy_screen_enabled();

  // optional .enterprise_management.RequiredClientCertificateForDeviceProto required_client_certificate_for_device = 101;
  bool has_required_client_certificate_for_device() const;
  private:
  bool _internal_has_required_client_certificate_for_device() const;
  public:
  void clear_required_client_certificate_for_device();
  const ::enterprise_management::RequiredClientCertificateForDeviceProto& required_client_certificate_for_device() const;
  PROTOBUF_NODISCARD ::enterprise_management::RequiredClientCertificateForDeviceProto* release_required_client_certificate_for_device();
  ::enterprise_management::RequiredClientCertificateForDeviceProto* mutable_required_client_certificate_for_device();
  void set_allocated_required_client_certificate_for_device(::enterprise_management::RequiredClientCertificateForDeviceProto* required_client_certificate_for_device);
  private:
  const ::enterprise_management::RequiredClientCertificateForDeviceProto& _internal_required_client_certificate_for_device() const;
  ::enterprise_management::RequiredClientCertificateForDeviceProto* _internal_mutable_required_client_certificate_for_device();
  public:
  void unsafe_arena_set_allocated_required_client_certificate_for_device(
      ::enterprise_management::RequiredClientCertificateForDeviceProto* required_client_certificate_for_device);
  ::enterprise_management::RequiredClientCertificateForDeviceProto* unsafe_arena_release_required_client_certificate_for_device();

  // optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto device_crostini_arc_adb_sideloading_allowed = 102;
  bool has_device_crostini_arc_adb_sideloading_allowed() const;
  private:
  bool _internal_has_device_crostini_arc_adb_sideloading_allowed() const;
  public:
  void clear_device_crostini_arc_adb_sideloading_allowed();
  const ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto& device_crostini_arc_adb_sideloading_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* release_device_crostini_arc_adb_sideloading_allowed();
  ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* mutable_device_crostini_arc_adb_sideloading_allowed();
  void set_allocated_device_crostini_arc_adb_sideloading_allowed(::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* device_crostini_arc_adb_sideloading_allowed);
  private:
  const ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto& _internal_device_crostini_arc_adb_sideloading_allowed() const;
  ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* _internal_mutable_device_crostini_arc_adb_sideloading_allowed();
  public:
  void unsafe_arena_set_allocated_device_crostini_arc_adb_sideloading_allowed(
      ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* device_crostini_arc_adb_sideloading_allowed);
  ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* unsafe_arena_release_device_crostini_arc_adb_sideloading_allowed();

  // optional .enterprise_management.StringPolicyProto device_minimum_version_aue_message = 103;
  bool has_device_minimum_version_aue_message() const;
  private:
  bool _internal_has_device_minimum_version_aue_message() const;
  public:
  void clear_device_minimum_version_aue_message();
  const ::enterprise_management::StringPolicyProto& device_minimum_version_aue_message() const;
  PROTOBUF_NODISCARD ::enterprise_management::StringPolicyProto* release_device_minimum_version_aue_message();
  ::enterprise_management::StringPolicyProto* mutable_device_minimum_version_aue_message();
  void set_allocated_device_minimum_version_aue_message(::enterprise_management::StringPolicyProto* device_minimum_version_aue_message);
  private:
  const ::enterprise_management::StringPolicyProto& _internal_device_minimum_version_aue_message() const;
  ::enterprise_management::StringPolicyProto* _internal_mutable_device_minimum_version_aue_message();
  public:
  void unsafe_arena_set_allocated_device_minimum_version_aue_message(
      ::enterprise_management::StringPolicyProto* device_minimum_version_aue_message);
  ::enterprise_management::StringPolicyProto* unsafe_arena_release_device_minimum_version_aue_message();

  // optional .enterprise_management.ManagedGuestSessionPrivacyWarningsProto managed_guest_session_privacy_warnings = 104;
  bool has_managed_guest_session_privacy_warnings() const;
  private:
  bool _internal_has_managed_guest_session_privacy_warnings() const;
  public:
  void clear_managed_guest_session_privacy_warnings();
  const ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto& managed_guest_session_privacy_warnings() const;
  PROTOBUF_NODISCARD ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* release_managed_guest_session_privacy_warnings();
  ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* mutable_managed_guest_session_privacy_warnings();
  void set_allocated_managed_guest_session_privacy_warnings(::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* managed_guest_session_privacy_warnings);
  private:
  const ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto& _internal_managed_guest_session_privacy_warnings() const;
  ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* _internal_mutable_managed_guest_session_privacy_warnings();
  public:
  void unsafe_arena_set_allocated_managed_guest_session_privacy_warnings(
      ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* managed_guest_session_privacy_warnings);
  ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* unsafe_arena_release_managed_guest_session_privacy_warnings();

  // optional .enterprise_management.DeviceExternalPrintServersProto external_print_servers = 105;
  bool has_external_print_servers() const;
  private:
  bool _internal_has_external_print_servers() const;
  public:
  void clear_external_print_servers();
  const ::enterprise_management::DeviceExternalPrintServersProto& external_print_servers() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceExternalPrintServersProto* release_external_print_servers();
  ::enterprise_management::DeviceExternalPrintServersProto* mutable_external_print_servers();
  void set_allocated_external_print_servers(::enterprise_management::DeviceExternalPrintServersProto* external_print_servers);
  private:
  const ::enterprise_management::DeviceExternalPrintServersProto& _internal_external_print_servers() const;
  ::enterprise_management::DeviceExternalPrintServersProto* _internal_mutable_external_print_servers();
  public:
  void unsafe_arena_set_allocated_external_print_servers(
      ::enterprise_management::DeviceExternalPrintServersProto* external_print_servers);
  ::enterprise_management::DeviceExternalPrintServersProto* unsafe_arena_release_external_print_servers();

  // optional .enterprise_management.DeviceExternalPrintServersAllowlistProto external_print_servers_allowlist = 106;
  bool has_external_print_servers_allowlist() const;
  private:
  bool _internal_has_external_print_servers_allowlist() const;
  public:
  void clear_external_print_servers_allowlist();
  const ::enterprise_management::DeviceExternalPrintServersAllowlistProto& external_print_servers_allowlist() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceExternalPrintServersAllowlistProto* release_external_print_servers_allowlist();
  ::enterprise_management::DeviceExternalPrintServersAllowlistProto* mutable_external_print_servers_allowlist();
  void set_allocated_external_print_servers_allowlist(::enterprise_management::DeviceExternalPrintServersAllowlistProto* external_print_servers_allowlist);
  private:
  const ::enterprise_management::DeviceExternalPrintServersAllowlistProto& _internal_external_print_servers_allowlist() const;
  ::enterprise_management::DeviceExternalPrintServersAllowlistProto* _internal_mutable_external_print_servers_allowlist();
  public:
  void unsafe_arena_set_allocated_external_print_servers_allowlist(
      ::enterprise_management::DeviceExternalPrintServersAllowlistProto* external_print_servers_allowlist);
  ::enterprise_management::DeviceExternalPrintServersAllowlistProto* unsafe_arena_release_external_print_servers_allowlist();

  // optional .enterprise_management.DevicePrintersAccessModeProto device_printers_access_mode = 107;
  bool has_device_printers_access_mode() const;
  private:
  bool _internal_has_device_printers_access_mode() const;
  public:
  void clear_device_printers_access_mode();
  const ::enterprise_management::DevicePrintersAccessModeProto& device_printers_access_mode() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePrintersAccessModeProto* release_device_printers_access_mode();
  ::enterprise_management::DevicePrintersAccessModeProto* mutable_device_printers_access_mode();
  void set_allocated_device_printers_access_mode(::enterprise_management::DevicePrintersAccessModeProto* device_printers_access_mode);
  private:
  const ::enterprise_management::DevicePrintersAccessModeProto& _internal_device_printers_access_mode() const;
  ::enterprise_management::DevicePrintersAccessModeProto* _internal_mutable_device_printers_access_mode();
  public:
  void unsafe_arena_set_allocated_device_printers_access_mode(
      ::enterprise_management::DevicePrintersAccessModeProto* device_printers_access_mode);
  ::enterprise_management::DevicePrintersAccessModeProto* unsafe_arena_release_device_printers_access_mode();

  // optional .enterprise_management.DevicePrintersBlocklistProto device_printers_blocklist = 108;
  bool has_device_printers_blocklist() const;
  private:
  bool _internal_has_device_printers_blocklist() const;
  public:
  void clear_device_printers_blocklist();
  const ::enterprise_management::DevicePrintersBlocklistProto& device_printers_blocklist() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePrintersBlocklistProto* release_device_printers_blocklist();
  ::enterprise_management::DevicePrintersBlocklistProto* mutable_device_printers_blocklist();
  void set_allocated_device_printers_blocklist(::enterprise_management::DevicePrintersBlocklistProto* device_printers_blocklist);
  private:
  const ::enterprise_management::DevicePrintersBlocklistProto& _internal_device_printers_blocklist() const;
  ::enterprise_management::DevicePrintersBlocklistProto* _internal_mutable_device_printers_blocklist();
  public:
  void unsafe_arena_set_allocated_device_printers_blocklist(
      ::enterprise_management::DevicePrintersBlocklistProto* device_printers_blocklist);
  ::enterprise_management::DevicePrintersBlocklistProto* unsafe_arena_release_device_printers_blocklist();

  // optional .enterprise_management.DevicePrintersAllowlistProto device_printers_allowlist = 109;
  bool has_device_printers_allowlist() const;
  private:
  bool _internal_has_device_printers_allowlist() const;
  public:
  void clear_device_printers_allowlist();
  const ::enterprise_management::DevicePrintersAllowlistProto& device_printers_allowlist() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePrintersAllowlistProto* release_device_printers_allowlist();
  ::enterprise_management::DevicePrintersAllowlistProto* mutable_device_printers_allowlist();
  void set_allocated_device_printers_allowlist(::enterprise_management::DevicePrintersAllowlistProto* device_printers_allowlist);
  private:
  const ::enterprise_management::DevicePrintersAllowlistProto& _internal_device_printers_allowlist() const;
  ::enterprise_management::DevicePrintersAllowlistProto* _internal_mutable_device_printers_allowlist();
  public:
  void unsafe_arena_set_allocated_device_printers_allowlist(
      ::enterprise_management::DevicePrintersAllowlistProto* device_printers_allowlist);
  ::enterprise_management::DevicePrintersAllowlistProto* unsafe_arena_release_device_printers_allowlist();

  // optional .enterprise_management.DevicePrintersProto device_printers = 110;
  bool has_device_printers() const;
  private:
  bool _internal_has_device_printers() const;
  public:
  void clear_device_printers();
  const ::enterprise_management::DevicePrintersProto& device_printers() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePrintersProto* release_device_printers();
  ::enterprise_management::DevicePrintersProto* mutable_device_printers();
  void set_allocated_device_printers(::enterprise_management::DevicePrintersProto* device_printers);
  private:
  const ::enterprise_management::DevicePrintersProto& _internal_device_printers() const;
  ::enterprise_management::DevicePrintersProto* _internal_mutable_device_printers();
  public:
  void unsafe_arena_set_allocated_device_printers(
      ::enterprise_management::DevicePrintersProto* device_printers);
  ::enterprise_management::DevicePrintersProto* unsafe_arena_release_device_printers();

  // optional .enterprise_management.DeviceShowLowDiskSpaceNotificationProto device_show_low_disk_space_notification = 111;
  bool has_device_show_low_disk_space_notification() const;
  private:
  bool _internal_has_device_show_low_disk_space_notification() const;
  public:
  void clear_device_show_low_disk_space_notification();
  const ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto& device_show_low_disk_space_notification() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* release_device_show_low_disk_space_notification();
  ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* mutable_device_show_low_disk_space_notification();
  void set_allocated_device_show_low_disk_space_notification(::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* device_show_low_disk_space_notification);
  private:
  const ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto& _internal_device_show_low_disk_space_notification() const;
  ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* _internal_mutable_device_show_low_disk_space_notification();
  public:
  void unsafe_arena_set_allocated_device_show_low_disk_space_notification(
      ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* device_show_low_disk_space_notification);
  ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* unsafe_arena_release_device_show_low_disk_space_notification();

  // optional .enterprise_management.UserAllowlistProto user_allowlist = 112;
  bool has_user_allowlist() const;
  private:
  bool _internal_has_user_allowlist() const;
  public:
  void clear_user_allowlist();
  const ::enterprise_management::UserAllowlistProto& user_allowlist() const;
  PROTOBUF_NODISCARD ::enterprise_management::UserAllowlistProto* release_user_allowlist();
  ::enterprise_management::UserAllowlistProto* mutable_user_allowlist();
  void set_allocated_user_allowlist(::enterprise_management::UserAllowlistProto* user_allowlist);
  private:
  const ::enterprise_management::UserAllowlistProto& _internal_user_allowlist() const;
  ::enterprise_management::UserAllowlistProto* _internal_mutable_user_allowlist();
  public:
  void unsafe_arena_set_allocated_user_allowlist(
      ::enterprise_management::UserAllowlistProto* user_allowlist);
  ::enterprise_management::UserAllowlistProto* unsafe_arena_release_user_allowlist();

  // optional .enterprise_management.UsbDetachableAllowlistProto usb_detachable_allowlist = 113;
  bool has_usb_detachable_allowlist() const;
  private:
  bool _internal_has_usb_detachable_allowlist() const;
  public:
  void clear_usb_detachable_allowlist();
  const ::enterprise_management::UsbDetachableAllowlistProto& usb_detachable_allowlist() const;
  PROTOBUF_NODISCARD ::enterprise_management::UsbDetachableAllowlistProto* release_usb_detachable_allowlist();
  ::enterprise_management::UsbDetachableAllowlistProto* mutable_usb_detachable_allowlist();
  void set_allocated_usb_detachable_allowlist(::enterprise_management::UsbDetachableAllowlistProto* usb_detachable_allowlist);
  private:
  const ::enterprise_management::UsbDetachableAllowlistProto& _internal_usb_detachable_allowlist() const;
  ::enterprise_management::UsbDetachableAllowlistProto* _internal_mutable_usb_detachable_allowlist();
  public:
  void unsafe_arena_set_allocated_usb_detachable_allowlist(
      ::enterprise_management::UsbDetachableAllowlistProto* usb_detachable_allowlist);
  ::enterprise_management::UsbDetachableAllowlistProto* unsafe_arena_release_usb_detachable_allowlist();

  // optional .enterprise_management.DeviceFamilyLinkAccountsAllowedProto family_link_accounts_allowed = 114;
  bool has_family_link_accounts_allowed() const;
  private:
  bool _internal_has_family_link_accounts_allowed() const;
  public:
  void clear_family_link_accounts_allowed();
  const ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto& family_link_accounts_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* release_family_link_accounts_allowed();
  ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* mutable_family_link_accounts_allowed();
  void set_allocated_family_link_accounts_allowed(::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* family_link_accounts_allowed);
  private:
  const ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto& _internal_family_link_accounts_allowed() const;
  ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* _internal_mutable_family_link_accounts_allowed();
  public:
  void unsafe_arena_set_allocated_family_link_accounts_allowed(
      ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* family_link_accounts_allowed);
  ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* unsafe_arena_release_family_link_accounts_allowed();

  // optional .enterprise_management.DeviceArcDataSnapshotHoursProto arc_data_snapshot_hours = 115;
  bool has_arc_data_snapshot_hours() const;
  private:
  bool _internal_has_arc_data_snapshot_hours() const;
  public:
  void clear_arc_data_snapshot_hours();
  const ::enterprise_management::DeviceArcDataSnapshotHoursProto& arc_data_snapshot_hours() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceArcDataSnapshotHoursProto* release_arc_data_snapshot_hours();
  ::enterprise_management::DeviceArcDataSnapshotHoursProto* mutable_arc_data_snapshot_hours();
  void set_allocated_arc_data_snapshot_hours(::enterprise_management::DeviceArcDataSnapshotHoursProto* arc_data_snapshot_hours);
  private:
  const ::enterprise_management::DeviceArcDataSnapshotHoursProto& _internal_arc_data_snapshot_hours() const;
  ::enterprise_management::DeviceArcDataSnapshotHoursProto* _internal_mutable_arc_data_snapshot_hours();
  public:
  void unsafe_arena_set_allocated_arc_data_snapshot_hours(
      ::enterprise_management::DeviceArcDataSnapshotHoursProto* arc_data_snapshot_hours);
  ::enterprise_management::DeviceArcDataSnapshotHoursProto* unsafe_arena_release_arc_data_snapshot_hours();

  // optional .enterprise_management.BooleanPolicyProto device_allow_mgs_to_store_display_properties = 116;
  bool has_device_allow_mgs_to_store_display_properties() const;
  private:
  bool _internal_has_device_allow_mgs_to_store_display_properties() const;
  public:
  void clear_device_allow_mgs_to_store_display_properties();
  const ::enterprise_management::BooleanPolicyProto& device_allow_mgs_to_store_display_properties() const;
  PROTOBUF_NODISCARD ::enterprise_management::BooleanPolicyProto* release_device_allow_mgs_to_store_display_properties();
  ::enterprise_management::BooleanPolicyProto* mutable_device_allow_mgs_to_store_display_properties();
  void set_allocated_device_allow_mgs_to_store_display_properties(::enterprise_management::BooleanPolicyProto* device_allow_mgs_to_store_display_properties);
  private:
  const ::enterprise_management::BooleanPolicyProto& _internal_device_allow_mgs_to_store_display_properties() const;
  ::enterprise_management::BooleanPolicyProto* _internal_mutable_device_allow_mgs_to_store_display_properties();
  public:
  void unsafe_arena_set_allocated_device_allow_mgs_to_store_display_properties(
      ::enterprise_management::BooleanPolicyProto* device_allow_mgs_to_store_display_properties);
  ::enterprise_management::BooleanPolicyProto* unsafe_arena_release_device_allow_mgs_to_store_display_properties();

  // optional .enterprise_management.DeviceSystemWideTracingEnabledProto device_system_wide_tracing_enabled = 117;
  bool has_device_system_wide_tracing_enabled() const;
  private:
  bool _internal_has_device_system_wide_tracing_enabled() const;
  public:
  void clear_device_system_wide_tracing_enabled();
  const ::enterprise_management::DeviceSystemWideTracingEnabledProto& device_system_wide_tracing_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceSystemWideTracingEnabledProto* release_device_system_wide_tracing_enabled();
  ::enterprise_management::DeviceSystemWideTracingEnabledProto* mutable_device_system_wide_tracing_enabled();
  void set_allocated_device_system_wide_tracing_enabled(::enterprise_management::DeviceSystemWideTracingEnabledProto* device_system_wide_tracing_enabled);
  private:
  const ::enterprise_management::DeviceSystemWideTracingEnabledProto& _internal_device_system_wide_tracing_enabled() const;
  ::enterprise_management::DeviceSystemWideTracingEnabledProto* _internal_mutable_device_system_wide_tracing_enabled();
  public:
  void unsafe_arena_set_allocated_device_system_wide_tracing_enabled(
      ::enterprise_management::DeviceSystemWideTracingEnabledProto* device_system_wide_tracing_enabled);
  ::enterprise_management::DeviceSystemWideTracingEnabledProto* unsafe_arena_release_device_system_wide_tracing_enabled();

  // optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProto device_pci_peripheral_data_access_enabled = 118;
  bool has_device_pci_peripheral_data_access_enabled() const;
  private:
  bool _internal_has_device_pci_peripheral_data_access_enabled() const;
  public:
  void clear_device_pci_peripheral_data_access_enabled();
  const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto& device_pci_peripheral_data_access_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* release_device_pci_peripheral_data_access_enabled();
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* mutable_device_pci_peripheral_data_access_enabled();
  void set_allocated_device_pci_peripheral_data_access_enabled(::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* device_pci_peripheral_data_access_enabled);
  private:
  const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto& _internal_device_pci_peripheral_data_access_enabled() const;
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* _internal_mutable_device_pci_peripheral_data_access_enabled();
  public:
  void unsafe_arena_set_allocated_device_pci_peripheral_data_access_enabled(
      ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* device_pci_peripheral_data_access_enabled);
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* unsafe_arena_release_device_pci_peripheral_data_access_enabled();

  // optional .enterprise_management.OBSOLETE_DeviceBorealisAllowedProto device_borealis_allowed = 119 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_device_borealis_allowed() const;
  private:
  bool _internal_has_device_borealis_allowed() const;
  public:
  PROTOBUF_DEPRECATED void clear_device_borealis_allowed();
  PROTOBUF_DEPRECATED const ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto& device_borealis_allowed() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* release_device_borealis_allowed();
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* mutable_device_borealis_allowed();
  PROTOBUF_DEPRECATED void set_allocated_device_borealis_allowed(::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* device_borealis_allowed);
  private:
  const ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto& _internal_device_borealis_allowed() const;
  ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* _internal_mutable_device_borealis_allowed();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_device_borealis_allowed(
      ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* device_borealis_allowed);
  PROTOBUF_DEPRECATED ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* unsafe_arena_release_device_borealis_allowed();

  // optional .enterprise_management.DeviceAllowedBluetoothServicesProto device_allowed_bluetooth_services = 120;
  bool has_device_allowed_bluetooth_services() const;
  private:
  bool _internal_has_device_allowed_bluetooth_services() const;
  public:
  void clear_device_allowed_bluetooth_services();
  const ::enterprise_management::DeviceAllowedBluetoothServicesProto& device_allowed_bluetooth_services() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAllowedBluetoothServicesProto* release_device_allowed_bluetooth_services();
  ::enterprise_management::DeviceAllowedBluetoothServicesProto* mutable_device_allowed_bluetooth_services();
  void set_allocated_device_allowed_bluetooth_services(::enterprise_management::DeviceAllowedBluetoothServicesProto* device_allowed_bluetooth_services);
  private:
  const ::enterprise_management::DeviceAllowedBluetoothServicesProto& _internal_device_allowed_bluetooth_services() const;
  ::enterprise_management::DeviceAllowedBluetoothServicesProto* _internal_mutable_device_allowed_bluetooth_services();
  public:
  void unsafe_arena_set_allocated_device_allowed_bluetooth_services(
      ::enterprise_management::DeviceAllowedBluetoothServicesProto* device_allowed_bluetooth_services);
  ::enterprise_management::DeviceAllowedBluetoothServicesProto* unsafe_arena_release_device_allowed_bluetooth_services();

  // optional .enterprise_management.DeviceDebugPacketCaptureAllowedProto device_debug_packet_capture_allowed = 121;
  bool has_device_debug_packet_capture_allowed() const;
  private:
  bool _internal_has_device_debug_packet_capture_allowed() const;
  public:
  void clear_device_debug_packet_capture_allowed();
  const ::enterprise_management::DeviceDebugPacketCaptureAllowedProto& device_debug_packet_capture_allowed() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* release_device_debug_packet_capture_allowed();
  ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* mutable_device_debug_packet_capture_allowed();
  void set_allocated_device_debug_packet_capture_allowed(::enterprise_management::DeviceDebugPacketCaptureAllowedProto* device_debug_packet_capture_allowed);
  private:
  const ::enterprise_management::DeviceDebugPacketCaptureAllowedProto& _internal_device_debug_packet_capture_allowed() const;
  ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* _internal_mutable_device_debug_packet_capture_allowed();
  public:
  void unsafe_arena_set_allocated_device_debug_packet_capture_allowed(
      ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* device_debug_packet_capture_allowed);
  ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* unsafe_arena_release_device_debug_packet_capture_allowed();

  // optional .enterprise_management.DeviceScheduledRebootProto device_scheduled_reboot = 122;
  bool has_device_scheduled_reboot() const;
  private:
  bool _internal_has_device_scheduled_reboot() const;
  public:
  void clear_device_scheduled_reboot();
  const ::enterprise_management::DeviceScheduledRebootProto& device_scheduled_reboot() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceScheduledRebootProto* release_device_scheduled_reboot();
  ::enterprise_management::DeviceScheduledRebootProto* mutable_device_scheduled_reboot();
  void set_allocated_device_scheduled_reboot(::enterprise_management::DeviceScheduledRebootProto* device_scheduled_reboot);
  private:
  const ::enterprise_management::DeviceScheduledRebootProto& _internal_device_scheduled_reboot() const;
  ::enterprise_management::DeviceScheduledRebootProto* _internal_mutable_device_scheduled_reboot();
  public:
  void unsafe_arena_set_allocated_device_scheduled_reboot(
      ::enterprise_management::DeviceScheduledRebootProto* device_scheduled_reboot);
  ::enterprise_management::DeviceScheduledRebootProto* unsafe_arena_release_device_scheduled_reboot();

  // optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2 device_pci_peripheral_data_access_enabled_v2 = 123;
  bool has_device_pci_peripheral_data_access_enabled_v2() const;
  private:
  bool _internal_has_device_pci_peripheral_data_access_enabled_v2() const;
  public:
  void clear_device_pci_peripheral_data_access_enabled_v2();
  const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2& device_pci_peripheral_data_access_enabled_v2() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* release_device_pci_peripheral_data_access_enabled_v2();
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* mutable_device_pci_peripheral_data_access_enabled_v2();
  void set_allocated_device_pci_peripheral_data_access_enabled_v2(::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* device_pci_peripheral_data_access_enabled_v2);
  private:
  const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2& _internal_device_pci_peripheral_data_access_enabled_v2() const;
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* _internal_mutable_device_pci_peripheral_data_access_enabled_v2();
  public:
  void unsafe_arena_set_allocated_device_pci_peripheral_data_access_enabled_v2(
      ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* device_pci_peripheral_data_access_enabled_v2);
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* unsafe_arena_release_device_pci_peripheral_data_access_enabled_v2();

  // optional .enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto device_restricted_managed_guest_session_enabled = 124;
  bool has_device_restricted_managed_guest_session_enabled() const;
  private:
  bool _internal_has_device_restricted_managed_guest_session_enabled() const;
  public:
  void clear_device_restricted_managed_guest_session_enabled();
  const ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto& device_restricted_managed_guest_session_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* release_device_restricted_managed_guest_session_enabled();
  ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* mutable_device_restricted_managed_guest_session_enabled();
  void set_allocated_device_restricted_managed_guest_session_enabled(::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* device_restricted_managed_guest_session_enabled);
  private:
  const ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto& _internal_device_restricted_managed_guest_session_enabled() const;
  ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* _internal_mutable_device_restricted_managed_guest_session_enabled();
  public:
  void unsafe_arena_set_allocated_device_restricted_managed_guest_session_enabled(
      ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* device_restricted_managed_guest_session_enabled);
  ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* unsafe_arena_release_device_restricted_managed_guest_session_enabled();

  // optional .enterprise_management.HostnameUserConfigurableProto hostname_user_configurable = 125;
  bool has_hostname_user_configurable() const;
  private:
  bool _internal_has_hostname_user_configurable() const;
  public:
  void clear_hostname_user_configurable();
  const ::enterprise_management::HostnameUserConfigurableProto& hostname_user_configurable() const;
  PROTOBUF_NODISCARD ::enterprise_management::HostnameUserConfigurableProto* release_hostname_user_configurable();
  ::enterprise_management::HostnameUserConfigurableProto* mutable_hostname_user_configurable();
  void set_allocated_hostname_user_configurable(::enterprise_management::HostnameUserConfigurableProto* hostname_user_configurable);
  private:
  const ::enterprise_management::HostnameUserConfigurableProto& _internal_hostname_user_configurable() const;
  ::enterprise_management::HostnameUserConfigurableProto* _internal_mutable_hostname_user_configurable();
  public:
  void unsafe_arena_set_allocated_hostname_user_configurable(
      ::enterprise_management::HostnameUserConfigurableProto* hostname_user_configurable);
  ::enterprise_management::HostnameUserConfigurableProto* unsafe_arena_release_hostname_user_configurable();

  // optional .enterprise_management.BooleanPolicyProto login_screen_prompt_on_multiple_matching_certificates = 126;
  bool has_login_screen_prompt_on_multiple_matching_certificates() const;
  private:
  bool _internal_has_login_screen_prompt_on_multiple_matching_certificates() const;
  public:
  void clear_login_screen_prompt_on_multiple_matching_certificates();
  const ::enterprise_management::BooleanPolicyProto& login_screen_prompt_on_multiple_matching_certificates() const;
  PROTOBUF_NODISCARD ::enterprise_management::BooleanPolicyProto* release_login_screen_prompt_on_multiple_matching_certificates();
  ::enterprise_management::BooleanPolicyProto* mutable_login_screen_prompt_on_multiple_matching_certificates();
  void set_allocated_login_screen_prompt_on_multiple_matching_certificates(::enterprise_management::BooleanPolicyProto* login_screen_prompt_on_multiple_matching_certificates);
  private:
  const ::enterprise_management::BooleanPolicyProto& _internal_login_screen_prompt_on_multiple_matching_certificates() const;
  ::enterprise_management::BooleanPolicyProto* _internal_mutable_login_screen_prompt_on_multiple_matching_certificates();
  public:
  void unsafe_arena_set_allocated_login_screen_prompt_on_multiple_matching_certificates(
      ::enterprise_management::BooleanPolicyProto* login_screen_prompt_on_multiple_matching_certificates);
  ::enterprise_management::BooleanPolicyProto* unsafe_arena_release_login_screen_prompt_on_multiple_matching_certificates();

  // optional .enterprise_management.BooleanPolicyProto kiosk_crx_manifest_update_url_ignored = 127;
  bool has_kiosk_crx_manifest_update_url_ignored() const;
  private:
  bool _internal_has_kiosk_crx_manifest_update_url_ignored() const;
  public:
  void clear_kiosk_crx_manifest_update_url_ignored();
  const ::enterprise_management::BooleanPolicyProto& kiosk_crx_manifest_update_url_ignored() const;
  PROTOBUF_NODISCARD ::enterprise_management::BooleanPolicyProto* release_kiosk_crx_manifest_update_url_ignored();
  ::enterprise_management::BooleanPolicyProto* mutable_kiosk_crx_manifest_update_url_ignored();
  void set_allocated_kiosk_crx_manifest_update_url_ignored(::enterprise_management::BooleanPolicyProto* kiosk_crx_manifest_update_url_ignored);
  private:
  const ::enterprise_management::BooleanPolicyProto& _internal_kiosk_crx_manifest_update_url_ignored() const;
  ::enterprise_management::BooleanPolicyProto* _internal_mutable_kiosk_crx_manifest_update_url_ignored();
  public:
  void unsafe_arena_set_allocated_kiosk_crx_manifest_update_url_ignored(
      ::enterprise_management::BooleanPolicyProto* kiosk_crx_manifest_update_url_ignored);
  ::enterprise_management::BooleanPolicyProto* unsafe_arena_release_kiosk_crx_manifest_update_url_ignored();

  // optional .enterprise_management.DeviceI18nShortcutsEnabledProto device_i18n_shortcuts_enabled = 128;
  bool has_device_i18n_shortcuts_enabled() const;
  private:
  bool _internal_has_device_i18n_shortcuts_enabled() const;
  public:
  void clear_device_i18n_shortcuts_enabled();
  const ::enterprise_management::DeviceI18nShortcutsEnabledProto& device_i18n_shortcuts_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceI18nShortcutsEnabledProto* release_device_i18n_shortcuts_enabled();
  ::enterprise_management::DeviceI18nShortcutsEnabledProto* mutable_device_i18n_shortcuts_enabled();
  void set_allocated_device_i18n_shortcuts_enabled(::enterprise_management::DeviceI18nShortcutsEnabledProto* device_i18n_shortcuts_enabled);
  private:
  const ::enterprise_management::DeviceI18nShortcutsEnabledProto& _internal_device_i18n_shortcuts_enabled() const;
  ::enterprise_management::DeviceI18nShortcutsEnabledProto* _internal_mutable_device_i18n_shortcuts_enabled();
  public:
  void unsafe_arena_set_allocated_device_i18n_shortcuts_enabled(
      ::enterprise_management::DeviceI18nShortcutsEnabledProto* device_i18n_shortcuts_enabled);
  ::enterprise_management::DeviceI18nShortcutsEnabledProto* unsafe_arena_release_device_i18n_shortcuts_enabled();

  // optional .enterprise_management.BooleanPolicyProto chromad_to_cloud_migration_enabled = 129;
  bool has_chromad_to_cloud_migration_enabled() const;
  private:
  bool _internal_has_chromad_to_cloud_migration_enabled() const;
  public:
  void clear_chromad_to_cloud_migration_enabled();
  const ::enterprise_management::BooleanPolicyProto& chromad_to_cloud_migration_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::BooleanPolicyProto* release_chromad_to_cloud_migration_enabled();
  ::enterprise_management::BooleanPolicyProto* mutable_chromad_to_cloud_migration_enabled();
  void set_allocated_chromad_to_cloud_migration_enabled(::enterprise_management::BooleanPolicyProto* chromad_to_cloud_migration_enabled);
  private:
  const ::enterprise_management::BooleanPolicyProto& _internal_chromad_to_cloud_migration_enabled() const;
  ::enterprise_management::BooleanPolicyProto* _internal_mutable_chromad_to_cloud_migration_enabled();
  public:
  void unsafe_arena_set_allocated_chromad_to_cloud_migration_enabled(
      ::enterprise_management::BooleanPolicyProto* chromad_to_cloud_migration_enabled);
  ::enterprise_management::BooleanPolicyProto* unsafe_arena_release_chromad_to_cloud_migration_enabled();

  // optional .enterprise_management.RevenDeviceHWDataUsageEnabledProto hardware_data_usage_enabled = 130;
  bool has_hardware_data_usage_enabled() const;
  private:
  bool _internal_has_hardware_data_usage_enabled() const;
  public:
  void clear_hardware_data_usage_enabled();
  const ::enterprise_management::RevenDeviceHWDataUsageEnabledProto& hardware_data_usage_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* release_hardware_data_usage_enabled();
  ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* mutable_hardware_data_usage_enabled();
  void set_allocated_hardware_data_usage_enabled(::enterprise_management::RevenDeviceHWDataUsageEnabledProto* hardware_data_usage_enabled);
  private:
  const ::enterprise_management::RevenDeviceHWDataUsageEnabledProto& _internal_hardware_data_usage_enabled() const;
  ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* _internal_mutable_hardware_data_usage_enabled();
  public:
  void unsafe_arena_set_allocated_hardware_data_usage_enabled(
      ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* hardware_data_usage_enabled);
  ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* unsafe_arena_release_hardware_data_usage_enabled();

  // optional .enterprise_management.DeviceLoginScreenWebUILazyLoadingProto login_web_ui_lazy_loading = 131;
  bool has_login_web_ui_lazy_loading() const;
  private:
  bool _internal_has_login_web_ui_lazy_loading() const;
  public:
  void clear_login_web_ui_lazy_loading();
  const ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto& login_web_ui_lazy_loading() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* release_login_web_ui_lazy_loading();
  ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* mutable_login_web_ui_lazy_loading();
  void set_allocated_login_web_ui_lazy_loading(::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* login_web_ui_lazy_loading);
  private:
  const ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto& _internal_login_web_ui_lazy_loading() const;
  ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* _internal_mutable_login_web_ui_lazy_loading();
  public:
  void unsafe_arena_set_allocated_login_web_ui_lazy_loading(
      ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* login_web_ui_lazy_loading);
  ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* unsafe_arena_release_login_web_ui_lazy_loading();

  // optional .enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto keylocker_for_storage_encryption_enabled = 132;
  bool has_keylocker_for_storage_encryption_enabled() const;
  private:
  bool _internal_has_keylocker_for_storage_encryption_enabled() const;
  public:
  void clear_keylocker_for_storage_encryption_enabled();
  const ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto& keylocker_for_storage_encryption_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* release_keylocker_for_storage_encryption_enabled();
  ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* mutable_keylocker_for_storage_encryption_enabled();
  void set_allocated_keylocker_for_storage_encryption_enabled(::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* keylocker_for_storage_encryption_enabled);
  private:
  const ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto& _internal_keylocker_for_storage_encryption_enabled() const;
  ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* _internal_mutable_keylocker_for_storage_encryption_enabled();
  public:
  void unsafe_arena_set_allocated_keylocker_for_storage_encryption_enabled(
      ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* keylocker_for_storage_encryption_enabled);
  ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* unsafe_arena_release_keylocker_for_storage_encryption_enabled();

  // optional .enterprise_management.BooleanPolicyProto device_run_automatic_cleanup_on_login = 133;
  bool has_device_run_automatic_cleanup_on_login() const;
  private:
  bool _internal_has_device_run_automatic_cleanup_on_login() const;
  public:
  void clear_device_run_automatic_cleanup_on_login();
  const ::enterprise_management::BooleanPolicyProto& device_run_automatic_cleanup_on_login() const;
  PROTOBUF_NODISCARD ::enterprise_management::BooleanPolicyProto* release_device_run_automatic_cleanup_on_login();
  ::enterprise_management::BooleanPolicyProto* mutable_device_run_automatic_cleanup_on_login();
  void set_allocated_device_run_automatic_cleanup_on_login(::enterprise_management::BooleanPolicyProto* device_run_automatic_cleanup_on_login);
  private:
  const ::enterprise_management::BooleanPolicyProto& _internal_device_run_automatic_cleanup_on_login() const;
  ::enterprise_management::BooleanPolicyProto* _internal_mutable_device_run_automatic_cleanup_on_login();
  public:
  void unsafe_arena_set_allocated_device_run_automatic_cleanup_on_login(
      ::enterprise_management::BooleanPolicyProto* device_run_automatic_cleanup_on_login);
  ::enterprise_management::BooleanPolicyProto* unsafe_arena_release_device_run_automatic_cleanup_on_login();

  // optional .enterprise_management.EncryptedReportingPipelineConfigurationProto device_encrypted_reporting_pipeline_enabled = 134;
  bool has_device_encrypted_reporting_pipeline_enabled() const;
  private:
  bool _internal_has_device_encrypted_reporting_pipeline_enabled() const;
  public:
  void clear_device_encrypted_reporting_pipeline_enabled();
  const ::enterprise_management::EncryptedReportingPipelineConfigurationProto& device_encrypted_reporting_pipeline_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::EncryptedReportingPipelineConfigurationProto* release_device_encrypted_reporting_pipeline_enabled();
  ::enterprise_management::EncryptedReportingPipelineConfigurationProto* mutable_device_encrypted_reporting_pipeline_enabled();
  void set_allocated_device_encrypted_reporting_pipeline_enabled(::enterprise_management::EncryptedReportingPipelineConfigurationProto* device_encrypted_reporting_pipeline_enabled);
  private:
  const ::enterprise_management::EncryptedReportingPipelineConfigurationProto& _internal_device_encrypted_reporting_pipeline_enabled() const;
  ::enterprise_management::EncryptedReportingPipelineConfigurationProto* _internal_mutable_device_encrypted_reporting_pipeline_enabled();
  public:
  void unsafe_arena_set_allocated_device_encrypted_reporting_pipeline_enabled(
      ::enterprise_management::EncryptedReportingPipelineConfigurationProto* device_encrypted_reporting_pipeline_enabled);
  ::enterprise_management::EncryptedReportingPipelineConfigurationProto* unsafe_arena_release_device_encrypted_reporting_pipeline_enabled();

  // optional .enterprise_management.SAMLUsernameProto saml_username = 135;
  bool has_saml_username() const;
  private:
  bool _internal_has_saml_username() const;
  public:
  void clear_saml_username();
  const ::enterprise_management::SAMLUsernameProto& saml_username() const;
  PROTOBUF_NODISCARD ::enterprise_management::SAMLUsernameProto* release_saml_username();
  ::enterprise_management::SAMLUsernameProto* mutable_saml_username();
  void set_allocated_saml_username(::enterprise_management::SAMLUsernameProto* saml_username);
  private:
  const ::enterprise_management::SAMLUsernameProto& _internal_saml_username() const;
  ::enterprise_management::SAMLUsernameProto* _internal_mutable_saml_username();
  public:
  void unsafe_arena_set_allocated_saml_username(
      ::enterprise_management::SAMLUsernameProto* saml_username);
  ::enterprise_management::SAMLUsernameProto* unsafe_arena_release_saml_username();

  // optional .enterprise_management.StringListPolicyProto device_login_screen_context_aware_access_signals_allowlist = 136;
  bool has_device_login_screen_context_aware_access_signals_allowlist() const;
  private:
  bool _internal_has_device_login_screen_context_aware_access_signals_allowlist() const;
  public:
  void clear_device_login_screen_context_aware_access_signals_allowlist();
  const ::enterprise_management::StringListPolicyProto& device_login_screen_context_aware_access_signals_allowlist() const;
  PROTOBUF_NODISCARD ::enterprise_management::StringListPolicyProto* release_device_login_screen_context_aware_access_signals_allowlist();
  ::enterprise_management::StringListPolicyProto* mutable_device_login_screen_context_aware_access_signals_allowlist();
  void set_allocated_device_login_screen_context_aware_access_signals_allowlist(::enterprise_management::StringListPolicyProto* device_login_screen_context_aware_access_signals_allowlist);
  private:
  const ::enterprise_management::StringListPolicyProto& _internal_device_login_screen_context_aware_access_signals_allowlist() const;
  ::enterprise_management::StringListPolicyProto* _internal_mutable_device_login_screen_context_aware_access_signals_allowlist();
  public:
  void unsafe_arena_set_allocated_device_login_screen_context_aware_access_signals_allowlist(
      ::enterprise_management::StringListPolicyProto* device_login_screen_context_aware_access_signals_allowlist);
  ::enterprise_management::StringListPolicyProto* unsafe_arena_release_device_login_screen_context_aware_access_signals_allowlist();

  // optional .enterprise_management.StringPolicyProto device_printing_client_name_template = 137;
  bool has_device_printing_client_name_template() const;
  private:
  bool _internal_has_device_printing_client_name_template() const;
  public:
  void clear_device_printing_client_name_template();
  const ::enterprise_management::StringPolicyProto& device_printing_client_name_template() const;
  PROTOBUF_NODISCARD ::enterprise_management::StringPolicyProto* release_device_printing_client_name_template();
  ::enterprise_management::StringPolicyProto* mutable_device_printing_client_name_template();
  void set_allocated_device_printing_client_name_template(::enterprise_management::StringPolicyProto* device_printing_client_name_template);
  private:
  const ::enterprise_management::StringPolicyProto& _internal_device_printing_client_name_template() const;
  ::enterprise_management::StringPolicyProto* _internal_mutable_device_printing_client_name_template();
  public:
  void unsafe_arena_set_allocated_device_printing_client_name_template(
      ::enterprise_management::StringPolicyProto* device_printing_client_name_template);
  ::enterprise_management::StringPolicyProto* unsafe_arena_release_device_printing_client_name_template();

  // optional .enterprise_management.DeviceReportXDREventsProto device_report_xdr_events = 138;
  bool has_device_report_xdr_events() const;
  private:
  bool _internal_has_device_report_xdr_events() const;
  public:
  void clear_device_report_xdr_events();
  const ::enterprise_management::DeviceReportXDREventsProto& device_report_xdr_events() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceReportXDREventsProto* release_device_report_xdr_events();
  ::enterprise_management::DeviceReportXDREventsProto* mutable_device_report_xdr_events();
  void set_allocated_device_report_xdr_events(::enterprise_management::DeviceReportXDREventsProto* device_report_xdr_events);
  private:
  const ::enterprise_management::DeviceReportXDREventsProto& _internal_device_report_xdr_events() const;
  ::enterprise_management::DeviceReportXDREventsProto* _internal_mutable_device_report_xdr_events();
  public:
  void unsafe_arena_set_allocated_device_report_xdr_events(
      ::enterprise_management::DeviceReportXDREventsProto* device_report_xdr_events);
  ::enterprise_management::DeviceReportXDREventsProto* unsafe_arena_release_device_report_xdr_events();

  // optional .enterprise_management.KeyboardBacklightColorProto keyboard_backlight_color = 139;
  bool has_keyboard_backlight_color() const;
  private:
  bool _internal_has_keyboard_backlight_color() const;
  public:
  void clear_keyboard_backlight_color();
  const ::enterprise_management::KeyboardBacklightColorProto& keyboard_backlight_color() const;
  PROTOBUF_NODISCARD ::enterprise_management::KeyboardBacklightColorProto* release_keyboard_backlight_color();
  ::enterprise_management::KeyboardBacklightColorProto* mutable_keyboard_backlight_color();
  void set_allocated_keyboard_backlight_color(::enterprise_management::KeyboardBacklightColorProto* keyboard_backlight_color);
  private:
  const ::enterprise_management::KeyboardBacklightColorProto& _internal_keyboard_backlight_color() const;
  ::enterprise_management::KeyboardBacklightColorProto* _internal_mutable_keyboard_backlight_color();
  public:
  void unsafe_arena_set_allocated_keyboard_backlight_color(
      ::enterprise_management::KeyboardBacklightColorProto* keyboard_backlight_color);
  ::enterprise_management::KeyboardBacklightColorProto* unsafe_arena_release_keyboard_backlight_color();

  // optional .enterprise_management.DeviceHindiInscriptLayoutEnabledProto device_hindi_inscript_layout_enabled = 140;
  bool has_device_hindi_inscript_layout_enabled() const;
  private:
  bool _internal_has_device_hindi_inscript_layout_enabled() const;
  public:
  void clear_device_hindi_inscript_layout_enabled();
  const ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto& device_hindi_inscript_layout_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* release_device_hindi_inscript_layout_enabled();
  ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* mutable_device_hindi_inscript_layout_enabled();
  void set_allocated_device_hindi_inscript_layout_enabled(::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* device_hindi_inscript_layout_enabled);
  private:
  const ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto& _internal_device_hindi_inscript_layout_enabled() const;
  ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* _internal_mutable_device_hindi_inscript_layout_enabled();
  public:
  void unsafe_arena_set_allocated_device_hindi_inscript_layout_enabled(
      ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* device_hindi_inscript_layout_enabled);
  ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* unsafe_arena_release_device_hindi_inscript_layout_enabled();

  // optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto login_screen_extension_manifest_v2_availability = 141;
  bool has_login_screen_extension_manifest_v2_availability() const;
  private:
  bool _internal_has_login_screen_extension_manifest_v2_availability() const;
  public:
  void clear_login_screen_extension_manifest_v2_availability();
  const ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto& login_screen_extension_manifest_v2_availability() const;
  PROTOBUF_NODISCARD ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* release_login_screen_extension_manifest_v2_availability();
  ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* mutable_login_screen_extension_manifest_v2_availability();
  void set_allocated_login_screen_extension_manifest_v2_availability(::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* login_screen_extension_manifest_v2_availability);
  private:
  const ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto& _internal_login_screen_extension_manifest_v2_availability() const;
  ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* _internal_mutable_login_screen_extension_manifest_v2_availability();
  public:
  void unsafe_arena_set_allocated_login_screen_extension_manifest_v2_availability(
      ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* login_screen_extension_manifest_v2_availability);
  ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* unsafe_arena_release_login_screen_extension_manifest_v2_availability();

  // optional .enterprise_management.DeviceScreensaverEnabledProto device_screensaver_enabled = 142;
  bool has_device_screensaver_enabled() const;
  private:
  bool _internal_has_device_screensaver_enabled() const;
  public:
  void clear_device_screensaver_enabled();
  const ::enterprise_management::DeviceScreensaverEnabledProto& device_screensaver_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceScreensaverEnabledProto* release_device_screensaver_enabled();
  ::enterprise_management::DeviceScreensaverEnabledProto* mutable_device_screensaver_enabled();
  void set_allocated_device_screensaver_enabled(::enterprise_management::DeviceScreensaverEnabledProto* device_screensaver_enabled);
  private:
  const ::enterprise_management::DeviceScreensaverEnabledProto& _internal_device_screensaver_enabled() const;
  ::enterprise_management::DeviceScreensaverEnabledProto* _internal_mutable_device_screensaver_enabled();
  public:
  void unsafe_arena_set_allocated_device_screensaver_enabled(
      ::enterprise_management::DeviceScreensaverEnabledProto* device_screensaver_enabled);
  ::enterprise_management::DeviceScreensaverEnabledProto* unsafe_arena_release_device_screensaver_enabled();

  // optional .enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto device_screensaver_idle_timeout_seconds = 143;
  bool has_device_screensaver_idle_timeout_seconds() const;
  private:
  bool _internal_has_device_screensaver_idle_timeout_seconds() const;
  public:
  void clear_device_screensaver_idle_timeout_seconds();
  const ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto& device_screensaver_idle_timeout_seconds() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* release_device_screensaver_idle_timeout_seconds();
  ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* mutable_device_screensaver_idle_timeout_seconds();
  void set_allocated_device_screensaver_idle_timeout_seconds(::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* device_screensaver_idle_timeout_seconds);
  private:
  const ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto& _internal_device_screensaver_idle_timeout_seconds() const;
  ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* _internal_mutable_device_screensaver_idle_timeout_seconds();
  public:
  void unsafe_arena_set_allocated_device_screensaver_idle_timeout_seconds(
      ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* device_screensaver_idle_timeout_seconds);
  ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* unsafe_arena_release_device_screensaver_idle_timeout_seconds();

  // optional .enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto device_screensaver_image_display_interval_seconds = 144;
  bool has_device_screensaver_image_display_interval_seconds() const;
  private:
  bool _internal_has_device_screensaver_image_display_interval_seconds() const;
  public:
  void clear_device_screensaver_image_display_interval_seconds();
  const ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto& device_screensaver_image_display_interval_seconds() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* release_device_screensaver_image_display_interval_seconds();
  ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* mutable_device_screensaver_image_display_interval_seconds();
  void set_allocated_device_screensaver_image_display_interval_seconds(::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* device_screensaver_image_display_interval_seconds);
  private:
  const ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto& _internal_device_screensaver_image_display_interval_seconds() const;
  ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* _internal_mutable_device_screensaver_image_display_interval_seconds();
  public:
  void unsafe_arena_set_allocated_device_screensaver_image_display_interval_seconds(
      ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* device_screensaver_image_display_interval_seconds);
  ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* unsafe_arena_release_device_screensaver_image_display_interval_seconds();

  // optional .enterprise_management.DeviceScreensaverImagesProto device_screensaver_images = 145;
  bool has_device_screensaver_images() const;
  private:
  bool _internal_has_device_screensaver_images() const;
  public:
  void clear_device_screensaver_images();
  const ::enterprise_management::DeviceScreensaverImagesProto& device_screensaver_images() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceScreensaverImagesProto* release_device_screensaver_images();
  ::enterprise_management::DeviceScreensaverImagesProto* mutable_device_screensaver_images();
  void set_allocated_device_screensaver_images(::enterprise_management::DeviceScreensaverImagesProto* device_screensaver_images);
  private:
  const ::enterprise_management::DeviceScreensaverImagesProto& _internal_device_screensaver_images() const;
  ::enterprise_management::DeviceScreensaverImagesProto* _internal_mutable_device_screensaver_images();
  public:
  void unsafe_arena_set_allocated_device_screensaver_images(
      ::enterprise_management::DeviceScreensaverImagesProto* device_screensaver_images);
  ::enterprise_management::DeviceScreensaverImagesProto* unsafe_arena_release_device_screensaver_images();

  // optional .enterprise_management.DeviceSystemAecEnabledProto device_system_aec_enabled = 146;
  bool has_device_system_aec_enabled() const;
  private:
  bool _internal_has_device_system_aec_enabled() const;
  public:
  void clear_device_system_aec_enabled();
  const ::enterprise_management::DeviceSystemAecEnabledProto& device_system_aec_enabled() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceSystemAecEnabledProto* release_device_system_aec_enabled();
  ::enterprise_management::DeviceSystemAecEnabledProto* mutable_device_system_aec_enabled();
  void set_allocated_device_system_aec_enabled(::enterprise_management::DeviceSystemAecEnabledProto* device_system_aec_enabled);
  private:
  const ::enterprise_management::DeviceSystemAecEnabledProto& _internal_device_system_aec_enabled() const;
  ::enterprise_management::DeviceSystemAecEnabledProto* _internal_mutable_device_system_aec_enabled();
  public:
  void unsafe_arena_set_allocated_device_system_aec_enabled(
      ::enterprise_management::DeviceSystemAecEnabledProto* device_system_aec_enabled);
  ::enterprise_management::DeviceSystemAecEnabledProto* unsafe_arena_release_device_system_aec_enabled();

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeDeviceSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<5> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::DevicePolicyRefreshRateProto* device_policy_refresh_rate_;
    ::enterprise_management::UserWhitelistProto* user_whitelist_;
    ::enterprise_management::GuestModeEnabledProto* guest_mode_enabled_;
    ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* device_proxy_settings_;
    ::enterprise_management::CameraEnabledProto* camera_enabled_;
    ::enterprise_management::ShowUserNamesOnSigninProto* show_user_names_;
    ::enterprise_management::DataRoamingEnabledProto* data_roaming_enabled_;
    ::enterprise_management::AllowNewUsersProto* allow_new_users_;
    ::enterprise_management::MetricsEnabledProto* metrics_enabled_;
    ::enterprise_management::ReleaseChannelProto* release_channel_;
    ::enterprise_management::DeviceOpenNetworkConfigurationProto* open_network_configuration_;
    ::enterprise_management::DeviceReportingProto* device_reporting_;
    ::enterprise_management::EphemeralUsersEnabledProto* ephemeral_users_enabled_;
    ::enterprise_management::OBSOLETE_AppPackProto* app_pack_;
    ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* forced_logout_timeouts_;
    ::enterprise_management::OBSOLETE_ScreenSaverProto* login_screen_saver_;
    ::enterprise_management::AutoUpdateSettingsProto* auto_update_settings_;
    ::enterprise_management::OBSOLETE_StartUpUrlsProto* start_up_urls_;
    ::enterprise_management::OBSOLETE_PinnedAppsProto* pinned_apps_;
    ::enterprise_management::SystemTimezoneProto* system_timezone_;
    ::enterprise_management::DeviceLocalAccountsProto* device_local_accounts_;
    ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* allow_redeem_offers_;
    ::enterprise_management::FeatureFlagsProto* feature_flags_;
    ::enterprise_management::UptimeLimitProto* uptime_limit_;
    ::enterprise_management::VariationsParameterProto* variations_parameter_;
    ::enterprise_management::AttestationSettingsProto* attestation_settings_;
    ::enterprise_management::AccessibilitySettingsProto* accessibility_settings_;
    ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* supervised_users_settings_;
    ::enterprise_management::LoginScreenPowerManagementProto* login_screen_power_management_;
    ::enterprise_management::SystemUse24HourClockProto* use_24hour_clock_;
    ::enterprise_management::AutoCleanupSettigsProto* auto_clean_up_settings_;
    ::enterprise_management::SystemSettingsProto* system_settings_;
    ::enterprise_management::SAMLSettingsProto* saml_settings_;
    ::enterprise_management::RebootOnShutdownProto* reboot_on_shutdown_;
    ::enterprise_management::DeviceHeartbeatSettingsProto* device_heartbeat_settings_;
    ::enterprise_management::ExtensionCacheSizeProto* extension_cache_size_;
    ::enterprise_management::LoginScreenDomainAutoCompleteProto* login_screen_domain_auto_complete_;
    ::enterprise_management::DeviceLogUploadSettingsProto* device_log_upload_settings_;
    ::enterprise_management::DisplayRotationDefaultProto* display_rotation_default_;
    ::enterprise_management::AllowKioskAppControlChromeVersionProto* allow_kiosk_app_control_chrome_version_;
    ::enterprise_management::LoginAuthenticationBehaviorProto* login_authentication_behavior_;
    ::enterprise_management::UsbDetachableWhitelistProto* usb_detachable_whitelist_;
    ::enterprise_management::AllowBluetoothProto* allow_bluetooth_;
    ::enterprise_management::DeviceQuirksDownloadEnabledProto* quirks_download_enabled_;
    ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* login_video_capture_allowed_urls_;
    ::enterprise_management::DeviceLoginScreenExtensionsProto* device_login_screen_extensions_;
    ::enterprise_management::NetworkThrottlingEnabledProto* network_throttling_;
    ::enterprise_management::DeviceWallpaperImageProto* device_wallpaper_image_;
    ::enterprise_management::LoginScreenLocalesProto* login_screen_locales_;
    ::enterprise_management::LoginScreenInputMethodsProto* login_screen_input_methods_;
    ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* device_ecryptfs_migration_strategy_;
    ::enterprise_management::DeviceSecondFactorAuthenticationProto* device_second_factor_authentication_;
    ::enterprise_management::CastReceiverNameProto* cast_receiver_name_;
    ::enterprise_management::DeviceOffHoursProto* device_off_hours_;
    ::enterprise_management::DeviceNativePrintersProto* native_device_printers_;
    ::enterprise_management::DeviceNativePrintersAccessModeProto* native_device_printers_access_mode_;
    ::enterprise_management::DeviceNativePrintersBlacklistProto* native_device_printers_blacklist_;
    ::enterprise_management::DeviceNativePrintersWhitelistProto* native_device_printers_whitelist_;
    ::enterprise_management::TPMFirmwareUpdateSettingsProto* tpm_firmware_update_settings_;
    ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* minimum_required_version_;
    ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* device_login_screen_auto_select_certificate_for_urls_;
    ::enterprise_management::UnaffiliatedArcAllowedProto* unaffiliated_arc_allowed_;
    ::enterprise_management::NetworkHostnameProto* network_hostname_;
    ::enterprise_management::DeviceKerberosEncryptionTypesProto* device_kerberos_encryption_types_;
    ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* device_user_policy_loopback_processing_mode_;
    ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* device_login_screen_isolate_origins_;
    ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* device_login_screen_site_per_process_;
    ::enterprise_management::VirtualMachinesAllowedProto* virtual_machines_allowed_;
    ::enterprise_management::DeviceMachinePasswordChangeRateProto* device_machine_password_change_rate_;
    ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* device_unaffiliated_crostini_allowed_;
    ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* device_wifi_fast_transition_enabled_;
    ::enterprise_management::DeviceDisplayResolutionProto* device_display_resolution_;
    ::enterprise_management::PluginVmAllowedProto* plugin_vm_allowed_;
    ::enterprise_management::DeviceGpoCacheLifetimeProto* device_gpo_cache_lifetime_;
    ::enterprise_management::DeviceAuthDataCacheLifetimeProto* device_auth_data_cache_lifetime_;
    ::enterprise_management::PluginVmLicenseKeyProto* plugin_vm_license_key_;
    ::enterprise_management::DeviceRebootOnUserSignoutProto* device_reboot_on_user_signout_;
    ::enterprise_management::DeviceWilcoDtcAllowedProto* device_wilco_dtc_allowed_;
    ::enterprise_management::DeviceWilcoDtcConfigurationProto* device_wilco_dtc_configuration_;
    ::enterprise_management::DeviceWiFiAllowedProto* device_wifi_allowed_;
    ::enterprise_management::DevicePowerPeakShiftProto* device_power_peak_shift_;
    ::enterprise_management::DeviceBootOnAcProto* device_boot_on_ac_;
    ::enterprise_management::DeviceDockMacAddressSourceProto* device_dock_mac_address_source_;
    ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* device_advanced_battery_charge_mode_;
    ::enterprise_management::DeviceBatteryChargeModeProto* device_battery_charge_mode_;
    ::enterprise_management::DeviceUsbPowerShareProto* device_usb_power_share_;
    ::enterprise_management::DeviceScheduledUpdateCheckProto* device_scheduled_update_check_;
    ::enterprise_management::DevicePowerwashAllowedProto* device_powerwash_allowed_;
    ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* device_login_screen_webusb_allow_devices_for_urls_;
    ::enterprise_management::BooleanPolicyProto* device_login_screen_system_info_enforced_;
    ::enterprise_management::StringListPolicyProto* device_web_based_attestation_allowed_urls_;
    ::enterprise_management::BooleanPolicyProto* device_show_numeric_keyboard_for_password_;
    ::enterprise_management::BooleanPolicyProto* login_screen_primary_mouse_button_switch_;
    ::enterprise_management::StringPolicyProto* device_minimum_version_;
    ::enterprise_management::SystemProxySettingsProto* system_proxy_settings_;
    ::enterprise_management::IntegerPolicyProto* device_chrome_variations_type_;
    ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* device_login_screen_privacy_screen_enabled_;
    ::enterprise_management::RequiredClientCertificateForDeviceProto* required_client_certificate_for_device_;
    ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* device_crostini_arc_adb_sideloading_allowed_;
    ::enterprise_management::StringPolicyProto* device_minimum_version_aue_message_;
    ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* managed_guest_session_privacy_warnings_;
    ::enterprise_management::DeviceExternalPrintServersProto* external_print_servers_;
    ::enterprise_management::DeviceExternalPrintServersAllowlistProto* external_print_servers_allowlist_;
    ::enterprise_management::DevicePrintersAccessModeProto* device_printers_access_mode_;
    ::enterprise_management::DevicePrintersBlocklistProto* device_printers_blocklist_;
    ::enterprise_management::DevicePrintersAllowlistProto* device_printers_allowlist_;
    ::enterprise_management::DevicePrintersProto* device_printers_;
    ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* device_show_low_disk_space_notification_;
    ::enterprise_management::UserAllowlistProto* user_allowlist_;
    ::enterprise_management::UsbDetachableAllowlistProto* usb_detachable_allowlist_;
    ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* family_link_accounts_allowed_;
    ::enterprise_management::DeviceArcDataSnapshotHoursProto* arc_data_snapshot_hours_;
    ::enterprise_management::BooleanPolicyProto* device_allow_mgs_to_store_display_properties_;
    ::enterprise_management::DeviceSystemWideTracingEnabledProto* device_system_wide_tracing_enabled_;
    ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* device_pci_peripheral_data_access_enabled_;
    ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* device_borealis_allowed_;
    ::enterprise_management::DeviceAllowedBluetoothServicesProto* device_allowed_bluetooth_services_;
    ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* device_debug_packet_capture_allowed_;
    ::enterprise_management::DeviceScheduledRebootProto* device_scheduled_reboot_;
    ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* device_pci_peripheral_data_access_enabled_v2_;
    ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* device_restricted_managed_guest_session_enabled_;
    ::enterprise_management::HostnameUserConfigurableProto* hostname_user_configurable_;
    ::enterprise_management::BooleanPolicyProto* login_screen_prompt_on_multiple_matching_certificates_;
    ::enterprise_management::BooleanPolicyProto* kiosk_crx_manifest_update_url_ignored_;
    ::enterprise_management::DeviceI18nShortcutsEnabledProto* device_i18n_shortcuts_enabled_;
    ::enterprise_management::BooleanPolicyProto* chromad_to_cloud_migration_enabled_;
    ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* hardware_data_usage_enabled_;
    ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* login_web_ui_lazy_loading_;
    ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* keylocker_for_storage_encryption_enabled_;
    ::enterprise_management::BooleanPolicyProto* device_run_automatic_cleanup_on_login_;
    ::enterprise_management::EncryptedReportingPipelineConfigurationProto* device_encrypted_reporting_pipeline_enabled_;
    ::enterprise_management::SAMLUsernameProto* saml_username_;
    ::enterprise_management::StringListPolicyProto* device_login_screen_context_aware_access_signals_allowlist_;
    ::enterprise_management::StringPolicyProto* device_printing_client_name_template_;
    ::enterprise_management::DeviceReportXDREventsProto* device_report_xdr_events_;
    ::enterprise_management::KeyboardBacklightColorProto* keyboard_backlight_color_;
    ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* device_hindi_inscript_layout_enabled_;
    ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* login_screen_extension_manifest_v2_availability_;
    ::enterprise_management::DeviceScreensaverEnabledProto* device_screensaver_enabled_;
    ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* device_screensaver_idle_timeout_seconds_;
    ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* device_screensaver_image_display_interval_seconds_;
    ::enterprise_management::DeviceScreensaverImagesProto* device_screensaver_images_;
    ::enterprise_management::DeviceSystemAecEnabledProto* device_system_aec_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chrome_5fdevice_5fpolicy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DevicePolicyRefreshRateProto

// optional int64 device_policy_refresh_rate = 1;
inline bool DevicePolicyRefreshRateProto::_internal_has_device_policy_refresh_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePolicyRefreshRateProto::has_device_policy_refresh_rate() const {
  return _internal_has_device_policy_refresh_rate();
}
inline void DevicePolicyRefreshRateProto::clear_device_policy_refresh_rate() {
  _impl_.device_policy_refresh_rate_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t DevicePolicyRefreshRateProto::_internal_device_policy_refresh_rate() const {
  return _impl_.device_policy_refresh_rate_;
}
inline int64_t DevicePolicyRefreshRateProto::device_policy_refresh_rate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePolicyRefreshRateProto.device_policy_refresh_rate)
  return _internal_device_policy_refresh_rate();
}
inline void DevicePolicyRefreshRateProto::_internal_set_device_policy_refresh_rate(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_policy_refresh_rate_ = value;
}
inline void DevicePolicyRefreshRateProto::set_device_policy_refresh_rate(int64_t value) {
  _internal_set_device_policy_refresh_rate(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePolicyRefreshRateProto.device_policy_refresh_rate)
}

// -------------------------------------------------------------------

// UserWhitelistProto

// repeated string user_whitelist = 1;
inline int UserWhitelistProto::_internal_user_whitelist_size() const {
  return _impl_.user_whitelist_.size();
}
inline int UserWhitelistProto::user_whitelist_size() const {
  return _internal_user_whitelist_size();
}
inline void UserWhitelistProto::clear_user_whitelist() {
  _impl_.user_whitelist_.Clear();
}
inline std::string* UserWhitelistProto::add_user_whitelist() {
  std::string* _s = _internal_add_user_whitelist();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.UserWhitelistProto.user_whitelist)
  return _s;
}
inline const std::string& UserWhitelistProto::_internal_user_whitelist(int index) const {
  return _impl_.user_whitelist_.Get(index);
}
inline const std::string& UserWhitelistProto::user_whitelist(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.UserWhitelistProto.user_whitelist)
  return _internal_user_whitelist(index);
}
inline std::string* UserWhitelistProto::mutable_user_whitelist(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.UserWhitelistProto.user_whitelist)
  return _impl_.user_whitelist_.Mutable(index);
}
inline void UserWhitelistProto::set_user_whitelist(int index, const std::string& value) {
  _impl_.user_whitelist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UserWhitelistProto.user_whitelist)
}
inline void UserWhitelistProto::set_user_whitelist(int index, std::string&& value) {
  _impl_.user_whitelist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.UserWhitelistProto.user_whitelist)
}
inline void UserWhitelistProto::set_user_whitelist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_whitelist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.UserWhitelistProto.user_whitelist)
}
inline void UserWhitelistProto::set_user_whitelist(int index, const char* value, size_t size) {
  _impl_.user_whitelist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.UserWhitelistProto.user_whitelist)
}
inline std::string* UserWhitelistProto::_internal_add_user_whitelist() {
  return _impl_.user_whitelist_.Add();
}
inline void UserWhitelistProto::add_user_whitelist(const std::string& value) {
  _impl_.user_whitelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.UserWhitelistProto.user_whitelist)
}
inline void UserWhitelistProto::add_user_whitelist(std::string&& value) {
  _impl_.user_whitelist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.UserWhitelistProto.user_whitelist)
}
inline void UserWhitelistProto::add_user_whitelist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_whitelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.UserWhitelistProto.user_whitelist)
}
inline void UserWhitelistProto::add_user_whitelist(const char* value, size_t size) {
  _impl_.user_whitelist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.UserWhitelistProto.user_whitelist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserWhitelistProto::user_whitelist() const {
  // @@protoc_insertion_point(field_list:enterprise_management.UserWhitelistProto.user_whitelist)
  return _impl_.user_whitelist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserWhitelistProto::mutable_user_whitelist() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.UserWhitelistProto.user_whitelist)
  return &_impl_.user_whitelist_;
}

// -------------------------------------------------------------------

// UserAllowlistProto

// repeated string user_allowlist = 1;
inline int UserAllowlistProto::_internal_user_allowlist_size() const {
  return _impl_.user_allowlist_.size();
}
inline int UserAllowlistProto::user_allowlist_size() const {
  return _internal_user_allowlist_size();
}
inline void UserAllowlistProto::clear_user_allowlist() {
  _impl_.user_allowlist_.Clear();
}
inline std::string* UserAllowlistProto::add_user_allowlist() {
  std::string* _s = _internal_add_user_allowlist();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.UserAllowlistProto.user_allowlist)
  return _s;
}
inline const std::string& UserAllowlistProto::_internal_user_allowlist(int index) const {
  return _impl_.user_allowlist_.Get(index);
}
inline const std::string& UserAllowlistProto::user_allowlist(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.UserAllowlistProto.user_allowlist)
  return _internal_user_allowlist(index);
}
inline std::string* UserAllowlistProto::mutable_user_allowlist(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.UserAllowlistProto.user_allowlist)
  return _impl_.user_allowlist_.Mutable(index);
}
inline void UserAllowlistProto::set_user_allowlist(int index, const std::string& value) {
  _impl_.user_allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UserAllowlistProto.user_allowlist)
}
inline void UserAllowlistProto::set_user_allowlist(int index, std::string&& value) {
  _impl_.user_allowlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.UserAllowlistProto.user_allowlist)
}
inline void UserAllowlistProto::set_user_allowlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.UserAllowlistProto.user_allowlist)
}
inline void UserAllowlistProto::set_user_allowlist(int index, const char* value, size_t size) {
  _impl_.user_allowlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.UserAllowlistProto.user_allowlist)
}
inline std::string* UserAllowlistProto::_internal_add_user_allowlist() {
  return _impl_.user_allowlist_.Add();
}
inline void UserAllowlistProto::add_user_allowlist(const std::string& value) {
  _impl_.user_allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.UserAllowlistProto.user_allowlist)
}
inline void UserAllowlistProto::add_user_allowlist(std::string&& value) {
  _impl_.user_allowlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.UserAllowlistProto.user_allowlist)
}
inline void UserAllowlistProto::add_user_allowlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.UserAllowlistProto.user_allowlist)
}
inline void UserAllowlistProto::add_user_allowlist(const char* value, size_t size) {
  _impl_.user_allowlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.UserAllowlistProto.user_allowlist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserAllowlistProto::user_allowlist() const {
  // @@protoc_insertion_point(field_list:enterprise_management.UserAllowlistProto.user_allowlist)
  return _impl_.user_allowlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserAllowlistProto::mutable_user_allowlist() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.UserAllowlistProto.user_allowlist)
  return &_impl_.user_allowlist_;
}

// -------------------------------------------------------------------

// AllowNewUsersProto

// optional bool allow_new_users = 1 [default = true];
inline bool AllowNewUsersProto::_internal_has_allow_new_users() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllowNewUsersProto::has_allow_new_users() const {
  return _internal_has_allow_new_users();
}
inline void AllowNewUsersProto::clear_allow_new_users() {
  _impl_.allow_new_users_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AllowNewUsersProto::_internal_allow_new_users() const {
  return _impl_.allow_new_users_;
}
inline bool AllowNewUsersProto::allow_new_users() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AllowNewUsersProto.allow_new_users)
  return _internal_allow_new_users();
}
inline void AllowNewUsersProto::_internal_set_allow_new_users(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allow_new_users_ = value;
}
inline void AllowNewUsersProto::set_allow_new_users(bool value) {
  _internal_set_allow_new_users(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AllowNewUsersProto.allow_new_users)
}

// -------------------------------------------------------------------

// GuestModeEnabledProto

// optional bool guest_mode_enabled = 1 [default = true];
inline bool GuestModeEnabledProto::_internal_has_guest_mode_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GuestModeEnabledProto::has_guest_mode_enabled() const {
  return _internal_has_guest_mode_enabled();
}
inline void GuestModeEnabledProto::clear_guest_mode_enabled() {
  _impl_.guest_mode_enabled_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool GuestModeEnabledProto::_internal_guest_mode_enabled() const {
  return _impl_.guest_mode_enabled_;
}
inline bool GuestModeEnabledProto::guest_mode_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.GuestModeEnabledProto.guest_mode_enabled)
  return _internal_guest_mode_enabled();
}
inline void GuestModeEnabledProto::_internal_set_guest_mode_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.guest_mode_enabled_ = value;
}
inline void GuestModeEnabledProto::set_guest_mode_enabled(bool value) {
  _internal_set_guest_mode_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.GuestModeEnabledProto.guest_mode_enabled)
}

// -------------------------------------------------------------------

// ShowUserNamesOnSigninProto

// optional bool show_user_names = 1 [default = true];
inline bool ShowUserNamesOnSigninProto::_internal_has_show_user_names() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowUserNamesOnSigninProto::has_show_user_names() const {
  return _internal_has_show_user_names();
}
inline void ShowUserNamesOnSigninProto::clear_show_user_names() {
  _impl_.show_user_names_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ShowUserNamesOnSigninProto::_internal_show_user_names() const {
  return _impl_.show_user_names_;
}
inline bool ShowUserNamesOnSigninProto::show_user_names() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ShowUserNamesOnSigninProto.show_user_names)
  return _internal_show_user_names();
}
inline void ShowUserNamesOnSigninProto::_internal_set_show_user_names(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.show_user_names_ = value;
}
inline void ShowUserNamesOnSigninProto::set_show_user_names(bool value) {
  _internal_set_show_user_names(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ShowUserNamesOnSigninProto.show_user_names)
}

// -------------------------------------------------------------------

// DataRoamingEnabledProto

// optional bool data_roaming_enabled = 1 [default = false];
inline bool DataRoamingEnabledProto::_internal_has_data_roaming_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataRoamingEnabledProto::has_data_roaming_enabled() const {
  return _internal_has_data_roaming_enabled();
}
inline void DataRoamingEnabledProto::clear_data_roaming_enabled() {
  _impl_.data_roaming_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DataRoamingEnabledProto::_internal_data_roaming_enabled() const {
  return _impl_.data_roaming_enabled_;
}
inline bool DataRoamingEnabledProto::data_roaming_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DataRoamingEnabledProto.data_roaming_enabled)
  return _internal_data_roaming_enabled();
}
inline void DataRoamingEnabledProto::_internal_set_data_roaming_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_roaming_enabled_ = value;
}
inline void DataRoamingEnabledProto::set_data_roaming_enabled(bool value) {
  _internal_set_data_roaming_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DataRoamingEnabledProto.data_roaming_enabled)
}

// -------------------------------------------------------------------

// OBSOLETE_DeviceProxySettingsProto

// optional string OBSOLETE_proxy_mode = 1 [deprecated = true];
inline bool OBSOLETE_DeviceProxySettingsProto::_internal_has_obsolete_proxy_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_DeviceProxySettingsProto::has_obsolete_proxy_mode() const {
  return _internal_has_obsolete_proxy_mode();
}
inline void OBSOLETE_DeviceProxySettingsProto::clear_obsolete_proxy_mode() {
  _impl_.obsolete_proxy_mode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OBSOLETE_DeviceProxySettingsProto::obsolete_proxy_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_mode)
  return _internal_obsolete_proxy_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_DeviceProxySettingsProto::set_obsolete_proxy_mode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.obsolete_proxy_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_mode)
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::mutable_obsolete_proxy_mode() {
  std::string* _s = _internal_mutable_obsolete_proxy_mode();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_mode)
  return _s;
}
inline const std::string& OBSOLETE_DeviceProxySettingsProto::_internal_obsolete_proxy_mode() const {
  return _impl_.obsolete_proxy_mode_.Get();
}
inline void OBSOLETE_DeviceProxySettingsProto::_internal_set_obsolete_proxy_mode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_proxy_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::_internal_mutable_obsolete_proxy_mode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.obsolete_proxy_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::release_obsolete_proxy_mode() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_mode)
  if (!_internal_has_obsolete_proxy_mode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.obsolete_proxy_mode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_proxy_mode_.IsDefault()) {
    _impl_.obsolete_proxy_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_DeviceProxySettingsProto::set_allocated_obsolete_proxy_mode(std::string* obsolete_proxy_mode) {
  if (obsolete_proxy_mode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obsolete_proxy_mode_.SetAllocated(obsolete_proxy_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_proxy_mode_.IsDefault()) {
    _impl_.obsolete_proxy_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_mode)
}

// optional string OBSOLETE_proxy_server = 2 [deprecated = true];
inline bool OBSOLETE_DeviceProxySettingsProto::_internal_has_obsolete_proxy_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OBSOLETE_DeviceProxySettingsProto::has_obsolete_proxy_server() const {
  return _internal_has_obsolete_proxy_server();
}
inline void OBSOLETE_DeviceProxySettingsProto::clear_obsolete_proxy_server() {
  _impl_.obsolete_proxy_server_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OBSOLETE_DeviceProxySettingsProto::obsolete_proxy_server() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_server)
  return _internal_obsolete_proxy_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_DeviceProxySettingsProto::set_obsolete_proxy_server(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.obsolete_proxy_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_server)
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::mutable_obsolete_proxy_server() {
  std::string* _s = _internal_mutable_obsolete_proxy_server();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_server)
  return _s;
}
inline const std::string& OBSOLETE_DeviceProxySettingsProto::_internal_obsolete_proxy_server() const {
  return _impl_.obsolete_proxy_server_.Get();
}
inline void OBSOLETE_DeviceProxySettingsProto::_internal_set_obsolete_proxy_server(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.obsolete_proxy_server_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::_internal_mutable_obsolete_proxy_server() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.obsolete_proxy_server_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::release_obsolete_proxy_server() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_server)
  if (!_internal_has_obsolete_proxy_server()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.obsolete_proxy_server_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_proxy_server_.IsDefault()) {
    _impl_.obsolete_proxy_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_DeviceProxySettingsProto::set_allocated_obsolete_proxy_server(std::string* obsolete_proxy_server) {
  if (obsolete_proxy_server != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.obsolete_proxy_server_.SetAllocated(obsolete_proxy_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_proxy_server_.IsDefault()) {
    _impl_.obsolete_proxy_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_server)
}

// optional string OBSOLETE_proxy_pac_url = 3 [deprecated = true];
inline bool OBSOLETE_DeviceProxySettingsProto::_internal_has_obsolete_proxy_pac_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OBSOLETE_DeviceProxySettingsProto::has_obsolete_proxy_pac_url() const {
  return _internal_has_obsolete_proxy_pac_url();
}
inline void OBSOLETE_DeviceProxySettingsProto::clear_obsolete_proxy_pac_url() {
  _impl_.obsolete_proxy_pac_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OBSOLETE_DeviceProxySettingsProto::obsolete_proxy_pac_url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_pac_url)
  return _internal_obsolete_proxy_pac_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_DeviceProxySettingsProto::set_obsolete_proxy_pac_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.obsolete_proxy_pac_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_pac_url)
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::mutable_obsolete_proxy_pac_url() {
  std::string* _s = _internal_mutable_obsolete_proxy_pac_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_pac_url)
  return _s;
}
inline const std::string& OBSOLETE_DeviceProxySettingsProto::_internal_obsolete_proxy_pac_url() const {
  return _impl_.obsolete_proxy_pac_url_.Get();
}
inline void OBSOLETE_DeviceProxySettingsProto::_internal_set_obsolete_proxy_pac_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.obsolete_proxy_pac_url_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::_internal_mutable_obsolete_proxy_pac_url() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.obsolete_proxy_pac_url_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::release_obsolete_proxy_pac_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_pac_url)
  if (!_internal_has_obsolete_proxy_pac_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.obsolete_proxy_pac_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_proxy_pac_url_.IsDefault()) {
    _impl_.obsolete_proxy_pac_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_DeviceProxySettingsProto::set_allocated_obsolete_proxy_pac_url(std::string* obsolete_proxy_pac_url) {
  if (obsolete_proxy_pac_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.obsolete_proxy_pac_url_.SetAllocated(obsolete_proxy_pac_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_proxy_pac_url_.IsDefault()) {
    _impl_.obsolete_proxy_pac_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_pac_url)
}

// optional string OBSOLETE_proxy_bypass_list = 4 [deprecated = true];
inline bool OBSOLETE_DeviceProxySettingsProto::_internal_has_obsolete_proxy_bypass_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OBSOLETE_DeviceProxySettingsProto::has_obsolete_proxy_bypass_list() const {
  return _internal_has_obsolete_proxy_bypass_list();
}
inline void OBSOLETE_DeviceProxySettingsProto::clear_obsolete_proxy_bypass_list() {
  _impl_.obsolete_proxy_bypass_list_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& OBSOLETE_DeviceProxySettingsProto::obsolete_proxy_bypass_list() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_bypass_list)
  return _internal_obsolete_proxy_bypass_list();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_DeviceProxySettingsProto::set_obsolete_proxy_bypass_list(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.obsolete_proxy_bypass_list_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_bypass_list)
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::mutable_obsolete_proxy_bypass_list() {
  std::string* _s = _internal_mutable_obsolete_proxy_bypass_list();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_bypass_list)
  return _s;
}
inline const std::string& OBSOLETE_DeviceProxySettingsProto::_internal_obsolete_proxy_bypass_list() const {
  return _impl_.obsolete_proxy_bypass_list_.Get();
}
inline void OBSOLETE_DeviceProxySettingsProto::_internal_set_obsolete_proxy_bypass_list(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.obsolete_proxy_bypass_list_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::_internal_mutable_obsolete_proxy_bypass_list() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.obsolete_proxy_bypass_list_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceProxySettingsProto::release_obsolete_proxy_bypass_list() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_bypass_list)
  if (!_internal_has_obsolete_proxy_bypass_list()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.obsolete_proxy_bypass_list_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_proxy_bypass_list_.IsDefault()) {
    _impl_.obsolete_proxy_bypass_list_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_DeviceProxySettingsProto::set_allocated_obsolete_proxy_bypass_list(std::string* obsolete_proxy_bypass_list) {
  if (obsolete_proxy_bypass_list != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.obsolete_proxy_bypass_list_.SetAllocated(obsolete_proxy_bypass_list, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_proxy_bypass_list_.IsDefault()) {
    _impl_.obsolete_proxy_bypass_list_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_DeviceProxySettingsProto.OBSOLETE_proxy_bypass_list)
}

// -------------------------------------------------------------------

// CameraEnabledProto

// optional bool camera_enabled = 1;
inline bool CameraEnabledProto::_internal_has_camera_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CameraEnabledProto::has_camera_enabled() const {
  return _internal_has_camera_enabled();
}
inline void CameraEnabledProto::clear_camera_enabled() {
  _impl_.camera_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CameraEnabledProto::_internal_camera_enabled() const {
  return _impl_.camera_enabled_;
}
inline bool CameraEnabledProto::camera_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CameraEnabledProto.camera_enabled)
  return _internal_camera_enabled();
}
inline void CameraEnabledProto::_internal_set_camera_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.camera_enabled_ = value;
}
inline void CameraEnabledProto::set_camera_enabled(bool value) {
  _internal_set_camera_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CameraEnabledProto.camera_enabled)
}

// -------------------------------------------------------------------

// MetricsEnabledProto

// optional bool metrics_enabled = 1;
inline bool MetricsEnabledProto::_internal_has_metrics_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MetricsEnabledProto::has_metrics_enabled() const {
  return _internal_has_metrics_enabled();
}
inline void MetricsEnabledProto::clear_metrics_enabled() {
  _impl_.metrics_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MetricsEnabledProto::_internal_metrics_enabled() const {
  return _impl_.metrics_enabled_;
}
inline bool MetricsEnabledProto::metrics_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.MetricsEnabledProto.metrics_enabled)
  return _internal_metrics_enabled();
}
inline void MetricsEnabledProto::_internal_set_metrics_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metrics_enabled_ = value;
}
inline void MetricsEnabledProto::set_metrics_enabled(bool value) {
  _internal_set_metrics_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.MetricsEnabledProto.metrics_enabled)
}

// -------------------------------------------------------------------

// ReleaseChannelProto

// optional string release_channel = 1;
inline bool ReleaseChannelProto::_internal_has_release_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReleaseChannelProto::has_release_channel() const {
  return _internal_has_release_channel();
}
inline void ReleaseChannelProto::clear_release_channel() {
  _impl_.release_channel_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReleaseChannelProto::release_channel() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ReleaseChannelProto.release_channel)
  return _internal_release_channel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReleaseChannelProto::set_release_channel(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.release_channel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ReleaseChannelProto.release_channel)
}
inline std::string* ReleaseChannelProto::mutable_release_channel() {
  std::string* _s = _internal_mutable_release_channel();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ReleaseChannelProto.release_channel)
  return _s;
}
inline const std::string& ReleaseChannelProto::_internal_release_channel() const {
  return _impl_.release_channel_.Get();
}
inline void ReleaseChannelProto::_internal_set_release_channel(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.release_channel_.Set(value, GetArenaForAllocation());
}
inline std::string* ReleaseChannelProto::_internal_mutable_release_channel() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.release_channel_.Mutable(GetArenaForAllocation());
}
inline std::string* ReleaseChannelProto::release_release_channel() {
  // @@protoc_insertion_point(field_release:enterprise_management.ReleaseChannelProto.release_channel)
  if (!_internal_has_release_channel()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.release_channel_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.release_channel_.IsDefault()) {
    _impl_.release_channel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReleaseChannelProto::set_allocated_release_channel(std::string* release_channel) {
  if (release_channel != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.release_channel_.SetAllocated(release_channel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.release_channel_.IsDefault()) {
    _impl_.release_channel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ReleaseChannelProto.release_channel)
}

// optional bool release_channel_delegated = 2;
inline bool ReleaseChannelProto::_internal_has_release_channel_delegated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReleaseChannelProto::has_release_channel_delegated() const {
  return _internal_has_release_channel_delegated();
}
inline void ReleaseChannelProto::clear_release_channel_delegated() {
  _impl_.release_channel_delegated_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ReleaseChannelProto::_internal_release_channel_delegated() const {
  return _impl_.release_channel_delegated_;
}
inline bool ReleaseChannelProto::release_channel_delegated() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ReleaseChannelProto.release_channel_delegated)
  return _internal_release_channel_delegated();
}
inline void ReleaseChannelProto::_internal_set_release_channel_delegated(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.release_channel_delegated_ = value;
}
inline void ReleaseChannelProto::set_release_channel_delegated(bool value) {
  _internal_set_release_channel_delegated(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ReleaseChannelProto.release_channel_delegated)
}

// optional string release_lts_tag = 3;
inline bool ReleaseChannelProto::_internal_has_release_lts_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReleaseChannelProto::has_release_lts_tag() const {
  return _internal_has_release_lts_tag();
}
inline void ReleaseChannelProto::clear_release_lts_tag() {
  _impl_.release_lts_tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReleaseChannelProto::release_lts_tag() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ReleaseChannelProto.release_lts_tag)
  return _internal_release_lts_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReleaseChannelProto::set_release_lts_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.release_lts_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ReleaseChannelProto.release_lts_tag)
}
inline std::string* ReleaseChannelProto::mutable_release_lts_tag() {
  std::string* _s = _internal_mutable_release_lts_tag();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ReleaseChannelProto.release_lts_tag)
  return _s;
}
inline const std::string& ReleaseChannelProto::_internal_release_lts_tag() const {
  return _impl_.release_lts_tag_.Get();
}
inline void ReleaseChannelProto::_internal_set_release_lts_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.release_lts_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ReleaseChannelProto::_internal_mutable_release_lts_tag() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.release_lts_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ReleaseChannelProto::release_release_lts_tag() {
  // @@protoc_insertion_point(field_release:enterprise_management.ReleaseChannelProto.release_lts_tag)
  if (!_internal_has_release_lts_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.release_lts_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.release_lts_tag_.IsDefault()) {
    _impl_.release_lts_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReleaseChannelProto::set_allocated_release_lts_tag(std::string* release_lts_tag) {
  if (release_lts_tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.release_lts_tag_.SetAllocated(release_lts_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.release_lts_tag_.IsDefault()) {
    _impl_.release_lts_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ReleaseChannelProto.release_lts_tag)
}

// -------------------------------------------------------------------

// DeviceOpenNetworkConfigurationProto

// optional string open_network_configuration = 1;
inline bool DeviceOpenNetworkConfigurationProto::_internal_has_open_network_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceOpenNetworkConfigurationProto::has_open_network_configuration() const {
  return _internal_has_open_network_configuration();
}
inline void DeviceOpenNetworkConfigurationProto::clear_open_network_configuration() {
  _impl_.open_network_configuration_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceOpenNetworkConfigurationProto::open_network_configuration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceOpenNetworkConfigurationProto.open_network_configuration)
  return _internal_open_network_configuration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceOpenNetworkConfigurationProto::set_open_network_configuration(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.open_network_configuration_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceOpenNetworkConfigurationProto.open_network_configuration)
}
inline std::string* DeviceOpenNetworkConfigurationProto::mutable_open_network_configuration() {
  std::string* _s = _internal_mutable_open_network_configuration();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceOpenNetworkConfigurationProto.open_network_configuration)
  return _s;
}
inline const std::string& DeviceOpenNetworkConfigurationProto::_internal_open_network_configuration() const {
  return _impl_.open_network_configuration_.Get();
}
inline void DeviceOpenNetworkConfigurationProto::_internal_set_open_network_configuration(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.open_network_configuration_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceOpenNetworkConfigurationProto::_internal_mutable_open_network_configuration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.open_network_configuration_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceOpenNetworkConfigurationProto::release_open_network_configuration() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceOpenNetworkConfigurationProto.open_network_configuration)
  if (!_internal_has_open_network_configuration()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.open_network_configuration_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.open_network_configuration_.IsDefault()) {
    _impl_.open_network_configuration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceOpenNetworkConfigurationProto::set_allocated_open_network_configuration(std::string* open_network_configuration) {
  if (open_network_configuration != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.open_network_configuration_.SetAllocated(open_network_configuration, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.open_network_configuration_.IsDefault()) {
    _impl_.open_network_configuration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceOpenNetworkConfigurationProto.open_network_configuration)
}

// -------------------------------------------------------------------

// NetworkHostnameProto

// optional string device_hostname_template = 1;
inline bool NetworkHostnameProto::_internal_has_device_hostname_template() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetworkHostnameProto::has_device_hostname_template() const {
  return _internal_has_device_hostname_template();
}
inline void NetworkHostnameProto::clear_device_hostname_template() {
  _impl_.device_hostname_template_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkHostnameProto::device_hostname_template() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkHostnameProto.device_hostname_template)
  return _internal_device_hostname_template();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkHostnameProto::set_device_hostname_template(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_hostname_template_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkHostnameProto.device_hostname_template)
}
inline std::string* NetworkHostnameProto::mutable_device_hostname_template() {
  std::string* _s = _internal_mutable_device_hostname_template();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkHostnameProto.device_hostname_template)
  return _s;
}
inline const std::string& NetworkHostnameProto::_internal_device_hostname_template() const {
  return _impl_.device_hostname_template_.Get();
}
inline void NetworkHostnameProto::_internal_set_device_hostname_template(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_hostname_template_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkHostnameProto::_internal_mutable_device_hostname_template() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_hostname_template_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkHostnameProto::release_device_hostname_template() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkHostnameProto.device_hostname_template)
  if (!_internal_has_device_hostname_template()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_hostname_template_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_hostname_template_.IsDefault()) {
    _impl_.device_hostname_template_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkHostnameProto::set_allocated_device_hostname_template(std::string* device_hostname_template) {
  if (device_hostname_template != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_hostname_template_.SetAllocated(device_hostname_template, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_hostname_template_.IsDefault()) {
    _impl_.device_hostname_template_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkHostnameProto.device_hostname_template)
}

// -------------------------------------------------------------------

// DeviceHindiInscriptLayoutEnabledProto

// optional bool enabled = 1 [default = false];
inline bool DeviceHindiInscriptLayoutEnabledProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceHindiInscriptLayoutEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceHindiInscriptLayoutEnabledProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceHindiInscriptLayoutEnabledProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceHindiInscriptLayoutEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceHindiInscriptLayoutEnabledProto.enabled)
  return _internal_enabled();
}
inline void DeviceHindiInscriptLayoutEnabledProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceHindiInscriptLayoutEnabledProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceHindiInscriptLayoutEnabledProto.enabled)
}

// -------------------------------------------------------------------

// HostnameUserConfigurableProto

// optional bool device_hostname_user_configurable = 1 [default = false];
inline bool HostnameUserConfigurableProto::_internal_has_device_hostname_user_configurable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HostnameUserConfigurableProto::has_device_hostname_user_configurable() const {
  return _internal_has_device_hostname_user_configurable();
}
inline void HostnameUserConfigurableProto::clear_device_hostname_user_configurable() {
  _impl_.device_hostname_user_configurable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool HostnameUserConfigurableProto::_internal_device_hostname_user_configurable() const {
  return _impl_.device_hostname_user_configurable_;
}
inline bool HostnameUserConfigurableProto::device_hostname_user_configurable() const {
  // @@protoc_insertion_point(field_get:enterprise_management.HostnameUserConfigurableProto.device_hostname_user_configurable)
  return _internal_device_hostname_user_configurable();
}
inline void HostnameUserConfigurableProto::_internal_set_device_hostname_user_configurable(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_hostname_user_configurable_ = value;
}
inline void HostnameUserConfigurableProto::set_device_hostname_user_configurable(bool value) {
  _internal_set_device_hostname_user_configurable(value);
  // @@protoc_insertion_point(field_set:enterprise_management.HostnameUserConfigurableProto.device_hostname_user_configurable)
}

// -------------------------------------------------------------------

// DeviceReportingProto

// optional bool report_version_info = 1 [default = true];
inline bool DeviceReportingProto::_internal_has_report_version_info() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_version_info() const {
  return _internal_has_report_version_info();
}
inline void DeviceReportingProto::clear_report_version_info() {
  _impl_.report_version_info_ = true;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline bool DeviceReportingProto::_internal_report_version_info() const {
  return _impl_.report_version_info_;
}
inline bool DeviceReportingProto::report_version_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_version_info)
  return _internal_report_version_info();
}
inline void DeviceReportingProto::_internal_set_report_version_info(bool value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.report_version_info_ = value;
}
inline void DeviceReportingProto::set_report_version_info(bool value) {
  _internal_set_report_version_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_version_info)
}

// optional bool report_activity_times = 2 [default = true];
inline bool DeviceReportingProto::_internal_has_report_activity_times() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_activity_times() const {
  return _internal_has_report_activity_times();
}
inline void DeviceReportingProto::clear_report_activity_times() {
  _impl_.report_activity_times_ = true;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline bool DeviceReportingProto::_internal_report_activity_times() const {
  return _impl_.report_activity_times_;
}
inline bool DeviceReportingProto::report_activity_times() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_activity_times)
  return _internal_report_activity_times();
}
inline void DeviceReportingProto::_internal_set_report_activity_times(bool value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.report_activity_times_ = value;
}
inline void DeviceReportingProto::set_report_activity_times(bool value) {
  _internal_set_report_activity_times(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_activity_times)
}

// optional bool report_boot_mode = 3 [default = true];
inline bool DeviceReportingProto::_internal_has_report_boot_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_boot_mode() const {
  return _internal_has_report_boot_mode();
}
inline void DeviceReportingProto::clear_report_boot_mode() {
  _impl_.report_boot_mode_ = true;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline bool DeviceReportingProto::_internal_report_boot_mode() const {
  return _impl_.report_boot_mode_;
}
inline bool DeviceReportingProto::report_boot_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_boot_mode)
  return _internal_report_boot_mode();
}
inline void DeviceReportingProto::_internal_set_report_boot_mode(bool value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.report_boot_mode_ = value;
}
inline void DeviceReportingProto::set_report_boot_mode(bool value) {
  _internal_set_report_boot_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_boot_mode)
}

// optional bool report_location = 4 [default = false];
inline bool DeviceReportingProto::_internal_has_report_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_location() const {
  return _internal_has_report_location();
}
inline void DeviceReportingProto::clear_report_location() {
  _impl_.report_location_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DeviceReportingProto::_internal_report_location() const {
  return _impl_.report_location_;
}
inline bool DeviceReportingProto::report_location() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_location)
  return _internal_report_location();
}
inline void DeviceReportingProto::_internal_set_report_location(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.report_location_ = value;
}
inline void DeviceReportingProto::set_report_location(bool value) {
  _internal_set_report_location(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_location)
}

// optional bool report_network_interfaces = 5 [default = true, deprecated = true];
inline bool DeviceReportingProto::_internal_has_report_network_interfaces() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_network_interfaces() const {
  return _internal_has_report_network_interfaces();
}
inline void DeviceReportingProto::clear_report_network_interfaces() {
  _impl_.report_network_interfaces_ = true;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline bool DeviceReportingProto::_internal_report_network_interfaces() const {
  return _impl_.report_network_interfaces_;
}
inline bool DeviceReportingProto::report_network_interfaces() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_network_interfaces)
  return _internal_report_network_interfaces();
}
inline void DeviceReportingProto::_internal_set_report_network_interfaces(bool value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.report_network_interfaces_ = value;
}
inline void DeviceReportingProto::set_report_network_interfaces(bool value) {
  _internal_set_report_network_interfaces(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_network_interfaces)
}

// optional bool report_users = 6 [default = true];
inline bool DeviceReportingProto::_internal_has_report_users() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_users() const {
  return _internal_has_report_users();
}
inline void DeviceReportingProto::clear_report_users() {
  _impl_.report_users_ = true;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline bool DeviceReportingProto::_internal_report_users() const {
  return _impl_.report_users_;
}
inline bool DeviceReportingProto::report_users() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_users)
  return _internal_report_users();
}
inline void DeviceReportingProto::_internal_set_report_users(bool value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.report_users_ = value;
}
inline void DeviceReportingProto::set_report_users(bool value) {
  _internal_set_report_users(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_users)
}

// optional bool report_hardware_status = 7 [default = true, deprecated = true];
inline bool DeviceReportingProto::_internal_has_report_hardware_status() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_hardware_status() const {
  return _internal_has_report_hardware_status();
}
inline void DeviceReportingProto::clear_report_hardware_status() {
  _impl_.report_hardware_status_ = true;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline bool DeviceReportingProto::_internal_report_hardware_status() const {
  return _impl_.report_hardware_status_;
}
inline bool DeviceReportingProto::report_hardware_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_hardware_status)
  return _internal_report_hardware_status();
}
inline void DeviceReportingProto::_internal_set_report_hardware_status(bool value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.report_hardware_status_ = value;
}
inline void DeviceReportingProto::set_report_hardware_status(bool value) {
  _internal_set_report_hardware_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_hardware_status)
}

// optional bool report_session_status = 8 [default = true];
inline bool DeviceReportingProto::_internal_has_report_session_status() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_session_status() const {
  return _internal_has_report_session_status();
}
inline void DeviceReportingProto::clear_report_session_status() {
  _impl_.report_session_status_ = true;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline bool DeviceReportingProto::_internal_report_session_status() const {
  return _impl_.report_session_status_;
}
inline bool DeviceReportingProto::report_session_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_session_status)
  return _internal_report_session_status();
}
inline void DeviceReportingProto::_internal_set_report_session_status(bool value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.report_session_status_ = value;
}
inline void DeviceReportingProto::set_report_session_status(bool value) {
  _internal_set_report_session_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_session_status)
}

// optional bool report_os_update_status = 10 [default = false];
inline bool DeviceReportingProto::_internal_has_report_os_update_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_os_update_status() const {
  return _internal_has_report_os_update_status();
}
inline void DeviceReportingProto::clear_report_os_update_status() {
  _impl_.report_os_update_status_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool DeviceReportingProto::_internal_report_os_update_status() const {
  return _impl_.report_os_update_status_;
}
inline bool DeviceReportingProto::report_os_update_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_os_update_status)
  return _internal_report_os_update_status();
}
inline void DeviceReportingProto::_internal_set_report_os_update_status(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.report_os_update_status_ = value;
}
inline void DeviceReportingProto::set_report_os_update_status(bool value) {
  _internal_set_report_os_update_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_os_update_status)
}

// optional bool report_running_kiosk_app = 11 [default = false];
inline bool DeviceReportingProto::_internal_has_report_running_kiosk_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_running_kiosk_app() const {
  return _internal_has_report_running_kiosk_app();
}
inline void DeviceReportingProto::clear_report_running_kiosk_app() {
  _impl_.report_running_kiosk_app_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DeviceReportingProto::_internal_report_running_kiosk_app() const {
  return _impl_.report_running_kiosk_app_;
}
inline bool DeviceReportingProto::report_running_kiosk_app() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_running_kiosk_app)
  return _internal_report_running_kiosk_app();
}
inline void DeviceReportingProto::_internal_set_report_running_kiosk_app(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.report_running_kiosk_app_ = value;
}
inline void DeviceReportingProto::set_report_running_kiosk_app(bool value) {
  _internal_set_report_running_kiosk_app(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_running_kiosk_app)
}

// optional bool report_power_status = 12 [default = false];
inline bool DeviceReportingProto::_internal_has_report_power_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_power_status() const {
  return _internal_has_report_power_status();
}
inline void DeviceReportingProto::clear_report_power_status() {
  _impl_.report_power_status_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool DeviceReportingProto::_internal_report_power_status() const {
  return _impl_.report_power_status_;
}
inline bool DeviceReportingProto::report_power_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_power_status)
  return _internal_report_power_status();
}
inline void DeviceReportingProto::_internal_set_report_power_status(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.report_power_status_ = value;
}
inline void DeviceReportingProto::set_report_power_status(bool value) {
  _internal_set_report_power_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_power_status)
}

// optional bool report_storage_status = 13 [default = false];
inline bool DeviceReportingProto::_internal_has_report_storage_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_storage_status() const {
  return _internal_has_report_storage_status();
}
inline void DeviceReportingProto::clear_report_storage_status() {
  _impl_.report_storage_status_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool DeviceReportingProto::_internal_report_storage_status() const {
  return _impl_.report_storage_status_;
}
inline bool DeviceReportingProto::report_storage_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_storage_status)
  return _internal_report_storage_status();
}
inline void DeviceReportingProto::_internal_set_report_storage_status(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.report_storage_status_ = value;
}
inline void DeviceReportingProto::set_report_storage_status(bool value) {
  _internal_set_report_storage_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_storage_status)
}

// optional bool report_board_status = 14 [default = false];
inline bool DeviceReportingProto::_internal_has_report_board_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_board_status() const {
  return _internal_has_report_board_status();
}
inline void DeviceReportingProto::clear_report_board_status() {
  _impl_.report_board_status_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool DeviceReportingProto::_internal_report_board_status() const {
  return _impl_.report_board_status_;
}
inline bool DeviceReportingProto::report_board_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_board_status)
  return _internal_report_board_status();
}
inline void DeviceReportingProto::_internal_set_report_board_status(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.report_board_status_ = value;
}
inline void DeviceReportingProto::set_report_board_status(bool value) {
  _internal_set_report_board_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_board_status)
}

// optional bool report_cpu_info = 15 [default = false];
inline bool DeviceReportingProto::_internal_has_report_cpu_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_cpu_info() const {
  return _internal_has_report_cpu_info();
}
inline void DeviceReportingProto::clear_report_cpu_info() {
  _impl_.report_cpu_info_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool DeviceReportingProto::_internal_report_cpu_info() const {
  return _impl_.report_cpu_info_;
}
inline bool DeviceReportingProto::report_cpu_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_cpu_info)
  return _internal_report_cpu_info();
}
inline void DeviceReportingProto::_internal_set_report_cpu_info(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.report_cpu_info_ = value;
}
inline void DeviceReportingProto::set_report_cpu_info(bool value) {
  _internal_set_report_cpu_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_cpu_info)
}

// optional bool report_graphics_status = 16 [default = false];
inline bool DeviceReportingProto::_internal_has_report_graphics_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_graphics_status() const {
  return _internal_has_report_graphics_status();
}
inline void DeviceReportingProto::clear_report_graphics_status() {
  _impl_.report_graphics_status_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool DeviceReportingProto::_internal_report_graphics_status() const {
  return _impl_.report_graphics_status_;
}
inline bool DeviceReportingProto::report_graphics_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_graphics_status)
  return _internal_report_graphics_status();
}
inline void DeviceReportingProto::_internal_set_report_graphics_status(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.report_graphics_status_ = value;
}
inline void DeviceReportingProto::set_report_graphics_status(bool value) {
  _internal_set_report_graphics_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_graphics_status)
}

// optional bool report_crash_report_info = 17 [default = false];
inline bool DeviceReportingProto::_internal_has_report_crash_report_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_crash_report_info() const {
  return _internal_has_report_crash_report_info();
}
inline void DeviceReportingProto::clear_report_crash_report_info() {
  _impl_.report_crash_report_info_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool DeviceReportingProto::_internal_report_crash_report_info() const {
  return _impl_.report_crash_report_info_;
}
inline bool DeviceReportingProto::report_crash_report_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_crash_report_info)
  return _internal_report_crash_report_info();
}
inline void DeviceReportingProto::_internal_set_report_crash_report_info(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.report_crash_report_info_ = value;
}
inline void DeviceReportingProto::set_report_crash_report_info(bool value) {
  _internal_set_report_crash_report_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_crash_report_info)
}

// optional bool report_timezone_info = 18 [default = false];
inline bool DeviceReportingProto::_internal_has_report_timezone_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_timezone_info() const {
  return _internal_has_report_timezone_info();
}
inline void DeviceReportingProto::clear_report_timezone_info() {
  _impl_.report_timezone_info_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool DeviceReportingProto::_internal_report_timezone_info() const {
  return _impl_.report_timezone_info_;
}
inline bool DeviceReportingProto::report_timezone_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_timezone_info)
  return _internal_report_timezone_info();
}
inline void DeviceReportingProto::_internal_set_report_timezone_info(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.report_timezone_info_ = value;
}
inline void DeviceReportingProto::set_report_timezone_info(bool value) {
  _internal_set_report_timezone_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_timezone_info)
}

// optional bool report_memory_info = 19 [default = false];
inline bool DeviceReportingProto::_internal_has_report_memory_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_memory_info() const {
  return _internal_has_report_memory_info();
}
inline void DeviceReportingProto::clear_report_memory_info() {
  _impl_.report_memory_info_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool DeviceReportingProto::_internal_report_memory_info() const {
  return _impl_.report_memory_info_;
}
inline bool DeviceReportingProto::report_memory_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_memory_info)
  return _internal_report_memory_info();
}
inline void DeviceReportingProto::_internal_set_report_memory_info(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.report_memory_info_ = value;
}
inline void DeviceReportingProto::set_report_memory_info(bool value) {
  _internal_set_report_memory_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_memory_info)
}

// optional bool report_backlight_info = 20 [default = false];
inline bool DeviceReportingProto::_internal_has_report_backlight_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_backlight_info() const {
  return _internal_has_report_backlight_info();
}
inline void DeviceReportingProto::clear_report_backlight_info() {
  _impl_.report_backlight_info_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool DeviceReportingProto::_internal_report_backlight_info() const {
  return _impl_.report_backlight_info_;
}
inline bool DeviceReportingProto::report_backlight_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_backlight_info)
  return _internal_report_backlight_info();
}
inline void DeviceReportingProto::_internal_set_report_backlight_info(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.report_backlight_info_ = value;
}
inline void DeviceReportingProto::set_report_backlight_info(bool value) {
  _internal_set_report_backlight_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_backlight_info)
}

// optional bool report_app_info = 21 [default = false];
inline bool DeviceReportingProto::_internal_has_report_app_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_app_info() const {
  return _internal_has_report_app_info();
}
inline void DeviceReportingProto::clear_report_app_info() {
  _impl_.report_app_info_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool DeviceReportingProto::_internal_report_app_info() const {
  return _impl_.report_app_info_;
}
inline bool DeviceReportingProto::report_app_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_app_info)
  return _internal_report_app_info();
}
inline void DeviceReportingProto::_internal_set_report_app_info(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.report_app_info_ = value;
}
inline void DeviceReportingProto::set_report_app_info(bool value) {
  _internal_set_report_app_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_app_info)
}

// optional bool report_bluetooth_info = 22 [default = false];
inline bool DeviceReportingProto::_internal_has_report_bluetooth_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_bluetooth_info() const {
  return _internal_has_report_bluetooth_info();
}
inline void DeviceReportingProto::clear_report_bluetooth_info() {
  _impl_.report_bluetooth_info_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool DeviceReportingProto::_internal_report_bluetooth_info() const {
  return _impl_.report_bluetooth_info_;
}
inline bool DeviceReportingProto::report_bluetooth_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_bluetooth_info)
  return _internal_report_bluetooth_info();
}
inline void DeviceReportingProto::_internal_set_report_bluetooth_info(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.report_bluetooth_info_ = value;
}
inline void DeviceReportingProto::set_report_bluetooth_info(bool value) {
  _internal_set_report_bluetooth_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_bluetooth_info)
}

// optional bool report_fan_info = 23 [default = false];
inline bool DeviceReportingProto::_internal_has_report_fan_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_fan_info() const {
  return _internal_has_report_fan_info();
}
inline void DeviceReportingProto::clear_report_fan_info() {
  _impl_.report_fan_info_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool DeviceReportingProto::_internal_report_fan_info() const {
  return _impl_.report_fan_info_;
}
inline bool DeviceReportingProto::report_fan_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_fan_info)
  return _internal_report_fan_info();
}
inline void DeviceReportingProto::_internal_set_report_fan_info(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.report_fan_info_ = value;
}
inline void DeviceReportingProto::set_report_fan_info(bool value) {
  _internal_set_report_fan_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_fan_info)
}

// optional bool report_vpd_info = 24 [default = false];
inline bool DeviceReportingProto::_internal_has_report_vpd_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_vpd_info() const {
  return _internal_has_report_vpd_info();
}
inline void DeviceReportingProto::clear_report_vpd_info() {
  _impl_.report_vpd_info_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool DeviceReportingProto::_internal_report_vpd_info() const {
  return _impl_.report_vpd_info_;
}
inline bool DeviceReportingProto::report_vpd_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_vpd_info)
  return _internal_report_vpd_info();
}
inline void DeviceReportingProto::_internal_set_report_vpd_info(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.report_vpd_info_ = value;
}
inline void DeviceReportingProto::set_report_vpd_info(bool value) {
  _internal_set_report_vpd_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_vpd_info)
}

// optional bool report_system_info = 25 [default = false];
inline bool DeviceReportingProto::_internal_has_report_system_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_system_info() const {
  return _internal_has_report_system_info();
}
inline void DeviceReportingProto::clear_report_system_info() {
  _impl_.report_system_info_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool DeviceReportingProto::_internal_report_system_info() const {
  return _impl_.report_system_info_;
}
inline bool DeviceReportingProto::report_system_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_system_info)
  return _internal_report_system_info();
}
inline void DeviceReportingProto::_internal_set_report_system_info(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.report_system_info_ = value;
}
inline void DeviceReportingProto::set_report_system_info(bool value) {
  _internal_set_report_system_info(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_system_info)
}

// optional bool report_print_jobs = 26 [default = false];
inline bool DeviceReportingProto::_internal_has_report_print_jobs() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_print_jobs() const {
  return _internal_has_report_print_jobs();
}
inline void DeviceReportingProto::clear_report_print_jobs() {
  _impl_.report_print_jobs_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool DeviceReportingProto::_internal_report_print_jobs() const {
  return _impl_.report_print_jobs_;
}
inline bool DeviceReportingProto::report_print_jobs() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_print_jobs)
  return _internal_report_print_jobs();
}
inline void DeviceReportingProto::_internal_set_report_print_jobs(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.report_print_jobs_ = value;
}
inline void DeviceReportingProto::set_report_print_jobs(bool value) {
  _internal_set_report_print_jobs(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_print_jobs)
}

// optional bool report_login_logout = 27 [default = false];
inline bool DeviceReportingProto::_internal_has_report_login_logout() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_login_logout() const {
  return _internal_has_report_login_logout();
}
inline void DeviceReportingProto::clear_report_login_logout() {
  _impl_.report_login_logout_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool DeviceReportingProto::_internal_report_login_logout() const {
  return _impl_.report_login_logout_;
}
inline bool DeviceReportingProto::report_login_logout() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_login_logout)
  return _internal_report_login_logout();
}
inline void DeviceReportingProto::_internal_set_report_login_logout(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.report_login_logout_ = value;
}
inline void DeviceReportingProto::set_report_login_logout(bool value) {
  _internal_set_report_login_logout(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_login_logout)
}

// optional bool report_audio_status = 28 [default = true];
inline bool DeviceReportingProto::_internal_has_report_audio_status() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_audio_status() const {
  return _internal_has_report_audio_status();
}
inline void DeviceReportingProto::clear_report_audio_status() {
  _impl_.report_audio_status_ = true;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline bool DeviceReportingProto::_internal_report_audio_status() const {
  return _impl_.report_audio_status_;
}
inline bool DeviceReportingProto::report_audio_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_audio_status)
  return _internal_report_audio_status();
}
inline void DeviceReportingProto::_internal_set_report_audio_status(bool value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.report_audio_status_ = value;
}
inline void DeviceReportingProto::set_report_audio_status(bool value) {
  _internal_set_report_audio_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_audio_status)
}

// optional bool report_network_configuration = 29 [default = true];
inline bool DeviceReportingProto::_internal_has_report_network_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_network_configuration() const {
  return _internal_has_report_network_configuration();
}
inline void DeviceReportingProto::clear_report_network_configuration() {
  _impl_.report_network_configuration_ = true;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline bool DeviceReportingProto::_internal_report_network_configuration() const {
  return _impl_.report_network_configuration_;
}
inline bool DeviceReportingProto::report_network_configuration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_network_configuration)
  return _internal_report_network_configuration();
}
inline void DeviceReportingProto::_internal_set_report_network_configuration(bool value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.report_network_configuration_ = value;
}
inline void DeviceReportingProto::set_report_network_configuration(bool value) {
  _internal_set_report_network_configuration(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_network_configuration)
}

// optional bool report_network_status = 30 [default = true];
inline bool DeviceReportingProto::_internal_has_report_network_status() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_network_status() const {
  return _internal_has_report_network_status();
}
inline void DeviceReportingProto::clear_report_network_status() {
  _impl_.report_network_status_ = true;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool DeviceReportingProto::_internal_report_network_status() const {
  return _impl_.report_network_status_;
}
inline bool DeviceReportingProto::report_network_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_network_status)
  return _internal_report_network_status();
}
inline void DeviceReportingProto::_internal_set_report_network_status(bool value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.report_network_status_ = value;
}
inline void DeviceReportingProto::set_report_network_status(bool value) {
  _internal_set_report_network_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_network_status)
}

// optional bool report_security_status = 31 [default = false];
inline bool DeviceReportingProto::_internal_has_report_security_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_security_status() const {
  return _internal_has_report_security_status();
}
inline void DeviceReportingProto::clear_report_security_status() {
  _impl_.report_security_status_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool DeviceReportingProto::_internal_report_security_status() const {
  return _impl_.report_security_status_;
}
inline bool DeviceReportingProto::report_security_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_security_status)
  return _internal_report_security_status();
}
inline void DeviceReportingProto::_internal_set_report_security_status(bool value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.report_security_status_ = value;
}
inline void DeviceReportingProto::set_report_security_status(bool value) {
  _internal_set_report_security_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_security_status)
}

// optional bool report_crd_sessions = 36 [default = false];
inline bool DeviceReportingProto::_internal_has_report_crd_sessions() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_crd_sessions() const {
  return _internal_has_report_crd_sessions();
}
inline void DeviceReportingProto::clear_report_crd_sessions() {
  _impl_.report_crd_sessions_ = false;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline bool DeviceReportingProto::_internal_report_crd_sessions() const {
  return _impl_.report_crd_sessions_;
}
inline bool DeviceReportingProto::report_crd_sessions() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_crd_sessions)
  return _internal_report_crd_sessions();
}
inline void DeviceReportingProto::_internal_set_report_crd_sessions(bool value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.report_crd_sessions_ = value;
}
inline void DeviceReportingProto::set_report_crd_sessions(bool value) {
  _internal_set_report_crd_sessions(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_crd_sessions)
}

// optional bool report_peripherals = 37 [default = false];
inline bool DeviceReportingProto::_internal_has_report_peripherals() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_peripherals() const {
  return _internal_has_report_peripherals();
}
inline void DeviceReportingProto::clear_report_peripherals() {
  _impl_.report_peripherals_ = false;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline bool DeviceReportingProto::_internal_report_peripherals() const {
  return _impl_.report_peripherals_;
}
inline bool DeviceReportingProto::report_peripherals() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_peripherals)
  return _internal_report_peripherals();
}
inline void DeviceReportingProto::_internal_set_report_peripherals(bool value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.report_peripherals_ = value;
}
inline void DeviceReportingProto::set_report_peripherals(bool value) {
  _internal_set_report_peripherals(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_peripherals)
}

// optional int64 device_status_frequency = 9 [default = 10800000];
inline bool DeviceReportingProto::_internal_has_device_status_frequency() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_device_status_frequency() const {
  return _internal_has_device_status_frequency();
}
inline void DeviceReportingProto::clear_device_status_frequency() {
  _impl_.device_status_frequency_ = int64_t{10800000};
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline int64_t DeviceReportingProto::_internal_device_status_frequency() const {
  return _impl_.device_status_frequency_;
}
inline int64_t DeviceReportingProto::device_status_frequency() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.device_status_frequency)
  return _internal_device_status_frequency();
}
inline void DeviceReportingProto::_internal_set_device_status_frequency(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.device_status_frequency_ = value;
}
inline void DeviceReportingProto::set_device_status_frequency(int64_t value) {
  _internal_set_device_status_frequency(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.device_status_frequency)
}

// optional bool enable_granular_reporting = 32 [default = true, deprecated = true];
inline bool DeviceReportingProto::_internal_has_enable_granular_reporting() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_enable_granular_reporting() const {
  return _internal_has_enable_granular_reporting();
}
inline void DeviceReportingProto::clear_enable_granular_reporting() {
  _impl_.enable_granular_reporting_ = true;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool DeviceReportingProto::_internal_enable_granular_reporting() const {
  return _impl_.enable_granular_reporting_;
}
inline bool DeviceReportingProto::enable_granular_reporting() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.enable_granular_reporting)
  return _internal_enable_granular_reporting();
}
inline void DeviceReportingProto::_internal_set_enable_granular_reporting(bool value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.enable_granular_reporting_ = value;
}
inline void DeviceReportingProto::set_enable_granular_reporting(bool value) {
  _internal_set_enable_granular_reporting(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.enable_granular_reporting)
}

// optional int64 report_network_telemetry_collection_rate_ms = 33 [default = 3600000];
inline bool DeviceReportingProto::_internal_has_report_network_telemetry_collection_rate_ms() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_network_telemetry_collection_rate_ms() const {
  return _internal_has_report_network_telemetry_collection_rate_ms();
}
inline void DeviceReportingProto::clear_report_network_telemetry_collection_rate_ms() {
  _impl_.report_network_telemetry_collection_rate_ms_ = int64_t{3600000};
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline int64_t DeviceReportingProto::_internal_report_network_telemetry_collection_rate_ms() const {
  return _impl_.report_network_telemetry_collection_rate_ms_;
}
inline int64_t DeviceReportingProto::report_network_telemetry_collection_rate_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_network_telemetry_collection_rate_ms)
  return _internal_report_network_telemetry_collection_rate_ms();
}
inline void DeviceReportingProto::_internal_set_report_network_telemetry_collection_rate_ms(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.report_network_telemetry_collection_rate_ms_ = value;
}
inline void DeviceReportingProto::set_report_network_telemetry_collection_rate_ms(int64_t value) {
  _internal_set_report_network_telemetry_collection_rate_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_network_telemetry_collection_rate_ms)
}

// optional int64 report_network_telemetry_event_checking_rate_ms = 34 [default = 600000];
inline bool DeviceReportingProto::_internal_has_report_network_telemetry_event_checking_rate_ms() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_network_telemetry_event_checking_rate_ms() const {
  return _internal_has_report_network_telemetry_event_checking_rate_ms();
}
inline void DeviceReportingProto::clear_report_network_telemetry_event_checking_rate_ms() {
  _impl_.report_network_telemetry_event_checking_rate_ms_ = int64_t{600000};
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline int64_t DeviceReportingProto::_internal_report_network_telemetry_event_checking_rate_ms() const {
  return _impl_.report_network_telemetry_event_checking_rate_ms_;
}
inline int64_t DeviceReportingProto::report_network_telemetry_event_checking_rate_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_network_telemetry_event_checking_rate_ms)
  return _internal_report_network_telemetry_event_checking_rate_ms();
}
inline void DeviceReportingProto::_internal_set_report_network_telemetry_event_checking_rate_ms(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.report_network_telemetry_event_checking_rate_ms_ = value;
}
inline void DeviceReportingProto::set_report_network_telemetry_event_checking_rate_ms(int64_t value) {
  _internal_set_report_network_telemetry_event_checking_rate_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_network_telemetry_event_checking_rate_ms)
}

// optional int64 report_device_audio_status_checking_rate_ms = 35 [default = 600000];
inline bool DeviceReportingProto::_internal_has_report_device_audio_status_checking_rate_ms() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_report_device_audio_status_checking_rate_ms() const {
  return _internal_has_report_device_audio_status_checking_rate_ms();
}
inline void DeviceReportingProto::clear_report_device_audio_status_checking_rate_ms() {
  _impl_.report_device_audio_status_checking_rate_ms_ = int64_t{600000};
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline int64_t DeviceReportingProto::_internal_report_device_audio_status_checking_rate_ms() const {
  return _impl_.report_device_audio_status_checking_rate_ms_;
}
inline int64_t DeviceReportingProto::report_device_audio_status_checking_rate_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_device_audio_status_checking_rate_ms)
  return _internal_report_device_audio_status_checking_rate_ms();
}
inline void DeviceReportingProto::_internal_set_report_device_audio_status_checking_rate_ms(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.report_device_audio_status_checking_rate_ms_ = value;
}
inline void DeviceReportingProto::set_report_device_audio_status_checking_rate_ms(int64_t value) {
  _internal_set_report_device_audio_status_checking_rate_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.report_device_audio_status_checking_rate_ms)
}

// optional .enterprise_management.StringList report_signal_strength_event_driven_telemetry = 38;
inline bool DeviceReportingProto::_internal_has_report_signal_strength_event_driven_telemetry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.report_signal_strength_event_driven_telemetry_ != nullptr);
  return value;
}
inline bool DeviceReportingProto::has_report_signal_strength_event_driven_telemetry() const {
  return _internal_has_report_signal_strength_event_driven_telemetry();
}
inline const ::enterprise_management::StringList& DeviceReportingProto::_internal_report_signal_strength_event_driven_telemetry() const {
  const ::enterprise_management::StringList* p = _impl_.report_signal_strength_event_driven_telemetry_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::StringList&>(
      ::enterprise_management::_StringList_default_instance_);
}
inline const ::enterprise_management::StringList& DeviceReportingProto::report_signal_strength_event_driven_telemetry() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.report_signal_strength_event_driven_telemetry)
  return _internal_report_signal_strength_event_driven_telemetry();
}
inline void DeviceReportingProto::unsafe_arena_set_allocated_report_signal_strength_event_driven_telemetry(
    ::enterprise_management::StringList* report_signal_strength_event_driven_telemetry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_signal_strength_event_driven_telemetry_);
  }
  _impl_.report_signal_strength_event_driven_telemetry_ = report_signal_strength_event_driven_telemetry;
  if (report_signal_strength_event_driven_telemetry) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceReportingProto.report_signal_strength_event_driven_telemetry)
}
inline ::enterprise_management::StringList* DeviceReportingProto::release_report_signal_strength_event_driven_telemetry() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::StringList* temp = _impl_.report_signal_strength_event_driven_telemetry_;
  _impl_.report_signal_strength_event_driven_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::StringList* DeviceReportingProto::unsafe_arena_release_report_signal_strength_event_driven_telemetry() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceReportingProto.report_signal_strength_event_driven_telemetry)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::StringList* temp = _impl_.report_signal_strength_event_driven_telemetry_;
  _impl_.report_signal_strength_event_driven_telemetry_ = nullptr;
  return temp;
}
inline ::enterprise_management::StringList* DeviceReportingProto::_internal_mutable_report_signal_strength_event_driven_telemetry() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.report_signal_strength_event_driven_telemetry_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::StringList>(GetArenaForAllocation());
    _impl_.report_signal_strength_event_driven_telemetry_ = p;
  }
  return _impl_.report_signal_strength_event_driven_telemetry_;
}
inline ::enterprise_management::StringList* DeviceReportingProto::mutable_report_signal_strength_event_driven_telemetry() {
  ::enterprise_management::StringList* _msg = _internal_mutable_report_signal_strength_event_driven_telemetry();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceReportingProto.report_signal_strength_event_driven_telemetry)
  return _msg;
}
inline void DeviceReportingProto::set_allocated_report_signal_strength_event_driven_telemetry(::enterprise_management::StringList* report_signal_strength_event_driven_telemetry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_signal_strength_event_driven_telemetry_);
  }
  if (report_signal_strength_event_driven_telemetry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_signal_strength_event_driven_telemetry));
    if (message_arena != submessage_arena) {
      report_signal_strength_event_driven_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report_signal_strength_event_driven_telemetry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.report_signal_strength_event_driven_telemetry_ = report_signal_strength_event_driven_telemetry;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceReportingProto.report_signal_strength_event_driven_telemetry)
}

// optional bool device_activity_heartbeat_enabled = 39 [default = false];
inline bool DeviceReportingProto::_internal_has_device_activity_heartbeat_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_device_activity_heartbeat_enabled() const {
  return _internal_has_device_activity_heartbeat_enabled();
}
inline void DeviceReportingProto::clear_device_activity_heartbeat_enabled() {
  _impl_.device_activity_heartbeat_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool DeviceReportingProto::_internal_device_activity_heartbeat_enabled() const {
  return _impl_.device_activity_heartbeat_enabled_;
}
inline bool DeviceReportingProto::device_activity_heartbeat_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.device_activity_heartbeat_enabled)
  return _internal_device_activity_heartbeat_enabled();
}
inline void DeviceReportingProto::_internal_set_device_activity_heartbeat_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.device_activity_heartbeat_enabled_ = value;
}
inline void DeviceReportingProto::set_device_activity_heartbeat_enabled(bool value) {
  _internal_set_device_activity_heartbeat_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.device_activity_heartbeat_enabled)
}

// optional int64 device_activity_heartbeat_collection_rate_ms = 40 [default = 900000];
inline bool DeviceReportingProto::_internal_has_device_activity_heartbeat_collection_rate_ms() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool DeviceReportingProto::has_device_activity_heartbeat_collection_rate_ms() const {
  return _internal_has_device_activity_heartbeat_collection_rate_ms();
}
inline void DeviceReportingProto::clear_device_activity_heartbeat_collection_rate_ms() {
  _impl_.device_activity_heartbeat_collection_rate_ms_ = int64_t{900000};
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline int64_t DeviceReportingProto::_internal_device_activity_heartbeat_collection_rate_ms() const {
  return _impl_.device_activity_heartbeat_collection_rate_ms_;
}
inline int64_t DeviceReportingProto::device_activity_heartbeat_collection_rate_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportingProto.device_activity_heartbeat_collection_rate_ms)
  return _internal_device_activity_heartbeat_collection_rate_ms();
}
inline void DeviceReportingProto::_internal_set_device_activity_heartbeat_collection_rate_ms(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.device_activity_heartbeat_collection_rate_ms_ = value;
}
inline void DeviceReportingProto::set_device_activity_heartbeat_collection_rate_ms(int64_t value) {
  _internal_set_device_activity_heartbeat_collection_rate_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportingProto.device_activity_heartbeat_collection_rate_ms)
}

// -------------------------------------------------------------------

// EphemeralUsersEnabledProto

// optional bool ephemeral_users_enabled = 1;
inline bool EphemeralUsersEnabledProto::_internal_has_ephemeral_users_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EphemeralUsersEnabledProto::has_ephemeral_users_enabled() const {
  return _internal_has_ephemeral_users_enabled();
}
inline void EphemeralUsersEnabledProto::clear_ephemeral_users_enabled() {
  _impl_.ephemeral_users_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EphemeralUsersEnabledProto::_internal_ephemeral_users_enabled() const {
  return _impl_.ephemeral_users_enabled_;
}
inline bool EphemeralUsersEnabledProto::ephemeral_users_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.EphemeralUsersEnabledProto.ephemeral_users_enabled)
  return _internal_ephemeral_users_enabled();
}
inline void EphemeralUsersEnabledProto::_internal_set_ephemeral_users_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ephemeral_users_enabled_ = value;
}
inline void EphemeralUsersEnabledProto::set_ephemeral_users_enabled(bool value) {
  _internal_set_ephemeral_users_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.EphemeralUsersEnabledProto.ephemeral_users_enabled)
}

// -------------------------------------------------------------------

// DeviceKeylockerForStorageEncryptionEnabledProto

// optional bool enabled = 1;
inline bool DeviceKeylockerForStorageEncryptionEnabledProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceKeylockerForStorageEncryptionEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceKeylockerForStorageEncryptionEnabledProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceKeylockerForStorageEncryptionEnabledProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceKeylockerForStorageEncryptionEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto.enabled)
  return _internal_enabled();
}
inline void DeviceKeylockerForStorageEncryptionEnabledProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceKeylockerForStorageEncryptionEnabledProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto.enabled)
}

// -------------------------------------------------------------------

// OBSOLETE_AppPackEntryProto

// optional string OBSOLETE_extension_id = 1 [deprecated = true];
inline bool OBSOLETE_AppPackEntryProto::_internal_has_obsolete_extension_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_AppPackEntryProto::has_obsolete_extension_id() const {
  return _internal_has_obsolete_extension_id();
}
inline void OBSOLETE_AppPackEntryProto::clear_obsolete_extension_id() {
  _impl_.obsolete_extension_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OBSOLETE_AppPackEntryProto::obsolete_extension_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_extension_id)
  return _internal_obsolete_extension_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_AppPackEntryProto::set_obsolete_extension_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.obsolete_extension_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_extension_id)
}
inline std::string* OBSOLETE_AppPackEntryProto::mutable_obsolete_extension_id() {
  std::string* _s = _internal_mutable_obsolete_extension_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_extension_id)
  return _s;
}
inline const std::string& OBSOLETE_AppPackEntryProto::_internal_obsolete_extension_id() const {
  return _impl_.obsolete_extension_id_.Get();
}
inline void OBSOLETE_AppPackEntryProto::_internal_set_obsolete_extension_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_extension_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_AppPackEntryProto::_internal_mutable_obsolete_extension_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.obsolete_extension_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_AppPackEntryProto::release_obsolete_extension_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_extension_id)
  if (!_internal_has_obsolete_extension_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.obsolete_extension_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_extension_id_.IsDefault()) {
    _impl_.obsolete_extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_AppPackEntryProto::set_allocated_obsolete_extension_id(std::string* obsolete_extension_id) {
  if (obsolete_extension_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obsolete_extension_id_.SetAllocated(obsolete_extension_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_extension_id_.IsDefault()) {
    _impl_.obsolete_extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_extension_id)
}

// optional string OBSOLETE_update_url = 2 [deprecated = true];
inline bool OBSOLETE_AppPackEntryProto::_internal_has_obsolete_update_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OBSOLETE_AppPackEntryProto::has_obsolete_update_url() const {
  return _internal_has_obsolete_update_url();
}
inline void OBSOLETE_AppPackEntryProto::clear_obsolete_update_url() {
  _impl_.obsolete_update_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OBSOLETE_AppPackEntryProto::obsolete_update_url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_update_url)
  return _internal_obsolete_update_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_AppPackEntryProto::set_obsolete_update_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.obsolete_update_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_update_url)
}
inline std::string* OBSOLETE_AppPackEntryProto::mutable_obsolete_update_url() {
  std::string* _s = _internal_mutable_obsolete_update_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_update_url)
  return _s;
}
inline const std::string& OBSOLETE_AppPackEntryProto::_internal_obsolete_update_url() const {
  return _impl_.obsolete_update_url_.Get();
}
inline void OBSOLETE_AppPackEntryProto::_internal_set_obsolete_update_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.obsolete_update_url_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_AppPackEntryProto::_internal_mutable_obsolete_update_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.obsolete_update_url_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_AppPackEntryProto::release_obsolete_update_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_update_url)
  if (!_internal_has_obsolete_update_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.obsolete_update_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_update_url_.IsDefault()) {
    _impl_.obsolete_update_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_AppPackEntryProto::set_allocated_obsolete_update_url(std::string* obsolete_update_url) {
  if (obsolete_update_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.obsolete_update_url_.SetAllocated(obsolete_update_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_update_url_.IsDefault()) {
    _impl_.obsolete_update_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_update_url)
}

// optional bool OBSOLETE_online_only = 3 [deprecated = true];
inline bool OBSOLETE_AppPackEntryProto::_internal_has_obsolete_online_only() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OBSOLETE_AppPackEntryProto::has_obsolete_online_only() const {
  return _internal_has_obsolete_online_only();
}
inline void OBSOLETE_AppPackEntryProto::clear_obsolete_online_only() {
  _impl_.obsolete_online_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool OBSOLETE_AppPackEntryProto::_internal_obsolete_online_only() const {
  return _impl_.obsolete_online_only_;
}
inline bool OBSOLETE_AppPackEntryProto::obsolete_online_only() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_online_only)
  return _internal_obsolete_online_only();
}
inline void OBSOLETE_AppPackEntryProto::_internal_set_obsolete_online_only(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.obsolete_online_only_ = value;
}
inline void OBSOLETE_AppPackEntryProto::set_obsolete_online_only(bool value) {
  _internal_set_obsolete_online_only(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_AppPackEntryProto.OBSOLETE_online_only)
}

// -------------------------------------------------------------------

// OBSOLETE_AppPackProto

// repeated .enterprise_management.OBSOLETE_AppPackEntryProto app_pack = 1 [deprecated = true];
inline int OBSOLETE_AppPackProto::_internal_app_pack_size() const {
  return _impl_.app_pack_.size();
}
inline int OBSOLETE_AppPackProto::app_pack_size() const {
  return _internal_app_pack_size();
}
inline void OBSOLETE_AppPackProto::clear_app_pack() {
  _impl_.app_pack_.Clear();
}
inline ::enterprise_management::OBSOLETE_AppPackEntryProto* OBSOLETE_AppPackProto::mutable_app_pack(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_AppPackProto.app_pack)
  return _impl_.app_pack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::OBSOLETE_AppPackEntryProto >*
OBSOLETE_AppPackProto::mutable_app_pack() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.OBSOLETE_AppPackProto.app_pack)
  return &_impl_.app_pack_;
}
inline const ::enterprise_management::OBSOLETE_AppPackEntryProto& OBSOLETE_AppPackProto::_internal_app_pack(int index) const {
  return _impl_.app_pack_.Get(index);
}
inline const ::enterprise_management::OBSOLETE_AppPackEntryProto& OBSOLETE_AppPackProto::app_pack(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_AppPackProto.app_pack)
  return _internal_app_pack(index);
}
inline ::enterprise_management::OBSOLETE_AppPackEntryProto* OBSOLETE_AppPackProto::_internal_add_app_pack() {
  return _impl_.app_pack_.Add();
}
inline ::enterprise_management::OBSOLETE_AppPackEntryProto* OBSOLETE_AppPackProto::add_app_pack() {
  ::enterprise_management::OBSOLETE_AppPackEntryProto* _add = _internal_add_app_pack();
  // @@protoc_insertion_point(field_add:enterprise_management.OBSOLETE_AppPackProto.app_pack)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::OBSOLETE_AppPackEntryProto >&
OBSOLETE_AppPackProto::app_pack() const {
  // @@protoc_insertion_point(field_list:enterprise_management.OBSOLETE_AppPackProto.app_pack)
  return _impl_.app_pack_;
}

// -------------------------------------------------------------------

// OBSOLETE_PinnedAppsProto

// repeated string OBSOLETE_app_id = 1 [deprecated = true];
inline int OBSOLETE_PinnedAppsProto::_internal_obsolete_app_id_size() const {
  return _impl_.obsolete_app_id_.size();
}
inline int OBSOLETE_PinnedAppsProto::obsolete_app_id_size() const {
  return _internal_obsolete_app_id_size();
}
inline void OBSOLETE_PinnedAppsProto::clear_obsolete_app_id() {
  _impl_.obsolete_app_id_.Clear();
}
inline std::string* OBSOLETE_PinnedAppsProto::add_obsolete_app_id() {
  std::string* _s = _internal_add_obsolete_app_id();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
  return _s;
}
inline const std::string& OBSOLETE_PinnedAppsProto::_internal_obsolete_app_id(int index) const {
  return _impl_.obsolete_app_id_.Get(index);
}
inline const std::string& OBSOLETE_PinnedAppsProto::obsolete_app_id(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
  return _internal_obsolete_app_id(index);
}
inline std::string* OBSOLETE_PinnedAppsProto::mutable_obsolete_app_id(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
  return _impl_.obsolete_app_id_.Mutable(index);
}
inline void OBSOLETE_PinnedAppsProto::set_obsolete_app_id(int index, const std::string& value) {
  _impl_.obsolete_app_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
}
inline void OBSOLETE_PinnedAppsProto::set_obsolete_app_id(int index, std::string&& value) {
  _impl_.obsolete_app_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
}
inline void OBSOLETE_PinnedAppsProto::set_obsolete_app_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.obsolete_app_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
}
inline void OBSOLETE_PinnedAppsProto::set_obsolete_app_id(int index, const char* value, size_t size) {
  _impl_.obsolete_app_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
}
inline std::string* OBSOLETE_PinnedAppsProto::_internal_add_obsolete_app_id() {
  return _impl_.obsolete_app_id_.Add();
}
inline void OBSOLETE_PinnedAppsProto::add_obsolete_app_id(const std::string& value) {
  _impl_.obsolete_app_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
}
inline void OBSOLETE_PinnedAppsProto::add_obsolete_app_id(std::string&& value) {
  _impl_.obsolete_app_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
}
inline void OBSOLETE_PinnedAppsProto::add_obsolete_app_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.obsolete_app_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
}
inline void OBSOLETE_PinnedAppsProto::add_obsolete_app_id(const char* value, size_t size) {
  _impl_.obsolete_app_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OBSOLETE_PinnedAppsProto::obsolete_app_id() const {
  // @@protoc_insertion_point(field_list:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
  return _impl_.obsolete_app_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OBSOLETE_PinnedAppsProto::mutable_obsolete_app_id() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.OBSOLETE_PinnedAppsProto.OBSOLETE_app_id)
  return &_impl_.obsolete_app_id_;
}

// -------------------------------------------------------------------

// OBSOLETE_ForcedLogoutTimeoutsProto

// optional int64 OBSOLETE_idle_logout_timeout = 1 [deprecated = true];
inline bool OBSOLETE_ForcedLogoutTimeoutsProto::_internal_has_obsolete_idle_logout_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_ForcedLogoutTimeoutsProto::has_obsolete_idle_logout_timeout() const {
  return _internal_has_obsolete_idle_logout_timeout();
}
inline void OBSOLETE_ForcedLogoutTimeoutsProto::clear_obsolete_idle_logout_timeout() {
  _impl_.obsolete_idle_logout_timeout_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t OBSOLETE_ForcedLogoutTimeoutsProto::_internal_obsolete_idle_logout_timeout() const {
  return _impl_.obsolete_idle_logout_timeout_;
}
inline int64_t OBSOLETE_ForcedLogoutTimeoutsProto::obsolete_idle_logout_timeout() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto.OBSOLETE_idle_logout_timeout)
  return _internal_obsolete_idle_logout_timeout();
}
inline void OBSOLETE_ForcedLogoutTimeoutsProto::_internal_set_obsolete_idle_logout_timeout(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_idle_logout_timeout_ = value;
}
inline void OBSOLETE_ForcedLogoutTimeoutsProto::set_obsolete_idle_logout_timeout(int64_t value) {
  _internal_set_obsolete_idle_logout_timeout(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto.OBSOLETE_idle_logout_timeout)
}

// optional int64 OBSOLETE_idle_logout_warning_duration = 2 [deprecated = true];
inline bool OBSOLETE_ForcedLogoutTimeoutsProto::_internal_has_obsolete_idle_logout_warning_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OBSOLETE_ForcedLogoutTimeoutsProto::has_obsolete_idle_logout_warning_duration() const {
  return _internal_has_obsolete_idle_logout_warning_duration();
}
inline void OBSOLETE_ForcedLogoutTimeoutsProto::clear_obsolete_idle_logout_warning_duration() {
  _impl_.obsolete_idle_logout_warning_duration_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t OBSOLETE_ForcedLogoutTimeoutsProto::_internal_obsolete_idle_logout_warning_duration() const {
  return _impl_.obsolete_idle_logout_warning_duration_;
}
inline int64_t OBSOLETE_ForcedLogoutTimeoutsProto::obsolete_idle_logout_warning_duration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto.OBSOLETE_idle_logout_warning_duration)
  return _internal_obsolete_idle_logout_warning_duration();
}
inline void OBSOLETE_ForcedLogoutTimeoutsProto::_internal_set_obsolete_idle_logout_warning_duration(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.obsolete_idle_logout_warning_duration_ = value;
}
inline void OBSOLETE_ForcedLogoutTimeoutsProto::set_obsolete_idle_logout_warning_duration(int64_t value) {
  _internal_set_obsolete_idle_logout_warning_duration(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto.OBSOLETE_idle_logout_warning_duration)
}

// -------------------------------------------------------------------

// OBSOLETE_ScreenSaverProto

// optional string OBSOLETE_screen_saver_extension_id = 1 [deprecated = true];
inline bool OBSOLETE_ScreenSaverProto::_internal_has_obsolete_screen_saver_extension_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_ScreenSaverProto::has_obsolete_screen_saver_extension_id() const {
  return _internal_has_obsolete_screen_saver_extension_id();
}
inline void OBSOLETE_ScreenSaverProto::clear_obsolete_screen_saver_extension_id() {
  _impl_.obsolete_screen_saver_extension_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OBSOLETE_ScreenSaverProto::obsolete_screen_saver_extension_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_ScreenSaverProto.OBSOLETE_screen_saver_extension_id)
  return _internal_obsolete_screen_saver_extension_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_ScreenSaverProto::set_obsolete_screen_saver_extension_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.obsolete_screen_saver_extension_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_ScreenSaverProto.OBSOLETE_screen_saver_extension_id)
}
inline std::string* OBSOLETE_ScreenSaverProto::mutable_obsolete_screen_saver_extension_id() {
  std::string* _s = _internal_mutable_obsolete_screen_saver_extension_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_ScreenSaverProto.OBSOLETE_screen_saver_extension_id)
  return _s;
}
inline const std::string& OBSOLETE_ScreenSaverProto::_internal_obsolete_screen_saver_extension_id() const {
  return _impl_.obsolete_screen_saver_extension_id_.Get();
}
inline void OBSOLETE_ScreenSaverProto::_internal_set_obsolete_screen_saver_extension_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_screen_saver_extension_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_ScreenSaverProto::_internal_mutable_obsolete_screen_saver_extension_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.obsolete_screen_saver_extension_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_ScreenSaverProto::release_obsolete_screen_saver_extension_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_ScreenSaverProto.OBSOLETE_screen_saver_extension_id)
  if (!_internal_has_obsolete_screen_saver_extension_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.obsolete_screen_saver_extension_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_screen_saver_extension_id_.IsDefault()) {
    _impl_.obsolete_screen_saver_extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_ScreenSaverProto::set_allocated_obsolete_screen_saver_extension_id(std::string* obsolete_screen_saver_extension_id) {
  if (obsolete_screen_saver_extension_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obsolete_screen_saver_extension_id_.SetAllocated(obsolete_screen_saver_extension_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_screen_saver_extension_id_.IsDefault()) {
    _impl_.obsolete_screen_saver_extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_ScreenSaverProto.OBSOLETE_screen_saver_extension_id)
}

// optional int64 OBSOLETE_screen_saver_timeout = 2 [deprecated = true];
inline bool OBSOLETE_ScreenSaverProto::_internal_has_obsolete_screen_saver_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OBSOLETE_ScreenSaverProto::has_obsolete_screen_saver_timeout() const {
  return _internal_has_obsolete_screen_saver_timeout();
}
inline void OBSOLETE_ScreenSaverProto::clear_obsolete_screen_saver_timeout() {
  _impl_.obsolete_screen_saver_timeout_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t OBSOLETE_ScreenSaverProto::_internal_obsolete_screen_saver_timeout() const {
  return _impl_.obsolete_screen_saver_timeout_;
}
inline int64_t OBSOLETE_ScreenSaverProto::obsolete_screen_saver_timeout() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_ScreenSaverProto.OBSOLETE_screen_saver_timeout)
  return _internal_obsolete_screen_saver_timeout();
}
inline void OBSOLETE_ScreenSaverProto::_internal_set_obsolete_screen_saver_timeout(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.obsolete_screen_saver_timeout_ = value;
}
inline void OBSOLETE_ScreenSaverProto::set_obsolete_screen_saver_timeout(int64_t value) {
  _internal_set_obsolete_screen_saver_timeout(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_ScreenSaverProto.OBSOLETE_screen_saver_timeout)
}

// -------------------------------------------------------------------

// AutoUpdateSettingsProto

// optional bool update_disabled = 1;
inline bool AutoUpdateSettingsProto::_internal_has_update_disabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_update_disabled() const {
  return _internal_has_update_disabled();
}
inline void AutoUpdateSettingsProto::clear_update_disabled() {
  _impl_.update_disabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool AutoUpdateSettingsProto::_internal_update_disabled() const {
  return _impl_.update_disabled_;
}
inline bool AutoUpdateSettingsProto::update_disabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.update_disabled)
  return _internal_update_disabled();
}
inline void AutoUpdateSettingsProto::_internal_set_update_disabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.update_disabled_ = value;
}
inline void AutoUpdateSettingsProto::set_update_disabled(bool value) {
  _internal_set_update_disabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.update_disabled)
}

// optional string target_version_prefix = 2;
inline bool AutoUpdateSettingsProto::_internal_has_target_version_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_target_version_prefix() const {
  return _internal_has_target_version_prefix();
}
inline void AutoUpdateSettingsProto::clear_target_version_prefix() {
  _impl_.target_version_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutoUpdateSettingsProto::target_version_prefix() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.target_version_prefix)
  return _internal_target_version_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoUpdateSettingsProto::set_target_version_prefix(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.target_version_prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.target_version_prefix)
}
inline std::string* AutoUpdateSettingsProto::mutable_target_version_prefix() {
  std::string* _s = _internal_mutable_target_version_prefix();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AutoUpdateSettingsProto.target_version_prefix)
  return _s;
}
inline const std::string& AutoUpdateSettingsProto::_internal_target_version_prefix() const {
  return _impl_.target_version_prefix_.Get();
}
inline void AutoUpdateSettingsProto::_internal_set_target_version_prefix(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.target_version_prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::_internal_mutable_target_version_prefix() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.target_version_prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::release_target_version_prefix() {
  // @@protoc_insertion_point(field_release:enterprise_management.AutoUpdateSettingsProto.target_version_prefix)
  if (!_internal_has_target_version_prefix()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.target_version_prefix_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_version_prefix_.IsDefault()) {
    _impl_.target_version_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoUpdateSettingsProto::set_allocated_target_version_prefix(std::string* target_version_prefix) {
  if (target_version_prefix != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_version_prefix_.SetAllocated(target_version_prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_version_prefix_.IsDefault()) {
    _impl_.target_version_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AutoUpdateSettingsProto.target_version_prefix)
}

// optional string target_version_display_name = 3;
inline bool AutoUpdateSettingsProto::_internal_has_target_version_display_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_target_version_display_name() const {
  return _internal_has_target_version_display_name();
}
inline void AutoUpdateSettingsProto::clear_target_version_display_name() {
  _impl_.target_version_display_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutoUpdateSettingsProto::target_version_display_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.target_version_display_name)
  return _internal_target_version_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoUpdateSettingsProto::set_target_version_display_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.target_version_display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.target_version_display_name)
}
inline std::string* AutoUpdateSettingsProto::mutable_target_version_display_name() {
  std::string* _s = _internal_mutable_target_version_display_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AutoUpdateSettingsProto.target_version_display_name)
  return _s;
}
inline const std::string& AutoUpdateSettingsProto::_internal_target_version_display_name() const {
  return _impl_.target_version_display_name_.Get();
}
inline void AutoUpdateSettingsProto::_internal_set_target_version_display_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.target_version_display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::_internal_mutable_target_version_display_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.target_version_display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::release_target_version_display_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.AutoUpdateSettingsProto.target_version_display_name)
  if (!_internal_has_target_version_display_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.target_version_display_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_version_display_name_.IsDefault()) {
    _impl_.target_version_display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoUpdateSettingsProto::set_allocated_target_version_display_name(std::string* target_version_display_name) {
  if (target_version_display_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.target_version_display_name_.SetAllocated(target_version_display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_version_display_name_.IsDefault()) {
    _impl_.target_version_display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AutoUpdateSettingsProto.target_version_display_name)
}

// optional int64 scatter_factor_in_seconds = 4;
inline bool AutoUpdateSettingsProto::_internal_has_scatter_factor_in_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_scatter_factor_in_seconds() const {
  return _internal_has_scatter_factor_in_seconds();
}
inline void AutoUpdateSettingsProto::clear_scatter_factor_in_seconds() {
  _impl_.scatter_factor_in_seconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t AutoUpdateSettingsProto::_internal_scatter_factor_in_seconds() const {
  return _impl_.scatter_factor_in_seconds_;
}
inline int64_t AutoUpdateSettingsProto::scatter_factor_in_seconds() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.scatter_factor_in_seconds)
  return _internal_scatter_factor_in_seconds();
}
inline void AutoUpdateSettingsProto::_internal_set_scatter_factor_in_seconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.scatter_factor_in_seconds_ = value;
}
inline void AutoUpdateSettingsProto::set_scatter_factor_in_seconds(int64_t value) {
  _internal_set_scatter_factor_in_seconds(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.scatter_factor_in_seconds)
}

// repeated .enterprise_management.AutoUpdateSettingsProto.ConnectionType allowed_connection_types = 5;
inline int AutoUpdateSettingsProto::_internal_allowed_connection_types_size() const {
  return _impl_.allowed_connection_types_.size();
}
inline int AutoUpdateSettingsProto::allowed_connection_types_size() const {
  return _internal_allowed_connection_types_size();
}
inline void AutoUpdateSettingsProto::clear_allowed_connection_types() {
  _impl_.allowed_connection_types_.Clear();
}
inline ::enterprise_management::AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::_internal_allowed_connection_types(int index) const {
  return static_cast< ::enterprise_management::AutoUpdateSettingsProto_ConnectionType >(_impl_.allowed_connection_types_.Get(index));
}
inline ::enterprise_management::AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::allowed_connection_types(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.allowed_connection_types)
  return _internal_allowed_connection_types(index);
}
inline void AutoUpdateSettingsProto::set_allowed_connection_types(int index, ::enterprise_management::AutoUpdateSettingsProto_ConnectionType value) {
  assert(::enterprise_management::AutoUpdateSettingsProto_ConnectionType_IsValid(value));
  _impl_.allowed_connection_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.allowed_connection_types)
}
inline void AutoUpdateSettingsProto::_internal_add_allowed_connection_types(::enterprise_management::AutoUpdateSettingsProto_ConnectionType value) {
  assert(::enterprise_management::AutoUpdateSettingsProto_ConnectionType_IsValid(value));
  _impl_.allowed_connection_types_.Add(value);
}
inline void AutoUpdateSettingsProto::add_allowed_connection_types(::enterprise_management::AutoUpdateSettingsProto_ConnectionType value) {
  _internal_add_allowed_connection_types(value);
  // @@protoc_insertion_point(field_add:enterprise_management.AutoUpdateSettingsProto.allowed_connection_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
AutoUpdateSettingsProto::allowed_connection_types() const {
  // @@protoc_insertion_point(field_list:enterprise_management.AutoUpdateSettingsProto.allowed_connection_types)
  return _impl_.allowed_connection_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AutoUpdateSettingsProto::_internal_mutable_allowed_connection_types() {
  return &_impl_.allowed_connection_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AutoUpdateSettingsProto::mutable_allowed_connection_types() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.AutoUpdateSettingsProto.allowed_connection_types)
  return _internal_mutable_allowed_connection_types();
}

// optional bool OBSOLETE_reboot_after_update = 6 [deprecated = true];
inline bool AutoUpdateSettingsProto::_internal_has_obsolete_reboot_after_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_obsolete_reboot_after_update() const {
  return _internal_has_obsolete_reboot_after_update();
}
inline void AutoUpdateSettingsProto::clear_obsolete_reboot_after_update() {
  _impl_.obsolete_reboot_after_update_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool AutoUpdateSettingsProto::_internal_obsolete_reboot_after_update() const {
  return _impl_.obsolete_reboot_after_update_;
}
inline bool AutoUpdateSettingsProto::obsolete_reboot_after_update() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.OBSOLETE_reboot_after_update)
  return _internal_obsolete_reboot_after_update();
}
inline void AutoUpdateSettingsProto::_internal_set_obsolete_reboot_after_update(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.obsolete_reboot_after_update_ = value;
}
inline void AutoUpdateSettingsProto::set_obsolete_reboot_after_update(bool value) {
  _internal_set_obsolete_reboot_after_update(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.OBSOLETE_reboot_after_update)
}

// optional bool http_downloads_enabled = 7 [default = false];
inline bool AutoUpdateSettingsProto::_internal_has_http_downloads_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_http_downloads_enabled() const {
  return _internal_has_http_downloads_enabled();
}
inline void AutoUpdateSettingsProto::clear_http_downloads_enabled() {
  _impl_.http_downloads_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool AutoUpdateSettingsProto::_internal_http_downloads_enabled() const {
  return _impl_.http_downloads_enabled_;
}
inline bool AutoUpdateSettingsProto::http_downloads_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.http_downloads_enabled)
  return _internal_http_downloads_enabled();
}
inline void AutoUpdateSettingsProto::_internal_set_http_downloads_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.http_downloads_enabled_ = value;
}
inline void AutoUpdateSettingsProto::set_http_downloads_enabled(bool value) {
  _internal_set_http_downloads_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.http_downloads_enabled)
}

// optional bool reboot_after_update = 8;
inline bool AutoUpdateSettingsProto::_internal_has_reboot_after_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_reboot_after_update() const {
  return _internal_has_reboot_after_update();
}
inline void AutoUpdateSettingsProto::clear_reboot_after_update() {
  _impl_.reboot_after_update_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool AutoUpdateSettingsProto::_internal_reboot_after_update() const {
  return _impl_.reboot_after_update_;
}
inline bool AutoUpdateSettingsProto::reboot_after_update() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.reboot_after_update)
  return _internal_reboot_after_update();
}
inline void AutoUpdateSettingsProto::_internal_set_reboot_after_update(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.reboot_after_update_ = value;
}
inline void AutoUpdateSettingsProto::set_reboot_after_update(bool value) {
  _internal_set_reboot_after_update(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.reboot_after_update)
}

// optional bool p2p_enabled = 9 [default = false];
inline bool AutoUpdateSettingsProto::_internal_has_p2p_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_p2p_enabled() const {
  return _internal_has_p2p_enabled();
}
inline void AutoUpdateSettingsProto::clear_p2p_enabled() {
  _impl_.p2p_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool AutoUpdateSettingsProto::_internal_p2p_enabled() const {
  return _impl_.p2p_enabled_;
}
inline bool AutoUpdateSettingsProto::p2p_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.p2p_enabled)
  return _internal_p2p_enabled();
}
inline void AutoUpdateSettingsProto::_internal_set_p2p_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.p2p_enabled_ = value;
}
inline void AutoUpdateSettingsProto::set_p2p_enabled(bool value) {
  _internal_set_p2p_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.p2p_enabled)
}

// optional .enterprise_management.AutoUpdateSettingsProto.RollbackToTargetVersion rollback_to_target_version = 10 [default = ROLLBACK_DISABLED];
inline bool AutoUpdateSettingsProto::_internal_has_rollback_to_target_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_rollback_to_target_version() const {
  return _internal_has_rollback_to_target_version();
}
inline void AutoUpdateSettingsProto::clear_rollback_to_target_version() {
  _impl_.rollback_to_target_version_ = 1;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto::_internal_rollback_to_target_version() const {
  return static_cast< ::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion >(_impl_.rollback_to_target_version_);
}
inline ::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto::rollback_to_target_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.rollback_to_target_version)
  return _internal_rollback_to_target_version();
}
inline void AutoUpdateSettingsProto::_internal_set_rollback_to_target_version(::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion value) {
  assert(::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.rollback_to_target_version_ = value;
}
inline void AutoUpdateSettingsProto::set_rollback_to_target_version(::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion value) {
  _internal_set_rollback_to_target_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.rollback_to_target_version)
}

// optional int32 rollback_allowed_milestones = 11 [default = 0];
inline bool AutoUpdateSettingsProto::_internal_has_rollback_allowed_milestones() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_rollback_allowed_milestones() const {
  return _internal_has_rollback_allowed_milestones();
}
inline void AutoUpdateSettingsProto::clear_rollback_allowed_milestones() {
  _impl_.rollback_allowed_milestones_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t AutoUpdateSettingsProto::_internal_rollback_allowed_milestones() const {
  return _impl_.rollback_allowed_milestones_;
}
inline int32_t AutoUpdateSettingsProto::rollback_allowed_milestones() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.rollback_allowed_milestones)
  return _internal_rollback_allowed_milestones();
}
inline void AutoUpdateSettingsProto::_internal_set_rollback_allowed_milestones(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.rollback_allowed_milestones_ = value;
}
inline void AutoUpdateSettingsProto::set_rollback_allowed_milestones(int32_t value) {
  _internal_set_rollback_allowed_milestones(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.rollback_allowed_milestones)
}

// optional string disallowed_time_intervals = 12;
inline bool AutoUpdateSettingsProto::_internal_has_disallowed_time_intervals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_disallowed_time_intervals() const {
  return _internal_has_disallowed_time_intervals();
}
inline void AutoUpdateSettingsProto::clear_disallowed_time_intervals() {
  _impl_.disallowed_time_intervals_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AutoUpdateSettingsProto::disallowed_time_intervals() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.disallowed_time_intervals)
  return _internal_disallowed_time_intervals();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoUpdateSettingsProto::set_disallowed_time_intervals(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.disallowed_time_intervals_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.disallowed_time_intervals)
}
inline std::string* AutoUpdateSettingsProto::mutable_disallowed_time_intervals() {
  std::string* _s = _internal_mutable_disallowed_time_intervals();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AutoUpdateSettingsProto.disallowed_time_intervals)
  return _s;
}
inline const std::string& AutoUpdateSettingsProto::_internal_disallowed_time_intervals() const {
  return _impl_.disallowed_time_intervals_.Get();
}
inline void AutoUpdateSettingsProto::_internal_set_disallowed_time_intervals(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.disallowed_time_intervals_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::_internal_mutable_disallowed_time_intervals() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.disallowed_time_intervals_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::release_disallowed_time_intervals() {
  // @@protoc_insertion_point(field_release:enterprise_management.AutoUpdateSettingsProto.disallowed_time_intervals)
  if (!_internal_has_disallowed_time_intervals()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.disallowed_time_intervals_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.disallowed_time_intervals_.IsDefault()) {
    _impl_.disallowed_time_intervals_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoUpdateSettingsProto::set_allocated_disallowed_time_intervals(std::string* disallowed_time_intervals) {
  if (disallowed_time_intervals != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.disallowed_time_intervals_.SetAllocated(disallowed_time_intervals, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.disallowed_time_intervals_.IsDefault()) {
    _impl_.disallowed_time_intervals_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AutoUpdateSettingsProto.disallowed_time_intervals)
}

// optional string staging_schedule = 14;
inline bool AutoUpdateSettingsProto::_internal_has_staging_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_staging_schedule() const {
  return _internal_has_staging_schedule();
}
inline void AutoUpdateSettingsProto::clear_staging_schedule() {
  _impl_.staging_schedule_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AutoUpdateSettingsProto::staging_schedule() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.staging_schedule)
  return _internal_staging_schedule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoUpdateSettingsProto::set_staging_schedule(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.staging_schedule_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.staging_schedule)
}
inline std::string* AutoUpdateSettingsProto::mutable_staging_schedule() {
  std::string* _s = _internal_mutable_staging_schedule();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AutoUpdateSettingsProto.staging_schedule)
  return _s;
}
inline const std::string& AutoUpdateSettingsProto::_internal_staging_schedule() const {
  return _impl_.staging_schedule_.Get();
}
inline void AutoUpdateSettingsProto::_internal_set_staging_schedule(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.staging_schedule_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::_internal_mutable_staging_schedule() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.staging_schedule_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::release_staging_schedule() {
  // @@protoc_insertion_point(field_release:enterprise_management.AutoUpdateSettingsProto.staging_schedule)
  if (!_internal_has_staging_schedule()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.staging_schedule_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.staging_schedule_.IsDefault()) {
    _impl_.staging_schedule_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoUpdateSettingsProto::set_allocated_staging_schedule(std::string* staging_schedule) {
  if (staging_schedule != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.staging_schedule_.SetAllocated(staging_schedule, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.staging_schedule_.IsDefault()) {
    _impl_.staging_schedule_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AutoUpdateSettingsProto.staging_schedule)
}

// optional string device_quick_fix_build_token = 15;
inline bool AutoUpdateSettingsProto::_internal_has_device_quick_fix_build_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_device_quick_fix_build_token() const {
  return _internal_has_device_quick_fix_build_token();
}
inline void AutoUpdateSettingsProto::clear_device_quick_fix_build_token() {
  _impl_.device_quick_fix_build_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AutoUpdateSettingsProto::device_quick_fix_build_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.device_quick_fix_build_token)
  return _internal_device_quick_fix_build_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoUpdateSettingsProto::set_device_quick_fix_build_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.device_quick_fix_build_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.device_quick_fix_build_token)
}
inline std::string* AutoUpdateSettingsProto::mutable_device_quick_fix_build_token() {
  std::string* _s = _internal_mutable_device_quick_fix_build_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AutoUpdateSettingsProto.device_quick_fix_build_token)
  return _s;
}
inline const std::string& AutoUpdateSettingsProto::_internal_device_quick_fix_build_token() const {
  return _impl_.device_quick_fix_build_token_.Get();
}
inline void AutoUpdateSettingsProto::_internal_set_device_quick_fix_build_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.device_quick_fix_build_token_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::_internal_mutable_device_quick_fix_build_token() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.device_quick_fix_build_token_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::release_device_quick_fix_build_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.AutoUpdateSettingsProto.device_quick_fix_build_token)
  if (!_internal_has_device_quick_fix_build_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.device_quick_fix_build_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_quick_fix_build_token_.IsDefault()) {
    _impl_.device_quick_fix_build_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoUpdateSettingsProto::set_allocated_device_quick_fix_build_token(std::string* device_quick_fix_build_token) {
  if (device_quick_fix_build_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.device_quick_fix_build_token_.SetAllocated(device_quick_fix_build_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_quick_fix_build_token_.IsDefault()) {
    _impl_.device_quick_fix_build_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AutoUpdateSettingsProto.device_quick_fix_build_token)
}

// optional .enterprise_management.AutoUpdateSettingsProto.ChannelDowngradeBehavior channel_downgrade_behavior = 16 [default = WAIT_FOR_VERSION_CATCH_UP];
inline bool AutoUpdateSettingsProto::_internal_has_channel_downgrade_behavior() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_channel_downgrade_behavior() const {
  return _internal_has_channel_downgrade_behavior();
}
inline void AutoUpdateSettingsProto::clear_channel_downgrade_behavior() {
  _impl_.channel_downgrade_behavior_ = 1;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto::_internal_channel_downgrade_behavior() const {
  return static_cast< ::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior >(_impl_.channel_downgrade_behavior_);
}
inline ::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto::channel_downgrade_behavior() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.channel_downgrade_behavior)
  return _internal_channel_downgrade_behavior();
}
inline void AutoUpdateSettingsProto::_internal_set_channel_downgrade_behavior(::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior value) {
  assert(::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.channel_downgrade_behavior_ = value;
}
inline void AutoUpdateSettingsProto::set_channel_downgrade_behavior(::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior value) {
  _internal_set_channel_downgrade_behavior(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.channel_downgrade_behavior)
}

// optional string target_version_selector = 17;
inline bool AutoUpdateSettingsProto::_internal_has_target_version_selector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AutoUpdateSettingsProto::has_target_version_selector() const {
  return _internal_has_target_version_selector();
}
inline void AutoUpdateSettingsProto::clear_target_version_selector() {
  _impl_.target_version_selector_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AutoUpdateSettingsProto::target_version_selector() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoUpdateSettingsProto.target_version_selector)
  return _internal_target_version_selector();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoUpdateSettingsProto::set_target_version_selector(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.target_version_selector_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AutoUpdateSettingsProto.target_version_selector)
}
inline std::string* AutoUpdateSettingsProto::mutable_target_version_selector() {
  std::string* _s = _internal_mutable_target_version_selector();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AutoUpdateSettingsProto.target_version_selector)
  return _s;
}
inline const std::string& AutoUpdateSettingsProto::_internal_target_version_selector() const {
  return _impl_.target_version_selector_.Get();
}
inline void AutoUpdateSettingsProto::_internal_set_target_version_selector(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.target_version_selector_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::_internal_mutable_target_version_selector() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.target_version_selector_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoUpdateSettingsProto::release_target_version_selector() {
  // @@protoc_insertion_point(field_release:enterprise_management.AutoUpdateSettingsProto.target_version_selector)
  if (!_internal_has_target_version_selector()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.target_version_selector_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_version_selector_.IsDefault()) {
    _impl_.target_version_selector_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoUpdateSettingsProto::set_allocated_target_version_selector(std::string* target_version_selector) {
  if (target_version_selector != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.target_version_selector_.SetAllocated(target_version_selector, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_version_selector_.IsDefault()) {
    _impl_.target_version_selector_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AutoUpdateSettingsProto.target_version_selector)
}

// -------------------------------------------------------------------

// OBSOLETE_StartUpUrlsProto

// repeated string OBSOLETE_start_up_urls = 1 [deprecated = true];
inline int OBSOLETE_StartUpUrlsProto::_internal_obsolete_start_up_urls_size() const {
  return _impl_.obsolete_start_up_urls_.size();
}
inline int OBSOLETE_StartUpUrlsProto::obsolete_start_up_urls_size() const {
  return _internal_obsolete_start_up_urls_size();
}
inline void OBSOLETE_StartUpUrlsProto::clear_obsolete_start_up_urls() {
  _impl_.obsolete_start_up_urls_.Clear();
}
inline std::string* OBSOLETE_StartUpUrlsProto::add_obsolete_start_up_urls() {
  std::string* _s = _internal_add_obsolete_start_up_urls();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
  return _s;
}
inline const std::string& OBSOLETE_StartUpUrlsProto::_internal_obsolete_start_up_urls(int index) const {
  return _impl_.obsolete_start_up_urls_.Get(index);
}
inline const std::string& OBSOLETE_StartUpUrlsProto::obsolete_start_up_urls(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
  return _internal_obsolete_start_up_urls(index);
}
inline std::string* OBSOLETE_StartUpUrlsProto::mutable_obsolete_start_up_urls(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
  return _impl_.obsolete_start_up_urls_.Mutable(index);
}
inline void OBSOLETE_StartUpUrlsProto::set_obsolete_start_up_urls(int index, const std::string& value) {
  _impl_.obsolete_start_up_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
}
inline void OBSOLETE_StartUpUrlsProto::set_obsolete_start_up_urls(int index, std::string&& value) {
  _impl_.obsolete_start_up_urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
}
inline void OBSOLETE_StartUpUrlsProto::set_obsolete_start_up_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.obsolete_start_up_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
}
inline void OBSOLETE_StartUpUrlsProto::set_obsolete_start_up_urls(int index, const char* value, size_t size) {
  _impl_.obsolete_start_up_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
}
inline std::string* OBSOLETE_StartUpUrlsProto::_internal_add_obsolete_start_up_urls() {
  return _impl_.obsolete_start_up_urls_.Add();
}
inline void OBSOLETE_StartUpUrlsProto::add_obsolete_start_up_urls(const std::string& value) {
  _impl_.obsolete_start_up_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
}
inline void OBSOLETE_StartUpUrlsProto::add_obsolete_start_up_urls(std::string&& value) {
  _impl_.obsolete_start_up_urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
}
inline void OBSOLETE_StartUpUrlsProto::add_obsolete_start_up_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.obsolete_start_up_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
}
inline void OBSOLETE_StartUpUrlsProto::add_obsolete_start_up_urls(const char* value, size_t size) {
  _impl_.obsolete_start_up_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OBSOLETE_StartUpUrlsProto::obsolete_start_up_urls() const {
  // @@protoc_insertion_point(field_list:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
  return _impl_.obsolete_start_up_urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OBSOLETE_StartUpUrlsProto::mutable_obsolete_start_up_urls() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.OBSOLETE_StartUpUrlsProto.OBSOLETE_start_up_urls)
  return &_impl_.obsolete_start_up_urls_;
}

// -------------------------------------------------------------------

// SystemTimezoneProto

// optional string timezone = 1;
inline bool SystemTimezoneProto::_internal_has_timezone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemTimezoneProto::has_timezone() const {
  return _internal_has_timezone();
}
inline void SystemTimezoneProto::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SystemTimezoneProto::timezone() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemTimezoneProto.timezone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemTimezoneProto::set_timezone(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemTimezoneProto.timezone)
}
inline std::string* SystemTimezoneProto::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemTimezoneProto.timezone)
  return _s;
}
inline const std::string& SystemTimezoneProto::_internal_timezone() const {
  return _impl_.timezone_.Get();
}
inline void SystemTimezoneProto::_internal_set_timezone(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemTimezoneProto::_internal_mutable_timezone() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemTimezoneProto::release_timezone() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemTimezoneProto.timezone)
  if (!_internal_has_timezone()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.timezone_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemTimezoneProto::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timezone_.SetAllocated(timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemTimezoneProto.timezone)
}

// optional .enterprise_management.SystemTimezoneProto.AutomaticTimezoneDetectionType timezone_detection_type = 2;
inline bool SystemTimezoneProto::_internal_has_timezone_detection_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SystemTimezoneProto::has_timezone_detection_type() const {
  return _internal_has_timezone_detection_type();
}
inline void SystemTimezoneProto::clear_timezone_detection_type() {
  _impl_.timezone_detection_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::_internal_timezone_detection_type() const {
  return static_cast< ::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType >(_impl_.timezone_detection_type_);
}
inline ::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::timezone_detection_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemTimezoneProto.timezone_detection_type)
  return _internal_timezone_detection_type();
}
inline void SystemTimezoneProto::_internal_set_timezone_detection_type(::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType value) {
  assert(::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timezone_detection_type_ = value;
}
inline void SystemTimezoneProto::set_timezone_detection_type(::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType value) {
  _internal_set_timezone_detection_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SystemTimezoneProto.timezone_detection_type)
}

// -------------------------------------------------------------------

// SystemUse24HourClockProto

// optional bool use_24hour_clock = 1;
inline bool SystemUse24HourClockProto::_internal_has_use_24hour_clock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemUse24HourClockProto::has_use_24hour_clock() const {
  return _internal_has_use_24hour_clock();
}
inline void SystemUse24HourClockProto::clear_use_24hour_clock() {
  _impl_.use_24hour_clock_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SystemUse24HourClockProto::_internal_use_24hour_clock() const {
  return _impl_.use_24hour_clock_;
}
inline bool SystemUse24HourClockProto::use_24hour_clock() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemUse24HourClockProto.use_24hour_clock)
  return _internal_use_24hour_clock();
}
inline void SystemUse24HourClockProto::_internal_set_use_24hour_clock(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.use_24hour_clock_ = value;
}
inline void SystemUse24HourClockProto::set_use_24hour_clock(bool value) {
  _internal_set_use_24hour_clock(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SystemUse24HourClockProto.use_24hour_clock)
}

// -------------------------------------------------------------------

// KioskAppInfoProto

// optional string app_id = 1;
inline bool KioskAppInfoProto::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KioskAppInfoProto::has_app_id() const {
  return _internal_has_app_id();
}
inline void KioskAppInfoProto::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KioskAppInfoProto::app_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.KioskAppInfoProto.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KioskAppInfoProto::set_app_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.KioskAppInfoProto.app_id)
}
inline std::string* KioskAppInfoProto::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.KioskAppInfoProto.app_id)
  return _s;
}
inline const std::string& KioskAppInfoProto::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void KioskAppInfoProto::_internal_set_app_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* KioskAppInfoProto::_internal_mutable_app_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* KioskAppInfoProto::release_app_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.KioskAppInfoProto.app_id)
  if (!_internal_has_app_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KioskAppInfoProto::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.KioskAppInfoProto.app_id)
}

// optional string update_url = 2;
inline bool KioskAppInfoProto::_internal_has_update_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KioskAppInfoProto::has_update_url() const {
  return _internal_has_update_url();
}
inline void KioskAppInfoProto::clear_update_url() {
  _impl_.update_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KioskAppInfoProto::update_url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.KioskAppInfoProto.update_url)
  return _internal_update_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KioskAppInfoProto::set_update_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.update_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.KioskAppInfoProto.update_url)
}
inline std::string* KioskAppInfoProto::mutable_update_url() {
  std::string* _s = _internal_mutable_update_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.KioskAppInfoProto.update_url)
  return _s;
}
inline const std::string& KioskAppInfoProto::_internal_update_url() const {
  return _impl_.update_url_.Get();
}
inline void KioskAppInfoProto::_internal_set_update_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.update_url_.Set(value, GetArenaForAllocation());
}
inline std::string* KioskAppInfoProto::_internal_mutable_update_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.update_url_.Mutable(GetArenaForAllocation());
}
inline std::string* KioskAppInfoProto::release_update_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.KioskAppInfoProto.update_url)
  if (!_internal_has_update_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.update_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.update_url_.IsDefault()) {
    _impl_.update_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KioskAppInfoProto::set_allocated_update_url(std::string* update_url) {
  if (update_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.update_url_.SetAllocated(update_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.update_url_.IsDefault()) {
    _impl_.update_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.KioskAppInfoProto.update_url)
}

// -------------------------------------------------------------------

// AndroidKioskAppInfoProto

// optional string package_name = 1;
inline bool AndroidKioskAppInfoProto::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AndroidKioskAppInfoProto::has_package_name() const {
  return _internal_has_package_name();
}
inline void AndroidKioskAppInfoProto::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AndroidKioskAppInfoProto::package_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidKioskAppInfoProto.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidKioskAppInfoProto::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidKioskAppInfoProto.package_name)
}
inline std::string* AndroidKioskAppInfoProto::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidKioskAppInfoProto.package_name)
  return _s;
}
inline const std::string& AndroidKioskAppInfoProto::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void AndroidKioskAppInfoProto::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidKioskAppInfoProto::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidKioskAppInfoProto::release_package_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidKioskAppInfoProto.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidKioskAppInfoProto::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidKioskAppInfoProto.package_name)
}

// optional string class_name = 2;
inline bool AndroidKioskAppInfoProto::_internal_has_class_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AndroidKioskAppInfoProto::has_class_name() const {
  return _internal_has_class_name();
}
inline void AndroidKioskAppInfoProto::clear_class_name() {
  _impl_.class_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AndroidKioskAppInfoProto::class_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidKioskAppInfoProto.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidKioskAppInfoProto::set_class_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.class_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidKioskAppInfoProto.class_name)
}
inline std::string* AndroidKioskAppInfoProto::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidKioskAppInfoProto.class_name)
  return _s;
}
inline const std::string& AndroidKioskAppInfoProto::_internal_class_name() const {
  return _impl_.class_name_.Get();
}
inline void AndroidKioskAppInfoProto::_internal_set_class_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidKioskAppInfoProto::_internal_mutable_class_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.class_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidKioskAppInfoProto::release_class_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidKioskAppInfoProto.class_name)
  if (!_internal_has_class_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.class_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class_name_.IsDefault()) {
    _impl_.class_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidKioskAppInfoProto::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.class_name_.SetAllocated(class_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class_name_.IsDefault()) {
    _impl_.class_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidKioskAppInfoProto.class_name)
}

// optional string action = 3;
inline bool AndroidKioskAppInfoProto::_internal_has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AndroidKioskAppInfoProto::has_action() const {
  return _internal_has_action();
}
inline void AndroidKioskAppInfoProto::clear_action() {
  _impl_.action_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AndroidKioskAppInfoProto::action() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidKioskAppInfoProto.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidKioskAppInfoProto::set_action(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidKioskAppInfoProto.action)
}
inline std::string* AndroidKioskAppInfoProto::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidKioskAppInfoProto.action)
  return _s;
}
inline const std::string& AndroidKioskAppInfoProto::_internal_action() const {
  return _impl_.action_.Get();
}
inline void AndroidKioskAppInfoProto::_internal_set_action(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidKioskAppInfoProto::_internal_mutable_action() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.action_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidKioskAppInfoProto::release_action() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidKioskAppInfoProto.action)
  if (!_internal_has_action()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.action_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidKioskAppInfoProto::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidKioskAppInfoProto.action)
}

// optional string display_name = 4;
inline bool AndroidKioskAppInfoProto::_internal_has_display_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AndroidKioskAppInfoProto::has_display_name() const {
  return _internal_has_display_name();
}
inline void AndroidKioskAppInfoProto::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AndroidKioskAppInfoProto::display_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidKioskAppInfoProto.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidKioskAppInfoProto::set_display_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidKioskAppInfoProto.display_name)
}
inline std::string* AndroidKioskAppInfoProto::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidKioskAppInfoProto.display_name)
  return _s;
}
inline const std::string& AndroidKioskAppInfoProto::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void AndroidKioskAppInfoProto::_internal_set_display_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidKioskAppInfoProto::_internal_mutable_display_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidKioskAppInfoProto::release_display_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidKioskAppInfoProto.display_name)
  if (!_internal_has_display_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.display_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidKioskAppInfoProto::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidKioskAppInfoProto.display_name)
}

// -------------------------------------------------------------------

// WebKioskAppInfoProto

// optional string url = 1;
inline bool WebKioskAppInfoProto::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WebKioskAppInfoProto::has_url() const {
  return _internal_has_url();
}
inline void WebKioskAppInfoProto::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WebKioskAppInfoProto::url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.WebKioskAppInfoProto.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebKioskAppInfoProto::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.WebKioskAppInfoProto.url)
}
inline std::string* WebKioskAppInfoProto::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.WebKioskAppInfoProto.url)
  return _s;
}
inline const std::string& WebKioskAppInfoProto::_internal_url() const {
  return _impl_.url_.Get();
}
inline void WebKioskAppInfoProto::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebKioskAppInfoProto::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebKioskAppInfoProto::release_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.WebKioskAppInfoProto.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WebKioskAppInfoProto::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.WebKioskAppInfoProto.url)
}

// optional string title = 2;
inline bool WebKioskAppInfoProto::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WebKioskAppInfoProto::has_title() const {
  return _internal_has_title();
}
inline void WebKioskAppInfoProto::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WebKioskAppInfoProto::title() const {
  // @@protoc_insertion_point(field_get:enterprise_management.WebKioskAppInfoProto.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebKioskAppInfoProto::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.WebKioskAppInfoProto.title)
}
inline std::string* WebKioskAppInfoProto::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:enterprise_management.WebKioskAppInfoProto.title)
  return _s;
}
inline const std::string& WebKioskAppInfoProto::_internal_title() const {
  return _impl_.title_.Get();
}
inline void WebKioskAppInfoProto::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* WebKioskAppInfoProto::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* WebKioskAppInfoProto::release_title() {
  // @@protoc_insertion_point(field_release:enterprise_management.WebKioskAppInfoProto.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WebKioskAppInfoProto::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.WebKioskAppInfoProto.title)
}

// optional string icon_url = 3;
inline bool WebKioskAppInfoProto::_internal_has_icon_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WebKioskAppInfoProto::has_icon_url() const {
  return _internal_has_icon_url();
}
inline void WebKioskAppInfoProto::clear_icon_url() {
  _impl_.icon_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WebKioskAppInfoProto::icon_url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.WebKioskAppInfoProto.icon_url)
  return _internal_icon_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebKioskAppInfoProto::set_icon_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.icon_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.WebKioskAppInfoProto.icon_url)
}
inline std::string* WebKioskAppInfoProto::mutable_icon_url() {
  std::string* _s = _internal_mutable_icon_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.WebKioskAppInfoProto.icon_url)
  return _s;
}
inline const std::string& WebKioskAppInfoProto::_internal_icon_url() const {
  return _impl_.icon_url_.Get();
}
inline void WebKioskAppInfoProto::_internal_set_icon_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.icon_url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebKioskAppInfoProto::_internal_mutable_icon_url() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.icon_url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebKioskAppInfoProto::release_icon_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.WebKioskAppInfoProto.icon_url)
  if (!_internal_has_icon_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.icon_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.icon_url_.IsDefault()) {
    _impl_.icon_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WebKioskAppInfoProto::set_allocated_icon_url(std::string* icon_url) {
  if (icon_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.icon_url_.SetAllocated(icon_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.icon_url_.IsDefault()) {
    _impl_.icon_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.WebKioskAppInfoProto.icon_url)
}

// -------------------------------------------------------------------

// DeviceLocalAccountInfoProto

// optional string deprecated_public_session_id = 1;
inline bool DeviceLocalAccountInfoProto::_internal_has_deprecated_public_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceLocalAccountInfoProto::has_deprecated_public_session_id() const {
  return _internal_has_deprecated_public_session_id();
}
inline void DeviceLocalAccountInfoProto::clear_deprecated_public_session_id() {
  _impl_.deprecated_public_session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceLocalAccountInfoProto::deprecated_public_session_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountInfoProto.deprecated_public_session_id)
  return _internal_deprecated_public_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceLocalAccountInfoProto::set_deprecated_public_session_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.deprecated_public_session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLocalAccountInfoProto.deprecated_public_session_id)
}
inline std::string* DeviceLocalAccountInfoProto::mutable_deprecated_public_session_id() {
  std::string* _s = _internal_mutable_deprecated_public_session_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLocalAccountInfoProto.deprecated_public_session_id)
  return _s;
}
inline const std::string& DeviceLocalAccountInfoProto::_internal_deprecated_public_session_id() const {
  return _impl_.deprecated_public_session_id_.Get();
}
inline void DeviceLocalAccountInfoProto::_internal_set_deprecated_public_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.deprecated_public_session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceLocalAccountInfoProto::_internal_mutable_deprecated_public_session_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.deprecated_public_session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceLocalAccountInfoProto::release_deprecated_public_session_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceLocalAccountInfoProto.deprecated_public_session_id)
  if (!_internal_has_deprecated_public_session_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.deprecated_public_session_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deprecated_public_session_id_.IsDefault()) {
    _impl_.deprecated_public_session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceLocalAccountInfoProto::set_allocated_deprecated_public_session_id(std::string* deprecated_public_session_id) {
  if (deprecated_public_session_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deprecated_public_session_id_.SetAllocated(deprecated_public_session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deprecated_public_session_id_.IsDefault()) {
    _impl_.deprecated_public_session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceLocalAccountInfoProto.deprecated_public_session_id)
}

// optional string account_id = 2;
inline bool DeviceLocalAccountInfoProto::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceLocalAccountInfoProto::has_account_id() const {
  return _internal_has_account_id();
}
inline void DeviceLocalAccountInfoProto::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceLocalAccountInfoProto::account_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountInfoProto.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceLocalAccountInfoProto::set_account_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLocalAccountInfoProto.account_id)
}
inline std::string* DeviceLocalAccountInfoProto::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLocalAccountInfoProto.account_id)
  return _s;
}
inline const std::string& DeviceLocalAccountInfoProto::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void DeviceLocalAccountInfoProto::_internal_set_account_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceLocalAccountInfoProto::_internal_mutable_account_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceLocalAccountInfoProto::release_account_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceLocalAccountInfoProto.account_id)
  if (!_internal_has_account_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.account_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceLocalAccountInfoProto::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceLocalAccountInfoProto.account_id)
}

// optional .enterprise_management.DeviceLocalAccountInfoProto.AccountType type = 3;
inline bool DeviceLocalAccountInfoProto::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceLocalAccountInfoProto::has_type() const {
  return _internal_has_type();
}
inline void DeviceLocalAccountInfoProto::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::_internal_type() const {
  return static_cast< ::enterprise_management::DeviceLocalAccountInfoProto_AccountType >(_impl_.type_);
}
inline ::enterprise_management::DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountInfoProto.type)
  return _internal_type();
}
inline void DeviceLocalAccountInfoProto::_internal_set_type(::enterprise_management::DeviceLocalAccountInfoProto_AccountType value) {
  assert(::enterprise_management::DeviceLocalAccountInfoProto_AccountType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_ = value;
}
inline void DeviceLocalAccountInfoProto::set_type(::enterprise_management::DeviceLocalAccountInfoProto_AccountType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLocalAccountInfoProto.type)
}

// optional .enterprise_management.KioskAppInfoProto kiosk_app = 4;
inline bool DeviceLocalAccountInfoProto::_internal_has_kiosk_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kiosk_app_ != nullptr);
  return value;
}
inline bool DeviceLocalAccountInfoProto::has_kiosk_app() const {
  return _internal_has_kiosk_app();
}
inline void DeviceLocalAccountInfoProto::clear_kiosk_app() {
  if (_impl_.kiosk_app_ != nullptr) _impl_.kiosk_app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::KioskAppInfoProto& DeviceLocalAccountInfoProto::_internal_kiosk_app() const {
  const ::enterprise_management::KioskAppInfoProto* p = _impl_.kiosk_app_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::KioskAppInfoProto&>(
      ::enterprise_management::_KioskAppInfoProto_default_instance_);
}
inline const ::enterprise_management::KioskAppInfoProto& DeviceLocalAccountInfoProto::kiosk_app() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountInfoProto.kiosk_app)
  return _internal_kiosk_app();
}
inline void DeviceLocalAccountInfoProto::unsafe_arena_set_allocated_kiosk_app(
    ::enterprise_management::KioskAppInfoProto* kiosk_app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kiosk_app_);
  }
  _impl_.kiosk_app_ = kiosk_app;
  if (kiosk_app) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceLocalAccountInfoProto.kiosk_app)
}
inline ::enterprise_management::KioskAppInfoProto* DeviceLocalAccountInfoProto::release_kiosk_app() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::KioskAppInfoProto* temp = _impl_.kiosk_app_;
  _impl_.kiosk_app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::KioskAppInfoProto* DeviceLocalAccountInfoProto::unsafe_arena_release_kiosk_app() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceLocalAccountInfoProto.kiosk_app)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::KioskAppInfoProto* temp = _impl_.kiosk_app_;
  _impl_.kiosk_app_ = nullptr;
  return temp;
}
inline ::enterprise_management::KioskAppInfoProto* DeviceLocalAccountInfoProto::_internal_mutable_kiosk_app() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.kiosk_app_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::KioskAppInfoProto>(GetArenaForAllocation());
    _impl_.kiosk_app_ = p;
  }
  return _impl_.kiosk_app_;
}
inline ::enterprise_management::KioskAppInfoProto* DeviceLocalAccountInfoProto::mutable_kiosk_app() {
  ::enterprise_management::KioskAppInfoProto* _msg = _internal_mutable_kiosk_app();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLocalAccountInfoProto.kiosk_app)
  return _msg;
}
inline void DeviceLocalAccountInfoProto::set_allocated_kiosk_app(::enterprise_management::KioskAppInfoProto* kiosk_app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.kiosk_app_;
  }
  if (kiosk_app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kiosk_app);
    if (message_arena != submessage_arena) {
      kiosk_app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kiosk_app, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.kiosk_app_ = kiosk_app;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceLocalAccountInfoProto.kiosk_app)
}

// optional .enterprise_management.AndroidKioskAppInfoProto android_kiosk_app = 5;
inline bool DeviceLocalAccountInfoProto::_internal_has_android_kiosk_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.android_kiosk_app_ != nullptr);
  return value;
}
inline bool DeviceLocalAccountInfoProto::has_android_kiosk_app() const {
  return _internal_has_android_kiosk_app();
}
inline void DeviceLocalAccountInfoProto::clear_android_kiosk_app() {
  if (_impl_.android_kiosk_app_ != nullptr) _impl_.android_kiosk_app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::AndroidKioskAppInfoProto& DeviceLocalAccountInfoProto::_internal_android_kiosk_app() const {
  const ::enterprise_management::AndroidKioskAppInfoProto* p = _impl_.android_kiosk_app_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AndroidKioskAppInfoProto&>(
      ::enterprise_management::_AndroidKioskAppInfoProto_default_instance_);
}
inline const ::enterprise_management::AndroidKioskAppInfoProto& DeviceLocalAccountInfoProto::android_kiosk_app() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountInfoProto.android_kiosk_app)
  return _internal_android_kiosk_app();
}
inline void DeviceLocalAccountInfoProto::unsafe_arena_set_allocated_android_kiosk_app(
    ::enterprise_management::AndroidKioskAppInfoProto* android_kiosk_app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.android_kiosk_app_);
  }
  _impl_.android_kiosk_app_ = android_kiosk_app;
  if (android_kiosk_app) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceLocalAccountInfoProto.android_kiosk_app)
}
inline ::enterprise_management::AndroidKioskAppInfoProto* DeviceLocalAccountInfoProto::release_android_kiosk_app() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::AndroidKioskAppInfoProto* temp = _impl_.android_kiosk_app_;
  _impl_.android_kiosk_app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AndroidKioskAppInfoProto* DeviceLocalAccountInfoProto::unsafe_arena_release_android_kiosk_app() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceLocalAccountInfoProto.android_kiosk_app)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::AndroidKioskAppInfoProto* temp = _impl_.android_kiosk_app_;
  _impl_.android_kiosk_app_ = nullptr;
  return temp;
}
inline ::enterprise_management::AndroidKioskAppInfoProto* DeviceLocalAccountInfoProto::_internal_mutable_android_kiosk_app() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.android_kiosk_app_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AndroidKioskAppInfoProto>(GetArenaForAllocation());
    _impl_.android_kiosk_app_ = p;
  }
  return _impl_.android_kiosk_app_;
}
inline ::enterprise_management::AndroidKioskAppInfoProto* DeviceLocalAccountInfoProto::mutable_android_kiosk_app() {
  ::enterprise_management::AndroidKioskAppInfoProto* _msg = _internal_mutable_android_kiosk_app();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLocalAccountInfoProto.android_kiosk_app)
  return _msg;
}
inline void DeviceLocalAccountInfoProto::set_allocated_android_kiosk_app(::enterprise_management::AndroidKioskAppInfoProto* android_kiosk_app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.android_kiosk_app_;
  }
  if (android_kiosk_app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(android_kiosk_app);
    if (message_arena != submessage_arena) {
      android_kiosk_app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, android_kiosk_app, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.android_kiosk_app_ = android_kiosk_app;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceLocalAccountInfoProto.android_kiosk_app)
}

// optional .enterprise_management.WebKioskAppInfoProto web_kiosk_app = 6;
inline bool DeviceLocalAccountInfoProto::_internal_has_web_kiosk_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.web_kiosk_app_ != nullptr);
  return value;
}
inline bool DeviceLocalAccountInfoProto::has_web_kiosk_app() const {
  return _internal_has_web_kiosk_app();
}
inline void DeviceLocalAccountInfoProto::clear_web_kiosk_app() {
  if (_impl_.web_kiosk_app_ != nullptr) _impl_.web_kiosk_app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::WebKioskAppInfoProto& DeviceLocalAccountInfoProto::_internal_web_kiosk_app() const {
  const ::enterprise_management::WebKioskAppInfoProto* p = _impl_.web_kiosk_app_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::WebKioskAppInfoProto&>(
      ::enterprise_management::_WebKioskAppInfoProto_default_instance_);
}
inline const ::enterprise_management::WebKioskAppInfoProto& DeviceLocalAccountInfoProto::web_kiosk_app() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountInfoProto.web_kiosk_app)
  return _internal_web_kiosk_app();
}
inline void DeviceLocalAccountInfoProto::unsafe_arena_set_allocated_web_kiosk_app(
    ::enterprise_management::WebKioskAppInfoProto* web_kiosk_app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_kiosk_app_);
  }
  _impl_.web_kiosk_app_ = web_kiosk_app;
  if (web_kiosk_app) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceLocalAccountInfoProto.web_kiosk_app)
}
inline ::enterprise_management::WebKioskAppInfoProto* DeviceLocalAccountInfoProto::release_web_kiosk_app() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::WebKioskAppInfoProto* temp = _impl_.web_kiosk_app_;
  _impl_.web_kiosk_app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::WebKioskAppInfoProto* DeviceLocalAccountInfoProto::unsafe_arena_release_web_kiosk_app() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceLocalAccountInfoProto.web_kiosk_app)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::WebKioskAppInfoProto* temp = _impl_.web_kiosk_app_;
  _impl_.web_kiosk_app_ = nullptr;
  return temp;
}
inline ::enterprise_management::WebKioskAppInfoProto* DeviceLocalAccountInfoProto::_internal_mutable_web_kiosk_app() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.web_kiosk_app_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::WebKioskAppInfoProto>(GetArenaForAllocation());
    _impl_.web_kiosk_app_ = p;
  }
  return _impl_.web_kiosk_app_;
}
inline ::enterprise_management::WebKioskAppInfoProto* DeviceLocalAccountInfoProto::mutable_web_kiosk_app() {
  ::enterprise_management::WebKioskAppInfoProto* _msg = _internal_mutable_web_kiosk_app();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLocalAccountInfoProto.web_kiosk_app)
  return _msg;
}
inline void DeviceLocalAccountInfoProto::set_allocated_web_kiosk_app(::enterprise_management::WebKioskAppInfoProto* web_kiosk_app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.web_kiosk_app_;
  }
  if (web_kiosk_app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(web_kiosk_app);
    if (message_arena != submessage_arena) {
      web_kiosk_app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, web_kiosk_app, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.web_kiosk_app_ = web_kiosk_app;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceLocalAccountInfoProto.web_kiosk_app)
}

// -------------------------------------------------------------------

// DeviceLocalAccountsProto

// repeated .enterprise_management.DeviceLocalAccountInfoProto account = 1;
inline int DeviceLocalAccountsProto::_internal_account_size() const {
  return _impl_.account_.size();
}
inline int DeviceLocalAccountsProto::account_size() const {
  return _internal_account_size();
}
inline void DeviceLocalAccountsProto::clear_account() {
  _impl_.account_.Clear();
}
inline ::enterprise_management::DeviceLocalAccountInfoProto* DeviceLocalAccountsProto::mutable_account(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLocalAccountsProto.account)
  return _impl_.account_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceLocalAccountInfoProto >*
DeviceLocalAccountsProto::mutable_account() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceLocalAccountsProto.account)
  return &_impl_.account_;
}
inline const ::enterprise_management::DeviceLocalAccountInfoProto& DeviceLocalAccountsProto::_internal_account(int index) const {
  return _impl_.account_.Get(index);
}
inline const ::enterprise_management::DeviceLocalAccountInfoProto& DeviceLocalAccountsProto::account(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountsProto.account)
  return _internal_account(index);
}
inline ::enterprise_management::DeviceLocalAccountInfoProto* DeviceLocalAccountsProto::_internal_add_account() {
  return _impl_.account_.Add();
}
inline ::enterprise_management::DeviceLocalAccountInfoProto* DeviceLocalAccountsProto::add_account() {
  ::enterprise_management::DeviceLocalAccountInfoProto* _add = _internal_add_account();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceLocalAccountsProto.account)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceLocalAccountInfoProto >&
DeviceLocalAccountsProto::account() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceLocalAccountsProto.account)
  return _impl_.account_;
}

// optional string auto_login_id = 2;
inline bool DeviceLocalAccountsProto::_internal_has_auto_login_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceLocalAccountsProto::has_auto_login_id() const {
  return _internal_has_auto_login_id();
}
inline void DeviceLocalAccountsProto::clear_auto_login_id() {
  _impl_.auto_login_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceLocalAccountsProto::auto_login_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountsProto.auto_login_id)
  return _internal_auto_login_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceLocalAccountsProto::set_auto_login_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.auto_login_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLocalAccountsProto.auto_login_id)
}
inline std::string* DeviceLocalAccountsProto::mutable_auto_login_id() {
  std::string* _s = _internal_mutable_auto_login_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLocalAccountsProto.auto_login_id)
  return _s;
}
inline const std::string& DeviceLocalAccountsProto::_internal_auto_login_id() const {
  return _impl_.auto_login_id_.Get();
}
inline void DeviceLocalAccountsProto::_internal_set_auto_login_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auto_login_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceLocalAccountsProto::_internal_mutable_auto_login_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auto_login_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceLocalAccountsProto::release_auto_login_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceLocalAccountsProto.auto_login_id)
  if (!_internal_has_auto_login_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.auto_login_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auto_login_id_.IsDefault()) {
    _impl_.auto_login_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceLocalAccountsProto::set_allocated_auto_login_id(std::string* auto_login_id) {
  if (auto_login_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auto_login_id_.SetAllocated(auto_login_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auto_login_id_.IsDefault()) {
    _impl_.auto_login_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceLocalAccountsProto.auto_login_id)
}

// optional int64 auto_login_delay = 3;
inline bool DeviceLocalAccountsProto::_internal_has_auto_login_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceLocalAccountsProto::has_auto_login_delay() const {
  return _internal_has_auto_login_delay();
}
inline void DeviceLocalAccountsProto::clear_auto_login_delay() {
  _impl_.auto_login_delay_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t DeviceLocalAccountsProto::_internal_auto_login_delay() const {
  return _impl_.auto_login_delay_;
}
inline int64_t DeviceLocalAccountsProto::auto_login_delay() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountsProto.auto_login_delay)
  return _internal_auto_login_delay();
}
inline void DeviceLocalAccountsProto::_internal_set_auto_login_delay(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.auto_login_delay_ = value;
}
inline void DeviceLocalAccountsProto::set_auto_login_delay(int64_t value) {
  _internal_set_auto_login_delay(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLocalAccountsProto.auto_login_delay)
}

// optional bool enable_auto_login_bailout = 4 [default = true];
inline bool DeviceLocalAccountsProto::_internal_has_enable_auto_login_bailout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceLocalAccountsProto::has_enable_auto_login_bailout() const {
  return _internal_has_enable_auto_login_bailout();
}
inline void DeviceLocalAccountsProto::clear_enable_auto_login_bailout() {
  _impl_.enable_auto_login_bailout_ = true;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool DeviceLocalAccountsProto::_internal_enable_auto_login_bailout() const {
  return _impl_.enable_auto_login_bailout_;
}
inline bool DeviceLocalAccountsProto::enable_auto_login_bailout() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountsProto.enable_auto_login_bailout)
  return _internal_enable_auto_login_bailout();
}
inline void DeviceLocalAccountsProto::_internal_set_enable_auto_login_bailout(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.enable_auto_login_bailout_ = value;
}
inline void DeviceLocalAccountsProto::set_enable_auto_login_bailout(bool value) {
  _internal_set_enable_auto_login_bailout(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLocalAccountsProto.enable_auto_login_bailout)
}

// optional bool prompt_for_network_when_offline = 5 [default = true];
inline bool DeviceLocalAccountsProto::_internal_has_prompt_for_network_when_offline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceLocalAccountsProto::has_prompt_for_network_when_offline() const {
  return _internal_has_prompt_for_network_when_offline();
}
inline void DeviceLocalAccountsProto::clear_prompt_for_network_when_offline() {
  _impl_.prompt_for_network_when_offline_ = true;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DeviceLocalAccountsProto::_internal_prompt_for_network_when_offline() const {
  return _impl_.prompt_for_network_when_offline_;
}
inline bool DeviceLocalAccountsProto::prompt_for_network_when_offline() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLocalAccountsProto.prompt_for_network_when_offline)
  return _internal_prompt_for_network_when_offline();
}
inline void DeviceLocalAccountsProto::_internal_set_prompt_for_network_when_offline(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prompt_for_network_when_offline_ = value;
}
inline void DeviceLocalAccountsProto::set_prompt_for_network_when_offline(bool value) {
  _internal_set_prompt_for_network_when_offline(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLocalAccountsProto.prompt_for_network_when_offline)
}

// -------------------------------------------------------------------

// ManagedGuestSessionPrivacyWarningsProto

// optional bool enabled = 1 [default = true];
inline bool ManagedGuestSessionPrivacyWarningsProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ManagedGuestSessionPrivacyWarningsProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void ManagedGuestSessionPrivacyWarningsProto::clear_enabled() {
  _impl_.enabled_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ManagedGuestSessionPrivacyWarningsProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ManagedGuestSessionPrivacyWarningsProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ManagedGuestSessionPrivacyWarningsProto.enabled)
  return _internal_enabled();
}
inline void ManagedGuestSessionPrivacyWarningsProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void ManagedGuestSessionPrivacyWarningsProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ManagedGuestSessionPrivacyWarningsProto.enabled)
}

// -------------------------------------------------------------------

// AllowRedeemChromeOsRegistrationOffersProto

// optional bool allow_redeem_offers = 1 [default = true];
inline bool AllowRedeemChromeOsRegistrationOffersProto::_internal_has_allow_redeem_offers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllowRedeemChromeOsRegistrationOffersProto::has_allow_redeem_offers() const {
  return _internal_has_allow_redeem_offers();
}
inline void AllowRedeemChromeOsRegistrationOffersProto::clear_allow_redeem_offers() {
  _impl_.allow_redeem_offers_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AllowRedeemChromeOsRegistrationOffersProto::_internal_allow_redeem_offers() const {
  return _impl_.allow_redeem_offers_;
}
inline bool AllowRedeemChromeOsRegistrationOffersProto::allow_redeem_offers() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto.allow_redeem_offers)
  return _internal_allow_redeem_offers();
}
inline void AllowRedeemChromeOsRegistrationOffersProto::_internal_set_allow_redeem_offers(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allow_redeem_offers_ = value;
}
inline void AllowRedeemChromeOsRegistrationOffersProto::set_allow_redeem_offers(bool value) {
  _internal_set_allow_redeem_offers(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto.allow_redeem_offers)
}

// -------------------------------------------------------------------

// FeatureFlagsProto

// repeated string switches = 1 [deprecated = true];
inline int FeatureFlagsProto::_internal_switches_size() const {
  return _impl_.switches_.size();
}
inline int FeatureFlagsProto::switches_size() const {
  return _internal_switches_size();
}
inline void FeatureFlagsProto::clear_switches() {
  _impl_.switches_.Clear();
}
inline std::string* FeatureFlagsProto::add_switches() {
  std::string* _s = _internal_add_switches();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.FeatureFlagsProto.switches)
  return _s;
}
inline const std::string& FeatureFlagsProto::_internal_switches(int index) const {
  return _impl_.switches_.Get(index);
}
inline const std::string& FeatureFlagsProto::switches(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.FeatureFlagsProto.switches)
  return _internal_switches(index);
}
inline std::string* FeatureFlagsProto::mutable_switches(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.FeatureFlagsProto.switches)
  return _impl_.switches_.Mutable(index);
}
inline void FeatureFlagsProto::set_switches(int index, const std::string& value) {
  _impl_.switches_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.FeatureFlagsProto.switches)
}
inline void FeatureFlagsProto::set_switches(int index, std::string&& value) {
  _impl_.switches_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.FeatureFlagsProto.switches)
}
inline void FeatureFlagsProto::set_switches(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.switches_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.FeatureFlagsProto.switches)
}
inline void FeatureFlagsProto::set_switches(int index, const char* value, size_t size) {
  _impl_.switches_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.FeatureFlagsProto.switches)
}
inline std::string* FeatureFlagsProto::_internal_add_switches() {
  return _impl_.switches_.Add();
}
inline void FeatureFlagsProto::add_switches(const std::string& value) {
  _impl_.switches_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.FeatureFlagsProto.switches)
}
inline void FeatureFlagsProto::add_switches(std::string&& value) {
  _impl_.switches_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.FeatureFlagsProto.switches)
}
inline void FeatureFlagsProto::add_switches(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.switches_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.FeatureFlagsProto.switches)
}
inline void FeatureFlagsProto::add_switches(const char* value, size_t size) {
  _impl_.switches_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.FeatureFlagsProto.switches)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeatureFlagsProto::switches() const {
  // @@protoc_insertion_point(field_list:enterprise_management.FeatureFlagsProto.switches)
  return _impl_.switches_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FeatureFlagsProto::mutable_switches() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.FeatureFlagsProto.switches)
  return &_impl_.switches_;
}

// repeated string feature_flags = 2;
inline int FeatureFlagsProto::_internal_feature_flags_size() const {
  return _impl_.feature_flags_.size();
}
inline int FeatureFlagsProto::feature_flags_size() const {
  return _internal_feature_flags_size();
}
inline void FeatureFlagsProto::clear_feature_flags() {
  _impl_.feature_flags_.Clear();
}
inline std::string* FeatureFlagsProto::add_feature_flags() {
  std::string* _s = _internal_add_feature_flags();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.FeatureFlagsProto.feature_flags)
  return _s;
}
inline const std::string& FeatureFlagsProto::_internal_feature_flags(int index) const {
  return _impl_.feature_flags_.Get(index);
}
inline const std::string& FeatureFlagsProto::feature_flags(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.FeatureFlagsProto.feature_flags)
  return _internal_feature_flags(index);
}
inline std::string* FeatureFlagsProto::mutable_feature_flags(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.FeatureFlagsProto.feature_flags)
  return _impl_.feature_flags_.Mutable(index);
}
inline void FeatureFlagsProto::set_feature_flags(int index, const std::string& value) {
  _impl_.feature_flags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.FeatureFlagsProto.feature_flags)
}
inline void FeatureFlagsProto::set_feature_flags(int index, std::string&& value) {
  _impl_.feature_flags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.FeatureFlagsProto.feature_flags)
}
inline void FeatureFlagsProto::set_feature_flags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.feature_flags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.FeatureFlagsProto.feature_flags)
}
inline void FeatureFlagsProto::set_feature_flags(int index, const char* value, size_t size) {
  _impl_.feature_flags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.FeatureFlagsProto.feature_flags)
}
inline std::string* FeatureFlagsProto::_internal_add_feature_flags() {
  return _impl_.feature_flags_.Add();
}
inline void FeatureFlagsProto::add_feature_flags(const std::string& value) {
  _impl_.feature_flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.FeatureFlagsProto.feature_flags)
}
inline void FeatureFlagsProto::add_feature_flags(std::string&& value) {
  _impl_.feature_flags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.FeatureFlagsProto.feature_flags)
}
inline void FeatureFlagsProto::add_feature_flags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.feature_flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.FeatureFlagsProto.feature_flags)
}
inline void FeatureFlagsProto::add_feature_flags(const char* value, size_t size) {
  _impl_.feature_flags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.FeatureFlagsProto.feature_flags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeatureFlagsProto::feature_flags() const {
  // @@protoc_insertion_point(field_list:enterprise_management.FeatureFlagsProto.feature_flags)
  return _impl_.feature_flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FeatureFlagsProto::mutable_feature_flags() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.FeatureFlagsProto.feature_flags)
  return &_impl_.feature_flags_;
}

// -------------------------------------------------------------------

// UptimeLimitProto

// optional int64 OBSOLETE_uptime_limit = 1 [deprecated = true];
inline bool UptimeLimitProto::_internal_has_obsolete_uptime_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UptimeLimitProto::has_obsolete_uptime_limit() const {
  return _internal_has_obsolete_uptime_limit();
}
inline void UptimeLimitProto::clear_obsolete_uptime_limit() {
  _impl_.obsolete_uptime_limit_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t UptimeLimitProto::_internal_obsolete_uptime_limit() const {
  return _impl_.obsolete_uptime_limit_;
}
inline int64_t UptimeLimitProto::obsolete_uptime_limit() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UptimeLimitProto.OBSOLETE_uptime_limit)
  return _internal_obsolete_uptime_limit();
}
inline void UptimeLimitProto::_internal_set_obsolete_uptime_limit(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_uptime_limit_ = value;
}
inline void UptimeLimitProto::set_obsolete_uptime_limit(int64_t value) {
  _internal_set_obsolete_uptime_limit(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UptimeLimitProto.OBSOLETE_uptime_limit)
}

// optional int64 uptime_limit = 2;
inline bool UptimeLimitProto::_internal_has_uptime_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UptimeLimitProto::has_uptime_limit() const {
  return _internal_has_uptime_limit();
}
inline void UptimeLimitProto::clear_uptime_limit() {
  _impl_.uptime_limit_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t UptimeLimitProto::_internal_uptime_limit() const {
  return _impl_.uptime_limit_;
}
inline int64_t UptimeLimitProto::uptime_limit() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UptimeLimitProto.uptime_limit)
  return _internal_uptime_limit();
}
inline void UptimeLimitProto::_internal_set_uptime_limit(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uptime_limit_ = value;
}
inline void UptimeLimitProto::set_uptime_limit(int64_t value) {
  _internal_set_uptime_limit(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UptimeLimitProto.uptime_limit)
}

// -------------------------------------------------------------------

// VariationsParameterProto

// optional string parameter = 1;
inline bool VariationsParameterProto::_internal_has_parameter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VariationsParameterProto::has_parameter() const {
  return _internal_has_parameter();
}
inline void VariationsParameterProto::clear_parameter() {
  _impl_.parameter_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VariationsParameterProto::parameter() const {
  // @@protoc_insertion_point(field_get:enterprise_management.VariationsParameterProto.parameter)
  return _internal_parameter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VariationsParameterProto::set_parameter(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.parameter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.VariationsParameterProto.parameter)
}
inline std::string* VariationsParameterProto::mutable_parameter() {
  std::string* _s = _internal_mutable_parameter();
  // @@protoc_insertion_point(field_mutable:enterprise_management.VariationsParameterProto.parameter)
  return _s;
}
inline const std::string& VariationsParameterProto::_internal_parameter() const {
  return _impl_.parameter_.Get();
}
inline void VariationsParameterProto::_internal_set_parameter(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parameter_.Set(value, GetArenaForAllocation());
}
inline std::string* VariationsParameterProto::_internal_mutable_parameter() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.parameter_.Mutable(GetArenaForAllocation());
}
inline std::string* VariationsParameterProto::release_parameter() {
  // @@protoc_insertion_point(field_release:enterprise_management.VariationsParameterProto.parameter)
  if (!_internal_has_parameter()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.parameter_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parameter_.IsDefault()) {
    _impl_.parameter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VariationsParameterProto::set_allocated_parameter(std::string* parameter) {
  if (parameter != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parameter_.SetAllocated(parameter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parameter_.IsDefault()) {
    _impl_.parameter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.VariationsParameterProto.parameter)
}

// -------------------------------------------------------------------

// AttestationSettingsProto

// optional bool attestation_enabled = 1 [default = false];
inline bool AttestationSettingsProto::_internal_has_attestation_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AttestationSettingsProto::has_attestation_enabled() const {
  return _internal_has_attestation_enabled();
}
inline void AttestationSettingsProto::clear_attestation_enabled() {
  _impl_.attestation_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AttestationSettingsProto::_internal_attestation_enabled() const {
  return _impl_.attestation_enabled_;
}
inline bool AttestationSettingsProto::attestation_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AttestationSettingsProto.attestation_enabled)
  return _internal_attestation_enabled();
}
inline void AttestationSettingsProto::_internal_set_attestation_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attestation_enabled_ = value;
}
inline void AttestationSettingsProto::set_attestation_enabled(bool value) {
  _internal_set_attestation_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AttestationSettingsProto.attestation_enabled)
}

// optional bool content_protection_enabled = 2 [default = true];
inline bool AttestationSettingsProto::_internal_has_content_protection_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AttestationSettingsProto::has_content_protection_enabled() const {
  return _internal_has_content_protection_enabled();
}
inline void AttestationSettingsProto::clear_content_protection_enabled() {
  _impl_.content_protection_enabled_ = true;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AttestationSettingsProto::_internal_content_protection_enabled() const {
  return _impl_.content_protection_enabled_;
}
inline bool AttestationSettingsProto::content_protection_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AttestationSettingsProto.content_protection_enabled)
  return _internal_content_protection_enabled();
}
inline void AttestationSettingsProto::_internal_set_content_protection_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_protection_enabled_ = value;
}
inline void AttestationSettingsProto::set_content_protection_enabled(bool value) {
  _internal_set_content_protection_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AttestationSettingsProto.content_protection_enabled)
}

// -------------------------------------------------------------------

// AccessibilitySettingsProto

// optional bool login_screen_default_large_cursor_enabled = 1;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_default_large_cursor_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_default_large_cursor_enabled() const {
  return _internal_has_login_screen_default_large_cursor_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_default_large_cursor_enabled() {
  _impl_.login_screen_default_large_cursor_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_default_large_cursor_enabled() const {
  return _impl_.login_screen_default_large_cursor_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_default_large_cursor_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_default_large_cursor_enabled)
  return _internal_login_screen_default_large_cursor_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_default_large_cursor_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.login_screen_default_large_cursor_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_default_large_cursor_enabled(bool value) {
  _internal_set_login_screen_default_large_cursor_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_default_large_cursor_enabled)
}

// optional bool login_screen_default_spoken_feedback_enabled = 2;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_default_spoken_feedback_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_default_spoken_feedback_enabled() const {
  return _internal_has_login_screen_default_spoken_feedback_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_default_spoken_feedback_enabled() {
  _impl_.login_screen_default_spoken_feedback_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_default_spoken_feedback_enabled() const {
  return _impl_.login_screen_default_spoken_feedback_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_default_spoken_feedback_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_default_spoken_feedback_enabled)
  return _internal_login_screen_default_spoken_feedback_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_default_spoken_feedback_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.login_screen_default_spoken_feedback_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_default_spoken_feedback_enabled(bool value) {
  _internal_set_login_screen_default_spoken_feedback_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_default_spoken_feedback_enabled)
}

// optional bool login_screen_default_high_contrast_enabled = 3;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_default_high_contrast_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_default_high_contrast_enabled() const {
  return _internal_has_login_screen_default_high_contrast_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_default_high_contrast_enabled() {
  _impl_.login_screen_default_high_contrast_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_default_high_contrast_enabled() const {
  return _impl_.login_screen_default_high_contrast_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_default_high_contrast_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_default_high_contrast_enabled)
  return _internal_login_screen_default_high_contrast_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_default_high_contrast_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.login_screen_default_high_contrast_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_default_high_contrast_enabled(bool value) {
  _internal_set_login_screen_default_high_contrast_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_default_high_contrast_enabled)
}

// optional .enterprise_management.AccessibilitySettingsProto.ScreenMagnifierType login_screen_default_screen_magnifier_type = 4;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_default_screen_magnifier_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_default_screen_magnifier_type() const {
  return _internal_has_login_screen_default_screen_magnifier_type();
}
inline void AccessibilitySettingsProto::clear_login_screen_default_screen_magnifier_type() {
  _impl_.login_screen_default_screen_magnifier_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType AccessibilitySettingsProto::_internal_login_screen_default_screen_magnifier_type() const {
  return static_cast< ::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType >(_impl_.login_screen_default_screen_magnifier_type_);
}
inline ::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType AccessibilitySettingsProto::login_screen_default_screen_magnifier_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_default_screen_magnifier_type)
  return _internal_login_screen_default_screen_magnifier_type();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_default_screen_magnifier_type(::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType value) {
  assert(::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.login_screen_default_screen_magnifier_type_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_default_screen_magnifier_type(::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType value) {
  _internal_set_login_screen_default_screen_magnifier_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_default_screen_magnifier_type)
}

// optional bool login_screen_default_virtual_keyboard_enabled = 5;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_default_virtual_keyboard_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_default_virtual_keyboard_enabled() const {
  return _internal_has_login_screen_default_virtual_keyboard_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_default_virtual_keyboard_enabled() {
  _impl_.login_screen_default_virtual_keyboard_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_default_virtual_keyboard_enabled() const {
  return _impl_.login_screen_default_virtual_keyboard_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_default_virtual_keyboard_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_default_virtual_keyboard_enabled)
  return _internal_login_screen_default_virtual_keyboard_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_default_virtual_keyboard_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.login_screen_default_virtual_keyboard_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_default_virtual_keyboard_enabled(bool value) {
  _internal_set_login_screen_default_virtual_keyboard_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_default_virtual_keyboard_enabled)
}

// optional bool login_screen_large_cursor_enabled = 6;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_large_cursor_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_large_cursor_enabled() const {
  return _internal_has_login_screen_large_cursor_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_large_cursor_enabled() {
  _impl_.login_screen_large_cursor_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_large_cursor_enabled() const {
  return _impl_.login_screen_large_cursor_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_large_cursor_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_large_cursor_enabled)
  return _internal_login_screen_large_cursor_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_large_cursor_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.login_screen_large_cursor_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_large_cursor_enabled(bool value) {
  _internal_set_login_screen_large_cursor_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_large_cursor_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_large_cursor_enabled_options = 7;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_large_cursor_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_large_cursor_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_large_cursor_enabled_options() const {
  return _internal_has_login_screen_large_cursor_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_large_cursor_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_large_cursor_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_large_cursor_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_large_cursor_enabled_options)
  return _internal_login_screen_large_cursor_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_large_cursor_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_large_cursor_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_large_cursor_enabled_options_);
  }
  _impl_.login_screen_large_cursor_enabled_options_ = login_screen_large_cursor_enabled_options;
  if (login_screen_large_cursor_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_large_cursor_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_large_cursor_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_large_cursor_enabled_options_;
  _impl_.login_screen_large_cursor_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_large_cursor_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_large_cursor_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_large_cursor_enabled_options_;
  _impl_.login_screen_large_cursor_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_large_cursor_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.login_screen_large_cursor_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_large_cursor_enabled_options_ = p;
  }
  return _impl_.login_screen_large_cursor_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_large_cursor_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_large_cursor_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_large_cursor_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_large_cursor_enabled_options(::enterprise_management::PolicyOptions* login_screen_large_cursor_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_large_cursor_enabled_options_);
  }
  if (login_screen_large_cursor_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_large_cursor_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_large_cursor_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_large_cursor_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.login_screen_large_cursor_enabled_options_ = login_screen_large_cursor_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_large_cursor_enabled_options)
}

// optional bool login_screen_spoken_feedback_enabled = 8;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_spoken_feedback_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_spoken_feedback_enabled() const {
  return _internal_has_login_screen_spoken_feedback_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_spoken_feedback_enabled() {
  _impl_.login_screen_spoken_feedback_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_spoken_feedback_enabled() const {
  return _impl_.login_screen_spoken_feedback_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_spoken_feedback_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_spoken_feedback_enabled)
  return _internal_login_screen_spoken_feedback_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_spoken_feedback_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.login_screen_spoken_feedback_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_spoken_feedback_enabled(bool value) {
  _internal_set_login_screen_spoken_feedback_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_spoken_feedback_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_spoken_feedback_enabled_options = 9;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_spoken_feedback_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_spoken_feedback_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_spoken_feedback_enabled_options() const {
  return _internal_has_login_screen_spoken_feedback_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_spoken_feedback_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_spoken_feedback_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_spoken_feedback_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_spoken_feedback_enabled_options)
  return _internal_login_screen_spoken_feedback_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_spoken_feedback_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_spoken_feedback_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_spoken_feedback_enabled_options_);
  }
  _impl_.login_screen_spoken_feedback_enabled_options_ = login_screen_spoken_feedback_enabled_options;
  if (login_screen_spoken_feedback_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_spoken_feedback_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_spoken_feedback_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_spoken_feedback_enabled_options_;
  _impl_.login_screen_spoken_feedback_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_spoken_feedback_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_spoken_feedback_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_spoken_feedback_enabled_options_;
  _impl_.login_screen_spoken_feedback_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_spoken_feedback_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.login_screen_spoken_feedback_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_spoken_feedback_enabled_options_ = p;
  }
  return _impl_.login_screen_spoken_feedback_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_spoken_feedback_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_spoken_feedback_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_spoken_feedback_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_spoken_feedback_enabled_options(::enterprise_management::PolicyOptions* login_screen_spoken_feedback_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_spoken_feedback_enabled_options_);
  }
  if (login_screen_spoken_feedback_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_spoken_feedback_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_spoken_feedback_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_spoken_feedback_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.login_screen_spoken_feedback_enabled_options_ = login_screen_spoken_feedback_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_spoken_feedback_enabled_options)
}

// optional bool login_screen_high_contrast_enabled = 10;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_high_contrast_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_high_contrast_enabled() const {
  return _internal_has_login_screen_high_contrast_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_high_contrast_enabled() {
  _impl_.login_screen_high_contrast_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_high_contrast_enabled() const {
  return _impl_.login_screen_high_contrast_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_high_contrast_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_high_contrast_enabled)
  return _internal_login_screen_high_contrast_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_high_contrast_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.login_screen_high_contrast_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_high_contrast_enabled(bool value) {
  _internal_set_login_screen_high_contrast_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_high_contrast_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_high_contrast_enabled_options = 11;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_high_contrast_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_high_contrast_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_high_contrast_enabled_options() const {
  return _internal_has_login_screen_high_contrast_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_high_contrast_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_high_contrast_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_high_contrast_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_high_contrast_enabled_options)
  return _internal_login_screen_high_contrast_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_high_contrast_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_high_contrast_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_high_contrast_enabled_options_);
  }
  _impl_.login_screen_high_contrast_enabled_options_ = login_screen_high_contrast_enabled_options;
  if (login_screen_high_contrast_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_high_contrast_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_high_contrast_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_high_contrast_enabled_options_;
  _impl_.login_screen_high_contrast_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_high_contrast_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_high_contrast_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_high_contrast_enabled_options_;
  _impl_.login_screen_high_contrast_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_high_contrast_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.login_screen_high_contrast_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_high_contrast_enabled_options_ = p;
  }
  return _impl_.login_screen_high_contrast_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_high_contrast_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_high_contrast_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_high_contrast_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_high_contrast_enabled_options(::enterprise_management::PolicyOptions* login_screen_high_contrast_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_high_contrast_enabled_options_);
  }
  if (login_screen_high_contrast_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_high_contrast_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_high_contrast_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_high_contrast_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.login_screen_high_contrast_enabled_options_ = login_screen_high_contrast_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_high_contrast_enabled_options)
}

// optional bool login_screen_virtual_keyboard_enabled = 12;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_virtual_keyboard_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_virtual_keyboard_enabled() const {
  return _internal_has_login_screen_virtual_keyboard_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_virtual_keyboard_enabled() {
  _impl_.login_screen_virtual_keyboard_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_virtual_keyboard_enabled() const {
  return _impl_.login_screen_virtual_keyboard_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_virtual_keyboard_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_virtual_keyboard_enabled)
  return _internal_login_screen_virtual_keyboard_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_virtual_keyboard_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.login_screen_virtual_keyboard_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_virtual_keyboard_enabled(bool value) {
  _internal_set_login_screen_virtual_keyboard_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_virtual_keyboard_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_virtual_keyboard_enabled_options = 13;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_virtual_keyboard_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_virtual_keyboard_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_virtual_keyboard_enabled_options() const {
  return _internal_has_login_screen_virtual_keyboard_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_virtual_keyboard_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_virtual_keyboard_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_virtual_keyboard_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_virtual_keyboard_enabled_options)
  return _internal_login_screen_virtual_keyboard_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_virtual_keyboard_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_virtual_keyboard_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_virtual_keyboard_enabled_options_);
  }
  _impl_.login_screen_virtual_keyboard_enabled_options_ = login_screen_virtual_keyboard_enabled_options;
  if (login_screen_virtual_keyboard_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_virtual_keyboard_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_virtual_keyboard_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_virtual_keyboard_enabled_options_;
  _impl_.login_screen_virtual_keyboard_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_virtual_keyboard_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_virtual_keyboard_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_virtual_keyboard_enabled_options_;
  _impl_.login_screen_virtual_keyboard_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_virtual_keyboard_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.login_screen_virtual_keyboard_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_virtual_keyboard_enabled_options_ = p;
  }
  return _impl_.login_screen_virtual_keyboard_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_virtual_keyboard_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_virtual_keyboard_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_virtual_keyboard_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_virtual_keyboard_enabled_options(::enterprise_management::PolicyOptions* login_screen_virtual_keyboard_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_virtual_keyboard_enabled_options_);
  }
  if (login_screen_virtual_keyboard_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_virtual_keyboard_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_virtual_keyboard_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_virtual_keyboard_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.login_screen_virtual_keyboard_enabled_options_ = login_screen_virtual_keyboard_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_virtual_keyboard_enabled_options)
}

// optional bool login_screen_dictation_enabled = 14;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_dictation_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_dictation_enabled() const {
  return _internal_has_login_screen_dictation_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_dictation_enabled() {
  _impl_.login_screen_dictation_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_dictation_enabled() const {
  return _impl_.login_screen_dictation_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_dictation_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_dictation_enabled)
  return _internal_login_screen_dictation_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_dictation_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.login_screen_dictation_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_dictation_enabled(bool value) {
  _internal_set_login_screen_dictation_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_dictation_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_dictation_enabled_options = 15;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_dictation_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_dictation_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_dictation_enabled_options() const {
  return _internal_has_login_screen_dictation_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_dictation_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_dictation_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_dictation_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_dictation_enabled_options)
  return _internal_login_screen_dictation_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_dictation_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_dictation_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_dictation_enabled_options_);
  }
  _impl_.login_screen_dictation_enabled_options_ = login_screen_dictation_enabled_options;
  if (login_screen_dictation_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_dictation_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_dictation_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_dictation_enabled_options_;
  _impl_.login_screen_dictation_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_dictation_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_dictation_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_dictation_enabled_options_;
  _impl_.login_screen_dictation_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_dictation_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.login_screen_dictation_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_dictation_enabled_options_ = p;
  }
  return _impl_.login_screen_dictation_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_dictation_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_dictation_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_dictation_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_dictation_enabled_options(::enterprise_management::PolicyOptions* login_screen_dictation_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_dictation_enabled_options_);
  }
  if (login_screen_dictation_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_dictation_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_dictation_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_dictation_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.login_screen_dictation_enabled_options_ = login_screen_dictation_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_dictation_enabled_options)
}

// optional bool login_screen_select_to_speak_enabled = 16;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_select_to_speak_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_select_to_speak_enabled() const {
  return _internal_has_login_screen_select_to_speak_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_select_to_speak_enabled() {
  _impl_.login_screen_select_to_speak_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_select_to_speak_enabled() const {
  return _impl_.login_screen_select_to_speak_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_select_to_speak_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_select_to_speak_enabled)
  return _internal_login_screen_select_to_speak_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_select_to_speak_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.login_screen_select_to_speak_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_select_to_speak_enabled(bool value) {
  _internal_set_login_screen_select_to_speak_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_select_to_speak_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_select_to_speak_enabled_options = 17;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_select_to_speak_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_select_to_speak_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_select_to_speak_enabled_options() const {
  return _internal_has_login_screen_select_to_speak_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_select_to_speak_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_select_to_speak_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_select_to_speak_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_select_to_speak_enabled_options)
  return _internal_login_screen_select_to_speak_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_select_to_speak_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_select_to_speak_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_select_to_speak_enabled_options_);
  }
  _impl_.login_screen_select_to_speak_enabled_options_ = login_screen_select_to_speak_enabled_options;
  if (login_screen_select_to_speak_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_select_to_speak_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_select_to_speak_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_select_to_speak_enabled_options_;
  _impl_.login_screen_select_to_speak_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_select_to_speak_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_select_to_speak_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_select_to_speak_enabled_options_;
  _impl_.login_screen_select_to_speak_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_select_to_speak_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.login_screen_select_to_speak_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_select_to_speak_enabled_options_ = p;
  }
  return _impl_.login_screen_select_to_speak_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_select_to_speak_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_select_to_speak_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_select_to_speak_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_select_to_speak_enabled_options(::enterprise_management::PolicyOptions* login_screen_select_to_speak_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_select_to_speak_enabled_options_);
  }
  if (login_screen_select_to_speak_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_select_to_speak_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_select_to_speak_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_select_to_speak_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.login_screen_select_to_speak_enabled_options_ = login_screen_select_to_speak_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_select_to_speak_enabled_options)
}

// optional bool login_screen_cursor_highlight_enabled = 18;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_cursor_highlight_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_cursor_highlight_enabled() const {
  return _internal_has_login_screen_cursor_highlight_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_cursor_highlight_enabled() {
  _impl_.login_screen_cursor_highlight_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_cursor_highlight_enabled() const {
  return _impl_.login_screen_cursor_highlight_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_cursor_highlight_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_cursor_highlight_enabled)
  return _internal_login_screen_cursor_highlight_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_cursor_highlight_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.login_screen_cursor_highlight_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_cursor_highlight_enabled(bool value) {
  _internal_set_login_screen_cursor_highlight_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_cursor_highlight_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_cursor_highlight_enabled_options = 19;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_cursor_highlight_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_cursor_highlight_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_cursor_highlight_enabled_options() const {
  return _internal_has_login_screen_cursor_highlight_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_cursor_highlight_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_cursor_highlight_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_cursor_highlight_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_cursor_highlight_enabled_options)
  return _internal_login_screen_cursor_highlight_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_cursor_highlight_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_cursor_highlight_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_cursor_highlight_enabled_options_);
  }
  _impl_.login_screen_cursor_highlight_enabled_options_ = login_screen_cursor_highlight_enabled_options;
  if (login_screen_cursor_highlight_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_cursor_highlight_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_cursor_highlight_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_cursor_highlight_enabled_options_;
  _impl_.login_screen_cursor_highlight_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_cursor_highlight_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_cursor_highlight_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_cursor_highlight_enabled_options_;
  _impl_.login_screen_cursor_highlight_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_cursor_highlight_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.login_screen_cursor_highlight_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_cursor_highlight_enabled_options_ = p;
  }
  return _impl_.login_screen_cursor_highlight_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_cursor_highlight_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_cursor_highlight_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_cursor_highlight_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_cursor_highlight_enabled_options(::enterprise_management::PolicyOptions* login_screen_cursor_highlight_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_cursor_highlight_enabled_options_);
  }
  if (login_screen_cursor_highlight_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_cursor_highlight_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_cursor_highlight_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_cursor_highlight_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.login_screen_cursor_highlight_enabled_options_ = login_screen_cursor_highlight_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_cursor_highlight_enabled_options)
}

// optional bool login_screen_caret_highlight_enabled = 20;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_caret_highlight_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_caret_highlight_enabled() const {
  return _internal_has_login_screen_caret_highlight_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_caret_highlight_enabled() {
  _impl_.login_screen_caret_highlight_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_caret_highlight_enabled() const {
  return _impl_.login_screen_caret_highlight_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_caret_highlight_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_caret_highlight_enabled)
  return _internal_login_screen_caret_highlight_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_caret_highlight_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.login_screen_caret_highlight_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_caret_highlight_enabled(bool value) {
  _internal_set_login_screen_caret_highlight_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_caret_highlight_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_caret_highlight_enabled_options = 21;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_caret_highlight_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_caret_highlight_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_caret_highlight_enabled_options() const {
  return _internal_has_login_screen_caret_highlight_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_caret_highlight_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_caret_highlight_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_caret_highlight_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_caret_highlight_enabled_options)
  return _internal_login_screen_caret_highlight_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_caret_highlight_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_caret_highlight_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_caret_highlight_enabled_options_);
  }
  _impl_.login_screen_caret_highlight_enabled_options_ = login_screen_caret_highlight_enabled_options;
  if (login_screen_caret_highlight_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_caret_highlight_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_caret_highlight_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_caret_highlight_enabled_options_;
  _impl_.login_screen_caret_highlight_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_caret_highlight_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_caret_highlight_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_caret_highlight_enabled_options_;
  _impl_.login_screen_caret_highlight_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_caret_highlight_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.login_screen_caret_highlight_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_caret_highlight_enabled_options_ = p;
  }
  return _impl_.login_screen_caret_highlight_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_caret_highlight_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_caret_highlight_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_caret_highlight_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_caret_highlight_enabled_options(::enterprise_management::PolicyOptions* login_screen_caret_highlight_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_caret_highlight_enabled_options_);
  }
  if (login_screen_caret_highlight_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_caret_highlight_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_caret_highlight_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_caret_highlight_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.login_screen_caret_highlight_enabled_options_ = login_screen_caret_highlight_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_caret_highlight_enabled_options)
}

// optional bool login_screen_mono_audio_enabled = 22;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_mono_audio_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_mono_audio_enabled() const {
  return _internal_has_login_screen_mono_audio_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_mono_audio_enabled() {
  _impl_.login_screen_mono_audio_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_mono_audio_enabled() const {
  return _impl_.login_screen_mono_audio_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_mono_audio_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_mono_audio_enabled)
  return _internal_login_screen_mono_audio_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_mono_audio_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.login_screen_mono_audio_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_mono_audio_enabled(bool value) {
  _internal_set_login_screen_mono_audio_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_mono_audio_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_mono_audio_enabled_options = 23;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_mono_audio_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_mono_audio_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_mono_audio_enabled_options() const {
  return _internal_has_login_screen_mono_audio_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_mono_audio_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_mono_audio_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_mono_audio_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_mono_audio_enabled_options)
  return _internal_login_screen_mono_audio_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_mono_audio_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_mono_audio_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_mono_audio_enabled_options_);
  }
  _impl_.login_screen_mono_audio_enabled_options_ = login_screen_mono_audio_enabled_options;
  if (login_screen_mono_audio_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_mono_audio_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_mono_audio_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_mono_audio_enabled_options_;
  _impl_.login_screen_mono_audio_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_mono_audio_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_mono_audio_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_mono_audio_enabled_options_;
  _impl_.login_screen_mono_audio_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_mono_audio_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.login_screen_mono_audio_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_mono_audio_enabled_options_ = p;
  }
  return _impl_.login_screen_mono_audio_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_mono_audio_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_mono_audio_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_mono_audio_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_mono_audio_enabled_options(::enterprise_management::PolicyOptions* login_screen_mono_audio_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_mono_audio_enabled_options_);
  }
  if (login_screen_mono_audio_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_mono_audio_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_mono_audio_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_mono_audio_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.login_screen_mono_audio_enabled_options_ = login_screen_mono_audio_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_mono_audio_enabled_options)
}

// optional bool login_screen_autoclick_enabled = 24;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_autoclick_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_autoclick_enabled() const {
  return _internal_has_login_screen_autoclick_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_autoclick_enabled() {
  _impl_.login_screen_autoclick_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_autoclick_enabled() const {
  return _impl_.login_screen_autoclick_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_autoclick_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_autoclick_enabled)
  return _internal_login_screen_autoclick_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_autoclick_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.login_screen_autoclick_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_autoclick_enabled(bool value) {
  _internal_set_login_screen_autoclick_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_autoclick_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_autoclick_enabled_options = 25;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_autoclick_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_autoclick_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_autoclick_enabled_options() const {
  return _internal_has_login_screen_autoclick_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_autoclick_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_autoclick_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_autoclick_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_autoclick_enabled_options)
  return _internal_login_screen_autoclick_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_autoclick_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_autoclick_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_autoclick_enabled_options_);
  }
  _impl_.login_screen_autoclick_enabled_options_ = login_screen_autoclick_enabled_options;
  if (login_screen_autoclick_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_autoclick_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_autoclick_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_autoclick_enabled_options_;
  _impl_.login_screen_autoclick_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_autoclick_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_autoclick_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_autoclick_enabled_options_;
  _impl_.login_screen_autoclick_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_autoclick_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.login_screen_autoclick_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_autoclick_enabled_options_ = p;
  }
  return _impl_.login_screen_autoclick_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_autoclick_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_autoclick_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_autoclick_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_autoclick_enabled_options(::enterprise_management::PolicyOptions* login_screen_autoclick_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_autoclick_enabled_options_);
  }
  if (login_screen_autoclick_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_autoclick_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_autoclick_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_autoclick_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.login_screen_autoclick_enabled_options_ = login_screen_autoclick_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_autoclick_enabled_options)
}

// optional bool login_screen_sticky_keys_enabled = 26;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_sticky_keys_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_sticky_keys_enabled() const {
  return _internal_has_login_screen_sticky_keys_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_sticky_keys_enabled() {
  _impl_.login_screen_sticky_keys_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_sticky_keys_enabled() const {
  return _impl_.login_screen_sticky_keys_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_sticky_keys_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_sticky_keys_enabled)
  return _internal_login_screen_sticky_keys_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_sticky_keys_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.login_screen_sticky_keys_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_sticky_keys_enabled(bool value) {
  _internal_set_login_screen_sticky_keys_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_sticky_keys_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_sticky_keys_enabled_options = 27;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_sticky_keys_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_sticky_keys_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_sticky_keys_enabled_options() const {
  return _internal_has_login_screen_sticky_keys_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_sticky_keys_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_sticky_keys_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_sticky_keys_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_sticky_keys_enabled_options)
  return _internal_login_screen_sticky_keys_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_sticky_keys_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_sticky_keys_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_sticky_keys_enabled_options_);
  }
  _impl_.login_screen_sticky_keys_enabled_options_ = login_screen_sticky_keys_enabled_options;
  if (login_screen_sticky_keys_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_sticky_keys_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_sticky_keys_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_sticky_keys_enabled_options_;
  _impl_.login_screen_sticky_keys_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_sticky_keys_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_sticky_keys_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_sticky_keys_enabled_options_;
  _impl_.login_screen_sticky_keys_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_sticky_keys_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.login_screen_sticky_keys_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_sticky_keys_enabled_options_ = p;
  }
  return _impl_.login_screen_sticky_keys_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_sticky_keys_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_sticky_keys_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_sticky_keys_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_sticky_keys_enabled_options(::enterprise_management::PolicyOptions* login_screen_sticky_keys_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_sticky_keys_enabled_options_);
  }
  if (login_screen_sticky_keys_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_sticky_keys_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_sticky_keys_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_sticky_keys_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.login_screen_sticky_keys_enabled_options_ = login_screen_sticky_keys_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_sticky_keys_enabled_options)
}

// optional bool login_screen_keyboard_focus_highlight_enabled = 28;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_keyboard_focus_highlight_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_keyboard_focus_highlight_enabled() const {
  return _internal_has_login_screen_keyboard_focus_highlight_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_keyboard_focus_highlight_enabled() {
  _impl_.login_screen_keyboard_focus_highlight_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_keyboard_focus_highlight_enabled() const {
  return _impl_.login_screen_keyboard_focus_highlight_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_keyboard_focus_highlight_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_keyboard_focus_highlight_enabled)
  return _internal_login_screen_keyboard_focus_highlight_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_keyboard_focus_highlight_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.login_screen_keyboard_focus_highlight_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_keyboard_focus_highlight_enabled(bool value) {
  _internal_set_login_screen_keyboard_focus_highlight_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_keyboard_focus_highlight_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_keyboard_focus_highlight_enabled_options = 29;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_keyboard_focus_highlight_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_keyboard_focus_highlight_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_keyboard_focus_highlight_enabled_options() const {
  return _internal_has_login_screen_keyboard_focus_highlight_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_keyboard_focus_highlight_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_keyboard_focus_highlight_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_keyboard_focus_highlight_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_keyboard_focus_highlight_enabled_options)
  return _internal_login_screen_keyboard_focus_highlight_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_keyboard_focus_highlight_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_keyboard_focus_highlight_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_keyboard_focus_highlight_enabled_options_);
  }
  _impl_.login_screen_keyboard_focus_highlight_enabled_options_ = login_screen_keyboard_focus_highlight_enabled_options;
  if (login_screen_keyboard_focus_highlight_enabled_options) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_keyboard_focus_highlight_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_keyboard_focus_highlight_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_keyboard_focus_highlight_enabled_options_;
  _impl_.login_screen_keyboard_focus_highlight_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_keyboard_focus_highlight_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_keyboard_focus_highlight_enabled_options)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_keyboard_focus_highlight_enabled_options_;
  _impl_.login_screen_keyboard_focus_highlight_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_keyboard_focus_highlight_enabled_options() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.login_screen_keyboard_focus_highlight_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_keyboard_focus_highlight_enabled_options_ = p;
  }
  return _impl_.login_screen_keyboard_focus_highlight_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_keyboard_focus_highlight_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_keyboard_focus_highlight_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_keyboard_focus_highlight_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_keyboard_focus_highlight_enabled_options(::enterprise_management::PolicyOptions* login_screen_keyboard_focus_highlight_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_keyboard_focus_highlight_enabled_options_);
  }
  if (login_screen_keyboard_focus_highlight_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_keyboard_focus_highlight_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_keyboard_focus_highlight_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_keyboard_focus_highlight_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.login_screen_keyboard_focus_highlight_enabled_options_ = login_screen_keyboard_focus_highlight_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_keyboard_focus_highlight_enabled_options)
}

// optional int64 login_screen_screen_magnifier_type = 30;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_screen_magnifier_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_screen_magnifier_type() const {
  return _internal_has_login_screen_screen_magnifier_type();
}
inline void AccessibilitySettingsProto::clear_login_screen_screen_magnifier_type() {
  _impl_.login_screen_screen_magnifier_type_ = int64_t{0};
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline int64_t AccessibilitySettingsProto::_internal_login_screen_screen_magnifier_type() const {
  return _impl_.login_screen_screen_magnifier_type_;
}
inline int64_t AccessibilitySettingsProto::login_screen_screen_magnifier_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_screen_magnifier_type)
  return _internal_login_screen_screen_magnifier_type();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_screen_magnifier_type(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.login_screen_screen_magnifier_type_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_screen_magnifier_type(int64_t value) {
  _internal_set_login_screen_screen_magnifier_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_screen_magnifier_type)
}

// optional .enterprise_management.PolicyOptions login_screen_screen_magnifier_type_options = 31;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_screen_magnifier_type_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_screen_magnifier_type_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_screen_magnifier_type_options() const {
  return _internal_has_login_screen_screen_magnifier_type_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_screen_magnifier_type_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_screen_magnifier_type_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_screen_magnifier_type_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_screen_magnifier_type_options)
  return _internal_login_screen_screen_magnifier_type_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_screen_magnifier_type_options(
    ::enterprise_management::PolicyOptions* login_screen_screen_magnifier_type_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_screen_magnifier_type_options_);
  }
  _impl_.login_screen_screen_magnifier_type_options_ = login_screen_screen_magnifier_type_options;
  if (login_screen_screen_magnifier_type_options) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_screen_magnifier_type_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_screen_magnifier_type_options() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_screen_magnifier_type_options_;
  _impl_.login_screen_screen_magnifier_type_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_screen_magnifier_type_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_screen_magnifier_type_options)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_screen_magnifier_type_options_;
  _impl_.login_screen_screen_magnifier_type_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_screen_magnifier_type_options() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.login_screen_screen_magnifier_type_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_screen_magnifier_type_options_ = p;
  }
  return _impl_.login_screen_screen_magnifier_type_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_screen_magnifier_type_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_screen_magnifier_type_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_screen_magnifier_type_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_screen_magnifier_type_options(::enterprise_management::PolicyOptions* login_screen_screen_magnifier_type_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_screen_magnifier_type_options_);
  }
  if (login_screen_screen_magnifier_type_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_screen_magnifier_type_options));
    if (message_arena != submessage_arena) {
      login_screen_screen_magnifier_type_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_screen_magnifier_type_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.login_screen_screen_magnifier_type_options_ = login_screen_screen_magnifier_type_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_screen_magnifier_type_options)
}

// optional bool login_screen_show_options_in_system_tray_menu_enabled = 32;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_show_options_in_system_tray_menu_enabled() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_show_options_in_system_tray_menu_enabled() const {
  return _internal_has_login_screen_show_options_in_system_tray_menu_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_show_options_in_system_tray_menu_enabled() {
  _impl_.login_screen_show_options_in_system_tray_menu_enabled_ = false;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_show_options_in_system_tray_menu_enabled() const {
  return _impl_.login_screen_show_options_in_system_tray_menu_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_show_options_in_system_tray_menu_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_show_options_in_system_tray_menu_enabled)
  return _internal_login_screen_show_options_in_system_tray_menu_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_show_options_in_system_tray_menu_enabled(bool value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.login_screen_show_options_in_system_tray_menu_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_show_options_in_system_tray_menu_enabled(bool value) {
  _internal_set_login_screen_show_options_in_system_tray_menu_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_show_options_in_system_tray_menu_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_show_options_in_system_tray_menu_enabled_options = 33;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_show_options_in_system_tray_menu_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_show_options_in_system_tray_menu_enabled_options() const {
  return _internal_has_login_screen_show_options_in_system_tray_menu_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_show_options_in_system_tray_menu_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_show_options_in_system_tray_menu_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_show_options_in_system_tray_menu_enabled_options)
  return _internal_login_screen_show_options_in_system_tray_menu_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_show_options_in_system_tray_menu_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_show_options_in_system_tray_menu_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_);
  }
  _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ = login_screen_show_options_in_system_tray_menu_enabled_options;
  if (login_screen_show_options_in_system_tray_menu_enabled_options) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_show_options_in_system_tray_menu_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_show_options_in_system_tray_menu_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_;
  _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_show_options_in_system_tray_menu_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_show_options_in_system_tray_menu_enabled_options)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_;
  _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_show_options_in_system_tray_menu_enabled_options() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ = p;
  }
  return _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_show_options_in_system_tray_menu_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_show_options_in_system_tray_menu_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_show_options_in_system_tray_menu_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_show_options_in_system_tray_menu_enabled_options(::enterprise_management::PolicyOptions* login_screen_show_options_in_system_tray_menu_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_);
  }
  if (login_screen_show_options_in_system_tray_menu_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_show_options_in_system_tray_menu_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_show_options_in_system_tray_menu_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_show_options_in_system_tray_menu_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ = login_screen_show_options_in_system_tray_menu_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_show_options_in_system_tray_menu_enabled_options)
}

// optional bool login_screen_shortcuts_enabled = 34;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_shortcuts_enabled() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_shortcuts_enabled() const {
  return _internal_has_login_screen_shortcuts_enabled();
}
inline void AccessibilitySettingsProto::clear_login_screen_shortcuts_enabled() {
  _impl_.login_screen_shortcuts_enabled_ = false;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline bool AccessibilitySettingsProto::_internal_login_screen_shortcuts_enabled() const {
  return _impl_.login_screen_shortcuts_enabled_;
}
inline bool AccessibilitySettingsProto::login_screen_shortcuts_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_shortcuts_enabled)
  return _internal_login_screen_shortcuts_enabled();
}
inline void AccessibilitySettingsProto::_internal_set_login_screen_shortcuts_enabled(bool value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.login_screen_shortcuts_enabled_ = value;
}
inline void AccessibilitySettingsProto::set_login_screen_shortcuts_enabled(bool value) {
  _internal_set_login_screen_shortcuts_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AccessibilitySettingsProto.login_screen_shortcuts_enabled)
}

// optional .enterprise_management.PolicyOptions login_screen_shortcuts_enabled_options = 35;
inline bool AccessibilitySettingsProto::_internal_has_login_screen_shortcuts_enabled_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_shortcuts_enabled_options_ != nullptr);
  return value;
}
inline bool AccessibilitySettingsProto::has_login_screen_shortcuts_enabled_options() const {
  return _internal_has_login_screen_shortcuts_enabled_options();
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::_internal_login_screen_shortcuts_enabled_options() const {
  const ::enterprise_management::PolicyOptions* p = _impl_.login_screen_shortcuts_enabled_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyOptions&>(
      ::enterprise_management::_PolicyOptions_default_instance_);
}
inline const ::enterprise_management::PolicyOptions& AccessibilitySettingsProto::login_screen_shortcuts_enabled_options() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AccessibilitySettingsProto.login_screen_shortcuts_enabled_options)
  return _internal_login_screen_shortcuts_enabled_options();
}
inline void AccessibilitySettingsProto::unsafe_arena_set_allocated_login_screen_shortcuts_enabled_options(
    ::enterprise_management::PolicyOptions* login_screen_shortcuts_enabled_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_shortcuts_enabled_options_);
  }
  _impl_.login_screen_shortcuts_enabled_options_ = login_screen_shortcuts_enabled_options;
  if (login_screen_shortcuts_enabled_options) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_shortcuts_enabled_options)
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::release_login_screen_shortcuts_enabled_options() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_shortcuts_enabled_options_;
  _impl_.login_screen_shortcuts_enabled_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::unsafe_arena_release_login_screen_shortcuts_enabled_options() {
  // @@protoc_insertion_point(field_release:enterprise_management.AccessibilitySettingsProto.login_screen_shortcuts_enabled_options)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::PolicyOptions* temp = _impl_.login_screen_shortcuts_enabled_options_;
  _impl_.login_screen_shortcuts_enabled_options_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::_internal_mutable_login_screen_shortcuts_enabled_options() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.login_screen_shortcuts_enabled_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyOptions>(GetArenaForAllocation());
    _impl_.login_screen_shortcuts_enabled_options_ = p;
  }
  return _impl_.login_screen_shortcuts_enabled_options_;
}
inline ::enterprise_management::PolicyOptions* AccessibilitySettingsProto::mutable_login_screen_shortcuts_enabled_options() {
  ::enterprise_management::PolicyOptions* _msg = _internal_mutable_login_screen_shortcuts_enabled_options();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AccessibilitySettingsProto.login_screen_shortcuts_enabled_options)
  return _msg;
}
inline void AccessibilitySettingsProto::set_allocated_login_screen_shortcuts_enabled_options(::enterprise_management::PolicyOptions* login_screen_shortcuts_enabled_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_shortcuts_enabled_options_);
  }
  if (login_screen_shortcuts_enabled_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_shortcuts_enabled_options));
    if (message_arena != submessage_arena) {
      login_screen_shortcuts_enabled_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_shortcuts_enabled_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.login_screen_shortcuts_enabled_options_ = login_screen_shortcuts_enabled_options;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AccessibilitySettingsProto.login_screen_shortcuts_enabled_options)
}

// -------------------------------------------------------------------

// OBSOLETE_SupervisedUsersSettingsProto

// optional bool OBSOLETE_supervised_users_enabled = 1 [deprecated = true];
inline bool OBSOLETE_SupervisedUsersSettingsProto::_internal_has_obsolete_supervised_users_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_SupervisedUsersSettingsProto::has_obsolete_supervised_users_enabled() const {
  return _internal_has_obsolete_supervised_users_enabled();
}
inline void OBSOLETE_SupervisedUsersSettingsProto::clear_obsolete_supervised_users_enabled() {
  _impl_.obsolete_supervised_users_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OBSOLETE_SupervisedUsersSettingsProto::_internal_obsolete_supervised_users_enabled() const {
  return _impl_.obsolete_supervised_users_enabled_;
}
inline bool OBSOLETE_SupervisedUsersSettingsProto::obsolete_supervised_users_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto.OBSOLETE_supervised_users_enabled)
  return _internal_obsolete_supervised_users_enabled();
}
inline void OBSOLETE_SupervisedUsersSettingsProto::_internal_set_obsolete_supervised_users_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_supervised_users_enabled_ = value;
}
inline void OBSOLETE_SupervisedUsersSettingsProto::set_obsolete_supervised_users_enabled(bool value) {
  _internal_set_obsolete_supervised_users_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto.OBSOLETE_supervised_users_enabled)
}

// -------------------------------------------------------------------

// LoginScreenPowerManagementProto

// optional string login_screen_power_management = 1;
inline bool LoginScreenPowerManagementProto::_internal_has_login_screen_power_management() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginScreenPowerManagementProto::has_login_screen_power_management() const {
  return _internal_has_login_screen_power_management();
}
inline void LoginScreenPowerManagementProto::clear_login_screen_power_management() {
  _impl_.login_screen_power_management_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginScreenPowerManagementProto::login_screen_power_management() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LoginScreenPowerManagementProto.login_screen_power_management)
  return _internal_login_screen_power_management();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginScreenPowerManagementProto::set_login_screen_power_management(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.login_screen_power_management_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.LoginScreenPowerManagementProto.login_screen_power_management)
}
inline std::string* LoginScreenPowerManagementProto::mutable_login_screen_power_management() {
  std::string* _s = _internal_mutable_login_screen_power_management();
  // @@protoc_insertion_point(field_mutable:enterprise_management.LoginScreenPowerManagementProto.login_screen_power_management)
  return _s;
}
inline const std::string& LoginScreenPowerManagementProto::_internal_login_screen_power_management() const {
  return _impl_.login_screen_power_management_.Get();
}
inline void LoginScreenPowerManagementProto::_internal_set_login_screen_power_management(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.login_screen_power_management_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginScreenPowerManagementProto::_internal_mutable_login_screen_power_management() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.login_screen_power_management_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginScreenPowerManagementProto::release_login_screen_power_management() {
  // @@protoc_insertion_point(field_release:enterprise_management.LoginScreenPowerManagementProto.login_screen_power_management)
  if (!_internal_has_login_screen_power_management()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.login_screen_power_management_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_screen_power_management_.IsDefault()) {
    _impl_.login_screen_power_management_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginScreenPowerManagementProto::set_allocated_login_screen_power_management(std::string* login_screen_power_management) {
  if (login_screen_power_management != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.login_screen_power_management_.SetAllocated(login_screen_power_management, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_screen_power_management_.IsDefault()) {
    _impl_.login_screen_power_management_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.LoginScreenPowerManagementProto.login_screen_power_management)
}

// -------------------------------------------------------------------

// AutoCleanupSettigsProto

// optional string clean_up_strategy = 1;
inline bool AutoCleanupSettigsProto::_internal_has_clean_up_strategy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutoCleanupSettigsProto::has_clean_up_strategy() const {
  return _internal_has_clean_up_strategy();
}
inline void AutoCleanupSettigsProto::clear_clean_up_strategy() {
  _impl_.clean_up_strategy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutoCleanupSettigsProto::clean_up_strategy() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AutoCleanupSettigsProto.clean_up_strategy)
  return _internal_clean_up_strategy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoCleanupSettigsProto::set_clean_up_strategy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.clean_up_strategy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AutoCleanupSettigsProto.clean_up_strategy)
}
inline std::string* AutoCleanupSettigsProto::mutable_clean_up_strategy() {
  std::string* _s = _internal_mutable_clean_up_strategy();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AutoCleanupSettigsProto.clean_up_strategy)
  return _s;
}
inline const std::string& AutoCleanupSettigsProto::_internal_clean_up_strategy() const {
  return _impl_.clean_up_strategy_.Get();
}
inline void AutoCleanupSettigsProto::_internal_set_clean_up_strategy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.clean_up_strategy_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoCleanupSettigsProto::_internal_mutable_clean_up_strategy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.clean_up_strategy_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoCleanupSettigsProto::release_clean_up_strategy() {
  // @@protoc_insertion_point(field_release:enterprise_management.AutoCleanupSettigsProto.clean_up_strategy)
  if (!_internal_has_clean_up_strategy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.clean_up_strategy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clean_up_strategy_.IsDefault()) {
    _impl_.clean_up_strategy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoCleanupSettigsProto::set_allocated_clean_up_strategy(std::string* clean_up_strategy) {
  if (clean_up_strategy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.clean_up_strategy_.SetAllocated(clean_up_strategy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clean_up_strategy_.IsDefault()) {
    _impl_.clean_up_strategy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AutoCleanupSettigsProto.clean_up_strategy)
}

// -------------------------------------------------------------------

// SystemSettingsProto

// optional bool block_devmode = 1;
inline bool SystemSettingsProto::_internal_has_block_devmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemSettingsProto::has_block_devmode() const {
  return _internal_has_block_devmode();
}
inline void SystemSettingsProto::clear_block_devmode() {
  _impl_.block_devmode_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SystemSettingsProto::_internal_block_devmode() const {
  return _impl_.block_devmode_;
}
inline bool SystemSettingsProto::block_devmode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemSettingsProto.block_devmode)
  return _internal_block_devmode();
}
inline void SystemSettingsProto::_internal_set_block_devmode(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.block_devmode_ = value;
}
inline void SystemSettingsProto::set_block_devmode(bool value) {
  _internal_set_block_devmode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SystemSettingsProto.block_devmode)
}

// -------------------------------------------------------------------

// SAMLSettingsProto

// optional bool transfer_saml_cookies = 1;
inline bool SAMLSettingsProto::_internal_has_transfer_saml_cookies() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SAMLSettingsProto::has_transfer_saml_cookies() const {
  return _internal_has_transfer_saml_cookies();
}
inline void SAMLSettingsProto::clear_transfer_saml_cookies() {
  _impl_.transfer_saml_cookies_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SAMLSettingsProto::_internal_transfer_saml_cookies() const {
  return _impl_.transfer_saml_cookies_;
}
inline bool SAMLSettingsProto::transfer_saml_cookies() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SAMLSettingsProto.transfer_saml_cookies)
  return _internal_transfer_saml_cookies();
}
inline void SAMLSettingsProto::_internal_set_transfer_saml_cookies(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transfer_saml_cookies_ = value;
}
inline void SAMLSettingsProto::set_transfer_saml_cookies(bool value) {
  _internal_set_transfer_saml_cookies(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SAMLSettingsProto.transfer_saml_cookies)
}

// optional string OBSOLETE_url_parameter_to_autofill_saml_username = 2 [deprecated = true];
inline bool SAMLSettingsProto::_internal_has_obsolete_url_parameter_to_autofill_saml_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SAMLSettingsProto::has_obsolete_url_parameter_to_autofill_saml_username() const {
  return _internal_has_obsolete_url_parameter_to_autofill_saml_username();
}
inline void SAMLSettingsProto::clear_obsolete_url_parameter_to_autofill_saml_username() {
  _impl_.obsolete_url_parameter_to_autofill_saml_username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SAMLSettingsProto::obsolete_url_parameter_to_autofill_saml_username() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SAMLSettingsProto.OBSOLETE_url_parameter_to_autofill_saml_username)
  return _internal_obsolete_url_parameter_to_autofill_saml_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SAMLSettingsProto::set_obsolete_url_parameter_to_autofill_saml_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.obsolete_url_parameter_to_autofill_saml_username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SAMLSettingsProto.OBSOLETE_url_parameter_to_autofill_saml_username)
}
inline std::string* SAMLSettingsProto::mutable_obsolete_url_parameter_to_autofill_saml_username() {
  std::string* _s = _internal_mutable_obsolete_url_parameter_to_autofill_saml_username();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SAMLSettingsProto.OBSOLETE_url_parameter_to_autofill_saml_username)
  return _s;
}
inline const std::string& SAMLSettingsProto::_internal_obsolete_url_parameter_to_autofill_saml_username() const {
  return _impl_.obsolete_url_parameter_to_autofill_saml_username_.Get();
}
inline void SAMLSettingsProto::_internal_set_obsolete_url_parameter_to_autofill_saml_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_url_parameter_to_autofill_saml_username_.Set(value, GetArenaForAllocation());
}
inline std::string* SAMLSettingsProto::_internal_mutable_obsolete_url_parameter_to_autofill_saml_username() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.obsolete_url_parameter_to_autofill_saml_username_.Mutable(GetArenaForAllocation());
}
inline std::string* SAMLSettingsProto::release_obsolete_url_parameter_to_autofill_saml_username() {
  // @@protoc_insertion_point(field_release:enterprise_management.SAMLSettingsProto.OBSOLETE_url_parameter_to_autofill_saml_username)
  if (!_internal_has_obsolete_url_parameter_to_autofill_saml_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.obsolete_url_parameter_to_autofill_saml_username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_url_parameter_to_autofill_saml_username_.IsDefault()) {
    _impl_.obsolete_url_parameter_to_autofill_saml_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SAMLSettingsProto::set_allocated_obsolete_url_parameter_to_autofill_saml_username(std::string* obsolete_url_parameter_to_autofill_saml_username) {
  if (obsolete_url_parameter_to_autofill_saml_username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obsolete_url_parameter_to_autofill_saml_username_.SetAllocated(obsolete_url_parameter_to_autofill_saml_username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_url_parameter_to_autofill_saml_username_.IsDefault()) {
    _impl_.obsolete_url_parameter_to_autofill_saml_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SAMLSettingsProto.OBSOLETE_url_parameter_to_autofill_saml_username)
}

// -------------------------------------------------------------------

// SAMLUsernameProto

// optional string url_parameter_to_autofill_saml_username = 1;
inline bool SAMLUsernameProto::_internal_has_url_parameter_to_autofill_saml_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SAMLUsernameProto::has_url_parameter_to_autofill_saml_username() const {
  return _internal_has_url_parameter_to_autofill_saml_username();
}
inline void SAMLUsernameProto::clear_url_parameter_to_autofill_saml_username() {
  _impl_.url_parameter_to_autofill_saml_username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SAMLUsernameProto::url_parameter_to_autofill_saml_username() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SAMLUsernameProto.url_parameter_to_autofill_saml_username)
  return _internal_url_parameter_to_autofill_saml_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SAMLUsernameProto::set_url_parameter_to_autofill_saml_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_parameter_to_autofill_saml_username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SAMLUsernameProto.url_parameter_to_autofill_saml_username)
}
inline std::string* SAMLUsernameProto::mutable_url_parameter_to_autofill_saml_username() {
  std::string* _s = _internal_mutable_url_parameter_to_autofill_saml_username();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SAMLUsernameProto.url_parameter_to_autofill_saml_username)
  return _s;
}
inline const std::string& SAMLUsernameProto::_internal_url_parameter_to_autofill_saml_username() const {
  return _impl_.url_parameter_to_autofill_saml_username_.Get();
}
inline void SAMLUsernameProto::_internal_set_url_parameter_to_autofill_saml_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_parameter_to_autofill_saml_username_.Set(value, GetArenaForAllocation());
}
inline std::string* SAMLUsernameProto::_internal_mutable_url_parameter_to_autofill_saml_username() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_parameter_to_autofill_saml_username_.Mutable(GetArenaForAllocation());
}
inline std::string* SAMLUsernameProto::release_url_parameter_to_autofill_saml_username() {
  // @@protoc_insertion_point(field_release:enterprise_management.SAMLUsernameProto.url_parameter_to_autofill_saml_username)
  if (!_internal_has_url_parameter_to_autofill_saml_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_parameter_to_autofill_saml_username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_parameter_to_autofill_saml_username_.IsDefault()) {
    _impl_.url_parameter_to_autofill_saml_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SAMLUsernameProto::set_allocated_url_parameter_to_autofill_saml_username(std::string* url_parameter_to_autofill_saml_username) {
  if (url_parameter_to_autofill_saml_username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_parameter_to_autofill_saml_username_.SetAllocated(url_parameter_to_autofill_saml_username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_parameter_to_autofill_saml_username_.IsDefault()) {
    _impl_.url_parameter_to_autofill_saml_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SAMLUsernameProto.url_parameter_to_autofill_saml_username)
}

// -------------------------------------------------------------------

// RebootOnShutdownProto

// optional bool reboot_on_shutdown = 1 [default = false];
inline bool RebootOnShutdownProto::_internal_has_reboot_on_shutdown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RebootOnShutdownProto::has_reboot_on_shutdown() const {
  return _internal_has_reboot_on_shutdown();
}
inline void RebootOnShutdownProto::clear_reboot_on_shutdown() {
  _impl_.reboot_on_shutdown_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RebootOnShutdownProto::_internal_reboot_on_shutdown() const {
  return _impl_.reboot_on_shutdown_;
}
inline bool RebootOnShutdownProto::reboot_on_shutdown() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RebootOnShutdownProto.reboot_on_shutdown)
  return _internal_reboot_on_shutdown();
}
inline void RebootOnShutdownProto::_internal_set_reboot_on_shutdown(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reboot_on_shutdown_ = value;
}
inline void RebootOnShutdownProto::set_reboot_on_shutdown(bool value) {
  _internal_set_reboot_on_shutdown(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RebootOnShutdownProto.reboot_on_shutdown)
}

// -------------------------------------------------------------------

// DeviceHeartbeatSettingsProto

// optional bool heartbeat_enabled = 1 [default = false];
inline bool DeviceHeartbeatSettingsProto::_internal_has_heartbeat_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceHeartbeatSettingsProto::has_heartbeat_enabled() const {
  return _internal_has_heartbeat_enabled();
}
inline void DeviceHeartbeatSettingsProto::clear_heartbeat_enabled() {
  _impl_.heartbeat_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceHeartbeatSettingsProto::_internal_heartbeat_enabled() const {
  return _impl_.heartbeat_enabled_;
}
inline bool DeviceHeartbeatSettingsProto::heartbeat_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceHeartbeatSettingsProto.heartbeat_enabled)
  return _internal_heartbeat_enabled();
}
inline void DeviceHeartbeatSettingsProto::_internal_set_heartbeat_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.heartbeat_enabled_ = value;
}
inline void DeviceHeartbeatSettingsProto::set_heartbeat_enabled(bool value) {
  _internal_set_heartbeat_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceHeartbeatSettingsProto.heartbeat_enabled)
}

// optional int64 heartbeat_frequency = 2 [default = 120000];
inline bool DeviceHeartbeatSettingsProto::_internal_has_heartbeat_frequency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceHeartbeatSettingsProto::has_heartbeat_frequency() const {
  return _internal_has_heartbeat_frequency();
}
inline void DeviceHeartbeatSettingsProto::clear_heartbeat_frequency() {
  _impl_.heartbeat_frequency_ = int64_t{120000};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t DeviceHeartbeatSettingsProto::_internal_heartbeat_frequency() const {
  return _impl_.heartbeat_frequency_;
}
inline int64_t DeviceHeartbeatSettingsProto::heartbeat_frequency() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceHeartbeatSettingsProto.heartbeat_frequency)
  return _internal_heartbeat_frequency();
}
inline void DeviceHeartbeatSettingsProto::_internal_set_heartbeat_frequency(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.heartbeat_frequency_ = value;
}
inline void DeviceHeartbeatSettingsProto::set_heartbeat_frequency(int64_t value) {
  _internal_set_heartbeat_frequency(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceHeartbeatSettingsProto.heartbeat_frequency)
}

// -------------------------------------------------------------------

// ExtensionCacheSizeProto

// optional int64 extension_cache_size = 1;
inline bool ExtensionCacheSizeProto::_internal_has_extension_cache_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtensionCacheSizeProto::has_extension_cache_size() const {
  return _internal_has_extension_cache_size();
}
inline void ExtensionCacheSizeProto::clear_extension_cache_size() {
  _impl_.extension_cache_size_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ExtensionCacheSizeProto::_internal_extension_cache_size() const {
  return _impl_.extension_cache_size_;
}
inline int64_t ExtensionCacheSizeProto::extension_cache_size() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionCacheSizeProto.extension_cache_size)
  return _internal_extension_cache_size();
}
inline void ExtensionCacheSizeProto::_internal_set_extension_cache_size(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.extension_cache_size_ = value;
}
inline void ExtensionCacheSizeProto::set_extension_cache_size(int64_t value) {
  _internal_set_extension_cache_size(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionCacheSizeProto.extension_cache_size)
}

// -------------------------------------------------------------------

// LoginScreenDomainAutoCompleteProto

// optional string login_screen_domain_auto_complete = 1;
inline bool LoginScreenDomainAutoCompleteProto::_internal_has_login_screen_domain_auto_complete() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginScreenDomainAutoCompleteProto::has_login_screen_domain_auto_complete() const {
  return _internal_has_login_screen_domain_auto_complete();
}
inline void LoginScreenDomainAutoCompleteProto::clear_login_screen_domain_auto_complete() {
  _impl_.login_screen_domain_auto_complete_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginScreenDomainAutoCompleteProto::login_screen_domain_auto_complete() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LoginScreenDomainAutoCompleteProto.login_screen_domain_auto_complete)
  return _internal_login_screen_domain_auto_complete();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginScreenDomainAutoCompleteProto::set_login_screen_domain_auto_complete(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.login_screen_domain_auto_complete_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.LoginScreenDomainAutoCompleteProto.login_screen_domain_auto_complete)
}
inline std::string* LoginScreenDomainAutoCompleteProto::mutable_login_screen_domain_auto_complete() {
  std::string* _s = _internal_mutable_login_screen_domain_auto_complete();
  // @@protoc_insertion_point(field_mutable:enterprise_management.LoginScreenDomainAutoCompleteProto.login_screen_domain_auto_complete)
  return _s;
}
inline const std::string& LoginScreenDomainAutoCompleteProto::_internal_login_screen_domain_auto_complete() const {
  return _impl_.login_screen_domain_auto_complete_.Get();
}
inline void LoginScreenDomainAutoCompleteProto::_internal_set_login_screen_domain_auto_complete(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.login_screen_domain_auto_complete_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginScreenDomainAutoCompleteProto::_internal_mutable_login_screen_domain_auto_complete() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.login_screen_domain_auto_complete_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginScreenDomainAutoCompleteProto::release_login_screen_domain_auto_complete() {
  // @@protoc_insertion_point(field_release:enterprise_management.LoginScreenDomainAutoCompleteProto.login_screen_domain_auto_complete)
  if (!_internal_has_login_screen_domain_auto_complete()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.login_screen_domain_auto_complete_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_screen_domain_auto_complete_.IsDefault()) {
    _impl_.login_screen_domain_auto_complete_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginScreenDomainAutoCompleteProto::set_allocated_login_screen_domain_auto_complete(std::string* login_screen_domain_auto_complete) {
  if (login_screen_domain_auto_complete != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.login_screen_domain_auto_complete_.SetAllocated(login_screen_domain_auto_complete, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_screen_domain_auto_complete_.IsDefault()) {
    _impl_.login_screen_domain_auto_complete_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.LoginScreenDomainAutoCompleteProto.login_screen_domain_auto_complete)
}

// -------------------------------------------------------------------

// DeviceLogUploadSettingsProto

// optional bool system_log_upload_enabled = 1 [default = false];
inline bool DeviceLogUploadSettingsProto::_internal_has_system_log_upload_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceLogUploadSettingsProto::has_system_log_upload_enabled() const {
  return _internal_has_system_log_upload_enabled();
}
inline void DeviceLogUploadSettingsProto::clear_system_log_upload_enabled() {
  _impl_.system_log_upload_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceLogUploadSettingsProto::_internal_system_log_upload_enabled() const {
  return _impl_.system_log_upload_enabled_;
}
inline bool DeviceLogUploadSettingsProto::system_log_upload_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLogUploadSettingsProto.system_log_upload_enabled)
  return _internal_system_log_upload_enabled();
}
inline void DeviceLogUploadSettingsProto::_internal_set_system_log_upload_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.system_log_upload_enabled_ = value;
}
inline void DeviceLogUploadSettingsProto::set_system_log_upload_enabled(bool value) {
  _internal_set_system_log_upload_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLogUploadSettingsProto.system_log_upload_enabled)
}

// -------------------------------------------------------------------

// DisplayRotationDefaultProto

// optional .enterprise_management.DisplayRotationDefaultProto.Rotation display_rotation_default = 1;
inline bool DisplayRotationDefaultProto::_internal_has_display_rotation_default() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisplayRotationDefaultProto::has_display_rotation_default() const {
  return _internal_has_display_rotation_default();
}
inline void DisplayRotationDefaultProto::clear_display_rotation_default() {
  _impl_.display_rotation_default_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto::_internal_display_rotation_default() const {
  return static_cast< ::enterprise_management::DisplayRotationDefaultProto_Rotation >(_impl_.display_rotation_default_);
}
inline ::enterprise_management::DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto::display_rotation_default() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DisplayRotationDefaultProto.display_rotation_default)
  return _internal_display_rotation_default();
}
inline void DisplayRotationDefaultProto::_internal_set_display_rotation_default(::enterprise_management::DisplayRotationDefaultProto_Rotation value) {
  assert(::enterprise_management::DisplayRotationDefaultProto_Rotation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.display_rotation_default_ = value;
}
inline void DisplayRotationDefaultProto::set_display_rotation_default(::enterprise_management::DisplayRotationDefaultProto_Rotation value) {
  _internal_set_display_rotation_default(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DisplayRotationDefaultProto.display_rotation_default)
}

// -------------------------------------------------------------------

// DeviceLoginScreenPrivacyScreenEnabledProto

// optional bool enabled = 1 [default = false];
inline bool DeviceLoginScreenPrivacyScreenEnabledProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceLoginScreenPrivacyScreenEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceLoginScreenPrivacyScreenEnabledProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceLoginScreenPrivacyScreenEnabledProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceLoginScreenPrivacyScreenEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto.enabled)
  return _internal_enabled();
}
inline void DeviceLoginScreenPrivacyScreenEnabledProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceLoginScreenPrivacyScreenEnabledProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto.enabled)
}

// -------------------------------------------------------------------

// DeviceDisplayResolutionProto

// optional string device_display_resolution = 1;
inline bool DeviceDisplayResolutionProto::_internal_has_device_display_resolution() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceDisplayResolutionProto::has_device_display_resolution() const {
  return _internal_has_device_display_resolution();
}
inline void DeviceDisplayResolutionProto::clear_device_display_resolution() {
  _impl_.device_display_resolution_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceDisplayResolutionProto::device_display_resolution() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceDisplayResolutionProto.device_display_resolution)
  return _internal_device_display_resolution();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceDisplayResolutionProto::set_device_display_resolution(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_display_resolution_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceDisplayResolutionProto.device_display_resolution)
}
inline std::string* DeviceDisplayResolutionProto::mutable_device_display_resolution() {
  std::string* _s = _internal_mutable_device_display_resolution();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceDisplayResolutionProto.device_display_resolution)
  return _s;
}
inline const std::string& DeviceDisplayResolutionProto::_internal_device_display_resolution() const {
  return _impl_.device_display_resolution_.Get();
}
inline void DeviceDisplayResolutionProto::_internal_set_device_display_resolution(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_display_resolution_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceDisplayResolutionProto::_internal_mutable_device_display_resolution() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_display_resolution_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceDisplayResolutionProto::release_device_display_resolution() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceDisplayResolutionProto.device_display_resolution)
  if (!_internal_has_device_display_resolution()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_display_resolution_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_display_resolution_.IsDefault()) {
    _impl_.device_display_resolution_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceDisplayResolutionProto::set_allocated_device_display_resolution(std::string* device_display_resolution) {
  if (device_display_resolution != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_display_resolution_.SetAllocated(device_display_resolution, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_display_resolution_.IsDefault()) {
    _impl_.device_display_resolution_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceDisplayResolutionProto.device_display_resolution)
}

// -------------------------------------------------------------------

// AllowKioskAppControlChromeVersionProto

// optional bool allow_kiosk_app_control_chrome_version = 1 [default = false];
inline bool AllowKioskAppControlChromeVersionProto::_internal_has_allow_kiosk_app_control_chrome_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllowKioskAppControlChromeVersionProto::has_allow_kiosk_app_control_chrome_version() const {
  return _internal_has_allow_kiosk_app_control_chrome_version();
}
inline void AllowKioskAppControlChromeVersionProto::clear_allow_kiosk_app_control_chrome_version() {
  _impl_.allow_kiosk_app_control_chrome_version_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AllowKioskAppControlChromeVersionProto::_internal_allow_kiosk_app_control_chrome_version() const {
  return _impl_.allow_kiosk_app_control_chrome_version_;
}
inline bool AllowKioskAppControlChromeVersionProto::allow_kiosk_app_control_chrome_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AllowKioskAppControlChromeVersionProto.allow_kiosk_app_control_chrome_version)
  return _internal_allow_kiosk_app_control_chrome_version();
}
inline void AllowKioskAppControlChromeVersionProto::_internal_set_allow_kiosk_app_control_chrome_version(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allow_kiosk_app_control_chrome_version_ = value;
}
inline void AllowKioskAppControlChromeVersionProto::set_allow_kiosk_app_control_chrome_version(bool value) {
  _internal_set_allow_kiosk_app_control_chrome_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AllowKioskAppControlChromeVersionProto.allow_kiosk_app_control_chrome_version)
}

// -------------------------------------------------------------------

// LoginAuthenticationBehaviorProto

// optional .enterprise_management.LoginAuthenticationBehaviorProto.LoginBehavior login_authentication_behavior = 1 [default = GAIA];
inline bool LoginAuthenticationBehaviorProto::_internal_has_login_authentication_behavior() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginAuthenticationBehaviorProto::has_login_authentication_behavior() const {
  return _internal_has_login_authentication_behavior();
}
inline void LoginAuthenticationBehaviorProto::clear_login_authentication_behavior() {
  _impl_.login_authentication_behavior_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior LoginAuthenticationBehaviorProto::_internal_login_authentication_behavior() const {
  return static_cast< ::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior >(_impl_.login_authentication_behavior_);
}
inline ::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior LoginAuthenticationBehaviorProto::login_authentication_behavior() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LoginAuthenticationBehaviorProto.login_authentication_behavior)
  return _internal_login_authentication_behavior();
}
inline void LoginAuthenticationBehaviorProto::_internal_set_login_authentication_behavior(::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior value) {
  assert(::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.login_authentication_behavior_ = value;
}
inline void LoginAuthenticationBehaviorProto::set_login_authentication_behavior(::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior value) {
  _internal_set_login_authentication_behavior(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LoginAuthenticationBehaviorProto.login_authentication_behavior)
}

// -------------------------------------------------------------------

// UsbDeviceIdProto

// optional int32 vendor_id = 1;
inline bool UsbDeviceIdProto::_internal_has_vendor_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UsbDeviceIdProto::has_vendor_id() const {
  return _internal_has_vendor_id();
}
inline void UsbDeviceIdProto::clear_vendor_id() {
  _impl_.vendor_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t UsbDeviceIdProto::_internal_vendor_id() const {
  return _impl_.vendor_id_;
}
inline int32_t UsbDeviceIdProto::vendor_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UsbDeviceIdProto.vendor_id)
  return _internal_vendor_id();
}
inline void UsbDeviceIdProto::_internal_set_vendor_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vendor_id_ = value;
}
inline void UsbDeviceIdProto::set_vendor_id(int32_t value) {
  _internal_set_vendor_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UsbDeviceIdProto.vendor_id)
}

// optional int32 product_id = 2;
inline bool UsbDeviceIdProto::_internal_has_product_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UsbDeviceIdProto::has_product_id() const {
  return _internal_has_product_id();
}
inline void UsbDeviceIdProto::clear_product_id() {
  _impl_.product_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t UsbDeviceIdProto::_internal_product_id() const {
  return _impl_.product_id_;
}
inline int32_t UsbDeviceIdProto::product_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UsbDeviceIdProto.product_id)
  return _internal_product_id();
}
inline void UsbDeviceIdProto::_internal_set_product_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.product_id_ = value;
}
inline void UsbDeviceIdProto::set_product_id(int32_t value) {
  _internal_set_product_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UsbDeviceIdProto.product_id)
}

// -------------------------------------------------------------------

// UsbDetachableWhitelistProto

// repeated .enterprise_management.UsbDeviceIdProto id = 1;
inline int UsbDetachableWhitelistProto::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int UsbDetachableWhitelistProto::id_size() const {
  return _internal_id_size();
}
inline void UsbDetachableWhitelistProto::clear_id() {
  _impl_.id_.Clear();
}
inline ::enterprise_management::UsbDeviceIdProto* UsbDetachableWhitelistProto::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.UsbDetachableWhitelistProto.id)
  return _impl_.id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdProto >*
UsbDetachableWhitelistProto::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.UsbDetachableWhitelistProto.id)
  return &_impl_.id_;
}
inline const ::enterprise_management::UsbDeviceIdProto& UsbDetachableWhitelistProto::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline const ::enterprise_management::UsbDeviceIdProto& UsbDetachableWhitelistProto::id(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.UsbDetachableWhitelistProto.id)
  return _internal_id(index);
}
inline ::enterprise_management::UsbDeviceIdProto* UsbDetachableWhitelistProto::_internal_add_id() {
  return _impl_.id_.Add();
}
inline ::enterprise_management::UsbDeviceIdProto* UsbDetachableWhitelistProto::add_id() {
  ::enterprise_management::UsbDeviceIdProto* _add = _internal_add_id();
  // @@protoc_insertion_point(field_add:enterprise_management.UsbDetachableWhitelistProto.id)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdProto >&
UsbDetachableWhitelistProto::id() const {
  // @@protoc_insertion_point(field_list:enterprise_management.UsbDetachableWhitelistProto.id)
  return _impl_.id_;
}

// -------------------------------------------------------------------

// UsbDeviceIdInclusiveProto

// optional int32 vendor_id = 1;
inline bool UsbDeviceIdInclusiveProto::_internal_has_vendor_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UsbDeviceIdInclusiveProto::has_vendor_id() const {
  return _internal_has_vendor_id();
}
inline void UsbDeviceIdInclusiveProto::clear_vendor_id() {
  _impl_.vendor_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t UsbDeviceIdInclusiveProto::_internal_vendor_id() const {
  return _impl_.vendor_id_;
}
inline int32_t UsbDeviceIdInclusiveProto::vendor_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UsbDeviceIdInclusiveProto.vendor_id)
  return _internal_vendor_id();
}
inline void UsbDeviceIdInclusiveProto::_internal_set_vendor_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vendor_id_ = value;
}
inline void UsbDeviceIdInclusiveProto::set_vendor_id(int32_t value) {
  _internal_set_vendor_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UsbDeviceIdInclusiveProto.vendor_id)
}

// optional int32 product_id = 2;
inline bool UsbDeviceIdInclusiveProto::_internal_has_product_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UsbDeviceIdInclusiveProto::has_product_id() const {
  return _internal_has_product_id();
}
inline void UsbDeviceIdInclusiveProto::clear_product_id() {
  _impl_.product_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t UsbDeviceIdInclusiveProto::_internal_product_id() const {
  return _impl_.product_id_;
}
inline int32_t UsbDeviceIdInclusiveProto::product_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UsbDeviceIdInclusiveProto.product_id)
  return _internal_product_id();
}
inline void UsbDeviceIdInclusiveProto::_internal_set_product_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.product_id_ = value;
}
inline void UsbDeviceIdInclusiveProto::set_product_id(int32_t value) {
  _internal_set_product_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UsbDeviceIdInclusiveProto.product_id)
}

// -------------------------------------------------------------------

// UsbDetachableAllowlistProto

// repeated .enterprise_management.UsbDeviceIdInclusiveProto id = 1;
inline int UsbDetachableAllowlistProto::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int UsbDetachableAllowlistProto::id_size() const {
  return _internal_id_size();
}
inline void UsbDetachableAllowlistProto::clear_id() {
  _impl_.id_.Clear();
}
inline ::enterprise_management::UsbDeviceIdInclusiveProto* UsbDetachableAllowlistProto::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.UsbDetachableAllowlistProto.id)
  return _impl_.id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdInclusiveProto >*
UsbDetachableAllowlistProto::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.UsbDetachableAllowlistProto.id)
  return &_impl_.id_;
}
inline const ::enterprise_management::UsbDeviceIdInclusiveProto& UsbDetachableAllowlistProto::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline const ::enterprise_management::UsbDeviceIdInclusiveProto& UsbDetachableAllowlistProto::id(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.UsbDetachableAllowlistProto.id)
  return _internal_id(index);
}
inline ::enterprise_management::UsbDeviceIdInclusiveProto* UsbDetachableAllowlistProto::_internal_add_id() {
  return _impl_.id_.Add();
}
inline ::enterprise_management::UsbDeviceIdInclusiveProto* UsbDetachableAllowlistProto::add_id() {
  ::enterprise_management::UsbDeviceIdInclusiveProto* _add = _internal_add_id();
  // @@protoc_insertion_point(field_add:enterprise_management.UsbDetachableAllowlistProto.id)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::UsbDeviceIdInclusiveProto >&
UsbDetachableAllowlistProto::id() const {
  // @@protoc_insertion_point(field_list:enterprise_management.UsbDetachableAllowlistProto.id)
  return _impl_.id_;
}

// -------------------------------------------------------------------

// AllowBluetoothProto

// optional bool allow_bluetooth = 1 [default = true];
inline bool AllowBluetoothProto::_internal_has_allow_bluetooth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllowBluetoothProto::has_allow_bluetooth() const {
  return _internal_has_allow_bluetooth();
}
inline void AllowBluetoothProto::clear_allow_bluetooth() {
  _impl_.allow_bluetooth_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AllowBluetoothProto::_internal_allow_bluetooth() const {
  return _impl_.allow_bluetooth_;
}
inline bool AllowBluetoothProto::allow_bluetooth() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AllowBluetoothProto.allow_bluetooth)
  return _internal_allow_bluetooth();
}
inline void AllowBluetoothProto::_internal_set_allow_bluetooth(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allow_bluetooth_ = value;
}
inline void AllowBluetoothProto::set_allow_bluetooth(bool value) {
  _internal_set_allow_bluetooth(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AllowBluetoothProto.allow_bluetooth)
}

// -------------------------------------------------------------------

// DeviceWiFiAllowedProto

// optional bool device_wifi_allowed = 1 [default = true];
inline bool DeviceWiFiAllowedProto::_internal_has_device_wifi_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceWiFiAllowedProto::has_device_wifi_allowed() const {
  return _internal_has_device_wifi_allowed();
}
inline void DeviceWiFiAllowedProto::clear_device_wifi_allowed() {
  _impl_.device_wifi_allowed_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceWiFiAllowedProto::_internal_device_wifi_allowed() const {
  return _impl_.device_wifi_allowed_;
}
inline bool DeviceWiFiAllowedProto::device_wifi_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceWiFiAllowedProto.device_wifi_allowed)
  return _internal_device_wifi_allowed();
}
inline void DeviceWiFiAllowedProto::_internal_set_device_wifi_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_wifi_allowed_ = value;
}
inline void DeviceWiFiAllowedProto::set_device_wifi_allowed(bool value) {
  _internal_set_device_wifi_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceWiFiAllowedProto.device_wifi_allowed)
}

// -------------------------------------------------------------------

// DeviceQuirksDownloadEnabledProto

// optional bool quirks_download_enabled = 1;
inline bool DeviceQuirksDownloadEnabledProto::_internal_has_quirks_download_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceQuirksDownloadEnabledProto::has_quirks_download_enabled() const {
  return _internal_has_quirks_download_enabled();
}
inline void DeviceQuirksDownloadEnabledProto::clear_quirks_download_enabled() {
  _impl_.quirks_download_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceQuirksDownloadEnabledProto::_internal_quirks_download_enabled() const {
  return _impl_.quirks_download_enabled_;
}
inline bool DeviceQuirksDownloadEnabledProto::quirks_download_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceQuirksDownloadEnabledProto.quirks_download_enabled)
  return _internal_quirks_download_enabled();
}
inline void DeviceQuirksDownloadEnabledProto::_internal_set_quirks_download_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.quirks_download_enabled_ = value;
}
inline void DeviceQuirksDownloadEnabledProto::set_quirks_download_enabled(bool value) {
  _internal_set_quirks_download_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceQuirksDownloadEnabledProto.quirks_download_enabled)
}

// -------------------------------------------------------------------

// LoginVideoCaptureAllowedUrlsProto

// repeated string urls = 1;
inline int LoginVideoCaptureAllowedUrlsProto::_internal_urls_size() const {
  return _impl_.urls_.size();
}
inline int LoginVideoCaptureAllowedUrlsProto::urls_size() const {
  return _internal_urls_size();
}
inline void LoginVideoCaptureAllowedUrlsProto::clear_urls() {
  _impl_.urls_.Clear();
}
inline std::string* LoginVideoCaptureAllowedUrlsProto::add_urls() {
  std::string* _s = _internal_add_urls();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
  return _s;
}
inline const std::string& LoginVideoCaptureAllowedUrlsProto::_internal_urls(int index) const {
  return _impl_.urls_.Get(index);
}
inline const std::string& LoginVideoCaptureAllowedUrlsProto::urls(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
  return _internal_urls(index);
}
inline std::string* LoginVideoCaptureAllowedUrlsProto::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
  return _impl_.urls_.Mutable(index);
}
inline void LoginVideoCaptureAllowedUrlsProto::set_urls(int index, const std::string& value) {
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
}
inline void LoginVideoCaptureAllowedUrlsProto::set_urls(int index, std::string&& value) {
  _impl_.urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
}
inline void LoginVideoCaptureAllowedUrlsProto::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
}
inline void LoginVideoCaptureAllowedUrlsProto::set_urls(int index, const char* value, size_t size) {
  _impl_.urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
}
inline std::string* LoginVideoCaptureAllowedUrlsProto::_internal_add_urls() {
  return _impl_.urls_.Add();
}
inline void LoginVideoCaptureAllowedUrlsProto::add_urls(const std::string& value) {
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
}
inline void LoginVideoCaptureAllowedUrlsProto::add_urls(std::string&& value) {
  _impl_.urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
}
inline void LoginVideoCaptureAllowedUrlsProto::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
}
inline void LoginVideoCaptureAllowedUrlsProto::add_urls(const char* value, size_t size) {
  _impl_.urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LoginVideoCaptureAllowedUrlsProto::urls() const {
  // @@protoc_insertion_point(field_list:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
  return _impl_.urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LoginVideoCaptureAllowedUrlsProto::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.LoginVideoCaptureAllowedUrlsProto.urls)
  return &_impl_.urls_;
}

// -------------------------------------------------------------------

// DeviceWiFiFastTransitionEnabledProto

// optional bool device_wifi_fast_transition_enabled = 1;
inline bool DeviceWiFiFastTransitionEnabledProto::_internal_has_device_wifi_fast_transition_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceWiFiFastTransitionEnabledProto::has_device_wifi_fast_transition_enabled() const {
  return _internal_has_device_wifi_fast_transition_enabled();
}
inline void DeviceWiFiFastTransitionEnabledProto::clear_device_wifi_fast_transition_enabled() {
  _impl_.device_wifi_fast_transition_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceWiFiFastTransitionEnabledProto::_internal_device_wifi_fast_transition_enabled() const {
  return _impl_.device_wifi_fast_transition_enabled_;
}
inline bool DeviceWiFiFastTransitionEnabledProto::device_wifi_fast_transition_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceWiFiFastTransitionEnabledProto.device_wifi_fast_transition_enabled)
  return _internal_device_wifi_fast_transition_enabled();
}
inline void DeviceWiFiFastTransitionEnabledProto::_internal_set_device_wifi_fast_transition_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_wifi_fast_transition_enabled_ = value;
}
inline void DeviceWiFiFastTransitionEnabledProto::set_device_wifi_fast_transition_enabled(bool value) {
  _internal_set_device_wifi_fast_transition_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceWiFiFastTransitionEnabledProto.device_wifi_fast_transition_enabled)
}

// -------------------------------------------------------------------

// NetworkThrottlingEnabledProto

// optional bool enabled = 1 [default = false];
inline bool NetworkThrottlingEnabledProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetworkThrottlingEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void NetworkThrottlingEnabledProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool NetworkThrottlingEnabledProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool NetworkThrottlingEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkThrottlingEnabledProto.enabled)
  return _internal_enabled();
}
inline void NetworkThrottlingEnabledProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void NetworkThrottlingEnabledProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkThrottlingEnabledProto.enabled)
}

// optional int32 upload_rate_kbits = 2 [default = 0];
inline bool NetworkThrottlingEnabledProto::_internal_has_upload_rate_kbits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NetworkThrottlingEnabledProto::has_upload_rate_kbits() const {
  return _internal_has_upload_rate_kbits();
}
inline void NetworkThrottlingEnabledProto::clear_upload_rate_kbits() {
  _impl_.upload_rate_kbits_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t NetworkThrottlingEnabledProto::_internal_upload_rate_kbits() const {
  return _impl_.upload_rate_kbits_;
}
inline int32_t NetworkThrottlingEnabledProto::upload_rate_kbits() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkThrottlingEnabledProto.upload_rate_kbits)
  return _internal_upload_rate_kbits();
}
inline void NetworkThrottlingEnabledProto::_internal_set_upload_rate_kbits(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.upload_rate_kbits_ = value;
}
inline void NetworkThrottlingEnabledProto::set_upload_rate_kbits(int32_t value) {
  _internal_set_upload_rate_kbits(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkThrottlingEnabledProto.upload_rate_kbits)
}

// optional int32 download_rate_kbits = 3 [default = 0];
inline bool NetworkThrottlingEnabledProto::_internal_has_download_rate_kbits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NetworkThrottlingEnabledProto::has_download_rate_kbits() const {
  return _internal_has_download_rate_kbits();
}
inline void NetworkThrottlingEnabledProto::clear_download_rate_kbits() {
  _impl_.download_rate_kbits_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t NetworkThrottlingEnabledProto::_internal_download_rate_kbits() const {
  return _impl_.download_rate_kbits_;
}
inline int32_t NetworkThrottlingEnabledProto::download_rate_kbits() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkThrottlingEnabledProto.download_rate_kbits)
  return _internal_download_rate_kbits();
}
inline void NetworkThrottlingEnabledProto::_internal_set_download_rate_kbits(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.download_rate_kbits_ = value;
}
inline void NetworkThrottlingEnabledProto::set_download_rate_kbits(int32_t value) {
  _internal_set_download_rate_kbits(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkThrottlingEnabledProto.download_rate_kbits)
}

// -------------------------------------------------------------------

// DeviceLoginScreenExtensionsProto

// repeated string device_login_screen_extensions = 1;
inline int DeviceLoginScreenExtensionsProto::_internal_device_login_screen_extensions_size() const {
  return _impl_.device_login_screen_extensions_.size();
}
inline int DeviceLoginScreenExtensionsProto::device_login_screen_extensions_size() const {
  return _internal_device_login_screen_extensions_size();
}
inline void DeviceLoginScreenExtensionsProto::clear_device_login_screen_extensions() {
  _impl_.device_login_screen_extensions_.Clear();
}
inline std::string* DeviceLoginScreenExtensionsProto::add_device_login_screen_extensions() {
  std::string* _s = _internal_add_device_login_screen_extensions();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
  return _s;
}
inline const std::string& DeviceLoginScreenExtensionsProto::_internal_device_login_screen_extensions(int index) const {
  return _impl_.device_login_screen_extensions_.Get(index);
}
inline const std::string& DeviceLoginScreenExtensionsProto::device_login_screen_extensions(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
  return _internal_device_login_screen_extensions(index);
}
inline std::string* DeviceLoginScreenExtensionsProto::mutable_device_login_screen_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
  return _impl_.device_login_screen_extensions_.Mutable(index);
}
inline void DeviceLoginScreenExtensionsProto::set_device_login_screen_extensions(int index, const std::string& value) {
  _impl_.device_login_screen_extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
}
inline void DeviceLoginScreenExtensionsProto::set_device_login_screen_extensions(int index, std::string&& value) {
  _impl_.device_login_screen_extensions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
}
inline void DeviceLoginScreenExtensionsProto::set_device_login_screen_extensions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.device_login_screen_extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
}
inline void DeviceLoginScreenExtensionsProto::set_device_login_screen_extensions(int index, const char* value, size_t size) {
  _impl_.device_login_screen_extensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
}
inline std::string* DeviceLoginScreenExtensionsProto::_internal_add_device_login_screen_extensions() {
  return _impl_.device_login_screen_extensions_.Add();
}
inline void DeviceLoginScreenExtensionsProto::add_device_login_screen_extensions(const std::string& value) {
  _impl_.device_login_screen_extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
}
inline void DeviceLoginScreenExtensionsProto::add_device_login_screen_extensions(std::string&& value) {
  _impl_.device_login_screen_extensions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
}
inline void DeviceLoginScreenExtensionsProto::add_device_login_screen_extensions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.device_login_screen_extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
}
inline void DeviceLoginScreenExtensionsProto::add_device_login_screen_extensions(const char* value, size_t size) {
  _impl_.device_login_screen_extensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceLoginScreenExtensionsProto::device_login_screen_extensions() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
  return _impl_.device_login_screen_extensions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceLoginScreenExtensionsProto::mutable_device_login_screen_extensions() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceLoginScreenExtensionsProto.device_login_screen_extensions)
  return &_impl_.device_login_screen_extensions_;
}

// -------------------------------------------------------------------

// LoginScreenExtensionManifestV2AvailabilityProto

// optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto.Availability login_screen_extension_manifest_v2_availability = 1;
inline bool LoginScreenExtensionManifestV2AvailabilityProto::_internal_has_login_screen_extension_manifest_v2_availability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginScreenExtensionManifestV2AvailabilityProto::has_login_screen_extension_manifest_v2_availability() const {
  return _internal_has_login_screen_extension_manifest_v2_availability();
}
inline void LoginScreenExtensionManifestV2AvailabilityProto::clear_login_screen_extension_manifest_v2_availability() {
  _impl_.login_screen_extension_manifest_v2_availability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto::_internal_login_screen_extension_manifest_v2_availability() const {
  return static_cast< ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability >(_impl_.login_screen_extension_manifest_v2_availability_);
}
inline ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto::login_screen_extension_manifest_v2_availability() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto.login_screen_extension_manifest_v2_availability)
  return _internal_login_screen_extension_manifest_v2_availability();
}
inline void LoginScreenExtensionManifestV2AvailabilityProto::_internal_set_login_screen_extension_manifest_v2_availability(::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability value) {
  assert(::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.login_screen_extension_manifest_v2_availability_ = value;
}
inline void LoginScreenExtensionManifestV2AvailabilityProto::set_login_screen_extension_manifest_v2_availability(::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability value) {
  _internal_set_login_screen_extension_manifest_v2_availability(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto.login_screen_extension_manifest_v2_availability)
}

// -------------------------------------------------------------------

// LoginScreenLocalesProto

// repeated string login_screen_locales = 1;
inline int LoginScreenLocalesProto::_internal_login_screen_locales_size() const {
  return _impl_.login_screen_locales_.size();
}
inline int LoginScreenLocalesProto::login_screen_locales_size() const {
  return _internal_login_screen_locales_size();
}
inline void LoginScreenLocalesProto::clear_login_screen_locales() {
  _impl_.login_screen_locales_.Clear();
}
inline std::string* LoginScreenLocalesProto::add_login_screen_locales() {
  std::string* _s = _internal_add_login_screen_locales();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
  return _s;
}
inline const std::string& LoginScreenLocalesProto::_internal_login_screen_locales(int index) const {
  return _impl_.login_screen_locales_.Get(index);
}
inline const std::string& LoginScreenLocalesProto::login_screen_locales(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
  return _internal_login_screen_locales(index);
}
inline std::string* LoginScreenLocalesProto::mutable_login_screen_locales(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
  return _impl_.login_screen_locales_.Mutable(index);
}
inline void LoginScreenLocalesProto::set_login_screen_locales(int index, const std::string& value) {
  _impl_.login_screen_locales_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
}
inline void LoginScreenLocalesProto::set_login_screen_locales(int index, std::string&& value) {
  _impl_.login_screen_locales_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
}
inline void LoginScreenLocalesProto::set_login_screen_locales(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.login_screen_locales_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
}
inline void LoginScreenLocalesProto::set_login_screen_locales(int index, const char* value, size_t size) {
  _impl_.login_screen_locales_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
}
inline std::string* LoginScreenLocalesProto::_internal_add_login_screen_locales() {
  return _impl_.login_screen_locales_.Add();
}
inline void LoginScreenLocalesProto::add_login_screen_locales(const std::string& value) {
  _impl_.login_screen_locales_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
}
inline void LoginScreenLocalesProto::add_login_screen_locales(std::string&& value) {
  _impl_.login_screen_locales_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
}
inline void LoginScreenLocalesProto::add_login_screen_locales(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.login_screen_locales_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
}
inline void LoginScreenLocalesProto::add_login_screen_locales(const char* value, size_t size) {
  _impl_.login_screen_locales_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LoginScreenLocalesProto::login_screen_locales() const {
  // @@protoc_insertion_point(field_list:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
  return _impl_.login_screen_locales_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LoginScreenLocalesProto::mutable_login_screen_locales() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.LoginScreenLocalesProto.login_screen_locales)
  return &_impl_.login_screen_locales_;
}

// -------------------------------------------------------------------

// LoginScreenInputMethodsProto

// repeated string login_screen_input_methods = 1;
inline int LoginScreenInputMethodsProto::_internal_login_screen_input_methods_size() const {
  return _impl_.login_screen_input_methods_.size();
}
inline int LoginScreenInputMethodsProto::login_screen_input_methods_size() const {
  return _internal_login_screen_input_methods_size();
}
inline void LoginScreenInputMethodsProto::clear_login_screen_input_methods() {
  _impl_.login_screen_input_methods_.Clear();
}
inline std::string* LoginScreenInputMethodsProto::add_login_screen_input_methods() {
  std::string* _s = _internal_add_login_screen_input_methods();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
  return _s;
}
inline const std::string& LoginScreenInputMethodsProto::_internal_login_screen_input_methods(int index) const {
  return _impl_.login_screen_input_methods_.Get(index);
}
inline const std::string& LoginScreenInputMethodsProto::login_screen_input_methods(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
  return _internal_login_screen_input_methods(index);
}
inline std::string* LoginScreenInputMethodsProto::mutable_login_screen_input_methods(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
  return _impl_.login_screen_input_methods_.Mutable(index);
}
inline void LoginScreenInputMethodsProto::set_login_screen_input_methods(int index, const std::string& value) {
  _impl_.login_screen_input_methods_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
}
inline void LoginScreenInputMethodsProto::set_login_screen_input_methods(int index, std::string&& value) {
  _impl_.login_screen_input_methods_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
}
inline void LoginScreenInputMethodsProto::set_login_screen_input_methods(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.login_screen_input_methods_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
}
inline void LoginScreenInputMethodsProto::set_login_screen_input_methods(int index, const char* value, size_t size) {
  _impl_.login_screen_input_methods_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
}
inline std::string* LoginScreenInputMethodsProto::_internal_add_login_screen_input_methods() {
  return _impl_.login_screen_input_methods_.Add();
}
inline void LoginScreenInputMethodsProto::add_login_screen_input_methods(const std::string& value) {
  _impl_.login_screen_input_methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
}
inline void LoginScreenInputMethodsProto::add_login_screen_input_methods(std::string&& value) {
  _impl_.login_screen_input_methods_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
}
inline void LoginScreenInputMethodsProto::add_login_screen_input_methods(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.login_screen_input_methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
}
inline void LoginScreenInputMethodsProto::add_login_screen_input_methods(const char* value, size_t size) {
  _impl_.login_screen_input_methods_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LoginScreenInputMethodsProto::login_screen_input_methods() const {
  // @@protoc_insertion_point(field_list:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
  return _impl_.login_screen_input_methods_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LoginScreenInputMethodsProto::mutable_login_screen_input_methods() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.LoginScreenInputMethodsProto.login_screen_input_methods)
  return &_impl_.login_screen_input_methods_;
}

// -------------------------------------------------------------------

// DeviceWallpaperImageProto

// optional string device_wallpaper_image = 1;
inline bool DeviceWallpaperImageProto::_internal_has_device_wallpaper_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceWallpaperImageProto::has_device_wallpaper_image() const {
  return _internal_has_device_wallpaper_image();
}
inline void DeviceWallpaperImageProto::clear_device_wallpaper_image() {
  _impl_.device_wallpaper_image_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceWallpaperImageProto::device_wallpaper_image() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceWallpaperImageProto.device_wallpaper_image)
  return _internal_device_wallpaper_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceWallpaperImageProto::set_device_wallpaper_image(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_wallpaper_image_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceWallpaperImageProto.device_wallpaper_image)
}
inline std::string* DeviceWallpaperImageProto::mutable_device_wallpaper_image() {
  std::string* _s = _internal_mutable_device_wallpaper_image();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceWallpaperImageProto.device_wallpaper_image)
  return _s;
}
inline const std::string& DeviceWallpaperImageProto::_internal_device_wallpaper_image() const {
  return _impl_.device_wallpaper_image_.Get();
}
inline void DeviceWallpaperImageProto::_internal_set_device_wallpaper_image(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_wallpaper_image_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceWallpaperImageProto::_internal_mutable_device_wallpaper_image() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_wallpaper_image_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceWallpaperImageProto::release_device_wallpaper_image() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceWallpaperImageProto.device_wallpaper_image)
  if (!_internal_has_device_wallpaper_image()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_wallpaper_image_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_wallpaper_image_.IsDefault()) {
    _impl_.device_wallpaper_image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceWallpaperImageProto::set_allocated_device_wallpaper_image(std::string* device_wallpaper_image) {
  if (device_wallpaper_image != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_wallpaper_image_.SetAllocated(device_wallpaper_image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_wallpaper_image_.IsDefault()) {
    _impl_.device_wallpaper_image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceWallpaperImageProto.device_wallpaper_image)
}

// -------------------------------------------------------------------

// DeviceScreensaverIdleTimeoutSecondsProto

// optional int64 device_screensaver_idle_timeout_seconds = 1;
inline bool DeviceScreensaverIdleTimeoutSecondsProto::_internal_has_device_screensaver_idle_timeout_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceScreensaverIdleTimeoutSecondsProto::has_device_screensaver_idle_timeout_seconds() const {
  return _internal_has_device_screensaver_idle_timeout_seconds();
}
inline void DeviceScreensaverIdleTimeoutSecondsProto::clear_device_screensaver_idle_timeout_seconds() {
  _impl_.device_screensaver_idle_timeout_seconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t DeviceScreensaverIdleTimeoutSecondsProto::_internal_device_screensaver_idle_timeout_seconds() const {
  return _impl_.device_screensaver_idle_timeout_seconds_;
}
inline int64_t DeviceScreensaverIdleTimeoutSecondsProto::device_screensaver_idle_timeout_seconds() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto.device_screensaver_idle_timeout_seconds)
  return _internal_device_screensaver_idle_timeout_seconds();
}
inline void DeviceScreensaverIdleTimeoutSecondsProto::_internal_set_device_screensaver_idle_timeout_seconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_screensaver_idle_timeout_seconds_ = value;
}
inline void DeviceScreensaverIdleTimeoutSecondsProto::set_device_screensaver_idle_timeout_seconds(int64_t value) {
  _internal_set_device_screensaver_idle_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto.device_screensaver_idle_timeout_seconds)
}

// -------------------------------------------------------------------

// DeviceScreensaverImageDisplayIntervalSecondsProto

// optional int64 device_screensaver_image_display_interval_seconds = 1;
inline bool DeviceScreensaverImageDisplayIntervalSecondsProto::_internal_has_device_screensaver_image_display_interval_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceScreensaverImageDisplayIntervalSecondsProto::has_device_screensaver_image_display_interval_seconds() const {
  return _internal_has_device_screensaver_image_display_interval_seconds();
}
inline void DeviceScreensaverImageDisplayIntervalSecondsProto::clear_device_screensaver_image_display_interval_seconds() {
  _impl_.device_screensaver_image_display_interval_seconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t DeviceScreensaverImageDisplayIntervalSecondsProto::_internal_device_screensaver_image_display_interval_seconds() const {
  return _impl_.device_screensaver_image_display_interval_seconds_;
}
inline int64_t DeviceScreensaverImageDisplayIntervalSecondsProto::device_screensaver_image_display_interval_seconds() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto.device_screensaver_image_display_interval_seconds)
  return _internal_device_screensaver_image_display_interval_seconds();
}
inline void DeviceScreensaverImageDisplayIntervalSecondsProto::_internal_set_device_screensaver_image_display_interval_seconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_screensaver_image_display_interval_seconds_ = value;
}
inline void DeviceScreensaverImageDisplayIntervalSecondsProto::set_device_screensaver_image_display_interval_seconds(int64_t value) {
  _internal_set_device_screensaver_image_display_interval_seconds(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto.device_screensaver_image_display_interval_seconds)
}

// -------------------------------------------------------------------

// DeviceScreensaverImagesProto

// repeated string device_screensaver_images = 1;
inline int DeviceScreensaverImagesProto::_internal_device_screensaver_images_size() const {
  return _impl_.device_screensaver_images_.size();
}
inline int DeviceScreensaverImagesProto::device_screensaver_images_size() const {
  return _internal_device_screensaver_images_size();
}
inline void DeviceScreensaverImagesProto::clear_device_screensaver_images() {
  _impl_.device_screensaver_images_.Clear();
}
inline std::string* DeviceScreensaverImagesProto::add_device_screensaver_images() {
  std::string* _s = _internal_add_device_screensaver_images();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
  return _s;
}
inline const std::string& DeviceScreensaverImagesProto::_internal_device_screensaver_images(int index) const {
  return _impl_.device_screensaver_images_.Get(index);
}
inline const std::string& DeviceScreensaverImagesProto::device_screensaver_images(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
  return _internal_device_screensaver_images(index);
}
inline std::string* DeviceScreensaverImagesProto::mutable_device_screensaver_images(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
  return _impl_.device_screensaver_images_.Mutable(index);
}
inline void DeviceScreensaverImagesProto::set_device_screensaver_images(int index, const std::string& value) {
  _impl_.device_screensaver_images_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
}
inline void DeviceScreensaverImagesProto::set_device_screensaver_images(int index, std::string&& value) {
  _impl_.device_screensaver_images_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
}
inline void DeviceScreensaverImagesProto::set_device_screensaver_images(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.device_screensaver_images_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
}
inline void DeviceScreensaverImagesProto::set_device_screensaver_images(int index, const char* value, size_t size) {
  _impl_.device_screensaver_images_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
}
inline std::string* DeviceScreensaverImagesProto::_internal_add_device_screensaver_images() {
  return _impl_.device_screensaver_images_.Add();
}
inline void DeviceScreensaverImagesProto::add_device_screensaver_images(const std::string& value) {
  _impl_.device_screensaver_images_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
}
inline void DeviceScreensaverImagesProto::add_device_screensaver_images(std::string&& value) {
  _impl_.device_screensaver_images_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
}
inline void DeviceScreensaverImagesProto::add_device_screensaver_images(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.device_screensaver_images_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
}
inline void DeviceScreensaverImagesProto::add_device_screensaver_images(const char* value, size_t size) {
  _impl_.device_screensaver_images_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceScreensaverImagesProto::device_screensaver_images() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
  return _impl_.device_screensaver_images_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceScreensaverImagesProto::mutable_device_screensaver_images() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceScreensaverImagesProto.device_screensaver_images)
  return &_impl_.device_screensaver_images_;
}

// -------------------------------------------------------------------

// DeviceSystemAecEnabledProto

// optional bool device_system_aec_enabled = 1;
inline bool DeviceSystemAecEnabledProto::_internal_has_device_system_aec_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceSystemAecEnabledProto::has_device_system_aec_enabled() const {
  return _internal_has_device_system_aec_enabled();
}
inline void DeviceSystemAecEnabledProto::clear_device_system_aec_enabled() {
  _impl_.device_system_aec_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceSystemAecEnabledProto::_internal_device_system_aec_enabled() const {
  return _impl_.device_system_aec_enabled_;
}
inline bool DeviceSystemAecEnabledProto::device_system_aec_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceSystemAecEnabledProto.device_system_aec_enabled)
  return _internal_device_system_aec_enabled();
}
inline void DeviceSystemAecEnabledProto::_internal_set_device_system_aec_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_system_aec_enabled_ = value;
}
inline void DeviceSystemAecEnabledProto::set_device_system_aec_enabled(bool value) {
  _internal_set_device_system_aec_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceSystemAecEnabledProto.device_system_aec_enabled)
}

// -------------------------------------------------------------------

// DeviceScreensaverEnabledProto

// optional bool device_screensaver_enabled = 1;
inline bool DeviceScreensaverEnabledProto::_internal_has_device_screensaver_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceScreensaverEnabledProto::has_device_screensaver_enabled() const {
  return _internal_has_device_screensaver_enabled();
}
inline void DeviceScreensaverEnabledProto::clear_device_screensaver_enabled() {
  _impl_.device_screensaver_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceScreensaverEnabledProto::_internal_device_screensaver_enabled() const {
  return _impl_.device_screensaver_enabled_;
}
inline bool DeviceScreensaverEnabledProto::device_screensaver_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceScreensaverEnabledProto.device_screensaver_enabled)
  return _internal_device_screensaver_enabled();
}
inline void DeviceScreensaverEnabledProto::_internal_set_device_screensaver_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_screensaver_enabled_ = value;
}
inline void DeviceScreensaverEnabledProto::set_device_screensaver_enabled(bool value) {
  _internal_set_device_screensaver_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceScreensaverEnabledProto.device_screensaver_enabled)
}

// -------------------------------------------------------------------

// DeviceEcryptfsMigrationStrategyProto

// optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto.MigrationStrategy migration_strategy = 1;
inline bool DeviceEcryptfsMigrationStrategyProto::_internal_has_migration_strategy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceEcryptfsMigrationStrategyProto::has_migration_strategy() const {
  return _internal_has_migration_strategy();
}
inline void DeviceEcryptfsMigrationStrategyProto::clear_migration_strategy() {
  _impl_.migration_strategy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto::_internal_migration_strategy() const {
  return static_cast< ::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy >(_impl_.migration_strategy_);
}
inline ::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto::migration_strategy() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceEcryptfsMigrationStrategyProto.migration_strategy)
  return _internal_migration_strategy();
}
inline void DeviceEcryptfsMigrationStrategyProto::_internal_set_migration_strategy(::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy value) {
  assert(::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.migration_strategy_ = value;
}
inline void DeviceEcryptfsMigrationStrategyProto::set_migration_strategy(::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy value) {
  _internal_set_migration_strategy(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceEcryptfsMigrationStrategyProto.migration_strategy)
}

// -------------------------------------------------------------------

// DeviceSecondFactorAuthenticationProto

// optional .enterprise_management.DeviceSecondFactorAuthenticationProto.U2fMode mode = 1;
inline bool DeviceSecondFactorAuthenticationProto::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceSecondFactorAuthenticationProto::has_mode() const {
  return _internal_has_mode();
}
inline void DeviceSecondFactorAuthenticationProto::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto::_internal_mode() const {
  return static_cast< ::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode >(_impl_.mode_);
}
inline ::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto::mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceSecondFactorAuthenticationProto.mode)
  return _internal_mode();
}
inline void DeviceSecondFactorAuthenticationProto::_internal_set_mode(::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode value) {
  assert(::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mode_ = value;
}
inline void DeviceSecondFactorAuthenticationProto::set_mode(::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceSecondFactorAuthenticationProto.mode)
}

// -------------------------------------------------------------------

// CastReceiverNameProto

// optional string name = 1;
inline bool CastReceiverNameProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CastReceiverNameProto::has_name() const {
  return _internal_has_name();
}
inline void CastReceiverNameProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CastReceiverNameProto::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CastReceiverNameProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastReceiverNameProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CastReceiverNameProto.name)
}
inline std::string* CastReceiverNameProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CastReceiverNameProto.name)
  return _s;
}
inline const std::string& CastReceiverNameProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CastReceiverNameProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CastReceiverNameProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CastReceiverNameProto::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.CastReceiverNameProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastReceiverNameProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CastReceiverNameProto.name)
}

// -------------------------------------------------------------------

// WeeklyTimeProto

// optional .enterprise_management.WeeklyTimeProto.DayOfWeek day_of_week = 1;
inline bool WeeklyTimeProto::_internal_has_day_of_week() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WeeklyTimeProto::has_day_of_week() const {
  return _internal_has_day_of_week();
}
inline void WeeklyTimeProto::clear_day_of_week() {
  _impl_.day_of_week_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::WeeklyTimeProto_DayOfWeek WeeklyTimeProto::_internal_day_of_week() const {
  return static_cast< ::enterprise_management::WeeklyTimeProto_DayOfWeek >(_impl_.day_of_week_);
}
inline ::enterprise_management::WeeklyTimeProto_DayOfWeek WeeklyTimeProto::day_of_week() const {
  // @@protoc_insertion_point(field_get:enterprise_management.WeeklyTimeProto.day_of_week)
  return _internal_day_of_week();
}
inline void WeeklyTimeProto::_internal_set_day_of_week(::enterprise_management::WeeklyTimeProto_DayOfWeek value) {
  assert(::enterprise_management::WeeklyTimeProto_DayOfWeek_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.day_of_week_ = value;
}
inline void WeeklyTimeProto::set_day_of_week(::enterprise_management::WeeklyTimeProto_DayOfWeek value) {
  _internal_set_day_of_week(value);
  // @@protoc_insertion_point(field_set:enterprise_management.WeeklyTimeProto.day_of_week)
}

// optional int32 time = 2;
inline bool WeeklyTimeProto::_internal_has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WeeklyTimeProto::has_time() const {
  return _internal_has_time();
}
inline void WeeklyTimeProto::clear_time() {
  _impl_.time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t WeeklyTimeProto::_internal_time() const {
  return _impl_.time_;
}
inline int32_t WeeklyTimeProto::time() const {
  // @@protoc_insertion_point(field_get:enterprise_management.WeeklyTimeProto.time)
  return _internal_time();
}
inline void WeeklyTimeProto::_internal_set_time(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.time_ = value;
}
inline void WeeklyTimeProto::set_time(int32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:enterprise_management.WeeklyTimeProto.time)
}

// -------------------------------------------------------------------

// WeeklyTimeIntervalProto

// optional .enterprise_management.WeeklyTimeProto start = 1;
inline bool WeeklyTimeIntervalProto::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline bool WeeklyTimeIntervalProto::has_start() const {
  return _internal_has_start();
}
inline void WeeklyTimeIntervalProto::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::WeeklyTimeProto& WeeklyTimeIntervalProto::_internal_start() const {
  const ::enterprise_management::WeeklyTimeProto* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::WeeklyTimeProto&>(
      ::enterprise_management::_WeeklyTimeProto_default_instance_);
}
inline const ::enterprise_management::WeeklyTimeProto& WeeklyTimeIntervalProto::start() const {
  // @@protoc_insertion_point(field_get:enterprise_management.WeeklyTimeIntervalProto.start)
  return _internal_start();
}
inline void WeeklyTimeIntervalProto::unsafe_arena_set_allocated_start(
    ::enterprise_management::WeeklyTimeProto* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.WeeklyTimeIntervalProto.start)
}
inline ::enterprise_management::WeeklyTimeProto* WeeklyTimeIntervalProto::release_start() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::WeeklyTimeProto* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::WeeklyTimeProto* WeeklyTimeIntervalProto::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:enterprise_management.WeeklyTimeIntervalProto.start)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::WeeklyTimeProto* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::enterprise_management::WeeklyTimeProto* WeeklyTimeIntervalProto::_internal_mutable_start() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::WeeklyTimeProto>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::enterprise_management::WeeklyTimeProto* WeeklyTimeIntervalProto::mutable_start() {
  ::enterprise_management::WeeklyTimeProto* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:enterprise_management.WeeklyTimeIntervalProto.start)
  return _msg;
}
inline void WeeklyTimeIntervalProto::set_allocated_start(::enterprise_management::WeeklyTimeProto* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.WeeklyTimeIntervalProto.start)
}

// optional .enterprise_management.WeeklyTimeProto end = 2;
inline bool WeeklyTimeIntervalProto::_internal_has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline bool WeeklyTimeIntervalProto::has_end() const {
  return _internal_has_end();
}
inline void WeeklyTimeIntervalProto::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::WeeklyTimeProto& WeeklyTimeIntervalProto::_internal_end() const {
  const ::enterprise_management::WeeklyTimeProto* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::WeeklyTimeProto&>(
      ::enterprise_management::_WeeklyTimeProto_default_instance_);
}
inline const ::enterprise_management::WeeklyTimeProto& WeeklyTimeIntervalProto::end() const {
  // @@protoc_insertion_point(field_get:enterprise_management.WeeklyTimeIntervalProto.end)
  return _internal_end();
}
inline void WeeklyTimeIntervalProto::unsafe_arena_set_allocated_end(
    ::enterprise_management::WeeklyTimeProto* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  if (end) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.WeeklyTimeIntervalProto.end)
}
inline ::enterprise_management::WeeklyTimeProto* WeeklyTimeIntervalProto::release_end() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::WeeklyTimeProto* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::WeeklyTimeProto* WeeklyTimeIntervalProto::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:enterprise_management.WeeklyTimeIntervalProto.end)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::WeeklyTimeProto* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::enterprise_management::WeeklyTimeProto* WeeklyTimeIntervalProto::_internal_mutable_end() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::WeeklyTimeProto>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::enterprise_management::WeeklyTimeProto* WeeklyTimeIntervalProto::mutable_end() {
  ::enterprise_management::WeeklyTimeProto* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:enterprise_management.WeeklyTimeIntervalProto.end)
  return _msg;
}
inline void WeeklyTimeIntervalProto::set_allocated_end(::enterprise_management::WeeklyTimeProto* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.WeeklyTimeIntervalProto.end)
}

// -------------------------------------------------------------------

// DeviceOffHoursProto

// repeated .enterprise_management.WeeklyTimeIntervalProto intervals = 1;
inline int DeviceOffHoursProto::_internal_intervals_size() const {
  return _impl_.intervals_.size();
}
inline int DeviceOffHoursProto::intervals_size() const {
  return _internal_intervals_size();
}
inline void DeviceOffHoursProto::clear_intervals() {
  _impl_.intervals_.Clear();
}
inline ::enterprise_management::WeeklyTimeIntervalProto* DeviceOffHoursProto::mutable_intervals(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceOffHoursProto.intervals)
  return _impl_.intervals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::WeeklyTimeIntervalProto >*
DeviceOffHoursProto::mutable_intervals() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceOffHoursProto.intervals)
  return &_impl_.intervals_;
}
inline const ::enterprise_management::WeeklyTimeIntervalProto& DeviceOffHoursProto::_internal_intervals(int index) const {
  return _impl_.intervals_.Get(index);
}
inline const ::enterprise_management::WeeklyTimeIntervalProto& DeviceOffHoursProto::intervals(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceOffHoursProto.intervals)
  return _internal_intervals(index);
}
inline ::enterprise_management::WeeklyTimeIntervalProto* DeviceOffHoursProto::_internal_add_intervals() {
  return _impl_.intervals_.Add();
}
inline ::enterprise_management::WeeklyTimeIntervalProto* DeviceOffHoursProto::add_intervals() {
  ::enterprise_management::WeeklyTimeIntervalProto* _add = _internal_add_intervals();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceOffHoursProto.intervals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::WeeklyTimeIntervalProto >&
DeviceOffHoursProto::intervals() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceOffHoursProto.intervals)
  return _impl_.intervals_;
}

// optional string timezone = 2;
inline bool DeviceOffHoursProto::_internal_has_timezone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceOffHoursProto::has_timezone() const {
  return _internal_has_timezone();
}
inline void DeviceOffHoursProto::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceOffHoursProto::timezone() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceOffHoursProto.timezone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceOffHoursProto::set_timezone(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceOffHoursProto.timezone)
}
inline std::string* DeviceOffHoursProto::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceOffHoursProto.timezone)
  return _s;
}
inline const std::string& DeviceOffHoursProto::_internal_timezone() const {
  return _impl_.timezone_.Get();
}
inline void DeviceOffHoursProto::_internal_set_timezone(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceOffHoursProto::_internal_mutable_timezone() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceOffHoursProto::release_timezone() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceOffHoursProto.timezone)
  if (!_internal_has_timezone()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.timezone_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceOffHoursProto::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timezone_.SetAllocated(timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceOffHoursProto.timezone)
}

// repeated int32 ignored_policy_proto_tags = 3;
inline int DeviceOffHoursProto::_internal_ignored_policy_proto_tags_size() const {
  return _impl_.ignored_policy_proto_tags_.size();
}
inline int DeviceOffHoursProto::ignored_policy_proto_tags_size() const {
  return _internal_ignored_policy_proto_tags_size();
}
inline void DeviceOffHoursProto::clear_ignored_policy_proto_tags() {
  _impl_.ignored_policy_proto_tags_.Clear();
}
inline int32_t DeviceOffHoursProto::_internal_ignored_policy_proto_tags(int index) const {
  return _impl_.ignored_policy_proto_tags_.Get(index);
}
inline int32_t DeviceOffHoursProto::ignored_policy_proto_tags(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceOffHoursProto.ignored_policy_proto_tags)
  return _internal_ignored_policy_proto_tags(index);
}
inline void DeviceOffHoursProto::set_ignored_policy_proto_tags(int index, int32_t value) {
  _impl_.ignored_policy_proto_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceOffHoursProto.ignored_policy_proto_tags)
}
inline void DeviceOffHoursProto::_internal_add_ignored_policy_proto_tags(int32_t value) {
  _impl_.ignored_policy_proto_tags_.Add(value);
}
inline void DeviceOffHoursProto::add_ignored_policy_proto_tags(int32_t value) {
  _internal_add_ignored_policy_proto_tags(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceOffHoursProto.ignored_policy_proto_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DeviceOffHoursProto::_internal_ignored_policy_proto_tags() const {
  return _impl_.ignored_policy_proto_tags_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DeviceOffHoursProto::ignored_policy_proto_tags() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceOffHoursProto.ignored_policy_proto_tags)
  return _internal_ignored_policy_proto_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DeviceOffHoursProto::_internal_mutable_ignored_policy_proto_tags() {
  return &_impl_.ignored_policy_proto_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DeviceOffHoursProto::mutable_ignored_policy_proto_tags() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceOffHoursProto.ignored_policy_proto_tags)
  return _internal_mutable_ignored_policy_proto_tags();
}

// -------------------------------------------------------------------

// DeviceNativePrintersProto

// optional string external_policy = 1;
inline bool DeviceNativePrintersProto::_internal_has_external_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceNativePrintersProto::has_external_policy() const {
  return _internal_has_external_policy();
}
inline void DeviceNativePrintersProto::clear_external_policy() {
  _impl_.external_policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceNativePrintersProto::external_policy() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceNativePrintersProto.external_policy)
  return _internal_external_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceNativePrintersProto::set_external_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.external_policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceNativePrintersProto.external_policy)
}
inline std::string* DeviceNativePrintersProto::mutable_external_policy() {
  std::string* _s = _internal_mutable_external_policy();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceNativePrintersProto.external_policy)
  return _s;
}
inline const std::string& DeviceNativePrintersProto::_internal_external_policy() const {
  return _impl_.external_policy_.Get();
}
inline void DeviceNativePrintersProto::_internal_set_external_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.external_policy_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceNativePrintersProto::_internal_mutable_external_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.external_policy_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceNativePrintersProto::release_external_policy() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceNativePrintersProto.external_policy)
  if (!_internal_has_external_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.external_policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_policy_.IsDefault()) {
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceNativePrintersProto::set_allocated_external_policy(std::string* external_policy) {
  if (external_policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.external_policy_.SetAllocated(external_policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_policy_.IsDefault()) {
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceNativePrintersProto.external_policy)
}

// -------------------------------------------------------------------

// DeviceNativePrintersAccessModeProto

// optional .enterprise_management.DeviceNativePrintersAccessModeProto.AccessMode access_mode = 1;
inline bool DeviceNativePrintersAccessModeProto::_internal_has_access_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceNativePrintersAccessModeProto::has_access_mode() const {
  return _internal_has_access_mode();
}
inline void DeviceNativePrintersAccessModeProto::clear_access_mode() {
  _impl_.access_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto::_internal_access_mode() const {
  return static_cast< ::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode >(_impl_.access_mode_);
}
inline ::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto::access_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceNativePrintersAccessModeProto.access_mode)
  return _internal_access_mode();
}
inline void DeviceNativePrintersAccessModeProto::_internal_set_access_mode(::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode value) {
  assert(::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_mode_ = value;
}
inline void DeviceNativePrintersAccessModeProto::set_access_mode(::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode value) {
  _internal_set_access_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceNativePrintersAccessModeProto.access_mode)
}

// -------------------------------------------------------------------

// DeviceNativePrintersBlacklistProto

// repeated string blacklist = 1;
inline int DeviceNativePrintersBlacklistProto::_internal_blacklist_size() const {
  return _impl_.blacklist_.size();
}
inline int DeviceNativePrintersBlacklistProto::blacklist_size() const {
  return _internal_blacklist_size();
}
inline void DeviceNativePrintersBlacklistProto::clear_blacklist() {
  _impl_.blacklist_.Clear();
}
inline std::string* DeviceNativePrintersBlacklistProto::add_blacklist() {
  std::string* _s = _internal_add_blacklist();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
  return _s;
}
inline const std::string& DeviceNativePrintersBlacklistProto::_internal_blacklist(int index) const {
  return _impl_.blacklist_.Get(index);
}
inline const std::string& DeviceNativePrintersBlacklistProto::blacklist(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
  return _internal_blacklist(index);
}
inline std::string* DeviceNativePrintersBlacklistProto::mutable_blacklist(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
  return _impl_.blacklist_.Mutable(index);
}
inline void DeviceNativePrintersBlacklistProto::set_blacklist(int index, const std::string& value) {
  _impl_.blacklist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
}
inline void DeviceNativePrintersBlacklistProto::set_blacklist(int index, std::string&& value) {
  _impl_.blacklist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
}
inline void DeviceNativePrintersBlacklistProto::set_blacklist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.blacklist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
}
inline void DeviceNativePrintersBlacklistProto::set_blacklist(int index, const char* value, size_t size) {
  _impl_.blacklist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
}
inline std::string* DeviceNativePrintersBlacklistProto::_internal_add_blacklist() {
  return _impl_.blacklist_.Add();
}
inline void DeviceNativePrintersBlacklistProto::add_blacklist(const std::string& value) {
  _impl_.blacklist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
}
inline void DeviceNativePrintersBlacklistProto::add_blacklist(std::string&& value) {
  _impl_.blacklist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
}
inline void DeviceNativePrintersBlacklistProto::add_blacklist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.blacklist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
}
inline void DeviceNativePrintersBlacklistProto::add_blacklist(const char* value, size_t size) {
  _impl_.blacklist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceNativePrintersBlacklistProto::blacklist() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
  return _impl_.blacklist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceNativePrintersBlacklistProto::mutable_blacklist() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceNativePrintersBlacklistProto.blacklist)
  return &_impl_.blacklist_;
}

// -------------------------------------------------------------------

// DeviceNativePrintersWhitelistProto

// repeated string whitelist = 1;
inline int DeviceNativePrintersWhitelistProto::_internal_whitelist_size() const {
  return _impl_.whitelist_.size();
}
inline int DeviceNativePrintersWhitelistProto::whitelist_size() const {
  return _internal_whitelist_size();
}
inline void DeviceNativePrintersWhitelistProto::clear_whitelist() {
  _impl_.whitelist_.Clear();
}
inline std::string* DeviceNativePrintersWhitelistProto::add_whitelist() {
  std::string* _s = _internal_add_whitelist();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
  return _s;
}
inline const std::string& DeviceNativePrintersWhitelistProto::_internal_whitelist(int index) const {
  return _impl_.whitelist_.Get(index);
}
inline const std::string& DeviceNativePrintersWhitelistProto::whitelist(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
  return _internal_whitelist(index);
}
inline std::string* DeviceNativePrintersWhitelistProto::mutable_whitelist(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
  return _impl_.whitelist_.Mutable(index);
}
inline void DeviceNativePrintersWhitelistProto::set_whitelist(int index, const std::string& value) {
  _impl_.whitelist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
}
inline void DeviceNativePrintersWhitelistProto::set_whitelist(int index, std::string&& value) {
  _impl_.whitelist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
}
inline void DeviceNativePrintersWhitelistProto::set_whitelist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.whitelist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
}
inline void DeviceNativePrintersWhitelistProto::set_whitelist(int index, const char* value, size_t size) {
  _impl_.whitelist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
}
inline std::string* DeviceNativePrintersWhitelistProto::_internal_add_whitelist() {
  return _impl_.whitelist_.Add();
}
inline void DeviceNativePrintersWhitelistProto::add_whitelist(const std::string& value) {
  _impl_.whitelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
}
inline void DeviceNativePrintersWhitelistProto::add_whitelist(std::string&& value) {
  _impl_.whitelist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
}
inline void DeviceNativePrintersWhitelistProto::add_whitelist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.whitelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
}
inline void DeviceNativePrintersWhitelistProto::add_whitelist(const char* value, size_t size) {
  _impl_.whitelist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceNativePrintersWhitelistProto::whitelist() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
  return _impl_.whitelist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceNativePrintersWhitelistProto::mutable_whitelist() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceNativePrintersWhitelistProto.whitelist)
  return &_impl_.whitelist_;
}

// -------------------------------------------------------------------

// DevicePrintersProto

// optional string external_policy = 1;
inline bool DevicePrintersProto::_internal_has_external_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePrintersProto::has_external_policy() const {
  return _internal_has_external_policy();
}
inline void DevicePrintersProto::clear_external_policy() {
  _impl_.external_policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DevicePrintersProto::external_policy() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePrintersProto.external_policy)
  return _internal_external_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicePrintersProto::set_external_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.external_policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePrintersProto.external_policy)
}
inline std::string* DevicePrintersProto::mutable_external_policy() {
  std::string* _s = _internal_mutable_external_policy();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePrintersProto.external_policy)
  return _s;
}
inline const std::string& DevicePrintersProto::_internal_external_policy() const {
  return _impl_.external_policy_.Get();
}
inline void DevicePrintersProto::_internal_set_external_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.external_policy_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicePrintersProto::_internal_mutable_external_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.external_policy_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicePrintersProto::release_external_policy() {
  // @@protoc_insertion_point(field_release:enterprise_management.DevicePrintersProto.external_policy)
  if (!_internal_has_external_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.external_policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_policy_.IsDefault()) {
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicePrintersProto::set_allocated_external_policy(std::string* external_policy) {
  if (external_policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.external_policy_.SetAllocated(external_policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_policy_.IsDefault()) {
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DevicePrintersProto.external_policy)
}

// -------------------------------------------------------------------

// DevicePrintersAccessModeProto

// optional .enterprise_management.DevicePrintersAccessModeProto.AccessMode access_mode = 1;
inline bool DevicePrintersAccessModeProto::_internal_has_access_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePrintersAccessModeProto::has_access_mode() const {
  return _internal_has_access_mode();
}
inline void DevicePrintersAccessModeProto::clear_access_mode() {
  _impl_.access_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto::_internal_access_mode() const {
  return static_cast< ::enterprise_management::DevicePrintersAccessModeProto_AccessMode >(_impl_.access_mode_);
}
inline ::enterprise_management::DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto::access_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePrintersAccessModeProto.access_mode)
  return _internal_access_mode();
}
inline void DevicePrintersAccessModeProto::_internal_set_access_mode(::enterprise_management::DevicePrintersAccessModeProto_AccessMode value) {
  assert(::enterprise_management::DevicePrintersAccessModeProto_AccessMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_mode_ = value;
}
inline void DevicePrintersAccessModeProto::set_access_mode(::enterprise_management::DevicePrintersAccessModeProto_AccessMode value) {
  _internal_set_access_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePrintersAccessModeProto.access_mode)
}

// -------------------------------------------------------------------

// DevicePrintersBlocklistProto

// repeated string blocklist = 1;
inline int DevicePrintersBlocklistProto::_internal_blocklist_size() const {
  return _impl_.blocklist_.size();
}
inline int DevicePrintersBlocklistProto::blocklist_size() const {
  return _internal_blocklist_size();
}
inline void DevicePrintersBlocklistProto::clear_blocklist() {
  _impl_.blocklist_.Clear();
}
inline std::string* DevicePrintersBlocklistProto::add_blocklist() {
  std::string* _s = _internal_add_blocklist();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DevicePrintersBlocklistProto.blocklist)
  return _s;
}
inline const std::string& DevicePrintersBlocklistProto::_internal_blocklist(int index) const {
  return _impl_.blocklist_.Get(index);
}
inline const std::string& DevicePrintersBlocklistProto::blocklist(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePrintersBlocklistProto.blocklist)
  return _internal_blocklist(index);
}
inline std::string* DevicePrintersBlocklistProto::mutable_blocklist(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePrintersBlocklistProto.blocklist)
  return _impl_.blocklist_.Mutable(index);
}
inline void DevicePrintersBlocklistProto::set_blocklist(int index, const std::string& value) {
  _impl_.blocklist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePrintersBlocklistProto.blocklist)
}
inline void DevicePrintersBlocklistProto::set_blocklist(int index, std::string&& value) {
  _impl_.blocklist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePrintersBlocklistProto.blocklist)
}
inline void DevicePrintersBlocklistProto::set_blocklist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.blocklist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DevicePrintersBlocklistProto.blocklist)
}
inline void DevicePrintersBlocklistProto::set_blocklist(int index, const char* value, size_t size) {
  _impl_.blocklist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DevicePrintersBlocklistProto.blocklist)
}
inline std::string* DevicePrintersBlocklistProto::_internal_add_blocklist() {
  return _impl_.blocklist_.Add();
}
inline void DevicePrintersBlocklistProto::add_blocklist(const std::string& value) {
  _impl_.blocklist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DevicePrintersBlocklistProto.blocklist)
}
inline void DevicePrintersBlocklistProto::add_blocklist(std::string&& value) {
  _impl_.blocklist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DevicePrintersBlocklistProto.blocklist)
}
inline void DevicePrintersBlocklistProto::add_blocklist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.blocklist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DevicePrintersBlocklistProto.blocklist)
}
inline void DevicePrintersBlocklistProto::add_blocklist(const char* value, size_t size) {
  _impl_.blocklist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DevicePrintersBlocklistProto.blocklist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DevicePrintersBlocklistProto::blocklist() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DevicePrintersBlocklistProto.blocklist)
  return _impl_.blocklist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DevicePrintersBlocklistProto::mutable_blocklist() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DevicePrintersBlocklistProto.blocklist)
  return &_impl_.blocklist_;
}

// -------------------------------------------------------------------

// DevicePrintersAllowlistProto

// repeated string allowlist = 1;
inline int DevicePrintersAllowlistProto::_internal_allowlist_size() const {
  return _impl_.allowlist_.size();
}
inline int DevicePrintersAllowlistProto::allowlist_size() const {
  return _internal_allowlist_size();
}
inline void DevicePrintersAllowlistProto::clear_allowlist() {
  _impl_.allowlist_.Clear();
}
inline std::string* DevicePrintersAllowlistProto::add_allowlist() {
  std::string* _s = _internal_add_allowlist();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DevicePrintersAllowlistProto.allowlist)
  return _s;
}
inline const std::string& DevicePrintersAllowlistProto::_internal_allowlist(int index) const {
  return _impl_.allowlist_.Get(index);
}
inline const std::string& DevicePrintersAllowlistProto::allowlist(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePrintersAllowlistProto.allowlist)
  return _internal_allowlist(index);
}
inline std::string* DevicePrintersAllowlistProto::mutable_allowlist(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePrintersAllowlistProto.allowlist)
  return _impl_.allowlist_.Mutable(index);
}
inline void DevicePrintersAllowlistProto::set_allowlist(int index, const std::string& value) {
  _impl_.allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePrintersAllowlistProto.allowlist)
}
inline void DevicePrintersAllowlistProto::set_allowlist(int index, std::string&& value) {
  _impl_.allowlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePrintersAllowlistProto.allowlist)
}
inline void DevicePrintersAllowlistProto::set_allowlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DevicePrintersAllowlistProto.allowlist)
}
inline void DevicePrintersAllowlistProto::set_allowlist(int index, const char* value, size_t size) {
  _impl_.allowlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DevicePrintersAllowlistProto.allowlist)
}
inline std::string* DevicePrintersAllowlistProto::_internal_add_allowlist() {
  return _impl_.allowlist_.Add();
}
inline void DevicePrintersAllowlistProto::add_allowlist(const std::string& value) {
  _impl_.allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DevicePrintersAllowlistProto.allowlist)
}
inline void DevicePrintersAllowlistProto::add_allowlist(std::string&& value) {
  _impl_.allowlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DevicePrintersAllowlistProto.allowlist)
}
inline void DevicePrintersAllowlistProto::add_allowlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DevicePrintersAllowlistProto.allowlist)
}
inline void DevicePrintersAllowlistProto::add_allowlist(const char* value, size_t size) {
  _impl_.allowlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DevicePrintersAllowlistProto.allowlist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DevicePrintersAllowlistProto::allowlist() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DevicePrintersAllowlistProto.allowlist)
  return _impl_.allowlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DevicePrintersAllowlistProto::mutable_allowlist() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DevicePrintersAllowlistProto.allowlist)
  return &_impl_.allowlist_;
}

// -------------------------------------------------------------------

// DeviceExternalPrintServersProto

// optional string external_policy = 1;
inline bool DeviceExternalPrintServersProto::_internal_has_external_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceExternalPrintServersProto::has_external_policy() const {
  return _internal_has_external_policy();
}
inline void DeviceExternalPrintServersProto::clear_external_policy() {
  _impl_.external_policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceExternalPrintServersProto::external_policy() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceExternalPrintServersProto.external_policy)
  return _internal_external_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceExternalPrintServersProto::set_external_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.external_policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceExternalPrintServersProto.external_policy)
}
inline std::string* DeviceExternalPrintServersProto::mutable_external_policy() {
  std::string* _s = _internal_mutable_external_policy();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceExternalPrintServersProto.external_policy)
  return _s;
}
inline const std::string& DeviceExternalPrintServersProto::_internal_external_policy() const {
  return _impl_.external_policy_.Get();
}
inline void DeviceExternalPrintServersProto::_internal_set_external_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.external_policy_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceExternalPrintServersProto::_internal_mutable_external_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.external_policy_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceExternalPrintServersProto::release_external_policy() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceExternalPrintServersProto.external_policy)
  if (!_internal_has_external_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.external_policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_policy_.IsDefault()) {
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceExternalPrintServersProto::set_allocated_external_policy(std::string* external_policy) {
  if (external_policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.external_policy_.SetAllocated(external_policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_policy_.IsDefault()) {
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceExternalPrintServersProto.external_policy)
}

// -------------------------------------------------------------------

// DeviceExternalPrintServersAllowlistProto

// repeated string allowlist = 1;
inline int DeviceExternalPrintServersAllowlistProto::_internal_allowlist_size() const {
  return _impl_.allowlist_.size();
}
inline int DeviceExternalPrintServersAllowlistProto::allowlist_size() const {
  return _internal_allowlist_size();
}
inline void DeviceExternalPrintServersAllowlistProto::clear_allowlist() {
  _impl_.allowlist_.Clear();
}
inline std::string* DeviceExternalPrintServersAllowlistProto::add_allowlist() {
  std::string* _s = _internal_add_allowlist();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
  return _s;
}
inline const std::string& DeviceExternalPrintServersAllowlistProto::_internal_allowlist(int index) const {
  return _impl_.allowlist_.Get(index);
}
inline const std::string& DeviceExternalPrintServersAllowlistProto::allowlist(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
  return _internal_allowlist(index);
}
inline std::string* DeviceExternalPrintServersAllowlistProto::mutable_allowlist(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
  return _impl_.allowlist_.Mutable(index);
}
inline void DeviceExternalPrintServersAllowlistProto::set_allowlist(int index, const std::string& value) {
  _impl_.allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
}
inline void DeviceExternalPrintServersAllowlistProto::set_allowlist(int index, std::string&& value) {
  _impl_.allowlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
}
inline void DeviceExternalPrintServersAllowlistProto::set_allowlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
}
inline void DeviceExternalPrintServersAllowlistProto::set_allowlist(int index, const char* value, size_t size) {
  _impl_.allowlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
}
inline std::string* DeviceExternalPrintServersAllowlistProto::_internal_add_allowlist() {
  return _impl_.allowlist_.Add();
}
inline void DeviceExternalPrintServersAllowlistProto::add_allowlist(const std::string& value) {
  _impl_.allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
}
inline void DeviceExternalPrintServersAllowlistProto::add_allowlist(std::string&& value) {
  _impl_.allowlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
}
inline void DeviceExternalPrintServersAllowlistProto::add_allowlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
}
inline void DeviceExternalPrintServersAllowlistProto::add_allowlist(const char* value, size_t size) {
  _impl_.allowlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceExternalPrintServersAllowlistProto::allowlist() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
  return _impl_.allowlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceExternalPrintServersAllowlistProto::mutable_allowlist() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceExternalPrintServersAllowlistProto.allowlist)
  return &_impl_.allowlist_;
}

// -------------------------------------------------------------------

// TPMFirmwareUpdateSettingsProto

// optional bool allow_user_initiated_powerwash = 1;
inline bool TPMFirmwareUpdateSettingsProto::_internal_has_allow_user_initiated_powerwash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TPMFirmwareUpdateSettingsProto::has_allow_user_initiated_powerwash() const {
  return _internal_has_allow_user_initiated_powerwash();
}
inline void TPMFirmwareUpdateSettingsProto::clear_allow_user_initiated_powerwash() {
  _impl_.allow_user_initiated_powerwash_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool TPMFirmwareUpdateSettingsProto::_internal_allow_user_initiated_powerwash() const {
  return _impl_.allow_user_initiated_powerwash_;
}
inline bool TPMFirmwareUpdateSettingsProto::allow_user_initiated_powerwash() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TPMFirmwareUpdateSettingsProto.allow_user_initiated_powerwash)
  return _internal_allow_user_initiated_powerwash();
}
inline void TPMFirmwareUpdateSettingsProto::_internal_set_allow_user_initiated_powerwash(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allow_user_initiated_powerwash_ = value;
}
inline void TPMFirmwareUpdateSettingsProto::set_allow_user_initiated_powerwash(bool value) {
  _internal_set_allow_user_initiated_powerwash(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TPMFirmwareUpdateSettingsProto.allow_user_initiated_powerwash)
}

// optional bool allow_user_initiated_preserve_device_state = 2;
inline bool TPMFirmwareUpdateSettingsProto::_internal_has_allow_user_initiated_preserve_device_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TPMFirmwareUpdateSettingsProto::has_allow_user_initiated_preserve_device_state() const {
  return _internal_has_allow_user_initiated_preserve_device_state();
}
inline void TPMFirmwareUpdateSettingsProto::clear_allow_user_initiated_preserve_device_state() {
  _impl_.allow_user_initiated_preserve_device_state_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TPMFirmwareUpdateSettingsProto::_internal_allow_user_initiated_preserve_device_state() const {
  return _impl_.allow_user_initiated_preserve_device_state_;
}
inline bool TPMFirmwareUpdateSettingsProto::allow_user_initiated_preserve_device_state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TPMFirmwareUpdateSettingsProto.allow_user_initiated_preserve_device_state)
  return _internal_allow_user_initiated_preserve_device_state();
}
inline void TPMFirmwareUpdateSettingsProto::_internal_set_allow_user_initiated_preserve_device_state(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.allow_user_initiated_preserve_device_state_ = value;
}
inline void TPMFirmwareUpdateSettingsProto::set_allow_user_initiated_preserve_device_state(bool value) {
  _internal_set_allow_user_initiated_preserve_device_state(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TPMFirmwareUpdateSettingsProto.allow_user_initiated_preserve_device_state)
}

// optional .enterprise_management.TPMFirmwareUpdateSettingsProto.AutoUpdateMode auto_update_mode = 3 [default = NEVER];
inline bool TPMFirmwareUpdateSettingsProto::_internal_has_auto_update_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TPMFirmwareUpdateSettingsProto::has_auto_update_mode() const {
  return _internal_has_auto_update_mode();
}
inline void TPMFirmwareUpdateSettingsProto::clear_auto_update_mode() {
  _impl_.auto_update_mode_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::_internal_auto_update_mode() const {
  return static_cast< ::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode >(_impl_.auto_update_mode_);
}
inline ::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::auto_update_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TPMFirmwareUpdateSettingsProto.auto_update_mode)
  return _internal_auto_update_mode();
}
inline void TPMFirmwareUpdateSettingsProto::_internal_set_auto_update_mode(::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode value) {
  assert(::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.auto_update_mode_ = value;
}
inline void TPMFirmwareUpdateSettingsProto::set_auto_update_mode(::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode value) {
  _internal_set_auto_update_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TPMFirmwareUpdateSettingsProto.auto_update_mode)
}

// -------------------------------------------------------------------

// OBSOLETE_MinimumRequiredVersionProto

// optional string OBSOLETE_chrome_version = 1 [deprecated = true];
inline bool OBSOLETE_MinimumRequiredVersionProto::_internal_has_obsolete_chrome_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_MinimumRequiredVersionProto::has_obsolete_chrome_version() const {
  return _internal_has_obsolete_chrome_version();
}
inline void OBSOLETE_MinimumRequiredVersionProto::clear_obsolete_chrome_version() {
  _impl_.obsolete_chrome_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OBSOLETE_MinimumRequiredVersionProto::obsolete_chrome_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_MinimumRequiredVersionProto.OBSOLETE_chrome_version)
  return _internal_obsolete_chrome_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_MinimumRequiredVersionProto::set_obsolete_chrome_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.obsolete_chrome_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_MinimumRequiredVersionProto.OBSOLETE_chrome_version)
}
inline std::string* OBSOLETE_MinimumRequiredVersionProto::mutable_obsolete_chrome_version() {
  std::string* _s = _internal_mutable_obsolete_chrome_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_MinimumRequiredVersionProto.OBSOLETE_chrome_version)
  return _s;
}
inline const std::string& OBSOLETE_MinimumRequiredVersionProto::_internal_obsolete_chrome_version() const {
  return _impl_.obsolete_chrome_version_.Get();
}
inline void OBSOLETE_MinimumRequiredVersionProto::_internal_set_obsolete_chrome_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_chrome_version_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_MinimumRequiredVersionProto::_internal_mutable_obsolete_chrome_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.obsolete_chrome_version_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_MinimumRequiredVersionProto::release_obsolete_chrome_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_MinimumRequiredVersionProto.OBSOLETE_chrome_version)
  if (!_internal_has_obsolete_chrome_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.obsolete_chrome_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_chrome_version_.IsDefault()) {
    _impl_.obsolete_chrome_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_MinimumRequiredVersionProto::set_allocated_obsolete_chrome_version(std::string* obsolete_chrome_version) {
  if (obsolete_chrome_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obsolete_chrome_version_.SetAllocated(obsolete_chrome_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_chrome_version_.IsDefault()) {
    _impl_.obsolete_chrome_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_MinimumRequiredVersionProto.OBSOLETE_chrome_version)
}

// -------------------------------------------------------------------

// DeviceLoginScreenAutoSelectCertificateForUrls

// repeated string login_screen_auto_select_certificate_rules = 1;
inline int DeviceLoginScreenAutoSelectCertificateForUrls::_internal_login_screen_auto_select_certificate_rules_size() const {
  return _impl_.login_screen_auto_select_certificate_rules_.size();
}
inline int DeviceLoginScreenAutoSelectCertificateForUrls::login_screen_auto_select_certificate_rules_size() const {
  return _internal_login_screen_auto_select_certificate_rules_size();
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::clear_login_screen_auto_select_certificate_rules() {
  _impl_.login_screen_auto_select_certificate_rules_.Clear();
}
inline std::string* DeviceLoginScreenAutoSelectCertificateForUrls::add_login_screen_auto_select_certificate_rules() {
  std::string* _s = _internal_add_login_screen_auto_select_certificate_rules();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
  return _s;
}
inline const std::string& DeviceLoginScreenAutoSelectCertificateForUrls::_internal_login_screen_auto_select_certificate_rules(int index) const {
  return _impl_.login_screen_auto_select_certificate_rules_.Get(index);
}
inline const std::string& DeviceLoginScreenAutoSelectCertificateForUrls::login_screen_auto_select_certificate_rules(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
  return _internal_login_screen_auto_select_certificate_rules(index);
}
inline std::string* DeviceLoginScreenAutoSelectCertificateForUrls::mutable_login_screen_auto_select_certificate_rules(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
  return _impl_.login_screen_auto_select_certificate_rules_.Mutable(index);
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::set_login_screen_auto_select_certificate_rules(int index, const std::string& value) {
  _impl_.login_screen_auto_select_certificate_rules_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::set_login_screen_auto_select_certificate_rules(int index, std::string&& value) {
  _impl_.login_screen_auto_select_certificate_rules_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::set_login_screen_auto_select_certificate_rules(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.login_screen_auto_select_certificate_rules_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::set_login_screen_auto_select_certificate_rules(int index, const char* value, size_t size) {
  _impl_.login_screen_auto_select_certificate_rules_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
}
inline std::string* DeviceLoginScreenAutoSelectCertificateForUrls::_internal_add_login_screen_auto_select_certificate_rules() {
  return _impl_.login_screen_auto_select_certificate_rules_.Add();
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::add_login_screen_auto_select_certificate_rules(const std::string& value) {
  _impl_.login_screen_auto_select_certificate_rules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::add_login_screen_auto_select_certificate_rules(std::string&& value) {
  _impl_.login_screen_auto_select_certificate_rules_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::add_login_screen_auto_select_certificate_rules(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.login_screen_auto_select_certificate_rules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
}
inline void DeviceLoginScreenAutoSelectCertificateForUrls::add_login_screen_auto_select_certificate_rules(const char* value, size_t size) {
  _impl_.login_screen_auto_select_certificate_rules_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceLoginScreenAutoSelectCertificateForUrls::login_screen_auto_select_certificate_rules() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
  return _impl_.login_screen_auto_select_certificate_rules_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceLoginScreenAutoSelectCertificateForUrls::mutable_login_screen_auto_select_certificate_rules() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls.login_screen_auto_select_certificate_rules)
  return &_impl_.login_screen_auto_select_certificate_rules_;
}

// -------------------------------------------------------------------

// UnaffiliatedArcAllowedProto

// optional bool unaffiliated_arc_allowed = 1;
inline bool UnaffiliatedArcAllowedProto::_internal_has_unaffiliated_arc_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnaffiliatedArcAllowedProto::has_unaffiliated_arc_allowed() const {
  return _internal_has_unaffiliated_arc_allowed();
}
inline void UnaffiliatedArcAllowedProto::clear_unaffiliated_arc_allowed() {
  _impl_.unaffiliated_arc_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UnaffiliatedArcAllowedProto::_internal_unaffiliated_arc_allowed() const {
  return _impl_.unaffiliated_arc_allowed_;
}
inline bool UnaffiliatedArcAllowedProto::unaffiliated_arc_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UnaffiliatedArcAllowedProto.unaffiliated_arc_allowed)
  return _internal_unaffiliated_arc_allowed();
}
inline void UnaffiliatedArcAllowedProto::_internal_set_unaffiliated_arc_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unaffiliated_arc_allowed_ = value;
}
inline void UnaffiliatedArcAllowedProto::set_unaffiliated_arc_allowed(bool value) {
  _internal_set_unaffiliated_arc_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UnaffiliatedArcAllowedProto.unaffiliated_arc_allowed)
}

// -------------------------------------------------------------------

// DeviceKerberosEncryptionTypesProto

// optional .enterprise_management.DeviceKerberosEncryptionTypesProto.Types types = 1 [default = ENC_TYPES_STRONG];
inline bool DeviceKerberosEncryptionTypesProto::_internal_has_types() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceKerberosEncryptionTypesProto::has_types() const {
  return _internal_has_types();
}
inline void DeviceKerberosEncryptionTypesProto::clear_types() {
  _impl_.types_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto::_internal_types() const {
  return static_cast< ::enterprise_management::DeviceKerberosEncryptionTypesProto_Types >(_impl_.types_);
}
inline ::enterprise_management::DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto::types() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceKerberosEncryptionTypesProto.types)
  return _internal_types();
}
inline void DeviceKerberosEncryptionTypesProto::_internal_set_types(::enterprise_management::DeviceKerberosEncryptionTypesProto_Types value) {
  assert(::enterprise_management::DeviceKerberosEncryptionTypesProto_Types_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.types_ = value;
}
inline void DeviceKerberosEncryptionTypesProto::set_types(::enterprise_management::DeviceKerberosEncryptionTypesProto_Types value) {
  _internal_set_types(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceKerberosEncryptionTypesProto.types)
}

// -------------------------------------------------------------------

// KeyboardBacklightColorProto

// optional .enterprise_management.KeyboardBacklightColorProto.BacklightColor color = 1 [default = BACKLIGHT_UNSPECIFIED];
inline bool KeyboardBacklightColorProto::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyboardBacklightColorProto::has_color() const {
  return _internal_has_color();
}
inline void KeyboardBacklightColorProto::clear_color() {
  _impl_.color_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::_internal_color() const {
  return static_cast< ::enterprise_management::KeyboardBacklightColorProto_BacklightColor >(_impl_.color_);
}
inline ::enterprise_management::KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::color() const {
  // @@protoc_insertion_point(field_get:enterprise_management.KeyboardBacklightColorProto.color)
  return _internal_color();
}
inline void KeyboardBacklightColorProto::_internal_set_color(::enterprise_management::KeyboardBacklightColorProto_BacklightColor value) {
  assert(::enterprise_management::KeyboardBacklightColorProto_BacklightColor_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.color_ = value;
}
inline void KeyboardBacklightColorProto::set_color(::enterprise_management::KeyboardBacklightColorProto_BacklightColor value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:enterprise_management.KeyboardBacklightColorProto.color)
}

// -------------------------------------------------------------------

// DeviceUserPolicyLoopbackProcessingModeProto

// optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto.Mode mode = 1 [default = USER_POLICY_MODE_DEFAULT];
inline bool DeviceUserPolicyLoopbackProcessingModeProto::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceUserPolicyLoopbackProcessingModeProto::has_mode() const {
  return _internal_has_mode();
}
inline void DeviceUserPolicyLoopbackProcessingModeProto::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto::_internal_mode() const {
  return static_cast< ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode >(_impl_.mode_);
}
inline ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto::mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto.mode)
  return _internal_mode();
}
inline void DeviceUserPolicyLoopbackProcessingModeProto::_internal_set_mode(::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode value) {
  assert(::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mode_ = value;
}
inline void DeviceUserPolicyLoopbackProcessingModeProto::set_mode(::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto.mode)
}

// -------------------------------------------------------------------

// OBSOLETE_DeviceLoginScreenIsolateOriginsProto

// optional string OBSOLETE_isolate_origins = 1 [deprecated = true];
inline bool OBSOLETE_DeviceLoginScreenIsolateOriginsProto::_internal_has_obsolete_isolate_origins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_DeviceLoginScreenIsolateOriginsProto::has_obsolete_isolate_origins() const {
  return _internal_has_obsolete_isolate_origins();
}
inline void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::clear_obsolete_isolate_origins() {
  _impl_.obsolete_isolate_origins_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OBSOLETE_DeviceLoginScreenIsolateOriginsProto::obsolete_isolate_origins() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto.OBSOLETE_isolate_origins)
  return _internal_obsolete_isolate_origins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::set_obsolete_isolate_origins(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.obsolete_isolate_origins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto.OBSOLETE_isolate_origins)
}
inline std::string* OBSOLETE_DeviceLoginScreenIsolateOriginsProto::mutable_obsolete_isolate_origins() {
  std::string* _s = _internal_mutable_obsolete_isolate_origins();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto.OBSOLETE_isolate_origins)
  return _s;
}
inline const std::string& OBSOLETE_DeviceLoginScreenIsolateOriginsProto::_internal_obsolete_isolate_origins() const {
  return _impl_.obsolete_isolate_origins_.Get();
}
inline void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::_internal_set_obsolete_isolate_origins(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_isolate_origins_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceLoginScreenIsolateOriginsProto::_internal_mutable_obsolete_isolate_origins() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.obsolete_isolate_origins_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_DeviceLoginScreenIsolateOriginsProto::release_obsolete_isolate_origins() {
  // @@protoc_insertion_point(field_release:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto.OBSOLETE_isolate_origins)
  if (!_internal_has_obsolete_isolate_origins()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.obsolete_isolate_origins_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_isolate_origins_.IsDefault()) {
    _impl_.obsolete_isolate_origins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::set_allocated_obsolete_isolate_origins(std::string* obsolete_isolate_origins) {
  if (obsolete_isolate_origins != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obsolete_isolate_origins_.SetAllocated(obsolete_isolate_origins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsolete_isolate_origins_.IsDefault()) {
    _impl_.obsolete_isolate_origins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto.OBSOLETE_isolate_origins)
}

// -------------------------------------------------------------------

// OBSOLETE_DeviceLoginScreenSitePerProcessProto

// optional bool OBSOLETE_site_per_process = 1 [deprecated = true];
inline bool OBSOLETE_DeviceLoginScreenSitePerProcessProto::_internal_has_obsolete_site_per_process() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_DeviceLoginScreenSitePerProcessProto::has_obsolete_site_per_process() const {
  return _internal_has_obsolete_site_per_process();
}
inline void OBSOLETE_DeviceLoginScreenSitePerProcessProto::clear_obsolete_site_per_process() {
  _impl_.obsolete_site_per_process_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OBSOLETE_DeviceLoginScreenSitePerProcessProto::_internal_obsolete_site_per_process() const {
  return _impl_.obsolete_site_per_process_;
}
inline bool OBSOLETE_DeviceLoginScreenSitePerProcessProto::obsolete_site_per_process() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto.OBSOLETE_site_per_process)
  return _internal_obsolete_site_per_process();
}
inline void OBSOLETE_DeviceLoginScreenSitePerProcessProto::_internal_set_obsolete_site_per_process(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obsolete_site_per_process_ = value;
}
inline void OBSOLETE_DeviceLoginScreenSitePerProcessProto::set_obsolete_site_per_process(bool value) {
  _internal_set_obsolete_site_per_process(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto.OBSOLETE_site_per_process)
}

// -------------------------------------------------------------------

// VirtualMachinesAllowedProto

// optional bool virtual_machines_allowed = 1;
inline bool VirtualMachinesAllowedProto::_internal_has_virtual_machines_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualMachinesAllowedProto::has_virtual_machines_allowed() const {
  return _internal_has_virtual_machines_allowed();
}
inline void VirtualMachinesAllowedProto::clear_virtual_machines_allowed() {
  _impl_.virtual_machines_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool VirtualMachinesAllowedProto::_internal_virtual_machines_allowed() const {
  return _impl_.virtual_machines_allowed_;
}
inline bool VirtualMachinesAllowedProto::virtual_machines_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.VirtualMachinesAllowedProto.virtual_machines_allowed)
  return _internal_virtual_machines_allowed();
}
inline void VirtualMachinesAllowedProto::_internal_set_virtual_machines_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.virtual_machines_allowed_ = value;
}
inline void VirtualMachinesAllowedProto::set_virtual_machines_allowed(bool value) {
  _internal_set_virtual_machines_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.VirtualMachinesAllowedProto.virtual_machines_allowed)
}

// -------------------------------------------------------------------

// DeviceMachinePasswordChangeRateProto

// optional int32 rate_days = 1;
inline bool DeviceMachinePasswordChangeRateProto::_internal_has_rate_days() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceMachinePasswordChangeRateProto::has_rate_days() const {
  return _internal_has_rate_days();
}
inline void DeviceMachinePasswordChangeRateProto::clear_rate_days() {
  _impl_.rate_days_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t DeviceMachinePasswordChangeRateProto::_internal_rate_days() const {
  return _impl_.rate_days_;
}
inline int32_t DeviceMachinePasswordChangeRateProto::rate_days() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceMachinePasswordChangeRateProto.rate_days)
  return _internal_rate_days();
}
inline void DeviceMachinePasswordChangeRateProto::_internal_set_rate_days(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rate_days_ = value;
}
inline void DeviceMachinePasswordChangeRateProto::set_rate_days(int32_t value) {
  _internal_set_rate_days(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceMachinePasswordChangeRateProto.rate_days)
}

// -------------------------------------------------------------------

// DeviceGpoCacheLifetimeProto

// optional int32 lifetime_hours = 1;
inline bool DeviceGpoCacheLifetimeProto::_internal_has_lifetime_hours() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceGpoCacheLifetimeProto::has_lifetime_hours() const {
  return _internal_has_lifetime_hours();
}
inline void DeviceGpoCacheLifetimeProto::clear_lifetime_hours() {
  _impl_.lifetime_hours_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t DeviceGpoCacheLifetimeProto::_internal_lifetime_hours() const {
  return _impl_.lifetime_hours_;
}
inline int32_t DeviceGpoCacheLifetimeProto::lifetime_hours() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceGpoCacheLifetimeProto.lifetime_hours)
  return _internal_lifetime_hours();
}
inline void DeviceGpoCacheLifetimeProto::_internal_set_lifetime_hours(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lifetime_hours_ = value;
}
inline void DeviceGpoCacheLifetimeProto::set_lifetime_hours(int32_t value) {
  _internal_set_lifetime_hours(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceGpoCacheLifetimeProto.lifetime_hours)
}

// -------------------------------------------------------------------

// DeviceAuthDataCacheLifetimeProto

// optional int32 lifetime_hours = 1;
inline bool DeviceAuthDataCacheLifetimeProto::_internal_has_lifetime_hours() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceAuthDataCacheLifetimeProto::has_lifetime_hours() const {
  return _internal_has_lifetime_hours();
}
inline void DeviceAuthDataCacheLifetimeProto::clear_lifetime_hours() {
  _impl_.lifetime_hours_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t DeviceAuthDataCacheLifetimeProto::_internal_lifetime_hours() const {
  return _impl_.lifetime_hours_;
}
inline int32_t DeviceAuthDataCacheLifetimeProto::lifetime_hours() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAuthDataCacheLifetimeProto.lifetime_hours)
  return _internal_lifetime_hours();
}
inline void DeviceAuthDataCacheLifetimeProto::_internal_set_lifetime_hours(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lifetime_hours_ = value;
}
inline void DeviceAuthDataCacheLifetimeProto::set_lifetime_hours(int32_t value) {
  _internal_set_lifetime_hours(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAuthDataCacheLifetimeProto.lifetime_hours)
}

// -------------------------------------------------------------------

// DeviceUnaffiliatedCrostiniAllowedProto

// optional bool device_unaffiliated_crostini_allowed = 1;
inline bool DeviceUnaffiliatedCrostiniAllowedProto::_internal_has_device_unaffiliated_crostini_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceUnaffiliatedCrostiniAllowedProto::has_device_unaffiliated_crostini_allowed() const {
  return _internal_has_device_unaffiliated_crostini_allowed();
}
inline void DeviceUnaffiliatedCrostiniAllowedProto::clear_device_unaffiliated_crostini_allowed() {
  _impl_.device_unaffiliated_crostini_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceUnaffiliatedCrostiniAllowedProto::_internal_device_unaffiliated_crostini_allowed() const {
  return _impl_.device_unaffiliated_crostini_allowed_;
}
inline bool DeviceUnaffiliatedCrostiniAllowedProto::device_unaffiliated_crostini_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto.device_unaffiliated_crostini_allowed)
  return _internal_device_unaffiliated_crostini_allowed();
}
inline void DeviceUnaffiliatedCrostiniAllowedProto::_internal_set_device_unaffiliated_crostini_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_unaffiliated_crostini_allowed_ = value;
}
inline void DeviceUnaffiliatedCrostiniAllowedProto::set_device_unaffiliated_crostini_allowed(bool value) {
  _internal_set_device_unaffiliated_crostini_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto.device_unaffiliated_crostini_allowed)
}

// -------------------------------------------------------------------

// PluginVmAllowedProto

// optional bool plugin_vm_allowed = 1;
inline bool PluginVmAllowedProto::_internal_has_plugin_vm_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PluginVmAllowedProto::has_plugin_vm_allowed() const {
  return _internal_has_plugin_vm_allowed();
}
inline void PluginVmAllowedProto::clear_plugin_vm_allowed() {
  _impl_.plugin_vm_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool PluginVmAllowedProto::_internal_plugin_vm_allowed() const {
  return _impl_.plugin_vm_allowed_;
}
inline bool PluginVmAllowedProto::plugin_vm_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PluginVmAllowedProto.plugin_vm_allowed)
  return _internal_plugin_vm_allowed();
}
inline void PluginVmAllowedProto::_internal_set_plugin_vm_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.plugin_vm_allowed_ = value;
}
inline void PluginVmAllowedProto::set_plugin_vm_allowed(bool value) {
  _internal_set_plugin_vm_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PluginVmAllowedProto.plugin_vm_allowed)
}

// -------------------------------------------------------------------

// PluginVmLicenseKeyProto

// optional string plugin_vm_license_key = 1;
inline bool PluginVmLicenseKeyProto::_internal_has_plugin_vm_license_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PluginVmLicenseKeyProto::has_plugin_vm_license_key() const {
  return _internal_has_plugin_vm_license_key();
}
inline void PluginVmLicenseKeyProto::clear_plugin_vm_license_key() {
  _impl_.plugin_vm_license_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PluginVmLicenseKeyProto::plugin_vm_license_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PluginVmLicenseKeyProto.plugin_vm_license_key)
  return _internal_plugin_vm_license_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PluginVmLicenseKeyProto::set_plugin_vm_license_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.plugin_vm_license_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PluginVmLicenseKeyProto.plugin_vm_license_key)
}
inline std::string* PluginVmLicenseKeyProto::mutable_plugin_vm_license_key() {
  std::string* _s = _internal_mutable_plugin_vm_license_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PluginVmLicenseKeyProto.plugin_vm_license_key)
  return _s;
}
inline const std::string& PluginVmLicenseKeyProto::_internal_plugin_vm_license_key() const {
  return _impl_.plugin_vm_license_key_.Get();
}
inline void PluginVmLicenseKeyProto::_internal_set_plugin_vm_license_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.plugin_vm_license_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PluginVmLicenseKeyProto::_internal_mutable_plugin_vm_license_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.plugin_vm_license_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PluginVmLicenseKeyProto::release_plugin_vm_license_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.PluginVmLicenseKeyProto.plugin_vm_license_key)
  if (!_internal_has_plugin_vm_license_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.plugin_vm_license_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plugin_vm_license_key_.IsDefault()) {
    _impl_.plugin_vm_license_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PluginVmLicenseKeyProto::set_allocated_plugin_vm_license_key(std::string* plugin_vm_license_key) {
  if (plugin_vm_license_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.plugin_vm_license_key_.SetAllocated(plugin_vm_license_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plugin_vm_license_key_.IsDefault()) {
    _impl_.plugin_vm_license_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PluginVmLicenseKeyProto.plugin_vm_license_key)
}

// -------------------------------------------------------------------

// DeviceRebootOnUserSignoutProto

// optional .enterprise_management.DeviceRebootOnUserSignoutProto.RebootOnSignoutMode reboot_on_signout_mode = 1 [default = NEVER];
inline bool DeviceRebootOnUserSignoutProto::_internal_has_reboot_on_signout_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceRebootOnUserSignoutProto::has_reboot_on_signout_mode() const {
  return _internal_has_reboot_on_signout_mode();
}
inline void DeviceRebootOnUserSignoutProto::clear_reboot_on_signout_mode() {
  _impl_.reboot_on_signout_mode_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::_internal_reboot_on_signout_mode() const {
  return static_cast< ::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode >(_impl_.reboot_on_signout_mode_);
}
inline ::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::reboot_on_signout_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRebootOnUserSignoutProto.reboot_on_signout_mode)
  return _internal_reboot_on_signout_mode();
}
inline void DeviceRebootOnUserSignoutProto::_internal_set_reboot_on_signout_mode(::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode value) {
  assert(::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reboot_on_signout_mode_ = value;
}
inline void DeviceRebootOnUserSignoutProto::set_reboot_on_signout_mode(::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode value) {
  _internal_set_reboot_on_signout_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRebootOnUserSignoutProto.reboot_on_signout_mode)
}

// -------------------------------------------------------------------

// DeviceWilcoDtcAllowedProto

// optional bool device_wilco_dtc_allowed = 1;
inline bool DeviceWilcoDtcAllowedProto::_internal_has_device_wilco_dtc_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceWilcoDtcAllowedProto::has_device_wilco_dtc_allowed() const {
  return _internal_has_device_wilco_dtc_allowed();
}
inline void DeviceWilcoDtcAllowedProto::clear_device_wilco_dtc_allowed() {
  _impl_.device_wilco_dtc_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceWilcoDtcAllowedProto::_internal_device_wilco_dtc_allowed() const {
  return _impl_.device_wilco_dtc_allowed_;
}
inline bool DeviceWilcoDtcAllowedProto::device_wilco_dtc_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceWilcoDtcAllowedProto.device_wilco_dtc_allowed)
  return _internal_device_wilco_dtc_allowed();
}
inline void DeviceWilcoDtcAllowedProto::_internal_set_device_wilco_dtc_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_wilco_dtc_allowed_ = value;
}
inline void DeviceWilcoDtcAllowedProto::set_device_wilco_dtc_allowed(bool value) {
  _internal_set_device_wilco_dtc_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceWilcoDtcAllowedProto.device_wilco_dtc_allowed)
}

// -------------------------------------------------------------------

// DeviceWilcoDtcConfigurationProto

// optional string device_wilco_dtc_configuration = 1;
inline bool DeviceWilcoDtcConfigurationProto::_internal_has_device_wilco_dtc_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceWilcoDtcConfigurationProto::has_device_wilco_dtc_configuration() const {
  return _internal_has_device_wilco_dtc_configuration();
}
inline void DeviceWilcoDtcConfigurationProto::clear_device_wilco_dtc_configuration() {
  _impl_.device_wilco_dtc_configuration_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceWilcoDtcConfigurationProto::device_wilco_dtc_configuration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceWilcoDtcConfigurationProto.device_wilco_dtc_configuration)
  return _internal_device_wilco_dtc_configuration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceWilcoDtcConfigurationProto::set_device_wilco_dtc_configuration(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_wilco_dtc_configuration_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceWilcoDtcConfigurationProto.device_wilco_dtc_configuration)
}
inline std::string* DeviceWilcoDtcConfigurationProto::mutable_device_wilco_dtc_configuration() {
  std::string* _s = _internal_mutable_device_wilco_dtc_configuration();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceWilcoDtcConfigurationProto.device_wilco_dtc_configuration)
  return _s;
}
inline const std::string& DeviceWilcoDtcConfigurationProto::_internal_device_wilco_dtc_configuration() const {
  return _impl_.device_wilco_dtc_configuration_.Get();
}
inline void DeviceWilcoDtcConfigurationProto::_internal_set_device_wilco_dtc_configuration(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_wilco_dtc_configuration_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceWilcoDtcConfigurationProto::_internal_mutable_device_wilco_dtc_configuration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_wilco_dtc_configuration_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceWilcoDtcConfigurationProto::release_device_wilco_dtc_configuration() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceWilcoDtcConfigurationProto.device_wilco_dtc_configuration)
  if (!_internal_has_device_wilco_dtc_configuration()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_wilco_dtc_configuration_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_wilco_dtc_configuration_.IsDefault()) {
    _impl_.device_wilco_dtc_configuration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceWilcoDtcConfigurationProto::set_allocated_device_wilco_dtc_configuration(std::string* device_wilco_dtc_configuration) {
  if (device_wilco_dtc_configuration != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_wilco_dtc_configuration_.SetAllocated(device_wilco_dtc_configuration, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_wilco_dtc_configuration_.IsDefault()) {
    _impl_.device_wilco_dtc_configuration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceWilcoDtcConfigurationProto.device_wilco_dtc_configuration)
}

// -------------------------------------------------------------------

// DevicePowerPeakShiftProto

// optional bool enabled = 1;
inline bool DevicePowerPeakShiftProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DevicePowerPeakShiftProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DevicePowerPeakShiftProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DevicePowerPeakShiftProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DevicePowerPeakShiftProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePowerPeakShiftProto.enabled)
  return _internal_enabled();
}
inline void DevicePowerPeakShiftProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enabled_ = value;
}
inline void DevicePowerPeakShiftProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePowerPeakShiftProto.enabled)
}

// optional int32 battery_threshold = 2;
inline bool DevicePowerPeakShiftProto::_internal_has_battery_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DevicePowerPeakShiftProto::has_battery_threshold() const {
  return _internal_has_battery_threshold();
}
inline void DevicePowerPeakShiftProto::clear_battery_threshold() {
  _impl_.battery_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DevicePowerPeakShiftProto::_internal_battery_threshold() const {
  return _impl_.battery_threshold_;
}
inline int32_t DevicePowerPeakShiftProto::battery_threshold() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePowerPeakShiftProto.battery_threshold)
  return _internal_battery_threshold();
}
inline void DevicePowerPeakShiftProto::_internal_set_battery_threshold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.battery_threshold_ = value;
}
inline void DevicePowerPeakShiftProto::set_battery_threshold(int32_t value) {
  _internal_set_battery_threshold(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePowerPeakShiftProto.battery_threshold)
}

// optional string day_configs = 3;
inline bool DevicePowerPeakShiftProto::_internal_has_day_configs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePowerPeakShiftProto::has_day_configs() const {
  return _internal_has_day_configs();
}
inline void DevicePowerPeakShiftProto::clear_day_configs() {
  _impl_.day_configs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DevicePowerPeakShiftProto::day_configs() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePowerPeakShiftProto.day_configs)
  return _internal_day_configs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicePowerPeakShiftProto::set_day_configs(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.day_configs_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePowerPeakShiftProto.day_configs)
}
inline std::string* DevicePowerPeakShiftProto::mutable_day_configs() {
  std::string* _s = _internal_mutable_day_configs();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePowerPeakShiftProto.day_configs)
  return _s;
}
inline const std::string& DevicePowerPeakShiftProto::_internal_day_configs() const {
  return _impl_.day_configs_.Get();
}
inline void DevicePowerPeakShiftProto::_internal_set_day_configs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.day_configs_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicePowerPeakShiftProto::_internal_mutable_day_configs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.day_configs_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicePowerPeakShiftProto::release_day_configs() {
  // @@protoc_insertion_point(field_release:enterprise_management.DevicePowerPeakShiftProto.day_configs)
  if (!_internal_has_day_configs()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.day_configs_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.day_configs_.IsDefault()) {
    _impl_.day_configs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicePowerPeakShiftProto::set_allocated_day_configs(std::string* day_configs) {
  if (day_configs != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.day_configs_.SetAllocated(day_configs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.day_configs_.IsDefault()) {
    _impl_.day_configs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DevicePowerPeakShiftProto.day_configs)
}

// -------------------------------------------------------------------

// DeviceBootOnAcProto

// optional bool enabled = 1;
inline bool DeviceBootOnAcProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceBootOnAcProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceBootOnAcProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceBootOnAcProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceBootOnAcProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceBootOnAcProto.enabled)
  return _internal_enabled();
}
inline void DeviceBootOnAcProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceBootOnAcProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceBootOnAcProto.enabled)
}

// -------------------------------------------------------------------

// DeviceDockMacAddressSourceProto

// optional .enterprise_management.DeviceDockMacAddressSourceProto.Source source = 1;
inline bool DeviceDockMacAddressSourceProto::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceDockMacAddressSourceProto::has_source() const {
  return _internal_has_source();
}
inline void DeviceDockMacAddressSourceProto::clear_source() {
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto::_internal_source() const {
  return static_cast< ::enterprise_management::DeviceDockMacAddressSourceProto_Source >(_impl_.source_);
}
inline ::enterprise_management::DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto::source() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceDockMacAddressSourceProto.source)
  return _internal_source();
}
inline void DeviceDockMacAddressSourceProto::_internal_set_source(::enterprise_management::DeviceDockMacAddressSourceProto_Source value) {
  assert(::enterprise_management::DeviceDockMacAddressSourceProto_Source_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_ = value;
}
inline void DeviceDockMacAddressSourceProto::set_source(::enterprise_management::DeviceDockMacAddressSourceProto_Source value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceDockMacAddressSourceProto.source)
}

// -------------------------------------------------------------------

// DeviceAdvancedBatteryChargeModeProto

// optional bool enabled = 1;
inline bool DeviceAdvancedBatteryChargeModeProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceAdvancedBatteryChargeModeProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceAdvancedBatteryChargeModeProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DeviceAdvancedBatteryChargeModeProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceAdvancedBatteryChargeModeProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAdvancedBatteryChargeModeProto.enabled)
  return _internal_enabled();
}
inline void DeviceAdvancedBatteryChargeModeProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enabled_ = value;
}
inline void DeviceAdvancedBatteryChargeModeProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAdvancedBatteryChargeModeProto.enabled)
}

// optional string day_configs = 2;
inline bool DeviceAdvancedBatteryChargeModeProto::_internal_has_day_configs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceAdvancedBatteryChargeModeProto::has_day_configs() const {
  return _internal_has_day_configs();
}
inline void DeviceAdvancedBatteryChargeModeProto::clear_day_configs() {
  _impl_.day_configs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceAdvancedBatteryChargeModeProto::day_configs() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAdvancedBatteryChargeModeProto.day_configs)
  return _internal_day_configs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceAdvancedBatteryChargeModeProto::set_day_configs(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.day_configs_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAdvancedBatteryChargeModeProto.day_configs)
}
inline std::string* DeviceAdvancedBatteryChargeModeProto::mutable_day_configs() {
  std::string* _s = _internal_mutable_day_configs();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAdvancedBatteryChargeModeProto.day_configs)
  return _s;
}
inline const std::string& DeviceAdvancedBatteryChargeModeProto::_internal_day_configs() const {
  return _impl_.day_configs_.Get();
}
inline void DeviceAdvancedBatteryChargeModeProto::_internal_set_day_configs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.day_configs_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceAdvancedBatteryChargeModeProto::_internal_mutable_day_configs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.day_configs_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceAdvancedBatteryChargeModeProto::release_day_configs() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceAdvancedBatteryChargeModeProto.day_configs)
  if (!_internal_has_day_configs()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.day_configs_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.day_configs_.IsDefault()) {
    _impl_.day_configs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceAdvancedBatteryChargeModeProto::set_allocated_day_configs(std::string* day_configs) {
  if (day_configs != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.day_configs_.SetAllocated(day_configs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.day_configs_.IsDefault()) {
    _impl_.day_configs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceAdvancedBatteryChargeModeProto.day_configs)
}

// -------------------------------------------------------------------

// DeviceBatteryChargeModeProto

// optional .enterprise_management.DeviceBatteryChargeModeProto.BatteryChargeMode battery_charge_mode = 1;
inline bool DeviceBatteryChargeModeProto::_internal_has_battery_charge_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceBatteryChargeModeProto::has_battery_charge_mode() const {
  return _internal_has_battery_charge_mode();
}
inline void DeviceBatteryChargeModeProto::clear_battery_charge_mode() {
  _impl_.battery_charge_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::_internal_battery_charge_mode() const {
  return static_cast< ::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode >(_impl_.battery_charge_mode_);
}
inline ::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::battery_charge_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceBatteryChargeModeProto.battery_charge_mode)
  return _internal_battery_charge_mode();
}
inline void DeviceBatteryChargeModeProto::_internal_set_battery_charge_mode(::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode value) {
  assert(::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.battery_charge_mode_ = value;
}
inline void DeviceBatteryChargeModeProto::set_battery_charge_mode(::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode value) {
  _internal_set_battery_charge_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceBatteryChargeModeProto.battery_charge_mode)
}

// optional int32 custom_charge_start = 2;
inline bool DeviceBatteryChargeModeProto::_internal_has_custom_charge_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceBatteryChargeModeProto::has_custom_charge_start() const {
  return _internal_has_custom_charge_start();
}
inline void DeviceBatteryChargeModeProto::clear_custom_charge_start() {
  _impl_.custom_charge_start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t DeviceBatteryChargeModeProto::_internal_custom_charge_start() const {
  return _impl_.custom_charge_start_;
}
inline int32_t DeviceBatteryChargeModeProto::custom_charge_start() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceBatteryChargeModeProto.custom_charge_start)
  return _internal_custom_charge_start();
}
inline void DeviceBatteryChargeModeProto::_internal_set_custom_charge_start(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.custom_charge_start_ = value;
}
inline void DeviceBatteryChargeModeProto::set_custom_charge_start(int32_t value) {
  _internal_set_custom_charge_start(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceBatteryChargeModeProto.custom_charge_start)
}

// optional int32 custom_charge_stop = 3;
inline bool DeviceBatteryChargeModeProto::_internal_has_custom_charge_stop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceBatteryChargeModeProto::has_custom_charge_stop() const {
  return _internal_has_custom_charge_stop();
}
inline void DeviceBatteryChargeModeProto::clear_custom_charge_stop() {
  _impl_.custom_charge_stop_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DeviceBatteryChargeModeProto::_internal_custom_charge_stop() const {
  return _impl_.custom_charge_stop_;
}
inline int32_t DeviceBatteryChargeModeProto::custom_charge_stop() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceBatteryChargeModeProto.custom_charge_stop)
  return _internal_custom_charge_stop();
}
inline void DeviceBatteryChargeModeProto::_internal_set_custom_charge_stop(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.custom_charge_stop_ = value;
}
inline void DeviceBatteryChargeModeProto::set_custom_charge_stop(int32_t value) {
  _internal_set_custom_charge_stop(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceBatteryChargeModeProto.custom_charge_stop)
}

// -------------------------------------------------------------------

// DeviceUsbPowerShareProto

// optional bool enabled = 1;
inline bool DeviceUsbPowerShareProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceUsbPowerShareProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceUsbPowerShareProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceUsbPowerShareProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceUsbPowerShareProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceUsbPowerShareProto.enabled)
  return _internal_enabled();
}
inline void DeviceUsbPowerShareProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceUsbPowerShareProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceUsbPowerShareProto.enabled)
}

// -------------------------------------------------------------------

// DeviceScheduledUpdateCheckProto

// optional string device_scheduled_update_check_settings = 1;
inline bool DeviceScheduledUpdateCheckProto::_internal_has_device_scheduled_update_check_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceScheduledUpdateCheckProto::has_device_scheduled_update_check_settings() const {
  return _internal_has_device_scheduled_update_check_settings();
}
inline void DeviceScheduledUpdateCheckProto::clear_device_scheduled_update_check_settings() {
  _impl_.device_scheduled_update_check_settings_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceScheduledUpdateCheckProto::device_scheduled_update_check_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceScheduledUpdateCheckProto.device_scheduled_update_check_settings)
  return _internal_device_scheduled_update_check_settings();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceScheduledUpdateCheckProto::set_device_scheduled_update_check_settings(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_scheduled_update_check_settings_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceScheduledUpdateCheckProto.device_scheduled_update_check_settings)
}
inline std::string* DeviceScheduledUpdateCheckProto::mutable_device_scheduled_update_check_settings() {
  std::string* _s = _internal_mutable_device_scheduled_update_check_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceScheduledUpdateCheckProto.device_scheduled_update_check_settings)
  return _s;
}
inline const std::string& DeviceScheduledUpdateCheckProto::_internal_device_scheduled_update_check_settings() const {
  return _impl_.device_scheduled_update_check_settings_.Get();
}
inline void DeviceScheduledUpdateCheckProto::_internal_set_device_scheduled_update_check_settings(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_scheduled_update_check_settings_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceScheduledUpdateCheckProto::_internal_mutable_device_scheduled_update_check_settings() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_scheduled_update_check_settings_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceScheduledUpdateCheckProto::release_device_scheduled_update_check_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceScheduledUpdateCheckProto.device_scheduled_update_check_settings)
  if (!_internal_has_device_scheduled_update_check_settings()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_scheduled_update_check_settings_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_scheduled_update_check_settings_.IsDefault()) {
    _impl_.device_scheduled_update_check_settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceScheduledUpdateCheckProto::set_allocated_device_scheduled_update_check_settings(std::string* device_scheduled_update_check_settings) {
  if (device_scheduled_update_check_settings != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_scheduled_update_check_settings_.SetAllocated(device_scheduled_update_check_settings, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_scheduled_update_check_settings_.IsDefault()) {
    _impl_.device_scheduled_update_check_settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceScheduledUpdateCheckProto.device_scheduled_update_check_settings)
}

// -------------------------------------------------------------------

// DevicePowerwashAllowedProto

// optional bool device_powerwash_allowed = 1;
inline bool DevicePowerwashAllowedProto::_internal_has_device_powerwash_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePowerwashAllowedProto::has_device_powerwash_allowed() const {
  return _internal_has_device_powerwash_allowed();
}
inline void DevicePowerwashAllowedProto::clear_device_powerwash_allowed() {
  _impl_.device_powerwash_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DevicePowerwashAllowedProto::_internal_device_powerwash_allowed() const {
  return _impl_.device_powerwash_allowed_;
}
inline bool DevicePowerwashAllowedProto::device_powerwash_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePowerwashAllowedProto.device_powerwash_allowed)
  return _internal_device_powerwash_allowed();
}
inline void DevicePowerwashAllowedProto::_internal_set_device_powerwash_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_powerwash_allowed_ = value;
}
inline void DevicePowerwashAllowedProto::set_device_powerwash_allowed(bool value) {
  _internal_set_device_powerwash_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePowerwashAllowedProto.device_powerwash_allowed)
}

// -------------------------------------------------------------------

// DeviceLoginScreenWebUsbAllowDevicesForUrlsProto

// optional string device_login_screen_webusb_allow_devices_for_urls = 1;
inline bool DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::_internal_has_device_login_screen_webusb_allow_devices_for_urls() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::has_device_login_screen_webusb_allow_devices_for_urls() const {
  return _internal_has_device_login_screen_webusb_allow_devices_for_urls();
}
inline void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::clear_device_login_screen_webusb_allow_devices_for_urls() {
  _impl_.device_login_screen_webusb_allow_devices_for_urls_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::device_login_screen_webusb_allow_devices_for_urls() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto.device_login_screen_webusb_allow_devices_for_urls)
  return _internal_device_login_screen_webusb_allow_devices_for_urls();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::set_device_login_screen_webusb_allow_devices_for_urls(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_login_screen_webusb_allow_devices_for_urls_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto.device_login_screen_webusb_allow_devices_for_urls)
}
inline std::string* DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::mutable_device_login_screen_webusb_allow_devices_for_urls() {
  std::string* _s = _internal_mutable_device_login_screen_webusb_allow_devices_for_urls();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto.device_login_screen_webusb_allow_devices_for_urls)
  return _s;
}
inline const std::string& DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::_internal_device_login_screen_webusb_allow_devices_for_urls() const {
  return _impl_.device_login_screen_webusb_allow_devices_for_urls_.Get();
}
inline void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::_internal_set_device_login_screen_webusb_allow_devices_for_urls(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_login_screen_webusb_allow_devices_for_urls_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::_internal_mutable_device_login_screen_webusb_allow_devices_for_urls() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_login_screen_webusb_allow_devices_for_urls_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::release_device_login_screen_webusb_allow_devices_for_urls() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto.device_login_screen_webusb_allow_devices_for_urls)
  if (!_internal_has_device_login_screen_webusb_allow_devices_for_urls()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_login_screen_webusb_allow_devices_for_urls_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_login_screen_webusb_allow_devices_for_urls_.IsDefault()) {
    _impl_.device_login_screen_webusb_allow_devices_for_urls_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::set_allocated_device_login_screen_webusb_allow_devices_for_urls(std::string* device_login_screen_webusb_allow_devices_for_urls) {
  if (device_login_screen_webusb_allow_devices_for_urls != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_login_screen_webusb_allow_devices_for_urls_.SetAllocated(device_login_screen_webusb_allow_devices_for_urls, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_login_screen_webusb_allow_devices_for_urls_.IsDefault()) {
    _impl_.device_login_screen_webusb_allow_devices_for_urls_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto.device_login_screen_webusb_allow_devices_for_urls)
}

// -------------------------------------------------------------------

// SystemProxySettingsProto

// optional string system_proxy_settings = 1;
inline bool SystemProxySettingsProto::_internal_has_system_proxy_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemProxySettingsProto::has_system_proxy_settings() const {
  return _internal_has_system_proxy_settings();
}
inline void SystemProxySettingsProto::clear_system_proxy_settings() {
  _impl_.system_proxy_settings_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SystemProxySettingsProto::system_proxy_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemProxySettingsProto.system_proxy_settings)
  return _internal_system_proxy_settings();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemProxySettingsProto::set_system_proxy_settings(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.system_proxy_settings_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemProxySettingsProto.system_proxy_settings)
}
inline std::string* SystemProxySettingsProto::mutable_system_proxy_settings() {
  std::string* _s = _internal_mutable_system_proxy_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemProxySettingsProto.system_proxy_settings)
  return _s;
}
inline const std::string& SystemProxySettingsProto::_internal_system_proxy_settings() const {
  return _impl_.system_proxy_settings_.Get();
}
inline void SystemProxySettingsProto::_internal_set_system_proxy_settings(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.system_proxy_settings_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemProxySettingsProto::_internal_mutable_system_proxy_settings() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.system_proxy_settings_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemProxySettingsProto::release_system_proxy_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemProxySettingsProto.system_proxy_settings)
  if (!_internal_has_system_proxy_settings()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.system_proxy_settings_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_proxy_settings_.IsDefault()) {
    _impl_.system_proxy_settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemProxySettingsProto::set_allocated_system_proxy_settings(std::string* system_proxy_settings) {
  if (system_proxy_settings != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.system_proxy_settings_.SetAllocated(system_proxy_settings, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_proxy_settings_.IsDefault()) {
    _impl_.system_proxy_settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemProxySettingsProto.system_proxy_settings)
}

// -------------------------------------------------------------------

// RequiredClientCertificateForDeviceProto

// optional string required_client_certificate_for_device = 1;
inline bool RequiredClientCertificateForDeviceProto::_internal_has_required_client_certificate_for_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequiredClientCertificateForDeviceProto::has_required_client_certificate_for_device() const {
  return _internal_has_required_client_certificate_for_device();
}
inline void RequiredClientCertificateForDeviceProto::clear_required_client_certificate_for_device() {
  _impl_.required_client_certificate_for_device_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequiredClientCertificateForDeviceProto::required_client_certificate_for_device() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RequiredClientCertificateForDeviceProto.required_client_certificate_for_device)
  return _internal_required_client_certificate_for_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequiredClientCertificateForDeviceProto::set_required_client_certificate_for_device(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.required_client_certificate_for_device_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RequiredClientCertificateForDeviceProto.required_client_certificate_for_device)
}
inline std::string* RequiredClientCertificateForDeviceProto::mutable_required_client_certificate_for_device() {
  std::string* _s = _internal_mutable_required_client_certificate_for_device();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RequiredClientCertificateForDeviceProto.required_client_certificate_for_device)
  return _s;
}
inline const std::string& RequiredClientCertificateForDeviceProto::_internal_required_client_certificate_for_device() const {
  return _impl_.required_client_certificate_for_device_.Get();
}
inline void RequiredClientCertificateForDeviceProto::_internal_set_required_client_certificate_for_device(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.required_client_certificate_for_device_.Set(value, GetArenaForAllocation());
}
inline std::string* RequiredClientCertificateForDeviceProto::_internal_mutable_required_client_certificate_for_device() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.required_client_certificate_for_device_.Mutable(GetArenaForAllocation());
}
inline std::string* RequiredClientCertificateForDeviceProto::release_required_client_certificate_for_device() {
  // @@protoc_insertion_point(field_release:enterprise_management.RequiredClientCertificateForDeviceProto.required_client_certificate_for_device)
  if (!_internal_has_required_client_certificate_for_device()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.required_client_certificate_for_device_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.required_client_certificate_for_device_.IsDefault()) {
    _impl_.required_client_certificate_for_device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequiredClientCertificateForDeviceProto::set_allocated_required_client_certificate_for_device(std::string* required_client_certificate_for_device) {
  if (required_client_certificate_for_device != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.required_client_certificate_for_device_.SetAllocated(required_client_certificate_for_device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.required_client_certificate_for_device_.IsDefault()) {
    _impl_.required_client_certificate_for_device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RequiredClientCertificateForDeviceProto.required_client_certificate_for_device)
}

// -------------------------------------------------------------------

// DeviceCrostiniArcAdbSideloadingAllowedProto

// optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto.AllowanceMode mode = 1 [default = DISALLOW];
inline bool DeviceCrostiniArcAdbSideloadingAllowedProto::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceCrostiniArcAdbSideloadingAllowedProto::has_mode() const {
  return _internal_has_mode();
}
inline void DeviceCrostiniArcAdbSideloadingAllowedProto::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto::_internal_mode() const {
  return static_cast< ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode >(_impl_.mode_);
}
inline ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto::mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto.mode)
  return _internal_mode();
}
inline void DeviceCrostiniArcAdbSideloadingAllowedProto::_internal_set_mode(::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode value) {
  assert(::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mode_ = value;
}
inline void DeviceCrostiniArcAdbSideloadingAllowedProto::set_mode(::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto.mode)
}

// -------------------------------------------------------------------

// DeviceShowLowDiskSpaceNotificationProto

// optional bool device_show_low_disk_space_notification = 1;
inline bool DeviceShowLowDiskSpaceNotificationProto::_internal_has_device_show_low_disk_space_notification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceShowLowDiskSpaceNotificationProto::has_device_show_low_disk_space_notification() const {
  return _internal_has_device_show_low_disk_space_notification();
}
inline void DeviceShowLowDiskSpaceNotificationProto::clear_device_show_low_disk_space_notification() {
  _impl_.device_show_low_disk_space_notification_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceShowLowDiskSpaceNotificationProto::_internal_device_show_low_disk_space_notification() const {
  return _impl_.device_show_low_disk_space_notification_;
}
inline bool DeviceShowLowDiskSpaceNotificationProto::device_show_low_disk_space_notification() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceShowLowDiskSpaceNotificationProto.device_show_low_disk_space_notification)
  return _internal_device_show_low_disk_space_notification();
}
inline void DeviceShowLowDiskSpaceNotificationProto::_internal_set_device_show_low_disk_space_notification(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_show_low_disk_space_notification_ = value;
}
inline void DeviceShowLowDiskSpaceNotificationProto::set_device_show_low_disk_space_notification(bool value) {
  _internal_set_device_show_low_disk_space_notification(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceShowLowDiskSpaceNotificationProto.device_show_low_disk_space_notification)
}

// -------------------------------------------------------------------

// DeviceFamilyLinkAccountsAllowedProto

// optional bool family_link_accounts_allowed = 1 [default = false];
inline bool DeviceFamilyLinkAccountsAllowedProto::_internal_has_family_link_accounts_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceFamilyLinkAccountsAllowedProto::has_family_link_accounts_allowed() const {
  return _internal_has_family_link_accounts_allowed();
}
inline void DeviceFamilyLinkAccountsAllowedProto::clear_family_link_accounts_allowed() {
  _impl_.family_link_accounts_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceFamilyLinkAccountsAllowedProto::_internal_family_link_accounts_allowed() const {
  return _impl_.family_link_accounts_allowed_;
}
inline bool DeviceFamilyLinkAccountsAllowedProto::family_link_accounts_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceFamilyLinkAccountsAllowedProto.family_link_accounts_allowed)
  return _internal_family_link_accounts_allowed();
}
inline void DeviceFamilyLinkAccountsAllowedProto::_internal_set_family_link_accounts_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.family_link_accounts_allowed_ = value;
}
inline void DeviceFamilyLinkAccountsAllowedProto::set_family_link_accounts_allowed(bool value) {
  _internal_set_family_link_accounts_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceFamilyLinkAccountsAllowedProto.family_link_accounts_allowed)
}

// -------------------------------------------------------------------

// DeviceArcDataSnapshotHoursProto

// optional string arc_data_snapshot_hours = 1;
inline bool DeviceArcDataSnapshotHoursProto::_internal_has_arc_data_snapshot_hours() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceArcDataSnapshotHoursProto::has_arc_data_snapshot_hours() const {
  return _internal_has_arc_data_snapshot_hours();
}
inline void DeviceArcDataSnapshotHoursProto::clear_arc_data_snapshot_hours() {
  _impl_.arc_data_snapshot_hours_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceArcDataSnapshotHoursProto::arc_data_snapshot_hours() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceArcDataSnapshotHoursProto.arc_data_snapshot_hours)
  return _internal_arc_data_snapshot_hours();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceArcDataSnapshotHoursProto::set_arc_data_snapshot_hours(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.arc_data_snapshot_hours_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceArcDataSnapshotHoursProto.arc_data_snapshot_hours)
}
inline std::string* DeviceArcDataSnapshotHoursProto::mutable_arc_data_snapshot_hours() {
  std::string* _s = _internal_mutable_arc_data_snapshot_hours();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceArcDataSnapshotHoursProto.arc_data_snapshot_hours)
  return _s;
}
inline const std::string& DeviceArcDataSnapshotHoursProto::_internal_arc_data_snapshot_hours() const {
  return _impl_.arc_data_snapshot_hours_.Get();
}
inline void DeviceArcDataSnapshotHoursProto::_internal_set_arc_data_snapshot_hours(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.arc_data_snapshot_hours_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceArcDataSnapshotHoursProto::_internal_mutable_arc_data_snapshot_hours() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.arc_data_snapshot_hours_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceArcDataSnapshotHoursProto::release_arc_data_snapshot_hours() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceArcDataSnapshotHoursProto.arc_data_snapshot_hours)
  if (!_internal_has_arc_data_snapshot_hours()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.arc_data_snapshot_hours_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arc_data_snapshot_hours_.IsDefault()) {
    _impl_.arc_data_snapshot_hours_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceArcDataSnapshotHoursProto::set_allocated_arc_data_snapshot_hours(std::string* arc_data_snapshot_hours) {
  if (arc_data_snapshot_hours != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.arc_data_snapshot_hours_.SetAllocated(arc_data_snapshot_hours, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arc_data_snapshot_hours_.IsDefault()) {
    _impl_.arc_data_snapshot_hours_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceArcDataSnapshotHoursProto.arc_data_snapshot_hours)
}

// -------------------------------------------------------------------

// DeviceSystemWideTracingEnabledProto

// optional bool enabled = 1 [default = false];
inline bool DeviceSystemWideTracingEnabledProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceSystemWideTracingEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceSystemWideTracingEnabledProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceSystemWideTracingEnabledProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceSystemWideTracingEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceSystemWideTracingEnabledProto.enabled)
  return _internal_enabled();
}
inline void DeviceSystemWideTracingEnabledProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceSystemWideTracingEnabledProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceSystemWideTracingEnabledProto.enabled)
}

// -------------------------------------------------------------------

// DevicePciPeripheralDataAccessEnabledProto

// optional bool enabled = 1 [default = false];
inline bool DevicePciPeripheralDataAccessEnabledProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePciPeripheralDataAccessEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DevicePciPeripheralDataAccessEnabledProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DevicePciPeripheralDataAccessEnabledProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DevicePciPeripheralDataAccessEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePciPeripheralDataAccessEnabledProto.enabled)
  return _internal_enabled();
}
inline void DevicePciPeripheralDataAccessEnabledProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DevicePciPeripheralDataAccessEnabledProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePciPeripheralDataAccessEnabledProto.enabled)
}

// -------------------------------------------------------------------

// DevicePciPeripheralDataAccessEnabledProtoV2

// optional bool enabled = 1;
inline bool DevicePciPeripheralDataAccessEnabledProtoV2::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePciPeripheralDataAccessEnabledProtoV2::has_enabled() const {
  return _internal_has_enabled();
}
inline void DevicePciPeripheralDataAccessEnabledProtoV2::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DevicePciPeripheralDataAccessEnabledProtoV2::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DevicePciPeripheralDataAccessEnabledProtoV2::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2.enabled)
  return _internal_enabled();
}
inline void DevicePciPeripheralDataAccessEnabledProtoV2::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DevicePciPeripheralDataAccessEnabledProtoV2::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2.enabled)
}

// -------------------------------------------------------------------

// OBSOLETE_DeviceBorealisAllowedProto

// optional bool allowed = 1 [default = true];
inline bool OBSOLETE_DeviceBorealisAllowedProto::_internal_has_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_DeviceBorealisAllowedProto::has_allowed() const {
  return _internal_has_allowed();
}
inline void OBSOLETE_DeviceBorealisAllowedProto::clear_allowed() {
  _impl_.allowed_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OBSOLETE_DeviceBorealisAllowedProto::_internal_allowed() const {
  return _impl_.allowed_;
}
inline bool OBSOLETE_DeviceBorealisAllowedProto::allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto.allowed)
  return _internal_allowed();
}
inline void OBSOLETE_DeviceBorealisAllowedProto::_internal_set_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allowed_ = value;
}
inline void OBSOLETE_DeviceBorealisAllowedProto::set_allowed(bool value) {
  _internal_set_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto.allowed)
}

// -------------------------------------------------------------------

// DeviceAllowedBluetoothServicesProto

// repeated string allowlist = 1;
inline int DeviceAllowedBluetoothServicesProto::_internal_allowlist_size() const {
  return _impl_.allowlist_.size();
}
inline int DeviceAllowedBluetoothServicesProto::allowlist_size() const {
  return _internal_allowlist_size();
}
inline void DeviceAllowedBluetoothServicesProto::clear_allowlist() {
  _impl_.allowlist_.Clear();
}
inline std::string* DeviceAllowedBluetoothServicesProto::add_allowlist() {
  std::string* _s = _internal_add_allowlist();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
  return _s;
}
inline const std::string& DeviceAllowedBluetoothServicesProto::_internal_allowlist(int index) const {
  return _impl_.allowlist_.Get(index);
}
inline const std::string& DeviceAllowedBluetoothServicesProto::allowlist(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
  return _internal_allowlist(index);
}
inline std::string* DeviceAllowedBluetoothServicesProto::mutable_allowlist(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
  return _impl_.allowlist_.Mutable(index);
}
inline void DeviceAllowedBluetoothServicesProto::set_allowlist(int index, const std::string& value) {
  _impl_.allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
}
inline void DeviceAllowedBluetoothServicesProto::set_allowlist(int index, std::string&& value) {
  _impl_.allowlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
}
inline void DeviceAllowedBluetoothServicesProto::set_allowlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
}
inline void DeviceAllowedBluetoothServicesProto::set_allowlist(int index, const char* value, size_t size) {
  _impl_.allowlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
}
inline std::string* DeviceAllowedBluetoothServicesProto::_internal_add_allowlist() {
  return _impl_.allowlist_.Add();
}
inline void DeviceAllowedBluetoothServicesProto::add_allowlist(const std::string& value) {
  _impl_.allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
}
inline void DeviceAllowedBluetoothServicesProto::add_allowlist(std::string&& value) {
  _impl_.allowlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
}
inline void DeviceAllowedBluetoothServicesProto::add_allowlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
}
inline void DeviceAllowedBluetoothServicesProto::add_allowlist(const char* value, size_t size) {
  _impl_.allowlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceAllowedBluetoothServicesProto::allowlist() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
  return _impl_.allowlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceAllowedBluetoothServicesProto::mutable_allowlist() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceAllowedBluetoothServicesProto.allowlist)
  return &_impl_.allowlist_;
}

// -------------------------------------------------------------------

// DeviceDebugPacketCaptureAllowedProto

// optional bool allowed = 1;
inline bool DeviceDebugPacketCaptureAllowedProto::_internal_has_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceDebugPacketCaptureAllowedProto::has_allowed() const {
  return _internal_has_allowed();
}
inline void DeviceDebugPacketCaptureAllowedProto::clear_allowed() {
  _impl_.allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceDebugPacketCaptureAllowedProto::_internal_allowed() const {
  return _impl_.allowed_;
}
inline bool DeviceDebugPacketCaptureAllowedProto::allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceDebugPacketCaptureAllowedProto.allowed)
  return _internal_allowed();
}
inline void DeviceDebugPacketCaptureAllowedProto::_internal_set_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allowed_ = value;
}
inline void DeviceDebugPacketCaptureAllowedProto::set_allowed(bool value) {
  _internal_set_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceDebugPacketCaptureAllowedProto.allowed)
}

// -------------------------------------------------------------------

// DeviceScheduledRebootProto

// optional string device_scheduled_reboot_settings = 1;
inline bool DeviceScheduledRebootProto::_internal_has_device_scheduled_reboot_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceScheduledRebootProto::has_device_scheduled_reboot_settings() const {
  return _internal_has_device_scheduled_reboot_settings();
}
inline void DeviceScheduledRebootProto::clear_device_scheduled_reboot_settings() {
  _impl_.device_scheduled_reboot_settings_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceScheduledRebootProto::device_scheduled_reboot_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceScheduledRebootProto.device_scheduled_reboot_settings)
  return _internal_device_scheduled_reboot_settings();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceScheduledRebootProto::set_device_scheduled_reboot_settings(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_scheduled_reboot_settings_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceScheduledRebootProto.device_scheduled_reboot_settings)
}
inline std::string* DeviceScheduledRebootProto::mutable_device_scheduled_reboot_settings() {
  std::string* _s = _internal_mutable_device_scheduled_reboot_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceScheduledRebootProto.device_scheduled_reboot_settings)
  return _s;
}
inline const std::string& DeviceScheduledRebootProto::_internal_device_scheduled_reboot_settings() const {
  return _impl_.device_scheduled_reboot_settings_.Get();
}
inline void DeviceScheduledRebootProto::_internal_set_device_scheduled_reboot_settings(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_scheduled_reboot_settings_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceScheduledRebootProto::_internal_mutable_device_scheduled_reboot_settings() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_scheduled_reboot_settings_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceScheduledRebootProto::release_device_scheduled_reboot_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceScheduledRebootProto.device_scheduled_reboot_settings)
  if (!_internal_has_device_scheduled_reboot_settings()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_scheduled_reboot_settings_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_scheduled_reboot_settings_.IsDefault()) {
    _impl_.device_scheduled_reboot_settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceScheduledRebootProto::set_allocated_device_scheduled_reboot_settings(std::string* device_scheduled_reboot_settings) {
  if (device_scheduled_reboot_settings != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_scheduled_reboot_settings_.SetAllocated(device_scheduled_reboot_settings, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_scheduled_reboot_settings_.IsDefault()) {
    _impl_.device_scheduled_reboot_settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceScheduledRebootProto.device_scheduled_reboot_settings)
}

// -------------------------------------------------------------------

// DeviceRestrictedManagedGuestSessionEnabledProto

// optional bool enabled = 1 [default = false];
inline bool DeviceRestrictedManagedGuestSessionEnabledProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceRestrictedManagedGuestSessionEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceRestrictedManagedGuestSessionEnabledProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceRestrictedManagedGuestSessionEnabledProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceRestrictedManagedGuestSessionEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto.enabled)
  return _internal_enabled();
}
inline void DeviceRestrictedManagedGuestSessionEnabledProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceRestrictedManagedGuestSessionEnabledProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto.enabled)
}

// -------------------------------------------------------------------

// DeviceI18nShortcutsEnabledProto

// optional bool enabled = 1 [default = true];
inline bool DeviceI18nShortcutsEnabledProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceI18nShortcutsEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceI18nShortcutsEnabledProto::clear_enabled() {
  _impl_.enabled_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceI18nShortcutsEnabledProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceI18nShortcutsEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceI18nShortcutsEnabledProto.enabled)
  return _internal_enabled();
}
inline void DeviceI18nShortcutsEnabledProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceI18nShortcutsEnabledProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceI18nShortcutsEnabledProto.enabled)
}

// -------------------------------------------------------------------

// RevenDeviceHWDataUsageEnabledProto

// optional bool hardware_data_usage_enabled = 1 [default = false];
inline bool RevenDeviceHWDataUsageEnabledProto::_internal_has_hardware_data_usage_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RevenDeviceHWDataUsageEnabledProto::has_hardware_data_usage_enabled() const {
  return _internal_has_hardware_data_usage_enabled();
}
inline void RevenDeviceHWDataUsageEnabledProto::clear_hardware_data_usage_enabled() {
  _impl_.hardware_data_usage_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RevenDeviceHWDataUsageEnabledProto::_internal_hardware_data_usage_enabled() const {
  return _impl_.hardware_data_usage_enabled_;
}
inline bool RevenDeviceHWDataUsageEnabledProto::hardware_data_usage_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RevenDeviceHWDataUsageEnabledProto.hardware_data_usage_enabled)
  return _internal_hardware_data_usage_enabled();
}
inline void RevenDeviceHWDataUsageEnabledProto::_internal_set_hardware_data_usage_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hardware_data_usage_enabled_ = value;
}
inline void RevenDeviceHWDataUsageEnabledProto::set_hardware_data_usage_enabled(bool value) {
  _internal_set_hardware_data_usage_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RevenDeviceHWDataUsageEnabledProto.hardware_data_usage_enabled)
}

// -------------------------------------------------------------------

// DeviceLoginScreenWebUILazyLoadingProto

// optional bool enabled = 1 [default = false];
inline bool DeviceLoginScreenWebUILazyLoadingProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceLoginScreenWebUILazyLoadingProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceLoginScreenWebUILazyLoadingProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceLoginScreenWebUILazyLoadingProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceLoginScreenWebUILazyLoadingProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto.enabled)
  return _internal_enabled();
}
inline void DeviceLoginScreenWebUILazyLoadingProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceLoginScreenWebUILazyLoadingProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto.enabled)
}

// -------------------------------------------------------------------

// EncryptedReportingPipelineConfigurationProto

// optional bool enabled = 1 [default = true];
inline bool EncryptedReportingPipelineConfigurationProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EncryptedReportingPipelineConfigurationProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void EncryptedReportingPipelineConfigurationProto::clear_enabled() {
  _impl_.enabled_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EncryptedReportingPipelineConfigurationProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool EncryptedReportingPipelineConfigurationProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.EncryptedReportingPipelineConfigurationProto.enabled)
  return _internal_enabled();
}
inline void EncryptedReportingPipelineConfigurationProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void EncryptedReportingPipelineConfigurationProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.EncryptedReportingPipelineConfigurationProto.enabled)
}

// -------------------------------------------------------------------

// DeviceReportXDREventsProto

// optional bool enabled = 1 [default = false];
inline bool DeviceReportXDREventsProto::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceReportXDREventsProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void DeviceReportXDREventsProto::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceReportXDREventsProto::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool DeviceReportXDREventsProto::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceReportXDREventsProto.enabled)
  return _internal_enabled();
}
inline void DeviceReportXDREventsProto::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void DeviceReportXDREventsProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceReportXDREventsProto.enabled)
}

// -------------------------------------------------------------------

// ChromeDeviceSettingsProto

// optional .enterprise_management.DevicePolicyRefreshRateProto device_policy_refresh_rate = 1;
inline bool ChromeDeviceSettingsProto::_internal_has_device_policy_refresh_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_policy_refresh_rate_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_policy_refresh_rate() const {
  return _internal_has_device_policy_refresh_rate();
}
inline void ChromeDeviceSettingsProto::clear_device_policy_refresh_rate() {
  if (_impl_.device_policy_refresh_rate_ != nullptr) _impl_.device_policy_refresh_rate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::DevicePolicyRefreshRateProto& ChromeDeviceSettingsProto::_internal_device_policy_refresh_rate() const {
  const ::enterprise_management::DevicePolicyRefreshRateProto* p = _impl_.device_policy_refresh_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePolicyRefreshRateProto&>(
      ::enterprise_management::_DevicePolicyRefreshRateProto_default_instance_);
}
inline const ::enterprise_management::DevicePolicyRefreshRateProto& ChromeDeviceSettingsProto::device_policy_refresh_rate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_policy_refresh_rate)
  return _internal_device_policy_refresh_rate();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_policy_refresh_rate(
    ::enterprise_management::DevicePolicyRefreshRateProto* device_policy_refresh_rate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_policy_refresh_rate_);
  }
  _impl_.device_policy_refresh_rate_ = device_policy_refresh_rate;
  if (device_policy_refresh_rate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_policy_refresh_rate)
}
inline ::enterprise_management::DevicePolicyRefreshRateProto* ChromeDeviceSettingsProto::release_device_policy_refresh_rate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DevicePolicyRefreshRateProto* temp = _impl_.device_policy_refresh_rate_;
  _impl_.device_policy_refresh_rate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePolicyRefreshRateProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_policy_refresh_rate() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_policy_refresh_rate)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DevicePolicyRefreshRateProto* temp = _impl_.device_policy_refresh_rate_;
  _impl_.device_policy_refresh_rate_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePolicyRefreshRateProto* ChromeDeviceSettingsProto::_internal_mutable_device_policy_refresh_rate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.device_policy_refresh_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePolicyRefreshRateProto>(GetArenaForAllocation());
    _impl_.device_policy_refresh_rate_ = p;
  }
  return _impl_.device_policy_refresh_rate_;
}
inline ::enterprise_management::DevicePolicyRefreshRateProto* ChromeDeviceSettingsProto::mutable_device_policy_refresh_rate() {
  ::enterprise_management::DevicePolicyRefreshRateProto* _msg = _internal_mutable_device_policy_refresh_rate();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_policy_refresh_rate)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_policy_refresh_rate(::enterprise_management::DevicePolicyRefreshRateProto* device_policy_refresh_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_policy_refresh_rate_;
  }
  if (device_policy_refresh_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_policy_refresh_rate);
    if (message_arena != submessage_arena) {
      device_policy_refresh_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_policy_refresh_rate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_policy_refresh_rate_ = device_policy_refresh_rate;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_policy_refresh_rate)
}

// optional .enterprise_management.UserWhitelistProto user_whitelist = 2;
inline bool ChromeDeviceSettingsProto::_internal_has_user_whitelist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_whitelist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_user_whitelist() const {
  return _internal_has_user_whitelist();
}
inline void ChromeDeviceSettingsProto::clear_user_whitelist() {
  if (_impl_.user_whitelist_ != nullptr) _impl_.user_whitelist_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::UserWhitelistProto& ChromeDeviceSettingsProto::_internal_user_whitelist() const {
  const ::enterprise_management::UserWhitelistProto* p = _impl_.user_whitelist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::UserWhitelistProto&>(
      ::enterprise_management::_UserWhitelistProto_default_instance_);
}
inline const ::enterprise_management::UserWhitelistProto& ChromeDeviceSettingsProto::user_whitelist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.user_whitelist)
  return _internal_user_whitelist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_user_whitelist(
    ::enterprise_management::UserWhitelistProto* user_whitelist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_whitelist_);
  }
  _impl_.user_whitelist_ = user_whitelist;
  if (user_whitelist) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.user_whitelist)
}
inline ::enterprise_management::UserWhitelistProto* ChromeDeviceSettingsProto::release_user_whitelist() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::UserWhitelistProto* temp = _impl_.user_whitelist_;
  _impl_.user_whitelist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::UserWhitelistProto* ChromeDeviceSettingsProto::unsafe_arena_release_user_whitelist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.user_whitelist)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::UserWhitelistProto* temp = _impl_.user_whitelist_;
  _impl_.user_whitelist_ = nullptr;
  return temp;
}
inline ::enterprise_management::UserWhitelistProto* ChromeDeviceSettingsProto::_internal_mutable_user_whitelist() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.user_whitelist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::UserWhitelistProto>(GetArenaForAllocation());
    _impl_.user_whitelist_ = p;
  }
  return _impl_.user_whitelist_;
}
inline ::enterprise_management::UserWhitelistProto* ChromeDeviceSettingsProto::mutable_user_whitelist() {
  ::enterprise_management::UserWhitelistProto* _msg = _internal_mutable_user_whitelist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.user_whitelist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_user_whitelist(::enterprise_management::UserWhitelistProto* user_whitelist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_whitelist_;
  }
  if (user_whitelist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_whitelist);
    if (message_arena != submessage_arena) {
      user_whitelist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_whitelist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.user_whitelist_ = user_whitelist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.user_whitelist)
}

// optional .enterprise_management.GuestModeEnabledProto guest_mode_enabled = 3;
inline bool ChromeDeviceSettingsProto::_internal_has_guest_mode_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.guest_mode_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_guest_mode_enabled() const {
  return _internal_has_guest_mode_enabled();
}
inline void ChromeDeviceSettingsProto::clear_guest_mode_enabled() {
  if (_impl_.guest_mode_enabled_ != nullptr) _impl_.guest_mode_enabled_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::GuestModeEnabledProto& ChromeDeviceSettingsProto::_internal_guest_mode_enabled() const {
  const ::enterprise_management::GuestModeEnabledProto* p = _impl_.guest_mode_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::GuestModeEnabledProto&>(
      ::enterprise_management::_GuestModeEnabledProto_default_instance_);
}
inline const ::enterprise_management::GuestModeEnabledProto& ChromeDeviceSettingsProto::guest_mode_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.guest_mode_enabled)
  return _internal_guest_mode_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_guest_mode_enabled(
    ::enterprise_management::GuestModeEnabledProto* guest_mode_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.guest_mode_enabled_);
  }
  _impl_.guest_mode_enabled_ = guest_mode_enabled;
  if (guest_mode_enabled) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.guest_mode_enabled)
}
inline ::enterprise_management::GuestModeEnabledProto* ChromeDeviceSettingsProto::release_guest_mode_enabled() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::GuestModeEnabledProto* temp = _impl_.guest_mode_enabled_;
  _impl_.guest_mode_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::GuestModeEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_guest_mode_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.guest_mode_enabled)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::GuestModeEnabledProto* temp = _impl_.guest_mode_enabled_;
  _impl_.guest_mode_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::GuestModeEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_guest_mode_enabled() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.guest_mode_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::GuestModeEnabledProto>(GetArenaForAllocation());
    _impl_.guest_mode_enabled_ = p;
  }
  return _impl_.guest_mode_enabled_;
}
inline ::enterprise_management::GuestModeEnabledProto* ChromeDeviceSettingsProto::mutable_guest_mode_enabled() {
  ::enterprise_management::GuestModeEnabledProto* _msg = _internal_mutable_guest_mode_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.guest_mode_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_guest_mode_enabled(::enterprise_management::GuestModeEnabledProto* guest_mode_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.guest_mode_enabled_;
  }
  if (guest_mode_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(guest_mode_enabled);
    if (message_arena != submessage_arena) {
      guest_mode_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, guest_mode_enabled, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.guest_mode_enabled_ = guest_mode_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.guest_mode_enabled)
}

// optional .enterprise_management.OBSOLETE_DeviceProxySettingsProto device_proxy_settings = 4 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_device_proxy_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_proxy_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_proxy_settings() const {
  return _internal_has_device_proxy_settings();
}
inline void ChromeDeviceSettingsProto::clear_device_proxy_settings() {
  if (_impl_.device_proxy_settings_ != nullptr) _impl_.device_proxy_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::OBSOLETE_DeviceProxySettingsProto& ChromeDeviceSettingsProto::_internal_device_proxy_settings() const {
  const ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* p = _impl_.device_proxy_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_DeviceProxySettingsProto&>(
      ::enterprise_management::_OBSOLETE_DeviceProxySettingsProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_DeviceProxySettingsProto& ChromeDeviceSettingsProto::device_proxy_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_proxy_settings)
  return _internal_device_proxy_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_proxy_settings(
    ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* device_proxy_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_proxy_settings_);
  }
  _impl_.device_proxy_settings_ = device_proxy_settings;
  if (device_proxy_settings) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_proxy_settings)
}
inline ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* ChromeDeviceSettingsProto::release_device_proxy_settings() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* temp = _impl_.device_proxy_settings_;
  _impl_.device_proxy_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_proxy_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_proxy_settings)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* temp = _impl_.device_proxy_settings_;
  _impl_.device_proxy_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* ChromeDeviceSettingsProto::_internal_mutable_device_proxy_settings() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.device_proxy_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_DeviceProxySettingsProto>(GetArenaForAllocation());
    _impl_.device_proxy_settings_ = p;
  }
  return _impl_.device_proxy_settings_;
}
inline ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* ChromeDeviceSettingsProto::mutable_device_proxy_settings() {
  ::enterprise_management::OBSOLETE_DeviceProxySettingsProto* _msg = _internal_mutable_device_proxy_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_proxy_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_proxy_settings(::enterprise_management::OBSOLETE_DeviceProxySettingsProto* device_proxy_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_proxy_settings_;
  }
  if (device_proxy_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_proxy_settings);
    if (message_arena != submessage_arena) {
      device_proxy_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_proxy_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.device_proxy_settings_ = device_proxy_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_proxy_settings)
}

// optional .enterprise_management.CameraEnabledProto camera_enabled = 5;
inline bool ChromeDeviceSettingsProto::_internal_has_camera_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_camera_enabled() const {
  return _internal_has_camera_enabled();
}
inline void ChromeDeviceSettingsProto::clear_camera_enabled() {
  if (_impl_.camera_enabled_ != nullptr) _impl_.camera_enabled_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::CameraEnabledProto& ChromeDeviceSettingsProto::_internal_camera_enabled() const {
  const ::enterprise_management::CameraEnabledProto* p = _impl_.camera_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CameraEnabledProto&>(
      ::enterprise_management::_CameraEnabledProto_default_instance_);
}
inline const ::enterprise_management::CameraEnabledProto& ChromeDeviceSettingsProto::camera_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.camera_enabled)
  return _internal_camera_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_camera_enabled(
    ::enterprise_management::CameraEnabledProto* camera_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_enabled_);
  }
  _impl_.camera_enabled_ = camera_enabled;
  if (camera_enabled) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.camera_enabled)
}
inline ::enterprise_management::CameraEnabledProto* ChromeDeviceSettingsProto::release_camera_enabled() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::CameraEnabledProto* temp = _impl_.camera_enabled_;
  _impl_.camera_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CameraEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_camera_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.camera_enabled)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::CameraEnabledProto* temp = _impl_.camera_enabled_;
  _impl_.camera_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::CameraEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_camera_enabled() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.camera_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CameraEnabledProto>(GetArenaForAllocation());
    _impl_.camera_enabled_ = p;
  }
  return _impl_.camera_enabled_;
}
inline ::enterprise_management::CameraEnabledProto* ChromeDeviceSettingsProto::mutable_camera_enabled() {
  ::enterprise_management::CameraEnabledProto* _msg = _internal_mutable_camera_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.camera_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_camera_enabled(::enterprise_management::CameraEnabledProto* camera_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_enabled_;
  }
  if (camera_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_enabled);
    if (message_arena != submessage_arena) {
      camera_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_enabled, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.camera_enabled_ = camera_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.camera_enabled)
}

// optional .enterprise_management.ShowUserNamesOnSigninProto show_user_names = 6;
inline bool ChromeDeviceSettingsProto::_internal_has_show_user_names() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.show_user_names_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_show_user_names() const {
  return _internal_has_show_user_names();
}
inline void ChromeDeviceSettingsProto::clear_show_user_names() {
  if (_impl_.show_user_names_ != nullptr) _impl_.show_user_names_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_management::ShowUserNamesOnSigninProto& ChromeDeviceSettingsProto::_internal_show_user_names() const {
  const ::enterprise_management::ShowUserNamesOnSigninProto* p = _impl_.show_user_names_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ShowUserNamesOnSigninProto&>(
      ::enterprise_management::_ShowUserNamesOnSigninProto_default_instance_);
}
inline const ::enterprise_management::ShowUserNamesOnSigninProto& ChromeDeviceSettingsProto::show_user_names() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.show_user_names)
  return _internal_show_user_names();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_show_user_names(
    ::enterprise_management::ShowUserNamesOnSigninProto* show_user_names) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.show_user_names_);
  }
  _impl_.show_user_names_ = show_user_names;
  if (show_user_names) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.show_user_names)
}
inline ::enterprise_management::ShowUserNamesOnSigninProto* ChromeDeviceSettingsProto::release_show_user_names() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::ShowUserNamesOnSigninProto* temp = _impl_.show_user_names_;
  _impl_.show_user_names_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ShowUserNamesOnSigninProto* ChromeDeviceSettingsProto::unsafe_arena_release_show_user_names() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.show_user_names)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::ShowUserNamesOnSigninProto* temp = _impl_.show_user_names_;
  _impl_.show_user_names_ = nullptr;
  return temp;
}
inline ::enterprise_management::ShowUserNamesOnSigninProto* ChromeDeviceSettingsProto::_internal_mutable_show_user_names() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.show_user_names_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ShowUserNamesOnSigninProto>(GetArenaForAllocation());
    _impl_.show_user_names_ = p;
  }
  return _impl_.show_user_names_;
}
inline ::enterprise_management::ShowUserNamesOnSigninProto* ChromeDeviceSettingsProto::mutable_show_user_names() {
  ::enterprise_management::ShowUserNamesOnSigninProto* _msg = _internal_mutable_show_user_names();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.show_user_names)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_show_user_names(::enterprise_management::ShowUserNamesOnSigninProto* show_user_names) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.show_user_names_;
  }
  if (show_user_names) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_user_names);
    if (message_arena != submessage_arena) {
      show_user_names = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_user_names, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.show_user_names_ = show_user_names;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.show_user_names)
}

// optional .enterprise_management.DataRoamingEnabledProto data_roaming_enabled = 7;
inline bool ChromeDeviceSettingsProto::_internal_has_data_roaming_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_roaming_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_data_roaming_enabled() const {
  return _internal_has_data_roaming_enabled();
}
inline void ChromeDeviceSettingsProto::clear_data_roaming_enabled() {
  if (_impl_.data_roaming_enabled_ != nullptr) _impl_.data_roaming_enabled_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::DataRoamingEnabledProto& ChromeDeviceSettingsProto::_internal_data_roaming_enabled() const {
  const ::enterprise_management::DataRoamingEnabledProto* p = _impl_.data_roaming_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DataRoamingEnabledProto&>(
      ::enterprise_management::_DataRoamingEnabledProto_default_instance_);
}
inline const ::enterprise_management::DataRoamingEnabledProto& ChromeDeviceSettingsProto::data_roaming_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.data_roaming_enabled)
  return _internal_data_roaming_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_data_roaming_enabled(
    ::enterprise_management::DataRoamingEnabledProto* data_roaming_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_roaming_enabled_);
  }
  _impl_.data_roaming_enabled_ = data_roaming_enabled;
  if (data_roaming_enabled) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.data_roaming_enabled)
}
inline ::enterprise_management::DataRoamingEnabledProto* ChromeDeviceSettingsProto::release_data_roaming_enabled() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::DataRoamingEnabledProto* temp = _impl_.data_roaming_enabled_;
  _impl_.data_roaming_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DataRoamingEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_data_roaming_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.data_roaming_enabled)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::DataRoamingEnabledProto* temp = _impl_.data_roaming_enabled_;
  _impl_.data_roaming_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DataRoamingEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_data_roaming_enabled() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.data_roaming_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DataRoamingEnabledProto>(GetArenaForAllocation());
    _impl_.data_roaming_enabled_ = p;
  }
  return _impl_.data_roaming_enabled_;
}
inline ::enterprise_management::DataRoamingEnabledProto* ChromeDeviceSettingsProto::mutable_data_roaming_enabled() {
  ::enterprise_management::DataRoamingEnabledProto* _msg = _internal_mutable_data_roaming_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.data_roaming_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_data_roaming_enabled(::enterprise_management::DataRoamingEnabledProto* data_roaming_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_roaming_enabled_;
  }
  if (data_roaming_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_roaming_enabled);
    if (message_arena != submessage_arena) {
      data_roaming_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_roaming_enabled, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.data_roaming_enabled_ = data_roaming_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.data_roaming_enabled)
}

// optional .enterprise_management.AllowNewUsersProto allow_new_users = 8;
inline bool ChromeDeviceSettingsProto::_internal_has_allow_new_users() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.allow_new_users_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_allow_new_users() const {
  return _internal_has_allow_new_users();
}
inline void ChromeDeviceSettingsProto::clear_allow_new_users() {
  if (_impl_.allow_new_users_ != nullptr) _impl_.allow_new_users_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::enterprise_management::AllowNewUsersProto& ChromeDeviceSettingsProto::_internal_allow_new_users() const {
  const ::enterprise_management::AllowNewUsersProto* p = _impl_.allow_new_users_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AllowNewUsersProto&>(
      ::enterprise_management::_AllowNewUsersProto_default_instance_);
}
inline const ::enterprise_management::AllowNewUsersProto& ChromeDeviceSettingsProto::allow_new_users() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.allow_new_users)
  return _internal_allow_new_users();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_allow_new_users(
    ::enterprise_management::AllowNewUsersProto* allow_new_users) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allow_new_users_);
  }
  _impl_.allow_new_users_ = allow_new_users;
  if (allow_new_users) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.allow_new_users)
}
inline ::enterprise_management::AllowNewUsersProto* ChromeDeviceSettingsProto::release_allow_new_users() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::AllowNewUsersProto* temp = _impl_.allow_new_users_;
  _impl_.allow_new_users_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AllowNewUsersProto* ChromeDeviceSettingsProto::unsafe_arena_release_allow_new_users() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.allow_new_users)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::AllowNewUsersProto* temp = _impl_.allow_new_users_;
  _impl_.allow_new_users_ = nullptr;
  return temp;
}
inline ::enterprise_management::AllowNewUsersProto* ChromeDeviceSettingsProto::_internal_mutable_allow_new_users() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.allow_new_users_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AllowNewUsersProto>(GetArenaForAllocation());
    _impl_.allow_new_users_ = p;
  }
  return _impl_.allow_new_users_;
}
inline ::enterprise_management::AllowNewUsersProto* ChromeDeviceSettingsProto::mutable_allow_new_users() {
  ::enterprise_management::AllowNewUsersProto* _msg = _internal_mutable_allow_new_users();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.allow_new_users)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_allow_new_users(::enterprise_management::AllowNewUsersProto* allow_new_users) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allow_new_users_;
  }
  if (allow_new_users) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allow_new_users);
    if (message_arena != submessage_arena) {
      allow_new_users = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allow_new_users, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.allow_new_users_ = allow_new_users;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.allow_new_users)
}

// optional .enterprise_management.MetricsEnabledProto metrics_enabled = 9;
inline bool ChromeDeviceSettingsProto::_internal_has_metrics_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metrics_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_metrics_enabled() const {
  return _internal_has_metrics_enabled();
}
inline void ChromeDeviceSettingsProto::clear_metrics_enabled() {
  if (_impl_.metrics_enabled_ != nullptr) _impl_.metrics_enabled_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::enterprise_management::MetricsEnabledProto& ChromeDeviceSettingsProto::_internal_metrics_enabled() const {
  const ::enterprise_management::MetricsEnabledProto* p = _impl_.metrics_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::MetricsEnabledProto&>(
      ::enterprise_management::_MetricsEnabledProto_default_instance_);
}
inline const ::enterprise_management::MetricsEnabledProto& ChromeDeviceSettingsProto::metrics_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.metrics_enabled)
  return _internal_metrics_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_metrics_enabled(
    ::enterprise_management::MetricsEnabledProto* metrics_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metrics_enabled_);
  }
  _impl_.metrics_enabled_ = metrics_enabled;
  if (metrics_enabled) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.metrics_enabled)
}
inline ::enterprise_management::MetricsEnabledProto* ChromeDeviceSettingsProto::release_metrics_enabled() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::MetricsEnabledProto* temp = _impl_.metrics_enabled_;
  _impl_.metrics_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::MetricsEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_metrics_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.metrics_enabled)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::MetricsEnabledProto* temp = _impl_.metrics_enabled_;
  _impl_.metrics_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::MetricsEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_metrics_enabled() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.metrics_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::MetricsEnabledProto>(GetArenaForAllocation());
    _impl_.metrics_enabled_ = p;
  }
  return _impl_.metrics_enabled_;
}
inline ::enterprise_management::MetricsEnabledProto* ChromeDeviceSettingsProto::mutable_metrics_enabled() {
  ::enterprise_management::MetricsEnabledProto* _msg = _internal_mutable_metrics_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.metrics_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_metrics_enabled(::enterprise_management::MetricsEnabledProto* metrics_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metrics_enabled_;
  }
  if (metrics_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metrics_enabled);
    if (message_arena != submessage_arena) {
      metrics_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics_enabled, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.metrics_enabled_ = metrics_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.metrics_enabled)
}

// optional .enterprise_management.ReleaseChannelProto release_channel = 10;
inline bool ChromeDeviceSettingsProto::_internal_has_release_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.release_channel_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_release_channel() const {
  return _internal_has_release_channel();
}
inline void ChromeDeviceSettingsProto::clear_release_channel() {
  if (_impl_.release_channel_ != nullptr) _impl_.release_channel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::enterprise_management::ReleaseChannelProto& ChromeDeviceSettingsProto::_internal_release_channel() const {
  const ::enterprise_management::ReleaseChannelProto* p = _impl_.release_channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ReleaseChannelProto&>(
      ::enterprise_management::_ReleaseChannelProto_default_instance_);
}
inline const ::enterprise_management::ReleaseChannelProto& ChromeDeviceSettingsProto::release_channel() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.release_channel)
  return _internal_release_channel();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_release_channel(
    ::enterprise_management::ReleaseChannelProto* release_channel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.release_channel_);
  }
  _impl_.release_channel_ = release_channel;
  if (release_channel) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.release_channel)
}
inline ::enterprise_management::ReleaseChannelProto* ChromeDeviceSettingsProto::release_release_channel() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::ReleaseChannelProto* temp = _impl_.release_channel_;
  _impl_.release_channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ReleaseChannelProto* ChromeDeviceSettingsProto::unsafe_arena_release_release_channel() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.release_channel)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::ReleaseChannelProto* temp = _impl_.release_channel_;
  _impl_.release_channel_ = nullptr;
  return temp;
}
inline ::enterprise_management::ReleaseChannelProto* ChromeDeviceSettingsProto::_internal_mutable_release_channel() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.release_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ReleaseChannelProto>(GetArenaForAllocation());
    _impl_.release_channel_ = p;
  }
  return _impl_.release_channel_;
}
inline ::enterprise_management::ReleaseChannelProto* ChromeDeviceSettingsProto::mutable_release_channel() {
  ::enterprise_management::ReleaseChannelProto* _msg = _internal_mutable_release_channel();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.release_channel)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_release_channel(::enterprise_management::ReleaseChannelProto* release_channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.release_channel_;
  }
  if (release_channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(release_channel);
    if (message_arena != submessage_arena) {
      release_channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, release_channel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.release_channel_ = release_channel;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.release_channel)
}

// optional .enterprise_management.DeviceOpenNetworkConfigurationProto open_network_configuration = 11;
inline bool ChromeDeviceSettingsProto::_internal_has_open_network_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.open_network_configuration_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_open_network_configuration() const {
  return _internal_has_open_network_configuration();
}
inline void ChromeDeviceSettingsProto::clear_open_network_configuration() {
  if (_impl_.open_network_configuration_ != nullptr) _impl_.open_network_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::DeviceOpenNetworkConfigurationProto& ChromeDeviceSettingsProto::_internal_open_network_configuration() const {
  const ::enterprise_management::DeviceOpenNetworkConfigurationProto* p = _impl_.open_network_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceOpenNetworkConfigurationProto&>(
      ::enterprise_management::_DeviceOpenNetworkConfigurationProto_default_instance_);
}
inline const ::enterprise_management::DeviceOpenNetworkConfigurationProto& ChromeDeviceSettingsProto::open_network_configuration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.open_network_configuration)
  return _internal_open_network_configuration();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_open_network_configuration(
    ::enterprise_management::DeviceOpenNetworkConfigurationProto* open_network_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.open_network_configuration_);
  }
  _impl_.open_network_configuration_ = open_network_configuration;
  if (open_network_configuration) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.open_network_configuration)
}
inline ::enterprise_management::DeviceOpenNetworkConfigurationProto* ChromeDeviceSettingsProto::release_open_network_configuration() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::DeviceOpenNetworkConfigurationProto* temp = _impl_.open_network_configuration_;
  _impl_.open_network_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceOpenNetworkConfigurationProto* ChromeDeviceSettingsProto::unsafe_arena_release_open_network_configuration() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.open_network_configuration)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::DeviceOpenNetworkConfigurationProto* temp = _impl_.open_network_configuration_;
  _impl_.open_network_configuration_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceOpenNetworkConfigurationProto* ChromeDeviceSettingsProto::_internal_mutable_open_network_configuration() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.open_network_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceOpenNetworkConfigurationProto>(GetArenaForAllocation());
    _impl_.open_network_configuration_ = p;
  }
  return _impl_.open_network_configuration_;
}
inline ::enterprise_management::DeviceOpenNetworkConfigurationProto* ChromeDeviceSettingsProto::mutable_open_network_configuration() {
  ::enterprise_management::DeviceOpenNetworkConfigurationProto* _msg = _internal_mutable_open_network_configuration();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.open_network_configuration)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_open_network_configuration(::enterprise_management::DeviceOpenNetworkConfigurationProto* open_network_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.open_network_configuration_;
  }
  if (open_network_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(open_network_configuration);
    if (message_arena != submessage_arena) {
      open_network_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, open_network_configuration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.open_network_configuration_ = open_network_configuration;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.open_network_configuration)
}

// optional .enterprise_management.DeviceReportingProto device_reporting = 12;
inline bool ChromeDeviceSettingsProto::_internal_has_device_reporting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_reporting_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_reporting() const {
  return _internal_has_device_reporting();
}
inline void ChromeDeviceSettingsProto::clear_device_reporting() {
  if (_impl_.device_reporting_ != nullptr) _impl_.device_reporting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::DeviceReportingProto& ChromeDeviceSettingsProto::_internal_device_reporting() const {
  const ::enterprise_management::DeviceReportingProto* p = _impl_.device_reporting_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceReportingProto&>(
      ::enterprise_management::_DeviceReportingProto_default_instance_);
}
inline const ::enterprise_management::DeviceReportingProto& ChromeDeviceSettingsProto::device_reporting() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_reporting)
  return _internal_device_reporting();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_reporting(
    ::enterprise_management::DeviceReportingProto* device_reporting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_reporting_);
  }
  _impl_.device_reporting_ = device_reporting;
  if (device_reporting) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_reporting)
}
inline ::enterprise_management::DeviceReportingProto* ChromeDeviceSettingsProto::release_device_reporting() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::DeviceReportingProto* temp = _impl_.device_reporting_;
  _impl_.device_reporting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceReportingProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_reporting() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_reporting)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::DeviceReportingProto* temp = _impl_.device_reporting_;
  _impl_.device_reporting_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceReportingProto* ChromeDeviceSettingsProto::_internal_mutable_device_reporting() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.device_reporting_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceReportingProto>(GetArenaForAllocation());
    _impl_.device_reporting_ = p;
  }
  return _impl_.device_reporting_;
}
inline ::enterprise_management::DeviceReportingProto* ChromeDeviceSettingsProto::mutable_device_reporting() {
  ::enterprise_management::DeviceReportingProto* _msg = _internal_mutable_device_reporting();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_reporting)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_reporting(::enterprise_management::DeviceReportingProto* device_reporting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_reporting_;
  }
  if (device_reporting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_reporting);
    if (message_arena != submessage_arena) {
      device_reporting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_reporting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.device_reporting_ = device_reporting;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_reporting)
}

// optional .enterprise_management.EphemeralUsersEnabledProto ephemeral_users_enabled = 13;
inline bool ChromeDeviceSettingsProto::_internal_has_ephemeral_users_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ephemeral_users_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_ephemeral_users_enabled() const {
  return _internal_has_ephemeral_users_enabled();
}
inline void ChromeDeviceSettingsProto::clear_ephemeral_users_enabled() {
  if (_impl_.ephemeral_users_enabled_ != nullptr) _impl_.ephemeral_users_enabled_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::enterprise_management::EphemeralUsersEnabledProto& ChromeDeviceSettingsProto::_internal_ephemeral_users_enabled() const {
  const ::enterprise_management::EphemeralUsersEnabledProto* p = _impl_.ephemeral_users_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::EphemeralUsersEnabledProto&>(
      ::enterprise_management::_EphemeralUsersEnabledProto_default_instance_);
}
inline const ::enterprise_management::EphemeralUsersEnabledProto& ChromeDeviceSettingsProto::ephemeral_users_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.ephemeral_users_enabled)
  return _internal_ephemeral_users_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_ephemeral_users_enabled(
    ::enterprise_management::EphemeralUsersEnabledProto* ephemeral_users_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ephemeral_users_enabled_);
  }
  _impl_.ephemeral_users_enabled_ = ephemeral_users_enabled;
  if (ephemeral_users_enabled) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.ephemeral_users_enabled)
}
inline ::enterprise_management::EphemeralUsersEnabledProto* ChromeDeviceSettingsProto::release_ephemeral_users_enabled() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::EphemeralUsersEnabledProto* temp = _impl_.ephemeral_users_enabled_;
  _impl_.ephemeral_users_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::EphemeralUsersEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_ephemeral_users_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.ephemeral_users_enabled)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::EphemeralUsersEnabledProto* temp = _impl_.ephemeral_users_enabled_;
  _impl_.ephemeral_users_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::EphemeralUsersEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_ephemeral_users_enabled() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.ephemeral_users_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::EphemeralUsersEnabledProto>(GetArenaForAllocation());
    _impl_.ephemeral_users_enabled_ = p;
  }
  return _impl_.ephemeral_users_enabled_;
}
inline ::enterprise_management::EphemeralUsersEnabledProto* ChromeDeviceSettingsProto::mutable_ephemeral_users_enabled() {
  ::enterprise_management::EphemeralUsersEnabledProto* _msg = _internal_mutable_ephemeral_users_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.ephemeral_users_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_ephemeral_users_enabled(::enterprise_management::EphemeralUsersEnabledProto* ephemeral_users_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ephemeral_users_enabled_;
  }
  if (ephemeral_users_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ephemeral_users_enabled);
    if (message_arena != submessage_arena) {
      ephemeral_users_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ephemeral_users_enabled, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.ephemeral_users_enabled_ = ephemeral_users_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.ephemeral_users_enabled)
}

// optional .enterprise_management.OBSOLETE_AppPackProto app_pack = 14 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_app_pack() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_pack_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_app_pack() const {
  return _internal_has_app_pack();
}
inline void ChromeDeviceSettingsProto::clear_app_pack() {
  if (_impl_.app_pack_ != nullptr) _impl_.app_pack_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::enterprise_management::OBSOLETE_AppPackProto& ChromeDeviceSettingsProto::_internal_app_pack() const {
  const ::enterprise_management::OBSOLETE_AppPackProto* p = _impl_.app_pack_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_AppPackProto&>(
      ::enterprise_management::_OBSOLETE_AppPackProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_AppPackProto& ChromeDeviceSettingsProto::app_pack() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.app_pack)
  return _internal_app_pack();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_app_pack(
    ::enterprise_management::OBSOLETE_AppPackProto* app_pack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_pack_);
  }
  _impl_.app_pack_ = app_pack;
  if (app_pack) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.app_pack)
}
inline ::enterprise_management::OBSOLETE_AppPackProto* ChromeDeviceSettingsProto::release_app_pack() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::OBSOLETE_AppPackProto* temp = _impl_.app_pack_;
  _impl_.app_pack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_AppPackProto* ChromeDeviceSettingsProto::unsafe_arena_release_app_pack() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.app_pack)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::OBSOLETE_AppPackProto* temp = _impl_.app_pack_;
  _impl_.app_pack_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_AppPackProto* ChromeDeviceSettingsProto::_internal_mutable_app_pack() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.app_pack_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_AppPackProto>(GetArenaForAllocation());
    _impl_.app_pack_ = p;
  }
  return _impl_.app_pack_;
}
inline ::enterprise_management::OBSOLETE_AppPackProto* ChromeDeviceSettingsProto::mutable_app_pack() {
  ::enterprise_management::OBSOLETE_AppPackProto* _msg = _internal_mutable_app_pack();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.app_pack)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_app_pack(::enterprise_management::OBSOLETE_AppPackProto* app_pack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_pack_;
  }
  if (app_pack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_pack);
    if (message_arena != submessage_arena) {
      app_pack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_pack, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.app_pack_ = app_pack;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.app_pack)
}

// optional .enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto forced_logout_timeouts = 15 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_forced_logout_timeouts() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forced_logout_timeouts_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_forced_logout_timeouts() const {
  return _internal_has_forced_logout_timeouts();
}
inline void ChromeDeviceSettingsProto::clear_forced_logout_timeouts() {
  if (_impl_.forced_logout_timeouts_ != nullptr) _impl_.forced_logout_timeouts_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto& ChromeDeviceSettingsProto::_internal_forced_logout_timeouts() const {
  const ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* p = _impl_.forced_logout_timeouts_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto&>(
      ::enterprise_management::_OBSOLETE_ForcedLogoutTimeoutsProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto& ChromeDeviceSettingsProto::forced_logout_timeouts() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.forced_logout_timeouts)
  return _internal_forced_logout_timeouts();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_forced_logout_timeouts(
    ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* forced_logout_timeouts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.forced_logout_timeouts_);
  }
  _impl_.forced_logout_timeouts_ = forced_logout_timeouts;
  if (forced_logout_timeouts) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.forced_logout_timeouts)
}
inline ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* ChromeDeviceSettingsProto::release_forced_logout_timeouts() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* temp = _impl_.forced_logout_timeouts_;
  _impl_.forced_logout_timeouts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* ChromeDeviceSettingsProto::unsafe_arena_release_forced_logout_timeouts() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.forced_logout_timeouts)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* temp = _impl_.forced_logout_timeouts_;
  _impl_.forced_logout_timeouts_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* ChromeDeviceSettingsProto::_internal_mutable_forced_logout_timeouts() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.forced_logout_timeouts_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto>(GetArenaForAllocation());
    _impl_.forced_logout_timeouts_ = p;
  }
  return _impl_.forced_logout_timeouts_;
}
inline ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* ChromeDeviceSettingsProto::mutable_forced_logout_timeouts() {
  ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* _msg = _internal_mutable_forced_logout_timeouts();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.forced_logout_timeouts)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_forced_logout_timeouts(::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto* forced_logout_timeouts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.forced_logout_timeouts_;
  }
  if (forced_logout_timeouts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forced_logout_timeouts);
    if (message_arena != submessage_arena) {
      forced_logout_timeouts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forced_logout_timeouts, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.forced_logout_timeouts_ = forced_logout_timeouts;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.forced_logout_timeouts)
}

// optional .enterprise_management.OBSOLETE_ScreenSaverProto login_screen_saver = 16 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_login_screen_saver() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_saver_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_screen_saver() const {
  return _internal_has_login_screen_saver();
}
inline void ChromeDeviceSettingsProto::clear_login_screen_saver() {
  if (_impl_.login_screen_saver_ != nullptr) _impl_.login_screen_saver_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::enterprise_management::OBSOLETE_ScreenSaverProto& ChromeDeviceSettingsProto::_internal_login_screen_saver() const {
  const ::enterprise_management::OBSOLETE_ScreenSaverProto* p = _impl_.login_screen_saver_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_ScreenSaverProto&>(
      ::enterprise_management::_OBSOLETE_ScreenSaverProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_ScreenSaverProto& ChromeDeviceSettingsProto::login_screen_saver() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_screen_saver)
  return _internal_login_screen_saver();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_screen_saver(
    ::enterprise_management::OBSOLETE_ScreenSaverProto* login_screen_saver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_saver_);
  }
  _impl_.login_screen_saver_ = login_screen_saver;
  if (login_screen_saver) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_saver)
}
inline ::enterprise_management::OBSOLETE_ScreenSaverProto* ChromeDeviceSettingsProto::release_login_screen_saver() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::enterprise_management::OBSOLETE_ScreenSaverProto* temp = _impl_.login_screen_saver_;
  _impl_.login_screen_saver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_ScreenSaverProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_screen_saver() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_screen_saver)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::enterprise_management::OBSOLETE_ScreenSaverProto* temp = _impl_.login_screen_saver_;
  _impl_.login_screen_saver_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_ScreenSaverProto* ChromeDeviceSettingsProto::_internal_mutable_login_screen_saver() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.login_screen_saver_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_ScreenSaverProto>(GetArenaForAllocation());
    _impl_.login_screen_saver_ = p;
  }
  return _impl_.login_screen_saver_;
}
inline ::enterprise_management::OBSOLETE_ScreenSaverProto* ChromeDeviceSettingsProto::mutable_login_screen_saver() {
  ::enterprise_management::OBSOLETE_ScreenSaverProto* _msg = _internal_mutable_login_screen_saver();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_screen_saver)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_screen_saver(::enterprise_management::OBSOLETE_ScreenSaverProto* login_screen_saver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_screen_saver_;
  }
  if (login_screen_saver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_screen_saver);
    if (message_arena != submessage_arena) {
      login_screen_saver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_saver, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.login_screen_saver_ = login_screen_saver;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_saver)
}

// optional .enterprise_management.AutoUpdateSettingsProto auto_update_settings = 17;
inline bool ChromeDeviceSettingsProto::_internal_has_auto_update_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auto_update_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_auto_update_settings() const {
  return _internal_has_auto_update_settings();
}
inline void ChromeDeviceSettingsProto::clear_auto_update_settings() {
  if (_impl_.auto_update_settings_ != nullptr) _impl_.auto_update_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::enterprise_management::AutoUpdateSettingsProto& ChromeDeviceSettingsProto::_internal_auto_update_settings() const {
  const ::enterprise_management::AutoUpdateSettingsProto* p = _impl_.auto_update_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AutoUpdateSettingsProto&>(
      ::enterprise_management::_AutoUpdateSettingsProto_default_instance_);
}
inline const ::enterprise_management::AutoUpdateSettingsProto& ChromeDeviceSettingsProto::auto_update_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.auto_update_settings)
  return _internal_auto_update_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_auto_update_settings(
    ::enterprise_management::AutoUpdateSettingsProto* auto_update_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auto_update_settings_);
  }
  _impl_.auto_update_settings_ = auto_update_settings;
  if (auto_update_settings) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.auto_update_settings)
}
inline ::enterprise_management::AutoUpdateSettingsProto* ChromeDeviceSettingsProto::release_auto_update_settings() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::enterprise_management::AutoUpdateSettingsProto* temp = _impl_.auto_update_settings_;
  _impl_.auto_update_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AutoUpdateSettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_auto_update_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.auto_update_settings)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::enterprise_management::AutoUpdateSettingsProto* temp = _impl_.auto_update_settings_;
  _impl_.auto_update_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::AutoUpdateSettingsProto* ChromeDeviceSettingsProto::_internal_mutable_auto_update_settings() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.auto_update_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AutoUpdateSettingsProto>(GetArenaForAllocation());
    _impl_.auto_update_settings_ = p;
  }
  return _impl_.auto_update_settings_;
}
inline ::enterprise_management::AutoUpdateSettingsProto* ChromeDeviceSettingsProto::mutable_auto_update_settings() {
  ::enterprise_management::AutoUpdateSettingsProto* _msg = _internal_mutable_auto_update_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.auto_update_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_auto_update_settings(::enterprise_management::AutoUpdateSettingsProto* auto_update_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auto_update_settings_;
  }
  if (auto_update_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_update_settings);
    if (message_arena != submessage_arena) {
      auto_update_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_update_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.auto_update_settings_ = auto_update_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.auto_update_settings)
}

// optional .enterprise_management.OBSOLETE_StartUpUrlsProto start_up_urls = 18 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_start_up_urls() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_up_urls_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_start_up_urls() const {
  return _internal_has_start_up_urls();
}
inline void ChromeDeviceSettingsProto::clear_start_up_urls() {
  if (_impl_.start_up_urls_ != nullptr) _impl_.start_up_urls_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::enterprise_management::OBSOLETE_StartUpUrlsProto& ChromeDeviceSettingsProto::_internal_start_up_urls() const {
  const ::enterprise_management::OBSOLETE_StartUpUrlsProto* p = _impl_.start_up_urls_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_StartUpUrlsProto&>(
      ::enterprise_management::_OBSOLETE_StartUpUrlsProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_StartUpUrlsProto& ChromeDeviceSettingsProto::start_up_urls() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.start_up_urls)
  return _internal_start_up_urls();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_start_up_urls(
    ::enterprise_management::OBSOLETE_StartUpUrlsProto* start_up_urls) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_up_urls_);
  }
  _impl_.start_up_urls_ = start_up_urls;
  if (start_up_urls) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.start_up_urls)
}
inline ::enterprise_management::OBSOLETE_StartUpUrlsProto* ChromeDeviceSettingsProto::release_start_up_urls() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::enterprise_management::OBSOLETE_StartUpUrlsProto* temp = _impl_.start_up_urls_;
  _impl_.start_up_urls_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_StartUpUrlsProto* ChromeDeviceSettingsProto::unsafe_arena_release_start_up_urls() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.start_up_urls)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::enterprise_management::OBSOLETE_StartUpUrlsProto* temp = _impl_.start_up_urls_;
  _impl_.start_up_urls_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_StartUpUrlsProto* ChromeDeviceSettingsProto::_internal_mutable_start_up_urls() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.start_up_urls_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_StartUpUrlsProto>(GetArenaForAllocation());
    _impl_.start_up_urls_ = p;
  }
  return _impl_.start_up_urls_;
}
inline ::enterprise_management::OBSOLETE_StartUpUrlsProto* ChromeDeviceSettingsProto::mutable_start_up_urls() {
  ::enterprise_management::OBSOLETE_StartUpUrlsProto* _msg = _internal_mutable_start_up_urls();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.start_up_urls)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_start_up_urls(::enterprise_management::OBSOLETE_StartUpUrlsProto* start_up_urls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_up_urls_;
  }
  if (start_up_urls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start_up_urls);
    if (message_arena != submessage_arena) {
      start_up_urls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_up_urls, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.start_up_urls_ = start_up_urls;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.start_up_urls)
}

// optional .enterprise_management.OBSOLETE_PinnedAppsProto pinned_apps = 19 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_pinned_apps() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pinned_apps_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_pinned_apps() const {
  return _internal_has_pinned_apps();
}
inline void ChromeDeviceSettingsProto::clear_pinned_apps() {
  if (_impl_.pinned_apps_ != nullptr) _impl_.pinned_apps_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::enterprise_management::OBSOLETE_PinnedAppsProto& ChromeDeviceSettingsProto::_internal_pinned_apps() const {
  const ::enterprise_management::OBSOLETE_PinnedAppsProto* p = _impl_.pinned_apps_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_PinnedAppsProto&>(
      ::enterprise_management::_OBSOLETE_PinnedAppsProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_PinnedAppsProto& ChromeDeviceSettingsProto::pinned_apps() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.pinned_apps)
  return _internal_pinned_apps();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_pinned_apps(
    ::enterprise_management::OBSOLETE_PinnedAppsProto* pinned_apps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pinned_apps_);
  }
  _impl_.pinned_apps_ = pinned_apps;
  if (pinned_apps) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.pinned_apps)
}
inline ::enterprise_management::OBSOLETE_PinnedAppsProto* ChromeDeviceSettingsProto::release_pinned_apps() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::enterprise_management::OBSOLETE_PinnedAppsProto* temp = _impl_.pinned_apps_;
  _impl_.pinned_apps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_PinnedAppsProto* ChromeDeviceSettingsProto::unsafe_arena_release_pinned_apps() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.pinned_apps)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::enterprise_management::OBSOLETE_PinnedAppsProto* temp = _impl_.pinned_apps_;
  _impl_.pinned_apps_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_PinnedAppsProto* ChromeDeviceSettingsProto::_internal_mutable_pinned_apps() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.pinned_apps_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_PinnedAppsProto>(GetArenaForAllocation());
    _impl_.pinned_apps_ = p;
  }
  return _impl_.pinned_apps_;
}
inline ::enterprise_management::OBSOLETE_PinnedAppsProto* ChromeDeviceSettingsProto::mutable_pinned_apps() {
  ::enterprise_management::OBSOLETE_PinnedAppsProto* _msg = _internal_mutable_pinned_apps();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.pinned_apps)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_pinned_apps(::enterprise_management::OBSOLETE_PinnedAppsProto* pinned_apps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pinned_apps_;
  }
  if (pinned_apps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pinned_apps);
    if (message_arena != submessage_arena) {
      pinned_apps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pinned_apps, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.pinned_apps_ = pinned_apps;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.pinned_apps)
}

// optional .enterprise_management.SystemTimezoneProto system_timezone = 20;
inline bool ChromeDeviceSettingsProto::_internal_has_system_timezone() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_timezone_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_system_timezone() const {
  return _internal_has_system_timezone();
}
inline void ChromeDeviceSettingsProto::clear_system_timezone() {
  if (_impl_.system_timezone_ != nullptr) _impl_.system_timezone_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::enterprise_management::SystemTimezoneProto& ChromeDeviceSettingsProto::_internal_system_timezone() const {
  const ::enterprise_management::SystemTimezoneProto* p = _impl_.system_timezone_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SystemTimezoneProto&>(
      ::enterprise_management::_SystemTimezoneProto_default_instance_);
}
inline const ::enterprise_management::SystemTimezoneProto& ChromeDeviceSettingsProto::system_timezone() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.system_timezone)
  return _internal_system_timezone();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_system_timezone(
    ::enterprise_management::SystemTimezoneProto* system_timezone) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_timezone_);
  }
  _impl_.system_timezone_ = system_timezone;
  if (system_timezone) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.system_timezone)
}
inline ::enterprise_management::SystemTimezoneProto* ChromeDeviceSettingsProto::release_system_timezone() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::enterprise_management::SystemTimezoneProto* temp = _impl_.system_timezone_;
  _impl_.system_timezone_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SystemTimezoneProto* ChromeDeviceSettingsProto::unsafe_arena_release_system_timezone() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.system_timezone)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::enterprise_management::SystemTimezoneProto* temp = _impl_.system_timezone_;
  _impl_.system_timezone_ = nullptr;
  return temp;
}
inline ::enterprise_management::SystemTimezoneProto* ChromeDeviceSettingsProto::_internal_mutable_system_timezone() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.system_timezone_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SystemTimezoneProto>(GetArenaForAllocation());
    _impl_.system_timezone_ = p;
  }
  return _impl_.system_timezone_;
}
inline ::enterprise_management::SystemTimezoneProto* ChromeDeviceSettingsProto::mutable_system_timezone() {
  ::enterprise_management::SystemTimezoneProto* _msg = _internal_mutable_system_timezone();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.system_timezone)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_system_timezone(::enterprise_management::SystemTimezoneProto* system_timezone) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_timezone_;
  }
  if (system_timezone) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_timezone);
    if (message_arena != submessage_arena) {
      system_timezone = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_timezone, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.system_timezone_ = system_timezone;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.system_timezone)
}

// optional .enterprise_management.DeviceLocalAccountsProto device_local_accounts = 21;
inline bool ChromeDeviceSettingsProto::_internal_has_device_local_accounts() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_local_accounts_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_local_accounts() const {
  return _internal_has_device_local_accounts();
}
inline void ChromeDeviceSettingsProto::clear_device_local_accounts() {
  if (_impl_.device_local_accounts_ != nullptr) _impl_.device_local_accounts_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::enterprise_management::DeviceLocalAccountsProto& ChromeDeviceSettingsProto::_internal_device_local_accounts() const {
  const ::enterprise_management::DeviceLocalAccountsProto* p = _impl_.device_local_accounts_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceLocalAccountsProto&>(
      ::enterprise_management::_DeviceLocalAccountsProto_default_instance_);
}
inline const ::enterprise_management::DeviceLocalAccountsProto& ChromeDeviceSettingsProto::device_local_accounts() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_local_accounts)
  return _internal_device_local_accounts();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_local_accounts(
    ::enterprise_management::DeviceLocalAccountsProto* device_local_accounts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_local_accounts_);
  }
  _impl_.device_local_accounts_ = device_local_accounts;
  if (device_local_accounts) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_local_accounts)
}
inline ::enterprise_management::DeviceLocalAccountsProto* ChromeDeviceSettingsProto::release_device_local_accounts() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::enterprise_management::DeviceLocalAccountsProto* temp = _impl_.device_local_accounts_;
  _impl_.device_local_accounts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceLocalAccountsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_local_accounts() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_local_accounts)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::enterprise_management::DeviceLocalAccountsProto* temp = _impl_.device_local_accounts_;
  _impl_.device_local_accounts_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceLocalAccountsProto* ChromeDeviceSettingsProto::_internal_mutable_device_local_accounts() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.device_local_accounts_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceLocalAccountsProto>(GetArenaForAllocation());
    _impl_.device_local_accounts_ = p;
  }
  return _impl_.device_local_accounts_;
}
inline ::enterprise_management::DeviceLocalAccountsProto* ChromeDeviceSettingsProto::mutable_device_local_accounts() {
  ::enterprise_management::DeviceLocalAccountsProto* _msg = _internal_mutable_device_local_accounts();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_local_accounts)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_local_accounts(::enterprise_management::DeviceLocalAccountsProto* device_local_accounts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_local_accounts_;
  }
  if (device_local_accounts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_local_accounts);
    if (message_arena != submessage_arena) {
      device_local_accounts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_local_accounts, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.device_local_accounts_ = device_local_accounts;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_local_accounts)
}

// optional .enterprise_management.AllowRedeemChromeOsRegistrationOffersProto allow_redeem_offers = 22;
inline bool ChromeDeviceSettingsProto::_internal_has_allow_redeem_offers() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.allow_redeem_offers_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_allow_redeem_offers() const {
  return _internal_has_allow_redeem_offers();
}
inline void ChromeDeviceSettingsProto::clear_allow_redeem_offers() {
  if (_impl_.allow_redeem_offers_ != nullptr) _impl_.allow_redeem_offers_->Clear();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto& ChromeDeviceSettingsProto::_internal_allow_redeem_offers() const {
  const ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* p = _impl_.allow_redeem_offers_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto&>(
      ::enterprise_management::_AllowRedeemChromeOsRegistrationOffersProto_default_instance_);
}
inline const ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto& ChromeDeviceSettingsProto::allow_redeem_offers() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.allow_redeem_offers)
  return _internal_allow_redeem_offers();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_allow_redeem_offers(
    ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* allow_redeem_offers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allow_redeem_offers_);
  }
  _impl_.allow_redeem_offers_ = allow_redeem_offers;
  if (allow_redeem_offers) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.allow_redeem_offers)
}
inline ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* ChromeDeviceSettingsProto::release_allow_redeem_offers() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* temp = _impl_.allow_redeem_offers_;
  _impl_.allow_redeem_offers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* ChromeDeviceSettingsProto::unsafe_arena_release_allow_redeem_offers() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.allow_redeem_offers)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* temp = _impl_.allow_redeem_offers_;
  _impl_.allow_redeem_offers_ = nullptr;
  return temp;
}
inline ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* ChromeDeviceSettingsProto::_internal_mutable_allow_redeem_offers() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.allow_redeem_offers_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto>(GetArenaForAllocation());
    _impl_.allow_redeem_offers_ = p;
  }
  return _impl_.allow_redeem_offers_;
}
inline ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* ChromeDeviceSettingsProto::mutable_allow_redeem_offers() {
  ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* _msg = _internal_mutable_allow_redeem_offers();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.allow_redeem_offers)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_allow_redeem_offers(::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto* allow_redeem_offers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allow_redeem_offers_;
  }
  if (allow_redeem_offers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allow_redeem_offers);
    if (message_arena != submessage_arena) {
      allow_redeem_offers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allow_redeem_offers, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.allow_redeem_offers_ = allow_redeem_offers;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.allow_redeem_offers)
}

// optional .enterprise_management.FeatureFlagsProto feature_flags = 23;
inline bool ChromeDeviceSettingsProto::_internal_has_feature_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feature_flags_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_feature_flags() const {
  return _internal_has_feature_flags();
}
inline void ChromeDeviceSettingsProto::clear_feature_flags() {
  if (_impl_.feature_flags_ != nullptr) _impl_.feature_flags_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::enterprise_management::FeatureFlagsProto& ChromeDeviceSettingsProto::_internal_feature_flags() const {
  const ::enterprise_management::FeatureFlagsProto* p = _impl_.feature_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::FeatureFlagsProto&>(
      ::enterprise_management::_FeatureFlagsProto_default_instance_);
}
inline const ::enterprise_management::FeatureFlagsProto& ChromeDeviceSettingsProto::feature_flags() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.feature_flags)
  return _internal_feature_flags();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_feature_flags(
    ::enterprise_management::FeatureFlagsProto* feature_flags) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feature_flags_);
  }
  _impl_.feature_flags_ = feature_flags;
  if (feature_flags) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.feature_flags)
}
inline ::enterprise_management::FeatureFlagsProto* ChromeDeviceSettingsProto::release_feature_flags() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::enterprise_management::FeatureFlagsProto* temp = _impl_.feature_flags_;
  _impl_.feature_flags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::FeatureFlagsProto* ChromeDeviceSettingsProto::unsafe_arena_release_feature_flags() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.feature_flags)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::enterprise_management::FeatureFlagsProto* temp = _impl_.feature_flags_;
  _impl_.feature_flags_ = nullptr;
  return temp;
}
inline ::enterprise_management::FeatureFlagsProto* ChromeDeviceSettingsProto::_internal_mutable_feature_flags() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.feature_flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::FeatureFlagsProto>(GetArenaForAllocation());
    _impl_.feature_flags_ = p;
  }
  return _impl_.feature_flags_;
}
inline ::enterprise_management::FeatureFlagsProto* ChromeDeviceSettingsProto::mutable_feature_flags() {
  ::enterprise_management::FeatureFlagsProto* _msg = _internal_mutable_feature_flags();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.feature_flags)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_feature_flags(::enterprise_management::FeatureFlagsProto* feature_flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feature_flags_;
  }
  if (feature_flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feature_flags);
    if (message_arena != submessage_arena) {
      feature_flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_flags, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.feature_flags_ = feature_flags;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.feature_flags)
}

// optional .enterprise_management.UptimeLimitProto uptime_limit = 24;
inline bool ChromeDeviceSettingsProto::_internal_has_uptime_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.uptime_limit_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_uptime_limit() const {
  return _internal_has_uptime_limit();
}
inline void ChromeDeviceSettingsProto::clear_uptime_limit() {
  if (_impl_.uptime_limit_ != nullptr) _impl_.uptime_limit_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::enterprise_management::UptimeLimitProto& ChromeDeviceSettingsProto::_internal_uptime_limit() const {
  const ::enterprise_management::UptimeLimitProto* p = _impl_.uptime_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::UptimeLimitProto&>(
      ::enterprise_management::_UptimeLimitProto_default_instance_);
}
inline const ::enterprise_management::UptimeLimitProto& ChromeDeviceSettingsProto::uptime_limit() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.uptime_limit)
  return _internal_uptime_limit();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_uptime_limit(
    ::enterprise_management::UptimeLimitProto* uptime_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uptime_limit_);
  }
  _impl_.uptime_limit_ = uptime_limit;
  if (uptime_limit) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.uptime_limit)
}
inline ::enterprise_management::UptimeLimitProto* ChromeDeviceSettingsProto::release_uptime_limit() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::enterprise_management::UptimeLimitProto* temp = _impl_.uptime_limit_;
  _impl_.uptime_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::UptimeLimitProto* ChromeDeviceSettingsProto::unsafe_arena_release_uptime_limit() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.uptime_limit)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::enterprise_management::UptimeLimitProto* temp = _impl_.uptime_limit_;
  _impl_.uptime_limit_ = nullptr;
  return temp;
}
inline ::enterprise_management::UptimeLimitProto* ChromeDeviceSettingsProto::_internal_mutable_uptime_limit() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.uptime_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::UptimeLimitProto>(GetArenaForAllocation());
    _impl_.uptime_limit_ = p;
  }
  return _impl_.uptime_limit_;
}
inline ::enterprise_management::UptimeLimitProto* ChromeDeviceSettingsProto::mutable_uptime_limit() {
  ::enterprise_management::UptimeLimitProto* _msg = _internal_mutable_uptime_limit();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.uptime_limit)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_uptime_limit(::enterprise_management::UptimeLimitProto* uptime_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uptime_limit_;
  }
  if (uptime_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uptime_limit);
    if (message_arena != submessage_arena) {
      uptime_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uptime_limit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.uptime_limit_ = uptime_limit;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.uptime_limit)
}

// optional .enterprise_management.VariationsParameterProto variations_parameter = 25;
inline bool ChromeDeviceSettingsProto::_internal_has_variations_parameter() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.variations_parameter_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_variations_parameter() const {
  return _internal_has_variations_parameter();
}
inline void ChromeDeviceSettingsProto::clear_variations_parameter() {
  if (_impl_.variations_parameter_ != nullptr) _impl_.variations_parameter_->Clear();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const ::enterprise_management::VariationsParameterProto& ChromeDeviceSettingsProto::_internal_variations_parameter() const {
  const ::enterprise_management::VariationsParameterProto* p = _impl_.variations_parameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::VariationsParameterProto&>(
      ::enterprise_management::_VariationsParameterProto_default_instance_);
}
inline const ::enterprise_management::VariationsParameterProto& ChromeDeviceSettingsProto::variations_parameter() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.variations_parameter)
  return _internal_variations_parameter();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_variations_parameter(
    ::enterprise_management::VariationsParameterProto* variations_parameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.variations_parameter_);
  }
  _impl_.variations_parameter_ = variations_parameter;
  if (variations_parameter) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.variations_parameter)
}
inline ::enterprise_management::VariationsParameterProto* ChromeDeviceSettingsProto::release_variations_parameter() {
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::enterprise_management::VariationsParameterProto* temp = _impl_.variations_parameter_;
  _impl_.variations_parameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::VariationsParameterProto* ChromeDeviceSettingsProto::unsafe_arena_release_variations_parameter() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.variations_parameter)
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::enterprise_management::VariationsParameterProto* temp = _impl_.variations_parameter_;
  _impl_.variations_parameter_ = nullptr;
  return temp;
}
inline ::enterprise_management::VariationsParameterProto* ChromeDeviceSettingsProto::_internal_mutable_variations_parameter() {
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.variations_parameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::VariationsParameterProto>(GetArenaForAllocation());
    _impl_.variations_parameter_ = p;
  }
  return _impl_.variations_parameter_;
}
inline ::enterprise_management::VariationsParameterProto* ChromeDeviceSettingsProto::mutable_variations_parameter() {
  ::enterprise_management::VariationsParameterProto* _msg = _internal_mutable_variations_parameter();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.variations_parameter)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_variations_parameter(::enterprise_management::VariationsParameterProto* variations_parameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.variations_parameter_;
  }
  if (variations_parameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(variations_parameter);
    if (message_arena != submessage_arena) {
      variations_parameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, variations_parameter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.variations_parameter_ = variations_parameter;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.variations_parameter)
}

// optional .enterprise_management.AttestationSettingsProto attestation_settings = 26;
inline bool ChromeDeviceSettingsProto::_internal_has_attestation_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attestation_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_attestation_settings() const {
  return _internal_has_attestation_settings();
}
inline void ChromeDeviceSettingsProto::clear_attestation_settings() {
  if (_impl_.attestation_settings_ != nullptr) _impl_.attestation_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const ::enterprise_management::AttestationSettingsProto& ChromeDeviceSettingsProto::_internal_attestation_settings() const {
  const ::enterprise_management::AttestationSettingsProto* p = _impl_.attestation_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AttestationSettingsProto&>(
      ::enterprise_management::_AttestationSettingsProto_default_instance_);
}
inline const ::enterprise_management::AttestationSettingsProto& ChromeDeviceSettingsProto::attestation_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.attestation_settings)
  return _internal_attestation_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_attestation_settings(
    ::enterprise_management::AttestationSettingsProto* attestation_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attestation_settings_);
  }
  _impl_.attestation_settings_ = attestation_settings;
  if (attestation_settings) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.attestation_settings)
}
inline ::enterprise_management::AttestationSettingsProto* ChromeDeviceSettingsProto::release_attestation_settings() {
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::enterprise_management::AttestationSettingsProto* temp = _impl_.attestation_settings_;
  _impl_.attestation_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AttestationSettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_attestation_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.attestation_settings)
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::enterprise_management::AttestationSettingsProto* temp = _impl_.attestation_settings_;
  _impl_.attestation_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::AttestationSettingsProto* ChromeDeviceSettingsProto::_internal_mutable_attestation_settings() {
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.attestation_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AttestationSettingsProto>(GetArenaForAllocation());
    _impl_.attestation_settings_ = p;
  }
  return _impl_.attestation_settings_;
}
inline ::enterprise_management::AttestationSettingsProto* ChromeDeviceSettingsProto::mutable_attestation_settings() {
  ::enterprise_management::AttestationSettingsProto* _msg = _internal_mutable_attestation_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.attestation_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_attestation_settings(::enterprise_management::AttestationSettingsProto* attestation_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attestation_settings_;
  }
  if (attestation_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attestation_settings);
    if (message_arena != submessage_arena) {
      attestation_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attestation_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.attestation_settings_ = attestation_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.attestation_settings)
}

// optional .enterprise_management.AccessibilitySettingsProto accessibility_settings = 27;
inline bool ChromeDeviceSettingsProto::_internal_has_accessibility_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accessibility_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_accessibility_settings() const {
  return _internal_has_accessibility_settings();
}
inline void ChromeDeviceSettingsProto::clear_accessibility_settings() {
  if (_impl_.accessibility_settings_ != nullptr) _impl_.accessibility_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const ::enterprise_management::AccessibilitySettingsProto& ChromeDeviceSettingsProto::_internal_accessibility_settings() const {
  const ::enterprise_management::AccessibilitySettingsProto* p = _impl_.accessibility_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AccessibilitySettingsProto&>(
      ::enterprise_management::_AccessibilitySettingsProto_default_instance_);
}
inline const ::enterprise_management::AccessibilitySettingsProto& ChromeDeviceSettingsProto::accessibility_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.accessibility_settings)
  return _internal_accessibility_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_accessibility_settings(
    ::enterprise_management::AccessibilitySettingsProto* accessibility_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accessibility_settings_);
  }
  _impl_.accessibility_settings_ = accessibility_settings;
  if (accessibility_settings) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.accessibility_settings)
}
inline ::enterprise_management::AccessibilitySettingsProto* ChromeDeviceSettingsProto::release_accessibility_settings() {
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::enterprise_management::AccessibilitySettingsProto* temp = _impl_.accessibility_settings_;
  _impl_.accessibility_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AccessibilitySettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_accessibility_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.accessibility_settings)
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::enterprise_management::AccessibilitySettingsProto* temp = _impl_.accessibility_settings_;
  _impl_.accessibility_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::AccessibilitySettingsProto* ChromeDeviceSettingsProto::_internal_mutable_accessibility_settings() {
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.accessibility_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AccessibilitySettingsProto>(GetArenaForAllocation());
    _impl_.accessibility_settings_ = p;
  }
  return _impl_.accessibility_settings_;
}
inline ::enterprise_management::AccessibilitySettingsProto* ChromeDeviceSettingsProto::mutable_accessibility_settings() {
  ::enterprise_management::AccessibilitySettingsProto* _msg = _internal_mutable_accessibility_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.accessibility_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_accessibility_settings(::enterprise_management::AccessibilitySettingsProto* accessibility_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accessibility_settings_;
  }
  if (accessibility_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accessibility_settings);
    if (message_arena != submessage_arena) {
      accessibility_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accessibility_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.accessibility_settings_ = accessibility_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.accessibility_settings)
}

// optional .enterprise_management.OBSOLETE_SupervisedUsersSettingsProto supervised_users_settings = 28 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_supervised_users_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.supervised_users_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_supervised_users_settings() const {
  return _internal_has_supervised_users_settings();
}
inline void ChromeDeviceSettingsProto::clear_supervised_users_settings() {
  if (_impl_.supervised_users_settings_ != nullptr) _impl_.supervised_users_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto& ChromeDeviceSettingsProto::_internal_supervised_users_settings() const {
  const ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* p = _impl_.supervised_users_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto&>(
      ::enterprise_management::_OBSOLETE_SupervisedUsersSettingsProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto& ChromeDeviceSettingsProto::supervised_users_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.supervised_users_settings)
  return _internal_supervised_users_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_supervised_users_settings(
    ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* supervised_users_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supervised_users_settings_);
  }
  _impl_.supervised_users_settings_ = supervised_users_settings;
  if (supervised_users_settings) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.supervised_users_settings)
}
inline ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* ChromeDeviceSettingsProto::release_supervised_users_settings() {
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* temp = _impl_.supervised_users_settings_;
  _impl_.supervised_users_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_supervised_users_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.supervised_users_settings)
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* temp = _impl_.supervised_users_settings_;
  _impl_.supervised_users_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* ChromeDeviceSettingsProto::_internal_mutable_supervised_users_settings() {
  _impl_._has_bits_[0] |= 0x08000000u;
  if (_impl_.supervised_users_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto>(GetArenaForAllocation());
    _impl_.supervised_users_settings_ = p;
  }
  return _impl_.supervised_users_settings_;
}
inline ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* ChromeDeviceSettingsProto::mutable_supervised_users_settings() {
  ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* _msg = _internal_mutable_supervised_users_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.supervised_users_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_supervised_users_settings(::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto* supervised_users_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supervised_users_settings_;
  }
  if (supervised_users_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supervised_users_settings);
    if (message_arena != submessage_arena) {
      supervised_users_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supervised_users_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.supervised_users_settings_ = supervised_users_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.supervised_users_settings)
}

// optional .enterprise_management.LoginScreenPowerManagementProto login_screen_power_management = 29;
inline bool ChromeDeviceSettingsProto::_internal_has_login_screen_power_management() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_power_management_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_screen_power_management() const {
  return _internal_has_login_screen_power_management();
}
inline void ChromeDeviceSettingsProto::clear_login_screen_power_management() {
  if (_impl_.login_screen_power_management_ != nullptr) _impl_.login_screen_power_management_->Clear();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const ::enterprise_management::LoginScreenPowerManagementProto& ChromeDeviceSettingsProto::_internal_login_screen_power_management() const {
  const ::enterprise_management::LoginScreenPowerManagementProto* p = _impl_.login_screen_power_management_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LoginScreenPowerManagementProto&>(
      ::enterprise_management::_LoginScreenPowerManagementProto_default_instance_);
}
inline const ::enterprise_management::LoginScreenPowerManagementProto& ChromeDeviceSettingsProto::login_screen_power_management() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_screen_power_management)
  return _internal_login_screen_power_management();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_screen_power_management(
    ::enterprise_management::LoginScreenPowerManagementProto* login_screen_power_management) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_power_management_);
  }
  _impl_.login_screen_power_management_ = login_screen_power_management;
  if (login_screen_power_management) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_power_management)
}
inline ::enterprise_management::LoginScreenPowerManagementProto* ChromeDeviceSettingsProto::release_login_screen_power_management() {
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::enterprise_management::LoginScreenPowerManagementProto* temp = _impl_.login_screen_power_management_;
  _impl_.login_screen_power_management_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LoginScreenPowerManagementProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_screen_power_management() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_screen_power_management)
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::enterprise_management::LoginScreenPowerManagementProto* temp = _impl_.login_screen_power_management_;
  _impl_.login_screen_power_management_ = nullptr;
  return temp;
}
inline ::enterprise_management::LoginScreenPowerManagementProto* ChromeDeviceSettingsProto::_internal_mutable_login_screen_power_management() {
  _impl_._has_bits_[0] |= 0x10000000u;
  if (_impl_.login_screen_power_management_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LoginScreenPowerManagementProto>(GetArenaForAllocation());
    _impl_.login_screen_power_management_ = p;
  }
  return _impl_.login_screen_power_management_;
}
inline ::enterprise_management::LoginScreenPowerManagementProto* ChromeDeviceSettingsProto::mutable_login_screen_power_management() {
  ::enterprise_management::LoginScreenPowerManagementProto* _msg = _internal_mutable_login_screen_power_management();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_screen_power_management)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_screen_power_management(::enterprise_management::LoginScreenPowerManagementProto* login_screen_power_management) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_screen_power_management_;
  }
  if (login_screen_power_management) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_screen_power_management);
    if (message_arena != submessage_arena) {
      login_screen_power_management = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_power_management, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.login_screen_power_management_ = login_screen_power_management;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_power_management)
}

// optional .enterprise_management.SystemUse24HourClockProto use_24hour_clock = 30;
inline bool ChromeDeviceSettingsProto::_internal_has_use_24hour_clock() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.use_24hour_clock_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_use_24hour_clock() const {
  return _internal_has_use_24hour_clock();
}
inline void ChromeDeviceSettingsProto::clear_use_24hour_clock() {
  if (_impl_.use_24hour_clock_ != nullptr) _impl_.use_24hour_clock_->Clear();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const ::enterprise_management::SystemUse24HourClockProto& ChromeDeviceSettingsProto::_internal_use_24hour_clock() const {
  const ::enterprise_management::SystemUse24HourClockProto* p = _impl_.use_24hour_clock_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SystemUse24HourClockProto&>(
      ::enterprise_management::_SystemUse24HourClockProto_default_instance_);
}
inline const ::enterprise_management::SystemUse24HourClockProto& ChromeDeviceSettingsProto::use_24hour_clock() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.use_24hour_clock)
  return _internal_use_24hour_clock();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_use_24hour_clock(
    ::enterprise_management::SystemUse24HourClockProto* use_24hour_clock) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.use_24hour_clock_);
  }
  _impl_.use_24hour_clock_ = use_24hour_clock;
  if (use_24hour_clock) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.use_24hour_clock)
}
inline ::enterprise_management::SystemUse24HourClockProto* ChromeDeviceSettingsProto::release_use_24hour_clock() {
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::enterprise_management::SystemUse24HourClockProto* temp = _impl_.use_24hour_clock_;
  _impl_.use_24hour_clock_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SystemUse24HourClockProto* ChromeDeviceSettingsProto::unsafe_arena_release_use_24hour_clock() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.use_24hour_clock)
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::enterprise_management::SystemUse24HourClockProto* temp = _impl_.use_24hour_clock_;
  _impl_.use_24hour_clock_ = nullptr;
  return temp;
}
inline ::enterprise_management::SystemUse24HourClockProto* ChromeDeviceSettingsProto::_internal_mutable_use_24hour_clock() {
  _impl_._has_bits_[0] |= 0x20000000u;
  if (_impl_.use_24hour_clock_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SystemUse24HourClockProto>(GetArenaForAllocation());
    _impl_.use_24hour_clock_ = p;
  }
  return _impl_.use_24hour_clock_;
}
inline ::enterprise_management::SystemUse24HourClockProto* ChromeDeviceSettingsProto::mutable_use_24hour_clock() {
  ::enterprise_management::SystemUse24HourClockProto* _msg = _internal_mutable_use_24hour_clock();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.use_24hour_clock)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_use_24hour_clock(::enterprise_management::SystemUse24HourClockProto* use_24hour_clock) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.use_24hour_clock_;
  }
  if (use_24hour_clock) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(use_24hour_clock);
    if (message_arena != submessage_arena) {
      use_24hour_clock = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, use_24hour_clock, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.use_24hour_clock_ = use_24hour_clock;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.use_24hour_clock)
}

// optional .enterprise_management.AutoCleanupSettigsProto auto_clean_up_settings = 31;
inline bool ChromeDeviceSettingsProto::_internal_has_auto_clean_up_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auto_clean_up_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_auto_clean_up_settings() const {
  return _internal_has_auto_clean_up_settings();
}
inline void ChromeDeviceSettingsProto::clear_auto_clean_up_settings() {
  if (_impl_.auto_clean_up_settings_ != nullptr) _impl_.auto_clean_up_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const ::enterprise_management::AutoCleanupSettigsProto& ChromeDeviceSettingsProto::_internal_auto_clean_up_settings() const {
  const ::enterprise_management::AutoCleanupSettigsProto* p = _impl_.auto_clean_up_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AutoCleanupSettigsProto&>(
      ::enterprise_management::_AutoCleanupSettigsProto_default_instance_);
}
inline const ::enterprise_management::AutoCleanupSettigsProto& ChromeDeviceSettingsProto::auto_clean_up_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.auto_clean_up_settings)
  return _internal_auto_clean_up_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_auto_clean_up_settings(
    ::enterprise_management::AutoCleanupSettigsProto* auto_clean_up_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auto_clean_up_settings_);
  }
  _impl_.auto_clean_up_settings_ = auto_clean_up_settings;
  if (auto_clean_up_settings) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.auto_clean_up_settings)
}
inline ::enterprise_management::AutoCleanupSettigsProto* ChromeDeviceSettingsProto::release_auto_clean_up_settings() {
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::enterprise_management::AutoCleanupSettigsProto* temp = _impl_.auto_clean_up_settings_;
  _impl_.auto_clean_up_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AutoCleanupSettigsProto* ChromeDeviceSettingsProto::unsafe_arena_release_auto_clean_up_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.auto_clean_up_settings)
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::enterprise_management::AutoCleanupSettigsProto* temp = _impl_.auto_clean_up_settings_;
  _impl_.auto_clean_up_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::AutoCleanupSettigsProto* ChromeDeviceSettingsProto::_internal_mutable_auto_clean_up_settings() {
  _impl_._has_bits_[0] |= 0x40000000u;
  if (_impl_.auto_clean_up_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AutoCleanupSettigsProto>(GetArenaForAllocation());
    _impl_.auto_clean_up_settings_ = p;
  }
  return _impl_.auto_clean_up_settings_;
}
inline ::enterprise_management::AutoCleanupSettigsProto* ChromeDeviceSettingsProto::mutable_auto_clean_up_settings() {
  ::enterprise_management::AutoCleanupSettigsProto* _msg = _internal_mutable_auto_clean_up_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.auto_clean_up_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_auto_clean_up_settings(::enterprise_management::AutoCleanupSettigsProto* auto_clean_up_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auto_clean_up_settings_;
  }
  if (auto_clean_up_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_clean_up_settings);
    if (message_arena != submessage_arena) {
      auto_clean_up_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_clean_up_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.auto_clean_up_settings_ = auto_clean_up_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.auto_clean_up_settings)
}

// optional .enterprise_management.SystemSettingsProto system_settings = 32;
inline bool ChromeDeviceSettingsProto::_internal_has_system_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_system_settings() const {
  return _internal_has_system_settings();
}
inline void ChromeDeviceSettingsProto::clear_system_settings() {
  if (_impl_.system_settings_ != nullptr) _impl_.system_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const ::enterprise_management::SystemSettingsProto& ChromeDeviceSettingsProto::_internal_system_settings() const {
  const ::enterprise_management::SystemSettingsProto* p = _impl_.system_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SystemSettingsProto&>(
      ::enterprise_management::_SystemSettingsProto_default_instance_);
}
inline const ::enterprise_management::SystemSettingsProto& ChromeDeviceSettingsProto::system_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.system_settings)
  return _internal_system_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_system_settings(
    ::enterprise_management::SystemSettingsProto* system_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_settings_);
  }
  _impl_.system_settings_ = system_settings;
  if (system_settings) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.system_settings)
}
inline ::enterprise_management::SystemSettingsProto* ChromeDeviceSettingsProto::release_system_settings() {
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::enterprise_management::SystemSettingsProto* temp = _impl_.system_settings_;
  _impl_.system_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SystemSettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_system_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.system_settings)
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::enterprise_management::SystemSettingsProto* temp = _impl_.system_settings_;
  _impl_.system_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::SystemSettingsProto* ChromeDeviceSettingsProto::_internal_mutable_system_settings() {
  _impl_._has_bits_[0] |= 0x80000000u;
  if (_impl_.system_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SystemSettingsProto>(GetArenaForAllocation());
    _impl_.system_settings_ = p;
  }
  return _impl_.system_settings_;
}
inline ::enterprise_management::SystemSettingsProto* ChromeDeviceSettingsProto::mutable_system_settings() {
  ::enterprise_management::SystemSettingsProto* _msg = _internal_mutable_system_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.system_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_system_settings(::enterprise_management::SystemSettingsProto* system_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_settings_;
  }
  if (system_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_settings);
    if (message_arena != submessage_arena) {
      system_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.system_settings_ = system_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.system_settings)
}

// optional .enterprise_management.SAMLSettingsProto saml_settings = 33;
inline bool ChromeDeviceSettingsProto::_internal_has_saml_settings() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.saml_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_saml_settings() const {
  return _internal_has_saml_settings();
}
inline void ChromeDeviceSettingsProto::clear_saml_settings() {
  if (_impl_.saml_settings_ != nullptr) _impl_.saml_settings_->Clear();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const ::enterprise_management::SAMLSettingsProto& ChromeDeviceSettingsProto::_internal_saml_settings() const {
  const ::enterprise_management::SAMLSettingsProto* p = _impl_.saml_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SAMLSettingsProto&>(
      ::enterprise_management::_SAMLSettingsProto_default_instance_);
}
inline const ::enterprise_management::SAMLSettingsProto& ChromeDeviceSettingsProto::saml_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.saml_settings)
  return _internal_saml_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_saml_settings(
    ::enterprise_management::SAMLSettingsProto* saml_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.saml_settings_);
  }
  _impl_.saml_settings_ = saml_settings;
  if (saml_settings) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.saml_settings)
}
inline ::enterprise_management::SAMLSettingsProto* ChromeDeviceSettingsProto::release_saml_settings() {
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::enterprise_management::SAMLSettingsProto* temp = _impl_.saml_settings_;
  _impl_.saml_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SAMLSettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_saml_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.saml_settings)
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::enterprise_management::SAMLSettingsProto* temp = _impl_.saml_settings_;
  _impl_.saml_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::SAMLSettingsProto* ChromeDeviceSettingsProto::_internal_mutable_saml_settings() {
  _impl_._has_bits_[1] |= 0x00000001u;
  if (_impl_.saml_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SAMLSettingsProto>(GetArenaForAllocation());
    _impl_.saml_settings_ = p;
  }
  return _impl_.saml_settings_;
}
inline ::enterprise_management::SAMLSettingsProto* ChromeDeviceSettingsProto::mutable_saml_settings() {
  ::enterprise_management::SAMLSettingsProto* _msg = _internal_mutable_saml_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.saml_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_saml_settings(::enterprise_management::SAMLSettingsProto* saml_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.saml_settings_;
  }
  if (saml_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saml_settings);
    if (message_arena != submessage_arena) {
      saml_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saml_settings, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.saml_settings_ = saml_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.saml_settings)
}

// optional .enterprise_management.RebootOnShutdownProto reboot_on_shutdown = 34;
inline bool ChromeDeviceSettingsProto::_internal_has_reboot_on_shutdown() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reboot_on_shutdown_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_reboot_on_shutdown() const {
  return _internal_has_reboot_on_shutdown();
}
inline void ChromeDeviceSettingsProto::clear_reboot_on_shutdown() {
  if (_impl_.reboot_on_shutdown_ != nullptr) _impl_.reboot_on_shutdown_->Clear();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const ::enterprise_management::RebootOnShutdownProto& ChromeDeviceSettingsProto::_internal_reboot_on_shutdown() const {
  const ::enterprise_management::RebootOnShutdownProto* p = _impl_.reboot_on_shutdown_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::RebootOnShutdownProto&>(
      ::enterprise_management::_RebootOnShutdownProto_default_instance_);
}
inline const ::enterprise_management::RebootOnShutdownProto& ChromeDeviceSettingsProto::reboot_on_shutdown() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.reboot_on_shutdown)
  return _internal_reboot_on_shutdown();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_reboot_on_shutdown(
    ::enterprise_management::RebootOnShutdownProto* reboot_on_shutdown) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reboot_on_shutdown_);
  }
  _impl_.reboot_on_shutdown_ = reboot_on_shutdown;
  if (reboot_on_shutdown) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.reboot_on_shutdown)
}
inline ::enterprise_management::RebootOnShutdownProto* ChromeDeviceSettingsProto::release_reboot_on_shutdown() {
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::enterprise_management::RebootOnShutdownProto* temp = _impl_.reboot_on_shutdown_;
  _impl_.reboot_on_shutdown_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::RebootOnShutdownProto* ChromeDeviceSettingsProto::unsafe_arena_release_reboot_on_shutdown() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.reboot_on_shutdown)
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::enterprise_management::RebootOnShutdownProto* temp = _impl_.reboot_on_shutdown_;
  _impl_.reboot_on_shutdown_ = nullptr;
  return temp;
}
inline ::enterprise_management::RebootOnShutdownProto* ChromeDeviceSettingsProto::_internal_mutable_reboot_on_shutdown() {
  _impl_._has_bits_[1] |= 0x00000002u;
  if (_impl_.reboot_on_shutdown_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::RebootOnShutdownProto>(GetArenaForAllocation());
    _impl_.reboot_on_shutdown_ = p;
  }
  return _impl_.reboot_on_shutdown_;
}
inline ::enterprise_management::RebootOnShutdownProto* ChromeDeviceSettingsProto::mutable_reboot_on_shutdown() {
  ::enterprise_management::RebootOnShutdownProto* _msg = _internal_mutable_reboot_on_shutdown();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.reboot_on_shutdown)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_reboot_on_shutdown(::enterprise_management::RebootOnShutdownProto* reboot_on_shutdown) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reboot_on_shutdown_;
  }
  if (reboot_on_shutdown) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reboot_on_shutdown);
    if (message_arena != submessage_arena) {
      reboot_on_shutdown = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reboot_on_shutdown, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.reboot_on_shutdown_ = reboot_on_shutdown;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.reboot_on_shutdown)
}

// optional .enterprise_management.DeviceHeartbeatSettingsProto device_heartbeat_settings = 35;
inline bool ChromeDeviceSettingsProto::_internal_has_device_heartbeat_settings() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_heartbeat_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_heartbeat_settings() const {
  return _internal_has_device_heartbeat_settings();
}
inline void ChromeDeviceSettingsProto::clear_device_heartbeat_settings() {
  if (_impl_.device_heartbeat_settings_ != nullptr) _impl_.device_heartbeat_settings_->Clear();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const ::enterprise_management::DeviceHeartbeatSettingsProto& ChromeDeviceSettingsProto::_internal_device_heartbeat_settings() const {
  const ::enterprise_management::DeviceHeartbeatSettingsProto* p = _impl_.device_heartbeat_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceHeartbeatSettingsProto&>(
      ::enterprise_management::_DeviceHeartbeatSettingsProto_default_instance_);
}
inline const ::enterprise_management::DeviceHeartbeatSettingsProto& ChromeDeviceSettingsProto::device_heartbeat_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_heartbeat_settings)
  return _internal_device_heartbeat_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_heartbeat_settings(
    ::enterprise_management::DeviceHeartbeatSettingsProto* device_heartbeat_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_heartbeat_settings_);
  }
  _impl_.device_heartbeat_settings_ = device_heartbeat_settings;
  if (device_heartbeat_settings) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_heartbeat_settings)
}
inline ::enterprise_management::DeviceHeartbeatSettingsProto* ChromeDeviceSettingsProto::release_device_heartbeat_settings() {
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::enterprise_management::DeviceHeartbeatSettingsProto* temp = _impl_.device_heartbeat_settings_;
  _impl_.device_heartbeat_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceHeartbeatSettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_heartbeat_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_heartbeat_settings)
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::enterprise_management::DeviceHeartbeatSettingsProto* temp = _impl_.device_heartbeat_settings_;
  _impl_.device_heartbeat_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceHeartbeatSettingsProto* ChromeDeviceSettingsProto::_internal_mutable_device_heartbeat_settings() {
  _impl_._has_bits_[1] |= 0x00000004u;
  if (_impl_.device_heartbeat_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceHeartbeatSettingsProto>(GetArenaForAllocation());
    _impl_.device_heartbeat_settings_ = p;
  }
  return _impl_.device_heartbeat_settings_;
}
inline ::enterprise_management::DeviceHeartbeatSettingsProto* ChromeDeviceSettingsProto::mutable_device_heartbeat_settings() {
  ::enterprise_management::DeviceHeartbeatSettingsProto* _msg = _internal_mutable_device_heartbeat_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_heartbeat_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_heartbeat_settings(::enterprise_management::DeviceHeartbeatSettingsProto* device_heartbeat_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_heartbeat_settings_;
  }
  if (device_heartbeat_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_heartbeat_settings);
    if (message_arena != submessage_arena) {
      device_heartbeat_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_heartbeat_settings, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.device_heartbeat_settings_ = device_heartbeat_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_heartbeat_settings)
}

// optional .enterprise_management.ExtensionCacheSizeProto extension_cache_size = 36;
inline bool ChromeDeviceSettingsProto::_internal_has_extension_cache_size() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extension_cache_size_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_extension_cache_size() const {
  return _internal_has_extension_cache_size();
}
inline void ChromeDeviceSettingsProto::clear_extension_cache_size() {
  if (_impl_.extension_cache_size_ != nullptr) _impl_.extension_cache_size_->Clear();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const ::enterprise_management::ExtensionCacheSizeProto& ChromeDeviceSettingsProto::_internal_extension_cache_size() const {
  const ::enterprise_management::ExtensionCacheSizeProto* p = _impl_.extension_cache_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ExtensionCacheSizeProto&>(
      ::enterprise_management::_ExtensionCacheSizeProto_default_instance_);
}
inline const ::enterprise_management::ExtensionCacheSizeProto& ChromeDeviceSettingsProto::extension_cache_size() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.extension_cache_size)
  return _internal_extension_cache_size();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_extension_cache_size(
    ::enterprise_management::ExtensionCacheSizeProto* extension_cache_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_cache_size_);
  }
  _impl_.extension_cache_size_ = extension_cache_size;
  if (extension_cache_size) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.extension_cache_size)
}
inline ::enterprise_management::ExtensionCacheSizeProto* ChromeDeviceSettingsProto::release_extension_cache_size() {
  _impl_._has_bits_[1] &= ~0x00000008u;
  ::enterprise_management::ExtensionCacheSizeProto* temp = _impl_.extension_cache_size_;
  _impl_.extension_cache_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ExtensionCacheSizeProto* ChromeDeviceSettingsProto::unsafe_arena_release_extension_cache_size() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.extension_cache_size)
  _impl_._has_bits_[1] &= ~0x00000008u;
  ::enterprise_management::ExtensionCacheSizeProto* temp = _impl_.extension_cache_size_;
  _impl_.extension_cache_size_ = nullptr;
  return temp;
}
inline ::enterprise_management::ExtensionCacheSizeProto* ChromeDeviceSettingsProto::_internal_mutable_extension_cache_size() {
  _impl_._has_bits_[1] |= 0x00000008u;
  if (_impl_.extension_cache_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ExtensionCacheSizeProto>(GetArenaForAllocation());
    _impl_.extension_cache_size_ = p;
  }
  return _impl_.extension_cache_size_;
}
inline ::enterprise_management::ExtensionCacheSizeProto* ChromeDeviceSettingsProto::mutable_extension_cache_size() {
  ::enterprise_management::ExtensionCacheSizeProto* _msg = _internal_mutable_extension_cache_size();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.extension_cache_size)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_extension_cache_size(::enterprise_management::ExtensionCacheSizeProto* extension_cache_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.extension_cache_size_;
  }
  if (extension_cache_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extension_cache_size);
    if (message_arena != submessage_arena) {
      extension_cache_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension_cache_size, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  _impl_.extension_cache_size_ = extension_cache_size;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.extension_cache_size)
}

// optional .enterprise_management.LoginScreenDomainAutoCompleteProto login_screen_domain_auto_complete = 37;
inline bool ChromeDeviceSettingsProto::_internal_has_login_screen_domain_auto_complete() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_domain_auto_complete_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_screen_domain_auto_complete() const {
  return _internal_has_login_screen_domain_auto_complete();
}
inline void ChromeDeviceSettingsProto::clear_login_screen_domain_auto_complete() {
  if (_impl_.login_screen_domain_auto_complete_ != nullptr) _impl_.login_screen_domain_auto_complete_->Clear();
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline const ::enterprise_management::LoginScreenDomainAutoCompleteProto& ChromeDeviceSettingsProto::_internal_login_screen_domain_auto_complete() const {
  const ::enterprise_management::LoginScreenDomainAutoCompleteProto* p = _impl_.login_screen_domain_auto_complete_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LoginScreenDomainAutoCompleteProto&>(
      ::enterprise_management::_LoginScreenDomainAutoCompleteProto_default_instance_);
}
inline const ::enterprise_management::LoginScreenDomainAutoCompleteProto& ChromeDeviceSettingsProto::login_screen_domain_auto_complete() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_screen_domain_auto_complete)
  return _internal_login_screen_domain_auto_complete();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_screen_domain_auto_complete(
    ::enterprise_management::LoginScreenDomainAutoCompleteProto* login_screen_domain_auto_complete) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_domain_auto_complete_);
  }
  _impl_.login_screen_domain_auto_complete_ = login_screen_domain_auto_complete;
  if (login_screen_domain_auto_complete) {
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_domain_auto_complete)
}
inline ::enterprise_management::LoginScreenDomainAutoCompleteProto* ChromeDeviceSettingsProto::release_login_screen_domain_auto_complete() {
  _impl_._has_bits_[1] &= ~0x00000010u;
  ::enterprise_management::LoginScreenDomainAutoCompleteProto* temp = _impl_.login_screen_domain_auto_complete_;
  _impl_.login_screen_domain_auto_complete_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LoginScreenDomainAutoCompleteProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_screen_domain_auto_complete() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_screen_domain_auto_complete)
  _impl_._has_bits_[1] &= ~0x00000010u;
  ::enterprise_management::LoginScreenDomainAutoCompleteProto* temp = _impl_.login_screen_domain_auto_complete_;
  _impl_.login_screen_domain_auto_complete_ = nullptr;
  return temp;
}
inline ::enterprise_management::LoginScreenDomainAutoCompleteProto* ChromeDeviceSettingsProto::_internal_mutable_login_screen_domain_auto_complete() {
  _impl_._has_bits_[1] |= 0x00000010u;
  if (_impl_.login_screen_domain_auto_complete_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LoginScreenDomainAutoCompleteProto>(GetArenaForAllocation());
    _impl_.login_screen_domain_auto_complete_ = p;
  }
  return _impl_.login_screen_domain_auto_complete_;
}
inline ::enterprise_management::LoginScreenDomainAutoCompleteProto* ChromeDeviceSettingsProto::mutable_login_screen_domain_auto_complete() {
  ::enterprise_management::LoginScreenDomainAutoCompleteProto* _msg = _internal_mutable_login_screen_domain_auto_complete();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_screen_domain_auto_complete)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_screen_domain_auto_complete(::enterprise_management::LoginScreenDomainAutoCompleteProto* login_screen_domain_auto_complete) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_screen_domain_auto_complete_;
  }
  if (login_screen_domain_auto_complete) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_screen_domain_auto_complete);
    if (message_arena != submessage_arena) {
      login_screen_domain_auto_complete = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_domain_auto_complete, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  _impl_.login_screen_domain_auto_complete_ = login_screen_domain_auto_complete;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_domain_auto_complete)
}

// optional .enterprise_management.DeviceLogUploadSettingsProto device_log_upload_settings = 38;
inline bool ChromeDeviceSettingsProto::_internal_has_device_log_upload_settings() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_log_upload_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_log_upload_settings() const {
  return _internal_has_device_log_upload_settings();
}
inline void ChromeDeviceSettingsProto::clear_device_log_upload_settings() {
  if (_impl_.device_log_upload_settings_ != nullptr) _impl_.device_log_upload_settings_->Clear();
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline const ::enterprise_management::DeviceLogUploadSettingsProto& ChromeDeviceSettingsProto::_internal_device_log_upload_settings() const {
  const ::enterprise_management::DeviceLogUploadSettingsProto* p = _impl_.device_log_upload_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceLogUploadSettingsProto&>(
      ::enterprise_management::_DeviceLogUploadSettingsProto_default_instance_);
}
inline const ::enterprise_management::DeviceLogUploadSettingsProto& ChromeDeviceSettingsProto::device_log_upload_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_log_upload_settings)
  return _internal_device_log_upload_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_log_upload_settings(
    ::enterprise_management::DeviceLogUploadSettingsProto* device_log_upload_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_log_upload_settings_);
  }
  _impl_.device_log_upload_settings_ = device_log_upload_settings;
  if (device_log_upload_settings) {
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_log_upload_settings)
}
inline ::enterprise_management::DeviceLogUploadSettingsProto* ChromeDeviceSettingsProto::release_device_log_upload_settings() {
  _impl_._has_bits_[1] &= ~0x00000020u;
  ::enterprise_management::DeviceLogUploadSettingsProto* temp = _impl_.device_log_upload_settings_;
  _impl_.device_log_upload_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceLogUploadSettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_log_upload_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_log_upload_settings)
  _impl_._has_bits_[1] &= ~0x00000020u;
  ::enterprise_management::DeviceLogUploadSettingsProto* temp = _impl_.device_log_upload_settings_;
  _impl_.device_log_upload_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceLogUploadSettingsProto* ChromeDeviceSettingsProto::_internal_mutable_device_log_upload_settings() {
  _impl_._has_bits_[1] |= 0x00000020u;
  if (_impl_.device_log_upload_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceLogUploadSettingsProto>(GetArenaForAllocation());
    _impl_.device_log_upload_settings_ = p;
  }
  return _impl_.device_log_upload_settings_;
}
inline ::enterprise_management::DeviceLogUploadSettingsProto* ChromeDeviceSettingsProto::mutable_device_log_upload_settings() {
  ::enterprise_management::DeviceLogUploadSettingsProto* _msg = _internal_mutable_device_log_upload_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_log_upload_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_log_upload_settings(::enterprise_management::DeviceLogUploadSettingsProto* device_log_upload_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_log_upload_settings_;
  }
  if (device_log_upload_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_log_upload_settings);
    if (message_arena != submessage_arena) {
      device_log_upload_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_log_upload_settings, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  _impl_.device_log_upload_settings_ = device_log_upload_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_log_upload_settings)
}

// optional .enterprise_management.DisplayRotationDefaultProto display_rotation_default = 39;
inline bool ChromeDeviceSettingsProto::_internal_has_display_rotation_default() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.display_rotation_default_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_display_rotation_default() const {
  return _internal_has_display_rotation_default();
}
inline void ChromeDeviceSettingsProto::clear_display_rotation_default() {
  if (_impl_.display_rotation_default_ != nullptr) _impl_.display_rotation_default_->Clear();
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline const ::enterprise_management::DisplayRotationDefaultProto& ChromeDeviceSettingsProto::_internal_display_rotation_default() const {
  const ::enterprise_management::DisplayRotationDefaultProto* p = _impl_.display_rotation_default_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DisplayRotationDefaultProto&>(
      ::enterprise_management::_DisplayRotationDefaultProto_default_instance_);
}
inline const ::enterprise_management::DisplayRotationDefaultProto& ChromeDeviceSettingsProto::display_rotation_default() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.display_rotation_default)
  return _internal_display_rotation_default();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_display_rotation_default(
    ::enterprise_management::DisplayRotationDefaultProto* display_rotation_default) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.display_rotation_default_);
  }
  _impl_.display_rotation_default_ = display_rotation_default;
  if (display_rotation_default) {
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.display_rotation_default)
}
inline ::enterprise_management::DisplayRotationDefaultProto* ChromeDeviceSettingsProto::release_display_rotation_default() {
  _impl_._has_bits_[1] &= ~0x00000040u;
  ::enterprise_management::DisplayRotationDefaultProto* temp = _impl_.display_rotation_default_;
  _impl_.display_rotation_default_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DisplayRotationDefaultProto* ChromeDeviceSettingsProto::unsafe_arena_release_display_rotation_default() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.display_rotation_default)
  _impl_._has_bits_[1] &= ~0x00000040u;
  ::enterprise_management::DisplayRotationDefaultProto* temp = _impl_.display_rotation_default_;
  _impl_.display_rotation_default_ = nullptr;
  return temp;
}
inline ::enterprise_management::DisplayRotationDefaultProto* ChromeDeviceSettingsProto::_internal_mutable_display_rotation_default() {
  _impl_._has_bits_[1] |= 0x00000040u;
  if (_impl_.display_rotation_default_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DisplayRotationDefaultProto>(GetArenaForAllocation());
    _impl_.display_rotation_default_ = p;
  }
  return _impl_.display_rotation_default_;
}
inline ::enterprise_management::DisplayRotationDefaultProto* ChromeDeviceSettingsProto::mutable_display_rotation_default() {
  ::enterprise_management::DisplayRotationDefaultProto* _msg = _internal_mutable_display_rotation_default();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.display_rotation_default)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_display_rotation_default(::enterprise_management::DisplayRotationDefaultProto* display_rotation_default) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.display_rotation_default_;
  }
  if (display_rotation_default) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(display_rotation_default);
    if (message_arena != submessage_arena) {
      display_rotation_default = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, display_rotation_default, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  _impl_.display_rotation_default_ = display_rotation_default;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.display_rotation_default)
}

// optional .enterprise_management.AllowKioskAppControlChromeVersionProto allow_kiosk_app_control_chrome_version = 40;
inline bool ChromeDeviceSettingsProto::_internal_has_allow_kiosk_app_control_chrome_version() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.allow_kiosk_app_control_chrome_version_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_allow_kiosk_app_control_chrome_version() const {
  return _internal_has_allow_kiosk_app_control_chrome_version();
}
inline void ChromeDeviceSettingsProto::clear_allow_kiosk_app_control_chrome_version() {
  if (_impl_.allow_kiosk_app_control_chrome_version_ != nullptr) _impl_.allow_kiosk_app_control_chrome_version_->Clear();
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline const ::enterprise_management::AllowKioskAppControlChromeVersionProto& ChromeDeviceSettingsProto::_internal_allow_kiosk_app_control_chrome_version() const {
  const ::enterprise_management::AllowKioskAppControlChromeVersionProto* p = _impl_.allow_kiosk_app_control_chrome_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AllowKioskAppControlChromeVersionProto&>(
      ::enterprise_management::_AllowKioskAppControlChromeVersionProto_default_instance_);
}
inline const ::enterprise_management::AllowKioskAppControlChromeVersionProto& ChromeDeviceSettingsProto::allow_kiosk_app_control_chrome_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.allow_kiosk_app_control_chrome_version)
  return _internal_allow_kiosk_app_control_chrome_version();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_allow_kiosk_app_control_chrome_version(
    ::enterprise_management::AllowKioskAppControlChromeVersionProto* allow_kiosk_app_control_chrome_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allow_kiosk_app_control_chrome_version_);
  }
  _impl_.allow_kiosk_app_control_chrome_version_ = allow_kiosk_app_control_chrome_version;
  if (allow_kiosk_app_control_chrome_version) {
    _impl_._has_bits_[1] |= 0x00000080u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.allow_kiosk_app_control_chrome_version)
}
inline ::enterprise_management::AllowKioskAppControlChromeVersionProto* ChromeDeviceSettingsProto::release_allow_kiosk_app_control_chrome_version() {
  _impl_._has_bits_[1] &= ~0x00000080u;
  ::enterprise_management::AllowKioskAppControlChromeVersionProto* temp = _impl_.allow_kiosk_app_control_chrome_version_;
  _impl_.allow_kiosk_app_control_chrome_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AllowKioskAppControlChromeVersionProto* ChromeDeviceSettingsProto::unsafe_arena_release_allow_kiosk_app_control_chrome_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.allow_kiosk_app_control_chrome_version)
  _impl_._has_bits_[1] &= ~0x00000080u;
  ::enterprise_management::AllowKioskAppControlChromeVersionProto* temp = _impl_.allow_kiosk_app_control_chrome_version_;
  _impl_.allow_kiosk_app_control_chrome_version_ = nullptr;
  return temp;
}
inline ::enterprise_management::AllowKioskAppControlChromeVersionProto* ChromeDeviceSettingsProto::_internal_mutable_allow_kiosk_app_control_chrome_version() {
  _impl_._has_bits_[1] |= 0x00000080u;
  if (_impl_.allow_kiosk_app_control_chrome_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AllowKioskAppControlChromeVersionProto>(GetArenaForAllocation());
    _impl_.allow_kiosk_app_control_chrome_version_ = p;
  }
  return _impl_.allow_kiosk_app_control_chrome_version_;
}
inline ::enterprise_management::AllowKioskAppControlChromeVersionProto* ChromeDeviceSettingsProto::mutable_allow_kiosk_app_control_chrome_version() {
  ::enterprise_management::AllowKioskAppControlChromeVersionProto* _msg = _internal_mutable_allow_kiosk_app_control_chrome_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.allow_kiosk_app_control_chrome_version)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_allow_kiosk_app_control_chrome_version(::enterprise_management::AllowKioskAppControlChromeVersionProto* allow_kiosk_app_control_chrome_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allow_kiosk_app_control_chrome_version_;
  }
  if (allow_kiosk_app_control_chrome_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allow_kiosk_app_control_chrome_version);
    if (message_arena != submessage_arena) {
      allow_kiosk_app_control_chrome_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allow_kiosk_app_control_chrome_version, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000080u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000080u;
  }
  _impl_.allow_kiosk_app_control_chrome_version_ = allow_kiosk_app_control_chrome_version;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.allow_kiosk_app_control_chrome_version)
}

// optional .enterprise_management.LoginAuthenticationBehaviorProto login_authentication_behavior = 41;
inline bool ChromeDeviceSettingsProto::_internal_has_login_authentication_behavior() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_authentication_behavior_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_authentication_behavior() const {
  return _internal_has_login_authentication_behavior();
}
inline void ChromeDeviceSettingsProto::clear_login_authentication_behavior() {
  if (_impl_.login_authentication_behavior_ != nullptr) _impl_.login_authentication_behavior_->Clear();
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline const ::enterprise_management::LoginAuthenticationBehaviorProto& ChromeDeviceSettingsProto::_internal_login_authentication_behavior() const {
  const ::enterprise_management::LoginAuthenticationBehaviorProto* p = _impl_.login_authentication_behavior_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LoginAuthenticationBehaviorProto&>(
      ::enterprise_management::_LoginAuthenticationBehaviorProto_default_instance_);
}
inline const ::enterprise_management::LoginAuthenticationBehaviorProto& ChromeDeviceSettingsProto::login_authentication_behavior() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_authentication_behavior)
  return _internal_login_authentication_behavior();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_authentication_behavior(
    ::enterprise_management::LoginAuthenticationBehaviorProto* login_authentication_behavior) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_authentication_behavior_);
  }
  _impl_.login_authentication_behavior_ = login_authentication_behavior;
  if (login_authentication_behavior) {
    _impl_._has_bits_[1] |= 0x00000100u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_authentication_behavior)
}
inline ::enterprise_management::LoginAuthenticationBehaviorProto* ChromeDeviceSettingsProto::release_login_authentication_behavior() {
  _impl_._has_bits_[1] &= ~0x00000100u;
  ::enterprise_management::LoginAuthenticationBehaviorProto* temp = _impl_.login_authentication_behavior_;
  _impl_.login_authentication_behavior_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LoginAuthenticationBehaviorProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_authentication_behavior() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_authentication_behavior)
  _impl_._has_bits_[1] &= ~0x00000100u;
  ::enterprise_management::LoginAuthenticationBehaviorProto* temp = _impl_.login_authentication_behavior_;
  _impl_.login_authentication_behavior_ = nullptr;
  return temp;
}
inline ::enterprise_management::LoginAuthenticationBehaviorProto* ChromeDeviceSettingsProto::_internal_mutable_login_authentication_behavior() {
  _impl_._has_bits_[1] |= 0x00000100u;
  if (_impl_.login_authentication_behavior_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LoginAuthenticationBehaviorProto>(GetArenaForAllocation());
    _impl_.login_authentication_behavior_ = p;
  }
  return _impl_.login_authentication_behavior_;
}
inline ::enterprise_management::LoginAuthenticationBehaviorProto* ChromeDeviceSettingsProto::mutable_login_authentication_behavior() {
  ::enterprise_management::LoginAuthenticationBehaviorProto* _msg = _internal_mutable_login_authentication_behavior();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_authentication_behavior)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_authentication_behavior(::enterprise_management::LoginAuthenticationBehaviorProto* login_authentication_behavior) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_authentication_behavior_;
  }
  if (login_authentication_behavior) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_authentication_behavior);
    if (message_arena != submessage_arena) {
      login_authentication_behavior = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_authentication_behavior, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000100u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000100u;
  }
  _impl_.login_authentication_behavior_ = login_authentication_behavior;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_authentication_behavior)
}

// optional .enterprise_management.UsbDetachableWhitelistProto usb_detachable_whitelist = 42;
inline bool ChromeDeviceSettingsProto::_internal_has_usb_detachable_whitelist() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.usb_detachable_whitelist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_usb_detachable_whitelist() const {
  return _internal_has_usb_detachable_whitelist();
}
inline void ChromeDeviceSettingsProto::clear_usb_detachable_whitelist() {
  if (_impl_.usb_detachable_whitelist_ != nullptr) _impl_.usb_detachable_whitelist_->Clear();
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline const ::enterprise_management::UsbDetachableWhitelistProto& ChromeDeviceSettingsProto::_internal_usb_detachable_whitelist() const {
  const ::enterprise_management::UsbDetachableWhitelistProto* p = _impl_.usb_detachable_whitelist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::UsbDetachableWhitelistProto&>(
      ::enterprise_management::_UsbDetachableWhitelistProto_default_instance_);
}
inline const ::enterprise_management::UsbDetachableWhitelistProto& ChromeDeviceSettingsProto::usb_detachable_whitelist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_whitelist)
  return _internal_usb_detachable_whitelist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_usb_detachable_whitelist(
    ::enterprise_management::UsbDetachableWhitelistProto* usb_detachable_whitelist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usb_detachable_whitelist_);
  }
  _impl_.usb_detachable_whitelist_ = usb_detachable_whitelist;
  if (usb_detachable_whitelist) {
    _impl_._has_bits_[1] |= 0x00000200u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_whitelist)
}
inline ::enterprise_management::UsbDetachableWhitelistProto* ChromeDeviceSettingsProto::release_usb_detachable_whitelist() {
  _impl_._has_bits_[1] &= ~0x00000200u;
  ::enterprise_management::UsbDetachableWhitelistProto* temp = _impl_.usb_detachable_whitelist_;
  _impl_.usb_detachable_whitelist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::UsbDetachableWhitelistProto* ChromeDeviceSettingsProto::unsafe_arena_release_usb_detachable_whitelist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_whitelist)
  _impl_._has_bits_[1] &= ~0x00000200u;
  ::enterprise_management::UsbDetachableWhitelistProto* temp = _impl_.usb_detachable_whitelist_;
  _impl_.usb_detachable_whitelist_ = nullptr;
  return temp;
}
inline ::enterprise_management::UsbDetachableWhitelistProto* ChromeDeviceSettingsProto::_internal_mutable_usb_detachable_whitelist() {
  _impl_._has_bits_[1] |= 0x00000200u;
  if (_impl_.usb_detachable_whitelist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::UsbDetachableWhitelistProto>(GetArenaForAllocation());
    _impl_.usb_detachable_whitelist_ = p;
  }
  return _impl_.usb_detachable_whitelist_;
}
inline ::enterprise_management::UsbDetachableWhitelistProto* ChromeDeviceSettingsProto::mutable_usb_detachable_whitelist() {
  ::enterprise_management::UsbDetachableWhitelistProto* _msg = _internal_mutable_usb_detachable_whitelist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_whitelist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_usb_detachable_whitelist(::enterprise_management::UsbDetachableWhitelistProto* usb_detachable_whitelist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.usb_detachable_whitelist_;
  }
  if (usb_detachable_whitelist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(usb_detachable_whitelist);
    if (message_arena != submessage_arena) {
      usb_detachable_whitelist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usb_detachable_whitelist, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000200u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000200u;
  }
  _impl_.usb_detachable_whitelist_ = usb_detachable_whitelist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_whitelist)
}

// optional .enterprise_management.AllowBluetoothProto allow_bluetooth = 43;
inline bool ChromeDeviceSettingsProto::_internal_has_allow_bluetooth() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.allow_bluetooth_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_allow_bluetooth() const {
  return _internal_has_allow_bluetooth();
}
inline void ChromeDeviceSettingsProto::clear_allow_bluetooth() {
  if (_impl_.allow_bluetooth_ != nullptr) _impl_.allow_bluetooth_->Clear();
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline const ::enterprise_management::AllowBluetoothProto& ChromeDeviceSettingsProto::_internal_allow_bluetooth() const {
  const ::enterprise_management::AllowBluetoothProto* p = _impl_.allow_bluetooth_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AllowBluetoothProto&>(
      ::enterprise_management::_AllowBluetoothProto_default_instance_);
}
inline const ::enterprise_management::AllowBluetoothProto& ChromeDeviceSettingsProto::allow_bluetooth() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.allow_bluetooth)
  return _internal_allow_bluetooth();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_allow_bluetooth(
    ::enterprise_management::AllowBluetoothProto* allow_bluetooth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allow_bluetooth_);
  }
  _impl_.allow_bluetooth_ = allow_bluetooth;
  if (allow_bluetooth) {
    _impl_._has_bits_[1] |= 0x00000400u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.allow_bluetooth)
}
inline ::enterprise_management::AllowBluetoothProto* ChromeDeviceSettingsProto::release_allow_bluetooth() {
  _impl_._has_bits_[1] &= ~0x00000400u;
  ::enterprise_management::AllowBluetoothProto* temp = _impl_.allow_bluetooth_;
  _impl_.allow_bluetooth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AllowBluetoothProto* ChromeDeviceSettingsProto::unsafe_arena_release_allow_bluetooth() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.allow_bluetooth)
  _impl_._has_bits_[1] &= ~0x00000400u;
  ::enterprise_management::AllowBluetoothProto* temp = _impl_.allow_bluetooth_;
  _impl_.allow_bluetooth_ = nullptr;
  return temp;
}
inline ::enterprise_management::AllowBluetoothProto* ChromeDeviceSettingsProto::_internal_mutable_allow_bluetooth() {
  _impl_._has_bits_[1] |= 0x00000400u;
  if (_impl_.allow_bluetooth_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AllowBluetoothProto>(GetArenaForAllocation());
    _impl_.allow_bluetooth_ = p;
  }
  return _impl_.allow_bluetooth_;
}
inline ::enterprise_management::AllowBluetoothProto* ChromeDeviceSettingsProto::mutable_allow_bluetooth() {
  ::enterprise_management::AllowBluetoothProto* _msg = _internal_mutable_allow_bluetooth();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.allow_bluetooth)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_allow_bluetooth(::enterprise_management::AllowBluetoothProto* allow_bluetooth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allow_bluetooth_;
  }
  if (allow_bluetooth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allow_bluetooth);
    if (message_arena != submessage_arena) {
      allow_bluetooth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allow_bluetooth, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000400u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000400u;
  }
  _impl_.allow_bluetooth_ = allow_bluetooth;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.allow_bluetooth)
}

// optional .enterprise_management.DeviceQuirksDownloadEnabledProto quirks_download_enabled = 44;
inline bool ChromeDeviceSettingsProto::_internal_has_quirks_download_enabled() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quirks_download_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_quirks_download_enabled() const {
  return _internal_has_quirks_download_enabled();
}
inline void ChromeDeviceSettingsProto::clear_quirks_download_enabled() {
  if (_impl_.quirks_download_enabled_ != nullptr) _impl_.quirks_download_enabled_->Clear();
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline const ::enterprise_management::DeviceQuirksDownloadEnabledProto& ChromeDeviceSettingsProto::_internal_quirks_download_enabled() const {
  const ::enterprise_management::DeviceQuirksDownloadEnabledProto* p = _impl_.quirks_download_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceQuirksDownloadEnabledProto&>(
      ::enterprise_management::_DeviceQuirksDownloadEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceQuirksDownloadEnabledProto& ChromeDeviceSettingsProto::quirks_download_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.quirks_download_enabled)
  return _internal_quirks_download_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_quirks_download_enabled(
    ::enterprise_management::DeviceQuirksDownloadEnabledProto* quirks_download_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quirks_download_enabled_);
  }
  _impl_.quirks_download_enabled_ = quirks_download_enabled;
  if (quirks_download_enabled) {
    _impl_._has_bits_[1] |= 0x00000800u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.quirks_download_enabled)
}
inline ::enterprise_management::DeviceQuirksDownloadEnabledProto* ChromeDeviceSettingsProto::release_quirks_download_enabled() {
  _impl_._has_bits_[1] &= ~0x00000800u;
  ::enterprise_management::DeviceQuirksDownloadEnabledProto* temp = _impl_.quirks_download_enabled_;
  _impl_.quirks_download_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceQuirksDownloadEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_quirks_download_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.quirks_download_enabled)
  _impl_._has_bits_[1] &= ~0x00000800u;
  ::enterprise_management::DeviceQuirksDownloadEnabledProto* temp = _impl_.quirks_download_enabled_;
  _impl_.quirks_download_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceQuirksDownloadEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_quirks_download_enabled() {
  _impl_._has_bits_[1] |= 0x00000800u;
  if (_impl_.quirks_download_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceQuirksDownloadEnabledProto>(GetArenaForAllocation());
    _impl_.quirks_download_enabled_ = p;
  }
  return _impl_.quirks_download_enabled_;
}
inline ::enterprise_management::DeviceQuirksDownloadEnabledProto* ChromeDeviceSettingsProto::mutable_quirks_download_enabled() {
  ::enterprise_management::DeviceQuirksDownloadEnabledProto* _msg = _internal_mutable_quirks_download_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.quirks_download_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_quirks_download_enabled(::enterprise_management::DeviceQuirksDownloadEnabledProto* quirks_download_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quirks_download_enabled_;
  }
  if (quirks_download_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quirks_download_enabled);
    if (message_arena != submessage_arena) {
      quirks_download_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quirks_download_enabled, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000800u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000800u;
  }
  _impl_.quirks_download_enabled_ = quirks_download_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.quirks_download_enabled)
}

// optional .enterprise_management.LoginVideoCaptureAllowedUrlsProto login_video_capture_allowed_urls = 45;
inline bool ChromeDeviceSettingsProto::_internal_has_login_video_capture_allowed_urls() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_video_capture_allowed_urls_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_video_capture_allowed_urls() const {
  return _internal_has_login_video_capture_allowed_urls();
}
inline void ChromeDeviceSettingsProto::clear_login_video_capture_allowed_urls() {
  if (_impl_.login_video_capture_allowed_urls_ != nullptr) _impl_.login_video_capture_allowed_urls_->Clear();
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline const ::enterprise_management::LoginVideoCaptureAllowedUrlsProto& ChromeDeviceSettingsProto::_internal_login_video_capture_allowed_urls() const {
  const ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* p = _impl_.login_video_capture_allowed_urls_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LoginVideoCaptureAllowedUrlsProto&>(
      ::enterprise_management::_LoginVideoCaptureAllowedUrlsProto_default_instance_);
}
inline const ::enterprise_management::LoginVideoCaptureAllowedUrlsProto& ChromeDeviceSettingsProto::login_video_capture_allowed_urls() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_video_capture_allowed_urls)
  return _internal_login_video_capture_allowed_urls();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_video_capture_allowed_urls(
    ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* login_video_capture_allowed_urls) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_video_capture_allowed_urls_);
  }
  _impl_.login_video_capture_allowed_urls_ = login_video_capture_allowed_urls;
  if (login_video_capture_allowed_urls) {
    _impl_._has_bits_[1] |= 0x00001000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_video_capture_allowed_urls)
}
inline ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* ChromeDeviceSettingsProto::release_login_video_capture_allowed_urls() {
  _impl_._has_bits_[1] &= ~0x00001000u;
  ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* temp = _impl_.login_video_capture_allowed_urls_;
  _impl_.login_video_capture_allowed_urls_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_video_capture_allowed_urls() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_video_capture_allowed_urls)
  _impl_._has_bits_[1] &= ~0x00001000u;
  ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* temp = _impl_.login_video_capture_allowed_urls_;
  _impl_.login_video_capture_allowed_urls_ = nullptr;
  return temp;
}
inline ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* ChromeDeviceSettingsProto::_internal_mutable_login_video_capture_allowed_urls() {
  _impl_._has_bits_[1] |= 0x00001000u;
  if (_impl_.login_video_capture_allowed_urls_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LoginVideoCaptureAllowedUrlsProto>(GetArenaForAllocation());
    _impl_.login_video_capture_allowed_urls_ = p;
  }
  return _impl_.login_video_capture_allowed_urls_;
}
inline ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* ChromeDeviceSettingsProto::mutable_login_video_capture_allowed_urls() {
  ::enterprise_management::LoginVideoCaptureAllowedUrlsProto* _msg = _internal_mutable_login_video_capture_allowed_urls();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_video_capture_allowed_urls)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_video_capture_allowed_urls(::enterprise_management::LoginVideoCaptureAllowedUrlsProto* login_video_capture_allowed_urls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_video_capture_allowed_urls_;
  }
  if (login_video_capture_allowed_urls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_video_capture_allowed_urls);
    if (message_arena != submessage_arena) {
      login_video_capture_allowed_urls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_video_capture_allowed_urls, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00001000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00001000u;
  }
  _impl_.login_video_capture_allowed_urls_ = login_video_capture_allowed_urls;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_video_capture_allowed_urls)
}

// optional .enterprise_management.DeviceLoginScreenExtensionsProto device_login_screen_extensions = 46;
inline bool ChromeDeviceSettingsProto::_internal_has_device_login_screen_extensions() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_login_screen_extensions_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_login_screen_extensions() const {
  return _internal_has_device_login_screen_extensions();
}
inline void ChromeDeviceSettingsProto::clear_device_login_screen_extensions() {
  if (_impl_.device_login_screen_extensions_ != nullptr) _impl_.device_login_screen_extensions_->Clear();
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline const ::enterprise_management::DeviceLoginScreenExtensionsProto& ChromeDeviceSettingsProto::_internal_device_login_screen_extensions() const {
  const ::enterprise_management::DeviceLoginScreenExtensionsProto* p = _impl_.device_login_screen_extensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceLoginScreenExtensionsProto&>(
      ::enterprise_management::_DeviceLoginScreenExtensionsProto_default_instance_);
}
inline const ::enterprise_management::DeviceLoginScreenExtensionsProto& ChromeDeviceSettingsProto::device_login_screen_extensions() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_extensions)
  return _internal_device_login_screen_extensions();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_login_screen_extensions(
    ::enterprise_management::DeviceLoginScreenExtensionsProto* device_login_screen_extensions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_extensions_);
  }
  _impl_.device_login_screen_extensions_ = device_login_screen_extensions;
  if (device_login_screen_extensions) {
    _impl_._has_bits_[1] |= 0x00002000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_extensions)
}
inline ::enterprise_management::DeviceLoginScreenExtensionsProto* ChromeDeviceSettingsProto::release_device_login_screen_extensions() {
  _impl_._has_bits_[1] &= ~0x00002000u;
  ::enterprise_management::DeviceLoginScreenExtensionsProto* temp = _impl_.device_login_screen_extensions_;
  _impl_.device_login_screen_extensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenExtensionsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_login_screen_extensions() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_extensions)
  _impl_._has_bits_[1] &= ~0x00002000u;
  ::enterprise_management::DeviceLoginScreenExtensionsProto* temp = _impl_.device_login_screen_extensions_;
  _impl_.device_login_screen_extensions_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenExtensionsProto* ChromeDeviceSettingsProto::_internal_mutable_device_login_screen_extensions() {
  _impl_._has_bits_[1] |= 0x00002000u;
  if (_impl_.device_login_screen_extensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceLoginScreenExtensionsProto>(GetArenaForAllocation());
    _impl_.device_login_screen_extensions_ = p;
  }
  return _impl_.device_login_screen_extensions_;
}
inline ::enterprise_management::DeviceLoginScreenExtensionsProto* ChromeDeviceSettingsProto::mutable_device_login_screen_extensions() {
  ::enterprise_management::DeviceLoginScreenExtensionsProto* _msg = _internal_mutable_device_login_screen_extensions();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_extensions)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_login_screen_extensions(::enterprise_management::DeviceLoginScreenExtensionsProto* device_login_screen_extensions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_login_screen_extensions_;
  }
  if (device_login_screen_extensions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_login_screen_extensions);
    if (message_arena != submessage_arena) {
      device_login_screen_extensions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_login_screen_extensions, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00002000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00002000u;
  }
  _impl_.device_login_screen_extensions_ = device_login_screen_extensions;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_extensions)
}

// optional .enterprise_management.NetworkThrottlingEnabledProto network_throttling = 47;
inline bool ChromeDeviceSettingsProto::_internal_has_network_throttling() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.network_throttling_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_network_throttling() const {
  return _internal_has_network_throttling();
}
inline void ChromeDeviceSettingsProto::clear_network_throttling() {
  if (_impl_.network_throttling_ != nullptr) _impl_.network_throttling_->Clear();
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline const ::enterprise_management::NetworkThrottlingEnabledProto& ChromeDeviceSettingsProto::_internal_network_throttling() const {
  const ::enterprise_management::NetworkThrottlingEnabledProto* p = _impl_.network_throttling_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::NetworkThrottlingEnabledProto&>(
      ::enterprise_management::_NetworkThrottlingEnabledProto_default_instance_);
}
inline const ::enterprise_management::NetworkThrottlingEnabledProto& ChromeDeviceSettingsProto::network_throttling() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.network_throttling)
  return _internal_network_throttling();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_network_throttling(
    ::enterprise_management::NetworkThrottlingEnabledProto* network_throttling) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.network_throttling_);
  }
  _impl_.network_throttling_ = network_throttling;
  if (network_throttling) {
    _impl_._has_bits_[1] |= 0x00004000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.network_throttling)
}
inline ::enterprise_management::NetworkThrottlingEnabledProto* ChromeDeviceSettingsProto::release_network_throttling() {
  _impl_._has_bits_[1] &= ~0x00004000u;
  ::enterprise_management::NetworkThrottlingEnabledProto* temp = _impl_.network_throttling_;
  _impl_.network_throttling_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::NetworkThrottlingEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_network_throttling() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.network_throttling)
  _impl_._has_bits_[1] &= ~0x00004000u;
  ::enterprise_management::NetworkThrottlingEnabledProto* temp = _impl_.network_throttling_;
  _impl_.network_throttling_ = nullptr;
  return temp;
}
inline ::enterprise_management::NetworkThrottlingEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_network_throttling() {
  _impl_._has_bits_[1] |= 0x00004000u;
  if (_impl_.network_throttling_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::NetworkThrottlingEnabledProto>(GetArenaForAllocation());
    _impl_.network_throttling_ = p;
  }
  return _impl_.network_throttling_;
}
inline ::enterprise_management::NetworkThrottlingEnabledProto* ChromeDeviceSettingsProto::mutable_network_throttling() {
  ::enterprise_management::NetworkThrottlingEnabledProto* _msg = _internal_mutable_network_throttling();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.network_throttling)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_network_throttling(::enterprise_management::NetworkThrottlingEnabledProto* network_throttling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.network_throttling_;
  }
  if (network_throttling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network_throttling);
    if (message_arena != submessage_arena) {
      network_throttling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_throttling, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00004000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00004000u;
  }
  _impl_.network_throttling_ = network_throttling;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.network_throttling)
}

// optional .enterprise_management.DeviceWallpaperImageProto device_wallpaper_image = 48;
inline bool ChromeDeviceSettingsProto::_internal_has_device_wallpaper_image() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_wallpaper_image_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_wallpaper_image() const {
  return _internal_has_device_wallpaper_image();
}
inline void ChromeDeviceSettingsProto::clear_device_wallpaper_image() {
  if (_impl_.device_wallpaper_image_ != nullptr) _impl_.device_wallpaper_image_->Clear();
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline const ::enterprise_management::DeviceWallpaperImageProto& ChromeDeviceSettingsProto::_internal_device_wallpaper_image() const {
  const ::enterprise_management::DeviceWallpaperImageProto* p = _impl_.device_wallpaper_image_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceWallpaperImageProto&>(
      ::enterprise_management::_DeviceWallpaperImageProto_default_instance_);
}
inline const ::enterprise_management::DeviceWallpaperImageProto& ChromeDeviceSettingsProto::device_wallpaper_image() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_wallpaper_image)
  return _internal_device_wallpaper_image();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_wallpaper_image(
    ::enterprise_management::DeviceWallpaperImageProto* device_wallpaper_image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_wallpaper_image_);
  }
  _impl_.device_wallpaper_image_ = device_wallpaper_image;
  if (device_wallpaper_image) {
    _impl_._has_bits_[1] |= 0x00008000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wallpaper_image)
}
inline ::enterprise_management::DeviceWallpaperImageProto* ChromeDeviceSettingsProto::release_device_wallpaper_image() {
  _impl_._has_bits_[1] &= ~0x00008000u;
  ::enterprise_management::DeviceWallpaperImageProto* temp = _impl_.device_wallpaper_image_;
  _impl_.device_wallpaper_image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceWallpaperImageProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_wallpaper_image() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_wallpaper_image)
  _impl_._has_bits_[1] &= ~0x00008000u;
  ::enterprise_management::DeviceWallpaperImageProto* temp = _impl_.device_wallpaper_image_;
  _impl_.device_wallpaper_image_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceWallpaperImageProto* ChromeDeviceSettingsProto::_internal_mutable_device_wallpaper_image() {
  _impl_._has_bits_[1] |= 0x00008000u;
  if (_impl_.device_wallpaper_image_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceWallpaperImageProto>(GetArenaForAllocation());
    _impl_.device_wallpaper_image_ = p;
  }
  return _impl_.device_wallpaper_image_;
}
inline ::enterprise_management::DeviceWallpaperImageProto* ChromeDeviceSettingsProto::mutable_device_wallpaper_image() {
  ::enterprise_management::DeviceWallpaperImageProto* _msg = _internal_mutable_device_wallpaper_image();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_wallpaper_image)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_wallpaper_image(::enterprise_management::DeviceWallpaperImageProto* device_wallpaper_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_wallpaper_image_;
  }
  if (device_wallpaper_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_wallpaper_image);
    if (message_arena != submessage_arena) {
      device_wallpaper_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_wallpaper_image, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00008000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00008000u;
  }
  _impl_.device_wallpaper_image_ = device_wallpaper_image;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wallpaper_image)
}

// optional .enterprise_management.LoginScreenLocalesProto login_screen_locales = 49;
inline bool ChromeDeviceSettingsProto::_internal_has_login_screen_locales() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_locales_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_screen_locales() const {
  return _internal_has_login_screen_locales();
}
inline void ChromeDeviceSettingsProto::clear_login_screen_locales() {
  if (_impl_.login_screen_locales_ != nullptr) _impl_.login_screen_locales_->Clear();
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline const ::enterprise_management::LoginScreenLocalesProto& ChromeDeviceSettingsProto::_internal_login_screen_locales() const {
  const ::enterprise_management::LoginScreenLocalesProto* p = _impl_.login_screen_locales_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LoginScreenLocalesProto&>(
      ::enterprise_management::_LoginScreenLocalesProto_default_instance_);
}
inline const ::enterprise_management::LoginScreenLocalesProto& ChromeDeviceSettingsProto::login_screen_locales() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_screen_locales)
  return _internal_login_screen_locales();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_screen_locales(
    ::enterprise_management::LoginScreenLocalesProto* login_screen_locales) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_locales_);
  }
  _impl_.login_screen_locales_ = login_screen_locales;
  if (login_screen_locales) {
    _impl_._has_bits_[1] |= 0x00010000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_locales)
}
inline ::enterprise_management::LoginScreenLocalesProto* ChromeDeviceSettingsProto::release_login_screen_locales() {
  _impl_._has_bits_[1] &= ~0x00010000u;
  ::enterprise_management::LoginScreenLocalesProto* temp = _impl_.login_screen_locales_;
  _impl_.login_screen_locales_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LoginScreenLocalesProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_screen_locales() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_screen_locales)
  _impl_._has_bits_[1] &= ~0x00010000u;
  ::enterprise_management::LoginScreenLocalesProto* temp = _impl_.login_screen_locales_;
  _impl_.login_screen_locales_ = nullptr;
  return temp;
}
inline ::enterprise_management::LoginScreenLocalesProto* ChromeDeviceSettingsProto::_internal_mutable_login_screen_locales() {
  _impl_._has_bits_[1] |= 0x00010000u;
  if (_impl_.login_screen_locales_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LoginScreenLocalesProto>(GetArenaForAllocation());
    _impl_.login_screen_locales_ = p;
  }
  return _impl_.login_screen_locales_;
}
inline ::enterprise_management::LoginScreenLocalesProto* ChromeDeviceSettingsProto::mutable_login_screen_locales() {
  ::enterprise_management::LoginScreenLocalesProto* _msg = _internal_mutable_login_screen_locales();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_screen_locales)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_screen_locales(::enterprise_management::LoginScreenLocalesProto* login_screen_locales) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_screen_locales_;
  }
  if (login_screen_locales) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_screen_locales);
    if (message_arena != submessage_arena) {
      login_screen_locales = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_locales, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00010000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00010000u;
  }
  _impl_.login_screen_locales_ = login_screen_locales;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_locales)
}

// optional .enterprise_management.LoginScreenInputMethodsProto login_screen_input_methods = 50;
inline bool ChromeDeviceSettingsProto::_internal_has_login_screen_input_methods() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_input_methods_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_screen_input_methods() const {
  return _internal_has_login_screen_input_methods();
}
inline void ChromeDeviceSettingsProto::clear_login_screen_input_methods() {
  if (_impl_.login_screen_input_methods_ != nullptr) _impl_.login_screen_input_methods_->Clear();
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline const ::enterprise_management::LoginScreenInputMethodsProto& ChromeDeviceSettingsProto::_internal_login_screen_input_methods() const {
  const ::enterprise_management::LoginScreenInputMethodsProto* p = _impl_.login_screen_input_methods_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LoginScreenInputMethodsProto&>(
      ::enterprise_management::_LoginScreenInputMethodsProto_default_instance_);
}
inline const ::enterprise_management::LoginScreenInputMethodsProto& ChromeDeviceSettingsProto::login_screen_input_methods() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_screen_input_methods)
  return _internal_login_screen_input_methods();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_screen_input_methods(
    ::enterprise_management::LoginScreenInputMethodsProto* login_screen_input_methods) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_input_methods_);
  }
  _impl_.login_screen_input_methods_ = login_screen_input_methods;
  if (login_screen_input_methods) {
    _impl_._has_bits_[1] |= 0x00020000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_input_methods)
}
inline ::enterprise_management::LoginScreenInputMethodsProto* ChromeDeviceSettingsProto::release_login_screen_input_methods() {
  _impl_._has_bits_[1] &= ~0x00020000u;
  ::enterprise_management::LoginScreenInputMethodsProto* temp = _impl_.login_screen_input_methods_;
  _impl_.login_screen_input_methods_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LoginScreenInputMethodsProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_screen_input_methods() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_screen_input_methods)
  _impl_._has_bits_[1] &= ~0x00020000u;
  ::enterprise_management::LoginScreenInputMethodsProto* temp = _impl_.login_screen_input_methods_;
  _impl_.login_screen_input_methods_ = nullptr;
  return temp;
}
inline ::enterprise_management::LoginScreenInputMethodsProto* ChromeDeviceSettingsProto::_internal_mutable_login_screen_input_methods() {
  _impl_._has_bits_[1] |= 0x00020000u;
  if (_impl_.login_screen_input_methods_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LoginScreenInputMethodsProto>(GetArenaForAllocation());
    _impl_.login_screen_input_methods_ = p;
  }
  return _impl_.login_screen_input_methods_;
}
inline ::enterprise_management::LoginScreenInputMethodsProto* ChromeDeviceSettingsProto::mutable_login_screen_input_methods() {
  ::enterprise_management::LoginScreenInputMethodsProto* _msg = _internal_mutable_login_screen_input_methods();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_screen_input_methods)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_screen_input_methods(::enterprise_management::LoginScreenInputMethodsProto* login_screen_input_methods) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_screen_input_methods_;
  }
  if (login_screen_input_methods) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_screen_input_methods);
    if (message_arena != submessage_arena) {
      login_screen_input_methods = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_input_methods, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00020000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00020000u;
  }
  _impl_.login_screen_input_methods_ = login_screen_input_methods;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_input_methods)
}

// optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto device_ecryptfs_migration_strategy = 51 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_device_ecryptfs_migration_strategy() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ecryptfs_migration_strategy_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_ecryptfs_migration_strategy() const {
  return _internal_has_device_ecryptfs_migration_strategy();
}
inline void ChromeDeviceSettingsProto::clear_device_ecryptfs_migration_strategy() {
  if (_impl_.device_ecryptfs_migration_strategy_ != nullptr) _impl_.device_ecryptfs_migration_strategy_->Clear();
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline const ::enterprise_management::DeviceEcryptfsMigrationStrategyProto& ChromeDeviceSettingsProto::_internal_device_ecryptfs_migration_strategy() const {
  const ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* p = _impl_.device_ecryptfs_migration_strategy_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceEcryptfsMigrationStrategyProto&>(
      ::enterprise_management::_DeviceEcryptfsMigrationStrategyProto_default_instance_);
}
inline const ::enterprise_management::DeviceEcryptfsMigrationStrategyProto& ChromeDeviceSettingsProto::device_ecryptfs_migration_strategy() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_ecryptfs_migration_strategy)
  return _internal_device_ecryptfs_migration_strategy();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_ecryptfs_migration_strategy(
    ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* device_ecryptfs_migration_strategy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_ecryptfs_migration_strategy_);
  }
  _impl_.device_ecryptfs_migration_strategy_ = device_ecryptfs_migration_strategy;
  if (device_ecryptfs_migration_strategy) {
    _impl_._has_bits_[1] |= 0x00040000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_ecryptfs_migration_strategy)
}
inline ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* ChromeDeviceSettingsProto::release_device_ecryptfs_migration_strategy() {
  _impl_._has_bits_[1] &= ~0x00040000u;
  ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* temp = _impl_.device_ecryptfs_migration_strategy_;
  _impl_.device_ecryptfs_migration_strategy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_ecryptfs_migration_strategy() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_ecryptfs_migration_strategy)
  _impl_._has_bits_[1] &= ~0x00040000u;
  ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* temp = _impl_.device_ecryptfs_migration_strategy_;
  _impl_.device_ecryptfs_migration_strategy_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* ChromeDeviceSettingsProto::_internal_mutable_device_ecryptfs_migration_strategy() {
  _impl_._has_bits_[1] |= 0x00040000u;
  if (_impl_.device_ecryptfs_migration_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceEcryptfsMigrationStrategyProto>(GetArenaForAllocation());
    _impl_.device_ecryptfs_migration_strategy_ = p;
  }
  return _impl_.device_ecryptfs_migration_strategy_;
}
inline ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* ChromeDeviceSettingsProto::mutable_device_ecryptfs_migration_strategy() {
  ::enterprise_management::DeviceEcryptfsMigrationStrategyProto* _msg = _internal_mutable_device_ecryptfs_migration_strategy();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_ecryptfs_migration_strategy)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_ecryptfs_migration_strategy(::enterprise_management::DeviceEcryptfsMigrationStrategyProto* device_ecryptfs_migration_strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_ecryptfs_migration_strategy_;
  }
  if (device_ecryptfs_migration_strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_ecryptfs_migration_strategy);
    if (message_arena != submessage_arena) {
      device_ecryptfs_migration_strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_ecryptfs_migration_strategy, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00040000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00040000u;
  }
  _impl_.device_ecryptfs_migration_strategy_ = device_ecryptfs_migration_strategy;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_ecryptfs_migration_strategy)
}

// optional .enterprise_management.DeviceSecondFactorAuthenticationProto device_second_factor_authentication = 52;
inline bool ChromeDeviceSettingsProto::_internal_has_device_second_factor_authentication() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_second_factor_authentication_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_second_factor_authentication() const {
  return _internal_has_device_second_factor_authentication();
}
inline void ChromeDeviceSettingsProto::clear_device_second_factor_authentication() {
  if (_impl_.device_second_factor_authentication_ != nullptr) _impl_.device_second_factor_authentication_->Clear();
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline const ::enterprise_management::DeviceSecondFactorAuthenticationProto& ChromeDeviceSettingsProto::_internal_device_second_factor_authentication() const {
  const ::enterprise_management::DeviceSecondFactorAuthenticationProto* p = _impl_.device_second_factor_authentication_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceSecondFactorAuthenticationProto&>(
      ::enterprise_management::_DeviceSecondFactorAuthenticationProto_default_instance_);
}
inline const ::enterprise_management::DeviceSecondFactorAuthenticationProto& ChromeDeviceSettingsProto::device_second_factor_authentication() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_second_factor_authentication)
  return _internal_device_second_factor_authentication();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_second_factor_authentication(
    ::enterprise_management::DeviceSecondFactorAuthenticationProto* device_second_factor_authentication) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_second_factor_authentication_);
  }
  _impl_.device_second_factor_authentication_ = device_second_factor_authentication;
  if (device_second_factor_authentication) {
    _impl_._has_bits_[1] |= 0x00080000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_second_factor_authentication)
}
inline ::enterprise_management::DeviceSecondFactorAuthenticationProto* ChromeDeviceSettingsProto::release_device_second_factor_authentication() {
  _impl_._has_bits_[1] &= ~0x00080000u;
  ::enterprise_management::DeviceSecondFactorAuthenticationProto* temp = _impl_.device_second_factor_authentication_;
  _impl_.device_second_factor_authentication_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceSecondFactorAuthenticationProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_second_factor_authentication() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_second_factor_authentication)
  _impl_._has_bits_[1] &= ~0x00080000u;
  ::enterprise_management::DeviceSecondFactorAuthenticationProto* temp = _impl_.device_second_factor_authentication_;
  _impl_.device_second_factor_authentication_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceSecondFactorAuthenticationProto* ChromeDeviceSettingsProto::_internal_mutable_device_second_factor_authentication() {
  _impl_._has_bits_[1] |= 0x00080000u;
  if (_impl_.device_second_factor_authentication_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceSecondFactorAuthenticationProto>(GetArenaForAllocation());
    _impl_.device_second_factor_authentication_ = p;
  }
  return _impl_.device_second_factor_authentication_;
}
inline ::enterprise_management::DeviceSecondFactorAuthenticationProto* ChromeDeviceSettingsProto::mutable_device_second_factor_authentication() {
  ::enterprise_management::DeviceSecondFactorAuthenticationProto* _msg = _internal_mutable_device_second_factor_authentication();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_second_factor_authentication)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_second_factor_authentication(::enterprise_management::DeviceSecondFactorAuthenticationProto* device_second_factor_authentication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_second_factor_authentication_;
  }
  if (device_second_factor_authentication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_second_factor_authentication);
    if (message_arena != submessage_arena) {
      device_second_factor_authentication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_second_factor_authentication, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00080000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00080000u;
  }
  _impl_.device_second_factor_authentication_ = device_second_factor_authentication;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_second_factor_authentication)
}

// optional .enterprise_management.CastReceiverNameProto cast_receiver_name = 53;
inline bool ChromeDeviceSettingsProto::_internal_has_cast_receiver_name() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cast_receiver_name_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_cast_receiver_name() const {
  return _internal_has_cast_receiver_name();
}
inline void ChromeDeviceSettingsProto::clear_cast_receiver_name() {
  if (_impl_.cast_receiver_name_ != nullptr) _impl_.cast_receiver_name_->Clear();
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline const ::enterprise_management::CastReceiverNameProto& ChromeDeviceSettingsProto::_internal_cast_receiver_name() const {
  const ::enterprise_management::CastReceiverNameProto* p = _impl_.cast_receiver_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CastReceiverNameProto&>(
      ::enterprise_management::_CastReceiverNameProto_default_instance_);
}
inline const ::enterprise_management::CastReceiverNameProto& ChromeDeviceSettingsProto::cast_receiver_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.cast_receiver_name)
  return _internal_cast_receiver_name();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_cast_receiver_name(
    ::enterprise_management::CastReceiverNameProto* cast_receiver_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cast_receiver_name_);
  }
  _impl_.cast_receiver_name_ = cast_receiver_name;
  if (cast_receiver_name) {
    _impl_._has_bits_[1] |= 0x00100000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.cast_receiver_name)
}
inline ::enterprise_management::CastReceiverNameProto* ChromeDeviceSettingsProto::release_cast_receiver_name() {
  _impl_._has_bits_[1] &= ~0x00100000u;
  ::enterprise_management::CastReceiverNameProto* temp = _impl_.cast_receiver_name_;
  _impl_.cast_receiver_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CastReceiverNameProto* ChromeDeviceSettingsProto::unsafe_arena_release_cast_receiver_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.cast_receiver_name)
  _impl_._has_bits_[1] &= ~0x00100000u;
  ::enterprise_management::CastReceiverNameProto* temp = _impl_.cast_receiver_name_;
  _impl_.cast_receiver_name_ = nullptr;
  return temp;
}
inline ::enterprise_management::CastReceiverNameProto* ChromeDeviceSettingsProto::_internal_mutable_cast_receiver_name() {
  _impl_._has_bits_[1] |= 0x00100000u;
  if (_impl_.cast_receiver_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CastReceiverNameProto>(GetArenaForAllocation());
    _impl_.cast_receiver_name_ = p;
  }
  return _impl_.cast_receiver_name_;
}
inline ::enterprise_management::CastReceiverNameProto* ChromeDeviceSettingsProto::mutable_cast_receiver_name() {
  ::enterprise_management::CastReceiverNameProto* _msg = _internal_mutable_cast_receiver_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.cast_receiver_name)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_cast_receiver_name(::enterprise_management::CastReceiverNameProto* cast_receiver_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cast_receiver_name_;
  }
  if (cast_receiver_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cast_receiver_name);
    if (message_arena != submessage_arena) {
      cast_receiver_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cast_receiver_name, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00100000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00100000u;
  }
  _impl_.cast_receiver_name_ = cast_receiver_name;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.cast_receiver_name)
}

// optional .enterprise_management.DeviceOffHoursProto device_off_hours = 54;
inline bool ChromeDeviceSettingsProto::_internal_has_device_off_hours() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_off_hours_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_off_hours() const {
  return _internal_has_device_off_hours();
}
inline void ChromeDeviceSettingsProto::clear_device_off_hours() {
  if (_impl_.device_off_hours_ != nullptr) _impl_.device_off_hours_->Clear();
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline const ::enterprise_management::DeviceOffHoursProto& ChromeDeviceSettingsProto::_internal_device_off_hours() const {
  const ::enterprise_management::DeviceOffHoursProto* p = _impl_.device_off_hours_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceOffHoursProto&>(
      ::enterprise_management::_DeviceOffHoursProto_default_instance_);
}
inline const ::enterprise_management::DeviceOffHoursProto& ChromeDeviceSettingsProto::device_off_hours() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_off_hours)
  return _internal_device_off_hours();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_off_hours(
    ::enterprise_management::DeviceOffHoursProto* device_off_hours) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_off_hours_);
  }
  _impl_.device_off_hours_ = device_off_hours;
  if (device_off_hours) {
    _impl_._has_bits_[1] |= 0x00200000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_off_hours)
}
inline ::enterprise_management::DeviceOffHoursProto* ChromeDeviceSettingsProto::release_device_off_hours() {
  _impl_._has_bits_[1] &= ~0x00200000u;
  ::enterprise_management::DeviceOffHoursProto* temp = _impl_.device_off_hours_;
  _impl_.device_off_hours_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceOffHoursProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_off_hours() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_off_hours)
  _impl_._has_bits_[1] &= ~0x00200000u;
  ::enterprise_management::DeviceOffHoursProto* temp = _impl_.device_off_hours_;
  _impl_.device_off_hours_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceOffHoursProto* ChromeDeviceSettingsProto::_internal_mutable_device_off_hours() {
  _impl_._has_bits_[1] |= 0x00200000u;
  if (_impl_.device_off_hours_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceOffHoursProto>(GetArenaForAllocation());
    _impl_.device_off_hours_ = p;
  }
  return _impl_.device_off_hours_;
}
inline ::enterprise_management::DeviceOffHoursProto* ChromeDeviceSettingsProto::mutable_device_off_hours() {
  ::enterprise_management::DeviceOffHoursProto* _msg = _internal_mutable_device_off_hours();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_off_hours)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_off_hours(::enterprise_management::DeviceOffHoursProto* device_off_hours) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_off_hours_;
  }
  if (device_off_hours) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_off_hours);
    if (message_arena != submessage_arena) {
      device_off_hours = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_off_hours, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00200000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00200000u;
  }
  _impl_.device_off_hours_ = device_off_hours;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_off_hours)
}

// optional .enterprise_management.DeviceNativePrintersProto native_device_printers = 55;
inline bool ChromeDeviceSettingsProto::_internal_has_native_device_printers() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.native_device_printers_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_native_device_printers() const {
  return _internal_has_native_device_printers();
}
inline void ChromeDeviceSettingsProto::clear_native_device_printers() {
  if (_impl_.native_device_printers_ != nullptr) _impl_.native_device_printers_->Clear();
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline const ::enterprise_management::DeviceNativePrintersProto& ChromeDeviceSettingsProto::_internal_native_device_printers() const {
  const ::enterprise_management::DeviceNativePrintersProto* p = _impl_.native_device_printers_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceNativePrintersProto&>(
      ::enterprise_management::_DeviceNativePrintersProto_default_instance_);
}
inline const ::enterprise_management::DeviceNativePrintersProto& ChromeDeviceSettingsProto::native_device_printers() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.native_device_printers)
  return _internal_native_device_printers();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_native_device_printers(
    ::enterprise_management::DeviceNativePrintersProto* native_device_printers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.native_device_printers_);
  }
  _impl_.native_device_printers_ = native_device_printers;
  if (native_device_printers) {
    _impl_._has_bits_[1] |= 0x00400000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.native_device_printers)
}
inline ::enterprise_management::DeviceNativePrintersProto* ChromeDeviceSettingsProto::release_native_device_printers() {
  _impl_._has_bits_[1] &= ~0x00400000u;
  ::enterprise_management::DeviceNativePrintersProto* temp = _impl_.native_device_printers_;
  _impl_.native_device_printers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceNativePrintersProto* ChromeDeviceSettingsProto::unsafe_arena_release_native_device_printers() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.native_device_printers)
  _impl_._has_bits_[1] &= ~0x00400000u;
  ::enterprise_management::DeviceNativePrintersProto* temp = _impl_.native_device_printers_;
  _impl_.native_device_printers_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceNativePrintersProto* ChromeDeviceSettingsProto::_internal_mutable_native_device_printers() {
  _impl_._has_bits_[1] |= 0x00400000u;
  if (_impl_.native_device_printers_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceNativePrintersProto>(GetArenaForAllocation());
    _impl_.native_device_printers_ = p;
  }
  return _impl_.native_device_printers_;
}
inline ::enterprise_management::DeviceNativePrintersProto* ChromeDeviceSettingsProto::mutable_native_device_printers() {
  ::enterprise_management::DeviceNativePrintersProto* _msg = _internal_mutable_native_device_printers();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.native_device_printers)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_native_device_printers(::enterprise_management::DeviceNativePrintersProto* native_device_printers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.native_device_printers_;
  }
  if (native_device_printers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(native_device_printers);
    if (message_arena != submessage_arena) {
      native_device_printers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, native_device_printers, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00400000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00400000u;
  }
  _impl_.native_device_printers_ = native_device_printers;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.native_device_printers)
}

// optional .enterprise_management.DeviceNativePrintersAccessModeProto native_device_printers_access_mode = 56;
inline bool ChromeDeviceSettingsProto::_internal_has_native_device_printers_access_mode() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.native_device_printers_access_mode_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_native_device_printers_access_mode() const {
  return _internal_has_native_device_printers_access_mode();
}
inline void ChromeDeviceSettingsProto::clear_native_device_printers_access_mode() {
  if (_impl_.native_device_printers_access_mode_ != nullptr) _impl_.native_device_printers_access_mode_->Clear();
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline const ::enterprise_management::DeviceNativePrintersAccessModeProto& ChromeDeviceSettingsProto::_internal_native_device_printers_access_mode() const {
  const ::enterprise_management::DeviceNativePrintersAccessModeProto* p = _impl_.native_device_printers_access_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceNativePrintersAccessModeProto&>(
      ::enterprise_management::_DeviceNativePrintersAccessModeProto_default_instance_);
}
inline const ::enterprise_management::DeviceNativePrintersAccessModeProto& ChromeDeviceSettingsProto::native_device_printers_access_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_access_mode)
  return _internal_native_device_printers_access_mode();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_native_device_printers_access_mode(
    ::enterprise_management::DeviceNativePrintersAccessModeProto* native_device_printers_access_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.native_device_printers_access_mode_);
  }
  _impl_.native_device_printers_access_mode_ = native_device_printers_access_mode;
  if (native_device_printers_access_mode) {
    _impl_._has_bits_[1] |= 0x00800000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_access_mode)
}
inline ::enterprise_management::DeviceNativePrintersAccessModeProto* ChromeDeviceSettingsProto::release_native_device_printers_access_mode() {
  _impl_._has_bits_[1] &= ~0x00800000u;
  ::enterprise_management::DeviceNativePrintersAccessModeProto* temp = _impl_.native_device_printers_access_mode_;
  _impl_.native_device_printers_access_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceNativePrintersAccessModeProto* ChromeDeviceSettingsProto::unsafe_arena_release_native_device_printers_access_mode() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_access_mode)
  _impl_._has_bits_[1] &= ~0x00800000u;
  ::enterprise_management::DeviceNativePrintersAccessModeProto* temp = _impl_.native_device_printers_access_mode_;
  _impl_.native_device_printers_access_mode_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceNativePrintersAccessModeProto* ChromeDeviceSettingsProto::_internal_mutable_native_device_printers_access_mode() {
  _impl_._has_bits_[1] |= 0x00800000u;
  if (_impl_.native_device_printers_access_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceNativePrintersAccessModeProto>(GetArenaForAllocation());
    _impl_.native_device_printers_access_mode_ = p;
  }
  return _impl_.native_device_printers_access_mode_;
}
inline ::enterprise_management::DeviceNativePrintersAccessModeProto* ChromeDeviceSettingsProto::mutable_native_device_printers_access_mode() {
  ::enterprise_management::DeviceNativePrintersAccessModeProto* _msg = _internal_mutable_native_device_printers_access_mode();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_access_mode)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_native_device_printers_access_mode(::enterprise_management::DeviceNativePrintersAccessModeProto* native_device_printers_access_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.native_device_printers_access_mode_;
  }
  if (native_device_printers_access_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(native_device_printers_access_mode);
    if (message_arena != submessage_arena) {
      native_device_printers_access_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, native_device_printers_access_mode, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00800000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00800000u;
  }
  _impl_.native_device_printers_access_mode_ = native_device_printers_access_mode;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_access_mode)
}

// optional .enterprise_management.DeviceNativePrintersBlacklistProto native_device_printers_blacklist = 57;
inline bool ChromeDeviceSettingsProto::_internal_has_native_device_printers_blacklist() const {
  bool value = (_impl_._has_bits_[1] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.native_device_printers_blacklist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_native_device_printers_blacklist() const {
  return _internal_has_native_device_printers_blacklist();
}
inline void ChromeDeviceSettingsProto::clear_native_device_printers_blacklist() {
  if (_impl_.native_device_printers_blacklist_ != nullptr) _impl_.native_device_printers_blacklist_->Clear();
  _impl_._has_bits_[1] &= ~0x01000000u;
}
inline const ::enterprise_management::DeviceNativePrintersBlacklistProto& ChromeDeviceSettingsProto::_internal_native_device_printers_blacklist() const {
  const ::enterprise_management::DeviceNativePrintersBlacklistProto* p = _impl_.native_device_printers_blacklist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceNativePrintersBlacklistProto&>(
      ::enterprise_management::_DeviceNativePrintersBlacklistProto_default_instance_);
}
inline const ::enterprise_management::DeviceNativePrintersBlacklistProto& ChromeDeviceSettingsProto::native_device_printers_blacklist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_blacklist)
  return _internal_native_device_printers_blacklist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_native_device_printers_blacklist(
    ::enterprise_management::DeviceNativePrintersBlacklistProto* native_device_printers_blacklist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.native_device_printers_blacklist_);
  }
  _impl_.native_device_printers_blacklist_ = native_device_printers_blacklist;
  if (native_device_printers_blacklist) {
    _impl_._has_bits_[1] |= 0x01000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_blacklist)
}
inline ::enterprise_management::DeviceNativePrintersBlacklistProto* ChromeDeviceSettingsProto::release_native_device_printers_blacklist() {
  _impl_._has_bits_[1] &= ~0x01000000u;
  ::enterprise_management::DeviceNativePrintersBlacklistProto* temp = _impl_.native_device_printers_blacklist_;
  _impl_.native_device_printers_blacklist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceNativePrintersBlacklistProto* ChromeDeviceSettingsProto::unsafe_arena_release_native_device_printers_blacklist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_blacklist)
  _impl_._has_bits_[1] &= ~0x01000000u;
  ::enterprise_management::DeviceNativePrintersBlacklistProto* temp = _impl_.native_device_printers_blacklist_;
  _impl_.native_device_printers_blacklist_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceNativePrintersBlacklistProto* ChromeDeviceSettingsProto::_internal_mutable_native_device_printers_blacklist() {
  _impl_._has_bits_[1] |= 0x01000000u;
  if (_impl_.native_device_printers_blacklist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceNativePrintersBlacklistProto>(GetArenaForAllocation());
    _impl_.native_device_printers_blacklist_ = p;
  }
  return _impl_.native_device_printers_blacklist_;
}
inline ::enterprise_management::DeviceNativePrintersBlacklistProto* ChromeDeviceSettingsProto::mutable_native_device_printers_blacklist() {
  ::enterprise_management::DeviceNativePrintersBlacklistProto* _msg = _internal_mutable_native_device_printers_blacklist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_blacklist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_native_device_printers_blacklist(::enterprise_management::DeviceNativePrintersBlacklistProto* native_device_printers_blacklist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.native_device_printers_blacklist_;
  }
  if (native_device_printers_blacklist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(native_device_printers_blacklist);
    if (message_arena != submessage_arena) {
      native_device_printers_blacklist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, native_device_printers_blacklist, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x01000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x01000000u;
  }
  _impl_.native_device_printers_blacklist_ = native_device_printers_blacklist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_blacklist)
}

// optional .enterprise_management.DeviceNativePrintersWhitelistProto native_device_printers_whitelist = 58;
inline bool ChromeDeviceSettingsProto::_internal_has_native_device_printers_whitelist() const {
  bool value = (_impl_._has_bits_[1] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.native_device_printers_whitelist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_native_device_printers_whitelist() const {
  return _internal_has_native_device_printers_whitelist();
}
inline void ChromeDeviceSettingsProto::clear_native_device_printers_whitelist() {
  if (_impl_.native_device_printers_whitelist_ != nullptr) _impl_.native_device_printers_whitelist_->Clear();
  _impl_._has_bits_[1] &= ~0x02000000u;
}
inline const ::enterprise_management::DeviceNativePrintersWhitelistProto& ChromeDeviceSettingsProto::_internal_native_device_printers_whitelist() const {
  const ::enterprise_management::DeviceNativePrintersWhitelistProto* p = _impl_.native_device_printers_whitelist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceNativePrintersWhitelistProto&>(
      ::enterprise_management::_DeviceNativePrintersWhitelistProto_default_instance_);
}
inline const ::enterprise_management::DeviceNativePrintersWhitelistProto& ChromeDeviceSettingsProto::native_device_printers_whitelist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_whitelist)
  return _internal_native_device_printers_whitelist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_native_device_printers_whitelist(
    ::enterprise_management::DeviceNativePrintersWhitelistProto* native_device_printers_whitelist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.native_device_printers_whitelist_);
  }
  _impl_.native_device_printers_whitelist_ = native_device_printers_whitelist;
  if (native_device_printers_whitelist) {
    _impl_._has_bits_[1] |= 0x02000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_whitelist)
}
inline ::enterprise_management::DeviceNativePrintersWhitelistProto* ChromeDeviceSettingsProto::release_native_device_printers_whitelist() {
  _impl_._has_bits_[1] &= ~0x02000000u;
  ::enterprise_management::DeviceNativePrintersWhitelistProto* temp = _impl_.native_device_printers_whitelist_;
  _impl_.native_device_printers_whitelist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceNativePrintersWhitelistProto* ChromeDeviceSettingsProto::unsafe_arena_release_native_device_printers_whitelist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_whitelist)
  _impl_._has_bits_[1] &= ~0x02000000u;
  ::enterprise_management::DeviceNativePrintersWhitelistProto* temp = _impl_.native_device_printers_whitelist_;
  _impl_.native_device_printers_whitelist_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceNativePrintersWhitelistProto* ChromeDeviceSettingsProto::_internal_mutable_native_device_printers_whitelist() {
  _impl_._has_bits_[1] |= 0x02000000u;
  if (_impl_.native_device_printers_whitelist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceNativePrintersWhitelistProto>(GetArenaForAllocation());
    _impl_.native_device_printers_whitelist_ = p;
  }
  return _impl_.native_device_printers_whitelist_;
}
inline ::enterprise_management::DeviceNativePrintersWhitelistProto* ChromeDeviceSettingsProto::mutable_native_device_printers_whitelist() {
  ::enterprise_management::DeviceNativePrintersWhitelistProto* _msg = _internal_mutable_native_device_printers_whitelist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_whitelist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_native_device_printers_whitelist(::enterprise_management::DeviceNativePrintersWhitelistProto* native_device_printers_whitelist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.native_device_printers_whitelist_;
  }
  if (native_device_printers_whitelist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(native_device_printers_whitelist);
    if (message_arena != submessage_arena) {
      native_device_printers_whitelist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, native_device_printers_whitelist, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x02000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x02000000u;
  }
  _impl_.native_device_printers_whitelist_ = native_device_printers_whitelist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.native_device_printers_whitelist)
}

// optional .enterprise_management.TPMFirmwareUpdateSettingsProto tpm_firmware_update_settings = 59;
inline bool ChromeDeviceSettingsProto::_internal_has_tpm_firmware_update_settings() const {
  bool value = (_impl_._has_bits_[1] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tpm_firmware_update_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_tpm_firmware_update_settings() const {
  return _internal_has_tpm_firmware_update_settings();
}
inline void ChromeDeviceSettingsProto::clear_tpm_firmware_update_settings() {
  if (_impl_.tpm_firmware_update_settings_ != nullptr) _impl_.tpm_firmware_update_settings_->Clear();
  _impl_._has_bits_[1] &= ~0x04000000u;
}
inline const ::enterprise_management::TPMFirmwareUpdateSettingsProto& ChromeDeviceSettingsProto::_internal_tpm_firmware_update_settings() const {
  const ::enterprise_management::TPMFirmwareUpdateSettingsProto* p = _impl_.tpm_firmware_update_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::TPMFirmwareUpdateSettingsProto&>(
      ::enterprise_management::_TPMFirmwareUpdateSettingsProto_default_instance_);
}
inline const ::enterprise_management::TPMFirmwareUpdateSettingsProto& ChromeDeviceSettingsProto::tpm_firmware_update_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.tpm_firmware_update_settings)
  return _internal_tpm_firmware_update_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_tpm_firmware_update_settings(
    ::enterprise_management::TPMFirmwareUpdateSettingsProto* tpm_firmware_update_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tpm_firmware_update_settings_);
  }
  _impl_.tpm_firmware_update_settings_ = tpm_firmware_update_settings;
  if (tpm_firmware_update_settings) {
    _impl_._has_bits_[1] |= 0x04000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.tpm_firmware_update_settings)
}
inline ::enterprise_management::TPMFirmwareUpdateSettingsProto* ChromeDeviceSettingsProto::release_tpm_firmware_update_settings() {
  _impl_._has_bits_[1] &= ~0x04000000u;
  ::enterprise_management::TPMFirmwareUpdateSettingsProto* temp = _impl_.tpm_firmware_update_settings_;
  _impl_.tpm_firmware_update_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::TPMFirmwareUpdateSettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_tpm_firmware_update_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.tpm_firmware_update_settings)
  _impl_._has_bits_[1] &= ~0x04000000u;
  ::enterprise_management::TPMFirmwareUpdateSettingsProto* temp = _impl_.tpm_firmware_update_settings_;
  _impl_.tpm_firmware_update_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::TPMFirmwareUpdateSettingsProto* ChromeDeviceSettingsProto::_internal_mutable_tpm_firmware_update_settings() {
  _impl_._has_bits_[1] |= 0x04000000u;
  if (_impl_.tpm_firmware_update_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::TPMFirmwareUpdateSettingsProto>(GetArenaForAllocation());
    _impl_.tpm_firmware_update_settings_ = p;
  }
  return _impl_.tpm_firmware_update_settings_;
}
inline ::enterprise_management::TPMFirmwareUpdateSettingsProto* ChromeDeviceSettingsProto::mutable_tpm_firmware_update_settings() {
  ::enterprise_management::TPMFirmwareUpdateSettingsProto* _msg = _internal_mutable_tpm_firmware_update_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.tpm_firmware_update_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_tpm_firmware_update_settings(::enterprise_management::TPMFirmwareUpdateSettingsProto* tpm_firmware_update_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tpm_firmware_update_settings_;
  }
  if (tpm_firmware_update_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tpm_firmware_update_settings);
    if (message_arena != submessage_arena) {
      tpm_firmware_update_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tpm_firmware_update_settings, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x04000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x04000000u;
  }
  _impl_.tpm_firmware_update_settings_ = tpm_firmware_update_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.tpm_firmware_update_settings)
}

// optional .enterprise_management.OBSOLETE_MinimumRequiredVersionProto minimum_required_version = 60 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_minimum_required_version() const {
  bool value = (_impl_._has_bits_[1] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimum_required_version_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_minimum_required_version() const {
  return _internal_has_minimum_required_version();
}
inline void ChromeDeviceSettingsProto::clear_minimum_required_version() {
  if (_impl_.minimum_required_version_ != nullptr) _impl_.minimum_required_version_->Clear();
  _impl_._has_bits_[1] &= ~0x08000000u;
}
inline const ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto& ChromeDeviceSettingsProto::_internal_minimum_required_version() const {
  const ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* p = _impl_.minimum_required_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto&>(
      ::enterprise_management::_OBSOLETE_MinimumRequiredVersionProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto& ChromeDeviceSettingsProto::minimum_required_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.minimum_required_version)
  return _internal_minimum_required_version();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_minimum_required_version(
    ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* minimum_required_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minimum_required_version_);
  }
  _impl_.minimum_required_version_ = minimum_required_version;
  if (minimum_required_version) {
    _impl_._has_bits_[1] |= 0x08000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.minimum_required_version)
}
inline ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* ChromeDeviceSettingsProto::release_minimum_required_version() {
  _impl_._has_bits_[1] &= ~0x08000000u;
  ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* temp = _impl_.minimum_required_version_;
  _impl_.minimum_required_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* ChromeDeviceSettingsProto::unsafe_arena_release_minimum_required_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.minimum_required_version)
  _impl_._has_bits_[1] &= ~0x08000000u;
  ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* temp = _impl_.minimum_required_version_;
  _impl_.minimum_required_version_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* ChromeDeviceSettingsProto::_internal_mutable_minimum_required_version() {
  _impl_._has_bits_[1] |= 0x08000000u;
  if (_impl_.minimum_required_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_MinimumRequiredVersionProto>(GetArenaForAllocation());
    _impl_.minimum_required_version_ = p;
  }
  return _impl_.minimum_required_version_;
}
inline ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* ChromeDeviceSettingsProto::mutable_minimum_required_version() {
  ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* _msg = _internal_mutable_minimum_required_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.minimum_required_version)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_minimum_required_version(::enterprise_management::OBSOLETE_MinimumRequiredVersionProto* minimum_required_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.minimum_required_version_;
  }
  if (minimum_required_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(minimum_required_version);
    if (message_arena != submessage_arena) {
      minimum_required_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimum_required_version, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x08000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x08000000u;
  }
  _impl_.minimum_required_version_ = minimum_required_version;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.minimum_required_version)
}

// optional .enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls device_login_screen_auto_select_certificate_for_urls = 62;
inline bool ChromeDeviceSettingsProto::_internal_has_device_login_screen_auto_select_certificate_for_urls() const {
  bool value = (_impl_._has_bits_[1] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_login_screen_auto_select_certificate_for_urls_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_login_screen_auto_select_certificate_for_urls() const {
  return _internal_has_device_login_screen_auto_select_certificate_for_urls();
}
inline void ChromeDeviceSettingsProto::clear_device_login_screen_auto_select_certificate_for_urls() {
  if (_impl_.device_login_screen_auto_select_certificate_for_urls_ != nullptr) _impl_.device_login_screen_auto_select_certificate_for_urls_->Clear();
  _impl_._has_bits_[1] &= ~0x10000000u;
}
inline const ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls& ChromeDeviceSettingsProto::_internal_device_login_screen_auto_select_certificate_for_urls() const {
  const ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* p = _impl_.device_login_screen_auto_select_certificate_for_urls_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls&>(
      ::enterprise_management::_DeviceLoginScreenAutoSelectCertificateForUrls_default_instance_);
}
inline const ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls& ChromeDeviceSettingsProto::device_login_screen_auto_select_certificate_for_urls() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_auto_select_certificate_for_urls)
  return _internal_device_login_screen_auto_select_certificate_for_urls();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_login_screen_auto_select_certificate_for_urls(
    ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* device_login_screen_auto_select_certificate_for_urls) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_auto_select_certificate_for_urls_);
  }
  _impl_.device_login_screen_auto_select_certificate_for_urls_ = device_login_screen_auto_select_certificate_for_urls;
  if (device_login_screen_auto_select_certificate_for_urls) {
    _impl_._has_bits_[1] |= 0x10000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_auto_select_certificate_for_urls)
}
inline ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* ChromeDeviceSettingsProto::release_device_login_screen_auto_select_certificate_for_urls() {
  _impl_._has_bits_[1] &= ~0x10000000u;
  ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* temp = _impl_.device_login_screen_auto_select_certificate_for_urls_;
  _impl_.device_login_screen_auto_select_certificate_for_urls_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* ChromeDeviceSettingsProto::unsafe_arena_release_device_login_screen_auto_select_certificate_for_urls() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_auto_select_certificate_for_urls)
  _impl_._has_bits_[1] &= ~0x10000000u;
  ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* temp = _impl_.device_login_screen_auto_select_certificate_for_urls_;
  _impl_.device_login_screen_auto_select_certificate_for_urls_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* ChromeDeviceSettingsProto::_internal_mutable_device_login_screen_auto_select_certificate_for_urls() {
  _impl_._has_bits_[1] |= 0x10000000u;
  if (_impl_.device_login_screen_auto_select_certificate_for_urls_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls>(GetArenaForAllocation());
    _impl_.device_login_screen_auto_select_certificate_for_urls_ = p;
  }
  return _impl_.device_login_screen_auto_select_certificate_for_urls_;
}
inline ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* ChromeDeviceSettingsProto::mutable_device_login_screen_auto_select_certificate_for_urls() {
  ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* _msg = _internal_mutable_device_login_screen_auto_select_certificate_for_urls();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_auto_select_certificate_for_urls)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_login_screen_auto_select_certificate_for_urls(::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls* device_login_screen_auto_select_certificate_for_urls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_login_screen_auto_select_certificate_for_urls_;
  }
  if (device_login_screen_auto_select_certificate_for_urls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_login_screen_auto_select_certificate_for_urls);
    if (message_arena != submessage_arena) {
      device_login_screen_auto_select_certificate_for_urls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_login_screen_auto_select_certificate_for_urls, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x10000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x10000000u;
  }
  _impl_.device_login_screen_auto_select_certificate_for_urls_ = device_login_screen_auto_select_certificate_for_urls;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_auto_select_certificate_for_urls)
}

// optional .enterprise_management.UnaffiliatedArcAllowedProto unaffiliated_arc_allowed = 63;
inline bool ChromeDeviceSettingsProto::_internal_has_unaffiliated_arc_allowed() const {
  bool value = (_impl_._has_bits_[1] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unaffiliated_arc_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_unaffiliated_arc_allowed() const {
  return _internal_has_unaffiliated_arc_allowed();
}
inline void ChromeDeviceSettingsProto::clear_unaffiliated_arc_allowed() {
  if (_impl_.unaffiliated_arc_allowed_ != nullptr) _impl_.unaffiliated_arc_allowed_->Clear();
  _impl_._has_bits_[1] &= ~0x20000000u;
}
inline const ::enterprise_management::UnaffiliatedArcAllowedProto& ChromeDeviceSettingsProto::_internal_unaffiliated_arc_allowed() const {
  const ::enterprise_management::UnaffiliatedArcAllowedProto* p = _impl_.unaffiliated_arc_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::UnaffiliatedArcAllowedProto&>(
      ::enterprise_management::_UnaffiliatedArcAllowedProto_default_instance_);
}
inline const ::enterprise_management::UnaffiliatedArcAllowedProto& ChromeDeviceSettingsProto::unaffiliated_arc_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.unaffiliated_arc_allowed)
  return _internal_unaffiliated_arc_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_unaffiliated_arc_allowed(
    ::enterprise_management::UnaffiliatedArcAllowedProto* unaffiliated_arc_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unaffiliated_arc_allowed_);
  }
  _impl_.unaffiliated_arc_allowed_ = unaffiliated_arc_allowed;
  if (unaffiliated_arc_allowed) {
    _impl_._has_bits_[1] |= 0x20000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.unaffiliated_arc_allowed)
}
inline ::enterprise_management::UnaffiliatedArcAllowedProto* ChromeDeviceSettingsProto::release_unaffiliated_arc_allowed() {
  _impl_._has_bits_[1] &= ~0x20000000u;
  ::enterprise_management::UnaffiliatedArcAllowedProto* temp = _impl_.unaffiliated_arc_allowed_;
  _impl_.unaffiliated_arc_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::UnaffiliatedArcAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_unaffiliated_arc_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.unaffiliated_arc_allowed)
  _impl_._has_bits_[1] &= ~0x20000000u;
  ::enterprise_management::UnaffiliatedArcAllowedProto* temp = _impl_.unaffiliated_arc_allowed_;
  _impl_.unaffiliated_arc_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::UnaffiliatedArcAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_unaffiliated_arc_allowed() {
  _impl_._has_bits_[1] |= 0x20000000u;
  if (_impl_.unaffiliated_arc_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::UnaffiliatedArcAllowedProto>(GetArenaForAllocation());
    _impl_.unaffiliated_arc_allowed_ = p;
  }
  return _impl_.unaffiliated_arc_allowed_;
}
inline ::enterprise_management::UnaffiliatedArcAllowedProto* ChromeDeviceSettingsProto::mutable_unaffiliated_arc_allowed() {
  ::enterprise_management::UnaffiliatedArcAllowedProto* _msg = _internal_mutable_unaffiliated_arc_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.unaffiliated_arc_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_unaffiliated_arc_allowed(::enterprise_management::UnaffiliatedArcAllowedProto* unaffiliated_arc_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.unaffiliated_arc_allowed_;
  }
  if (unaffiliated_arc_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unaffiliated_arc_allowed);
    if (message_arena != submessage_arena) {
      unaffiliated_arc_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unaffiliated_arc_allowed, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x20000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x20000000u;
  }
  _impl_.unaffiliated_arc_allowed_ = unaffiliated_arc_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.unaffiliated_arc_allowed)
}

// optional .enterprise_management.NetworkHostnameProto network_hostname = 64;
inline bool ChromeDeviceSettingsProto::_internal_has_network_hostname() const {
  bool value = (_impl_._has_bits_[1] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.network_hostname_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_network_hostname() const {
  return _internal_has_network_hostname();
}
inline void ChromeDeviceSettingsProto::clear_network_hostname() {
  if (_impl_.network_hostname_ != nullptr) _impl_.network_hostname_->Clear();
  _impl_._has_bits_[1] &= ~0x40000000u;
}
inline const ::enterprise_management::NetworkHostnameProto& ChromeDeviceSettingsProto::_internal_network_hostname() const {
  const ::enterprise_management::NetworkHostnameProto* p = _impl_.network_hostname_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::NetworkHostnameProto&>(
      ::enterprise_management::_NetworkHostnameProto_default_instance_);
}
inline const ::enterprise_management::NetworkHostnameProto& ChromeDeviceSettingsProto::network_hostname() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.network_hostname)
  return _internal_network_hostname();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_network_hostname(
    ::enterprise_management::NetworkHostnameProto* network_hostname) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.network_hostname_);
  }
  _impl_.network_hostname_ = network_hostname;
  if (network_hostname) {
    _impl_._has_bits_[1] |= 0x40000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.network_hostname)
}
inline ::enterprise_management::NetworkHostnameProto* ChromeDeviceSettingsProto::release_network_hostname() {
  _impl_._has_bits_[1] &= ~0x40000000u;
  ::enterprise_management::NetworkHostnameProto* temp = _impl_.network_hostname_;
  _impl_.network_hostname_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::NetworkHostnameProto* ChromeDeviceSettingsProto::unsafe_arena_release_network_hostname() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.network_hostname)
  _impl_._has_bits_[1] &= ~0x40000000u;
  ::enterprise_management::NetworkHostnameProto* temp = _impl_.network_hostname_;
  _impl_.network_hostname_ = nullptr;
  return temp;
}
inline ::enterprise_management::NetworkHostnameProto* ChromeDeviceSettingsProto::_internal_mutable_network_hostname() {
  _impl_._has_bits_[1] |= 0x40000000u;
  if (_impl_.network_hostname_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::NetworkHostnameProto>(GetArenaForAllocation());
    _impl_.network_hostname_ = p;
  }
  return _impl_.network_hostname_;
}
inline ::enterprise_management::NetworkHostnameProto* ChromeDeviceSettingsProto::mutable_network_hostname() {
  ::enterprise_management::NetworkHostnameProto* _msg = _internal_mutable_network_hostname();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.network_hostname)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_network_hostname(::enterprise_management::NetworkHostnameProto* network_hostname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.network_hostname_;
  }
  if (network_hostname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network_hostname);
    if (message_arena != submessage_arena) {
      network_hostname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_hostname, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x40000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x40000000u;
  }
  _impl_.network_hostname_ = network_hostname;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.network_hostname)
}

// optional .enterprise_management.DeviceKerberosEncryptionTypesProto device_kerberos_encryption_types = 65;
inline bool ChromeDeviceSettingsProto::_internal_has_device_kerberos_encryption_types() const {
  bool value = (_impl_._has_bits_[1] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_kerberos_encryption_types_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_kerberos_encryption_types() const {
  return _internal_has_device_kerberos_encryption_types();
}
inline void ChromeDeviceSettingsProto::clear_device_kerberos_encryption_types() {
  if (_impl_.device_kerberos_encryption_types_ != nullptr) _impl_.device_kerberos_encryption_types_->Clear();
  _impl_._has_bits_[1] &= ~0x80000000u;
}
inline const ::enterprise_management::DeviceKerberosEncryptionTypesProto& ChromeDeviceSettingsProto::_internal_device_kerberos_encryption_types() const {
  const ::enterprise_management::DeviceKerberosEncryptionTypesProto* p = _impl_.device_kerberos_encryption_types_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceKerberosEncryptionTypesProto&>(
      ::enterprise_management::_DeviceKerberosEncryptionTypesProto_default_instance_);
}
inline const ::enterprise_management::DeviceKerberosEncryptionTypesProto& ChromeDeviceSettingsProto::device_kerberos_encryption_types() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_kerberos_encryption_types)
  return _internal_device_kerberos_encryption_types();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_kerberos_encryption_types(
    ::enterprise_management::DeviceKerberosEncryptionTypesProto* device_kerberos_encryption_types) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_kerberos_encryption_types_);
  }
  _impl_.device_kerberos_encryption_types_ = device_kerberos_encryption_types;
  if (device_kerberos_encryption_types) {
    _impl_._has_bits_[1] |= 0x80000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_kerberos_encryption_types)
}
inline ::enterprise_management::DeviceKerberosEncryptionTypesProto* ChromeDeviceSettingsProto::release_device_kerberos_encryption_types() {
  _impl_._has_bits_[1] &= ~0x80000000u;
  ::enterprise_management::DeviceKerberosEncryptionTypesProto* temp = _impl_.device_kerberos_encryption_types_;
  _impl_.device_kerberos_encryption_types_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceKerberosEncryptionTypesProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_kerberos_encryption_types() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_kerberos_encryption_types)
  _impl_._has_bits_[1] &= ~0x80000000u;
  ::enterprise_management::DeviceKerberosEncryptionTypesProto* temp = _impl_.device_kerberos_encryption_types_;
  _impl_.device_kerberos_encryption_types_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceKerberosEncryptionTypesProto* ChromeDeviceSettingsProto::_internal_mutable_device_kerberos_encryption_types() {
  _impl_._has_bits_[1] |= 0x80000000u;
  if (_impl_.device_kerberos_encryption_types_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceKerberosEncryptionTypesProto>(GetArenaForAllocation());
    _impl_.device_kerberos_encryption_types_ = p;
  }
  return _impl_.device_kerberos_encryption_types_;
}
inline ::enterprise_management::DeviceKerberosEncryptionTypesProto* ChromeDeviceSettingsProto::mutable_device_kerberos_encryption_types() {
  ::enterprise_management::DeviceKerberosEncryptionTypesProto* _msg = _internal_mutable_device_kerberos_encryption_types();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_kerberos_encryption_types)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_kerberos_encryption_types(::enterprise_management::DeviceKerberosEncryptionTypesProto* device_kerberos_encryption_types) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_kerberos_encryption_types_;
  }
  if (device_kerberos_encryption_types) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_kerberos_encryption_types);
    if (message_arena != submessage_arena) {
      device_kerberos_encryption_types = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_kerberos_encryption_types, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x80000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x80000000u;
  }
  _impl_.device_kerberos_encryption_types_ = device_kerberos_encryption_types;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_kerberos_encryption_types)
}

// optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto device_user_policy_loopback_processing_mode = 66;
inline bool ChromeDeviceSettingsProto::_internal_has_device_user_policy_loopback_processing_mode() const {
  bool value = (_impl_._has_bits_[2] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_user_policy_loopback_processing_mode_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_user_policy_loopback_processing_mode() const {
  return _internal_has_device_user_policy_loopback_processing_mode();
}
inline void ChromeDeviceSettingsProto::clear_device_user_policy_loopback_processing_mode() {
  if (_impl_.device_user_policy_loopback_processing_mode_ != nullptr) _impl_.device_user_policy_loopback_processing_mode_->Clear();
  _impl_._has_bits_[2] &= ~0x00000001u;
}
inline const ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto& ChromeDeviceSettingsProto::_internal_device_user_policy_loopback_processing_mode() const {
  const ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* p = _impl_.device_user_policy_loopback_processing_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto&>(
      ::enterprise_management::_DeviceUserPolicyLoopbackProcessingModeProto_default_instance_);
}
inline const ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto& ChromeDeviceSettingsProto::device_user_policy_loopback_processing_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_user_policy_loopback_processing_mode)
  return _internal_device_user_policy_loopback_processing_mode();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_user_policy_loopback_processing_mode(
    ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* device_user_policy_loopback_processing_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_user_policy_loopback_processing_mode_);
  }
  _impl_.device_user_policy_loopback_processing_mode_ = device_user_policy_loopback_processing_mode;
  if (device_user_policy_loopback_processing_mode) {
    _impl_._has_bits_[2] |= 0x00000001u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_user_policy_loopback_processing_mode)
}
inline ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* ChromeDeviceSettingsProto::release_device_user_policy_loopback_processing_mode() {
  _impl_._has_bits_[2] &= ~0x00000001u;
  ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* temp = _impl_.device_user_policy_loopback_processing_mode_;
  _impl_.device_user_policy_loopback_processing_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_user_policy_loopback_processing_mode() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_user_policy_loopback_processing_mode)
  _impl_._has_bits_[2] &= ~0x00000001u;
  ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* temp = _impl_.device_user_policy_loopback_processing_mode_;
  _impl_.device_user_policy_loopback_processing_mode_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* ChromeDeviceSettingsProto::_internal_mutable_device_user_policy_loopback_processing_mode() {
  _impl_._has_bits_[2] |= 0x00000001u;
  if (_impl_.device_user_policy_loopback_processing_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto>(GetArenaForAllocation());
    _impl_.device_user_policy_loopback_processing_mode_ = p;
  }
  return _impl_.device_user_policy_loopback_processing_mode_;
}
inline ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* ChromeDeviceSettingsProto::mutable_device_user_policy_loopback_processing_mode() {
  ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* _msg = _internal_mutable_device_user_policy_loopback_processing_mode();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_user_policy_loopback_processing_mode)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_user_policy_loopback_processing_mode(::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto* device_user_policy_loopback_processing_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_user_policy_loopback_processing_mode_;
  }
  if (device_user_policy_loopback_processing_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_user_policy_loopback_processing_mode);
    if (message_arena != submessage_arena) {
      device_user_policy_loopback_processing_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_user_policy_loopback_processing_mode, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000001u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000001u;
  }
  _impl_.device_user_policy_loopback_processing_mode_ = device_user_policy_loopback_processing_mode;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_user_policy_loopback_processing_mode)
}

// optional .enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto device_login_screen_isolate_origins = 67 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_device_login_screen_isolate_origins() const {
  bool value = (_impl_._has_bits_[2] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_login_screen_isolate_origins_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_login_screen_isolate_origins() const {
  return _internal_has_device_login_screen_isolate_origins();
}
inline void ChromeDeviceSettingsProto::clear_device_login_screen_isolate_origins() {
  if (_impl_.device_login_screen_isolate_origins_ != nullptr) _impl_.device_login_screen_isolate_origins_->Clear();
  _impl_._has_bits_[2] &= ~0x00000002u;
}
inline const ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto& ChromeDeviceSettingsProto::_internal_device_login_screen_isolate_origins() const {
  const ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* p = _impl_.device_login_screen_isolate_origins_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto&>(
      ::enterprise_management::_OBSOLETE_DeviceLoginScreenIsolateOriginsProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto& ChromeDeviceSettingsProto::device_login_screen_isolate_origins() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_isolate_origins)
  return _internal_device_login_screen_isolate_origins();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_login_screen_isolate_origins(
    ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* device_login_screen_isolate_origins) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_isolate_origins_);
  }
  _impl_.device_login_screen_isolate_origins_ = device_login_screen_isolate_origins;
  if (device_login_screen_isolate_origins) {
    _impl_._has_bits_[2] |= 0x00000002u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_isolate_origins)
}
inline ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* ChromeDeviceSettingsProto::release_device_login_screen_isolate_origins() {
  _impl_._has_bits_[2] &= ~0x00000002u;
  ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* temp = _impl_.device_login_screen_isolate_origins_;
  _impl_.device_login_screen_isolate_origins_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_login_screen_isolate_origins() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_isolate_origins)
  _impl_._has_bits_[2] &= ~0x00000002u;
  ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* temp = _impl_.device_login_screen_isolate_origins_;
  _impl_.device_login_screen_isolate_origins_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* ChromeDeviceSettingsProto::_internal_mutable_device_login_screen_isolate_origins() {
  _impl_._has_bits_[2] |= 0x00000002u;
  if (_impl_.device_login_screen_isolate_origins_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto>(GetArenaForAllocation());
    _impl_.device_login_screen_isolate_origins_ = p;
  }
  return _impl_.device_login_screen_isolate_origins_;
}
inline ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* ChromeDeviceSettingsProto::mutable_device_login_screen_isolate_origins() {
  ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* _msg = _internal_mutable_device_login_screen_isolate_origins();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_isolate_origins)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_login_screen_isolate_origins(::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto* device_login_screen_isolate_origins) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_login_screen_isolate_origins_;
  }
  if (device_login_screen_isolate_origins) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_login_screen_isolate_origins);
    if (message_arena != submessage_arena) {
      device_login_screen_isolate_origins = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_login_screen_isolate_origins, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000002u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000002u;
  }
  _impl_.device_login_screen_isolate_origins_ = device_login_screen_isolate_origins;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_isolate_origins)
}

// optional .enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto device_login_screen_site_per_process = 68 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_device_login_screen_site_per_process() const {
  bool value = (_impl_._has_bits_[2] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_login_screen_site_per_process_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_login_screen_site_per_process() const {
  return _internal_has_device_login_screen_site_per_process();
}
inline void ChromeDeviceSettingsProto::clear_device_login_screen_site_per_process() {
  if (_impl_.device_login_screen_site_per_process_ != nullptr) _impl_.device_login_screen_site_per_process_->Clear();
  _impl_._has_bits_[2] &= ~0x00000004u;
}
inline const ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto& ChromeDeviceSettingsProto::_internal_device_login_screen_site_per_process() const {
  const ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* p = _impl_.device_login_screen_site_per_process_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto&>(
      ::enterprise_management::_OBSOLETE_DeviceLoginScreenSitePerProcessProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto& ChromeDeviceSettingsProto::device_login_screen_site_per_process() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_site_per_process)
  return _internal_device_login_screen_site_per_process();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_login_screen_site_per_process(
    ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* device_login_screen_site_per_process) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_site_per_process_);
  }
  _impl_.device_login_screen_site_per_process_ = device_login_screen_site_per_process;
  if (device_login_screen_site_per_process) {
    _impl_._has_bits_[2] |= 0x00000004u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_site_per_process)
}
inline ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* ChromeDeviceSettingsProto::release_device_login_screen_site_per_process() {
  _impl_._has_bits_[2] &= ~0x00000004u;
  ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* temp = _impl_.device_login_screen_site_per_process_;
  _impl_.device_login_screen_site_per_process_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_login_screen_site_per_process() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_site_per_process)
  _impl_._has_bits_[2] &= ~0x00000004u;
  ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* temp = _impl_.device_login_screen_site_per_process_;
  _impl_.device_login_screen_site_per_process_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* ChromeDeviceSettingsProto::_internal_mutable_device_login_screen_site_per_process() {
  _impl_._has_bits_[2] |= 0x00000004u;
  if (_impl_.device_login_screen_site_per_process_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto>(GetArenaForAllocation());
    _impl_.device_login_screen_site_per_process_ = p;
  }
  return _impl_.device_login_screen_site_per_process_;
}
inline ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* ChromeDeviceSettingsProto::mutable_device_login_screen_site_per_process() {
  ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* _msg = _internal_mutable_device_login_screen_site_per_process();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_site_per_process)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_login_screen_site_per_process(::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto* device_login_screen_site_per_process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_login_screen_site_per_process_;
  }
  if (device_login_screen_site_per_process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_login_screen_site_per_process);
    if (message_arena != submessage_arena) {
      device_login_screen_site_per_process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_login_screen_site_per_process, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000004u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000004u;
  }
  _impl_.device_login_screen_site_per_process_ = device_login_screen_site_per_process;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_site_per_process)
}

// optional .enterprise_management.VirtualMachinesAllowedProto virtual_machines_allowed = 69;
inline bool ChromeDeviceSettingsProto::_internal_has_virtual_machines_allowed() const {
  bool value = (_impl_._has_bits_[2] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.virtual_machines_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_virtual_machines_allowed() const {
  return _internal_has_virtual_machines_allowed();
}
inline void ChromeDeviceSettingsProto::clear_virtual_machines_allowed() {
  if (_impl_.virtual_machines_allowed_ != nullptr) _impl_.virtual_machines_allowed_->Clear();
  _impl_._has_bits_[2] &= ~0x00000008u;
}
inline const ::enterprise_management::VirtualMachinesAllowedProto& ChromeDeviceSettingsProto::_internal_virtual_machines_allowed() const {
  const ::enterprise_management::VirtualMachinesAllowedProto* p = _impl_.virtual_machines_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::VirtualMachinesAllowedProto&>(
      ::enterprise_management::_VirtualMachinesAllowedProto_default_instance_);
}
inline const ::enterprise_management::VirtualMachinesAllowedProto& ChromeDeviceSettingsProto::virtual_machines_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.virtual_machines_allowed)
  return _internal_virtual_machines_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_virtual_machines_allowed(
    ::enterprise_management::VirtualMachinesAllowedProto* virtual_machines_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.virtual_machines_allowed_);
  }
  _impl_.virtual_machines_allowed_ = virtual_machines_allowed;
  if (virtual_machines_allowed) {
    _impl_._has_bits_[2] |= 0x00000008u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.virtual_machines_allowed)
}
inline ::enterprise_management::VirtualMachinesAllowedProto* ChromeDeviceSettingsProto::release_virtual_machines_allowed() {
  _impl_._has_bits_[2] &= ~0x00000008u;
  ::enterprise_management::VirtualMachinesAllowedProto* temp = _impl_.virtual_machines_allowed_;
  _impl_.virtual_machines_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::VirtualMachinesAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_virtual_machines_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.virtual_machines_allowed)
  _impl_._has_bits_[2] &= ~0x00000008u;
  ::enterprise_management::VirtualMachinesAllowedProto* temp = _impl_.virtual_machines_allowed_;
  _impl_.virtual_machines_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::VirtualMachinesAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_virtual_machines_allowed() {
  _impl_._has_bits_[2] |= 0x00000008u;
  if (_impl_.virtual_machines_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::VirtualMachinesAllowedProto>(GetArenaForAllocation());
    _impl_.virtual_machines_allowed_ = p;
  }
  return _impl_.virtual_machines_allowed_;
}
inline ::enterprise_management::VirtualMachinesAllowedProto* ChromeDeviceSettingsProto::mutable_virtual_machines_allowed() {
  ::enterprise_management::VirtualMachinesAllowedProto* _msg = _internal_mutable_virtual_machines_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.virtual_machines_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_virtual_machines_allowed(::enterprise_management::VirtualMachinesAllowedProto* virtual_machines_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.virtual_machines_allowed_;
  }
  if (virtual_machines_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(virtual_machines_allowed);
    if (message_arena != submessage_arena) {
      virtual_machines_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_machines_allowed, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000008u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000008u;
  }
  _impl_.virtual_machines_allowed_ = virtual_machines_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.virtual_machines_allowed)
}

// optional .enterprise_management.DeviceMachinePasswordChangeRateProto device_machine_password_change_rate = 70;
inline bool ChromeDeviceSettingsProto::_internal_has_device_machine_password_change_rate() const {
  bool value = (_impl_._has_bits_[2] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_machine_password_change_rate_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_machine_password_change_rate() const {
  return _internal_has_device_machine_password_change_rate();
}
inline void ChromeDeviceSettingsProto::clear_device_machine_password_change_rate() {
  if (_impl_.device_machine_password_change_rate_ != nullptr) _impl_.device_machine_password_change_rate_->Clear();
  _impl_._has_bits_[2] &= ~0x00000010u;
}
inline const ::enterprise_management::DeviceMachinePasswordChangeRateProto& ChromeDeviceSettingsProto::_internal_device_machine_password_change_rate() const {
  const ::enterprise_management::DeviceMachinePasswordChangeRateProto* p = _impl_.device_machine_password_change_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceMachinePasswordChangeRateProto&>(
      ::enterprise_management::_DeviceMachinePasswordChangeRateProto_default_instance_);
}
inline const ::enterprise_management::DeviceMachinePasswordChangeRateProto& ChromeDeviceSettingsProto::device_machine_password_change_rate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_machine_password_change_rate)
  return _internal_device_machine_password_change_rate();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_machine_password_change_rate(
    ::enterprise_management::DeviceMachinePasswordChangeRateProto* device_machine_password_change_rate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_machine_password_change_rate_);
  }
  _impl_.device_machine_password_change_rate_ = device_machine_password_change_rate;
  if (device_machine_password_change_rate) {
    _impl_._has_bits_[2] |= 0x00000010u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_machine_password_change_rate)
}
inline ::enterprise_management::DeviceMachinePasswordChangeRateProto* ChromeDeviceSettingsProto::release_device_machine_password_change_rate() {
  _impl_._has_bits_[2] &= ~0x00000010u;
  ::enterprise_management::DeviceMachinePasswordChangeRateProto* temp = _impl_.device_machine_password_change_rate_;
  _impl_.device_machine_password_change_rate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceMachinePasswordChangeRateProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_machine_password_change_rate() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_machine_password_change_rate)
  _impl_._has_bits_[2] &= ~0x00000010u;
  ::enterprise_management::DeviceMachinePasswordChangeRateProto* temp = _impl_.device_machine_password_change_rate_;
  _impl_.device_machine_password_change_rate_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceMachinePasswordChangeRateProto* ChromeDeviceSettingsProto::_internal_mutable_device_machine_password_change_rate() {
  _impl_._has_bits_[2] |= 0x00000010u;
  if (_impl_.device_machine_password_change_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceMachinePasswordChangeRateProto>(GetArenaForAllocation());
    _impl_.device_machine_password_change_rate_ = p;
  }
  return _impl_.device_machine_password_change_rate_;
}
inline ::enterprise_management::DeviceMachinePasswordChangeRateProto* ChromeDeviceSettingsProto::mutable_device_machine_password_change_rate() {
  ::enterprise_management::DeviceMachinePasswordChangeRateProto* _msg = _internal_mutable_device_machine_password_change_rate();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_machine_password_change_rate)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_machine_password_change_rate(::enterprise_management::DeviceMachinePasswordChangeRateProto* device_machine_password_change_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_machine_password_change_rate_;
  }
  if (device_machine_password_change_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_machine_password_change_rate);
    if (message_arena != submessage_arena) {
      device_machine_password_change_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_machine_password_change_rate, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000010u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000010u;
  }
  _impl_.device_machine_password_change_rate_ = device_machine_password_change_rate;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_machine_password_change_rate)
}

// optional .enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto device_unaffiliated_crostini_allowed = 72;
inline bool ChromeDeviceSettingsProto::_internal_has_device_unaffiliated_crostini_allowed() const {
  bool value = (_impl_._has_bits_[2] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_unaffiliated_crostini_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_unaffiliated_crostini_allowed() const {
  return _internal_has_device_unaffiliated_crostini_allowed();
}
inline void ChromeDeviceSettingsProto::clear_device_unaffiliated_crostini_allowed() {
  if (_impl_.device_unaffiliated_crostini_allowed_ != nullptr) _impl_.device_unaffiliated_crostini_allowed_->Clear();
  _impl_._has_bits_[2] &= ~0x00000020u;
}
inline const ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto& ChromeDeviceSettingsProto::_internal_device_unaffiliated_crostini_allowed() const {
  const ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* p = _impl_.device_unaffiliated_crostini_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto&>(
      ::enterprise_management::_DeviceUnaffiliatedCrostiniAllowedProto_default_instance_);
}
inline const ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto& ChromeDeviceSettingsProto::device_unaffiliated_crostini_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_unaffiliated_crostini_allowed)
  return _internal_device_unaffiliated_crostini_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_unaffiliated_crostini_allowed(
    ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* device_unaffiliated_crostini_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_unaffiliated_crostini_allowed_);
  }
  _impl_.device_unaffiliated_crostini_allowed_ = device_unaffiliated_crostini_allowed;
  if (device_unaffiliated_crostini_allowed) {
    _impl_._has_bits_[2] |= 0x00000020u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_unaffiliated_crostini_allowed)
}
inline ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* ChromeDeviceSettingsProto::release_device_unaffiliated_crostini_allowed() {
  _impl_._has_bits_[2] &= ~0x00000020u;
  ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* temp = _impl_.device_unaffiliated_crostini_allowed_;
  _impl_.device_unaffiliated_crostini_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_unaffiliated_crostini_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_unaffiliated_crostini_allowed)
  _impl_._has_bits_[2] &= ~0x00000020u;
  ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* temp = _impl_.device_unaffiliated_crostini_allowed_;
  _impl_.device_unaffiliated_crostini_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_device_unaffiliated_crostini_allowed() {
  _impl_._has_bits_[2] |= 0x00000020u;
  if (_impl_.device_unaffiliated_crostini_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto>(GetArenaForAllocation());
    _impl_.device_unaffiliated_crostini_allowed_ = p;
  }
  return _impl_.device_unaffiliated_crostini_allowed_;
}
inline ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* ChromeDeviceSettingsProto::mutable_device_unaffiliated_crostini_allowed() {
  ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* _msg = _internal_mutable_device_unaffiliated_crostini_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_unaffiliated_crostini_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_unaffiliated_crostini_allowed(::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto* device_unaffiliated_crostini_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_unaffiliated_crostini_allowed_;
  }
  if (device_unaffiliated_crostini_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_unaffiliated_crostini_allowed);
    if (message_arena != submessage_arena) {
      device_unaffiliated_crostini_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_unaffiliated_crostini_allowed, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000020u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000020u;
  }
  _impl_.device_unaffiliated_crostini_allowed_ = device_unaffiliated_crostini_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_unaffiliated_crostini_allowed)
}

// optional .enterprise_management.DeviceWiFiFastTransitionEnabledProto device_wifi_fast_transition_enabled = 73;
inline bool ChromeDeviceSettingsProto::_internal_has_device_wifi_fast_transition_enabled() const {
  bool value = (_impl_._has_bits_[2] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_wifi_fast_transition_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_wifi_fast_transition_enabled() const {
  return _internal_has_device_wifi_fast_transition_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_wifi_fast_transition_enabled() {
  if (_impl_.device_wifi_fast_transition_enabled_ != nullptr) _impl_.device_wifi_fast_transition_enabled_->Clear();
  _impl_._has_bits_[2] &= ~0x00000040u;
}
inline const ::enterprise_management::DeviceWiFiFastTransitionEnabledProto& ChromeDeviceSettingsProto::_internal_device_wifi_fast_transition_enabled() const {
  const ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* p = _impl_.device_wifi_fast_transition_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceWiFiFastTransitionEnabledProto&>(
      ::enterprise_management::_DeviceWiFiFastTransitionEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceWiFiFastTransitionEnabledProto& ChromeDeviceSettingsProto::device_wifi_fast_transition_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_wifi_fast_transition_enabled)
  return _internal_device_wifi_fast_transition_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_wifi_fast_transition_enabled(
    ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* device_wifi_fast_transition_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_wifi_fast_transition_enabled_);
  }
  _impl_.device_wifi_fast_transition_enabled_ = device_wifi_fast_transition_enabled;
  if (device_wifi_fast_transition_enabled) {
    _impl_._has_bits_[2] |= 0x00000040u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wifi_fast_transition_enabled)
}
inline ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* ChromeDeviceSettingsProto::release_device_wifi_fast_transition_enabled() {
  _impl_._has_bits_[2] &= ~0x00000040u;
  ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* temp = _impl_.device_wifi_fast_transition_enabled_;
  _impl_.device_wifi_fast_transition_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_wifi_fast_transition_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_wifi_fast_transition_enabled)
  _impl_._has_bits_[2] &= ~0x00000040u;
  ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* temp = _impl_.device_wifi_fast_transition_enabled_;
  _impl_.device_wifi_fast_transition_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_wifi_fast_transition_enabled() {
  _impl_._has_bits_[2] |= 0x00000040u;
  if (_impl_.device_wifi_fast_transition_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceWiFiFastTransitionEnabledProto>(GetArenaForAllocation());
    _impl_.device_wifi_fast_transition_enabled_ = p;
  }
  return _impl_.device_wifi_fast_transition_enabled_;
}
inline ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* ChromeDeviceSettingsProto::mutable_device_wifi_fast_transition_enabled() {
  ::enterprise_management::DeviceWiFiFastTransitionEnabledProto* _msg = _internal_mutable_device_wifi_fast_transition_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_wifi_fast_transition_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_wifi_fast_transition_enabled(::enterprise_management::DeviceWiFiFastTransitionEnabledProto* device_wifi_fast_transition_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_wifi_fast_transition_enabled_;
  }
  if (device_wifi_fast_transition_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_wifi_fast_transition_enabled);
    if (message_arena != submessage_arena) {
      device_wifi_fast_transition_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_wifi_fast_transition_enabled, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000040u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000040u;
  }
  _impl_.device_wifi_fast_transition_enabled_ = device_wifi_fast_transition_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wifi_fast_transition_enabled)
}

// optional .enterprise_management.DeviceDisplayResolutionProto device_display_resolution = 74;
inline bool ChromeDeviceSettingsProto::_internal_has_device_display_resolution() const {
  bool value = (_impl_._has_bits_[2] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_display_resolution_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_display_resolution() const {
  return _internal_has_device_display_resolution();
}
inline void ChromeDeviceSettingsProto::clear_device_display_resolution() {
  if (_impl_.device_display_resolution_ != nullptr) _impl_.device_display_resolution_->Clear();
  _impl_._has_bits_[2] &= ~0x00000080u;
}
inline const ::enterprise_management::DeviceDisplayResolutionProto& ChromeDeviceSettingsProto::_internal_device_display_resolution() const {
  const ::enterprise_management::DeviceDisplayResolutionProto* p = _impl_.device_display_resolution_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceDisplayResolutionProto&>(
      ::enterprise_management::_DeviceDisplayResolutionProto_default_instance_);
}
inline const ::enterprise_management::DeviceDisplayResolutionProto& ChromeDeviceSettingsProto::device_display_resolution() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_display_resolution)
  return _internal_device_display_resolution();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_display_resolution(
    ::enterprise_management::DeviceDisplayResolutionProto* device_display_resolution) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_display_resolution_);
  }
  _impl_.device_display_resolution_ = device_display_resolution;
  if (device_display_resolution) {
    _impl_._has_bits_[2] |= 0x00000080u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_display_resolution)
}
inline ::enterprise_management::DeviceDisplayResolutionProto* ChromeDeviceSettingsProto::release_device_display_resolution() {
  _impl_._has_bits_[2] &= ~0x00000080u;
  ::enterprise_management::DeviceDisplayResolutionProto* temp = _impl_.device_display_resolution_;
  _impl_.device_display_resolution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceDisplayResolutionProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_display_resolution() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_display_resolution)
  _impl_._has_bits_[2] &= ~0x00000080u;
  ::enterprise_management::DeviceDisplayResolutionProto* temp = _impl_.device_display_resolution_;
  _impl_.device_display_resolution_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceDisplayResolutionProto* ChromeDeviceSettingsProto::_internal_mutable_device_display_resolution() {
  _impl_._has_bits_[2] |= 0x00000080u;
  if (_impl_.device_display_resolution_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceDisplayResolutionProto>(GetArenaForAllocation());
    _impl_.device_display_resolution_ = p;
  }
  return _impl_.device_display_resolution_;
}
inline ::enterprise_management::DeviceDisplayResolutionProto* ChromeDeviceSettingsProto::mutable_device_display_resolution() {
  ::enterprise_management::DeviceDisplayResolutionProto* _msg = _internal_mutable_device_display_resolution();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_display_resolution)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_display_resolution(::enterprise_management::DeviceDisplayResolutionProto* device_display_resolution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_display_resolution_;
  }
  if (device_display_resolution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_display_resolution);
    if (message_arena != submessage_arena) {
      device_display_resolution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_display_resolution, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000080u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000080u;
  }
  _impl_.device_display_resolution_ = device_display_resolution;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_display_resolution)
}

// optional .enterprise_management.PluginVmAllowedProto plugin_vm_allowed = 75;
inline bool ChromeDeviceSettingsProto::_internal_has_plugin_vm_allowed() const {
  bool value = (_impl_._has_bits_[2] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.plugin_vm_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_plugin_vm_allowed() const {
  return _internal_has_plugin_vm_allowed();
}
inline void ChromeDeviceSettingsProto::clear_plugin_vm_allowed() {
  if (_impl_.plugin_vm_allowed_ != nullptr) _impl_.plugin_vm_allowed_->Clear();
  _impl_._has_bits_[2] &= ~0x00000100u;
}
inline const ::enterprise_management::PluginVmAllowedProto& ChromeDeviceSettingsProto::_internal_plugin_vm_allowed() const {
  const ::enterprise_management::PluginVmAllowedProto* p = _impl_.plugin_vm_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PluginVmAllowedProto&>(
      ::enterprise_management::_PluginVmAllowedProto_default_instance_);
}
inline const ::enterprise_management::PluginVmAllowedProto& ChromeDeviceSettingsProto::plugin_vm_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_allowed)
  return _internal_plugin_vm_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_plugin_vm_allowed(
    ::enterprise_management::PluginVmAllowedProto* plugin_vm_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.plugin_vm_allowed_);
  }
  _impl_.plugin_vm_allowed_ = plugin_vm_allowed;
  if (plugin_vm_allowed) {
    _impl_._has_bits_[2] |= 0x00000100u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_allowed)
}
inline ::enterprise_management::PluginVmAllowedProto* ChromeDeviceSettingsProto::release_plugin_vm_allowed() {
  _impl_._has_bits_[2] &= ~0x00000100u;
  ::enterprise_management::PluginVmAllowedProto* temp = _impl_.plugin_vm_allowed_;
  _impl_.plugin_vm_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PluginVmAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_plugin_vm_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_allowed)
  _impl_._has_bits_[2] &= ~0x00000100u;
  ::enterprise_management::PluginVmAllowedProto* temp = _impl_.plugin_vm_allowed_;
  _impl_.plugin_vm_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::PluginVmAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_plugin_vm_allowed() {
  _impl_._has_bits_[2] |= 0x00000100u;
  if (_impl_.plugin_vm_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PluginVmAllowedProto>(GetArenaForAllocation());
    _impl_.plugin_vm_allowed_ = p;
  }
  return _impl_.plugin_vm_allowed_;
}
inline ::enterprise_management::PluginVmAllowedProto* ChromeDeviceSettingsProto::mutable_plugin_vm_allowed() {
  ::enterprise_management::PluginVmAllowedProto* _msg = _internal_mutable_plugin_vm_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_plugin_vm_allowed(::enterprise_management::PluginVmAllowedProto* plugin_vm_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.plugin_vm_allowed_;
  }
  if (plugin_vm_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(plugin_vm_allowed);
    if (message_arena != submessage_arena) {
      plugin_vm_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plugin_vm_allowed, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000100u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000100u;
  }
  _impl_.plugin_vm_allowed_ = plugin_vm_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_allowed)
}

// optional .enterprise_management.DeviceGpoCacheLifetimeProto device_gpo_cache_lifetime = 76;
inline bool ChromeDeviceSettingsProto::_internal_has_device_gpo_cache_lifetime() const {
  bool value = (_impl_._has_bits_[2] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_gpo_cache_lifetime_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_gpo_cache_lifetime() const {
  return _internal_has_device_gpo_cache_lifetime();
}
inline void ChromeDeviceSettingsProto::clear_device_gpo_cache_lifetime() {
  if (_impl_.device_gpo_cache_lifetime_ != nullptr) _impl_.device_gpo_cache_lifetime_->Clear();
  _impl_._has_bits_[2] &= ~0x00000200u;
}
inline const ::enterprise_management::DeviceGpoCacheLifetimeProto& ChromeDeviceSettingsProto::_internal_device_gpo_cache_lifetime() const {
  const ::enterprise_management::DeviceGpoCacheLifetimeProto* p = _impl_.device_gpo_cache_lifetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceGpoCacheLifetimeProto&>(
      ::enterprise_management::_DeviceGpoCacheLifetimeProto_default_instance_);
}
inline const ::enterprise_management::DeviceGpoCacheLifetimeProto& ChromeDeviceSettingsProto::device_gpo_cache_lifetime() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_gpo_cache_lifetime)
  return _internal_device_gpo_cache_lifetime();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_gpo_cache_lifetime(
    ::enterprise_management::DeviceGpoCacheLifetimeProto* device_gpo_cache_lifetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_gpo_cache_lifetime_);
  }
  _impl_.device_gpo_cache_lifetime_ = device_gpo_cache_lifetime;
  if (device_gpo_cache_lifetime) {
    _impl_._has_bits_[2] |= 0x00000200u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_gpo_cache_lifetime)
}
inline ::enterprise_management::DeviceGpoCacheLifetimeProto* ChromeDeviceSettingsProto::release_device_gpo_cache_lifetime() {
  _impl_._has_bits_[2] &= ~0x00000200u;
  ::enterprise_management::DeviceGpoCacheLifetimeProto* temp = _impl_.device_gpo_cache_lifetime_;
  _impl_.device_gpo_cache_lifetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceGpoCacheLifetimeProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_gpo_cache_lifetime() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_gpo_cache_lifetime)
  _impl_._has_bits_[2] &= ~0x00000200u;
  ::enterprise_management::DeviceGpoCacheLifetimeProto* temp = _impl_.device_gpo_cache_lifetime_;
  _impl_.device_gpo_cache_lifetime_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceGpoCacheLifetimeProto* ChromeDeviceSettingsProto::_internal_mutable_device_gpo_cache_lifetime() {
  _impl_._has_bits_[2] |= 0x00000200u;
  if (_impl_.device_gpo_cache_lifetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceGpoCacheLifetimeProto>(GetArenaForAllocation());
    _impl_.device_gpo_cache_lifetime_ = p;
  }
  return _impl_.device_gpo_cache_lifetime_;
}
inline ::enterprise_management::DeviceGpoCacheLifetimeProto* ChromeDeviceSettingsProto::mutable_device_gpo_cache_lifetime() {
  ::enterprise_management::DeviceGpoCacheLifetimeProto* _msg = _internal_mutable_device_gpo_cache_lifetime();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_gpo_cache_lifetime)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_gpo_cache_lifetime(::enterprise_management::DeviceGpoCacheLifetimeProto* device_gpo_cache_lifetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_gpo_cache_lifetime_;
  }
  if (device_gpo_cache_lifetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_gpo_cache_lifetime);
    if (message_arena != submessage_arena) {
      device_gpo_cache_lifetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_gpo_cache_lifetime, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000200u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000200u;
  }
  _impl_.device_gpo_cache_lifetime_ = device_gpo_cache_lifetime;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_gpo_cache_lifetime)
}

// optional .enterprise_management.DeviceAuthDataCacheLifetimeProto device_auth_data_cache_lifetime = 77;
inline bool ChromeDeviceSettingsProto::_internal_has_device_auth_data_cache_lifetime() const {
  bool value = (_impl_._has_bits_[2] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_auth_data_cache_lifetime_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_auth_data_cache_lifetime() const {
  return _internal_has_device_auth_data_cache_lifetime();
}
inline void ChromeDeviceSettingsProto::clear_device_auth_data_cache_lifetime() {
  if (_impl_.device_auth_data_cache_lifetime_ != nullptr) _impl_.device_auth_data_cache_lifetime_->Clear();
  _impl_._has_bits_[2] &= ~0x00000400u;
}
inline const ::enterprise_management::DeviceAuthDataCacheLifetimeProto& ChromeDeviceSettingsProto::_internal_device_auth_data_cache_lifetime() const {
  const ::enterprise_management::DeviceAuthDataCacheLifetimeProto* p = _impl_.device_auth_data_cache_lifetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAuthDataCacheLifetimeProto&>(
      ::enterprise_management::_DeviceAuthDataCacheLifetimeProto_default_instance_);
}
inline const ::enterprise_management::DeviceAuthDataCacheLifetimeProto& ChromeDeviceSettingsProto::device_auth_data_cache_lifetime() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_auth_data_cache_lifetime)
  return _internal_device_auth_data_cache_lifetime();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_auth_data_cache_lifetime(
    ::enterprise_management::DeviceAuthDataCacheLifetimeProto* device_auth_data_cache_lifetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_auth_data_cache_lifetime_);
  }
  _impl_.device_auth_data_cache_lifetime_ = device_auth_data_cache_lifetime;
  if (device_auth_data_cache_lifetime) {
    _impl_._has_bits_[2] |= 0x00000400u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_auth_data_cache_lifetime)
}
inline ::enterprise_management::DeviceAuthDataCacheLifetimeProto* ChromeDeviceSettingsProto::release_device_auth_data_cache_lifetime() {
  _impl_._has_bits_[2] &= ~0x00000400u;
  ::enterprise_management::DeviceAuthDataCacheLifetimeProto* temp = _impl_.device_auth_data_cache_lifetime_;
  _impl_.device_auth_data_cache_lifetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAuthDataCacheLifetimeProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_auth_data_cache_lifetime() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_auth_data_cache_lifetime)
  _impl_._has_bits_[2] &= ~0x00000400u;
  ::enterprise_management::DeviceAuthDataCacheLifetimeProto* temp = _impl_.device_auth_data_cache_lifetime_;
  _impl_.device_auth_data_cache_lifetime_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAuthDataCacheLifetimeProto* ChromeDeviceSettingsProto::_internal_mutable_device_auth_data_cache_lifetime() {
  _impl_._has_bits_[2] |= 0x00000400u;
  if (_impl_.device_auth_data_cache_lifetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAuthDataCacheLifetimeProto>(GetArenaForAllocation());
    _impl_.device_auth_data_cache_lifetime_ = p;
  }
  return _impl_.device_auth_data_cache_lifetime_;
}
inline ::enterprise_management::DeviceAuthDataCacheLifetimeProto* ChromeDeviceSettingsProto::mutable_device_auth_data_cache_lifetime() {
  ::enterprise_management::DeviceAuthDataCacheLifetimeProto* _msg = _internal_mutable_device_auth_data_cache_lifetime();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_auth_data_cache_lifetime)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_auth_data_cache_lifetime(::enterprise_management::DeviceAuthDataCacheLifetimeProto* device_auth_data_cache_lifetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_auth_data_cache_lifetime_;
  }
  if (device_auth_data_cache_lifetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_auth_data_cache_lifetime);
    if (message_arena != submessage_arena) {
      device_auth_data_cache_lifetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_auth_data_cache_lifetime, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000400u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000400u;
  }
  _impl_.device_auth_data_cache_lifetime_ = device_auth_data_cache_lifetime;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_auth_data_cache_lifetime)
}

// optional .enterprise_management.PluginVmLicenseKeyProto plugin_vm_license_key = 78;
inline bool ChromeDeviceSettingsProto::_internal_has_plugin_vm_license_key() const {
  bool value = (_impl_._has_bits_[2] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.plugin_vm_license_key_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_plugin_vm_license_key() const {
  return _internal_has_plugin_vm_license_key();
}
inline void ChromeDeviceSettingsProto::clear_plugin_vm_license_key() {
  if (_impl_.plugin_vm_license_key_ != nullptr) _impl_.plugin_vm_license_key_->Clear();
  _impl_._has_bits_[2] &= ~0x00000800u;
}
inline const ::enterprise_management::PluginVmLicenseKeyProto& ChromeDeviceSettingsProto::_internal_plugin_vm_license_key() const {
  const ::enterprise_management::PluginVmLicenseKeyProto* p = _impl_.plugin_vm_license_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PluginVmLicenseKeyProto&>(
      ::enterprise_management::_PluginVmLicenseKeyProto_default_instance_);
}
inline const ::enterprise_management::PluginVmLicenseKeyProto& ChromeDeviceSettingsProto::plugin_vm_license_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_license_key)
  return _internal_plugin_vm_license_key();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_plugin_vm_license_key(
    ::enterprise_management::PluginVmLicenseKeyProto* plugin_vm_license_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.plugin_vm_license_key_);
  }
  _impl_.plugin_vm_license_key_ = plugin_vm_license_key;
  if (plugin_vm_license_key) {
    _impl_._has_bits_[2] |= 0x00000800u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_license_key)
}
inline ::enterprise_management::PluginVmLicenseKeyProto* ChromeDeviceSettingsProto::release_plugin_vm_license_key() {
  _impl_._has_bits_[2] &= ~0x00000800u;
  ::enterprise_management::PluginVmLicenseKeyProto* temp = _impl_.plugin_vm_license_key_;
  _impl_.plugin_vm_license_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PluginVmLicenseKeyProto* ChromeDeviceSettingsProto::unsafe_arena_release_plugin_vm_license_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_license_key)
  _impl_._has_bits_[2] &= ~0x00000800u;
  ::enterprise_management::PluginVmLicenseKeyProto* temp = _impl_.plugin_vm_license_key_;
  _impl_.plugin_vm_license_key_ = nullptr;
  return temp;
}
inline ::enterprise_management::PluginVmLicenseKeyProto* ChromeDeviceSettingsProto::_internal_mutable_plugin_vm_license_key() {
  _impl_._has_bits_[2] |= 0x00000800u;
  if (_impl_.plugin_vm_license_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PluginVmLicenseKeyProto>(GetArenaForAllocation());
    _impl_.plugin_vm_license_key_ = p;
  }
  return _impl_.plugin_vm_license_key_;
}
inline ::enterprise_management::PluginVmLicenseKeyProto* ChromeDeviceSettingsProto::mutable_plugin_vm_license_key() {
  ::enterprise_management::PluginVmLicenseKeyProto* _msg = _internal_mutable_plugin_vm_license_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_license_key)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_plugin_vm_license_key(::enterprise_management::PluginVmLicenseKeyProto* plugin_vm_license_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.plugin_vm_license_key_;
  }
  if (plugin_vm_license_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(plugin_vm_license_key);
    if (message_arena != submessage_arena) {
      plugin_vm_license_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plugin_vm_license_key, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00000800u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000800u;
  }
  _impl_.plugin_vm_license_key_ = plugin_vm_license_key;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.plugin_vm_license_key)
}

// optional .enterprise_management.DeviceRebootOnUserSignoutProto device_reboot_on_user_signout = 79;
inline bool ChromeDeviceSettingsProto::_internal_has_device_reboot_on_user_signout() const {
  bool value = (_impl_._has_bits_[2] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_reboot_on_user_signout_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_reboot_on_user_signout() const {
  return _internal_has_device_reboot_on_user_signout();
}
inline void ChromeDeviceSettingsProto::clear_device_reboot_on_user_signout() {
  if (_impl_.device_reboot_on_user_signout_ != nullptr) _impl_.device_reboot_on_user_signout_->Clear();
  _impl_._has_bits_[2] &= ~0x00001000u;
}
inline const ::enterprise_management::DeviceRebootOnUserSignoutProto& ChromeDeviceSettingsProto::_internal_device_reboot_on_user_signout() const {
  const ::enterprise_management::DeviceRebootOnUserSignoutProto* p = _impl_.device_reboot_on_user_signout_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRebootOnUserSignoutProto&>(
      ::enterprise_management::_DeviceRebootOnUserSignoutProto_default_instance_);
}
inline const ::enterprise_management::DeviceRebootOnUserSignoutProto& ChromeDeviceSettingsProto::device_reboot_on_user_signout() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_reboot_on_user_signout)
  return _internal_device_reboot_on_user_signout();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_reboot_on_user_signout(
    ::enterprise_management::DeviceRebootOnUserSignoutProto* device_reboot_on_user_signout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_reboot_on_user_signout_);
  }
  _impl_.device_reboot_on_user_signout_ = device_reboot_on_user_signout;
  if (device_reboot_on_user_signout) {
    _impl_._has_bits_[2] |= 0x00001000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_reboot_on_user_signout)
}
inline ::enterprise_management::DeviceRebootOnUserSignoutProto* ChromeDeviceSettingsProto::release_device_reboot_on_user_signout() {
  _impl_._has_bits_[2] &= ~0x00001000u;
  ::enterprise_management::DeviceRebootOnUserSignoutProto* temp = _impl_.device_reboot_on_user_signout_;
  _impl_.device_reboot_on_user_signout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRebootOnUserSignoutProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_reboot_on_user_signout() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_reboot_on_user_signout)
  _impl_._has_bits_[2] &= ~0x00001000u;
  ::enterprise_management::DeviceRebootOnUserSignoutProto* temp = _impl_.device_reboot_on_user_signout_;
  _impl_.device_reboot_on_user_signout_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRebootOnUserSignoutProto* ChromeDeviceSettingsProto::_internal_mutable_device_reboot_on_user_signout() {
  _impl_._has_bits_[2] |= 0x00001000u;
  if (_impl_.device_reboot_on_user_signout_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRebootOnUserSignoutProto>(GetArenaForAllocation());
    _impl_.device_reboot_on_user_signout_ = p;
  }
  return _impl_.device_reboot_on_user_signout_;
}
inline ::enterprise_management::DeviceRebootOnUserSignoutProto* ChromeDeviceSettingsProto::mutable_device_reboot_on_user_signout() {
  ::enterprise_management::DeviceRebootOnUserSignoutProto* _msg = _internal_mutable_device_reboot_on_user_signout();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_reboot_on_user_signout)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_reboot_on_user_signout(::enterprise_management::DeviceRebootOnUserSignoutProto* device_reboot_on_user_signout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_reboot_on_user_signout_;
  }
  if (device_reboot_on_user_signout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_reboot_on_user_signout);
    if (message_arena != submessage_arena) {
      device_reboot_on_user_signout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_reboot_on_user_signout, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00001000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00001000u;
  }
  _impl_.device_reboot_on_user_signout_ = device_reboot_on_user_signout;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_reboot_on_user_signout)
}

// optional .enterprise_management.DeviceWilcoDtcAllowedProto device_wilco_dtc_allowed = 80;
inline bool ChromeDeviceSettingsProto::_internal_has_device_wilco_dtc_allowed() const {
  bool value = (_impl_._has_bits_[2] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_wilco_dtc_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_wilco_dtc_allowed() const {
  return _internal_has_device_wilco_dtc_allowed();
}
inline void ChromeDeviceSettingsProto::clear_device_wilco_dtc_allowed() {
  if (_impl_.device_wilco_dtc_allowed_ != nullptr) _impl_.device_wilco_dtc_allowed_->Clear();
  _impl_._has_bits_[2] &= ~0x00002000u;
}
inline const ::enterprise_management::DeviceWilcoDtcAllowedProto& ChromeDeviceSettingsProto::_internal_device_wilco_dtc_allowed() const {
  const ::enterprise_management::DeviceWilcoDtcAllowedProto* p = _impl_.device_wilco_dtc_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceWilcoDtcAllowedProto&>(
      ::enterprise_management::_DeviceWilcoDtcAllowedProto_default_instance_);
}
inline const ::enterprise_management::DeviceWilcoDtcAllowedProto& ChromeDeviceSettingsProto::device_wilco_dtc_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_allowed)
  return _internal_device_wilco_dtc_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_wilco_dtc_allowed(
    ::enterprise_management::DeviceWilcoDtcAllowedProto* device_wilco_dtc_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_wilco_dtc_allowed_);
  }
  _impl_.device_wilco_dtc_allowed_ = device_wilco_dtc_allowed;
  if (device_wilco_dtc_allowed) {
    _impl_._has_bits_[2] |= 0x00002000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_allowed)
}
inline ::enterprise_management::DeviceWilcoDtcAllowedProto* ChromeDeviceSettingsProto::release_device_wilco_dtc_allowed() {
  _impl_._has_bits_[2] &= ~0x00002000u;
  ::enterprise_management::DeviceWilcoDtcAllowedProto* temp = _impl_.device_wilco_dtc_allowed_;
  _impl_.device_wilco_dtc_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceWilcoDtcAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_wilco_dtc_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_allowed)
  _impl_._has_bits_[2] &= ~0x00002000u;
  ::enterprise_management::DeviceWilcoDtcAllowedProto* temp = _impl_.device_wilco_dtc_allowed_;
  _impl_.device_wilco_dtc_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceWilcoDtcAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_device_wilco_dtc_allowed() {
  _impl_._has_bits_[2] |= 0x00002000u;
  if (_impl_.device_wilco_dtc_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceWilcoDtcAllowedProto>(GetArenaForAllocation());
    _impl_.device_wilco_dtc_allowed_ = p;
  }
  return _impl_.device_wilco_dtc_allowed_;
}
inline ::enterprise_management::DeviceWilcoDtcAllowedProto* ChromeDeviceSettingsProto::mutable_device_wilco_dtc_allowed() {
  ::enterprise_management::DeviceWilcoDtcAllowedProto* _msg = _internal_mutable_device_wilco_dtc_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_wilco_dtc_allowed(::enterprise_management::DeviceWilcoDtcAllowedProto* device_wilco_dtc_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_wilco_dtc_allowed_;
  }
  if (device_wilco_dtc_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_wilco_dtc_allowed);
    if (message_arena != submessage_arena) {
      device_wilco_dtc_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_wilco_dtc_allowed, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00002000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00002000u;
  }
  _impl_.device_wilco_dtc_allowed_ = device_wilco_dtc_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_allowed)
}

// optional .enterprise_management.DeviceWilcoDtcConfigurationProto device_wilco_dtc_configuration = 81;
inline bool ChromeDeviceSettingsProto::_internal_has_device_wilco_dtc_configuration() const {
  bool value = (_impl_._has_bits_[2] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_wilco_dtc_configuration_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_wilco_dtc_configuration() const {
  return _internal_has_device_wilco_dtc_configuration();
}
inline void ChromeDeviceSettingsProto::clear_device_wilco_dtc_configuration() {
  if (_impl_.device_wilco_dtc_configuration_ != nullptr) _impl_.device_wilco_dtc_configuration_->Clear();
  _impl_._has_bits_[2] &= ~0x00004000u;
}
inline const ::enterprise_management::DeviceWilcoDtcConfigurationProto& ChromeDeviceSettingsProto::_internal_device_wilco_dtc_configuration() const {
  const ::enterprise_management::DeviceWilcoDtcConfigurationProto* p = _impl_.device_wilco_dtc_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceWilcoDtcConfigurationProto&>(
      ::enterprise_management::_DeviceWilcoDtcConfigurationProto_default_instance_);
}
inline const ::enterprise_management::DeviceWilcoDtcConfigurationProto& ChromeDeviceSettingsProto::device_wilco_dtc_configuration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_configuration)
  return _internal_device_wilco_dtc_configuration();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_wilco_dtc_configuration(
    ::enterprise_management::DeviceWilcoDtcConfigurationProto* device_wilco_dtc_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_wilco_dtc_configuration_);
  }
  _impl_.device_wilco_dtc_configuration_ = device_wilco_dtc_configuration;
  if (device_wilco_dtc_configuration) {
    _impl_._has_bits_[2] |= 0x00004000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_configuration)
}
inline ::enterprise_management::DeviceWilcoDtcConfigurationProto* ChromeDeviceSettingsProto::release_device_wilco_dtc_configuration() {
  _impl_._has_bits_[2] &= ~0x00004000u;
  ::enterprise_management::DeviceWilcoDtcConfigurationProto* temp = _impl_.device_wilco_dtc_configuration_;
  _impl_.device_wilco_dtc_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceWilcoDtcConfigurationProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_wilco_dtc_configuration() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_configuration)
  _impl_._has_bits_[2] &= ~0x00004000u;
  ::enterprise_management::DeviceWilcoDtcConfigurationProto* temp = _impl_.device_wilco_dtc_configuration_;
  _impl_.device_wilco_dtc_configuration_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceWilcoDtcConfigurationProto* ChromeDeviceSettingsProto::_internal_mutable_device_wilco_dtc_configuration() {
  _impl_._has_bits_[2] |= 0x00004000u;
  if (_impl_.device_wilco_dtc_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceWilcoDtcConfigurationProto>(GetArenaForAllocation());
    _impl_.device_wilco_dtc_configuration_ = p;
  }
  return _impl_.device_wilco_dtc_configuration_;
}
inline ::enterprise_management::DeviceWilcoDtcConfigurationProto* ChromeDeviceSettingsProto::mutable_device_wilco_dtc_configuration() {
  ::enterprise_management::DeviceWilcoDtcConfigurationProto* _msg = _internal_mutable_device_wilco_dtc_configuration();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_configuration)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_wilco_dtc_configuration(::enterprise_management::DeviceWilcoDtcConfigurationProto* device_wilco_dtc_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_wilco_dtc_configuration_;
  }
  if (device_wilco_dtc_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_wilco_dtc_configuration);
    if (message_arena != submessage_arena) {
      device_wilco_dtc_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_wilco_dtc_configuration, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00004000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00004000u;
  }
  _impl_.device_wilco_dtc_configuration_ = device_wilco_dtc_configuration;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wilco_dtc_configuration)
}

// optional .enterprise_management.DeviceWiFiAllowedProto device_wifi_allowed = 82;
inline bool ChromeDeviceSettingsProto::_internal_has_device_wifi_allowed() const {
  bool value = (_impl_._has_bits_[2] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_wifi_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_wifi_allowed() const {
  return _internal_has_device_wifi_allowed();
}
inline void ChromeDeviceSettingsProto::clear_device_wifi_allowed() {
  if (_impl_.device_wifi_allowed_ != nullptr) _impl_.device_wifi_allowed_->Clear();
  _impl_._has_bits_[2] &= ~0x00008000u;
}
inline const ::enterprise_management::DeviceWiFiAllowedProto& ChromeDeviceSettingsProto::_internal_device_wifi_allowed() const {
  const ::enterprise_management::DeviceWiFiAllowedProto* p = _impl_.device_wifi_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceWiFiAllowedProto&>(
      ::enterprise_management::_DeviceWiFiAllowedProto_default_instance_);
}
inline const ::enterprise_management::DeviceWiFiAllowedProto& ChromeDeviceSettingsProto::device_wifi_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_wifi_allowed)
  return _internal_device_wifi_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_wifi_allowed(
    ::enterprise_management::DeviceWiFiAllowedProto* device_wifi_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_wifi_allowed_);
  }
  _impl_.device_wifi_allowed_ = device_wifi_allowed;
  if (device_wifi_allowed) {
    _impl_._has_bits_[2] |= 0x00008000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wifi_allowed)
}
inline ::enterprise_management::DeviceWiFiAllowedProto* ChromeDeviceSettingsProto::release_device_wifi_allowed() {
  _impl_._has_bits_[2] &= ~0x00008000u;
  ::enterprise_management::DeviceWiFiAllowedProto* temp = _impl_.device_wifi_allowed_;
  _impl_.device_wifi_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceWiFiAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_wifi_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_wifi_allowed)
  _impl_._has_bits_[2] &= ~0x00008000u;
  ::enterprise_management::DeviceWiFiAllowedProto* temp = _impl_.device_wifi_allowed_;
  _impl_.device_wifi_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceWiFiAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_device_wifi_allowed() {
  _impl_._has_bits_[2] |= 0x00008000u;
  if (_impl_.device_wifi_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceWiFiAllowedProto>(GetArenaForAllocation());
    _impl_.device_wifi_allowed_ = p;
  }
  return _impl_.device_wifi_allowed_;
}
inline ::enterprise_management::DeviceWiFiAllowedProto* ChromeDeviceSettingsProto::mutable_device_wifi_allowed() {
  ::enterprise_management::DeviceWiFiAllowedProto* _msg = _internal_mutable_device_wifi_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_wifi_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_wifi_allowed(::enterprise_management::DeviceWiFiAllowedProto* device_wifi_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_wifi_allowed_;
  }
  if (device_wifi_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_wifi_allowed);
    if (message_arena != submessage_arena) {
      device_wifi_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_wifi_allowed, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00008000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00008000u;
  }
  _impl_.device_wifi_allowed_ = device_wifi_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_wifi_allowed)
}

// optional .enterprise_management.DevicePowerPeakShiftProto device_power_peak_shift = 83;
inline bool ChromeDeviceSettingsProto::_internal_has_device_power_peak_shift() const {
  bool value = (_impl_._has_bits_[2] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_power_peak_shift_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_power_peak_shift() const {
  return _internal_has_device_power_peak_shift();
}
inline void ChromeDeviceSettingsProto::clear_device_power_peak_shift() {
  if (_impl_.device_power_peak_shift_ != nullptr) _impl_.device_power_peak_shift_->Clear();
  _impl_._has_bits_[2] &= ~0x00010000u;
}
inline const ::enterprise_management::DevicePowerPeakShiftProto& ChromeDeviceSettingsProto::_internal_device_power_peak_shift() const {
  const ::enterprise_management::DevicePowerPeakShiftProto* p = _impl_.device_power_peak_shift_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePowerPeakShiftProto&>(
      ::enterprise_management::_DevicePowerPeakShiftProto_default_instance_);
}
inline const ::enterprise_management::DevicePowerPeakShiftProto& ChromeDeviceSettingsProto::device_power_peak_shift() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_power_peak_shift)
  return _internal_device_power_peak_shift();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_power_peak_shift(
    ::enterprise_management::DevicePowerPeakShiftProto* device_power_peak_shift) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_power_peak_shift_);
  }
  _impl_.device_power_peak_shift_ = device_power_peak_shift;
  if (device_power_peak_shift) {
    _impl_._has_bits_[2] |= 0x00010000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_power_peak_shift)
}
inline ::enterprise_management::DevicePowerPeakShiftProto* ChromeDeviceSettingsProto::release_device_power_peak_shift() {
  _impl_._has_bits_[2] &= ~0x00010000u;
  ::enterprise_management::DevicePowerPeakShiftProto* temp = _impl_.device_power_peak_shift_;
  _impl_.device_power_peak_shift_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePowerPeakShiftProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_power_peak_shift() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_power_peak_shift)
  _impl_._has_bits_[2] &= ~0x00010000u;
  ::enterprise_management::DevicePowerPeakShiftProto* temp = _impl_.device_power_peak_shift_;
  _impl_.device_power_peak_shift_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePowerPeakShiftProto* ChromeDeviceSettingsProto::_internal_mutable_device_power_peak_shift() {
  _impl_._has_bits_[2] |= 0x00010000u;
  if (_impl_.device_power_peak_shift_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePowerPeakShiftProto>(GetArenaForAllocation());
    _impl_.device_power_peak_shift_ = p;
  }
  return _impl_.device_power_peak_shift_;
}
inline ::enterprise_management::DevicePowerPeakShiftProto* ChromeDeviceSettingsProto::mutable_device_power_peak_shift() {
  ::enterprise_management::DevicePowerPeakShiftProto* _msg = _internal_mutable_device_power_peak_shift();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_power_peak_shift)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_power_peak_shift(::enterprise_management::DevicePowerPeakShiftProto* device_power_peak_shift) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_power_peak_shift_;
  }
  if (device_power_peak_shift) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_power_peak_shift);
    if (message_arena != submessage_arena) {
      device_power_peak_shift = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_power_peak_shift, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00010000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00010000u;
  }
  _impl_.device_power_peak_shift_ = device_power_peak_shift;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_power_peak_shift)
}

// optional .enterprise_management.DeviceBootOnAcProto device_boot_on_ac = 84;
inline bool ChromeDeviceSettingsProto::_internal_has_device_boot_on_ac() const {
  bool value = (_impl_._has_bits_[2] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_boot_on_ac_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_boot_on_ac() const {
  return _internal_has_device_boot_on_ac();
}
inline void ChromeDeviceSettingsProto::clear_device_boot_on_ac() {
  if (_impl_.device_boot_on_ac_ != nullptr) _impl_.device_boot_on_ac_->Clear();
  _impl_._has_bits_[2] &= ~0x00020000u;
}
inline const ::enterprise_management::DeviceBootOnAcProto& ChromeDeviceSettingsProto::_internal_device_boot_on_ac() const {
  const ::enterprise_management::DeviceBootOnAcProto* p = _impl_.device_boot_on_ac_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceBootOnAcProto&>(
      ::enterprise_management::_DeviceBootOnAcProto_default_instance_);
}
inline const ::enterprise_management::DeviceBootOnAcProto& ChromeDeviceSettingsProto::device_boot_on_ac() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_boot_on_ac)
  return _internal_device_boot_on_ac();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_boot_on_ac(
    ::enterprise_management::DeviceBootOnAcProto* device_boot_on_ac) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_boot_on_ac_);
  }
  _impl_.device_boot_on_ac_ = device_boot_on_ac;
  if (device_boot_on_ac) {
    _impl_._has_bits_[2] |= 0x00020000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_boot_on_ac)
}
inline ::enterprise_management::DeviceBootOnAcProto* ChromeDeviceSettingsProto::release_device_boot_on_ac() {
  _impl_._has_bits_[2] &= ~0x00020000u;
  ::enterprise_management::DeviceBootOnAcProto* temp = _impl_.device_boot_on_ac_;
  _impl_.device_boot_on_ac_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceBootOnAcProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_boot_on_ac() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_boot_on_ac)
  _impl_._has_bits_[2] &= ~0x00020000u;
  ::enterprise_management::DeviceBootOnAcProto* temp = _impl_.device_boot_on_ac_;
  _impl_.device_boot_on_ac_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceBootOnAcProto* ChromeDeviceSettingsProto::_internal_mutable_device_boot_on_ac() {
  _impl_._has_bits_[2] |= 0x00020000u;
  if (_impl_.device_boot_on_ac_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceBootOnAcProto>(GetArenaForAllocation());
    _impl_.device_boot_on_ac_ = p;
  }
  return _impl_.device_boot_on_ac_;
}
inline ::enterprise_management::DeviceBootOnAcProto* ChromeDeviceSettingsProto::mutable_device_boot_on_ac() {
  ::enterprise_management::DeviceBootOnAcProto* _msg = _internal_mutable_device_boot_on_ac();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_boot_on_ac)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_boot_on_ac(::enterprise_management::DeviceBootOnAcProto* device_boot_on_ac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_boot_on_ac_;
  }
  if (device_boot_on_ac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_boot_on_ac);
    if (message_arena != submessage_arena) {
      device_boot_on_ac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_boot_on_ac, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00020000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00020000u;
  }
  _impl_.device_boot_on_ac_ = device_boot_on_ac;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_boot_on_ac)
}

// optional .enterprise_management.DeviceDockMacAddressSourceProto device_dock_mac_address_source = 85;
inline bool ChromeDeviceSettingsProto::_internal_has_device_dock_mac_address_source() const {
  bool value = (_impl_._has_bits_[2] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_dock_mac_address_source_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_dock_mac_address_source() const {
  return _internal_has_device_dock_mac_address_source();
}
inline void ChromeDeviceSettingsProto::clear_device_dock_mac_address_source() {
  if (_impl_.device_dock_mac_address_source_ != nullptr) _impl_.device_dock_mac_address_source_->Clear();
  _impl_._has_bits_[2] &= ~0x00040000u;
}
inline const ::enterprise_management::DeviceDockMacAddressSourceProto& ChromeDeviceSettingsProto::_internal_device_dock_mac_address_source() const {
  const ::enterprise_management::DeviceDockMacAddressSourceProto* p = _impl_.device_dock_mac_address_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceDockMacAddressSourceProto&>(
      ::enterprise_management::_DeviceDockMacAddressSourceProto_default_instance_);
}
inline const ::enterprise_management::DeviceDockMacAddressSourceProto& ChromeDeviceSettingsProto::device_dock_mac_address_source() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_dock_mac_address_source)
  return _internal_device_dock_mac_address_source();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_dock_mac_address_source(
    ::enterprise_management::DeviceDockMacAddressSourceProto* device_dock_mac_address_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_dock_mac_address_source_);
  }
  _impl_.device_dock_mac_address_source_ = device_dock_mac_address_source;
  if (device_dock_mac_address_source) {
    _impl_._has_bits_[2] |= 0x00040000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_dock_mac_address_source)
}
inline ::enterprise_management::DeviceDockMacAddressSourceProto* ChromeDeviceSettingsProto::release_device_dock_mac_address_source() {
  _impl_._has_bits_[2] &= ~0x00040000u;
  ::enterprise_management::DeviceDockMacAddressSourceProto* temp = _impl_.device_dock_mac_address_source_;
  _impl_.device_dock_mac_address_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceDockMacAddressSourceProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_dock_mac_address_source() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_dock_mac_address_source)
  _impl_._has_bits_[2] &= ~0x00040000u;
  ::enterprise_management::DeviceDockMacAddressSourceProto* temp = _impl_.device_dock_mac_address_source_;
  _impl_.device_dock_mac_address_source_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceDockMacAddressSourceProto* ChromeDeviceSettingsProto::_internal_mutable_device_dock_mac_address_source() {
  _impl_._has_bits_[2] |= 0x00040000u;
  if (_impl_.device_dock_mac_address_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceDockMacAddressSourceProto>(GetArenaForAllocation());
    _impl_.device_dock_mac_address_source_ = p;
  }
  return _impl_.device_dock_mac_address_source_;
}
inline ::enterprise_management::DeviceDockMacAddressSourceProto* ChromeDeviceSettingsProto::mutable_device_dock_mac_address_source() {
  ::enterprise_management::DeviceDockMacAddressSourceProto* _msg = _internal_mutable_device_dock_mac_address_source();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_dock_mac_address_source)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_dock_mac_address_source(::enterprise_management::DeviceDockMacAddressSourceProto* device_dock_mac_address_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_dock_mac_address_source_;
  }
  if (device_dock_mac_address_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_dock_mac_address_source);
    if (message_arena != submessage_arena) {
      device_dock_mac_address_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_dock_mac_address_source, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00040000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00040000u;
  }
  _impl_.device_dock_mac_address_source_ = device_dock_mac_address_source;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_dock_mac_address_source)
}

// optional .enterprise_management.DeviceAdvancedBatteryChargeModeProto device_advanced_battery_charge_mode = 86;
inline bool ChromeDeviceSettingsProto::_internal_has_device_advanced_battery_charge_mode() const {
  bool value = (_impl_._has_bits_[2] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_advanced_battery_charge_mode_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_advanced_battery_charge_mode() const {
  return _internal_has_device_advanced_battery_charge_mode();
}
inline void ChromeDeviceSettingsProto::clear_device_advanced_battery_charge_mode() {
  if (_impl_.device_advanced_battery_charge_mode_ != nullptr) _impl_.device_advanced_battery_charge_mode_->Clear();
  _impl_._has_bits_[2] &= ~0x00080000u;
}
inline const ::enterprise_management::DeviceAdvancedBatteryChargeModeProto& ChromeDeviceSettingsProto::_internal_device_advanced_battery_charge_mode() const {
  const ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* p = _impl_.device_advanced_battery_charge_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAdvancedBatteryChargeModeProto&>(
      ::enterprise_management::_DeviceAdvancedBatteryChargeModeProto_default_instance_);
}
inline const ::enterprise_management::DeviceAdvancedBatteryChargeModeProto& ChromeDeviceSettingsProto::device_advanced_battery_charge_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_advanced_battery_charge_mode)
  return _internal_device_advanced_battery_charge_mode();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_advanced_battery_charge_mode(
    ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* device_advanced_battery_charge_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_advanced_battery_charge_mode_);
  }
  _impl_.device_advanced_battery_charge_mode_ = device_advanced_battery_charge_mode;
  if (device_advanced_battery_charge_mode) {
    _impl_._has_bits_[2] |= 0x00080000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_advanced_battery_charge_mode)
}
inline ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* ChromeDeviceSettingsProto::release_device_advanced_battery_charge_mode() {
  _impl_._has_bits_[2] &= ~0x00080000u;
  ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* temp = _impl_.device_advanced_battery_charge_mode_;
  _impl_.device_advanced_battery_charge_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_advanced_battery_charge_mode() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_advanced_battery_charge_mode)
  _impl_._has_bits_[2] &= ~0x00080000u;
  ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* temp = _impl_.device_advanced_battery_charge_mode_;
  _impl_.device_advanced_battery_charge_mode_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* ChromeDeviceSettingsProto::_internal_mutable_device_advanced_battery_charge_mode() {
  _impl_._has_bits_[2] |= 0x00080000u;
  if (_impl_.device_advanced_battery_charge_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAdvancedBatteryChargeModeProto>(GetArenaForAllocation());
    _impl_.device_advanced_battery_charge_mode_ = p;
  }
  return _impl_.device_advanced_battery_charge_mode_;
}
inline ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* ChromeDeviceSettingsProto::mutable_device_advanced_battery_charge_mode() {
  ::enterprise_management::DeviceAdvancedBatteryChargeModeProto* _msg = _internal_mutable_device_advanced_battery_charge_mode();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_advanced_battery_charge_mode)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_advanced_battery_charge_mode(::enterprise_management::DeviceAdvancedBatteryChargeModeProto* device_advanced_battery_charge_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_advanced_battery_charge_mode_;
  }
  if (device_advanced_battery_charge_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_advanced_battery_charge_mode);
    if (message_arena != submessage_arena) {
      device_advanced_battery_charge_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_advanced_battery_charge_mode, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00080000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00080000u;
  }
  _impl_.device_advanced_battery_charge_mode_ = device_advanced_battery_charge_mode;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_advanced_battery_charge_mode)
}

// optional .enterprise_management.DeviceBatteryChargeModeProto device_battery_charge_mode = 87;
inline bool ChromeDeviceSettingsProto::_internal_has_device_battery_charge_mode() const {
  bool value = (_impl_._has_bits_[2] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_battery_charge_mode_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_battery_charge_mode() const {
  return _internal_has_device_battery_charge_mode();
}
inline void ChromeDeviceSettingsProto::clear_device_battery_charge_mode() {
  if (_impl_.device_battery_charge_mode_ != nullptr) _impl_.device_battery_charge_mode_->Clear();
  _impl_._has_bits_[2] &= ~0x00100000u;
}
inline const ::enterprise_management::DeviceBatteryChargeModeProto& ChromeDeviceSettingsProto::_internal_device_battery_charge_mode() const {
  const ::enterprise_management::DeviceBatteryChargeModeProto* p = _impl_.device_battery_charge_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceBatteryChargeModeProto&>(
      ::enterprise_management::_DeviceBatteryChargeModeProto_default_instance_);
}
inline const ::enterprise_management::DeviceBatteryChargeModeProto& ChromeDeviceSettingsProto::device_battery_charge_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_battery_charge_mode)
  return _internal_device_battery_charge_mode();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_battery_charge_mode(
    ::enterprise_management::DeviceBatteryChargeModeProto* device_battery_charge_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_battery_charge_mode_);
  }
  _impl_.device_battery_charge_mode_ = device_battery_charge_mode;
  if (device_battery_charge_mode) {
    _impl_._has_bits_[2] |= 0x00100000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_battery_charge_mode)
}
inline ::enterprise_management::DeviceBatteryChargeModeProto* ChromeDeviceSettingsProto::release_device_battery_charge_mode() {
  _impl_._has_bits_[2] &= ~0x00100000u;
  ::enterprise_management::DeviceBatteryChargeModeProto* temp = _impl_.device_battery_charge_mode_;
  _impl_.device_battery_charge_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceBatteryChargeModeProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_battery_charge_mode() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_battery_charge_mode)
  _impl_._has_bits_[2] &= ~0x00100000u;
  ::enterprise_management::DeviceBatteryChargeModeProto* temp = _impl_.device_battery_charge_mode_;
  _impl_.device_battery_charge_mode_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceBatteryChargeModeProto* ChromeDeviceSettingsProto::_internal_mutable_device_battery_charge_mode() {
  _impl_._has_bits_[2] |= 0x00100000u;
  if (_impl_.device_battery_charge_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceBatteryChargeModeProto>(GetArenaForAllocation());
    _impl_.device_battery_charge_mode_ = p;
  }
  return _impl_.device_battery_charge_mode_;
}
inline ::enterprise_management::DeviceBatteryChargeModeProto* ChromeDeviceSettingsProto::mutable_device_battery_charge_mode() {
  ::enterprise_management::DeviceBatteryChargeModeProto* _msg = _internal_mutable_device_battery_charge_mode();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_battery_charge_mode)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_battery_charge_mode(::enterprise_management::DeviceBatteryChargeModeProto* device_battery_charge_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_battery_charge_mode_;
  }
  if (device_battery_charge_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_battery_charge_mode);
    if (message_arena != submessage_arena) {
      device_battery_charge_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_battery_charge_mode, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00100000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00100000u;
  }
  _impl_.device_battery_charge_mode_ = device_battery_charge_mode;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_battery_charge_mode)
}

// optional .enterprise_management.DeviceUsbPowerShareProto device_usb_power_share = 88;
inline bool ChromeDeviceSettingsProto::_internal_has_device_usb_power_share() const {
  bool value = (_impl_._has_bits_[2] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_usb_power_share_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_usb_power_share() const {
  return _internal_has_device_usb_power_share();
}
inline void ChromeDeviceSettingsProto::clear_device_usb_power_share() {
  if (_impl_.device_usb_power_share_ != nullptr) _impl_.device_usb_power_share_->Clear();
  _impl_._has_bits_[2] &= ~0x00200000u;
}
inline const ::enterprise_management::DeviceUsbPowerShareProto& ChromeDeviceSettingsProto::_internal_device_usb_power_share() const {
  const ::enterprise_management::DeviceUsbPowerShareProto* p = _impl_.device_usb_power_share_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceUsbPowerShareProto&>(
      ::enterprise_management::_DeviceUsbPowerShareProto_default_instance_);
}
inline const ::enterprise_management::DeviceUsbPowerShareProto& ChromeDeviceSettingsProto::device_usb_power_share() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_usb_power_share)
  return _internal_device_usb_power_share();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_usb_power_share(
    ::enterprise_management::DeviceUsbPowerShareProto* device_usb_power_share) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_usb_power_share_);
  }
  _impl_.device_usb_power_share_ = device_usb_power_share;
  if (device_usb_power_share) {
    _impl_._has_bits_[2] |= 0x00200000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_usb_power_share)
}
inline ::enterprise_management::DeviceUsbPowerShareProto* ChromeDeviceSettingsProto::release_device_usb_power_share() {
  _impl_._has_bits_[2] &= ~0x00200000u;
  ::enterprise_management::DeviceUsbPowerShareProto* temp = _impl_.device_usb_power_share_;
  _impl_.device_usb_power_share_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceUsbPowerShareProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_usb_power_share() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_usb_power_share)
  _impl_._has_bits_[2] &= ~0x00200000u;
  ::enterprise_management::DeviceUsbPowerShareProto* temp = _impl_.device_usb_power_share_;
  _impl_.device_usb_power_share_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceUsbPowerShareProto* ChromeDeviceSettingsProto::_internal_mutable_device_usb_power_share() {
  _impl_._has_bits_[2] |= 0x00200000u;
  if (_impl_.device_usb_power_share_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceUsbPowerShareProto>(GetArenaForAllocation());
    _impl_.device_usb_power_share_ = p;
  }
  return _impl_.device_usb_power_share_;
}
inline ::enterprise_management::DeviceUsbPowerShareProto* ChromeDeviceSettingsProto::mutable_device_usb_power_share() {
  ::enterprise_management::DeviceUsbPowerShareProto* _msg = _internal_mutable_device_usb_power_share();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_usb_power_share)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_usb_power_share(::enterprise_management::DeviceUsbPowerShareProto* device_usb_power_share) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_usb_power_share_;
  }
  if (device_usb_power_share) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_usb_power_share);
    if (message_arena != submessage_arena) {
      device_usb_power_share = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_usb_power_share, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00200000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00200000u;
  }
  _impl_.device_usb_power_share_ = device_usb_power_share;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_usb_power_share)
}

// optional .enterprise_management.DeviceScheduledUpdateCheckProto device_scheduled_update_check = 89;
inline bool ChromeDeviceSettingsProto::_internal_has_device_scheduled_update_check() const {
  bool value = (_impl_._has_bits_[2] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_scheduled_update_check_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_scheduled_update_check() const {
  return _internal_has_device_scheduled_update_check();
}
inline void ChromeDeviceSettingsProto::clear_device_scheduled_update_check() {
  if (_impl_.device_scheduled_update_check_ != nullptr) _impl_.device_scheduled_update_check_->Clear();
  _impl_._has_bits_[2] &= ~0x00400000u;
}
inline const ::enterprise_management::DeviceScheduledUpdateCheckProto& ChromeDeviceSettingsProto::_internal_device_scheduled_update_check() const {
  const ::enterprise_management::DeviceScheduledUpdateCheckProto* p = _impl_.device_scheduled_update_check_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceScheduledUpdateCheckProto&>(
      ::enterprise_management::_DeviceScheduledUpdateCheckProto_default_instance_);
}
inline const ::enterprise_management::DeviceScheduledUpdateCheckProto& ChromeDeviceSettingsProto::device_scheduled_update_check() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_update_check)
  return _internal_device_scheduled_update_check();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_scheduled_update_check(
    ::enterprise_management::DeviceScheduledUpdateCheckProto* device_scheduled_update_check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_scheduled_update_check_);
  }
  _impl_.device_scheduled_update_check_ = device_scheduled_update_check;
  if (device_scheduled_update_check) {
    _impl_._has_bits_[2] |= 0x00400000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_update_check)
}
inline ::enterprise_management::DeviceScheduledUpdateCheckProto* ChromeDeviceSettingsProto::release_device_scheduled_update_check() {
  _impl_._has_bits_[2] &= ~0x00400000u;
  ::enterprise_management::DeviceScheduledUpdateCheckProto* temp = _impl_.device_scheduled_update_check_;
  _impl_.device_scheduled_update_check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceScheduledUpdateCheckProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_scheduled_update_check() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_update_check)
  _impl_._has_bits_[2] &= ~0x00400000u;
  ::enterprise_management::DeviceScheduledUpdateCheckProto* temp = _impl_.device_scheduled_update_check_;
  _impl_.device_scheduled_update_check_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceScheduledUpdateCheckProto* ChromeDeviceSettingsProto::_internal_mutable_device_scheduled_update_check() {
  _impl_._has_bits_[2] |= 0x00400000u;
  if (_impl_.device_scheduled_update_check_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceScheduledUpdateCheckProto>(GetArenaForAllocation());
    _impl_.device_scheduled_update_check_ = p;
  }
  return _impl_.device_scheduled_update_check_;
}
inline ::enterprise_management::DeviceScheduledUpdateCheckProto* ChromeDeviceSettingsProto::mutable_device_scheduled_update_check() {
  ::enterprise_management::DeviceScheduledUpdateCheckProto* _msg = _internal_mutable_device_scheduled_update_check();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_update_check)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_scheduled_update_check(::enterprise_management::DeviceScheduledUpdateCheckProto* device_scheduled_update_check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_scheduled_update_check_;
  }
  if (device_scheduled_update_check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_scheduled_update_check);
    if (message_arena != submessage_arena) {
      device_scheduled_update_check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_scheduled_update_check, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00400000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00400000u;
  }
  _impl_.device_scheduled_update_check_ = device_scheduled_update_check;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_update_check)
}

// optional .enterprise_management.DevicePowerwashAllowedProto device_powerwash_allowed = 91;
inline bool ChromeDeviceSettingsProto::_internal_has_device_powerwash_allowed() const {
  bool value = (_impl_._has_bits_[2] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_powerwash_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_powerwash_allowed() const {
  return _internal_has_device_powerwash_allowed();
}
inline void ChromeDeviceSettingsProto::clear_device_powerwash_allowed() {
  if (_impl_.device_powerwash_allowed_ != nullptr) _impl_.device_powerwash_allowed_->Clear();
  _impl_._has_bits_[2] &= ~0x00800000u;
}
inline const ::enterprise_management::DevicePowerwashAllowedProto& ChromeDeviceSettingsProto::_internal_device_powerwash_allowed() const {
  const ::enterprise_management::DevicePowerwashAllowedProto* p = _impl_.device_powerwash_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePowerwashAllowedProto&>(
      ::enterprise_management::_DevicePowerwashAllowedProto_default_instance_);
}
inline const ::enterprise_management::DevicePowerwashAllowedProto& ChromeDeviceSettingsProto::device_powerwash_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_powerwash_allowed)
  return _internal_device_powerwash_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_powerwash_allowed(
    ::enterprise_management::DevicePowerwashAllowedProto* device_powerwash_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_powerwash_allowed_);
  }
  _impl_.device_powerwash_allowed_ = device_powerwash_allowed;
  if (device_powerwash_allowed) {
    _impl_._has_bits_[2] |= 0x00800000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_powerwash_allowed)
}
inline ::enterprise_management::DevicePowerwashAllowedProto* ChromeDeviceSettingsProto::release_device_powerwash_allowed() {
  _impl_._has_bits_[2] &= ~0x00800000u;
  ::enterprise_management::DevicePowerwashAllowedProto* temp = _impl_.device_powerwash_allowed_;
  _impl_.device_powerwash_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePowerwashAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_powerwash_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_powerwash_allowed)
  _impl_._has_bits_[2] &= ~0x00800000u;
  ::enterprise_management::DevicePowerwashAllowedProto* temp = _impl_.device_powerwash_allowed_;
  _impl_.device_powerwash_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePowerwashAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_device_powerwash_allowed() {
  _impl_._has_bits_[2] |= 0x00800000u;
  if (_impl_.device_powerwash_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePowerwashAllowedProto>(GetArenaForAllocation());
    _impl_.device_powerwash_allowed_ = p;
  }
  return _impl_.device_powerwash_allowed_;
}
inline ::enterprise_management::DevicePowerwashAllowedProto* ChromeDeviceSettingsProto::mutable_device_powerwash_allowed() {
  ::enterprise_management::DevicePowerwashAllowedProto* _msg = _internal_mutable_device_powerwash_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_powerwash_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_powerwash_allowed(::enterprise_management::DevicePowerwashAllowedProto* device_powerwash_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_powerwash_allowed_;
  }
  if (device_powerwash_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_powerwash_allowed);
    if (message_arena != submessage_arena) {
      device_powerwash_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_powerwash_allowed, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x00800000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00800000u;
  }
  _impl_.device_powerwash_allowed_ = device_powerwash_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_powerwash_allowed)
}

// optional .enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto device_login_screen_webusb_allow_devices_for_urls = 92;
inline bool ChromeDeviceSettingsProto::_internal_has_device_login_screen_webusb_allow_devices_for_urls() const {
  bool value = (_impl_._has_bits_[2] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_login_screen_webusb_allow_devices_for_urls_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_login_screen_webusb_allow_devices_for_urls() const {
  return _internal_has_device_login_screen_webusb_allow_devices_for_urls();
}
inline void ChromeDeviceSettingsProto::clear_device_login_screen_webusb_allow_devices_for_urls() {
  if (_impl_.device_login_screen_webusb_allow_devices_for_urls_ != nullptr) _impl_.device_login_screen_webusb_allow_devices_for_urls_->Clear();
  _impl_._has_bits_[2] &= ~0x01000000u;
}
inline const ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& ChromeDeviceSettingsProto::_internal_device_login_screen_webusb_allow_devices_for_urls() const {
  const ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* p = _impl_.device_login_screen_webusb_allow_devices_for_urls_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto&>(
      ::enterprise_management::_DeviceLoginScreenWebUsbAllowDevicesForUrlsProto_default_instance_);
}
inline const ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& ChromeDeviceSettingsProto::device_login_screen_webusb_allow_devices_for_urls() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_webusb_allow_devices_for_urls)
  return _internal_device_login_screen_webusb_allow_devices_for_urls();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_login_screen_webusb_allow_devices_for_urls(
    ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* device_login_screen_webusb_allow_devices_for_urls) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_webusb_allow_devices_for_urls_);
  }
  _impl_.device_login_screen_webusb_allow_devices_for_urls_ = device_login_screen_webusb_allow_devices_for_urls;
  if (device_login_screen_webusb_allow_devices_for_urls) {
    _impl_._has_bits_[2] |= 0x01000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_webusb_allow_devices_for_urls)
}
inline ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* ChromeDeviceSettingsProto::release_device_login_screen_webusb_allow_devices_for_urls() {
  _impl_._has_bits_[2] &= ~0x01000000u;
  ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* temp = _impl_.device_login_screen_webusb_allow_devices_for_urls_;
  _impl_.device_login_screen_webusb_allow_devices_for_urls_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_login_screen_webusb_allow_devices_for_urls() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_webusb_allow_devices_for_urls)
  _impl_._has_bits_[2] &= ~0x01000000u;
  ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* temp = _impl_.device_login_screen_webusb_allow_devices_for_urls_;
  _impl_.device_login_screen_webusb_allow_devices_for_urls_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* ChromeDeviceSettingsProto::_internal_mutable_device_login_screen_webusb_allow_devices_for_urls() {
  _impl_._has_bits_[2] |= 0x01000000u;
  if (_impl_.device_login_screen_webusb_allow_devices_for_urls_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto>(GetArenaForAllocation());
    _impl_.device_login_screen_webusb_allow_devices_for_urls_ = p;
  }
  return _impl_.device_login_screen_webusb_allow_devices_for_urls_;
}
inline ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* ChromeDeviceSettingsProto::mutable_device_login_screen_webusb_allow_devices_for_urls() {
  ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* _msg = _internal_mutable_device_login_screen_webusb_allow_devices_for_urls();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_webusb_allow_devices_for_urls)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_login_screen_webusb_allow_devices_for_urls(::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* device_login_screen_webusb_allow_devices_for_urls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_login_screen_webusb_allow_devices_for_urls_;
  }
  if (device_login_screen_webusb_allow_devices_for_urls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_login_screen_webusb_allow_devices_for_urls);
    if (message_arena != submessage_arena) {
      device_login_screen_webusb_allow_devices_for_urls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_login_screen_webusb_allow_devices_for_urls, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x01000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x01000000u;
  }
  _impl_.device_login_screen_webusb_allow_devices_for_urls_ = device_login_screen_webusb_allow_devices_for_urls;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_webusb_allow_devices_for_urls)
}

// optional .enterprise_management.BooleanPolicyProto device_login_screen_system_info_enforced = 93;
inline bool ChromeDeviceSettingsProto::_internal_has_device_login_screen_system_info_enforced() const {
  bool value = (_impl_._has_bits_[2] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_login_screen_system_info_enforced_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_login_screen_system_info_enforced() const {
  return _internal_has_device_login_screen_system_info_enforced();
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::_internal_device_login_screen_system_info_enforced() const {
  const ::enterprise_management::BooleanPolicyProto* p = _impl_.device_login_screen_system_info_enforced_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BooleanPolicyProto&>(
      ::enterprise_management::_BooleanPolicyProto_default_instance_);
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::device_login_screen_system_info_enforced() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_system_info_enforced)
  return _internal_device_login_screen_system_info_enforced();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_login_screen_system_info_enforced(
    ::enterprise_management::BooleanPolicyProto* device_login_screen_system_info_enforced) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_system_info_enforced_);
  }
  _impl_.device_login_screen_system_info_enforced_ = device_login_screen_system_info_enforced;
  if (device_login_screen_system_info_enforced) {
    _impl_._has_bits_[2] |= 0x02000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_system_info_enforced)
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::release_device_login_screen_system_info_enforced() {
  _impl_._has_bits_[2] &= ~0x02000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.device_login_screen_system_info_enforced_;
  _impl_.device_login_screen_system_info_enforced_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_login_screen_system_info_enforced() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_system_info_enforced)
  _impl_._has_bits_[2] &= ~0x02000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.device_login_screen_system_info_enforced_;
  _impl_.device_login_screen_system_info_enforced_ = nullptr;
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_login_screen_system_info_enforced() {
  _impl_._has_bits_[2] |= 0x02000000u;
  if (_impl_.device_login_screen_system_info_enforced_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BooleanPolicyProto>(GetArenaForAllocation());
    _impl_.device_login_screen_system_info_enforced_ = p;
  }
  return _impl_.device_login_screen_system_info_enforced_;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::mutable_device_login_screen_system_info_enforced() {
  ::enterprise_management::BooleanPolicyProto* _msg = _internal_mutable_device_login_screen_system_info_enforced();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_system_info_enforced)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_login_screen_system_info_enforced(::enterprise_management::BooleanPolicyProto* device_login_screen_system_info_enforced) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_system_info_enforced_);
  }
  if (device_login_screen_system_info_enforced) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_login_screen_system_info_enforced));
    if (message_arena != submessage_arena) {
      device_login_screen_system_info_enforced = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_login_screen_system_info_enforced, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x02000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x02000000u;
  }
  _impl_.device_login_screen_system_info_enforced_ = device_login_screen_system_info_enforced;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_system_info_enforced)
}

// optional .enterprise_management.StringListPolicyProto device_web_based_attestation_allowed_urls = 94;
inline bool ChromeDeviceSettingsProto::_internal_has_device_web_based_attestation_allowed_urls() const {
  bool value = (_impl_._has_bits_[2] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_web_based_attestation_allowed_urls_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_web_based_attestation_allowed_urls() const {
  return _internal_has_device_web_based_attestation_allowed_urls();
}
inline const ::enterprise_management::StringListPolicyProto& ChromeDeviceSettingsProto::_internal_device_web_based_attestation_allowed_urls() const {
  const ::enterprise_management::StringListPolicyProto* p = _impl_.device_web_based_attestation_allowed_urls_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::StringListPolicyProto&>(
      ::enterprise_management::_StringListPolicyProto_default_instance_);
}
inline const ::enterprise_management::StringListPolicyProto& ChromeDeviceSettingsProto::device_web_based_attestation_allowed_urls() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_web_based_attestation_allowed_urls)
  return _internal_device_web_based_attestation_allowed_urls();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_web_based_attestation_allowed_urls(
    ::enterprise_management::StringListPolicyProto* device_web_based_attestation_allowed_urls) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_web_based_attestation_allowed_urls_);
  }
  _impl_.device_web_based_attestation_allowed_urls_ = device_web_based_attestation_allowed_urls;
  if (device_web_based_attestation_allowed_urls) {
    _impl_._has_bits_[2] |= 0x04000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_web_based_attestation_allowed_urls)
}
inline ::enterprise_management::StringListPolicyProto* ChromeDeviceSettingsProto::release_device_web_based_attestation_allowed_urls() {
  _impl_._has_bits_[2] &= ~0x04000000u;
  ::enterprise_management::StringListPolicyProto* temp = _impl_.device_web_based_attestation_allowed_urls_;
  _impl_.device_web_based_attestation_allowed_urls_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::StringListPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_web_based_attestation_allowed_urls() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_web_based_attestation_allowed_urls)
  _impl_._has_bits_[2] &= ~0x04000000u;
  ::enterprise_management::StringListPolicyProto* temp = _impl_.device_web_based_attestation_allowed_urls_;
  _impl_.device_web_based_attestation_allowed_urls_ = nullptr;
  return temp;
}
inline ::enterprise_management::StringListPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_web_based_attestation_allowed_urls() {
  _impl_._has_bits_[2] |= 0x04000000u;
  if (_impl_.device_web_based_attestation_allowed_urls_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::StringListPolicyProto>(GetArenaForAllocation());
    _impl_.device_web_based_attestation_allowed_urls_ = p;
  }
  return _impl_.device_web_based_attestation_allowed_urls_;
}
inline ::enterprise_management::StringListPolicyProto* ChromeDeviceSettingsProto::mutable_device_web_based_attestation_allowed_urls() {
  ::enterprise_management::StringListPolicyProto* _msg = _internal_mutable_device_web_based_attestation_allowed_urls();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_web_based_attestation_allowed_urls)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_web_based_attestation_allowed_urls(::enterprise_management::StringListPolicyProto* device_web_based_attestation_allowed_urls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_web_based_attestation_allowed_urls_);
  }
  if (device_web_based_attestation_allowed_urls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_web_based_attestation_allowed_urls));
    if (message_arena != submessage_arena) {
      device_web_based_attestation_allowed_urls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_web_based_attestation_allowed_urls, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x04000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x04000000u;
  }
  _impl_.device_web_based_attestation_allowed_urls_ = device_web_based_attestation_allowed_urls;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_web_based_attestation_allowed_urls)
}

// optional .enterprise_management.BooleanPolicyProto device_show_numeric_keyboard_for_password = 95;
inline bool ChromeDeviceSettingsProto::_internal_has_device_show_numeric_keyboard_for_password() const {
  bool value = (_impl_._has_bits_[2] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_show_numeric_keyboard_for_password_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_show_numeric_keyboard_for_password() const {
  return _internal_has_device_show_numeric_keyboard_for_password();
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::_internal_device_show_numeric_keyboard_for_password() const {
  const ::enterprise_management::BooleanPolicyProto* p = _impl_.device_show_numeric_keyboard_for_password_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BooleanPolicyProto&>(
      ::enterprise_management::_BooleanPolicyProto_default_instance_);
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::device_show_numeric_keyboard_for_password() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_show_numeric_keyboard_for_password)
  return _internal_device_show_numeric_keyboard_for_password();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_show_numeric_keyboard_for_password(
    ::enterprise_management::BooleanPolicyProto* device_show_numeric_keyboard_for_password) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_show_numeric_keyboard_for_password_);
  }
  _impl_.device_show_numeric_keyboard_for_password_ = device_show_numeric_keyboard_for_password;
  if (device_show_numeric_keyboard_for_password) {
    _impl_._has_bits_[2] |= 0x08000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_show_numeric_keyboard_for_password)
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::release_device_show_numeric_keyboard_for_password() {
  _impl_._has_bits_[2] &= ~0x08000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.device_show_numeric_keyboard_for_password_;
  _impl_.device_show_numeric_keyboard_for_password_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_show_numeric_keyboard_for_password() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_show_numeric_keyboard_for_password)
  _impl_._has_bits_[2] &= ~0x08000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.device_show_numeric_keyboard_for_password_;
  _impl_.device_show_numeric_keyboard_for_password_ = nullptr;
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_show_numeric_keyboard_for_password() {
  _impl_._has_bits_[2] |= 0x08000000u;
  if (_impl_.device_show_numeric_keyboard_for_password_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BooleanPolicyProto>(GetArenaForAllocation());
    _impl_.device_show_numeric_keyboard_for_password_ = p;
  }
  return _impl_.device_show_numeric_keyboard_for_password_;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::mutable_device_show_numeric_keyboard_for_password() {
  ::enterprise_management::BooleanPolicyProto* _msg = _internal_mutable_device_show_numeric_keyboard_for_password();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_show_numeric_keyboard_for_password)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_show_numeric_keyboard_for_password(::enterprise_management::BooleanPolicyProto* device_show_numeric_keyboard_for_password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_show_numeric_keyboard_for_password_);
  }
  if (device_show_numeric_keyboard_for_password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_show_numeric_keyboard_for_password));
    if (message_arena != submessage_arena) {
      device_show_numeric_keyboard_for_password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_show_numeric_keyboard_for_password, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x08000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x08000000u;
  }
  _impl_.device_show_numeric_keyboard_for_password_ = device_show_numeric_keyboard_for_password;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_show_numeric_keyboard_for_password)
}

// optional .enterprise_management.BooleanPolicyProto login_screen_primary_mouse_button_switch = 96;
inline bool ChromeDeviceSettingsProto::_internal_has_login_screen_primary_mouse_button_switch() const {
  bool value = (_impl_._has_bits_[2] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_primary_mouse_button_switch_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_screen_primary_mouse_button_switch() const {
  return _internal_has_login_screen_primary_mouse_button_switch();
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::_internal_login_screen_primary_mouse_button_switch() const {
  const ::enterprise_management::BooleanPolicyProto* p = _impl_.login_screen_primary_mouse_button_switch_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BooleanPolicyProto&>(
      ::enterprise_management::_BooleanPolicyProto_default_instance_);
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::login_screen_primary_mouse_button_switch() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_screen_primary_mouse_button_switch)
  return _internal_login_screen_primary_mouse_button_switch();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_screen_primary_mouse_button_switch(
    ::enterprise_management::BooleanPolicyProto* login_screen_primary_mouse_button_switch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_primary_mouse_button_switch_);
  }
  _impl_.login_screen_primary_mouse_button_switch_ = login_screen_primary_mouse_button_switch;
  if (login_screen_primary_mouse_button_switch) {
    _impl_._has_bits_[2] |= 0x10000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_primary_mouse_button_switch)
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::release_login_screen_primary_mouse_button_switch() {
  _impl_._has_bits_[2] &= ~0x10000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.login_screen_primary_mouse_button_switch_;
  _impl_.login_screen_primary_mouse_button_switch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_screen_primary_mouse_button_switch() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_screen_primary_mouse_button_switch)
  _impl_._has_bits_[2] &= ~0x10000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.login_screen_primary_mouse_button_switch_;
  _impl_.login_screen_primary_mouse_button_switch_ = nullptr;
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_login_screen_primary_mouse_button_switch() {
  _impl_._has_bits_[2] |= 0x10000000u;
  if (_impl_.login_screen_primary_mouse_button_switch_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BooleanPolicyProto>(GetArenaForAllocation());
    _impl_.login_screen_primary_mouse_button_switch_ = p;
  }
  return _impl_.login_screen_primary_mouse_button_switch_;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::mutable_login_screen_primary_mouse_button_switch() {
  ::enterprise_management::BooleanPolicyProto* _msg = _internal_mutable_login_screen_primary_mouse_button_switch();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_screen_primary_mouse_button_switch)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_screen_primary_mouse_button_switch(::enterprise_management::BooleanPolicyProto* login_screen_primary_mouse_button_switch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_primary_mouse_button_switch_);
  }
  if (login_screen_primary_mouse_button_switch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_primary_mouse_button_switch));
    if (message_arena != submessage_arena) {
      login_screen_primary_mouse_button_switch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_primary_mouse_button_switch, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x10000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x10000000u;
  }
  _impl_.login_screen_primary_mouse_button_switch_ = login_screen_primary_mouse_button_switch;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_primary_mouse_button_switch)
}

// optional .enterprise_management.StringPolicyProto device_minimum_version = 97;
inline bool ChromeDeviceSettingsProto::_internal_has_device_minimum_version() const {
  bool value = (_impl_._has_bits_[2] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_minimum_version_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_minimum_version() const {
  return _internal_has_device_minimum_version();
}
inline const ::enterprise_management::StringPolicyProto& ChromeDeviceSettingsProto::_internal_device_minimum_version() const {
  const ::enterprise_management::StringPolicyProto* p = _impl_.device_minimum_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::StringPolicyProto&>(
      ::enterprise_management::_StringPolicyProto_default_instance_);
}
inline const ::enterprise_management::StringPolicyProto& ChromeDeviceSettingsProto::device_minimum_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version)
  return _internal_device_minimum_version();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_minimum_version(
    ::enterprise_management::StringPolicyProto* device_minimum_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_minimum_version_);
  }
  _impl_.device_minimum_version_ = device_minimum_version;
  if (device_minimum_version) {
    _impl_._has_bits_[2] |= 0x20000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version)
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::release_device_minimum_version() {
  _impl_._has_bits_[2] &= ~0x20000000u;
  ::enterprise_management::StringPolicyProto* temp = _impl_.device_minimum_version_;
  _impl_.device_minimum_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_minimum_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version)
  _impl_._has_bits_[2] &= ~0x20000000u;
  ::enterprise_management::StringPolicyProto* temp = _impl_.device_minimum_version_;
  _impl_.device_minimum_version_ = nullptr;
  return temp;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_minimum_version() {
  _impl_._has_bits_[2] |= 0x20000000u;
  if (_impl_.device_minimum_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::StringPolicyProto>(GetArenaForAllocation());
    _impl_.device_minimum_version_ = p;
  }
  return _impl_.device_minimum_version_;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::mutable_device_minimum_version() {
  ::enterprise_management::StringPolicyProto* _msg = _internal_mutable_device_minimum_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_minimum_version(::enterprise_management::StringPolicyProto* device_minimum_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_minimum_version_);
  }
  if (device_minimum_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_minimum_version));
    if (message_arena != submessage_arena) {
      device_minimum_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_minimum_version, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x20000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x20000000u;
  }
  _impl_.device_minimum_version_ = device_minimum_version;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version)
}

// optional .enterprise_management.SystemProxySettingsProto system_proxy_settings = 98;
inline bool ChromeDeviceSettingsProto::_internal_has_system_proxy_settings() const {
  bool value = (_impl_._has_bits_[2] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_proxy_settings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_system_proxy_settings() const {
  return _internal_has_system_proxy_settings();
}
inline void ChromeDeviceSettingsProto::clear_system_proxy_settings() {
  if (_impl_.system_proxy_settings_ != nullptr) _impl_.system_proxy_settings_->Clear();
  _impl_._has_bits_[2] &= ~0x40000000u;
}
inline const ::enterprise_management::SystemProxySettingsProto& ChromeDeviceSettingsProto::_internal_system_proxy_settings() const {
  const ::enterprise_management::SystemProxySettingsProto* p = _impl_.system_proxy_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SystemProxySettingsProto&>(
      ::enterprise_management::_SystemProxySettingsProto_default_instance_);
}
inline const ::enterprise_management::SystemProxySettingsProto& ChromeDeviceSettingsProto::system_proxy_settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.system_proxy_settings)
  return _internal_system_proxy_settings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_system_proxy_settings(
    ::enterprise_management::SystemProxySettingsProto* system_proxy_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_proxy_settings_);
  }
  _impl_.system_proxy_settings_ = system_proxy_settings;
  if (system_proxy_settings) {
    _impl_._has_bits_[2] |= 0x40000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.system_proxy_settings)
}
inline ::enterprise_management::SystemProxySettingsProto* ChromeDeviceSettingsProto::release_system_proxy_settings() {
  _impl_._has_bits_[2] &= ~0x40000000u;
  ::enterprise_management::SystemProxySettingsProto* temp = _impl_.system_proxy_settings_;
  _impl_.system_proxy_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SystemProxySettingsProto* ChromeDeviceSettingsProto::unsafe_arena_release_system_proxy_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.system_proxy_settings)
  _impl_._has_bits_[2] &= ~0x40000000u;
  ::enterprise_management::SystemProxySettingsProto* temp = _impl_.system_proxy_settings_;
  _impl_.system_proxy_settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::SystemProxySettingsProto* ChromeDeviceSettingsProto::_internal_mutable_system_proxy_settings() {
  _impl_._has_bits_[2] |= 0x40000000u;
  if (_impl_.system_proxy_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SystemProxySettingsProto>(GetArenaForAllocation());
    _impl_.system_proxy_settings_ = p;
  }
  return _impl_.system_proxy_settings_;
}
inline ::enterprise_management::SystemProxySettingsProto* ChromeDeviceSettingsProto::mutable_system_proxy_settings() {
  ::enterprise_management::SystemProxySettingsProto* _msg = _internal_mutable_system_proxy_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.system_proxy_settings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_system_proxy_settings(::enterprise_management::SystemProxySettingsProto* system_proxy_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_proxy_settings_;
  }
  if (system_proxy_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_proxy_settings);
    if (message_arena != submessage_arena) {
      system_proxy_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_proxy_settings, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x40000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x40000000u;
  }
  _impl_.system_proxy_settings_ = system_proxy_settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.system_proxy_settings)
}

// optional .enterprise_management.IntegerPolicyProto device_chrome_variations_type = 99;
inline bool ChromeDeviceSettingsProto::_internal_has_device_chrome_variations_type() const {
  bool value = (_impl_._has_bits_[2] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_chrome_variations_type_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_chrome_variations_type() const {
  return _internal_has_device_chrome_variations_type();
}
inline const ::enterprise_management::IntegerPolicyProto& ChromeDeviceSettingsProto::_internal_device_chrome_variations_type() const {
  const ::enterprise_management::IntegerPolicyProto* p = _impl_.device_chrome_variations_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::IntegerPolicyProto&>(
      ::enterprise_management::_IntegerPolicyProto_default_instance_);
}
inline const ::enterprise_management::IntegerPolicyProto& ChromeDeviceSettingsProto::device_chrome_variations_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_chrome_variations_type)
  return _internal_device_chrome_variations_type();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_chrome_variations_type(
    ::enterprise_management::IntegerPolicyProto* device_chrome_variations_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_chrome_variations_type_);
  }
  _impl_.device_chrome_variations_type_ = device_chrome_variations_type;
  if (device_chrome_variations_type) {
    _impl_._has_bits_[2] |= 0x80000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_chrome_variations_type)
}
inline ::enterprise_management::IntegerPolicyProto* ChromeDeviceSettingsProto::release_device_chrome_variations_type() {
  _impl_._has_bits_[2] &= ~0x80000000u;
  ::enterprise_management::IntegerPolicyProto* temp = _impl_.device_chrome_variations_type_;
  _impl_.device_chrome_variations_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::IntegerPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_chrome_variations_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_chrome_variations_type)
  _impl_._has_bits_[2] &= ~0x80000000u;
  ::enterprise_management::IntegerPolicyProto* temp = _impl_.device_chrome_variations_type_;
  _impl_.device_chrome_variations_type_ = nullptr;
  return temp;
}
inline ::enterprise_management::IntegerPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_chrome_variations_type() {
  _impl_._has_bits_[2] |= 0x80000000u;
  if (_impl_.device_chrome_variations_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::IntegerPolicyProto>(GetArenaForAllocation());
    _impl_.device_chrome_variations_type_ = p;
  }
  return _impl_.device_chrome_variations_type_;
}
inline ::enterprise_management::IntegerPolicyProto* ChromeDeviceSettingsProto::mutable_device_chrome_variations_type() {
  ::enterprise_management::IntegerPolicyProto* _msg = _internal_mutable_device_chrome_variations_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_chrome_variations_type)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_chrome_variations_type(::enterprise_management::IntegerPolicyProto* device_chrome_variations_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_chrome_variations_type_);
  }
  if (device_chrome_variations_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_chrome_variations_type));
    if (message_arena != submessage_arena) {
      device_chrome_variations_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_chrome_variations_type, submessage_arena);
    }
    _impl_._has_bits_[2] |= 0x80000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x80000000u;
  }
  _impl_.device_chrome_variations_type_ = device_chrome_variations_type;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_chrome_variations_type)
}

// optional .enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto device_login_screen_privacy_screen_enabled = 100;
inline bool ChromeDeviceSettingsProto::_internal_has_device_login_screen_privacy_screen_enabled() const {
  bool value = (_impl_._has_bits_[3] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_login_screen_privacy_screen_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_login_screen_privacy_screen_enabled() const {
  return _internal_has_device_login_screen_privacy_screen_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_login_screen_privacy_screen_enabled() {
  if (_impl_.device_login_screen_privacy_screen_enabled_ != nullptr) _impl_.device_login_screen_privacy_screen_enabled_->Clear();
  _impl_._has_bits_[3] &= ~0x00000001u;
}
inline const ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto& ChromeDeviceSettingsProto::_internal_device_login_screen_privacy_screen_enabled() const {
  const ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* p = _impl_.device_login_screen_privacy_screen_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto&>(
      ::enterprise_management::_DeviceLoginScreenPrivacyScreenEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto& ChromeDeviceSettingsProto::device_login_screen_privacy_screen_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_privacy_screen_enabled)
  return _internal_device_login_screen_privacy_screen_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_login_screen_privacy_screen_enabled(
    ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* device_login_screen_privacy_screen_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_privacy_screen_enabled_);
  }
  _impl_.device_login_screen_privacy_screen_enabled_ = device_login_screen_privacy_screen_enabled;
  if (device_login_screen_privacy_screen_enabled) {
    _impl_._has_bits_[3] |= 0x00000001u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_privacy_screen_enabled)
}
inline ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* ChromeDeviceSettingsProto::release_device_login_screen_privacy_screen_enabled() {
  _impl_._has_bits_[3] &= ~0x00000001u;
  ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* temp = _impl_.device_login_screen_privacy_screen_enabled_;
  _impl_.device_login_screen_privacy_screen_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_login_screen_privacy_screen_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_privacy_screen_enabled)
  _impl_._has_bits_[3] &= ~0x00000001u;
  ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* temp = _impl_.device_login_screen_privacy_screen_enabled_;
  _impl_.device_login_screen_privacy_screen_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_login_screen_privacy_screen_enabled() {
  _impl_._has_bits_[3] |= 0x00000001u;
  if (_impl_.device_login_screen_privacy_screen_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto>(GetArenaForAllocation());
    _impl_.device_login_screen_privacy_screen_enabled_ = p;
  }
  return _impl_.device_login_screen_privacy_screen_enabled_;
}
inline ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* ChromeDeviceSettingsProto::mutable_device_login_screen_privacy_screen_enabled() {
  ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* _msg = _internal_mutable_device_login_screen_privacy_screen_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_privacy_screen_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_login_screen_privacy_screen_enabled(::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto* device_login_screen_privacy_screen_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_login_screen_privacy_screen_enabled_;
  }
  if (device_login_screen_privacy_screen_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_login_screen_privacy_screen_enabled);
    if (message_arena != submessage_arena) {
      device_login_screen_privacy_screen_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_login_screen_privacy_screen_enabled, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000001u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000001u;
  }
  _impl_.device_login_screen_privacy_screen_enabled_ = device_login_screen_privacy_screen_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_privacy_screen_enabled)
}

// optional .enterprise_management.RequiredClientCertificateForDeviceProto required_client_certificate_for_device = 101;
inline bool ChromeDeviceSettingsProto::_internal_has_required_client_certificate_for_device() const {
  bool value = (_impl_._has_bits_[3] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.required_client_certificate_for_device_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_required_client_certificate_for_device() const {
  return _internal_has_required_client_certificate_for_device();
}
inline void ChromeDeviceSettingsProto::clear_required_client_certificate_for_device() {
  if (_impl_.required_client_certificate_for_device_ != nullptr) _impl_.required_client_certificate_for_device_->Clear();
  _impl_._has_bits_[3] &= ~0x00000002u;
}
inline const ::enterprise_management::RequiredClientCertificateForDeviceProto& ChromeDeviceSettingsProto::_internal_required_client_certificate_for_device() const {
  const ::enterprise_management::RequiredClientCertificateForDeviceProto* p = _impl_.required_client_certificate_for_device_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::RequiredClientCertificateForDeviceProto&>(
      ::enterprise_management::_RequiredClientCertificateForDeviceProto_default_instance_);
}
inline const ::enterprise_management::RequiredClientCertificateForDeviceProto& ChromeDeviceSettingsProto::required_client_certificate_for_device() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.required_client_certificate_for_device)
  return _internal_required_client_certificate_for_device();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_required_client_certificate_for_device(
    ::enterprise_management::RequiredClientCertificateForDeviceProto* required_client_certificate_for_device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.required_client_certificate_for_device_);
  }
  _impl_.required_client_certificate_for_device_ = required_client_certificate_for_device;
  if (required_client_certificate_for_device) {
    _impl_._has_bits_[3] |= 0x00000002u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.required_client_certificate_for_device)
}
inline ::enterprise_management::RequiredClientCertificateForDeviceProto* ChromeDeviceSettingsProto::release_required_client_certificate_for_device() {
  _impl_._has_bits_[3] &= ~0x00000002u;
  ::enterprise_management::RequiredClientCertificateForDeviceProto* temp = _impl_.required_client_certificate_for_device_;
  _impl_.required_client_certificate_for_device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::RequiredClientCertificateForDeviceProto* ChromeDeviceSettingsProto::unsafe_arena_release_required_client_certificate_for_device() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.required_client_certificate_for_device)
  _impl_._has_bits_[3] &= ~0x00000002u;
  ::enterprise_management::RequiredClientCertificateForDeviceProto* temp = _impl_.required_client_certificate_for_device_;
  _impl_.required_client_certificate_for_device_ = nullptr;
  return temp;
}
inline ::enterprise_management::RequiredClientCertificateForDeviceProto* ChromeDeviceSettingsProto::_internal_mutable_required_client_certificate_for_device() {
  _impl_._has_bits_[3] |= 0x00000002u;
  if (_impl_.required_client_certificate_for_device_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::RequiredClientCertificateForDeviceProto>(GetArenaForAllocation());
    _impl_.required_client_certificate_for_device_ = p;
  }
  return _impl_.required_client_certificate_for_device_;
}
inline ::enterprise_management::RequiredClientCertificateForDeviceProto* ChromeDeviceSettingsProto::mutable_required_client_certificate_for_device() {
  ::enterprise_management::RequiredClientCertificateForDeviceProto* _msg = _internal_mutable_required_client_certificate_for_device();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.required_client_certificate_for_device)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_required_client_certificate_for_device(::enterprise_management::RequiredClientCertificateForDeviceProto* required_client_certificate_for_device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.required_client_certificate_for_device_;
  }
  if (required_client_certificate_for_device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(required_client_certificate_for_device);
    if (message_arena != submessage_arena) {
      required_client_certificate_for_device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, required_client_certificate_for_device, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000002u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000002u;
  }
  _impl_.required_client_certificate_for_device_ = required_client_certificate_for_device;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.required_client_certificate_for_device)
}

// optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto device_crostini_arc_adb_sideloading_allowed = 102;
inline bool ChromeDeviceSettingsProto::_internal_has_device_crostini_arc_adb_sideloading_allowed() const {
  bool value = (_impl_._has_bits_[3] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_crostini_arc_adb_sideloading_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_crostini_arc_adb_sideloading_allowed() const {
  return _internal_has_device_crostini_arc_adb_sideloading_allowed();
}
inline void ChromeDeviceSettingsProto::clear_device_crostini_arc_adb_sideloading_allowed() {
  if (_impl_.device_crostini_arc_adb_sideloading_allowed_ != nullptr) _impl_.device_crostini_arc_adb_sideloading_allowed_->Clear();
  _impl_._has_bits_[3] &= ~0x00000004u;
}
inline const ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto& ChromeDeviceSettingsProto::_internal_device_crostini_arc_adb_sideloading_allowed() const {
  const ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* p = _impl_.device_crostini_arc_adb_sideloading_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto&>(
      ::enterprise_management::_DeviceCrostiniArcAdbSideloadingAllowedProto_default_instance_);
}
inline const ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto& ChromeDeviceSettingsProto::device_crostini_arc_adb_sideloading_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_crostini_arc_adb_sideloading_allowed)
  return _internal_device_crostini_arc_adb_sideloading_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_crostini_arc_adb_sideloading_allowed(
    ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* device_crostini_arc_adb_sideloading_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_crostini_arc_adb_sideloading_allowed_);
  }
  _impl_.device_crostini_arc_adb_sideloading_allowed_ = device_crostini_arc_adb_sideloading_allowed;
  if (device_crostini_arc_adb_sideloading_allowed) {
    _impl_._has_bits_[3] |= 0x00000004u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_crostini_arc_adb_sideloading_allowed)
}
inline ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* ChromeDeviceSettingsProto::release_device_crostini_arc_adb_sideloading_allowed() {
  _impl_._has_bits_[3] &= ~0x00000004u;
  ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* temp = _impl_.device_crostini_arc_adb_sideloading_allowed_;
  _impl_.device_crostini_arc_adb_sideloading_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_crostini_arc_adb_sideloading_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_crostini_arc_adb_sideloading_allowed)
  _impl_._has_bits_[3] &= ~0x00000004u;
  ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* temp = _impl_.device_crostini_arc_adb_sideloading_allowed_;
  _impl_.device_crostini_arc_adb_sideloading_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_device_crostini_arc_adb_sideloading_allowed() {
  _impl_._has_bits_[3] |= 0x00000004u;
  if (_impl_.device_crostini_arc_adb_sideloading_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto>(GetArenaForAllocation());
    _impl_.device_crostini_arc_adb_sideloading_allowed_ = p;
  }
  return _impl_.device_crostini_arc_adb_sideloading_allowed_;
}
inline ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* ChromeDeviceSettingsProto::mutable_device_crostini_arc_adb_sideloading_allowed() {
  ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* _msg = _internal_mutable_device_crostini_arc_adb_sideloading_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_crostini_arc_adb_sideloading_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_crostini_arc_adb_sideloading_allowed(::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto* device_crostini_arc_adb_sideloading_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_crostini_arc_adb_sideloading_allowed_;
  }
  if (device_crostini_arc_adb_sideloading_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_crostini_arc_adb_sideloading_allowed);
    if (message_arena != submessage_arena) {
      device_crostini_arc_adb_sideloading_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_crostini_arc_adb_sideloading_allowed, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000004u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000004u;
  }
  _impl_.device_crostini_arc_adb_sideloading_allowed_ = device_crostini_arc_adb_sideloading_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_crostini_arc_adb_sideloading_allowed)
}

// optional .enterprise_management.StringPolicyProto device_minimum_version_aue_message = 103;
inline bool ChromeDeviceSettingsProto::_internal_has_device_minimum_version_aue_message() const {
  bool value = (_impl_._has_bits_[3] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_minimum_version_aue_message_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_minimum_version_aue_message() const {
  return _internal_has_device_minimum_version_aue_message();
}
inline const ::enterprise_management::StringPolicyProto& ChromeDeviceSettingsProto::_internal_device_minimum_version_aue_message() const {
  const ::enterprise_management::StringPolicyProto* p = _impl_.device_minimum_version_aue_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::StringPolicyProto&>(
      ::enterprise_management::_StringPolicyProto_default_instance_);
}
inline const ::enterprise_management::StringPolicyProto& ChromeDeviceSettingsProto::device_minimum_version_aue_message() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version_aue_message)
  return _internal_device_minimum_version_aue_message();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_minimum_version_aue_message(
    ::enterprise_management::StringPolicyProto* device_minimum_version_aue_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_minimum_version_aue_message_);
  }
  _impl_.device_minimum_version_aue_message_ = device_minimum_version_aue_message;
  if (device_minimum_version_aue_message) {
    _impl_._has_bits_[3] |= 0x00000008u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version_aue_message)
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::release_device_minimum_version_aue_message() {
  _impl_._has_bits_[3] &= ~0x00000008u;
  ::enterprise_management::StringPolicyProto* temp = _impl_.device_minimum_version_aue_message_;
  _impl_.device_minimum_version_aue_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_minimum_version_aue_message() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version_aue_message)
  _impl_._has_bits_[3] &= ~0x00000008u;
  ::enterprise_management::StringPolicyProto* temp = _impl_.device_minimum_version_aue_message_;
  _impl_.device_minimum_version_aue_message_ = nullptr;
  return temp;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_minimum_version_aue_message() {
  _impl_._has_bits_[3] |= 0x00000008u;
  if (_impl_.device_minimum_version_aue_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::StringPolicyProto>(GetArenaForAllocation());
    _impl_.device_minimum_version_aue_message_ = p;
  }
  return _impl_.device_minimum_version_aue_message_;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::mutable_device_minimum_version_aue_message() {
  ::enterprise_management::StringPolicyProto* _msg = _internal_mutable_device_minimum_version_aue_message();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version_aue_message)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_minimum_version_aue_message(::enterprise_management::StringPolicyProto* device_minimum_version_aue_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_minimum_version_aue_message_);
  }
  if (device_minimum_version_aue_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_minimum_version_aue_message));
    if (message_arena != submessage_arena) {
      device_minimum_version_aue_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_minimum_version_aue_message, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000008u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000008u;
  }
  _impl_.device_minimum_version_aue_message_ = device_minimum_version_aue_message;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_minimum_version_aue_message)
}

// optional .enterprise_management.ManagedGuestSessionPrivacyWarningsProto managed_guest_session_privacy_warnings = 104;
inline bool ChromeDeviceSettingsProto::_internal_has_managed_guest_session_privacy_warnings() const {
  bool value = (_impl_._has_bits_[3] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.managed_guest_session_privacy_warnings_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_managed_guest_session_privacy_warnings() const {
  return _internal_has_managed_guest_session_privacy_warnings();
}
inline void ChromeDeviceSettingsProto::clear_managed_guest_session_privacy_warnings() {
  if (_impl_.managed_guest_session_privacy_warnings_ != nullptr) _impl_.managed_guest_session_privacy_warnings_->Clear();
  _impl_._has_bits_[3] &= ~0x00000010u;
}
inline const ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto& ChromeDeviceSettingsProto::_internal_managed_guest_session_privacy_warnings() const {
  const ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* p = _impl_.managed_guest_session_privacy_warnings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto&>(
      ::enterprise_management::_ManagedGuestSessionPrivacyWarningsProto_default_instance_);
}
inline const ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto& ChromeDeviceSettingsProto::managed_guest_session_privacy_warnings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.managed_guest_session_privacy_warnings)
  return _internal_managed_guest_session_privacy_warnings();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_managed_guest_session_privacy_warnings(
    ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* managed_guest_session_privacy_warnings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.managed_guest_session_privacy_warnings_);
  }
  _impl_.managed_guest_session_privacy_warnings_ = managed_guest_session_privacy_warnings;
  if (managed_guest_session_privacy_warnings) {
    _impl_._has_bits_[3] |= 0x00000010u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.managed_guest_session_privacy_warnings)
}
inline ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* ChromeDeviceSettingsProto::release_managed_guest_session_privacy_warnings() {
  _impl_._has_bits_[3] &= ~0x00000010u;
  ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* temp = _impl_.managed_guest_session_privacy_warnings_;
  _impl_.managed_guest_session_privacy_warnings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* ChromeDeviceSettingsProto::unsafe_arena_release_managed_guest_session_privacy_warnings() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.managed_guest_session_privacy_warnings)
  _impl_._has_bits_[3] &= ~0x00000010u;
  ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* temp = _impl_.managed_guest_session_privacy_warnings_;
  _impl_.managed_guest_session_privacy_warnings_ = nullptr;
  return temp;
}
inline ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* ChromeDeviceSettingsProto::_internal_mutable_managed_guest_session_privacy_warnings() {
  _impl_._has_bits_[3] |= 0x00000010u;
  if (_impl_.managed_guest_session_privacy_warnings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ManagedGuestSessionPrivacyWarningsProto>(GetArenaForAllocation());
    _impl_.managed_guest_session_privacy_warnings_ = p;
  }
  return _impl_.managed_guest_session_privacy_warnings_;
}
inline ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* ChromeDeviceSettingsProto::mutable_managed_guest_session_privacy_warnings() {
  ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* _msg = _internal_mutable_managed_guest_session_privacy_warnings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.managed_guest_session_privacy_warnings)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_managed_guest_session_privacy_warnings(::enterprise_management::ManagedGuestSessionPrivacyWarningsProto* managed_guest_session_privacy_warnings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.managed_guest_session_privacy_warnings_;
  }
  if (managed_guest_session_privacy_warnings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(managed_guest_session_privacy_warnings);
    if (message_arena != submessage_arena) {
      managed_guest_session_privacy_warnings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, managed_guest_session_privacy_warnings, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000010u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000010u;
  }
  _impl_.managed_guest_session_privacy_warnings_ = managed_guest_session_privacy_warnings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.managed_guest_session_privacy_warnings)
}

// optional .enterprise_management.DeviceExternalPrintServersProto external_print_servers = 105;
inline bool ChromeDeviceSettingsProto::_internal_has_external_print_servers() const {
  bool value = (_impl_._has_bits_[3] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_print_servers_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_external_print_servers() const {
  return _internal_has_external_print_servers();
}
inline void ChromeDeviceSettingsProto::clear_external_print_servers() {
  if (_impl_.external_print_servers_ != nullptr) _impl_.external_print_servers_->Clear();
  _impl_._has_bits_[3] &= ~0x00000020u;
}
inline const ::enterprise_management::DeviceExternalPrintServersProto& ChromeDeviceSettingsProto::_internal_external_print_servers() const {
  const ::enterprise_management::DeviceExternalPrintServersProto* p = _impl_.external_print_servers_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceExternalPrintServersProto&>(
      ::enterprise_management::_DeviceExternalPrintServersProto_default_instance_);
}
inline const ::enterprise_management::DeviceExternalPrintServersProto& ChromeDeviceSettingsProto::external_print_servers() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.external_print_servers)
  return _internal_external_print_servers();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_external_print_servers(
    ::enterprise_management::DeviceExternalPrintServersProto* external_print_servers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_print_servers_);
  }
  _impl_.external_print_servers_ = external_print_servers;
  if (external_print_servers) {
    _impl_._has_bits_[3] |= 0x00000020u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.external_print_servers)
}
inline ::enterprise_management::DeviceExternalPrintServersProto* ChromeDeviceSettingsProto::release_external_print_servers() {
  _impl_._has_bits_[3] &= ~0x00000020u;
  ::enterprise_management::DeviceExternalPrintServersProto* temp = _impl_.external_print_servers_;
  _impl_.external_print_servers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceExternalPrintServersProto* ChromeDeviceSettingsProto::unsafe_arena_release_external_print_servers() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.external_print_servers)
  _impl_._has_bits_[3] &= ~0x00000020u;
  ::enterprise_management::DeviceExternalPrintServersProto* temp = _impl_.external_print_servers_;
  _impl_.external_print_servers_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceExternalPrintServersProto* ChromeDeviceSettingsProto::_internal_mutable_external_print_servers() {
  _impl_._has_bits_[3] |= 0x00000020u;
  if (_impl_.external_print_servers_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceExternalPrintServersProto>(GetArenaForAllocation());
    _impl_.external_print_servers_ = p;
  }
  return _impl_.external_print_servers_;
}
inline ::enterprise_management::DeviceExternalPrintServersProto* ChromeDeviceSettingsProto::mutable_external_print_servers() {
  ::enterprise_management::DeviceExternalPrintServersProto* _msg = _internal_mutable_external_print_servers();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.external_print_servers)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_external_print_servers(::enterprise_management::DeviceExternalPrintServersProto* external_print_servers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_print_servers_;
  }
  if (external_print_servers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_print_servers);
    if (message_arena != submessage_arena) {
      external_print_servers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_print_servers, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000020u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000020u;
  }
  _impl_.external_print_servers_ = external_print_servers;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.external_print_servers)
}

// optional .enterprise_management.DeviceExternalPrintServersAllowlistProto external_print_servers_allowlist = 106;
inline bool ChromeDeviceSettingsProto::_internal_has_external_print_servers_allowlist() const {
  bool value = (_impl_._has_bits_[3] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_print_servers_allowlist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_external_print_servers_allowlist() const {
  return _internal_has_external_print_servers_allowlist();
}
inline void ChromeDeviceSettingsProto::clear_external_print_servers_allowlist() {
  if (_impl_.external_print_servers_allowlist_ != nullptr) _impl_.external_print_servers_allowlist_->Clear();
  _impl_._has_bits_[3] &= ~0x00000040u;
}
inline const ::enterprise_management::DeviceExternalPrintServersAllowlistProto& ChromeDeviceSettingsProto::_internal_external_print_servers_allowlist() const {
  const ::enterprise_management::DeviceExternalPrintServersAllowlistProto* p = _impl_.external_print_servers_allowlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceExternalPrintServersAllowlistProto&>(
      ::enterprise_management::_DeviceExternalPrintServersAllowlistProto_default_instance_);
}
inline const ::enterprise_management::DeviceExternalPrintServersAllowlistProto& ChromeDeviceSettingsProto::external_print_servers_allowlist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.external_print_servers_allowlist)
  return _internal_external_print_servers_allowlist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_external_print_servers_allowlist(
    ::enterprise_management::DeviceExternalPrintServersAllowlistProto* external_print_servers_allowlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_print_servers_allowlist_);
  }
  _impl_.external_print_servers_allowlist_ = external_print_servers_allowlist;
  if (external_print_servers_allowlist) {
    _impl_._has_bits_[3] |= 0x00000040u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.external_print_servers_allowlist)
}
inline ::enterprise_management::DeviceExternalPrintServersAllowlistProto* ChromeDeviceSettingsProto::release_external_print_servers_allowlist() {
  _impl_._has_bits_[3] &= ~0x00000040u;
  ::enterprise_management::DeviceExternalPrintServersAllowlistProto* temp = _impl_.external_print_servers_allowlist_;
  _impl_.external_print_servers_allowlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceExternalPrintServersAllowlistProto* ChromeDeviceSettingsProto::unsafe_arena_release_external_print_servers_allowlist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.external_print_servers_allowlist)
  _impl_._has_bits_[3] &= ~0x00000040u;
  ::enterprise_management::DeviceExternalPrintServersAllowlistProto* temp = _impl_.external_print_servers_allowlist_;
  _impl_.external_print_servers_allowlist_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceExternalPrintServersAllowlistProto* ChromeDeviceSettingsProto::_internal_mutable_external_print_servers_allowlist() {
  _impl_._has_bits_[3] |= 0x00000040u;
  if (_impl_.external_print_servers_allowlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceExternalPrintServersAllowlistProto>(GetArenaForAllocation());
    _impl_.external_print_servers_allowlist_ = p;
  }
  return _impl_.external_print_servers_allowlist_;
}
inline ::enterprise_management::DeviceExternalPrintServersAllowlistProto* ChromeDeviceSettingsProto::mutable_external_print_servers_allowlist() {
  ::enterprise_management::DeviceExternalPrintServersAllowlistProto* _msg = _internal_mutable_external_print_servers_allowlist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.external_print_servers_allowlist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_external_print_servers_allowlist(::enterprise_management::DeviceExternalPrintServersAllowlistProto* external_print_servers_allowlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_print_servers_allowlist_;
  }
  if (external_print_servers_allowlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_print_servers_allowlist);
    if (message_arena != submessage_arena) {
      external_print_servers_allowlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_print_servers_allowlist, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000040u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000040u;
  }
  _impl_.external_print_servers_allowlist_ = external_print_servers_allowlist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.external_print_servers_allowlist)
}

// optional .enterprise_management.DevicePrintersAccessModeProto device_printers_access_mode = 107;
inline bool ChromeDeviceSettingsProto::_internal_has_device_printers_access_mode() const {
  bool value = (_impl_._has_bits_[3] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_printers_access_mode_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_printers_access_mode() const {
  return _internal_has_device_printers_access_mode();
}
inline void ChromeDeviceSettingsProto::clear_device_printers_access_mode() {
  if (_impl_.device_printers_access_mode_ != nullptr) _impl_.device_printers_access_mode_->Clear();
  _impl_._has_bits_[3] &= ~0x00000080u;
}
inline const ::enterprise_management::DevicePrintersAccessModeProto& ChromeDeviceSettingsProto::_internal_device_printers_access_mode() const {
  const ::enterprise_management::DevicePrintersAccessModeProto* p = _impl_.device_printers_access_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePrintersAccessModeProto&>(
      ::enterprise_management::_DevicePrintersAccessModeProto_default_instance_);
}
inline const ::enterprise_management::DevicePrintersAccessModeProto& ChromeDeviceSettingsProto::device_printers_access_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_printers_access_mode)
  return _internal_device_printers_access_mode();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_printers_access_mode(
    ::enterprise_management::DevicePrintersAccessModeProto* device_printers_access_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_printers_access_mode_);
  }
  _impl_.device_printers_access_mode_ = device_printers_access_mode;
  if (device_printers_access_mode) {
    _impl_._has_bits_[3] |= 0x00000080u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printers_access_mode)
}
inline ::enterprise_management::DevicePrintersAccessModeProto* ChromeDeviceSettingsProto::release_device_printers_access_mode() {
  _impl_._has_bits_[3] &= ~0x00000080u;
  ::enterprise_management::DevicePrintersAccessModeProto* temp = _impl_.device_printers_access_mode_;
  _impl_.device_printers_access_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePrintersAccessModeProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_printers_access_mode() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_printers_access_mode)
  _impl_._has_bits_[3] &= ~0x00000080u;
  ::enterprise_management::DevicePrintersAccessModeProto* temp = _impl_.device_printers_access_mode_;
  _impl_.device_printers_access_mode_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePrintersAccessModeProto* ChromeDeviceSettingsProto::_internal_mutable_device_printers_access_mode() {
  _impl_._has_bits_[3] |= 0x00000080u;
  if (_impl_.device_printers_access_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePrintersAccessModeProto>(GetArenaForAllocation());
    _impl_.device_printers_access_mode_ = p;
  }
  return _impl_.device_printers_access_mode_;
}
inline ::enterprise_management::DevicePrintersAccessModeProto* ChromeDeviceSettingsProto::mutable_device_printers_access_mode() {
  ::enterprise_management::DevicePrintersAccessModeProto* _msg = _internal_mutable_device_printers_access_mode();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_printers_access_mode)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_printers_access_mode(::enterprise_management::DevicePrintersAccessModeProto* device_printers_access_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_printers_access_mode_;
  }
  if (device_printers_access_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_printers_access_mode);
    if (message_arena != submessage_arena) {
      device_printers_access_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_printers_access_mode, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000080u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000080u;
  }
  _impl_.device_printers_access_mode_ = device_printers_access_mode;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printers_access_mode)
}

// optional .enterprise_management.DevicePrintersBlocklistProto device_printers_blocklist = 108;
inline bool ChromeDeviceSettingsProto::_internal_has_device_printers_blocklist() const {
  bool value = (_impl_._has_bits_[3] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_printers_blocklist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_printers_blocklist() const {
  return _internal_has_device_printers_blocklist();
}
inline void ChromeDeviceSettingsProto::clear_device_printers_blocklist() {
  if (_impl_.device_printers_blocklist_ != nullptr) _impl_.device_printers_blocklist_->Clear();
  _impl_._has_bits_[3] &= ~0x00000100u;
}
inline const ::enterprise_management::DevicePrintersBlocklistProto& ChromeDeviceSettingsProto::_internal_device_printers_blocklist() const {
  const ::enterprise_management::DevicePrintersBlocklistProto* p = _impl_.device_printers_blocklist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePrintersBlocklistProto&>(
      ::enterprise_management::_DevicePrintersBlocklistProto_default_instance_);
}
inline const ::enterprise_management::DevicePrintersBlocklistProto& ChromeDeviceSettingsProto::device_printers_blocklist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_printers_blocklist)
  return _internal_device_printers_blocklist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_printers_blocklist(
    ::enterprise_management::DevicePrintersBlocklistProto* device_printers_blocklist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_printers_blocklist_);
  }
  _impl_.device_printers_blocklist_ = device_printers_blocklist;
  if (device_printers_blocklist) {
    _impl_._has_bits_[3] |= 0x00000100u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printers_blocklist)
}
inline ::enterprise_management::DevicePrintersBlocklistProto* ChromeDeviceSettingsProto::release_device_printers_blocklist() {
  _impl_._has_bits_[3] &= ~0x00000100u;
  ::enterprise_management::DevicePrintersBlocklistProto* temp = _impl_.device_printers_blocklist_;
  _impl_.device_printers_blocklist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePrintersBlocklistProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_printers_blocklist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_printers_blocklist)
  _impl_._has_bits_[3] &= ~0x00000100u;
  ::enterprise_management::DevicePrintersBlocklistProto* temp = _impl_.device_printers_blocklist_;
  _impl_.device_printers_blocklist_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePrintersBlocklistProto* ChromeDeviceSettingsProto::_internal_mutable_device_printers_blocklist() {
  _impl_._has_bits_[3] |= 0x00000100u;
  if (_impl_.device_printers_blocklist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePrintersBlocklistProto>(GetArenaForAllocation());
    _impl_.device_printers_blocklist_ = p;
  }
  return _impl_.device_printers_blocklist_;
}
inline ::enterprise_management::DevicePrintersBlocklistProto* ChromeDeviceSettingsProto::mutable_device_printers_blocklist() {
  ::enterprise_management::DevicePrintersBlocklistProto* _msg = _internal_mutable_device_printers_blocklist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_printers_blocklist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_printers_blocklist(::enterprise_management::DevicePrintersBlocklistProto* device_printers_blocklist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_printers_blocklist_;
  }
  if (device_printers_blocklist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_printers_blocklist);
    if (message_arena != submessage_arena) {
      device_printers_blocklist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_printers_blocklist, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000100u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000100u;
  }
  _impl_.device_printers_blocklist_ = device_printers_blocklist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printers_blocklist)
}

// optional .enterprise_management.DevicePrintersAllowlistProto device_printers_allowlist = 109;
inline bool ChromeDeviceSettingsProto::_internal_has_device_printers_allowlist() const {
  bool value = (_impl_._has_bits_[3] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_printers_allowlist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_printers_allowlist() const {
  return _internal_has_device_printers_allowlist();
}
inline void ChromeDeviceSettingsProto::clear_device_printers_allowlist() {
  if (_impl_.device_printers_allowlist_ != nullptr) _impl_.device_printers_allowlist_->Clear();
  _impl_._has_bits_[3] &= ~0x00000200u;
}
inline const ::enterprise_management::DevicePrintersAllowlistProto& ChromeDeviceSettingsProto::_internal_device_printers_allowlist() const {
  const ::enterprise_management::DevicePrintersAllowlistProto* p = _impl_.device_printers_allowlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePrintersAllowlistProto&>(
      ::enterprise_management::_DevicePrintersAllowlistProto_default_instance_);
}
inline const ::enterprise_management::DevicePrintersAllowlistProto& ChromeDeviceSettingsProto::device_printers_allowlist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_printers_allowlist)
  return _internal_device_printers_allowlist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_printers_allowlist(
    ::enterprise_management::DevicePrintersAllowlistProto* device_printers_allowlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_printers_allowlist_);
  }
  _impl_.device_printers_allowlist_ = device_printers_allowlist;
  if (device_printers_allowlist) {
    _impl_._has_bits_[3] |= 0x00000200u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printers_allowlist)
}
inline ::enterprise_management::DevicePrintersAllowlistProto* ChromeDeviceSettingsProto::release_device_printers_allowlist() {
  _impl_._has_bits_[3] &= ~0x00000200u;
  ::enterprise_management::DevicePrintersAllowlistProto* temp = _impl_.device_printers_allowlist_;
  _impl_.device_printers_allowlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePrintersAllowlistProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_printers_allowlist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_printers_allowlist)
  _impl_._has_bits_[3] &= ~0x00000200u;
  ::enterprise_management::DevicePrintersAllowlistProto* temp = _impl_.device_printers_allowlist_;
  _impl_.device_printers_allowlist_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePrintersAllowlistProto* ChromeDeviceSettingsProto::_internal_mutable_device_printers_allowlist() {
  _impl_._has_bits_[3] |= 0x00000200u;
  if (_impl_.device_printers_allowlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePrintersAllowlistProto>(GetArenaForAllocation());
    _impl_.device_printers_allowlist_ = p;
  }
  return _impl_.device_printers_allowlist_;
}
inline ::enterprise_management::DevicePrintersAllowlistProto* ChromeDeviceSettingsProto::mutable_device_printers_allowlist() {
  ::enterprise_management::DevicePrintersAllowlistProto* _msg = _internal_mutable_device_printers_allowlist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_printers_allowlist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_printers_allowlist(::enterprise_management::DevicePrintersAllowlistProto* device_printers_allowlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_printers_allowlist_;
  }
  if (device_printers_allowlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_printers_allowlist);
    if (message_arena != submessage_arena) {
      device_printers_allowlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_printers_allowlist, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000200u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000200u;
  }
  _impl_.device_printers_allowlist_ = device_printers_allowlist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printers_allowlist)
}

// optional .enterprise_management.DevicePrintersProto device_printers = 110;
inline bool ChromeDeviceSettingsProto::_internal_has_device_printers() const {
  bool value = (_impl_._has_bits_[3] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_printers_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_printers() const {
  return _internal_has_device_printers();
}
inline void ChromeDeviceSettingsProto::clear_device_printers() {
  if (_impl_.device_printers_ != nullptr) _impl_.device_printers_->Clear();
  _impl_._has_bits_[3] &= ~0x00000400u;
}
inline const ::enterprise_management::DevicePrintersProto& ChromeDeviceSettingsProto::_internal_device_printers() const {
  const ::enterprise_management::DevicePrintersProto* p = _impl_.device_printers_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePrintersProto&>(
      ::enterprise_management::_DevicePrintersProto_default_instance_);
}
inline const ::enterprise_management::DevicePrintersProto& ChromeDeviceSettingsProto::device_printers() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_printers)
  return _internal_device_printers();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_printers(
    ::enterprise_management::DevicePrintersProto* device_printers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_printers_);
  }
  _impl_.device_printers_ = device_printers;
  if (device_printers) {
    _impl_._has_bits_[3] |= 0x00000400u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printers)
}
inline ::enterprise_management::DevicePrintersProto* ChromeDeviceSettingsProto::release_device_printers() {
  _impl_._has_bits_[3] &= ~0x00000400u;
  ::enterprise_management::DevicePrintersProto* temp = _impl_.device_printers_;
  _impl_.device_printers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePrintersProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_printers() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_printers)
  _impl_._has_bits_[3] &= ~0x00000400u;
  ::enterprise_management::DevicePrintersProto* temp = _impl_.device_printers_;
  _impl_.device_printers_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePrintersProto* ChromeDeviceSettingsProto::_internal_mutable_device_printers() {
  _impl_._has_bits_[3] |= 0x00000400u;
  if (_impl_.device_printers_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePrintersProto>(GetArenaForAllocation());
    _impl_.device_printers_ = p;
  }
  return _impl_.device_printers_;
}
inline ::enterprise_management::DevicePrintersProto* ChromeDeviceSettingsProto::mutable_device_printers() {
  ::enterprise_management::DevicePrintersProto* _msg = _internal_mutable_device_printers();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_printers)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_printers(::enterprise_management::DevicePrintersProto* device_printers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_printers_;
  }
  if (device_printers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_printers);
    if (message_arena != submessage_arena) {
      device_printers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_printers, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000400u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000400u;
  }
  _impl_.device_printers_ = device_printers;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printers)
}

// optional .enterprise_management.DeviceShowLowDiskSpaceNotificationProto device_show_low_disk_space_notification = 111;
inline bool ChromeDeviceSettingsProto::_internal_has_device_show_low_disk_space_notification() const {
  bool value = (_impl_._has_bits_[3] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_show_low_disk_space_notification_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_show_low_disk_space_notification() const {
  return _internal_has_device_show_low_disk_space_notification();
}
inline void ChromeDeviceSettingsProto::clear_device_show_low_disk_space_notification() {
  if (_impl_.device_show_low_disk_space_notification_ != nullptr) _impl_.device_show_low_disk_space_notification_->Clear();
  _impl_._has_bits_[3] &= ~0x00000800u;
}
inline const ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto& ChromeDeviceSettingsProto::_internal_device_show_low_disk_space_notification() const {
  const ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* p = _impl_.device_show_low_disk_space_notification_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto&>(
      ::enterprise_management::_DeviceShowLowDiskSpaceNotificationProto_default_instance_);
}
inline const ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto& ChromeDeviceSettingsProto::device_show_low_disk_space_notification() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_show_low_disk_space_notification)
  return _internal_device_show_low_disk_space_notification();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_show_low_disk_space_notification(
    ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* device_show_low_disk_space_notification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_show_low_disk_space_notification_);
  }
  _impl_.device_show_low_disk_space_notification_ = device_show_low_disk_space_notification;
  if (device_show_low_disk_space_notification) {
    _impl_._has_bits_[3] |= 0x00000800u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_show_low_disk_space_notification)
}
inline ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* ChromeDeviceSettingsProto::release_device_show_low_disk_space_notification() {
  _impl_._has_bits_[3] &= ~0x00000800u;
  ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* temp = _impl_.device_show_low_disk_space_notification_;
  _impl_.device_show_low_disk_space_notification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_show_low_disk_space_notification() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_show_low_disk_space_notification)
  _impl_._has_bits_[3] &= ~0x00000800u;
  ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* temp = _impl_.device_show_low_disk_space_notification_;
  _impl_.device_show_low_disk_space_notification_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* ChromeDeviceSettingsProto::_internal_mutable_device_show_low_disk_space_notification() {
  _impl_._has_bits_[3] |= 0x00000800u;
  if (_impl_.device_show_low_disk_space_notification_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceShowLowDiskSpaceNotificationProto>(GetArenaForAllocation());
    _impl_.device_show_low_disk_space_notification_ = p;
  }
  return _impl_.device_show_low_disk_space_notification_;
}
inline ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* ChromeDeviceSettingsProto::mutable_device_show_low_disk_space_notification() {
  ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* _msg = _internal_mutable_device_show_low_disk_space_notification();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_show_low_disk_space_notification)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_show_low_disk_space_notification(::enterprise_management::DeviceShowLowDiskSpaceNotificationProto* device_show_low_disk_space_notification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_show_low_disk_space_notification_;
  }
  if (device_show_low_disk_space_notification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_show_low_disk_space_notification);
    if (message_arena != submessage_arena) {
      device_show_low_disk_space_notification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_show_low_disk_space_notification, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00000800u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000800u;
  }
  _impl_.device_show_low_disk_space_notification_ = device_show_low_disk_space_notification;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_show_low_disk_space_notification)
}

// optional .enterprise_management.UserAllowlistProto user_allowlist = 112;
inline bool ChromeDeviceSettingsProto::_internal_has_user_allowlist() const {
  bool value = (_impl_._has_bits_[3] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_allowlist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_user_allowlist() const {
  return _internal_has_user_allowlist();
}
inline void ChromeDeviceSettingsProto::clear_user_allowlist() {
  if (_impl_.user_allowlist_ != nullptr) _impl_.user_allowlist_->Clear();
  _impl_._has_bits_[3] &= ~0x00001000u;
}
inline const ::enterprise_management::UserAllowlistProto& ChromeDeviceSettingsProto::_internal_user_allowlist() const {
  const ::enterprise_management::UserAllowlistProto* p = _impl_.user_allowlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::UserAllowlistProto&>(
      ::enterprise_management::_UserAllowlistProto_default_instance_);
}
inline const ::enterprise_management::UserAllowlistProto& ChromeDeviceSettingsProto::user_allowlist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.user_allowlist)
  return _internal_user_allowlist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_user_allowlist(
    ::enterprise_management::UserAllowlistProto* user_allowlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_allowlist_);
  }
  _impl_.user_allowlist_ = user_allowlist;
  if (user_allowlist) {
    _impl_._has_bits_[3] |= 0x00001000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.user_allowlist)
}
inline ::enterprise_management::UserAllowlistProto* ChromeDeviceSettingsProto::release_user_allowlist() {
  _impl_._has_bits_[3] &= ~0x00001000u;
  ::enterprise_management::UserAllowlistProto* temp = _impl_.user_allowlist_;
  _impl_.user_allowlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::UserAllowlistProto* ChromeDeviceSettingsProto::unsafe_arena_release_user_allowlist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.user_allowlist)
  _impl_._has_bits_[3] &= ~0x00001000u;
  ::enterprise_management::UserAllowlistProto* temp = _impl_.user_allowlist_;
  _impl_.user_allowlist_ = nullptr;
  return temp;
}
inline ::enterprise_management::UserAllowlistProto* ChromeDeviceSettingsProto::_internal_mutable_user_allowlist() {
  _impl_._has_bits_[3] |= 0x00001000u;
  if (_impl_.user_allowlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::UserAllowlistProto>(GetArenaForAllocation());
    _impl_.user_allowlist_ = p;
  }
  return _impl_.user_allowlist_;
}
inline ::enterprise_management::UserAllowlistProto* ChromeDeviceSettingsProto::mutable_user_allowlist() {
  ::enterprise_management::UserAllowlistProto* _msg = _internal_mutable_user_allowlist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.user_allowlist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_user_allowlist(::enterprise_management::UserAllowlistProto* user_allowlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_allowlist_;
  }
  if (user_allowlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_allowlist);
    if (message_arena != submessage_arena) {
      user_allowlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_allowlist, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00001000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00001000u;
  }
  _impl_.user_allowlist_ = user_allowlist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.user_allowlist)
}

// optional .enterprise_management.UsbDetachableAllowlistProto usb_detachable_allowlist = 113;
inline bool ChromeDeviceSettingsProto::_internal_has_usb_detachable_allowlist() const {
  bool value = (_impl_._has_bits_[3] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.usb_detachable_allowlist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_usb_detachable_allowlist() const {
  return _internal_has_usb_detachable_allowlist();
}
inline void ChromeDeviceSettingsProto::clear_usb_detachable_allowlist() {
  if (_impl_.usb_detachable_allowlist_ != nullptr) _impl_.usb_detachable_allowlist_->Clear();
  _impl_._has_bits_[3] &= ~0x00002000u;
}
inline const ::enterprise_management::UsbDetachableAllowlistProto& ChromeDeviceSettingsProto::_internal_usb_detachable_allowlist() const {
  const ::enterprise_management::UsbDetachableAllowlistProto* p = _impl_.usb_detachable_allowlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::UsbDetachableAllowlistProto&>(
      ::enterprise_management::_UsbDetachableAllowlistProto_default_instance_);
}
inline const ::enterprise_management::UsbDetachableAllowlistProto& ChromeDeviceSettingsProto::usb_detachable_allowlist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_allowlist)
  return _internal_usb_detachable_allowlist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_usb_detachable_allowlist(
    ::enterprise_management::UsbDetachableAllowlistProto* usb_detachable_allowlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usb_detachable_allowlist_);
  }
  _impl_.usb_detachable_allowlist_ = usb_detachable_allowlist;
  if (usb_detachable_allowlist) {
    _impl_._has_bits_[3] |= 0x00002000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_allowlist)
}
inline ::enterprise_management::UsbDetachableAllowlistProto* ChromeDeviceSettingsProto::release_usb_detachable_allowlist() {
  _impl_._has_bits_[3] &= ~0x00002000u;
  ::enterprise_management::UsbDetachableAllowlistProto* temp = _impl_.usb_detachable_allowlist_;
  _impl_.usb_detachable_allowlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::UsbDetachableAllowlistProto* ChromeDeviceSettingsProto::unsafe_arena_release_usb_detachable_allowlist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_allowlist)
  _impl_._has_bits_[3] &= ~0x00002000u;
  ::enterprise_management::UsbDetachableAllowlistProto* temp = _impl_.usb_detachable_allowlist_;
  _impl_.usb_detachable_allowlist_ = nullptr;
  return temp;
}
inline ::enterprise_management::UsbDetachableAllowlistProto* ChromeDeviceSettingsProto::_internal_mutable_usb_detachable_allowlist() {
  _impl_._has_bits_[3] |= 0x00002000u;
  if (_impl_.usb_detachable_allowlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::UsbDetachableAllowlistProto>(GetArenaForAllocation());
    _impl_.usb_detachable_allowlist_ = p;
  }
  return _impl_.usb_detachable_allowlist_;
}
inline ::enterprise_management::UsbDetachableAllowlistProto* ChromeDeviceSettingsProto::mutable_usb_detachable_allowlist() {
  ::enterprise_management::UsbDetachableAllowlistProto* _msg = _internal_mutable_usb_detachable_allowlist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_allowlist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_usb_detachable_allowlist(::enterprise_management::UsbDetachableAllowlistProto* usb_detachable_allowlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.usb_detachable_allowlist_;
  }
  if (usb_detachable_allowlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(usb_detachable_allowlist);
    if (message_arena != submessage_arena) {
      usb_detachable_allowlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usb_detachable_allowlist, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00002000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00002000u;
  }
  _impl_.usb_detachable_allowlist_ = usb_detachable_allowlist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.usb_detachable_allowlist)
}

// optional .enterprise_management.DeviceFamilyLinkAccountsAllowedProto family_link_accounts_allowed = 114;
inline bool ChromeDeviceSettingsProto::_internal_has_family_link_accounts_allowed() const {
  bool value = (_impl_._has_bits_[3] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.family_link_accounts_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_family_link_accounts_allowed() const {
  return _internal_has_family_link_accounts_allowed();
}
inline void ChromeDeviceSettingsProto::clear_family_link_accounts_allowed() {
  if (_impl_.family_link_accounts_allowed_ != nullptr) _impl_.family_link_accounts_allowed_->Clear();
  _impl_._has_bits_[3] &= ~0x00004000u;
}
inline const ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto& ChromeDeviceSettingsProto::_internal_family_link_accounts_allowed() const {
  const ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* p = _impl_.family_link_accounts_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto&>(
      ::enterprise_management::_DeviceFamilyLinkAccountsAllowedProto_default_instance_);
}
inline const ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto& ChromeDeviceSettingsProto::family_link_accounts_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.family_link_accounts_allowed)
  return _internal_family_link_accounts_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_family_link_accounts_allowed(
    ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* family_link_accounts_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.family_link_accounts_allowed_);
  }
  _impl_.family_link_accounts_allowed_ = family_link_accounts_allowed;
  if (family_link_accounts_allowed) {
    _impl_._has_bits_[3] |= 0x00004000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.family_link_accounts_allowed)
}
inline ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* ChromeDeviceSettingsProto::release_family_link_accounts_allowed() {
  _impl_._has_bits_[3] &= ~0x00004000u;
  ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* temp = _impl_.family_link_accounts_allowed_;
  _impl_.family_link_accounts_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_family_link_accounts_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.family_link_accounts_allowed)
  _impl_._has_bits_[3] &= ~0x00004000u;
  ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* temp = _impl_.family_link_accounts_allowed_;
  _impl_.family_link_accounts_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_family_link_accounts_allowed() {
  _impl_._has_bits_[3] |= 0x00004000u;
  if (_impl_.family_link_accounts_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceFamilyLinkAccountsAllowedProto>(GetArenaForAllocation());
    _impl_.family_link_accounts_allowed_ = p;
  }
  return _impl_.family_link_accounts_allowed_;
}
inline ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* ChromeDeviceSettingsProto::mutable_family_link_accounts_allowed() {
  ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* _msg = _internal_mutable_family_link_accounts_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.family_link_accounts_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_family_link_accounts_allowed(::enterprise_management::DeviceFamilyLinkAccountsAllowedProto* family_link_accounts_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.family_link_accounts_allowed_;
  }
  if (family_link_accounts_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(family_link_accounts_allowed);
    if (message_arena != submessage_arena) {
      family_link_accounts_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, family_link_accounts_allowed, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00004000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00004000u;
  }
  _impl_.family_link_accounts_allowed_ = family_link_accounts_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.family_link_accounts_allowed)
}

// optional .enterprise_management.DeviceArcDataSnapshotHoursProto arc_data_snapshot_hours = 115;
inline bool ChromeDeviceSettingsProto::_internal_has_arc_data_snapshot_hours() const {
  bool value = (_impl_._has_bits_[3] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arc_data_snapshot_hours_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_arc_data_snapshot_hours() const {
  return _internal_has_arc_data_snapshot_hours();
}
inline void ChromeDeviceSettingsProto::clear_arc_data_snapshot_hours() {
  if (_impl_.arc_data_snapshot_hours_ != nullptr) _impl_.arc_data_snapshot_hours_->Clear();
  _impl_._has_bits_[3] &= ~0x00008000u;
}
inline const ::enterprise_management::DeviceArcDataSnapshotHoursProto& ChromeDeviceSettingsProto::_internal_arc_data_snapshot_hours() const {
  const ::enterprise_management::DeviceArcDataSnapshotHoursProto* p = _impl_.arc_data_snapshot_hours_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceArcDataSnapshotHoursProto&>(
      ::enterprise_management::_DeviceArcDataSnapshotHoursProto_default_instance_);
}
inline const ::enterprise_management::DeviceArcDataSnapshotHoursProto& ChromeDeviceSettingsProto::arc_data_snapshot_hours() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.arc_data_snapshot_hours)
  return _internal_arc_data_snapshot_hours();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_arc_data_snapshot_hours(
    ::enterprise_management::DeviceArcDataSnapshotHoursProto* arc_data_snapshot_hours) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arc_data_snapshot_hours_);
  }
  _impl_.arc_data_snapshot_hours_ = arc_data_snapshot_hours;
  if (arc_data_snapshot_hours) {
    _impl_._has_bits_[3] |= 0x00008000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.arc_data_snapshot_hours)
}
inline ::enterprise_management::DeviceArcDataSnapshotHoursProto* ChromeDeviceSettingsProto::release_arc_data_snapshot_hours() {
  _impl_._has_bits_[3] &= ~0x00008000u;
  ::enterprise_management::DeviceArcDataSnapshotHoursProto* temp = _impl_.arc_data_snapshot_hours_;
  _impl_.arc_data_snapshot_hours_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceArcDataSnapshotHoursProto* ChromeDeviceSettingsProto::unsafe_arena_release_arc_data_snapshot_hours() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.arc_data_snapshot_hours)
  _impl_._has_bits_[3] &= ~0x00008000u;
  ::enterprise_management::DeviceArcDataSnapshotHoursProto* temp = _impl_.arc_data_snapshot_hours_;
  _impl_.arc_data_snapshot_hours_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceArcDataSnapshotHoursProto* ChromeDeviceSettingsProto::_internal_mutable_arc_data_snapshot_hours() {
  _impl_._has_bits_[3] |= 0x00008000u;
  if (_impl_.arc_data_snapshot_hours_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceArcDataSnapshotHoursProto>(GetArenaForAllocation());
    _impl_.arc_data_snapshot_hours_ = p;
  }
  return _impl_.arc_data_snapshot_hours_;
}
inline ::enterprise_management::DeviceArcDataSnapshotHoursProto* ChromeDeviceSettingsProto::mutable_arc_data_snapshot_hours() {
  ::enterprise_management::DeviceArcDataSnapshotHoursProto* _msg = _internal_mutable_arc_data_snapshot_hours();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.arc_data_snapshot_hours)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_arc_data_snapshot_hours(::enterprise_management::DeviceArcDataSnapshotHoursProto* arc_data_snapshot_hours) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arc_data_snapshot_hours_;
  }
  if (arc_data_snapshot_hours) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arc_data_snapshot_hours);
    if (message_arena != submessage_arena) {
      arc_data_snapshot_hours = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arc_data_snapshot_hours, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00008000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00008000u;
  }
  _impl_.arc_data_snapshot_hours_ = arc_data_snapshot_hours;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.arc_data_snapshot_hours)
}

// optional .enterprise_management.BooleanPolicyProto device_allow_mgs_to_store_display_properties = 116;
inline bool ChromeDeviceSettingsProto::_internal_has_device_allow_mgs_to_store_display_properties() const {
  bool value = (_impl_._has_bits_[3] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_allow_mgs_to_store_display_properties_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_allow_mgs_to_store_display_properties() const {
  return _internal_has_device_allow_mgs_to_store_display_properties();
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::_internal_device_allow_mgs_to_store_display_properties() const {
  const ::enterprise_management::BooleanPolicyProto* p = _impl_.device_allow_mgs_to_store_display_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BooleanPolicyProto&>(
      ::enterprise_management::_BooleanPolicyProto_default_instance_);
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::device_allow_mgs_to_store_display_properties() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_allow_mgs_to_store_display_properties)
  return _internal_device_allow_mgs_to_store_display_properties();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_allow_mgs_to_store_display_properties(
    ::enterprise_management::BooleanPolicyProto* device_allow_mgs_to_store_display_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_allow_mgs_to_store_display_properties_);
  }
  _impl_.device_allow_mgs_to_store_display_properties_ = device_allow_mgs_to_store_display_properties;
  if (device_allow_mgs_to_store_display_properties) {
    _impl_._has_bits_[3] |= 0x00010000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_allow_mgs_to_store_display_properties)
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::release_device_allow_mgs_to_store_display_properties() {
  _impl_._has_bits_[3] &= ~0x00010000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.device_allow_mgs_to_store_display_properties_;
  _impl_.device_allow_mgs_to_store_display_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_allow_mgs_to_store_display_properties() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_allow_mgs_to_store_display_properties)
  _impl_._has_bits_[3] &= ~0x00010000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.device_allow_mgs_to_store_display_properties_;
  _impl_.device_allow_mgs_to_store_display_properties_ = nullptr;
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_allow_mgs_to_store_display_properties() {
  _impl_._has_bits_[3] |= 0x00010000u;
  if (_impl_.device_allow_mgs_to_store_display_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BooleanPolicyProto>(GetArenaForAllocation());
    _impl_.device_allow_mgs_to_store_display_properties_ = p;
  }
  return _impl_.device_allow_mgs_to_store_display_properties_;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::mutable_device_allow_mgs_to_store_display_properties() {
  ::enterprise_management::BooleanPolicyProto* _msg = _internal_mutable_device_allow_mgs_to_store_display_properties();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_allow_mgs_to_store_display_properties)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_allow_mgs_to_store_display_properties(::enterprise_management::BooleanPolicyProto* device_allow_mgs_to_store_display_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_allow_mgs_to_store_display_properties_);
  }
  if (device_allow_mgs_to_store_display_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_allow_mgs_to_store_display_properties));
    if (message_arena != submessage_arena) {
      device_allow_mgs_to_store_display_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_allow_mgs_to_store_display_properties, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00010000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00010000u;
  }
  _impl_.device_allow_mgs_to_store_display_properties_ = device_allow_mgs_to_store_display_properties;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_allow_mgs_to_store_display_properties)
}

// optional .enterprise_management.DeviceSystemWideTracingEnabledProto device_system_wide_tracing_enabled = 117;
inline bool ChromeDeviceSettingsProto::_internal_has_device_system_wide_tracing_enabled() const {
  bool value = (_impl_._has_bits_[3] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_system_wide_tracing_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_system_wide_tracing_enabled() const {
  return _internal_has_device_system_wide_tracing_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_system_wide_tracing_enabled() {
  if (_impl_.device_system_wide_tracing_enabled_ != nullptr) _impl_.device_system_wide_tracing_enabled_->Clear();
  _impl_._has_bits_[3] &= ~0x00020000u;
}
inline const ::enterprise_management::DeviceSystemWideTracingEnabledProto& ChromeDeviceSettingsProto::_internal_device_system_wide_tracing_enabled() const {
  const ::enterprise_management::DeviceSystemWideTracingEnabledProto* p = _impl_.device_system_wide_tracing_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceSystemWideTracingEnabledProto&>(
      ::enterprise_management::_DeviceSystemWideTracingEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceSystemWideTracingEnabledProto& ChromeDeviceSettingsProto::device_system_wide_tracing_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_system_wide_tracing_enabled)
  return _internal_device_system_wide_tracing_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_system_wide_tracing_enabled(
    ::enterprise_management::DeviceSystemWideTracingEnabledProto* device_system_wide_tracing_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_system_wide_tracing_enabled_);
  }
  _impl_.device_system_wide_tracing_enabled_ = device_system_wide_tracing_enabled;
  if (device_system_wide_tracing_enabled) {
    _impl_._has_bits_[3] |= 0x00020000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_system_wide_tracing_enabled)
}
inline ::enterprise_management::DeviceSystemWideTracingEnabledProto* ChromeDeviceSettingsProto::release_device_system_wide_tracing_enabled() {
  _impl_._has_bits_[3] &= ~0x00020000u;
  ::enterprise_management::DeviceSystemWideTracingEnabledProto* temp = _impl_.device_system_wide_tracing_enabled_;
  _impl_.device_system_wide_tracing_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceSystemWideTracingEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_system_wide_tracing_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_system_wide_tracing_enabled)
  _impl_._has_bits_[3] &= ~0x00020000u;
  ::enterprise_management::DeviceSystemWideTracingEnabledProto* temp = _impl_.device_system_wide_tracing_enabled_;
  _impl_.device_system_wide_tracing_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceSystemWideTracingEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_system_wide_tracing_enabled() {
  _impl_._has_bits_[3] |= 0x00020000u;
  if (_impl_.device_system_wide_tracing_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceSystemWideTracingEnabledProto>(GetArenaForAllocation());
    _impl_.device_system_wide_tracing_enabled_ = p;
  }
  return _impl_.device_system_wide_tracing_enabled_;
}
inline ::enterprise_management::DeviceSystemWideTracingEnabledProto* ChromeDeviceSettingsProto::mutable_device_system_wide_tracing_enabled() {
  ::enterprise_management::DeviceSystemWideTracingEnabledProto* _msg = _internal_mutable_device_system_wide_tracing_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_system_wide_tracing_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_system_wide_tracing_enabled(::enterprise_management::DeviceSystemWideTracingEnabledProto* device_system_wide_tracing_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_system_wide_tracing_enabled_;
  }
  if (device_system_wide_tracing_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_system_wide_tracing_enabled);
    if (message_arena != submessage_arena) {
      device_system_wide_tracing_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_system_wide_tracing_enabled, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00020000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00020000u;
  }
  _impl_.device_system_wide_tracing_enabled_ = device_system_wide_tracing_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_system_wide_tracing_enabled)
}

// optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProto device_pci_peripheral_data_access_enabled = 118;
inline bool ChromeDeviceSettingsProto::_internal_has_device_pci_peripheral_data_access_enabled() const {
  bool value = (_impl_._has_bits_[3] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_pci_peripheral_data_access_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_pci_peripheral_data_access_enabled() const {
  return _internal_has_device_pci_peripheral_data_access_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_pci_peripheral_data_access_enabled() {
  if (_impl_.device_pci_peripheral_data_access_enabled_ != nullptr) _impl_.device_pci_peripheral_data_access_enabled_->Clear();
  _impl_._has_bits_[3] &= ~0x00040000u;
}
inline const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto& ChromeDeviceSettingsProto::_internal_device_pci_peripheral_data_access_enabled() const {
  const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* p = _impl_.device_pci_peripheral_data_access_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto&>(
      ::enterprise_management::_DevicePciPeripheralDataAccessEnabledProto_default_instance_);
}
inline const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto& ChromeDeviceSettingsProto::device_pci_peripheral_data_access_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled)
  return _internal_device_pci_peripheral_data_access_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_pci_peripheral_data_access_enabled(
    ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* device_pci_peripheral_data_access_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_pci_peripheral_data_access_enabled_);
  }
  _impl_.device_pci_peripheral_data_access_enabled_ = device_pci_peripheral_data_access_enabled;
  if (device_pci_peripheral_data_access_enabled) {
    _impl_._has_bits_[3] |= 0x00040000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled)
}
inline ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* ChromeDeviceSettingsProto::release_device_pci_peripheral_data_access_enabled() {
  _impl_._has_bits_[3] &= ~0x00040000u;
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* temp = _impl_.device_pci_peripheral_data_access_enabled_;
  _impl_.device_pci_peripheral_data_access_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_pci_peripheral_data_access_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled)
  _impl_._has_bits_[3] &= ~0x00040000u;
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* temp = _impl_.device_pci_peripheral_data_access_enabled_;
  _impl_.device_pci_peripheral_data_access_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_pci_peripheral_data_access_enabled() {
  _impl_._has_bits_[3] |= 0x00040000u;
  if (_impl_.device_pci_peripheral_data_access_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePciPeripheralDataAccessEnabledProto>(GetArenaForAllocation());
    _impl_.device_pci_peripheral_data_access_enabled_ = p;
  }
  return _impl_.device_pci_peripheral_data_access_enabled_;
}
inline ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* ChromeDeviceSettingsProto::mutable_device_pci_peripheral_data_access_enabled() {
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* _msg = _internal_mutable_device_pci_peripheral_data_access_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_pci_peripheral_data_access_enabled(::enterprise_management::DevicePciPeripheralDataAccessEnabledProto* device_pci_peripheral_data_access_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_pci_peripheral_data_access_enabled_;
  }
  if (device_pci_peripheral_data_access_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_pci_peripheral_data_access_enabled);
    if (message_arena != submessage_arena) {
      device_pci_peripheral_data_access_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_pci_peripheral_data_access_enabled, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00040000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00040000u;
  }
  _impl_.device_pci_peripheral_data_access_enabled_ = device_pci_peripheral_data_access_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled)
}

// optional .enterprise_management.OBSOLETE_DeviceBorealisAllowedProto device_borealis_allowed = 119 [deprecated = true];
inline bool ChromeDeviceSettingsProto::_internal_has_device_borealis_allowed() const {
  bool value = (_impl_._has_bits_[3] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_borealis_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_borealis_allowed() const {
  return _internal_has_device_borealis_allowed();
}
inline void ChromeDeviceSettingsProto::clear_device_borealis_allowed() {
  if (_impl_.device_borealis_allowed_ != nullptr) _impl_.device_borealis_allowed_->Clear();
  _impl_._has_bits_[3] &= ~0x00080000u;
}
inline const ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto& ChromeDeviceSettingsProto::_internal_device_borealis_allowed() const {
  const ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* p = _impl_.device_borealis_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto&>(
      ::enterprise_management::_OBSOLETE_DeviceBorealisAllowedProto_default_instance_);
}
inline const ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto& ChromeDeviceSettingsProto::device_borealis_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_borealis_allowed)
  return _internal_device_borealis_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_borealis_allowed(
    ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* device_borealis_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_borealis_allowed_);
  }
  _impl_.device_borealis_allowed_ = device_borealis_allowed;
  if (device_borealis_allowed) {
    _impl_._has_bits_[3] |= 0x00080000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_borealis_allowed)
}
inline ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* ChromeDeviceSettingsProto::release_device_borealis_allowed() {
  _impl_._has_bits_[3] &= ~0x00080000u;
  ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* temp = _impl_.device_borealis_allowed_;
  _impl_.device_borealis_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_borealis_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_borealis_allowed)
  _impl_._has_bits_[3] &= ~0x00080000u;
  ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* temp = _impl_.device_borealis_allowed_;
  _impl_.device_borealis_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_device_borealis_allowed() {
  _impl_._has_bits_[3] |= 0x00080000u;
  if (_impl_.device_borealis_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto>(GetArenaForAllocation());
    _impl_.device_borealis_allowed_ = p;
  }
  return _impl_.device_borealis_allowed_;
}
inline ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* ChromeDeviceSettingsProto::mutable_device_borealis_allowed() {
  ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* _msg = _internal_mutable_device_borealis_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_borealis_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_borealis_allowed(::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto* device_borealis_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_borealis_allowed_;
  }
  if (device_borealis_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_borealis_allowed);
    if (message_arena != submessage_arena) {
      device_borealis_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_borealis_allowed, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00080000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00080000u;
  }
  _impl_.device_borealis_allowed_ = device_borealis_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_borealis_allowed)
}

// optional .enterprise_management.DeviceAllowedBluetoothServicesProto device_allowed_bluetooth_services = 120;
inline bool ChromeDeviceSettingsProto::_internal_has_device_allowed_bluetooth_services() const {
  bool value = (_impl_._has_bits_[3] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_allowed_bluetooth_services_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_allowed_bluetooth_services() const {
  return _internal_has_device_allowed_bluetooth_services();
}
inline void ChromeDeviceSettingsProto::clear_device_allowed_bluetooth_services() {
  if (_impl_.device_allowed_bluetooth_services_ != nullptr) _impl_.device_allowed_bluetooth_services_->Clear();
  _impl_._has_bits_[3] &= ~0x00100000u;
}
inline const ::enterprise_management::DeviceAllowedBluetoothServicesProto& ChromeDeviceSettingsProto::_internal_device_allowed_bluetooth_services() const {
  const ::enterprise_management::DeviceAllowedBluetoothServicesProto* p = _impl_.device_allowed_bluetooth_services_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAllowedBluetoothServicesProto&>(
      ::enterprise_management::_DeviceAllowedBluetoothServicesProto_default_instance_);
}
inline const ::enterprise_management::DeviceAllowedBluetoothServicesProto& ChromeDeviceSettingsProto::device_allowed_bluetooth_services() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_allowed_bluetooth_services)
  return _internal_device_allowed_bluetooth_services();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_allowed_bluetooth_services(
    ::enterprise_management::DeviceAllowedBluetoothServicesProto* device_allowed_bluetooth_services) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_allowed_bluetooth_services_);
  }
  _impl_.device_allowed_bluetooth_services_ = device_allowed_bluetooth_services;
  if (device_allowed_bluetooth_services) {
    _impl_._has_bits_[3] |= 0x00100000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_allowed_bluetooth_services)
}
inline ::enterprise_management::DeviceAllowedBluetoothServicesProto* ChromeDeviceSettingsProto::release_device_allowed_bluetooth_services() {
  _impl_._has_bits_[3] &= ~0x00100000u;
  ::enterprise_management::DeviceAllowedBluetoothServicesProto* temp = _impl_.device_allowed_bluetooth_services_;
  _impl_.device_allowed_bluetooth_services_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAllowedBluetoothServicesProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_allowed_bluetooth_services() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_allowed_bluetooth_services)
  _impl_._has_bits_[3] &= ~0x00100000u;
  ::enterprise_management::DeviceAllowedBluetoothServicesProto* temp = _impl_.device_allowed_bluetooth_services_;
  _impl_.device_allowed_bluetooth_services_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAllowedBluetoothServicesProto* ChromeDeviceSettingsProto::_internal_mutable_device_allowed_bluetooth_services() {
  _impl_._has_bits_[3] |= 0x00100000u;
  if (_impl_.device_allowed_bluetooth_services_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAllowedBluetoothServicesProto>(GetArenaForAllocation());
    _impl_.device_allowed_bluetooth_services_ = p;
  }
  return _impl_.device_allowed_bluetooth_services_;
}
inline ::enterprise_management::DeviceAllowedBluetoothServicesProto* ChromeDeviceSettingsProto::mutable_device_allowed_bluetooth_services() {
  ::enterprise_management::DeviceAllowedBluetoothServicesProto* _msg = _internal_mutable_device_allowed_bluetooth_services();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_allowed_bluetooth_services)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_allowed_bluetooth_services(::enterprise_management::DeviceAllowedBluetoothServicesProto* device_allowed_bluetooth_services) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_allowed_bluetooth_services_;
  }
  if (device_allowed_bluetooth_services) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_allowed_bluetooth_services);
    if (message_arena != submessage_arena) {
      device_allowed_bluetooth_services = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_allowed_bluetooth_services, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00100000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00100000u;
  }
  _impl_.device_allowed_bluetooth_services_ = device_allowed_bluetooth_services;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_allowed_bluetooth_services)
}

// optional .enterprise_management.DeviceDebugPacketCaptureAllowedProto device_debug_packet_capture_allowed = 121;
inline bool ChromeDeviceSettingsProto::_internal_has_device_debug_packet_capture_allowed() const {
  bool value = (_impl_._has_bits_[3] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_debug_packet_capture_allowed_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_debug_packet_capture_allowed() const {
  return _internal_has_device_debug_packet_capture_allowed();
}
inline void ChromeDeviceSettingsProto::clear_device_debug_packet_capture_allowed() {
  if (_impl_.device_debug_packet_capture_allowed_ != nullptr) _impl_.device_debug_packet_capture_allowed_->Clear();
  _impl_._has_bits_[3] &= ~0x00200000u;
}
inline const ::enterprise_management::DeviceDebugPacketCaptureAllowedProto& ChromeDeviceSettingsProto::_internal_device_debug_packet_capture_allowed() const {
  const ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* p = _impl_.device_debug_packet_capture_allowed_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceDebugPacketCaptureAllowedProto&>(
      ::enterprise_management::_DeviceDebugPacketCaptureAllowedProto_default_instance_);
}
inline const ::enterprise_management::DeviceDebugPacketCaptureAllowedProto& ChromeDeviceSettingsProto::device_debug_packet_capture_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_debug_packet_capture_allowed)
  return _internal_device_debug_packet_capture_allowed();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_debug_packet_capture_allowed(
    ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* device_debug_packet_capture_allowed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_debug_packet_capture_allowed_);
  }
  _impl_.device_debug_packet_capture_allowed_ = device_debug_packet_capture_allowed;
  if (device_debug_packet_capture_allowed) {
    _impl_._has_bits_[3] |= 0x00200000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_debug_packet_capture_allowed)
}
inline ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* ChromeDeviceSettingsProto::release_device_debug_packet_capture_allowed() {
  _impl_._has_bits_[3] &= ~0x00200000u;
  ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* temp = _impl_.device_debug_packet_capture_allowed_;
  _impl_.device_debug_packet_capture_allowed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_debug_packet_capture_allowed() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_debug_packet_capture_allowed)
  _impl_._has_bits_[3] &= ~0x00200000u;
  ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* temp = _impl_.device_debug_packet_capture_allowed_;
  _impl_.device_debug_packet_capture_allowed_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* ChromeDeviceSettingsProto::_internal_mutable_device_debug_packet_capture_allowed() {
  _impl_._has_bits_[3] |= 0x00200000u;
  if (_impl_.device_debug_packet_capture_allowed_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceDebugPacketCaptureAllowedProto>(GetArenaForAllocation());
    _impl_.device_debug_packet_capture_allowed_ = p;
  }
  return _impl_.device_debug_packet_capture_allowed_;
}
inline ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* ChromeDeviceSettingsProto::mutable_device_debug_packet_capture_allowed() {
  ::enterprise_management::DeviceDebugPacketCaptureAllowedProto* _msg = _internal_mutable_device_debug_packet_capture_allowed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_debug_packet_capture_allowed)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_debug_packet_capture_allowed(::enterprise_management::DeviceDebugPacketCaptureAllowedProto* device_debug_packet_capture_allowed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_debug_packet_capture_allowed_;
  }
  if (device_debug_packet_capture_allowed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_debug_packet_capture_allowed);
    if (message_arena != submessage_arena) {
      device_debug_packet_capture_allowed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_debug_packet_capture_allowed, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00200000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00200000u;
  }
  _impl_.device_debug_packet_capture_allowed_ = device_debug_packet_capture_allowed;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_debug_packet_capture_allowed)
}

// optional .enterprise_management.DeviceScheduledRebootProto device_scheduled_reboot = 122;
inline bool ChromeDeviceSettingsProto::_internal_has_device_scheduled_reboot() const {
  bool value = (_impl_._has_bits_[3] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_scheduled_reboot_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_scheduled_reboot() const {
  return _internal_has_device_scheduled_reboot();
}
inline void ChromeDeviceSettingsProto::clear_device_scheduled_reboot() {
  if (_impl_.device_scheduled_reboot_ != nullptr) _impl_.device_scheduled_reboot_->Clear();
  _impl_._has_bits_[3] &= ~0x00400000u;
}
inline const ::enterprise_management::DeviceScheduledRebootProto& ChromeDeviceSettingsProto::_internal_device_scheduled_reboot() const {
  const ::enterprise_management::DeviceScheduledRebootProto* p = _impl_.device_scheduled_reboot_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceScheduledRebootProto&>(
      ::enterprise_management::_DeviceScheduledRebootProto_default_instance_);
}
inline const ::enterprise_management::DeviceScheduledRebootProto& ChromeDeviceSettingsProto::device_scheduled_reboot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_reboot)
  return _internal_device_scheduled_reboot();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_scheduled_reboot(
    ::enterprise_management::DeviceScheduledRebootProto* device_scheduled_reboot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_scheduled_reboot_);
  }
  _impl_.device_scheduled_reboot_ = device_scheduled_reboot;
  if (device_scheduled_reboot) {
    _impl_._has_bits_[3] |= 0x00400000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_reboot)
}
inline ::enterprise_management::DeviceScheduledRebootProto* ChromeDeviceSettingsProto::release_device_scheduled_reboot() {
  _impl_._has_bits_[3] &= ~0x00400000u;
  ::enterprise_management::DeviceScheduledRebootProto* temp = _impl_.device_scheduled_reboot_;
  _impl_.device_scheduled_reboot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceScheduledRebootProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_scheduled_reboot() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_reboot)
  _impl_._has_bits_[3] &= ~0x00400000u;
  ::enterprise_management::DeviceScheduledRebootProto* temp = _impl_.device_scheduled_reboot_;
  _impl_.device_scheduled_reboot_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceScheduledRebootProto* ChromeDeviceSettingsProto::_internal_mutable_device_scheduled_reboot() {
  _impl_._has_bits_[3] |= 0x00400000u;
  if (_impl_.device_scheduled_reboot_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceScheduledRebootProto>(GetArenaForAllocation());
    _impl_.device_scheduled_reboot_ = p;
  }
  return _impl_.device_scheduled_reboot_;
}
inline ::enterprise_management::DeviceScheduledRebootProto* ChromeDeviceSettingsProto::mutable_device_scheduled_reboot() {
  ::enterprise_management::DeviceScheduledRebootProto* _msg = _internal_mutable_device_scheduled_reboot();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_reboot)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_scheduled_reboot(::enterprise_management::DeviceScheduledRebootProto* device_scheduled_reboot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_scheduled_reboot_;
  }
  if (device_scheduled_reboot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_scheduled_reboot);
    if (message_arena != submessage_arena) {
      device_scheduled_reboot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_scheduled_reboot, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00400000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00400000u;
  }
  _impl_.device_scheduled_reboot_ = device_scheduled_reboot;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_scheduled_reboot)
}

// optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2 device_pci_peripheral_data_access_enabled_v2 = 123;
inline bool ChromeDeviceSettingsProto::_internal_has_device_pci_peripheral_data_access_enabled_v2() const {
  bool value = (_impl_._has_bits_[3] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_pci_peripheral_data_access_enabled_v2_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_pci_peripheral_data_access_enabled_v2() const {
  return _internal_has_device_pci_peripheral_data_access_enabled_v2();
}
inline void ChromeDeviceSettingsProto::clear_device_pci_peripheral_data_access_enabled_v2() {
  if (_impl_.device_pci_peripheral_data_access_enabled_v2_ != nullptr) _impl_.device_pci_peripheral_data_access_enabled_v2_->Clear();
  _impl_._has_bits_[3] &= ~0x00800000u;
}
inline const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2& ChromeDeviceSettingsProto::_internal_device_pci_peripheral_data_access_enabled_v2() const {
  const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* p = _impl_.device_pci_peripheral_data_access_enabled_v2_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2&>(
      ::enterprise_management::_DevicePciPeripheralDataAccessEnabledProtoV2_default_instance_);
}
inline const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2& ChromeDeviceSettingsProto::device_pci_peripheral_data_access_enabled_v2() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled_v2)
  return _internal_device_pci_peripheral_data_access_enabled_v2();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_pci_peripheral_data_access_enabled_v2(
    ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* device_pci_peripheral_data_access_enabled_v2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_pci_peripheral_data_access_enabled_v2_);
  }
  _impl_.device_pci_peripheral_data_access_enabled_v2_ = device_pci_peripheral_data_access_enabled_v2;
  if (device_pci_peripheral_data_access_enabled_v2) {
    _impl_._has_bits_[3] |= 0x00800000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled_v2)
}
inline ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* ChromeDeviceSettingsProto::release_device_pci_peripheral_data_access_enabled_v2() {
  _impl_._has_bits_[3] &= ~0x00800000u;
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* temp = _impl_.device_pci_peripheral_data_access_enabled_v2_;
  _impl_.device_pci_peripheral_data_access_enabled_v2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* ChromeDeviceSettingsProto::unsafe_arena_release_device_pci_peripheral_data_access_enabled_v2() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled_v2)
  _impl_._has_bits_[3] &= ~0x00800000u;
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* temp = _impl_.device_pci_peripheral_data_access_enabled_v2_;
  _impl_.device_pci_peripheral_data_access_enabled_v2_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* ChromeDeviceSettingsProto::_internal_mutable_device_pci_peripheral_data_access_enabled_v2() {
  _impl_._has_bits_[3] |= 0x00800000u;
  if (_impl_.device_pci_peripheral_data_access_enabled_v2_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2>(GetArenaForAllocation());
    _impl_.device_pci_peripheral_data_access_enabled_v2_ = p;
  }
  return _impl_.device_pci_peripheral_data_access_enabled_v2_;
}
inline ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* ChromeDeviceSettingsProto::mutable_device_pci_peripheral_data_access_enabled_v2() {
  ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* _msg = _internal_mutable_device_pci_peripheral_data_access_enabled_v2();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled_v2)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_pci_peripheral_data_access_enabled_v2(::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2* device_pci_peripheral_data_access_enabled_v2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_pci_peripheral_data_access_enabled_v2_;
  }
  if (device_pci_peripheral_data_access_enabled_v2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_pci_peripheral_data_access_enabled_v2);
    if (message_arena != submessage_arena) {
      device_pci_peripheral_data_access_enabled_v2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_pci_peripheral_data_access_enabled_v2, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x00800000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00800000u;
  }
  _impl_.device_pci_peripheral_data_access_enabled_v2_ = device_pci_peripheral_data_access_enabled_v2;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_pci_peripheral_data_access_enabled_v2)
}

// optional .enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto device_restricted_managed_guest_session_enabled = 124;
inline bool ChromeDeviceSettingsProto::_internal_has_device_restricted_managed_guest_session_enabled() const {
  bool value = (_impl_._has_bits_[3] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_restricted_managed_guest_session_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_restricted_managed_guest_session_enabled() const {
  return _internal_has_device_restricted_managed_guest_session_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_restricted_managed_guest_session_enabled() {
  if (_impl_.device_restricted_managed_guest_session_enabled_ != nullptr) _impl_.device_restricted_managed_guest_session_enabled_->Clear();
  _impl_._has_bits_[3] &= ~0x01000000u;
}
inline const ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto& ChromeDeviceSettingsProto::_internal_device_restricted_managed_guest_session_enabled() const {
  const ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* p = _impl_.device_restricted_managed_guest_session_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto&>(
      ::enterprise_management::_DeviceRestrictedManagedGuestSessionEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto& ChromeDeviceSettingsProto::device_restricted_managed_guest_session_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_restricted_managed_guest_session_enabled)
  return _internal_device_restricted_managed_guest_session_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_restricted_managed_guest_session_enabled(
    ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* device_restricted_managed_guest_session_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_restricted_managed_guest_session_enabled_);
  }
  _impl_.device_restricted_managed_guest_session_enabled_ = device_restricted_managed_guest_session_enabled;
  if (device_restricted_managed_guest_session_enabled) {
    _impl_._has_bits_[3] |= 0x01000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_restricted_managed_guest_session_enabled)
}
inline ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* ChromeDeviceSettingsProto::release_device_restricted_managed_guest_session_enabled() {
  _impl_._has_bits_[3] &= ~0x01000000u;
  ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* temp = _impl_.device_restricted_managed_guest_session_enabled_;
  _impl_.device_restricted_managed_guest_session_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_restricted_managed_guest_session_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_restricted_managed_guest_session_enabled)
  _impl_._has_bits_[3] &= ~0x01000000u;
  ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* temp = _impl_.device_restricted_managed_guest_session_enabled_;
  _impl_.device_restricted_managed_guest_session_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_restricted_managed_guest_session_enabled() {
  _impl_._has_bits_[3] |= 0x01000000u;
  if (_impl_.device_restricted_managed_guest_session_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto>(GetArenaForAllocation());
    _impl_.device_restricted_managed_guest_session_enabled_ = p;
  }
  return _impl_.device_restricted_managed_guest_session_enabled_;
}
inline ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* ChromeDeviceSettingsProto::mutable_device_restricted_managed_guest_session_enabled() {
  ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* _msg = _internal_mutable_device_restricted_managed_guest_session_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_restricted_managed_guest_session_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_restricted_managed_guest_session_enabled(::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto* device_restricted_managed_guest_session_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_restricted_managed_guest_session_enabled_;
  }
  if (device_restricted_managed_guest_session_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_restricted_managed_guest_session_enabled);
    if (message_arena != submessage_arena) {
      device_restricted_managed_guest_session_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_restricted_managed_guest_session_enabled, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x01000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x01000000u;
  }
  _impl_.device_restricted_managed_guest_session_enabled_ = device_restricted_managed_guest_session_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_restricted_managed_guest_session_enabled)
}

// optional .enterprise_management.HostnameUserConfigurableProto hostname_user_configurable = 125;
inline bool ChromeDeviceSettingsProto::_internal_has_hostname_user_configurable() const {
  bool value = (_impl_._has_bits_[3] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hostname_user_configurable_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_hostname_user_configurable() const {
  return _internal_has_hostname_user_configurable();
}
inline void ChromeDeviceSettingsProto::clear_hostname_user_configurable() {
  if (_impl_.hostname_user_configurable_ != nullptr) _impl_.hostname_user_configurable_->Clear();
  _impl_._has_bits_[3] &= ~0x02000000u;
}
inline const ::enterprise_management::HostnameUserConfigurableProto& ChromeDeviceSettingsProto::_internal_hostname_user_configurable() const {
  const ::enterprise_management::HostnameUserConfigurableProto* p = _impl_.hostname_user_configurable_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::HostnameUserConfigurableProto&>(
      ::enterprise_management::_HostnameUserConfigurableProto_default_instance_);
}
inline const ::enterprise_management::HostnameUserConfigurableProto& ChromeDeviceSettingsProto::hostname_user_configurable() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.hostname_user_configurable)
  return _internal_hostname_user_configurable();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_hostname_user_configurable(
    ::enterprise_management::HostnameUserConfigurableProto* hostname_user_configurable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hostname_user_configurable_);
  }
  _impl_.hostname_user_configurable_ = hostname_user_configurable;
  if (hostname_user_configurable) {
    _impl_._has_bits_[3] |= 0x02000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.hostname_user_configurable)
}
inline ::enterprise_management::HostnameUserConfigurableProto* ChromeDeviceSettingsProto::release_hostname_user_configurable() {
  _impl_._has_bits_[3] &= ~0x02000000u;
  ::enterprise_management::HostnameUserConfigurableProto* temp = _impl_.hostname_user_configurable_;
  _impl_.hostname_user_configurable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::HostnameUserConfigurableProto* ChromeDeviceSettingsProto::unsafe_arena_release_hostname_user_configurable() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.hostname_user_configurable)
  _impl_._has_bits_[3] &= ~0x02000000u;
  ::enterprise_management::HostnameUserConfigurableProto* temp = _impl_.hostname_user_configurable_;
  _impl_.hostname_user_configurable_ = nullptr;
  return temp;
}
inline ::enterprise_management::HostnameUserConfigurableProto* ChromeDeviceSettingsProto::_internal_mutable_hostname_user_configurable() {
  _impl_._has_bits_[3] |= 0x02000000u;
  if (_impl_.hostname_user_configurable_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::HostnameUserConfigurableProto>(GetArenaForAllocation());
    _impl_.hostname_user_configurable_ = p;
  }
  return _impl_.hostname_user_configurable_;
}
inline ::enterprise_management::HostnameUserConfigurableProto* ChromeDeviceSettingsProto::mutable_hostname_user_configurable() {
  ::enterprise_management::HostnameUserConfigurableProto* _msg = _internal_mutable_hostname_user_configurable();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.hostname_user_configurable)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_hostname_user_configurable(::enterprise_management::HostnameUserConfigurableProto* hostname_user_configurable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hostname_user_configurable_;
  }
  if (hostname_user_configurable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hostname_user_configurable);
    if (message_arena != submessage_arena) {
      hostname_user_configurable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hostname_user_configurable, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x02000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x02000000u;
  }
  _impl_.hostname_user_configurable_ = hostname_user_configurable;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.hostname_user_configurable)
}

// optional .enterprise_management.BooleanPolicyProto login_screen_prompt_on_multiple_matching_certificates = 126;
inline bool ChromeDeviceSettingsProto::_internal_has_login_screen_prompt_on_multiple_matching_certificates() const {
  bool value = (_impl_._has_bits_[3] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_prompt_on_multiple_matching_certificates_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_screen_prompt_on_multiple_matching_certificates() const {
  return _internal_has_login_screen_prompt_on_multiple_matching_certificates();
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::_internal_login_screen_prompt_on_multiple_matching_certificates() const {
  const ::enterprise_management::BooleanPolicyProto* p = _impl_.login_screen_prompt_on_multiple_matching_certificates_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BooleanPolicyProto&>(
      ::enterprise_management::_BooleanPolicyProto_default_instance_);
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::login_screen_prompt_on_multiple_matching_certificates() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_screen_prompt_on_multiple_matching_certificates)
  return _internal_login_screen_prompt_on_multiple_matching_certificates();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_screen_prompt_on_multiple_matching_certificates(
    ::enterprise_management::BooleanPolicyProto* login_screen_prompt_on_multiple_matching_certificates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_prompt_on_multiple_matching_certificates_);
  }
  _impl_.login_screen_prompt_on_multiple_matching_certificates_ = login_screen_prompt_on_multiple_matching_certificates;
  if (login_screen_prompt_on_multiple_matching_certificates) {
    _impl_._has_bits_[3] |= 0x04000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_prompt_on_multiple_matching_certificates)
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::release_login_screen_prompt_on_multiple_matching_certificates() {
  _impl_._has_bits_[3] &= ~0x04000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.login_screen_prompt_on_multiple_matching_certificates_;
  _impl_.login_screen_prompt_on_multiple_matching_certificates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_screen_prompt_on_multiple_matching_certificates() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_screen_prompt_on_multiple_matching_certificates)
  _impl_._has_bits_[3] &= ~0x04000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.login_screen_prompt_on_multiple_matching_certificates_;
  _impl_.login_screen_prompt_on_multiple_matching_certificates_ = nullptr;
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_login_screen_prompt_on_multiple_matching_certificates() {
  _impl_._has_bits_[3] |= 0x04000000u;
  if (_impl_.login_screen_prompt_on_multiple_matching_certificates_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BooleanPolicyProto>(GetArenaForAllocation());
    _impl_.login_screen_prompt_on_multiple_matching_certificates_ = p;
  }
  return _impl_.login_screen_prompt_on_multiple_matching_certificates_;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::mutable_login_screen_prompt_on_multiple_matching_certificates() {
  ::enterprise_management::BooleanPolicyProto* _msg = _internal_mutable_login_screen_prompt_on_multiple_matching_certificates();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_screen_prompt_on_multiple_matching_certificates)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_screen_prompt_on_multiple_matching_certificates(::enterprise_management::BooleanPolicyProto* login_screen_prompt_on_multiple_matching_certificates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_prompt_on_multiple_matching_certificates_);
  }
  if (login_screen_prompt_on_multiple_matching_certificates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_screen_prompt_on_multiple_matching_certificates));
    if (message_arena != submessage_arena) {
      login_screen_prompt_on_multiple_matching_certificates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_prompt_on_multiple_matching_certificates, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x04000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x04000000u;
  }
  _impl_.login_screen_prompt_on_multiple_matching_certificates_ = login_screen_prompt_on_multiple_matching_certificates;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_prompt_on_multiple_matching_certificates)
}

// optional .enterprise_management.BooleanPolicyProto kiosk_crx_manifest_update_url_ignored = 127;
inline bool ChromeDeviceSettingsProto::_internal_has_kiosk_crx_manifest_update_url_ignored() const {
  bool value = (_impl_._has_bits_[3] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kiosk_crx_manifest_update_url_ignored_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_kiosk_crx_manifest_update_url_ignored() const {
  return _internal_has_kiosk_crx_manifest_update_url_ignored();
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::_internal_kiosk_crx_manifest_update_url_ignored() const {
  const ::enterprise_management::BooleanPolicyProto* p = _impl_.kiosk_crx_manifest_update_url_ignored_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BooleanPolicyProto&>(
      ::enterprise_management::_BooleanPolicyProto_default_instance_);
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::kiosk_crx_manifest_update_url_ignored() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.kiosk_crx_manifest_update_url_ignored)
  return _internal_kiosk_crx_manifest_update_url_ignored();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_kiosk_crx_manifest_update_url_ignored(
    ::enterprise_management::BooleanPolicyProto* kiosk_crx_manifest_update_url_ignored) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kiosk_crx_manifest_update_url_ignored_);
  }
  _impl_.kiosk_crx_manifest_update_url_ignored_ = kiosk_crx_manifest_update_url_ignored;
  if (kiosk_crx_manifest_update_url_ignored) {
    _impl_._has_bits_[3] |= 0x08000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.kiosk_crx_manifest_update_url_ignored)
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::release_kiosk_crx_manifest_update_url_ignored() {
  _impl_._has_bits_[3] &= ~0x08000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.kiosk_crx_manifest_update_url_ignored_;
  _impl_.kiosk_crx_manifest_update_url_ignored_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_kiosk_crx_manifest_update_url_ignored() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.kiosk_crx_manifest_update_url_ignored)
  _impl_._has_bits_[3] &= ~0x08000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.kiosk_crx_manifest_update_url_ignored_;
  _impl_.kiosk_crx_manifest_update_url_ignored_ = nullptr;
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_kiosk_crx_manifest_update_url_ignored() {
  _impl_._has_bits_[3] |= 0x08000000u;
  if (_impl_.kiosk_crx_manifest_update_url_ignored_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BooleanPolicyProto>(GetArenaForAllocation());
    _impl_.kiosk_crx_manifest_update_url_ignored_ = p;
  }
  return _impl_.kiosk_crx_manifest_update_url_ignored_;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::mutable_kiosk_crx_manifest_update_url_ignored() {
  ::enterprise_management::BooleanPolicyProto* _msg = _internal_mutable_kiosk_crx_manifest_update_url_ignored();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.kiosk_crx_manifest_update_url_ignored)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_kiosk_crx_manifest_update_url_ignored(::enterprise_management::BooleanPolicyProto* kiosk_crx_manifest_update_url_ignored) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kiosk_crx_manifest_update_url_ignored_);
  }
  if (kiosk_crx_manifest_update_url_ignored) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kiosk_crx_manifest_update_url_ignored));
    if (message_arena != submessage_arena) {
      kiosk_crx_manifest_update_url_ignored = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kiosk_crx_manifest_update_url_ignored, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x08000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x08000000u;
  }
  _impl_.kiosk_crx_manifest_update_url_ignored_ = kiosk_crx_manifest_update_url_ignored;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.kiosk_crx_manifest_update_url_ignored)
}

// optional .enterprise_management.DeviceI18nShortcutsEnabledProto device_i18n_shortcuts_enabled = 128;
inline bool ChromeDeviceSettingsProto::_internal_has_device_i18n_shortcuts_enabled() const {
  bool value = (_impl_._has_bits_[3] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_i18n_shortcuts_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_i18n_shortcuts_enabled() const {
  return _internal_has_device_i18n_shortcuts_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_i18n_shortcuts_enabled() {
  if (_impl_.device_i18n_shortcuts_enabled_ != nullptr) _impl_.device_i18n_shortcuts_enabled_->Clear();
  _impl_._has_bits_[3] &= ~0x10000000u;
}
inline const ::enterprise_management::DeviceI18nShortcutsEnabledProto& ChromeDeviceSettingsProto::_internal_device_i18n_shortcuts_enabled() const {
  const ::enterprise_management::DeviceI18nShortcutsEnabledProto* p = _impl_.device_i18n_shortcuts_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceI18nShortcutsEnabledProto&>(
      ::enterprise_management::_DeviceI18nShortcutsEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceI18nShortcutsEnabledProto& ChromeDeviceSettingsProto::device_i18n_shortcuts_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_i18n_shortcuts_enabled)
  return _internal_device_i18n_shortcuts_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_i18n_shortcuts_enabled(
    ::enterprise_management::DeviceI18nShortcutsEnabledProto* device_i18n_shortcuts_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_i18n_shortcuts_enabled_);
  }
  _impl_.device_i18n_shortcuts_enabled_ = device_i18n_shortcuts_enabled;
  if (device_i18n_shortcuts_enabled) {
    _impl_._has_bits_[3] |= 0x10000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_i18n_shortcuts_enabled)
}
inline ::enterprise_management::DeviceI18nShortcutsEnabledProto* ChromeDeviceSettingsProto::release_device_i18n_shortcuts_enabled() {
  _impl_._has_bits_[3] &= ~0x10000000u;
  ::enterprise_management::DeviceI18nShortcutsEnabledProto* temp = _impl_.device_i18n_shortcuts_enabled_;
  _impl_.device_i18n_shortcuts_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceI18nShortcutsEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_i18n_shortcuts_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_i18n_shortcuts_enabled)
  _impl_._has_bits_[3] &= ~0x10000000u;
  ::enterprise_management::DeviceI18nShortcutsEnabledProto* temp = _impl_.device_i18n_shortcuts_enabled_;
  _impl_.device_i18n_shortcuts_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceI18nShortcutsEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_i18n_shortcuts_enabled() {
  _impl_._has_bits_[3] |= 0x10000000u;
  if (_impl_.device_i18n_shortcuts_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceI18nShortcutsEnabledProto>(GetArenaForAllocation());
    _impl_.device_i18n_shortcuts_enabled_ = p;
  }
  return _impl_.device_i18n_shortcuts_enabled_;
}
inline ::enterprise_management::DeviceI18nShortcutsEnabledProto* ChromeDeviceSettingsProto::mutable_device_i18n_shortcuts_enabled() {
  ::enterprise_management::DeviceI18nShortcutsEnabledProto* _msg = _internal_mutable_device_i18n_shortcuts_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_i18n_shortcuts_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_i18n_shortcuts_enabled(::enterprise_management::DeviceI18nShortcutsEnabledProto* device_i18n_shortcuts_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_i18n_shortcuts_enabled_;
  }
  if (device_i18n_shortcuts_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_i18n_shortcuts_enabled);
    if (message_arena != submessage_arena) {
      device_i18n_shortcuts_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_i18n_shortcuts_enabled, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x10000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x10000000u;
  }
  _impl_.device_i18n_shortcuts_enabled_ = device_i18n_shortcuts_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_i18n_shortcuts_enabled)
}

// optional .enterprise_management.BooleanPolicyProto chromad_to_cloud_migration_enabled = 129;
inline bool ChromeDeviceSettingsProto::_internal_has_chromad_to_cloud_migration_enabled() const {
  bool value = (_impl_._has_bits_[3] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chromad_to_cloud_migration_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_chromad_to_cloud_migration_enabled() const {
  return _internal_has_chromad_to_cloud_migration_enabled();
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::_internal_chromad_to_cloud_migration_enabled() const {
  const ::enterprise_management::BooleanPolicyProto* p = _impl_.chromad_to_cloud_migration_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BooleanPolicyProto&>(
      ::enterprise_management::_BooleanPolicyProto_default_instance_);
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::chromad_to_cloud_migration_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.chromad_to_cloud_migration_enabled)
  return _internal_chromad_to_cloud_migration_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_chromad_to_cloud_migration_enabled(
    ::enterprise_management::BooleanPolicyProto* chromad_to_cloud_migration_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chromad_to_cloud_migration_enabled_);
  }
  _impl_.chromad_to_cloud_migration_enabled_ = chromad_to_cloud_migration_enabled;
  if (chromad_to_cloud_migration_enabled) {
    _impl_._has_bits_[3] |= 0x20000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.chromad_to_cloud_migration_enabled)
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::release_chromad_to_cloud_migration_enabled() {
  _impl_._has_bits_[3] &= ~0x20000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.chromad_to_cloud_migration_enabled_;
  _impl_.chromad_to_cloud_migration_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_chromad_to_cloud_migration_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.chromad_to_cloud_migration_enabled)
  _impl_._has_bits_[3] &= ~0x20000000u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.chromad_to_cloud_migration_enabled_;
  _impl_.chromad_to_cloud_migration_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_chromad_to_cloud_migration_enabled() {
  _impl_._has_bits_[3] |= 0x20000000u;
  if (_impl_.chromad_to_cloud_migration_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BooleanPolicyProto>(GetArenaForAllocation());
    _impl_.chromad_to_cloud_migration_enabled_ = p;
  }
  return _impl_.chromad_to_cloud_migration_enabled_;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::mutable_chromad_to_cloud_migration_enabled() {
  ::enterprise_management::BooleanPolicyProto* _msg = _internal_mutable_chromad_to_cloud_migration_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.chromad_to_cloud_migration_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_chromad_to_cloud_migration_enabled(::enterprise_management::BooleanPolicyProto* chromad_to_cloud_migration_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chromad_to_cloud_migration_enabled_);
  }
  if (chromad_to_cloud_migration_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chromad_to_cloud_migration_enabled));
    if (message_arena != submessage_arena) {
      chromad_to_cloud_migration_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chromad_to_cloud_migration_enabled, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x20000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x20000000u;
  }
  _impl_.chromad_to_cloud_migration_enabled_ = chromad_to_cloud_migration_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.chromad_to_cloud_migration_enabled)
}

// optional .enterprise_management.RevenDeviceHWDataUsageEnabledProto hardware_data_usage_enabled = 130;
inline bool ChromeDeviceSettingsProto::_internal_has_hardware_data_usage_enabled() const {
  bool value = (_impl_._has_bits_[3] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hardware_data_usage_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_hardware_data_usage_enabled() const {
  return _internal_has_hardware_data_usage_enabled();
}
inline void ChromeDeviceSettingsProto::clear_hardware_data_usage_enabled() {
  if (_impl_.hardware_data_usage_enabled_ != nullptr) _impl_.hardware_data_usage_enabled_->Clear();
  _impl_._has_bits_[3] &= ~0x40000000u;
}
inline const ::enterprise_management::RevenDeviceHWDataUsageEnabledProto& ChromeDeviceSettingsProto::_internal_hardware_data_usage_enabled() const {
  const ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* p = _impl_.hardware_data_usage_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::RevenDeviceHWDataUsageEnabledProto&>(
      ::enterprise_management::_RevenDeviceHWDataUsageEnabledProto_default_instance_);
}
inline const ::enterprise_management::RevenDeviceHWDataUsageEnabledProto& ChromeDeviceSettingsProto::hardware_data_usage_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.hardware_data_usage_enabled)
  return _internal_hardware_data_usage_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_hardware_data_usage_enabled(
    ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* hardware_data_usage_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hardware_data_usage_enabled_);
  }
  _impl_.hardware_data_usage_enabled_ = hardware_data_usage_enabled;
  if (hardware_data_usage_enabled) {
    _impl_._has_bits_[3] |= 0x40000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.hardware_data_usage_enabled)
}
inline ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* ChromeDeviceSettingsProto::release_hardware_data_usage_enabled() {
  _impl_._has_bits_[3] &= ~0x40000000u;
  ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* temp = _impl_.hardware_data_usage_enabled_;
  _impl_.hardware_data_usage_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_hardware_data_usage_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.hardware_data_usage_enabled)
  _impl_._has_bits_[3] &= ~0x40000000u;
  ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* temp = _impl_.hardware_data_usage_enabled_;
  _impl_.hardware_data_usage_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_hardware_data_usage_enabled() {
  _impl_._has_bits_[3] |= 0x40000000u;
  if (_impl_.hardware_data_usage_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::RevenDeviceHWDataUsageEnabledProto>(GetArenaForAllocation());
    _impl_.hardware_data_usage_enabled_ = p;
  }
  return _impl_.hardware_data_usage_enabled_;
}
inline ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* ChromeDeviceSettingsProto::mutable_hardware_data_usage_enabled() {
  ::enterprise_management::RevenDeviceHWDataUsageEnabledProto* _msg = _internal_mutable_hardware_data_usage_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.hardware_data_usage_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_hardware_data_usage_enabled(::enterprise_management::RevenDeviceHWDataUsageEnabledProto* hardware_data_usage_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hardware_data_usage_enabled_;
  }
  if (hardware_data_usage_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hardware_data_usage_enabled);
    if (message_arena != submessage_arena) {
      hardware_data_usage_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hardware_data_usage_enabled, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x40000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x40000000u;
  }
  _impl_.hardware_data_usage_enabled_ = hardware_data_usage_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.hardware_data_usage_enabled)
}

// optional .enterprise_management.DeviceLoginScreenWebUILazyLoadingProto login_web_ui_lazy_loading = 131;
inline bool ChromeDeviceSettingsProto::_internal_has_login_web_ui_lazy_loading() const {
  bool value = (_impl_._has_bits_[3] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_web_ui_lazy_loading_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_web_ui_lazy_loading() const {
  return _internal_has_login_web_ui_lazy_loading();
}
inline void ChromeDeviceSettingsProto::clear_login_web_ui_lazy_loading() {
  if (_impl_.login_web_ui_lazy_loading_ != nullptr) _impl_.login_web_ui_lazy_loading_->Clear();
  _impl_._has_bits_[3] &= ~0x80000000u;
}
inline const ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto& ChromeDeviceSettingsProto::_internal_login_web_ui_lazy_loading() const {
  const ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* p = _impl_.login_web_ui_lazy_loading_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto&>(
      ::enterprise_management::_DeviceLoginScreenWebUILazyLoadingProto_default_instance_);
}
inline const ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto& ChromeDeviceSettingsProto::login_web_ui_lazy_loading() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_web_ui_lazy_loading)
  return _internal_login_web_ui_lazy_loading();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_web_ui_lazy_loading(
    ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* login_web_ui_lazy_loading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_web_ui_lazy_loading_);
  }
  _impl_.login_web_ui_lazy_loading_ = login_web_ui_lazy_loading;
  if (login_web_ui_lazy_loading) {
    _impl_._has_bits_[3] |= 0x80000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_web_ui_lazy_loading)
}
inline ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* ChromeDeviceSettingsProto::release_login_web_ui_lazy_loading() {
  _impl_._has_bits_[3] &= ~0x80000000u;
  ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* temp = _impl_.login_web_ui_lazy_loading_;
  _impl_.login_web_ui_lazy_loading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_web_ui_lazy_loading() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_web_ui_lazy_loading)
  _impl_._has_bits_[3] &= ~0x80000000u;
  ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* temp = _impl_.login_web_ui_lazy_loading_;
  _impl_.login_web_ui_lazy_loading_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* ChromeDeviceSettingsProto::_internal_mutable_login_web_ui_lazy_loading() {
  _impl_._has_bits_[3] |= 0x80000000u;
  if (_impl_.login_web_ui_lazy_loading_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto>(GetArenaForAllocation());
    _impl_.login_web_ui_lazy_loading_ = p;
  }
  return _impl_.login_web_ui_lazy_loading_;
}
inline ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* ChromeDeviceSettingsProto::mutable_login_web_ui_lazy_loading() {
  ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* _msg = _internal_mutable_login_web_ui_lazy_loading();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_web_ui_lazy_loading)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_web_ui_lazy_loading(::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto* login_web_ui_lazy_loading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_web_ui_lazy_loading_;
  }
  if (login_web_ui_lazy_loading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_web_ui_lazy_loading);
    if (message_arena != submessage_arena) {
      login_web_ui_lazy_loading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_web_ui_lazy_loading, submessage_arena);
    }
    _impl_._has_bits_[3] |= 0x80000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x80000000u;
  }
  _impl_.login_web_ui_lazy_loading_ = login_web_ui_lazy_loading;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_web_ui_lazy_loading)
}

// optional .enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto keylocker_for_storage_encryption_enabled = 132;
inline bool ChromeDeviceSettingsProto::_internal_has_keylocker_for_storage_encryption_enabled() const {
  bool value = (_impl_._has_bits_[4] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keylocker_for_storage_encryption_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_keylocker_for_storage_encryption_enabled() const {
  return _internal_has_keylocker_for_storage_encryption_enabled();
}
inline void ChromeDeviceSettingsProto::clear_keylocker_for_storage_encryption_enabled() {
  if (_impl_.keylocker_for_storage_encryption_enabled_ != nullptr) _impl_.keylocker_for_storage_encryption_enabled_->Clear();
  _impl_._has_bits_[4] &= ~0x00000001u;
}
inline const ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto& ChromeDeviceSettingsProto::_internal_keylocker_for_storage_encryption_enabled() const {
  const ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* p = _impl_.keylocker_for_storage_encryption_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto&>(
      ::enterprise_management::_DeviceKeylockerForStorageEncryptionEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto& ChromeDeviceSettingsProto::keylocker_for_storage_encryption_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.keylocker_for_storage_encryption_enabled)
  return _internal_keylocker_for_storage_encryption_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_keylocker_for_storage_encryption_enabled(
    ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* keylocker_for_storage_encryption_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keylocker_for_storage_encryption_enabled_);
  }
  _impl_.keylocker_for_storage_encryption_enabled_ = keylocker_for_storage_encryption_enabled;
  if (keylocker_for_storage_encryption_enabled) {
    _impl_._has_bits_[4] |= 0x00000001u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.keylocker_for_storage_encryption_enabled)
}
inline ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* ChromeDeviceSettingsProto::release_keylocker_for_storage_encryption_enabled() {
  _impl_._has_bits_[4] &= ~0x00000001u;
  ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* temp = _impl_.keylocker_for_storage_encryption_enabled_;
  _impl_.keylocker_for_storage_encryption_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_keylocker_for_storage_encryption_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.keylocker_for_storage_encryption_enabled)
  _impl_._has_bits_[4] &= ~0x00000001u;
  ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* temp = _impl_.keylocker_for_storage_encryption_enabled_;
  _impl_.keylocker_for_storage_encryption_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_keylocker_for_storage_encryption_enabled() {
  _impl_._has_bits_[4] |= 0x00000001u;
  if (_impl_.keylocker_for_storage_encryption_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto>(GetArenaForAllocation());
    _impl_.keylocker_for_storage_encryption_enabled_ = p;
  }
  return _impl_.keylocker_for_storage_encryption_enabled_;
}
inline ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* ChromeDeviceSettingsProto::mutable_keylocker_for_storage_encryption_enabled() {
  ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* _msg = _internal_mutable_keylocker_for_storage_encryption_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.keylocker_for_storage_encryption_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_keylocker_for_storage_encryption_enabled(::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto* keylocker_for_storage_encryption_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keylocker_for_storage_encryption_enabled_;
  }
  if (keylocker_for_storage_encryption_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keylocker_for_storage_encryption_enabled);
    if (message_arena != submessage_arena) {
      keylocker_for_storage_encryption_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keylocker_for_storage_encryption_enabled, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000001u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000001u;
  }
  _impl_.keylocker_for_storage_encryption_enabled_ = keylocker_for_storage_encryption_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.keylocker_for_storage_encryption_enabled)
}

// optional .enterprise_management.BooleanPolicyProto device_run_automatic_cleanup_on_login = 133;
inline bool ChromeDeviceSettingsProto::_internal_has_device_run_automatic_cleanup_on_login() const {
  bool value = (_impl_._has_bits_[4] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_run_automatic_cleanup_on_login_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_run_automatic_cleanup_on_login() const {
  return _internal_has_device_run_automatic_cleanup_on_login();
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::_internal_device_run_automatic_cleanup_on_login() const {
  const ::enterprise_management::BooleanPolicyProto* p = _impl_.device_run_automatic_cleanup_on_login_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BooleanPolicyProto&>(
      ::enterprise_management::_BooleanPolicyProto_default_instance_);
}
inline const ::enterprise_management::BooleanPolicyProto& ChromeDeviceSettingsProto::device_run_automatic_cleanup_on_login() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_run_automatic_cleanup_on_login)
  return _internal_device_run_automatic_cleanup_on_login();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_run_automatic_cleanup_on_login(
    ::enterprise_management::BooleanPolicyProto* device_run_automatic_cleanup_on_login) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_run_automatic_cleanup_on_login_);
  }
  _impl_.device_run_automatic_cleanup_on_login_ = device_run_automatic_cleanup_on_login;
  if (device_run_automatic_cleanup_on_login) {
    _impl_._has_bits_[4] |= 0x00000002u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_run_automatic_cleanup_on_login)
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::release_device_run_automatic_cleanup_on_login() {
  _impl_._has_bits_[4] &= ~0x00000002u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.device_run_automatic_cleanup_on_login_;
  _impl_.device_run_automatic_cleanup_on_login_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_run_automatic_cleanup_on_login() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_run_automatic_cleanup_on_login)
  _impl_._has_bits_[4] &= ~0x00000002u;
  ::enterprise_management::BooleanPolicyProto* temp = _impl_.device_run_automatic_cleanup_on_login_;
  _impl_.device_run_automatic_cleanup_on_login_ = nullptr;
  return temp;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_run_automatic_cleanup_on_login() {
  _impl_._has_bits_[4] |= 0x00000002u;
  if (_impl_.device_run_automatic_cleanup_on_login_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BooleanPolicyProto>(GetArenaForAllocation());
    _impl_.device_run_automatic_cleanup_on_login_ = p;
  }
  return _impl_.device_run_automatic_cleanup_on_login_;
}
inline ::enterprise_management::BooleanPolicyProto* ChromeDeviceSettingsProto::mutable_device_run_automatic_cleanup_on_login() {
  ::enterprise_management::BooleanPolicyProto* _msg = _internal_mutable_device_run_automatic_cleanup_on_login();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_run_automatic_cleanup_on_login)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_run_automatic_cleanup_on_login(::enterprise_management::BooleanPolicyProto* device_run_automatic_cleanup_on_login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_run_automatic_cleanup_on_login_);
  }
  if (device_run_automatic_cleanup_on_login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_run_automatic_cleanup_on_login));
    if (message_arena != submessage_arena) {
      device_run_automatic_cleanup_on_login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_run_automatic_cleanup_on_login, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000002u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000002u;
  }
  _impl_.device_run_automatic_cleanup_on_login_ = device_run_automatic_cleanup_on_login;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_run_automatic_cleanup_on_login)
}

// optional .enterprise_management.EncryptedReportingPipelineConfigurationProto device_encrypted_reporting_pipeline_enabled = 134;
inline bool ChromeDeviceSettingsProto::_internal_has_device_encrypted_reporting_pipeline_enabled() const {
  bool value = (_impl_._has_bits_[4] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_encrypted_reporting_pipeline_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_encrypted_reporting_pipeline_enabled() const {
  return _internal_has_device_encrypted_reporting_pipeline_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_encrypted_reporting_pipeline_enabled() {
  if (_impl_.device_encrypted_reporting_pipeline_enabled_ != nullptr) _impl_.device_encrypted_reporting_pipeline_enabled_->Clear();
  _impl_._has_bits_[4] &= ~0x00000004u;
}
inline const ::enterprise_management::EncryptedReportingPipelineConfigurationProto& ChromeDeviceSettingsProto::_internal_device_encrypted_reporting_pipeline_enabled() const {
  const ::enterprise_management::EncryptedReportingPipelineConfigurationProto* p = _impl_.device_encrypted_reporting_pipeline_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::EncryptedReportingPipelineConfigurationProto&>(
      ::enterprise_management::_EncryptedReportingPipelineConfigurationProto_default_instance_);
}
inline const ::enterprise_management::EncryptedReportingPipelineConfigurationProto& ChromeDeviceSettingsProto::device_encrypted_reporting_pipeline_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_encrypted_reporting_pipeline_enabled)
  return _internal_device_encrypted_reporting_pipeline_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_encrypted_reporting_pipeline_enabled(
    ::enterprise_management::EncryptedReportingPipelineConfigurationProto* device_encrypted_reporting_pipeline_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_encrypted_reporting_pipeline_enabled_);
  }
  _impl_.device_encrypted_reporting_pipeline_enabled_ = device_encrypted_reporting_pipeline_enabled;
  if (device_encrypted_reporting_pipeline_enabled) {
    _impl_._has_bits_[4] |= 0x00000004u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_encrypted_reporting_pipeline_enabled)
}
inline ::enterprise_management::EncryptedReportingPipelineConfigurationProto* ChromeDeviceSettingsProto::release_device_encrypted_reporting_pipeline_enabled() {
  _impl_._has_bits_[4] &= ~0x00000004u;
  ::enterprise_management::EncryptedReportingPipelineConfigurationProto* temp = _impl_.device_encrypted_reporting_pipeline_enabled_;
  _impl_.device_encrypted_reporting_pipeline_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::EncryptedReportingPipelineConfigurationProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_encrypted_reporting_pipeline_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_encrypted_reporting_pipeline_enabled)
  _impl_._has_bits_[4] &= ~0x00000004u;
  ::enterprise_management::EncryptedReportingPipelineConfigurationProto* temp = _impl_.device_encrypted_reporting_pipeline_enabled_;
  _impl_.device_encrypted_reporting_pipeline_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::EncryptedReportingPipelineConfigurationProto* ChromeDeviceSettingsProto::_internal_mutable_device_encrypted_reporting_pipeline_enabled() {
  _impl_._has_bits_[4] |= 0x00000004u;
  if (_impl_.device_encrypted_reporting_pipeline_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::EncryptedReportingPipelineConfigurationProto>(GetArenaForAllocation());
    _impl_.device_encrypted_reporting_pipeline_enabled_ = p;
  }
  return _impl_.device_encrypted_reporting_pipeline_enabled_;
}
inline ::enterprise_management::EncryptedReportingPipelineConfigurationProto* ChromeDeviceSettingsProto::mutable_device_encrypted_reporting_pipeline_enabled() {
  ::enterprise_management::EncryptedReportingPipelineConfigurationProto* _msg = _internal_mutable_device_encrypted_reporting_pipeline_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_encrypted_reporting_pipeline_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_encrypted_reporting_pipeline_enabled(::enterprise_management::EncryptedReportingPipelineConfigurationProto* device_encrypted_reporting_pipeline_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_encrypted_reporting_pipeline_enabled_;
  }
  if (device_encrypted_reporting_pipeline_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_encrypted_reporting_pipeline_enabled);
    if (message_arena != submessage_arena) {
      device_encrypted_reporting_pipeline_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_encrypted_reporting_pipeline_enabled, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000004u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000004u;
  }
  _impl_.device_encrypted_reporting_pipeline_enabled_ = device_encrypted_reporting_pipeline_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_encrypted_reporting_pipeline_enabled)
}

// optional .enterprise_management.SAMLUsernameProto saml_username = 135;
inline bool ChromeDeviceSettingsProto::_internal_has_saml_username() const {
  bool value = (_impl_._has_bits_[4] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.saml_username_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_saml_username() const {
  return _internal_has_saml_username();
}
inline void ChromeDeviceSettingsProto::clear_saml_username() {
  if (_impl_.saml_username_ != nullptr) _impl_.saml_username_->Clear();
  _impl_._has_bits_[4] &= ~0x00000008u;
}
inline const ::enterprise_management::SAMLUsernameProto& ChromeDeviceSettingsProto::_internal_saml_username() const {
  const ::enterprise_management::SAMLUsernameProto* p = _impl_.saml_username_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SAMLUsernameProto&>(
      ::enterprise_management::_SAMLUsernameProto_default_instance_);
}
inline const ::enterprise_management::SAMLUsernameProto& ChromeDeviceSettingsProto::saml_username() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.saml_username)
  return _internal_saml_username();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_saml_username(
    ::enterprise_management::SAMLUsernameProto* saml_username) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.saml_username_);
  }
  _impl_.saml_username_ = saml_username;
  if (saml_username) {
    _impl_._has_bits_[4] |= 0x00000008u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.saml_username)
}
inline ::enterprise_management::SAMLUsernameProto* ChromeDeviceSettingsProto::release_saml_username() {
  _impl_._has_bits_[4] &= ~0x00000008u;
  ::enterprise_management::SAMLUsernameProto* temp = _impl_.saml_username_;
  _impl_.saml_username_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SAMLUsernameProto* ChromeDeviceSettingsProto::unsafe_arena_release_saml_username() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.saml_username)
  _impl_._has_bits_[4] &= ~0x00000008u;
  ::enterprise_management::SAMLUsernameProto* temp = _impl_.saml_username_;
  _impl_.saml_username_ = nullptr;
  return temp;
}
inline ::enterprise_management::SAMLUsernameProto* ChromeDeviceSettingsProto::_internal_mutable_saml_username() {
  _impl_._has_bits_[4] |= 0x00000008u;
  if (_impl_.saml_username_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SAMLUsernameProto>(GetArenaForAllocation());
    _impl_.saml_username_ = p;
  }
  return _impl_.saml_username_;
}
inline ::enterprise_management::SAMLUsernameProto* ChromeDeviceSettingsProto::mutable_saml_username() {
  ::enterprise_management::SAMLUsernameProto* _msg = _internal_mutable_saml_username();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.saml_username)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_saml_username(::enterprise_management::SAMLUsernameProto* saml_username) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.saml_username_;
  }
  if (saml_username) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saml_username);
    if (message_arena != submessage_arena) {
      saml_username = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saml_username, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000008u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000008u;
  }
  _impl_.saml_username_ = saml_username;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.saml_username)
}

// optional .enterprise_management.StringListPolicyProto device_login_screen_context_aware_access_signals_allowlist = 136;
inline bool ChromeDeviceSettingsProto::_internal_has_device_login_screen_context_aware_access_signals_allowlist() const {
  bool value = (_impl_._has_bits_[4] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_login_screen_context_aware_access_signals_allowlist_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_login_screen_context_aware_access_signals_allowlist() const {
  return _internal_has_device_login_screen_context_aware_access_signals_allowlist();
}
inline const ::enterprise_management::StringListPolicyProto& ChromeDeviceSettingsProto::_internal_device_login_screen_context_aware_access_signals_allowlist() const {
  const ::enterprise_management::StringListPolicyProto* p = _impl_.device_login_screen_context_aware_access_signals_allowlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::StringListPolicyProto&>(
      ::enterprise_management::_StringListPolicyProto_default_instance_);
}
inline const ::enterprise_management::StringListPolicyProto& ChromeDeviceSettingsProto::device_login_screen_context_aware_access_signals_allowlist() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_context_aware_access_signals_allowlist)
  return _internal_device_login_screen_context_aware_access_signals_allowlist();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_login_screen_context_aware_access_signals_allowlist(
    ::enterprise_management::StringListPolicyProto* device_login_screen_context_aware_access_signals_allowlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_context_aware_access_signals_allowlist_);
  }
  _impl_.device_login_screen_context_aware_access_signals_allowlist_ = device_login_screen_context_aware_access_signals_allowlist;
  if (device_login_screen_context_aware_access_signals_allowlist) {
    _impl_._has_bits_[4] |= 0x00000010u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_context_aware_access_signals_allowlist)
}
inline ::enterprise_management::StringListPolicyProto* ChromeDeviceSettingsProto::release_device_login_screen_context_aware_access_signals_allowlist() {
  _impl_._has_bits_[4] &= ~0x00000010u;
  ::enterprise_management::StringListPolicyProto* temp = _impl_.device_login_screen_context_aware_access_signals_allowlist_;
  _impl_.device_login_screen_context_aware_access_signals_allowlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::StringListPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_login_screen_context_aware_access_signals_allowlist() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_context_aware_access_signals_allowlist)
  _impl_._has_bits_[4] &= ~0x00000010u;
  ::enterprise_management::StringListPolicyProto* temp = _impl_.device_login_screen_context_aware_access_signals_allowlist_;
  _impl_.device_login_screen_context_aware_access_signals_allowlist_ = nullptr;
  return temp;
}
inline ::enterprise_management::StringListPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_login_screen_context_aware_access_signals_allowlist() {
  _impl_._has_bits_[4] |= 0x00000010u;
  if (_impl_.device_login_screen_context_aware_access_signals_allowlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::StringListPolicyProto>(GetArenaForAllocation());
    _impl_.device_login_screen_context_aware_access_signals_allowlist_ = p;
  }
  return _impl_.device_login_screen_context_aware_access_signals_allowlist_;
}
inline ::enterprise_management::StringListPolicyProto* ChromeDeviceSettingsProto::mutable_device_login_screen_context_aware_access_signals_allowlist() {
  ::enterprise_management::StringListPolicyProto* _msg = _internal_mutable_device_login_screen_context_aware_access_signals_allowlist();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_context_aware_access_signals_allowlist)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_login_screen_context_aware_access_signals_allowlist(::enterprise_management::StringListPolicyProto* device_login_screen_context_aware_access_signals_allowlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_login_screen_context_aware_access_signals_allowlist_);
  }
  if (device_login_screen_context_aware_access_signals_allowlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_login_screen_context_aware_access_signals_allowlist));
    if (message_arena != submessage_arena) {
      device_login_screen_context_aware_access_signals_allowlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_login_screen_context_aware_access_signals_allowlist, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000010u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000010u;
  }
  _impl_.device_login_screen_context_aware_access_signals_allowlist_ = device_login_screen_context_aware_access_signals_allowlist;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_login_screen_context_aware_access_signals_allowlist)
}

// optional .enterprise_management.StringPolicyProto device_printing_client_name_template = 137;
inline bool ChromeDeviceSettingsProto::_internal_has_device_printing_client_name_template() const {
  bool value = (_impl_._has_bits_[4] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_printing_client_name_template_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_printing_client_name_template() const {
  return _internal_has_device_printing_client_name_template();
}
inline const ::enterprise_management::StringPolicyProto& ChromeDeviceSettingsProto::_internal_device_printing_client_name_template() const {
  const ::enterprise_management::StringPolicyProto* p = _impl_.device_printing_client_name_template_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::StringPolicyProto&>(
      ::enterprise_management::_StringPolicyProto_default_instance_);
}
inline const ::enterprise_management::StringPolicyProto& ChromeDeviceSettingsProto::device_printing_client_name_template() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_printing_client_name_template)
  return _internal_device_printing_client_name_template();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_printing_client_name_template(
    ::enterprise_management::StringPolicyProto* device_printing_client_name_template) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_printing_client_name_template_);
  }
  _impl_.device_printing_client_name_template_ = device_printing_client_name_template;
  if (device_printing_client_name_template) {
    _impl_._has_bits_[4] |= 0x00000020u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printing_client_name_template)
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::release_device_printing_client_name_template() {
  _impl_._has_bits_[4] &= ~0x00000020u;
  ::enterprise_management::StringPolicyProto* temp = _impl_.device_printing_client_name_template_;
  _impl_.device_printing_client_name_template_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_printing_client_name_template() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_printing_client_name_template)
  _impl_._has_bits_[4] &= ~0x00000020u;
  ::enterprise_management::StringPolicyProto* temp = _impl_.device_printing_client_name_template_;
  _impl_.device_printing_client_name_template_ = nullptr;
  return temp;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::_internal_mutable_device_printing_client_name_template() {
  _impl_._has_bits_[4] |= 0x00000020u;
  if (_impl_.device_printing_client_name_template_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::StringPolicyProto>(GetArenaForAllocation());
    _impl_.device_printing_client_name_template_ = p;
  }
  return _impl_.device_printing_client_name_template_;
}
inline ::enterprise_management::StringPolicyProto* ChromeDeviceSettingsProto::mutable_device_printing_client_name_template() {
  ::enterprise_management::StringPolicyProto* _msg = _internal_mutable_device_printing_client_name_template();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_printing_client_name_template)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_printing_client_name_template(::enterprise_management::StringPolicyProto* device_printing_client_name_template) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_printing_client_name_template_);
  }
  if (device_printing_client_name_template) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_printing_client_name_template));
    if (message_arena != submessage_arena) {
      device_printing_client_name_template = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_printing_client_name_template, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000020u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000020u;
  }
  _impl_.device_printing_client_name_template_ = device_printing_client_name_template;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_printing_client_name_template)
}

// optional .enterprise_management.DeviceReportXDREventsProto device_report_xdr_events = 138;
inline bool ChromeDeviceSettingsProto::_internal_has_device_report_xdr_events() const {
  bool value = (_impl_._has_bits_[4] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_report_xdr_events_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_report_xdr_events() const {
  return _internal_has_device_report_xdr_events();
}
inline void ChromeDeviceSettingsProto::clear_device_report_xdr_events() {
  if (_impl_.device_report_xdr_events_ != nullptr) _impl_.device_report_xdr_events_->Clear();
  _impl_._has_bits_[4] &= ~0x00000040u;
}
inline const ::enterprise_management::DeviceReportXDREventsProto& ChromeDeviceSettingsProto::_internal_device_report_xdr_events() const {
  const ::enterprise_management::DeviceReportXDREventsProto* p = _impl_.device_report_xdr_events_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceReportXDREventsProto&>(
      ::enterprise_management::_DeviceReportXDREventsProto_default_instance_);
}
inline const ::enterprise_management::DeviceReportXDREventsProto& ChromeDeviceSettingsProto::device_report_xdr_events() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_report_xdr_events)
  return _internal_device_report_xdr_events();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_report_xdr_events(
    ::enterprise_management::DeviceReportXDREventsProto* device_report_xdr_events) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_report_xdr_events_);
  }
  _impl_.device_report_xdr_events_ = device_report_xdr_events;
  if (device_report_xdr_events) {
    _impl_._has_bits_[4] |= 0x00000040u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_report_xdr_events)
}
inline ::enterprise_management::DeviceReportXDREventsProto* ChromeDeviceSettingsProto::release_device_report_xdr_events() {
  _impl_._has_bits_[4] &= ~0x00000040u;
  ::enterprise_management::DeviceReportXDREventsProto* temp = _impl_.device_report_xdr_events_;
  _impl_.device_report_xdr_events_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceReportXDREventsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_report_xdr_events() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_report_xdr_events)
  _impl_._has_bits_[4] &= ~0x00000040u;
  ::enterprise_management::DeviceReportXDREventsProto* temp = _impl_.device_report_xdr_events_;
  _impl_.device_report_xdr_events_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceReportXDREventsProto* ChromeDeviceSettingsProto::_internal_mutable_device_report_xdr_events() {
  _impl_._has_bits_[4] |= 0x00000040u;
  if (_impl_.device_report_xdr_events_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceReportXDREventsProto>(GetArenaForAllocation());
    _impl_.device_report_xdr_events_ = p;
  }
  return _impl_.device_report_xdr_events_;
}
inline ::enterprise_management::DeviceReportXDREventsProto* ChromeDeviceSettingsProto::mutable_device_report_xdr_events() {
  ::enterprise_management::DeviceReportXDREventsProto* _msg = _internal_mutable_device_report_xdr_events();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_report_xdr_events)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_report_xdr_events(::enterprise_management::DeviceReportXDREventsProto* device_report_xdr_events) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_report_xdr_events_;
  }
  if (device_report_xdr_events) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_report_xdr_events);
    if (message_arena != submessage_arena) {
      device_report_xdr_events = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_report_xdr_events, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000040u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000040u;
  }
  _impl_.device_report_xdr_events_ = device_report_xdr_events;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_report_xdr_events)
}

// optional .enterprise_management.KeyboardBacklightColorProto keyboard_backlight_color = 139;
inline bool ChromeDeviceSettingsProto::_internal_has_keyboard_backlight_color() const {
  bool value = (_impl_._has_bits_[4] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keyboard_backlight_color_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_keyboard_backlight_color() const {
  return _internal_has_keyboard_backlight_color();
}
inline void ChromeDeviceSettingsProto::clear_keyboard_backlight_color() {
  if (_impl_.keyboard_backlight_color_ != nullptr) _impl_.keyboard_backlight_color_->Clear();
  _impl_._has_bits_[4] &= ~0x00000080u;
}
inline const ::enterprise_management::KeyboardBacklightColorProto& ChromeDeviceSettingsProto::_internal_keyboard_backlight_color() const {
  const ::enterprise_management::KeyboardBacklightColorProto* p = _impl_.keyboard_backlight_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::KeyboardBacklightColorProto&>(
      ::enterprise_management::_KeyboardBacklightColorProto_default_instance_);
}
inline const ::enterprise_management::KeyboardBacklightColorProto& ChromeDeviceSettingsProto::keyboard_backlight_color() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.keyboard_backlight_color)
  return _internal_keyboard_backlight_color();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_keyboard_backlight_color(
    ::enterprise_management::KeyboardBacklightColorProto* keyboard_backlight_color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keyboard_backlight_color_);
  }
  _impl_.keyboard_backlight_color_ = keyboard_backlight_color;
  if (keyboard_backlight_color) {
    _impl_._has_bits_[4] |= 0x00000080u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.keyboard_backlight_color)
}
inline ::enterprise_management::KeyboardBacklightColorProto* ChromeDeviceSettingsProto::release_keyboard_backlight_color() {
  _impl_._has_bits_[4] &= ~0x00000080u;
  ::enterprise_management::KeyboardBacklightColorProto* temp = _impl_.keyboard_backlight_color_;
  _impl_.keyboard_backlight_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::KeyboardBacklightColorProto* ChromeDeviceSettingsProto::unsafe_arena_release_keyboard_backlight_color() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.keyboard_backlight_color)
  _impl_._has_bits_[4] &= ~0x00000080u;
  ::enterprise_management::KeyboardBacklightColorProto* temp = _impl_.keyboard_backlight_color_;
  _impl_.keyboard_backlight_color_ = nullptr;
  return temp;
}
inline ::enterprise_management::KeyboardBacklightColorProto* ChromeDeviceSettingsProto::_internal_mutable_keyboard_backlight_color() {
  _impl_._has_bits_[4] |= 0x00000080u;
  if (_impl_.keyboard_backlight_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::KeyboardBacklightColorProto>(GetArenaForAllocation());
    _impl_.keyboard_backlight_color_ = p;
  }
  return _impl_.keyboard_backlight_color_;
}
inline ::enterprise_management::KeyboardBacklightColorProto* ChromeDeviceSettingsProto::mutable_keyboard_backlight_color() {
  ::enterprise_management::KeyboardBacklightColorProto* _msg = _internal_mutable_keyboard_backlight_color();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.keyboard_backlight_color)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_keyboard_backlight_color(::enterprise_management::KeyboardBacklightColorProto* keyboard_backlight_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keyboard_backlight_color_;
  }
  if (keyboard_backlight_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keyboard_backlight_color);
    if (message_arena != submessage_arena) {
      keyboard_backlight_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keyboard_backlight_color, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000080u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000080u;
  }
  _impl_.keyboard_backlight_color_ = keyboard_backlight_color;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.keyboard_backlight_color)
}

// optional .enterprise_management.DeviceHindiInscriptLayoutEnabledProto device_hindi_inscript_layout_enabled = 140;
inline bool ChromeDeviceSettingsProto::_internal_has_device_hindi_inscript_layout_enabled() const {
  bool value = (_impl_._has_bits_[4] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_hindi_inscript_layout_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_hindi_inscript_layout_enabled() const {
  return _internal_has_device_hindi_inscript_layout_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_hindi_inscript_layout_enabled() {
  if (_impl_.device_hindi_inscript_layout_enabled_ != nullptr) _impl_.device_hindi_inscript_layout_enabled_->Clear();
  _impl_._has_bits_[4] &= ~0x00000100u;
}
inline const ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto& ChromeDeviceSettingsProto::_internal_device_hindi_inscript_layout_enabled() const {
  const ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* p = _impl_.device_hindi_inscript_layout_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto&>(
      ::enterprise_management::_DeviceHindiInscriptLayoutEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto& ChromeDeviceSettingsProto::device_hindi_inscript_layout_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_hindi_inscript_layout_enabled)
  return _internal_device_hindi_inscript_layout_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_hindi_inscript_layout_enabled(
    ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* device_hindi_inscript_layout_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_hindi_inscript_layout_enabled_);
  }
  _impl_.device_hindi_inscript_layout_enabled_ = device_hindi_inscript_layout_enabled;
  if (device_hindi_inscript_layout_enabled) {
    _impl_._has_bits_[4] |= 0x00000100u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_hindi_inscript_layout_enabled)
}
inline ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* ChromeDeviceSettingsProto::release_device_hindi_inscript_layout_enabled() {
  _impl_._has_bits_[4] &= ~0x00000100u;
  ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* temp = _impl_.device_hindi_inscript_layout_enabled_;
  _impl_.device_hindi_inscript_layout_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_hindi_inscript_layout_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_hindi_inscript_layout_enabled)
  _impl_._has_bits_[4] &= ~0x00000100u;
  ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* temp = _impl_.device_hindi_inscript_layout_enabled_;
  _impl_.device_hindi_inscript_layout_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_hindi_inscript_layout_enabled() {
  _impl_._has_bits_[4] |= 0x00000100u;
  if (_impl_.device_hindi_inscript_layout_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceHindiInscriptLayoutEnabledProto>(GetArenaForAllocation());
    _impl_.device_hindi_inscript_layout_enabled_ = p;
  }
  return _impl_.device_hindi_inscript_layout_enabled_;
}
inline ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* ChromeDeviceSettingsProto::mutable_device_hindi_inscript_layout_enabled() {
  ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* _msg = _internal_mutable_device_hindi_inscript_layout_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_hindi_inscript_layout_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_hindi_inscript_layout_enabled(::enterprise_management::DeviceHindiInscriptLayoutEnabledProto* device_hindi_inscript_layout_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_hindi_inscript_layout_enabled_;
  }
  if (device_hindi_inscript_layout_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_hindi_inscript_layout_enabled);
    if (message_arena != submessage_arena) {
      device_hindi_inscript_layout_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_hindi_inscript_layout_enabled, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000100u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000100u;
  }
  _impl_.device_hindi_inscript_layout_enabled_ = device_hindi_inscript_layout_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_hindi_inscript_layout_enabled)
}

// optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto login_screen_extension_manifest_v2_availability = 141;
inline bool ChromeDeviceSettingsProto::_internal_has_login_screen_extension_manifest_v2_availability() const {
  bool value = (_impl_._has_bits_[4] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.login_screen_extension_manifest_v2_availability_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_login_screen_extension_manifest_v2_availability() const {
  return _internal_has_login_screen_extension_manifest_v2_availability();
}
inline void ChromeDeviceSettingsProto::clear_login_screen_extension_manifest_v2_availability() {
  if (_impl_.login_screen_extension_manifest_v2_availability_ != nullptr) _impl_.login_screen_extension_manifest_v2_availability_->Clear();
  _impl_._has_bits_[4] &= ~0x00000200u;
}
inline const ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto& ChromeDeviceSettingsProto::_internal_login_screen_extension_manifest_v2_availability() const {
  const ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* p = _impl_.login_screen_extension_manifest_v2_availability_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto&>(
      ::enterprise_management::_LoginScreenExtensionManifestV2AvailabilityProto_default_instance_);
}
inline const ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto& ChromeDeviceSettingsProto::login_screen_extension_manifest_v2_availability() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.login_screen_extension_manifest_v2_availability)
  return _internal_login_screen_extension_manifest_v2_availability();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_login_screen_extension_manifest_v2_availability(
    ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* login_screen_extension_manifest_v2_availability) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_screen_extension_manifest_v2_availability_);
  }
  _impl_.login_screen_extension_manifest_v2_availability_ = login_screen_extension_manifest_v2_availability;
  if (login_screen_extension_manifest_v2_availability) {
    _impl_._has_bits_[4] |= 0x00000200u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_extension_manifest_v2_availability)
}
inline ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* ChromeDeviceSettingsProto::release_login_screen_extension_manifest_v2_availability() {
  _impl_._has_bits_[4] &= ~0x00000200u;
  ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* temp = _impl_.login_screen_extension_manifest_v2_availability_;
  _impl_.login_screen_extension_manifest_v2_availability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* ChromeDeviceSettingsProto::unsafe_arena_release_login_screen_extension_manifest_v2_availability() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.login_screen_extension_manifest_v2_availability)
  _impl_._has_bits_[4] &= ~0x00000200u;
  ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* temp = _impl_.login_screen_extension_manifest_v2_availability_;
  _impl_.login_screen_extension_manifest_v2_availability_ = nullptr;
  return temp;
}
inline ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* ChromeDeviceSettingsProto::_internal_mutable_login_screen_extension_manifest_v2_availability() {
  _impl_._has_bits_[4] |= 0x00000200u;
  if (_impl_.login_screen_extension_manifest_v2_availability_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto>(GetArenaForAllocation());
    _impl_.login_screen_extension_manifest_v2_availability_ = p;
  }
  return _impl_.login_screen_extension_manifest_v2_availability_;
}
inline ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* ChromeDeviceSettingsProto::mutable_login_screen_extension_manifest_v2_availability() {
  ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* _msg = _internal_mutable_login_screen_extension_manifest_v2_availability();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.login_screen_extension_manifest_v2_availability)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_login_screen_extension_manifest_v2_availability(::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto* login_screen_extension_manifest_v2_availability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_screen_extension_manifest_v2_availability_;
  }
  if (login_screen_extension_manifest_v2_availability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_screen_extension_manifest_v2_availability);
    if (message_arena != submessage_arena) {
      login_screen_extension_manifest_v2_availability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_screen_extension_manifest_v2_availability, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000200u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000200u;
  }
  _impl_.login_screen_extension_manifest_v2_availability_ = login_screen_extension_manifest_v2_availability;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.login_screen_extension_manifest_v2_availability)
}

// optional .enterprise_management.DeviceScreensaverEnabledProto device_screensaver_enabled = 142;
inline bool ChromeDeviceSettingsProto::_internal_has_device_screensaver_enabled() const {
  bool value = (_impl_._has_bits_[4] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_screensaver_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_screensaver_enabled() const {
  return _internal_has_device_screensaver_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_screensaver_enabled() {
  if (_impl_.device_screensaver_enabled_ != nullptr) _impl_.device_screensaver_enabled_->Clear();
  _impl_._has_bits_[4] &= ~0x00000400u;
}
inline const ::enterprise_management::DeviceScreensaverEnabledProto& ChromeDeviceSettingsProto::_internal_device_screensaver_enabled() const {
  const ::enterprise_management::DeviceScreensaverEnabledProto* p = _impl_.device_screensaver_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceScreensaverEnabledProto&>(
      ::enterprise_management::_DeviceScreensaverEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceScreensaverEnabledProto& ChromeDeviceSettingsProto::device_screensaver_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_enabled)
  return _internal_device_screensaver_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_screensaver_enabled(
    ::enterprise_management::DeviceScreensaverEnabledProto* device_screensaver_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_screensaver_enabled_);
  }
  _impl_.device_screensaver_enabled_ = device_screensaver_enabled;
  if (device_screensaver_enabled) {
    _impl_._has_bits_[4] |= 0x00000400u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_enabled)
}
inline ::enterprise_management::DeviceScreensaverEnabledProto* ChromeDeviceSettingsProto::release_device_screensaver_enabled() {
  _impl_._has_bits_[4] &= ~0x00000400u;
  ::enterprise_management::DeviceScreensaverEnabledProto* temp = _impl_.device_screensaver_enabled_;
  _impl_.device_screensaver_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceScreensaverEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_screensaver_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_enabled)
  _impl_._has_bits_[4] &= ~0x00000400u;
  ::enterprise_management::DeviceScreensaverEnabledProto* temp = _impl_.device_screensaver_enabled_;
  _impl_.device_screensaver_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceScreensaverEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_screensaver_enabled() {
  _impl_._has_bits_[4] |= 0x00000400u;
  if (_impl_.device_screensaver_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceScreensaverEnabledProto>(GetArenaForAllocation());
    _impl_.device_screensaver_enabled_ = p;
  }
  return _impl_.device_screensaver_enabled_;
}
inline ::enterprise_management::DeviceScreensaverEnabledProto* ChromeDeviceSettingsProto::mutable_device_screensaver_enabled() {
  ::enterprise_management::DeviceScreensaverEnabledProto* _msg = _internal_mutable_device_screensaver_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_screensaver_enabled(::enterprise_management::DeviceScreensaverEnabledProto* device_screensaver_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_screensaver_enabled_;
  }
  if (device_screensaver_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_screensaver_enabled);
    if (message_arena != submessage_arena) {
      device_screensaver_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_screensaver_enabled, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000400u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000400u;
  }
  _impl_.device_screensaver_enabled_ = device_screensaver_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_enabled)
}

// optional .enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto device_screensaver_idle_timeout_seconds = 143;
inline bool ChromeDeviceSettingsProto::_internal_has_device_screensaver_idle_timeout_seconds() const {
  bool value = (_impl_._has_bits_[4] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_screensaver_idle_timeout_seconds_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_screensaver_idle_timeout_seconds() const {
  return _internal_has_device_screensaver_idle_timeout_seconds();
}
inline void ChromeDeviceSettingsProto::clear_device_screensaver_idle_timeout_seconds() {
  if (_impl_.device_screensaver_idle_timeout_seconds_ != nullptr) _impl_.device_screensaver_idle_timeout_seconds_->Clear();
  _impl_._has_bits_[4] &= ~0x00000800u;
}
inline const ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto& ChromeDeviceSettingsProto::_internal_device_screensaver_idle_timeout_seconds() const {
  const ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* p = _impl_.device_screensaver_idle_timeout_seconds_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto&>(
      ::enterprise_management::_DeviceScreensaverIdleTimeoutSecondsProto_default_instance_);
}
inline const ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto& ChromeDeviceSettingsProto::device_screensaver_idle_timeout_seconds() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_idle_timeout_seconds)
  return _internal_device_screensaver_idle_timeout_seconds();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_screensaver_idle_timeout_seconds(
    ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* device_screensaver_idle_timeout_seconds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_screensaver_idle_timeout_seconds_);
  }
  _impl_.device_screensaver_idle_timeout_seconds_ = device_screensaver_idle_timeout_seconds;
  if (device_screensaver_idle_timeout_seconds) {
    _impl_._has_bits_[4] |= 0x00000800u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_idle_timeout_seconds)
}
inline ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* ChromeDeviceSettingsProto::release_device_screensaver_idle_timeout_seconds() {
  _impl_._has_bits_[4] &= ~0x00000800u;
  ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* temp = _impl_.device_screensaver_idle_timeout_seconds_;
  _impl_.device_screensaver_idle_timeout_seconds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_screensaver_idle_timeout_seconds() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_idle_timeout_seconds)
  _impl_._has_bits_[4] &= ~0x00000800u;
  ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* temp = _impl_.device_screensaver_idle_timeout_seconds_;
  _impl_.device_screensaver_idle_timeout_seconds_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* ChromeDeviceSettingsProto::_internal_mutable_device_screensaver_idle_timeout_seconds() {
  _impl_._has_bits_[4] |= 0x00000800u;
  if (_impl_.device_screensaver_idle_timeout_seconds_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto>(GetArenaForAllocation());
    _impl_.device_screensaver_idle_timeout_seconds_ = p;
  }
  return _impl_.device_screensaver_idle_timeout_seconds_;
}
inline ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* ChromeDeviceSettingsProto::mutable_device_screensaver_idle_timeout_seconds() {
  ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* _msg = _internal_mutable_device_screensaver_idle_timeout_seconds();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_idle_timeout_seconds)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_screensaver_idle_timeout_seconds(::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto* device_screensaver_idle_timeout_seconds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_screensaver_idle_timeout_seconds_;
  }
  if (device_screensaver_idle_timeout_seconds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_screensaver_idle_timeout_seconds);
    if (message_arena != submessage_arena) {
      device_screensaver_idle_timeout_seconds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_screensaver_idle_timeout_seconds, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00000800u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000800u;
  }
  _impl_.device_screensaver_idle_timeout_seconds_ = device_screensaver_idle_timeout_seconds;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_idle_timeout_seconds)
}

// optional .enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto device_screensaver_image_display_interval_seconds = 144;
inline bool ChromeDeviceSettingsProto::_internal_has_device_screensaver_image_display_interval_seconds() const {
  bool value = (_impl_._has_bits_[4] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_screensaver_image_display_interval_seconds_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_screensaver_image_display_interval_seconds() const {
  return _internal_has_device_screensaver_image_display_interval_seconds();
}
inline void ChromeDeviceSettingsProto::clear_device_screensaver_image_display_interval_seconds() {
  if (_impl_.device_screensaver_image_display_interval_seconds_ != nullptr) _impl_.device_screensaver_image_display_interval_seconds_->Clear();
  _impl_._has_bits_[4] &= ~0x00001000u;
}
inline const ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto& ChromeDeviceSettingsProto::_internal_device_screensaver_image_display_interval_seconds() const {
  const ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* p = _impl_.device_screensaver_image_display_interval_seconds_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto&>(
      ::enterprise_management::_DeviceScreensaverImageDisplayIntervalSecondsProto_default_instance_);
}
inline const ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto& ChromeDeviceSettingsProto::device_screensaver_image_display_interval_seconds() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_image_display_interval_seconds)
  return _internal_device_screensaver_image_display_interval_seconds();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_screensaver_image_display_interval_seconds(
    ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* device_screensaver_image_display_interval_seconds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_screensaver_image_display_interval_seconds_);
  }
  _impl_.device_screensaver_image_display_interval_seconds_ = device_screensaver_image_display_interval_seconds;
  if (device_screensaver_image_display_interval_seconds) {
    _impl_._has_bits_[4] |= 0x00001000u;
  } else {
    _impl_._has_bits_[4] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_image_display_interval_seconds)
}
inline ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* ChromeDeviceSettingsProto::release_device_screensaver_image_display_interval_seconds() {
  _impl_._has_bits_[4] &= ~0x00001000u;
  ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* temp = _impl_.device_screensaver_image_display_interval_seconds_;
  _impl_.device_screensaver_image_display_interval_seconds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_screensaver_image_display_interval_seconds() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_image_display_interval_seconds)
  _impl_._has_bits_[4] &= ~0x00001000u;
  ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* temp = _impl_.device_screensaver_image_display_interval_seconds_;
  _impl_.device_screensaver_image_display_interval_seconds_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* ChromeDeviceSettingsProto::_internal_mutable_device_screensaver_image_display_interval_seconds() {
  _impl_._has_bits_[4] |= 0x00001000u;
  if (_impl_.device_screensaver_image_display_interval_seconds_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto>(GetArenaForAllocation());
    _impl_.device_screensaver_image_display_interval_seconds_ = p;
  }
  return _impl_.device_screensaver_image_display_interval_seconds_;
}
inline ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* ChromeDeviceSettingsProto::mutable_device_screensaver_image_display_interval_seconds() {
  ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* _msg = _internal_mutable_device_screensaver_image_display_interval_seconds();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_image_display_interval_seconds)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_screensaver_image_display_interval_seconds(::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto* device_screensaver_image_display_interval_seconds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_screensaver_image_display_interval_seconds_;
  }
  if (device_screensaver_image_display_interval_seconds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_screensaver_image_display_interval_seconds);
    if (message_arena != submessage_arena) {
      device_screensaver_image_display_interval_seconds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_screensaver_image_display_interval_seconds, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00001000u;
  } else {
    _impl_._has_bits_[4] &= ~0x00001000u;
  }
  _impl_.device_screensaver_image_display_interval_seconds_ = device_screensaver_image_display_interval_seconds;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_image_display_interval_seconds)
}

// optional .enterprise_management.DeviceScreensaverImagesProto device_screensaver_images = 145;
inline bool ChromeDeviceSettingsProto::_internal_has_device_screensaver_images() const {
  bool value = (_impl_._has_bits_[4] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_screensaver_images_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_screensaver_images() const {
  return _internal_has_device_screensaver_images();
}
inline void ChromeDeviceSettingsProto::clear_device_screensaver_images() {
  if (_impl_.device_screensaver_images_ != nullptr) _impl_.device_screensaver_images_->Clear();
  _impl_._has_bits_[4] &= ~0x00002000u;
}
inline const ::enterprise_management::DeviceScreensaverImagesProto& ChromeDeviceSettingsProto::_internal_device_screensaver_images() const {
  const ::enterprise_management::DeviceScreensaverImagesProto* p = _impl_.device_screensaver_images_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceScreensaverImagesProto&>(
      ::enterprise_management::_DeviceScreensaverImagesProto_default_instance_);
}
inline const ::enterprise_management::DeviceScreensaverImagesProto& ChromeDeviceSettingsProto::device_screensaver_images() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_images)
  return _internal_device_screensaver_images();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_screensaver_images(
    ::enterprise_management::DeviceScreensaverImagesProto* device_screensaver_images) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_screensaver_images_);
  }
  _impl_.device_screensaver_images_ = device_screensaver_images;
  if (device_screensaver_images) {
    _impl_._has_bits_[4] |= 0x00002000u;
  } else {
    _impl_._has_bits_[4] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_images)
}
inline ::enterprise_management::DeviceScreensaverImagesProto* ChromeDeviceSettingsProto::release_device_screensaver_images() {
  _impl_._has_bits_[4] &= ~0x00002000u;
  ::enterprise_management::DeviceScreensaverImagesProto* temp = _impl_.device_screensaver_images_;
  _impl_.device_screensaver_images_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceScreensaverImagesProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_screensaver_images() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_images)
  _impl_._has_bits_[4] &= ~0x00002000u;
  ::enterprise_management::DeviceScreensaverImagesProto* temp = _impl_.device_screensaver_images_;
  _impl_.device_screensaver_images_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceScreensaverImagesProto* ChromeDeviceSettingsProto::_internal_mutable_device_screensaver_images() {
  _impl_._has_bits_[4] |= 0x00002000u;
  if (_impl_.device_screensaver_images_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceScreensaverImagesProto>(GetArenaForAllocation());
    _impl_.device_screensaver_images_ = p;
  }
  return _impl_.device_screensaver_images_;
}
inline ::enterprise_management::DeviceScreensaverImagesProto* ChromeDeviceSettingsProto::mutable_device_screensaver_images() {
  ::enterprise_management::DeviceScreensaverImagesProto* _msg = _internal_mutable_device_screensaver_images();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_images)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_screensaver_images(::enterprise_management::DeviceScreensaverImagesProto* device_screensaver_images) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_screensaver_images_;
  }
  if (device_screensaver_images) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_screensaver_images);
    if (message_arena != submessage_arena) {
      device_screensaver_images = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_screensaver_images, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00002000u;
  } else {
    _impl_._has_bits_[4] &= ~0x00002000u;
  }
  _impl_.device_screensaver_images_ = device_screensaver_images;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_screensaver_images)
}

// optional .enterprise_management.DeviceSystemAecEnabledProto device_system_aec_enabled = 146;
inline bool ChromeDeviceSettingsProto::_internal_has_device_system_aec_enabled() const {
  bool value = (_impl_._has_bits_[4] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_system_aec_enabled_ != nullptr);
  return value;
}
inline bool ChromeDeviceSettingsProto::has_device_system_aec_enabled() const {
  return _internal_has_device_system_aec_enabled();
}
inline void ChromeDeviceSettingsProto::clear_device_system_aec_enabled() {
  if (_impl_.device_system_aec_enabled_ != nullptr) _impl_.device_system_aec_enabled_->Clear();
  _impl_._has_bits_[4] &= ~0x00004000u;
}
inline const ::enterprise_management::DeviceSystemAecEnabledProto& ChromeDeviceSettingsProto::_internal_device_system_aec_enabled() const {
  const ::enterprise_management::DeviceSystemAecEnabledProto* p = _impl_.device_system_aec_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceSystemAecEnabledProto&>(
      ::enterprise_management::_DeviceSystemAecEnabledProto_default_instance_);
}
inline const ::enterprise_management::DeviceSystemAecEnabledProto& ChromeDeviceSettingsProto::device_system_aec_enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDeviceSettingsProto.device_system_aec_enabled)
  return _internal_device_system_aec_enabled();
}
inline void ChromeDeviceSettingsProto::unsafe_arena_set_allocated_device_system_aec_enabled(
    ::enterprise_management::DeviceSystemAecEnabledProto* device_system_aec_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_system_aec_enabled_);
  }
  _impl_.device_system_aec_enabled_ = device_system_aec_enabled;
  if (device_system_aec_enabled) {
    _impl_._has_bits_[4] |= 0x00004000u;
  } else {
    _impl_._has_bits_[4] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_system_aec_enabled)
}
inline ::enterprise_management::DeviceSystemAecEnabledProto* ChromeDeviceSettingsProto::release_device_system_aec_enabled() {
  _impl_._has_bits_[4] &= ~0x00004000u;
  ::enterprise_management::DeviceSystemAecEnabledProto* temp = _impl_.device_system_aec_enabled_;
  _impl_.device_system_aec_enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceSystemAecEnabledProto* ChromeDeviceSettingsProto::unsafe_arena_release_device_system_aec_enabled() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDeviceSettingsProto.device_system_aec_enabled)
  _impl_._has_bits_[4] &= ~0x00004000u;
  ::enterprise_management::DeviceSystemAecEnabledProto* temp = _impl_.device_system_aec_enabled_;
  _impl_.device_system_aec_enabled_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceSystemAecEnabledProto* ChromeDeviceSettingsProto::_internal_mutable_device_system_aec_enabled() {
  _impl_._has_bits_[4] |= 0x00004000u;
  if (_impl_.device_system_aec_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceSystemAecEnabledProto>(GetArenaForAllocation());
    _impl_.device_system_aec_enabled_ = p;
  }
  return _impl_.device_system_aec_enabled_;
}
inline ::enterprise_management::DeviceSystemAecEnabledProto* ChromeDeviceSettingsProto::mutable_device_system_aec_enabled() {
  ::enterprise_management::DeviceSystemAecEnabledProto* _msg = _internal_mutable_device_system_aec_enabled();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDeviceSettingsProto.device_system_aec_enabled)
  return _msg;
}
inline void ChromeDeviceSettingsProto::set_allocated_device_system_aec_enabled(::enterprise_management::DeviceSystemAecEnabledProto* device_system_aec_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_system_aec_enabled_;
  }
  if (device_system_aec_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_system_aec_enabled);
    if (message_arena != submessage_arena) {
      device_system_aec_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_system_aec_enabled, submessage_arena);
    }
    _impl_._has_bits_[4] |= 0x00004000u;
  } else {
    _impl_._has_bits_[4] &= ~0x00004000u;
  }
  _impl_.device_system_aec_enabled_ = device_system_aec_enabled;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDeviceSettingsProto.device_system_aec_enabled)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace enterprise_management

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::enterprise_management::AutoUpdateSettingsProto_ConnectionType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceLocalAccountInfoProto_AccountType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DisplayRotationDefaultProto_Rotation> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::WeeklyTimeProto_DayOfWeek> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DevicePrintersAccessModeProto_AccessMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceKerberosEncryptionTypesProto_Types> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::KeyboardBacklightColorProto_BacklightColor> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceDockMacAddressSourceProto_Source> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chrome_5fdevice_5fpolicy_2eproto
