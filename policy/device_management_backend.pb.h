// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_management_backend.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_device_5fmanagement_5fbackend_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_device_5fmanagement_5fbackend_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "private_membership_rlwe.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_device_5fmanagement_5fbackend_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_device_5fmanagement_5fbackend_2eproto {
  static const uint32_t offsets[];
};
namespace enterprise_management {
class ActiveDirectoryEnrollPlayUserRequest;
struct ActiveDirectoryEnrollPlayUserRequestDefaultTypeInternal;
extern ActiveDirectoryEnrollPlayUserRequestDefaultTypeInternal _ActiveDirectoryEnrollPlayUserRequest_default_instance_;
class ActiveDirectoryEnrollPlayUserResponse;
struct ActiveDirectoryEnrollPlayUserResponseDefaultTypeInternal;
extern ActiveDirectoryEnrollPlayUserResponseDefaultTypeInternal _ActiveDirectoryEnrollPlayUserResponse_default_instance_;
class ActiveDirectoryPlayActivityRequest;
struct ActiveDirectoryPlayActivityRequestDefaultTypeInternal;
extern ActiveDirectoryPlayActivityRequestDefaultTypeInternal _ActiveDirectoryPlayActivityRequest_default_instance_;
class ActiveDirectoryPlayActivityResponse;
struct ActiveDirectoryPlayActivityResponseDefaultTypeInternal;
extern ActiveDirectoryPlayActivityResponseDefaultTypeInternal _ActiveDirectoryPlayActivityResponse_default_instance_;
class ActiveDirectoryUserSigninRequest;
struct ActiveDirectoryUserSigninRequestDefaultTypeInternal;
extern ActiveDirectoryUserSigninRequestDefaultTypeInternal _ActiveDirectoryUserSigninRequest_default_instance_;
class ActiveDirectoryUserSigninResponse;
struct ActiveDirectoryUserSigninResponseDefaultTypeInternal;
extern ActiveDirectoryUserSigninResponseDefaultTypeInternal _ActiveDirectoryUserSigninResponse_default_instance_;
class ActiveTimePeriod;
struct ActiveTimePeriodDefaultTypeInternal;
extern ActiveTimePeriodDefaultTypeInternal _ActiveTimePeriod_default_instance_;
class AndroidAppInfo;
struct AndroidAppInfoDefaultTypeInternal;
extern AndroidAppInfoDefaultTypeInternal _AndroidAppInfo_default_instance_;
class AndroidAppPermission;
struct AndroidAppPermissionDefaultTypeInternal;
extern AndroidAppPermissionDefaultTypeInternal _AndroidAppPermission_default_instance_;
class AndroidStatus;
struct AndroidStatusDefaultTypeInternal;
extern AndroidStatusDefaultTypeInternal _AndroidStatus_default_instance_;
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class AppActivity;
struct AppActivityDefaultTypeInternal;
extern AppActivityDefaultTypeInternal _AppActivity_default_instance_;
class AppInfo;
struct AppInfoDefaultTypeInternal;
extern AppInfoDefaultTypeInternal _AppInfo_default_instance_;
class AppInstallReport;
struct AppInstallReportDefaultTypeInternal;
extern AppInstallReportDefaultTypeInternal _AppInstallReport_default_instance_;
class AppInstallReportLogEvent;
struct AppInstallReportLogEventDefaultTypeInternal;
extern AppInstallReportLogEventDefaultTypeInternal _AppInstallReportLogEvent_default_instance_;
class AppInstallReportRequest;
struct AppInstallReportRequestDefaultTypeInternal;
extern AppInstallReportRequestDefaultTypeInternal _AppInstallReportRequest_default_instance_;
class AppInstallReportResponse;
struct AppInstallReportResponseDefaultTypeInternal;
extern AppInstallReportResponseDefaultTypeInternal _AppInstallReportResponse_default_instance_;
class AppStatus;
struct AppStatusDefaultTypeInternal;
extern AppStatusDefaultTypeInternal _AppStatus_default_instance_;
class BacklightInfo;
struct BacklightInfoDefaultTypeInternal;
extern BacklightInfoDefaultTypeInternal _BacklightInfo_default_instance_;
class BatteryInfo;
struct BatteryInfoDefaultTypeInternal;
extern BatteryInfoDefaultTypeInternal _BatteryInfo_default_instance_;
class BatterySample;
struct BatterySampleDefaultTypeInternal;
extern BatterySampleDefaultTypeInternal _BatterySample_default_instance_;
class BluetoothAdapterInfo;
struct BluetoothAdapterInfoDefaultTypeInternal;
extern BluetoothAdapterInfoDefaultTypeInternal _BluetoothAdapterInfo_default_instance_;
class BoardStatus;
struct BoardStatusDefaultTypeInternal;
extern BoardStatusDefaultTypeInternal _BoardStatus_default_instance_;
class BootInfo;
struct BootInfoDefaultTypeInternal;
extern BootInfoDefaultTypeInternal _BootInfo_default_instance_;
class BrowserDeviceIdentifier;
struct BrowserDeviceIdentifierDefaultTypeInternal;
extern BrowserDeviceIdentifierDefaultTypeInternal _BrowserDeviceIdentifier_default_instance_;
class BrowserPublicKeyUploadRequest;
struct BrowserPublicKeyUploadRequestDefaultTypeInternal;
extern BrowserPublicKeyUploadRequestDefaultTypeInternal _BrowserPublicKeyUploadRequest_default_instance_;
class BrowserPublicKeyUploadResponse;
struct BrowserPublicKeyUploadResponseDefaultTypeInternal;
extern BrowserPublicKeyUploadResponseDefaultTypeInternal _BrowserPublicKeyUploadResponse_default_instance_;
class BrowserReport;
struct BrowserReportDefaultTypeInternal;
extern BrowserReportDefaultTypeInternal _BrowserReport_default_instance_;
class CPUTempInfo;
struct CPUTempInfoDefaultTypeInternal;
extern CPUTempInfoDefaultTypeInternal _CPUTempInfo_default_instance_;
class CertProvAuthorizeInstruction;
struct CertProvAuthorizeInstructionDefaultTypeInternal;
extern CertProvAuthorizeInstructionDefaultTypeInternal _CertProvAuthorizeInstruction_default_instance_;
class CertProvAuthorizeRequest;
struct CertProvAuthorizeRequestDefaultTypeInternal;
extern CertProvAuthorizeRequestDefaultTypeInternal _CertProvAuthorizeRequest_default_instance_;
class CertProvImportCertificateInstruction;
struct CertProvImportCertificateInstructionDefaultTypeInternal;
extern CertProvImportCertificateInstructionDefaultTypeInternal _CertProvImportCertificateInstruction_default_instance_;
class CertProvNextActionResponse;
struct CertProvNextActionResponseDefaultTypeInternal;
extern CertProvNextActionResponseDefaultTypeInternal _CertProvNextActionResponse_default_instance_;
class CertProvProofOfPossessionInstruction;
struct CertProvProofOfPossessionInstructionDefaultTypeInternal;
extern CertProvProofOfPossessionInstructionDefaultTypeInternal _CertProvProofOfPossessionInstruction_default_instance_;
class CertProvStartOrContinueRequest;
struct CertProvStartOrContinueRequestDefaultTypeInternal;
extern CertProvStartOrContinueRequestDefaultTypeInternal _CertProvStartOrContinueRequest_default_instance_;
class CertProvTryLaterInstruction;
struct CertProvTryLaterInstructionDefaultTypeInternal;
extern CertProvTryLaterInstructionDefaultTypeInternal _CertProvTryLaterInstruction_default_instance_;
class CertProvUploadProofOfPossessionRequest;
struct CertProvUploadProofOfPossessionRequestDefaultTypeInternal;
extern CertProvUploadProofOfPossessionRequestDefaultTypeInternal _CertProvUploadProofOfPossessionRequest_default_instance_;
class CertificateBasedDeviceRegisterRequest;
struct CertificateBasedDeviceRegisterRequestDefaultTypeInternal;
extern CertificateBasedDeviceRegisterRequestDefaultTypeInternal _CertificateBasedDeviceRegisterRequest_default_instance_;
class CertificateBasedDeviceRegistrationData;
struct CertificateBasedDeviceRegistrationDataDefaultTypeInternal;
extern CertificateBasedDeviceRegistrationDataDefaultTypeInternal _CertificateBasedDeviceRegistrationData_default_instance_;
class CheckAndroidManagementRequest;
struct CheckAndroidManagementRequestDefaultTypeInternal;
extern CheckAndroidManagementRequestDefaultTypeInternal _CheckAndroidManagementRequest_default_instance_;
class CheckAndroidManagementResponse;
struct CheckAndroidManagementResponseDefaultTypeInternal;
extern CheckAndroidManagementResponseDefaultTypeInternal _CheckAndroidManagementResponse_default_instance_;
class CheckDeviceLicenseRequest;
struct CheckDeviceLicenseRequestDefaultTypeInternal;
extern CheckDeviceLicenseRequestDefaultTypeInternal _CheckDeviceLicenseRequest_default_instance_;
class CheckDeviceLicenseResponse;
struct CheckDeviceLicenseResponseDefaultTypeInternal;
extern CheckDeviceLicenseResponseDefaultTypeInternal _CheckDeviceLicenseResponse_default_instance_;
class CheckDevicePairingRequest;
struct CheckDevicePairingRequestDefaultTypeInternal;
extern CheckDevicePairingRequestDefaultTypeInternal _CheckDevicePairingRequest_default_instance_;
class CheckDevicePairingResponse;
struct CheckDevicePairingResponseDefaultTypeInternal;
extern CheckDevicePairingResponseDefaultTypeInternal _CheckDevicePairingResponse_default_instance_;
class CheckUserAccountRequest;
struct CheckUserAccountRequestDefaultTypeInternal;
extern CheckUserAccountRequestDefaultTypeInternal _CheckUserAccountRequest_default_instance_;
class CheckUserAccountResponse;
struct CheckUserAccountResponseDefaultTypeInternal;
extern CheckUserAccountResponseDefaultTypeInternal _CheckUserAccountResponse_default_instance_;
class ChildStatusReportRequest;
struct ChildStatusReportRequestDefaultTypeInternal;
extern ChildStatusReportRequestDefaultTypeInternal _ChildStatusReportRequest_default_instance_;
class ChildStatusReportResponse;
struct ChildStatusReportResponseDefaultTypeInternal;
extern ChildStatusReportResponseDefaultTypeInternal _ChildStatusReportResponse_default_instance_;
class ChromeDesktopReportRequest;
struct ChromeDesktopReportRequestDefaultTypeInternal;
extern ChromeDesktopReportRequestDefaultTypeInternal _ChromeDesktopReportRequest_default_instance_;
class ChromeDesktopReportResponse;
struct ChromeDesktopReportResponseDefaultTypeInternal;
extern ChromeDesktopReportResponseDefaultTypeInternal _ChromeDesktopReportResponse_default_instance_;
class ChromeOsUserReportRequest;
struct ChromeOsUserReportRequestDefaultTypeInternal;
extern ChromeOsUserReportRequestDefaultTypeInternal _ChromeOsUserReportRequest_default_instance_;
class ChromeOsUserReportResponse;
struct ChromeOsUserReportResponseDefaultTypeInternal;
extern ChromeOsUserReportResponseDefaultTypeInternal _ChromeOsUserReportResponse_default_instance_;
class ChromeProfileReportRequest;
struct ChromeProfileReportRequestDefaultTypeInternal;
extern ChromeProfileReportRequestDefaultTypeInternal _ChromeProfileReportRequest_default_instance_;
class ChromeProfileReportResponse;
struct ChromeProfileReportResponseDefaultTypeInternal;
extern ChromeProfileReportResponseDefaultTypeInternal _ChromeProfileReportResponse_default_instance_;
class ChromeSignedInUser;
struct ChromeSignedInUserDefaultTypeInternal;
extern ChromeSignedInUserDefaultTypeInternal _ChromeSignedInUser_default_instance_;
class ChromeUserProfileInfo;
struct ChromeUserProfileInfoDefaultTypeInternal;
extern ChromeUserProfileInfoDefaultTypeInternal _ChromeUserProfileInfo_default_instance_;
class ChromeUserProfileReport;
struct ChromeUserProfileReportDefaultTypeInternal;
extern ChromeUserProfileReportDefaultTypeInternal _ChromeUserProfileReport_default_instance_;
class ClientActionRequired;
struct ClientActionRequiredDefaultTypeInternal;
extern ClientActionRequiredDefaultTypeInternal _ClientActionRequired_default_instance_;
class ClientCertificateProvisioningRequest;
struct ClientCertificateProvisioningRequestDefaultTypeInternal;
extern ClientCertificateProvisioningRequestDefaultTypeInternal _ClientCertificateProvisioningRequest_default_instance_;
class ClientCertificateProvisioningResponse;
struct ClientCertificateProvisioningResponseDefaultTypeInternal;
extern ClientCertificateProvisioningResponseDefaultTypeInternal _ClientCertificateProvisioningResponse_default_instance_;
class CpuCStateInfo;
struct CpuCStateInfoDefaultTypeInternal;
extern CpuCStateInfoDefaultTypeInternal _CpuCStateInfo_default_instance_;
class CpuInfo;
struct CpuInfoDefaultTypeInternal;
extern CpuInfoDefaultTypeInternal _CpuInfo_default_instance_;
class CpuUtilizationInfo;
struct CpuUtilizationInfoDefaultTypeInternal;
extern CpuUtilizationInfoDefaultTypeInternal _CpuUtilizationInfo_default_instance_;
class CrashReportInfo;
struct CrashReportInfoDefaultTypeInternal;
extern CrashReportInfoDefaultTypeInternal _CrashReportInfo_default_instance_;
class CrostiniApp;
struct CrostiniAppDefaultTypeInternal;
extern CrostiniAppDefaultTypeInternal _CrostiniApp_default_instance_;
class CrostiniStatus;
struct CrostiniStatusDefaultTypeInternal;
extern CrostiniStatusDefaultTypeInternal _CrostiniStatus_default_instance_;
class CustomerLogo;
struct CustomerLogoDefaultTypeInternal;
extern CustomerLogoDefaultTypeInternal _CustomerLogo_default_instance_;
class DEPRECATEDPolicyPublicKeyAndDomain;
struct DEPRECATEDPolicyPublicKeyAndDomainDefaultTypeInternal;
extern DEPRECATEDPolicyPublicKeyAndDomainDefaultTypeInternal _DEPRECATEDPolicyPublicKeyAndDomain_default_instance_;
class DeviceAttributeUpdatePermissionRequest;
struct DeviceAttributeUpdatePermissionRequestDefaultTypeInternal;
extern DeviceAttributeUpdatePermissionRequestDefaultTypeInternal _DeviceAttributeUpdatePermissionRequest_default_instance_;
class DeviceAttributeUpdatePermissionResponse;
struct DeviceAttributeUpdatePermissionResponseDefaultTypeInternal;
extern DeviceAttributeUpdatePermissionResponseDefaultTypeInternal _DeviceAttributeUpdatePermissionResponse_default_instance_;
class DeviceAttributeUpdateRequest;
struct DeviceAttributeUpdateRequestDefaultTypeInternal;
extern DeviceAttributeUpdateRequestDefaultTypeInternal _DeviceAttributeUpdateRequest_default_instance_;
class DeviceAttributeUpdateResponse;
struct DeviceAttributeUpdateResponseDefaultTypeInternal;
extern DeviceAttributeUpdateResponseDefaultTypeInternal _DeviceAttributeUpdateResponse_default_instance_;
class DeviceAutoEnrollmentRequest;
struct DeviceAutoEnrollmentRequestDefaultTypeInternal;
extern DeviceAutoEnrollmentRequestDefaultTypeInternal _DeviceAutoEnrollmentRequest_default_instance_;
class DeviceAutoEnrollmentResponse;
struct DeviceAutoEnrollmentResponseDefaultTypeInternal;
extern DeviceAutoEnrollmentResponseDefaultTypeInternal _DeviceAutoEnrollmentResponse_default_instance_;
class DeviceCertUploadRequest;
struct DeviceCertUploadRequestDefaultTypeInternal;
extern DeviceCertUploadRequestDefaultTypeInternal _DeviceCertUploadRequest_default_instance_;
class DeviceCertUploadResponse;
struct DeviceCertUploadResponseDefaultTypeInternal;
extern DeviceCertUploadResponseDefaultTypeInternal _DeviceCertUploadResponse_default_instance_;
class DeviceInitialEnrollmentStateRequest;
struct DeviceInitialEnrollmentStateRequestDefaultTypeInternal;
extern DeviceInitialEnrollmentStateRequestDefaultTypeInternal _DeviceInitialEnrollmentStateRequest_default_instance_;
class DeviceInitialEnrollmentStateResponse;
struct DeviceInitialEnrollmentStateResponseDefaultTypeInternal;
extern DeviceInitialEnrollmentStateResponseDefaultTypeInternal _DeviceInitialEnrollmentStateResponse_default_instance_;
class DeviceManagementRequest;
struct DeviceManagementRequestDefaultTypeInternal;
extern DeviceManagementRequestDefaultTypeInternal _DeviceManagementRequest_default_instance_;
class DeviceManagementResponse;
struct DeviceManagementResponseDefaultTypeInternal;
extern DeviceManagementResponseDefaultTypeInternal _DeviceManagementResponse_default_instance_;
class DevicePairingRequest;
struct DevicePairingRequestDefaultTypeInternal;
extern DevicePairingRequestDefaultTypeInternal _DevicePairingRequest_default_instance_;
class DevicePairingResponse;
struct DevicePairingResponseDefaultTypeInternal;
extern DevicePairingResponseDefaultTypeInternal _DevicePairingResponse_default_instance_;
class DevicePolicyRequest;
struct DevicePolicyRequestDefaultTypeInternal;
extern DevicePolicyRequestDefaultTypeInternal _DevicePolicyRequest_default_instance_;
class DevicePolicyResponse;
struct DevicePolicyResponseDefaultTypeInternal;
extern DevicePolicyResponseDefaultTypeInternal _DevicePolicyResponse_default_instance_;
class DeviceRegisterConfiguration;
struct DeviceRegisterConfigurationDefaultTypeInternal;
extern DeviceRegisterConfigurationDefaultTypeInternal _DeviceRegisterConfiguration_default_instance_;
class DeviceRegisterIdentification;
struct DeviceRegisterIdentificationDefaultTypeInternal;
extern DeviceRegisterIdentificationDefaultTypeInternal _DeviceRegisterIdentification_default_instance_;
class DeviceRegisterRequest;
struct DeviceRegisterRequestDefaultTypeInternal;
extern DeviceRegisterRequestDefaultTypeInternal _DeviceRegisterRequest_default_instance_;
class DeviceRegisterResponse;
struct DeviceRegisterResponseDefaultTypeInternal;
extern DeviceRegisterResponseDefaultTypeInternal _DeviceRegisterResponse_default_instance_;
class DeviceRemoteCommandRequest;
struct DeviceRemoteCommandRequestDefaultTypeInternal;
extern DeviceRemoteCommandRequestDefaultTypeInternal _DeviceRemoteCommandRequest_default_instance_;
class DeviceRemoteCommandResponse;
struct DeviceRemoteCommandResponseDefaultTypeInternal;
extern DeviceRemoteCommandResponseDefaultTypeInternal _DeviceRemoteCommandResponse_default_instance_;
class DeviceServiceApiAccessRequest;
struct DeviceServiceApiAccessRequestDefaultTypeInternal;
extern DeviceServiceApiAccessRequestDefaultTypeInternal _DeviceServiceApiAccessRequest_default_instance_;
class DeviceServiceApiAccessResponse;
struct DeviceServiceApiAccessResponseDefaultTypeInternal;
extern DeviceServiceApiAccessResponseDefaultTypeInternal _DeviceServiceApiAccessResponse_default_instance_;
class DeviceState;
struct DeviceStateDefaultTypeInternal;
extern DeviceStateDefaultTypeInternal _DeviceState_default_instance_;
class DeviceStateKeyUpdateRequest;
struct DeviceStateKeyUpdateRequestDefaultTypeInternal;
extern DeviceStateKeyUpdateRequestDefaultTypeInternal _DeviceStateKeyUpdateRequest_default_instance_;
class DeviceStateRetrievalInfo;
struct DeviceStateRetrievalInfoDefaultTypeInternal;
extern DeviceStateRetrievalInfoDefaultTypeInternal _DeviceStateRetrievalInfo_default_instance_;
class DeviceStateRetrievalRequest;
struct DeviceStateRetrievalRequestDefaultTypeInternal;
extern DeviceStateRetrievalRequestDefaultTypeInternal _DeviceStateRetrievalRequest_default_instance_;
class DeviceStateRetrievalResponse;
struct DeviceStateRetrievalResponseDefaultTypeInternal;
extern DeviceStateRetrievalResponseDefaultTypeInternal _DeviceStateRetrievalResponse_default_instance_;
class DeviceStatusReportRequest;
struct DeviceStatusReportRequestDefaultTypeInternal;
extern DeviceStatusReportRequestDefaultTypeInternal _DeviceStatusReportRequest_default_instance_;
class DeviceStatusReportResponse;
struct DeviceStatusReportResponseDefaultTypeInternal;
extern DeviceStatusReportResponseDefaultTypeInternal _DeviceStatusReportResponse_default_instance_;
class DeviceUnregisterRequest;
struct DeviceUnregisterRequestDefaultTypeInternal;
extern DeviceUnregisterRequestDefaultTypeInternal _DeviceUnregisterRequest_default_instance_;
class DeviceUnregisterResponse;
struct DeviceUnregisterResponseDefaultTypeInternal;
extern DeviceUnregisterResponseDefaultTypeInternal _DeviceUnregisterResponse_default_instance_;
class DeviceUser;
struct DeviceUserDefaultTypeInternal;
extern DeviceUserDefaultTypeInternal _DeviceUser_default_instance_;
class DisabledState;
struct DisabledStateDefaultTypeInternal;
extern DisabledStateDefaultTypeInternal _DisabledState_default_instance_;
class DiskInfo;
struct DiskInfoDefaultTypeInternal;
extern DiskInfoDefaultTypeInternal _DiskInfo_default_instance_;
class DiskLifetimeEstimation;
struct DiskLifetimeEstimationDefaultTypeInternal;
extern DiskLifetimeEstimationDefaultTypeInternal _DiskLifetimeEstimation_default_instance_;
class DisplayInfo;
struct DisplayInfoDefaultTypeInternal;
extern DisplayInfoDefaultTypeInternal _DisplayInfo_default_instance_;
class DownloadCertRequest;
struct DownloadCertRequestDefaultTypeInternal;
extern DownloadCertRequestDefaultTypeInternal _DownloadCertRequest_default_instance_;
class DownloadCertResponse;
struct DownloadCertResponseDefaultTypeInternal;
extern DownloadCertResponseDefaultTypeInternal _DownloadCertResponse_default_instance_;
class EFIVars;
struct EFIVarsDefaultTypeInternal;
extern EFIVarsDefaultTypeInternal _EFIVars_default_instance_;
class ESimProfileInfo;
struct ESimProfileInfoDefaultTypeInternal;
extern ESimProfileInfoDefaultTypeInternal _ESimProfileInfo_default_instance_;
class Extension;
struct ExtensionDefaultTypeInternal;
extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class ExtensionInstallReport;
struct ExtensionInstallReportDefaultTypeInternal;
extern ExtensionInstallReportDefaultTypeInternal _ExtensionInstallReport_default_instance_;
class ExtensionInstallReportLogEvent;
struct ExtensionInstallReportLogEventDefaultTypeInternal;
extern ExtensionInstallReportLogEventDefaultTypeInternal _ExtensionInstallReportLogEvent_default_instance_;
class ExtensionInstallReportRequest;
struct ExtensionInstallReportRequestDefaultTypeInternal;
extern ExtensionInstallReportRequestDefaultTypeInternal _ExtensionInstallReportRequest_default_instance_;
class ExtensionPolicy;
struct ExtensionPolicyDefaultTypeInternal;
extern ExtensionPolicyDefaultTypeInternal _ExtensionPolicy_default_instance_;
class ExtensionRequest;
struct ExtensionRequestDefaultTypeInternal;
extern ExtensionRequestDefaultTypeInternal _ExtensionRequest_default_instance_;
class FanInfo;
struct FanInfoDefaultTypeInternal;
extern FanInfoDefaultTypeInternal _FanInfo_default_instance_;
class FinishCsrRequest;
struct FinishCsrRequestDefaultTypeInternal;
extern FinishCsrRequestDefaultTypeInternal _FinishCsrRequest_default_instance_;
class FinishCsrResponse;
struct FinishCsrResponseDefaultTypeInternal;
extern FinishCsrResponseDefaultTypeInternal _FinishCsrResponse_default_instance_;
class GcmIdUpdateRequest;
struct GcmIdUpdateRequestDefaultTypeInternal;
extern GcmIdUpdateRequestDefaultTypeInternal _GcmIdUpdateRequest_default_instance_;
class GcmIdUpdateResponse;
struct GcmIdUpdateResponseDefaultTypeInternal;
extern GcmIdUpdateResponseDefaultTypeInternal _GcmIdUpdateResponse_default_instance_;
class GlobalCpuInfo;
struct GlobalCpuInfoDefaultTypeInternal;
extern GlobalCpuInfoDefaultTypeInternal _GlobalCpuInfo_default_instance_;
class GraphicsAdapterInfo;
struct GraphicsAdapterInfoDefaultTypeInternal;
extern GraphicsAdapterInfoDefaultTypeInternal _GraphicsAdapterInfo_default_instance_;
class GraphicsStatus;
struct GraphicsStatusDefaultTypeInternal;
extern GraphicsStatusDefaultTypeInternal _GraphicsStatus_default_instance_;
class KernelParameters;
struct KernelParametersDefaultTypeInternal;
extern KernelParametersDefaultTypeInternal _KernelParameters_default_instance_;
class LaCrOsBrowserReport;
struct LaCrOsBrowserReportDefaultTypeInternal;
extern LaCrOsBrowserReportDefaultTypeInternal _LaCrOsBrowserReport_default_instance_;
class LicenseAvailability;
struct LicenseAvailabilityDefaultTypeInternal;
extern LicenseAvailabilityDefaultTypeInternal _LicenseAvailability_default_instance_;
class LicenseType;
struct LicenseTypeDefaultTypeInternal;
extern LicenseTypeDefaultTypeInternal _LicenseType_default_instance_;
class LogicalCpuInfo;
struct LogicalCpuInfoDefaultTypeInternal;
extern LogicalCpuInfoDefaultTypeInternal _LogicalCpuInfo_default_instance_;
class MemoryInfo;
struct MemoryInfoDefaultTypeInternal;
extern MemoryInfoDefaultTypeInternal _MemoryInfo_default_instance_;
class NetworkAdapterInfo;
struct NetworkAdapterInfoDefaultTypeInternal;
extern NetworkAdapterInfoDefaultTypeInternal _NetworkAdapterInfo_default_instance_;
class NetworkInterface;
struct NetworkInterfaceDefaultTypeInternal;
extern NetworkInterfaceDefaultTypeInternal _NetworkInterface_default_instance_;
class NetworkState;
struct NetworkStateDefaultTypeInternal;
extern NetworkStateDefaultTypeInternal _NetworkState_default_instance_;
class OSReport;
struct OSReportDefaultTypeInternal;
extern OSReportDefaultTypeInternal _OSReport_default_instance_;
class OsUpdateStatus;
struct OsUpdateStatusDefaultTypeInternal;
extern OsUpdateStatusDefaultTypeInternal _OsUpdateStatus_default_instance_;
class Plugin;
struct PluginDefaultTypeInternal;
extern PluginDefaultTypeInternal _Plugin_default_instance_;
class Policy;
struct PolicyDefaultTypeInternal;
extern PolicyDefaultTypeInternal _Policy_default_instance_;
class PolicyData;
struct PolicyDataDefaultTypeInternal;
extern PolicyDataDefaultTypeInternal _PolicyData_default_instance_;
class PolicyFetchRequest;
struct PolicyFetchRequestDefaultTypeInternal;
extern PolicyFetchRequestDefaultTypeInternal _PolicyFetchRequest_default_instance_;
class PolicyFetchResponse;
struct PolicyFetchResponseDefaultTypeInternal;
extern PolicyFetchResponseDefaultTypeInternal _PolicyFetchResponse_default_instance_;
class PolicyFetchTimestamp;
struct PolicyFetchTimestampDefaultTypeInternal;
extern PolicyFetchTimestampDefaultTypeInternal _PolicyFetchTimestamp_default_instance_;
class PolicyValidationReportRequest;
struct PolicyValidationReportRequestDefaultTypeInternal;
extern PolicyValidationReportRequestDefaultTypeInternal _PolicyValidationReportRequest_default_instance_;
class PolicyValidationReportResponse;
struct PolicyValidationReportResponseDefaultTypeInternal;
extern PolicyValidationReportResponseDefaultTypeInternal _PolicyValidationReportResponse_default_instance_;
class PolicyValueValidationIssue;
struct PolicyValueValidationIssueDefaultTypeInternal;
extern PolicyValueValidationIssueDefaultTypeInternal _PolicyValueValidationIssue_default_instance_;
class PowerStatus;
struct PowerStatusDefaultTypeInternal;
extern PowerStatusDefaultTypeInternal _PowerStatus_default_instance_;
class PrintJobEvent;
struct PrintJobEventDefaultTypeInternal;
extern PrintJobEventDefaultTypeInternal _PrintJobEvent_default_instance_;
class PrintJobEvent_PrintJobConfiguration;
struct PrintJobEvent_PrintJobConfigurationDefaultTypeInternal;
extern PrintJobEvent_PrintJobConfigurationDefaultTypeInternal _PrintJobEvent_PrintJobConfiguration_default_instance_;
class PrintJobEvent_PrintSettings;
struct PrintJobEvent_PrintSettingsDefaultTypeInternal;
extern PrintJobEvent_PrintSettingsDefaultTypeInternal _PrintJobEvent_PrintSettings_default_instance_;
class PrintJobEvent_PrintSettings_MediaSize;
struct PrintJobEvent_PrintSettings_MediaSizeDefaultTypeInternal;
extern PrintJobEvent_PrintSettings_MediaSizeDefaultTypeInternal _PrintJobEvent_PrintSettings_MediaSize_default_instance_;
class PrintJobEvent_Printer;
struct PrintJobEvent_PrinterDefaultTypeInternal;
extern PrintJobEvent_PrinterDefaultTypeInternal _PrintJobEvent_Printer_default_instance_;
class PrivateSetMembershipRequest;
struct PrivateSetMembershipRequestDefaultTypeInternal;
extern PrivateSetMembershipRequestDefaultTypeInternal _PrivateSetMembershipRequest_default_instance_;
class PrivateSetMembershipResponse;
struct PrivateSetMembershipResponseDefaultTypeInternal;
extern PrivateSetMembershipResponseDefaultTypeInternal _PrivateSetMembershipResponse_default_instance_;
class PrivateSetMembershipRlweRequest;
struct PrivateSetMembershipRlweRequestDefaultTypeInternal;
extern PrivateSetMembershipRlweRequestDefaultTypeInternal _PrivateSetMembershipRlweRequest_default_instance_;
class PrivateSetMembershipRlweResponse;
struct PrivateSetMembershipRlweResponseDefaultTypeInternal;
extern PrivateSetMembershipRlweResponseDefaultTypeInternal _PrivateSetMembershipRlweResponse_default_instance_;
class PublicKeyVerificationData;
struct PublicKeyVerificationDataDefaultTypeInternal;
extern PublicKeyVerificationDataDefaultTypeInternal _PublicKeyVerificationData_default_instance_;
class PublicSamlUserRequest;
struct PublicSamlUserRequestDefaultTypeInternal;
extern PublicSamlUserRequestDefaultTypeInternal _PublicSamlUserRequest_default_instance_;
class PublicSamlUserResponse;
struct PublicSamlUserResponseDefaultTypeInternal;
extern PublicSamlUserResponseDefaultTypeInternal _PublicSamlUserResponse_default_instance_;
class RefreshAccountRequest;
struct RefreshAccountRequestDefaultTypeInternal;
extern RefreshAccountRequestDefaultTypeInternal _RefreshAccountRequest_default_instance_;
class RefreshAccountResponse;
struct RefreshAccountResponseDefaultTypeInternal;
extern RefreshAccountResponseDefaultTypeInternal _RefreshAccountResponse_default_instance_;
class RegisterBrowserRequest;
struct RegisterBrowserRequestDefaultTypeInternal;
extern RegisterBrowserRequestDefaultTypeInternal _RegisterBrowserRequest_default_instance_;
class RemoteCommand;
struct RemoteCommandDefaultTypeInternal;
extern RemoteCommandDefaultTypeInternal _RemoteCommand_default_instance_;
class RemoteCommandResult;
struct RemoteCommandResultDefaultTypeInternal;
extern RemoteCommandResultDefaultTypeInternal _RemoteCommandResult_default_instance_;
class RsuLookupKeyUploadRequest;
struct RsuLookupKeyUploadRequestDefaultTypeInternal;
extern RsuLookupKeyUploadRequestDefaultTypeInternal _RsuLookupKeyUploadRequest_default_instance_;
class RsuLookupKeyUploadResponse;
struct RsuLookupKeyUploadResponseDefaultTypeInternal;
extern RsuLookupKeyUploadResponseDefaultTypeInternal _RsuLookupKeyUploadResponse_default_instance_;
class SamlParametersProto;
struct SamlParametersProtoDefaultTypeInternal;
extern SamlParametersProtoDefaultTypeInternal _SamlParametersProto_default_instance_;
class ScreenTimeSpan;
struct ScreenTimeSpanDefaultTypeInternal;
extern ScreenTimeSpanDefaultTypeInternal _ScreenTimeSpan_default_instance_;
class SessionStatusReportRequest;
struct SessionStatusReportRequestDefaultTypeInternal;
extern SessionStatusReportRequestDefaultTypeInternal _SessionStatusReportRequest_default_instance_;
class SessionStatusReportResponse;
struct SessionStatusReportResponseDefaultTypeInternal;
extern SessionStatusReportResponseDefaultTypeInternal _SessionStatusReportResponse_default_instance_;
class SignedData;
struct SignedDataDefaultTypeInternal;
extern SignedDataDefaultTypeInternal _SignedData_default_instance_;
class SmbiosInfo;
struct SmbiosInfoDefaultTypeInternal;
extern SmbiosInfoDefaultTypeInternal _SmbiosInfo_default_instance_;
class StartCsrRequest;
struct StartCsrRequestDefaultTypeInternal;
extern StartCsrRequestDefaultTypeInternal _StartCsrRequest_default_instance_;
class StartCsrResponse;
struct StartCsrResponseDefaultTypeInternal;
extern StartCsrResponseDefaultTypeInternal _StartCsrResponse_default_instance_;
class StatefulPartitionInfo;
struct StatefulPartitionInfoDefaultTypeInternal;
extern StatefulPartitionInfoDefaultTypeInternal _StatefulPartitionInfo_default_instance_;
class StorageStatus;
struct StorageStatusDefaultTypeInternal;
extern StorageStatusDefaultTypeInternal _StorageStatus_default_instance_;
class SystemFreeRamInfo;
struct SystemFreeRamInfoDefaultTypeInternal;
extern SystemFreeRamInfoDefaultTypeInternal _SystemFreeRamInfo_default_instance_;
class SystemState;
struct SystemStateDefaultTypeInternal;
extern SystemStateDefaultTypeInternal _SystemState_default_instance_;
class SystemStatus;
struct SystemStatusDefaultTypeInternal;
extern SystemStatusDefaultTypeInternal _SystemStatus_default_instance_;
class ThermalInfo;
struct ThermalInfoDefaultTypeInternal;
extern ThermalInfoDefaultTypeInternal _ThermalInfo_default_instance_;
class ThermalSample;
struct ThermalSampleDefaultTypeInternal;
extern ThermalSampleDefaultTypeInternal _ThermalSample_default_instance_;
class TimePeriod;
struct TimePeriodDefaultTypeInternal;
extern TimePeriodDefaultTypeInternal _TimePeriod_default_instance_;
class TimezoneInfo;
struct TimezoneInfoDefaultTypeInternal;
extern TimezoneInfoDefaultTypeInternal _TimezoneInfo_default_instance_;
class TpmStatusInfo;
struct TpmStatusInfoDefaultTypeInternal;
extern TpmStatusInfoDefaultTypeInternal _TpmStatusInfo_default_instance_;
class TpmSupportedFeatures;
struct TpmSupportedFeaturesDefaultTypeInternal;
extern TpmSupportedFeaturesDefaultTypeInternal _TpmSupportedFeatures_default_instance_;
class TpmVersionInfo;
struct TpmVersionInfoDefaultTypeInternal;
extern TpmVersionInfoDefaultTypeInternal _TpmVersionInfo_default_instance_;
class UploadEuiccInfoRequest;
struct UploadEuiccInfoRequestDefaultTypeInternal;
extern UploadEuiccInfoRequestDefaultTypeInternal _UploadEuiccInfoRequest_default_instance_;
class UploadEuiccInfoResponse;
struct UploadEuiccInfoResponseDefaultTypeInternal;
extern UploadEuiccInfoResponseDefaultTypeInternal _UploadEuiccInfoResponse_default_instance_;
class VolumeInfo;
struct VolumeInfoDefaultTypeInternal;
extern VolumeInfoDefaultTypeInternal _VolumeInfo_default_instance_;
}  // namespace enterprise_management
PROTOBUF_NAMESPACE_OPEN
template<> ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryEnrollPlayUserRequest>(Arena*);
template<> ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryEnrollPlayUserResponse>(Arena*);
template<> ::enterprise_management::ActiveDirectoryPlayActivityRequest* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryPlayActivityRequest>(Arena*);
template<> ::enterprise_management::ActiveDirectoryPlayActivityResponse* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryPlayActivityResponse>(Arena*);
template<> ::enterprise_management::ActiveDirectoryUserSigninRequest* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryUserSigninRequest>(Arena*);
template<> ::enterprise_management::ActiveDirectoryUserSigninResponse* Arena::CreateMaybeMessage<::enterprise_management::ActiveDirectoryUserSigninResponse>(Arena*);
template<> ::enterprise_management::ActiveTimePeriod* Arena::CreateMaybeMessage<::enterprise_management::ActiveTimePeriod>(Arena*);
template<> ::enterprise_management::AndroidAppInfo* Arena::CreateMaybeMessage<::enterprise_management::AndroidAppInfo>(Arena*);
template<> ::enterprise_management::AndroidAppPermission* Arena::CreateMaybeMessage<::enterprise_management::AndroidAppPermission>(Arena*);
template<> ::enterprise_management::AndroidStatus* Arena::CreateMaybeMessage<::enterprise_management::AndroidStatus>(Arena*);
template<> ::enterprise_management::App* Arena::CreateMaybeMessage<::enterprise_management::App>(Arena*);
template<> ::enterprise_management::AppActivity* Arena::CreateMaybeMessage<::enterprise_management::AppActivity>(Arena*);
template<> ::enterprise_management::AppInfo* Arena::CreateMaybeMessage<::enterprise_management::AppInfo>(Arena*);
template<> ::enterprise_management::AppInstallReport* Arena::CreateMaybeMessage<::enterprise_management::AppInstallReport>(Arena*);
template<> ::enterprise_management::AppInstallReportLogEvent* Arena::CreateMaybeMessage<::enterprise_management::AppInstallReportLogEvent>(Arena*);
template<> ::enterprise_management::AppInstallReportRequest* Arena::CreateMaybeMessage<::enterprise_management::AppInstallReportRequest>(Arena*);
template<> ::enterprise_management::AppInstallReportResponse* Arena::CreateMaybeMessage<::enterprise_management::AppInstallReportResponse>(Arena*);
template<> ::enterprise_management::AppStatus* Arena::CreateMaybeMessage<::enterprise_management::AppStatus>(Arena*);
template<> ::enterprise_management::BacklightInfo* Arena::CreateMaybeMessage<::enterprise_management::BacklightInfo>(Arena*);
template<> ::enterprise_management::BatteryInfo* Arena::CreateMaybeMessage<::enterprise_management::BatteryInfo>(Arena*);
template<> ::enterprise_management::BatterySample* Arena::CreateMaybeMessage<::enterprise_management::BatterySample>(Arena*);
template<> ::enterprise_management::BluetoothAdapterInfo* Arena::CreateMaybeMessage<::enterprise_management::BluetoothAdapterInfo>(Arena*);
template<> ::enterprise_management::BoardStatus* Arena::CreateMaybeMessage<::enterprise_management::BoardStatus>(Arena*);
template<> ::enterprise_management::BootInfo* Arena::CreateMaybeMessage<::enterprise_management::BootInfo>(Arena*);
template<> ::enterprise_management::BrowserDeviceIdentifier* Arena::CreateMaybeMessage<::enterprise_management::BrowserDeviceIdentifier>(Arena*);
template<> ::enterprise_management::BrowserPublicKeyUploadRequest* Arena::CreateMaybeMessage<::enterprise_management::BrowserPublicKeyUploadRequest>(Arena*);
template<> ::enterprise_management::BrowserPublicKeyUploadResponse* Arena::CreateMaybeMessage<::enterprise_management::BrowserPublicKeyUploadResponse>(Arena*);
template<> ::enterprise_management::BrowserReport* Arena::CreateMaybeMessage<::enterprise_management::BrowserReport>(Arena*);
template<> ::enterprise_management::CPUTempInfo* Arena::CreateMaybeMessage<::enterprise_management::CPUTempInfo>(Arena*);
template<> ::enterprise_management::CertProvAuthorizeInstruction* Arena::CreateMaybeMessage<::enterprise_management::CertProvAuthorizeInstruction>(Arena*);
template<> ::enterprise_management::CertProvAuthorizeRequest* Arena::CreateMaybeMessage<::enterprise_management::CertProvAuthorizeRequest>(Arena*);
template<> ::enterprise_management::CertProvImportCertificateInstruction* Arena::CreateMaybeMessage<::enterprise_management::CertProvImportCertificateInstruction>(Arena*);
template<> ::enterprise_management::CertProvNextActionResponse* Arena::CreateMaybeMessage<::enterprise_management::CertProvNextActionResponse>(Arena*);
template<> ::enterprise_management::CertProvProofOfPossessionInstruction* Arena::CreateMaybeMessage<::enterprise_management::CertProvProofOfPossessionInstruction>(Arena*);
template<> ::enterprise_management::CertProvStartOrContinueRequest* Arena::CreateMaybeMessage<::enterprise_management::CertProvStartOrContinueRequest>(Arena*);
template<> ::enterprise_management::CertProvTryLaterInstruction* Arena::CreateMaybeMessage<::enterprise_management::CertProvTryLaterInstruction>(Arena*);
template<> ::enterprise_management::CertProvUploadProofOfPossessionRequest* Arena::CreateMaybeMessage<::enterprise_management::CertProvUploadProofOfPossessionRequest>(Arena*);
template<> ::enterprise_management::CertificateBasedDeviceRegisterRequest* Arena::CreateMaybeMessage<::enterprise_management::CertificateBasedDeviceRegisterRequest>(Arena*);
template<> ::enterprise_management::CertificateBasedDeviceRegistrationData* Arena::CreateMaybeMessage<::enterprise_management::CertificateBasedDeviceRegistrationData>(Arena*);
template<> ::enterprise_management::CheckAndroidManagementRequest* Arena::CreateMaybeMessage<::enterprise_management::CheckAndroidManagementRequest>(Arena*);
template<> ::enterprise_management::CheckAndroidManagementResponse* Arena::CreateMaybeMessage<::enterprise_management::CheckAndroidManagementResponse>(Arena*);
template<> ::enterprise_management::CheckDeviceLicenseRequest* Arena::CreateMaybeMessage<::enterprise_management::CheckDeviceLicenseRequest>(Arena*);
template<> ::enterprise_management::CheckDeviceLicenseResponse* Arena::CreateMaybeMessage<::enterprise_management::CheckDeviceLicenseResponse>(Arena*);
template<> ::enterprise_management::CheckDevicePairingRequest* Arena::CreateMaybeMessage<::enterprise_management::CheckDevicePairingRequest>(Arena*);
template<> ::enterprise_management::CheckDevicePairingResponse* Arena::CreateMaybeMessage<::enterprise_management::CheckDevicePairingResponse>(Arena*);
template<> ::enterprise_management::CheckUserAccountRequest* Arena::CreateMaybeMessage<::enterprise_management::CheckUserAccountRequest>(Arena*);
template<> ::enterprise_management::CheckUserAccountResponse* Arena::CreateMaybeMessage<::enterprise_management::CheckUserAccountResponse>(Arena*);
template<> ::enterprise_management::ChildStatusReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ChildStatusReportRequest>(Arena*);
template<> ::enterprise_management::ChildStatusReportResponse* Arena::CreateMaybeMessage<::enterprise_management::ChildStatusReportResponse>(Arena*);
template<> ::enterprise_management::ChromeDesktopReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ChromeDesktopReportRequest>(Arena*);
template<> ::enterprise_management::ChromeDesktopReportResponse* Arena::CreateMaybeMessage<::enterprise_management::ChromeDesktopReportResponse>(Arena*);
template<> ::enterprise_management::ChromeOsUserReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ChromeOsUserReportRequest>(Arena*);
template<> ::enterprise_management::ChromeOsUserReportResponse* Arena::CreateMaybeMessage<::enterprise_management::ChromeOsUserReportResponse>(Arena*);
template<> ::enterprise_management::ChromeProfileReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ChromeProfileReportRequest>(Arena*);
template<> ::enterprise_management::ChromeProfileReportResponse* Arena::CreateMaybeMessage<::enterprise_management::ChromeProfileReportResponse>(Arena*);
template<> ::enterprise_management::ChromeSignedInUser* Arena::CreateMaybeMessage<::enterprise_management::ChromeSignedInUser>(Arena*);
template<> ::enterprise_management::ChromeUserProfileInfo* Arena::CreateMaybeMessage<::enterprise_management::ChromeUserProfileInfo>(Arena*);
template<> ::enterprise_management::ChromeUserProfileReport* Arena::CreateMaybeMessage<::enterprise_management::ChromeUserProfileReport>(Arena*);
template<> ::enterprise_management::ClientActionRequired* Arena::CreateMaybeMessage<::enterprise_management::ClientActionRequired>(Arena*);
template<> ::enterprise_management::ClientCertificateProvisioningRequest* Arena::CreateMaybeMessage<::enterprise_management::ClientCertificateProvisioningRequest>(Arena*);
template<> ::enterprise_management::ClientCertificateProvisioningResponse* Arena::CreateMaybeMessage<::enterprise_management::ClientCertificateProvisioningResponse>(Arena*);
template<> ::enterprise_management::CpuCStateInfo* Arena::CreateMaybeMessage<::enterprise_management::CpuCStateInfo>(Arena*);
template<> ::enterprise_management::CpuInfo* Arena::CreateMaybeMessage<::enterprise_management::CpuInfo>(Arena*);
template<> ::enterprise_management::CpuUtilizationInfo* Arena::CreateMaybeMessage<::enterprise_management::CpuUtilizationInfo>(Arena*);
template<> ::enterprise_management::CrashReportInfo* Arena::CreateMaybeMessage<::enterprise_management::CrashReportInfo>(Arena*);
template<> ::enterprise_management::CrostiniApp* Arena::CreateMaybeMessage<::enterprise_management::CrostiniApp>(Arena*);
template<> ::enterprise_management::CrostiniStatus* Arena::CreateMaybeMessage<::enterprise_management::CrostiniStatus>(Arena*);
template<> ::enterprise_management::CustomerLogo* Arena::CreateMaybeMessage<::enterprise_management::CustomerLogo>(Arena*);
template<> ::enterprise_management::DEPRECATEDPolicyPublicKeyAndDomain* Arena::CreateMaybeMessage<::enterprise_management::DEPRECATEDPolicyPublicKeyAndDomain>(Arena*);
template<> ::enterprise_management::DeviceAttributeUpdatePermissionRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdatePermissionRequest>(Arena*);
template<> ::enterprise_management::DeviceAttributeUpdatePermissionResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdatePermissionResponse>(Arena*);
template<> ::enterprise_management::DeviceAttributeUpdateRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdateRequest>(Arena*);
template<> ::enterprise_management::DeviceAttributeUpdateResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdateResponse>(Arena*);
template<> ::enterprise_management::DeviceAutoEnrollmentRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceAutoEnrollmentRequest>(Arena*);
template<> ::enterprise_management::DeviceAutoEnrollmentResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceAutoEnrollmentResponse>(Arena*);
template<> ::enterprise_management::DeviceCertUploadRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceCertUploadRequest>(Arena*);
template<> ::enterprise_management::DeviceCertUploadResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceCertUploadResponse>(Arena*);
template<> ::enterprise_management::DeviceInitialEnrollmentStateRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateRequest>(Arena*);
template<> ::enterprise_management::DeviceInitialEnrollmentStateResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateResponse>(Arena*);
template<> ::enterprise_management::DeviceManagementRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceManagementRequest>(Arena*);
template<> ::enterprise_management::DeviceManagementResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceManagementResponse>(Arena*);
template<> ::enterprise_management::DevicePairingRequest* Arena::CreateMaybeMessage<::enterprise_management::DevicePairingRequest>(Arena*);
template<> ::enterprise_management::DevicePairingResponse* Arena::CreateMaybeMessage<::enterprise_management::DevicePairingResponse>(Arena*);
template<> ::enterprise_management::DevicePolicyRequest* Arena::CreateMaybeMessage<::enterprise_management::DevicePolicyRequest>(Arena*);
template<> ::enterprise_management::DevicePolicyResponse* Arena::CreateMaybeMessage<::enterprise_management::DevicePolicyResponse>(Arena*);
template<> ::enterprise_management::DeviceRegisterConfiguration* Arena::CreateMaybeMessage<::enterprise_management::DeviceRegisterConfiguration>(Arena*);
template<> ::enterprise_management::DeviceRegisterIdentification* Arena::CreateMaybeMessage<::enterprise_management::DeviceRegisterIdentification>(Arena*);
template<> ::enterprise_management::DeviceRegisterRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceRegisterRequest>(Arena*);
template<> ::enterprise_management::DeviceRegisterResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceRegisterResponse>(Arena*);
template<> ::enterprise_management::DeviceRemoteCommandRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceRemoteCommandRequest>(Arena*);
template<> ::enterprise_management::DeviceRemoteCommandResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceRemoteCommandResponse>(Arena*);
template<> ::enterprise_management::DeviceServiceApiAccessRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceServiceApiAccessRequest>(Arena*);
template<> ::enterprise_management::DeviceServiceApiAccessResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceServiceApiAccessResponse>(Arena*);
template<> ::enterprise_management::DeviceState* Arena::CreateMaybeMessage<::enterprise_management::DeviceState>(Arena*);
template<> ::enterprise_management::DeviceStateKeyUpdateRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceStateKeyUpdateRequest>(Arena*);
template<> ::enterprise_management::DeviceStateRetrievalInfo* Arena::CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalInfo>(Arena*);
template<> ::enterprise_management::DeviceStateRetrievalRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalRequest>(Arena*);
template<> ::enterprise_management::DeviceStateRetrievalResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalResponse>(Arena*);
template<> ::enterprise_management::DeviceStatusReportRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceStatusReportRequest>(Arena*);
template<> ::enterprise_management::DeviceStatusReportResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceStatusReportResponse>(Arena*);
template<> ::enterprise_management::DeviceUnregisterRequest* Arena::CreateMaybeMessage<::enterprise_management::DeviceUnregisterRequest>(Arena*);
template<> ::enterprise_management::DeviceUnregisterResponse* Arena::CreateMaybeMessage<::enterprise_management::DeviceUnregisterResponse>(Arena*);
template<> ::enterprise_management::DeviceUser* Arena::CreateMaybeMessage<::enterprise_management::DeviceUser>(Arena*);
template<> ::enterprise_management::DisabledState* Arena::CreateMaybeMessage<::enterprise_management::DisabledState>(Arena*);
template<> ::enterprise_management::DiskInfo* Arena::CreateMaybeMessage<::enterprise_management::DiskInfo>(Arena*);
template<> ::enterprise_management::DiskLifetimeEstimation* Arena::CreateMaybeMessage<::enterprise_management::DiskLifetimeEstimation>(Arena*);
template<> ::enterprise_management::DisplayInfo* Arena::CreateMaybeMessage<::enterprise_management::DisplayInfo>(Arena*);
template<> ::enterprise_management::DownloadCertRequest* Arena::CreateMaybeMessage<::enterprise_management::DownloadCertRequest>(Arena*);
template<> ::enterprise_management::DownloadCertResponse* Arena::CreateMaybeMessage<::enterprise_management::DownloadCertResponse>(Arena*);
template<> ::enterprise_management::EFIVars* Arena::CreateMaybeMessage<::enterprise_management::EFIVars>(Arena*);
template<> ::enterprise_management::ESimProfileInfo* Arena::CreateMaybeMessage<::enterprise_management::ESimProfileInfo>(Arena*);
template<> ::enterprise_management::Extension* Arena::CreateMaybeMessage<::enterprise_management::Extension>(Arena*);
template<> ::enterprise_management::ExtensionInstallReport* Arena::CreateMaybeMessage<::enterprise_management::ExtensionInstallReport>(Arena*);
template<> ::enterprise_management::ExtensionInstallReportLogEvent* Arena::CreateMaybeMessage<::enterprise_management::ExtensionInstallReportLogEvent>(Arena*);
template<> ::enterprise_management::ExtensionInstallReportRequest* Arena::CreateMaybeMessage<::enterprise_management::ExtensionInstallReportRequest>(Arena*);
template<> ::enterprise_management::ExtensionPolicy* Arena::CreateMaybeMessage<::enterprise_management::ExtensionPolicy>(Arena*);
template<> ::enterprise_management::ExtensionRequest* Arena::CreateMaybeMessage<::enterprise_management::ExtensionRequest>(Arena*);
template<> ::enterprise_management::FanInfo* Arena::CreateMaybeMessage<::enterprise_management::FanInfo>(Arena*);
template<> ::enterprise_management::FinishCsrRequest* Arena::CreateMaybeMessage<::enterprise_management::FinishCsrRequest>(Arena*);
template<> ::enterprise_management::FinishCsrResponse* Arena::CreateMaybeMessage<::enterprise_management::FinishCsrResponse>(Arena*);
template<> ::enterprise_management::GcmIdUpdateRequest* Arena::CreateMaybeMessage<::enterprise_management::GcmIdUpdateRequest>(Arena*);
template<> ::enterprise_management::GcmIdUpdateResponse* Arena::CreateMaybeMessage<::enterprise_management::GcmIdUpdateResponse>(Arena*);
template<> ::enterprise_management::GlobalCpuInfo* Arena::CreateMaybeMessage<::enterprise_management::GlobalCpuInfo>(Arena*);
template<> ::enterprise_management::GraphicsAdapterInfo* Arena::CreateMaybeMessage<::enterprise_management::GraphicsAdapterInfo>(Arena*);
template<> ::enterprise_management::GraphicsStatus* Arena::CreateMaybeMessage<::enterprise_management::GraphicsStatus>(Arena*);
template<> ::enterprise_management::KernelParameters* Arena::CreateMaybeMessage<::enterprise_management::KernelParameters>(Arena*);
template<> ::enterprise_management::LaCrOsBrowserReport* Arena::CreateMaybeMessage<::enterprise_management::LaCrOsBrowserReport>(Arena*);
template<> ::enterprise_management::LicenseAvailability* Arena::CreateMaybeMessage<::enterprise_management::LicenseAvailability>(Arena*);
template<> ::enterprise_management::LicenseType* Arena::CreateMaybeMessage<::enterprise_management::LicenseType>(Arena*);
template<> ::enterprise_management::LogicalCpuInfo* Arena::CreateMaybeMessage<::enterprise_management::LogicalCpuInfo>(Arena*);
template<> ::enterprise_management::MemoryInfo* Arena::CreateMaybeMessage<::enterprise_management::MemoryInfo>(Arena*);
template<> ::enterprise_management::NetworkAdapterInfo* Arena::CreateMaybeMessage<::enterprise_management::NetworkAdapterInfo>(Arena*);
template<> ::enterprise_management::NetworkInterface* Arena::CreateMaybeMessage<::enterprise_management::NetworkInterface>(Arena*);
template<> ::enterprise_management::NetworkState* Arena::CreateMaybeMessage<::enterprise_management::NetworkState>(Arena*);
template<> ::enterprise_management::OSReport* Arena::CreateMaybeMessage<::enterprise_management::OSReport>(Arena*);
template<> ::enterprise_management::OsUpdateStatus* Arena::CreateMaybeMessage<::enterprise_management::OsUpdateStatus>(Arena*);
template<> ::enterprise_management::Plugin* Arena::CreateMaybeMessage<::enterprise_management::Plugin>(Arena*);
template<> ::enterprise_management::Policy* Arena::CreateMaybeMessage<::enterprise_management::Policy>(Arena*);
template<> ::enterprise_management::PolicyData* Arena::CreateMaybeMessage<::enterprise_management::PolicyData>(Arena*);
template<> ::enterprise_management::PolicyFetchRequest* Arena::CreateMaybeMessage<::enterprise_management::PolicyFetchRequest>(Arena*);
template<> ::enterprise_management::PolicyFetchResponse* Arena::CreateMaybeMessage<::enterprise_management::PolicyFetchResponse>(Arena*);
template<> ::enterprise_management::PolicyFetchTimestamp* Arena::CreateMaybeMessage<::enterprise_management::PolicyFetchTimestamp>(Arena*);
template<> ::enterprise_management::PolicyValidationReportRequest* Arena::CreateMaybeMessage<::enterprise_management::PolicyValidationReportRequest>(Arena*);
template<> ::enterprise_management::PolicyValidationReportResponse* Arena::CreateMaybeMessage<::enterprise_management::PolicyValidationReportResponse>(Arena*);
template<> ::enterprise_management::PolicyValueValidationIssue* Arena::CreateMaybeMessage<::enterprise_management::PolicyValueValidationIssue>(Arena*);
template<> ::enterprise_management::PowerStatus* Arena::CreateMaybeMessage<::enterprise_management::PowerStatus>(Arena*);
template<> ::enterprise_management::PrintJobEvent* Arena::CreateMaybeMessage<::enterprise_management::PrintJobEvent>(Arena*);
template<> ::enterprise_management::PrintJobEvent_PrintJobConfiguration* Arena::CreateMaybeMessage<::enterprise_management::PrintJobEvent_PrintJobConfiguration>(Arena*);
template<> ::enterprise_management::PrintJobEvent_PrintSettings* Arena::CreateMaybeMessage<::enterprise_management::PrintJobEvent_PrintSettings>(Arena*);
template<> ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* Arena::CreateMaybeMessage<::enterprise_management::PrintJobEvent_PrintSettings_MediaSize>(Arena*);
template<> ::enterprise_management::PrintJobEvent_Printer* Arena::CreateMaybeMessage<::enterprise_management::PrintJobEvent_Printer>(Arena*);
template<> ::enterprise_management::PrivateSetMembershipRequest* Arena::CreateMaybeMessage<::enterprise_management::PrivateSetMembershipRequest>(Arena*);
template<> ::enterprise_management::PrivateSetMembershipResponse* Arena::CreateMaybeMessage<::enterprise_management::PrivateSetMembershipResponse>(Arena*);
template<> ::enterprise_management::PrivateSetMembershipRlweRequest* Arena::CreateMaybeMessage<::enterprise_management::PrivateSetMembershipRlweRequest>(Arena*);
template<> ::enterprise_management::PrivateSetMembershipRlweResponse* Arena::CreateMaybeMessage<::enterprise_management::PrivateSetMembershipRlweResponse>(Arena*);
template<> ::enterprise_management::PublicKeyVerificationData* Arena::CreateMaybeMessage<::enterprise_management::PublicKeyVerificationData>(Arena*);
template<> ::enterprise_management::PublicSamlUserRequest* Arena::CreateMaybeMessage<::enterprise_management::PublicSamlUserRequest>(Arena*);
template<> ::enterprise_management::PublicSamlUserResponse* Arena::CreateMaybeMessage<::enterprise_management::PublicSamlUserResponse>(Arena*);
template<> ::enterprise_management::RefreshAccountRequest* Arena::CreateMaybeMessage<::enterprise_management::RefreshAccountRequest>(Arena*);
template<> ::enterprise_management::RefreshAccountResponse* Arena::CreateMaybeMessage<::enterprise_management::RefreshAccountResponse>(Arena*);
template<> ::enterprise_management::RegisterBrowserRequest* Arena::CreateMaybeMessage<::enterprise_management::RegisterBrowserRequest>(Arena*);
template<> ::enterprise_management::RemoteCommand* Arena::CreateMaybeMessage<::enterprise_management::RemoteCommand>(Arena*);
template<> ::enterprise_management::RemoteCommandResult* Arena::CreateMaybeMessage<::enterprise_management::RemoteCommandResult>(Arena*);
template<> ::enterprise_management::RsuLookupKeyUploadRequest* Arena::CreateMaybeMessage<::enterprise_management::RsuLookupKeyUploadRequest>(Arena*);
template<> ::enterprise_management::RsuLookupKeyUploadResponse* Arena::CreateMaybeMessage<::enterprise_management::RsuLookupKeyUploadResponse>(Arena*);
template<> ::enterprise_management::SamlParametersProto* Arena::CreateMaybeMessage<::enterprise_management::SamlParametersProto>(Arena*);
template<> ::enterprise_management::ScreenTimeSpan* Arena::CreateMaybeMessage<::enterprise_management::ScreenTimeSpan>(Arena*);
template<> ::enterprise_management::SessionStatusReportRequest* Arena::CreateMaybeMessage<::enterprise_management::SessionStatusReportRequest>(Arena*);
template<> ::enterprise_management::SessionStatusReportResponse* Arena::CreateMaybeMessage<::enterprise_management::SessionStatusReportResponse>(Arena*);
template<> ::enterprise_management::SignedData* Arena::CreateMaybeMessage<::enterprise_management::SignedData>(Arena*);
template<> ::enterprise_management::SmbiosInfo* Arena::CreateMaybeMessage<::enterprise_management::SmbiosInfo>(Arena*);
template<> ::enterprise_management::StartCsrRequest* Arena::CreateMaybeMessage<::enterprise_management::StartCsrRequest>(Arena*);
template<> ::enterprise_management::StartCsrResponse* Arena::CreateMaybeMessage<::enterprise_management::StartCsrResponse>(Arena*);
template<> ::enterprise_management::StatefulPartitionInfo* Arena::CreateMaybeMessage<::enterprise_management::StatefulPartitionInfo>(Arena*);
template<> ::enterprise_management::StorageStatus* Arena::CreateMaybeMessage<::enterprise_management::StorageStatus>(Arena*);
template<> ::enterprise_management::SystemFreeRamInfo* Arena::CreateMaybeMessage<::enterprise_management::SystemFreeRamInfo>(Arena*);
template<> ::enterprise_management::SystemState* Arena::CreateMaybeMessage<::enterprise_management::SystemState>(Arena*);
template<> ::enterprise_management::SystemStatus* Arena::CreateMaybeMessage<::enterprise_management::SystemStatus>(Arena*);
template<> ::enterprise_management::ThermalInfo* Arena::CreateMaybeMessage<::enterprise_management::ThermalInfo>(Arena*);
template<> ::enterprise_management::ThermalSample* Arena::CreateMaybeMessage<::enterprise_management::ThermalSample>(Arena*);
template<> ::enterprise_management::TimePeriod* Arena::CreateMaybeMessage<::enterprise_management::TimePeriod>(Arena*);
template<> ::enterprise_management::TimezoneInfo* Arena::CreateMaybeMessage<::enterprise_management::TimezoneInfo>(Arena*);
template<> ::enterprise_management::TpmStatusInfo* Arena::CreateMaybeMessage<::enterprise_management::TpmStatusInfo>(Arena*);
template<> ::enterprise_management::TpmSupportedFeatures* Arena::CreateMaybeMessage<::enterprise_management::TpmSupportedFeatures>(Arena*);
template<> ::enterprise_management::TpmVersionInfo* Arena::CreateMaybeMessage<::enterprise_management::TpmVersionInfo>(Arena*);
template<> ::enterprise_management::UploadEuiccInfoRequest* Arena::CreateMaybeMessage<::enterprise_management::UploadEuiccInfoRequest>(Arena*);
template<> ::enterprise_management::UploadEuiccInfoResponse* Arena::CreateMaybeMessage<::enterprise_management::UploadEuiccInfoResponse>(Arena*);
template<> ::enterprise_management::VolumeInfo* Arena::CreateMaybeMessage<::enterprise_management::VolumeInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace enterprise_management {

enum LicenseType_LicenseTypeEnum : int {
  LicenseType_LicenseTypeEnum_UNDEFINED = 0,
  LicenseType_LicenseTypeEnum_CDM_PERPETUAL = 1,
  LicenseType_LicenseTypeEnum_CDM_ANNUAL = 2,
  LicenseType_LicenseTypeEnum_KIOSK = 3,
  LicenseType_LicenseTypeEnum_CDM_PACKAGED = 4
};
bool LicenseType_LicenseTypeEnum_IsValid(int value);
constexpr LicenseType_LicenseTypeEnum LicenseType_LicenseTypeEnum_LicenseTypeEnum_MIN = LicenseType_LicenseTypeEnum_UNDEFINED;
constexpr LicenseType_LicenseTypeEnum LicenseType_LicenseTypeEnum_LicenseTypeEnum_MAX = LicenseType_LicenseTypeEnum_CDM_PACKAGED;
constexpr int LicenseType_LicenseTypeEnum_LicenseTypeEnum_ARRAYSIZE = LicenseType_LicenseTypeEnum_LicenseTypeEnum_MAX + 1;

const std::string& LicenseType_LicenseTypeEnum_Name(LicenseType_LicenseTypeEnum value);
template<typename T>
inline const std::string& LicenseType_LicenseTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LicenseType_LicenseTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LicenseType_LicenseTypeEnum_Name.");
  return LicenseType_LicenseTypeEnum_Name(static_cast<LicenseType_LicenseTypeEnum>(enum_t_value));
}
bool LicenseType_LicenseTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LicenseType_LicenseTypeEnum* value);
enum DeviceRegisterRequest_Type : int {
  DeviceRegisterRequest_Type_TT = 0,
  DeviceRegisterRequest_Type_USER = 1,
  DeviceRegisterRequest_Type_DEVICE = 2,
  DeviceRegisterRequest_Type_BROWSER = 3,
  DeviceRegisterRequest_Type_ANDROID_BROWSER = 4,
  DeviceRegisterRequest_Type_IOS_BROWSER = 6
};
bool DeviceRegisterRequest_Type_IsValid(int value);
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest_Type_Type_MIN = DeviceRegisterRequest_Type_TT;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest_Type_Type_MAX = DeviceRegisterRequest_Type_IOS_BROWSER;
constexpr int DeviceRegisterRequest_Type_Type_ARRAYSIZE = DeviceRegisterRequest_Type_Type_MAX + 1;

const std::string& DeviceRegisterRequest_Type_Name(DeviceRegisterRequest_Type value);
template<typename T>
inline const std::string& DeviceRegisterRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceRegisterRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceRegisterRequest_Type_Name.");
  return DeviceRegisterRequest_Type_Name(static_cast<DeviceRegisterRequest_Type>(enum_t_value));
}
bool DeviceRegisterRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterRequest_Type* value);
enum DeviceRegisterRequest_Flavor : int {
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL = 0,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL_RENEW = 1,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_FORCED = 2,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_ADVERTISED = 3,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_FORCED = 4,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_ADVERTISED = 5,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_RECOVERY = 6,
  DeviceRegisterRequest_Flavor_FLAVOR_USER_REGISTRATION = 7,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION = 8,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED = 9,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED = 10,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK = 11,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED = 13,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED = 14,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK = 15,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_FORCED = 16,
  DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_MANUAL_FALLBACK = 17
};
bool DeviceRegisterRequest_Flavor_IsValid(int value);
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest_Flavor_Flavor_MIN = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest_Flavor_Flavor_MAX = DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_MANUAL_FALLBACK;
constexpr int DeviceRegisterRequest_Flavor_Flavor_ARRAYSIZE = DeviceRegisterRequest_Flavor_Flavor_MAX + 1;

const std::string& DeviceRegisterRequest_Flavor_Name(DeviceRegisterRequest_Flavor value);
template<typename T>
inline const std::string& DeviceRegisterRequest_Flavor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceRegisterRequest_Flavor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceRegisterRequest_Flavor_Name.");
  return DeviceRegisterRequest_Flavor_Name(static_cast<DeviceRegisterRequest_Flavor>(enum_t_value));
}
bool DeviceRegisterRequest_Flavor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterRequest_Flavor* value);
enum DeviceRegisterRequest_Lifetime : int {
  DeviceRegisterRequest_Lifetime_LIFETIME_UNDEFINED = 0,
  DeviceRegisterRequest_Lifetime_LIFETIME_INDEFINITE = 1,
  DeviceRegisterRequest_Lifetime_LIFETIME_EPHEMERAL_USER = 2
};
bool DeviceRegisterRequest_Lifetime_IsValid(int value);
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest_Lifetime_Lifetime_MIN = DeviceRegisterRequest_Lifetime_LIFETIME_UNDEFINED;
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest_Lifetime_Lifetime_MAX = DeviceRegisterRequest_Lifetime_LIFETIME_EPHEMERAL_USER;
constexpr int DeviceRegisterRequest_Lifetime_Lifetime_ARRAYSIZE = DeviceRegisterRequest_Lifetime_Lifetime_MAX + 1;

const std::string& DeviceRegisterRequest_Lifetime_Name(DeviceRegisterRequest_Lifetime value);
template<typename T>
inline const std::string& DeviceRegisterRequest_Lifetime_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceRegisterRequest_Lifetime>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceRegisterRequest_Lifetime_Name.");
  return DeviceRegisterRequest_Lifetime_Name(static_cast<DeviceRegisterRequest_Lifetime>(enum_t_value));
}
bool DeviceRegisterRequest_Lifetime_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterRequest_Lifetime* value);
enum DeviceRegisterRequest_PsmExecutionResult : int {
  DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_UNKNOWN = 0,
  DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_SUCCESSFUL_WITH_STATE = 1,
  DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_SUCCESSFUL_WITHOUT_STATE = 2,
  DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_ERROR = 3
};
bool DeviceRegisterRequest_PsmExecutionResult_IsValid(int value);
constexpr DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest_PsmExecutionResult_PsmExecutionResult_MIN = DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_UNKNOWN;
constexpr DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest_PsmExecutionResult_PsmExecutionResult_MAX = DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_ERROR;
constexpr int DeviceRegisterRequest_PsmExecutionResult_PsmExecutionResult_ARRAYSIZE = DeviceRegisterRequest_PsmExecutionResult_PsmExecutionResult_MAX + 1;

const std::string& DeviceRegisterRequest_PsmExecutionResult_Name(DeviceRegisterRequest_PsmExecutionResult value);
template<typename T>
inline const std::string& DeviceRegisterRequest_PsmExecutionResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceRegisterRequest_PsmExecutionResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceRegisterRequest_PsmExecutionResult_Name.");
  return DeviceRegisterRequest_PsmExecutionResult_Name(static_cast<DeviceRegisterRequest_PsmExecutionResult>(enum_t_value));
}
bool DeviceRegisterRequest_PsmExecutionResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterRequest_PsmExecutionResult* value);
enum CheckUserAccountResponse_UserAccountType : int {
  CheckUserAccountResponse_UserAccountType_UNKNOWN_USER_ACCOUNT_TYPE = 0,
  CheckUserAccountResponse_UserAccountType_NOT_EXIST = 1,
  CheckUserAccountResponse_UserAccountType_CONSUMER = 2,
  CheckUserAccountResponse_UserAccountType_DASHER = 3
};
bool CheckUserAccountResponse_UserAccountType_IsValid(int value);
constexpr CheckUserAccountResponse_UserAccountType CheckUserAccountResponse_UserAccountType_UserAccountType_MIN = CheckUserAccountResponse_UserAccountType_UNKNOWN_USER_ACCOUNT_TYPE;
constexpr CheckUserAccountResponse_UserAccountType CheckUserAccountResponse_UserAccountType_UserAccountType_MAX = CheckUserAccountResponse_UserAccountType_DASHER;
constexpr int CheckUserAccountResponse_UserAccountType_UserAccountType_ARRAYSIZE = CheckUserAccountResponse_UserAccountType_UserAccountType_MAX + 1;

const std::string& CheckUserAccountResponse_UserAccountType_Name(CheckUserAccountResponse_UserAccountType value);
template<typename T>
inline const std::string& CheckUserAccountResponse_UserAccountType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckUserAccountResponse_UserAccountType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckUserAccountResponse_UserAccountType_Name.");
  return CheckUserAccountResponse_UserAccountType_Name(static_cast<CheckUserAccountResponse_UserAccountType>(enum_t_value));
}
bool CheckUserAccountResponse_UserAccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckUserAccountResponse_UserAccountType* value);
enum DeviceRegisterResponse_DeviceMode : int {
  DeviceRegisterResponse_DeviceMode_ENTERPRISE = 0,
  DeviceRegisterResponse_DeviceMode_RETAIL_DEPRECATED = 1,
  DeviceRegisterResponse_DeviceMode_CHROME_AD = 2,
  DeviceRegisterResponse_DeviceMode_DEMO = 3
};
bool DeviceRegisterResponse_DeviceMode_IsValid(int value);
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse_DeviceMode_DeviceMode_MIN = DeviceRegisterResponse_DeviceMode_ENTERPRISE;
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse_DeviceMode_DeviceMode_MAX = DeviceRegisterResponse_DeviceMode_DEMO;
constexpr int DeviceRegisterResponse_DeviceMode_DeviceMode_ARRAYSIZE = DeviceRegisterResponse_DeviceMode_DeviceMode_MAX + 1;

const std::string& DeviceRegisterResponse_DeviceMode_Name(DeviceRegisterResponse_DeviceMode value);
template<typename T>
inline const std::string& DeviceRegisterResponse_DeviceMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceRegisterResponse_DeviceMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceRegisterResponse_DeviceMode_Name.");
  return DeviceRegisterResponse_DeviceMode_Name(static_cast<DeviceRegisterResponse_DeviceMode>(enum_t_value));
}
bool DeviceRegisterResponse_DeviceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterResponse_DeviceMode* value);
enum DeviceCertUploadRequest_CertificateType : int {
  DeviceCertUploadRequest_CertificateType_CERTIFICATE_TYPE_UNSPECIFIED = 0,
  DeviceCertUploadRequest_CertificateType_ENTERPRISE_MACHINE_CERTIFICATE = 1,
  DeviceCertUploadRequest_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE = 2
};
bool DeviceCertUploadRequest_CertificateType_IsValid(int value);
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest_CertificateType_CertificateType_MIN = DeviceCertUploadRequest_CertificateType_CERTIFICATE_TYPE_UNSPECIFIED;
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest_CertificateType_CertificateType_MAX = DeviceCertUploadRequest_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
constexpr int DeviceCertUploadRequest_CertificateType_CertificateType_ARRAYSIZE = DeviceCertUploadRequest_CertificateType_CertificateType_MAX + 1;

const std::string& DeviceCertUploadRequest_CertificateType_Name(DeviceCertUploadRequest_CertificateType value);
template<typename T>
inline const std::string& DeviceCertUploadRequest_CertificateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceCertUploadRequest_CertificateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceCertUploadRequest_CertificateType_Name.");
  return DeviceCertUploadRequest_CertificateType_Name(static_cast<DeviceCertUploadRequest_CertificateType>(enum_t_value));
}
bool DeviceCertUploadRequest_CertificateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceCertUploadRequest_CertificateType* value);
enum DeviceServiceApiAccessRequest_DeviceType : int {
  DeviceServiceApiAccessRequest_DeviceType_CHROME_OS = 0,
  DeviceServiceApiAccessRequest_DeviceType_ANDROID_OS = 1,
  DeviceServiceApiAccessRequest_DeviceType_CHROME_OS_DEMO_MODE = 2,
  DeviceServiceApiAccessRequest_DeviceType_CHROME_BROWSER = 3
};
bool DeviceServiceApiAccessRequest_DeviceType_IsValid(int value);
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest_DeviceType_DeviceType_MIN = DeviceServiceApiAccessRequest_DeviceType_CHROME_OS;
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX = DeviceServiceApiAccessRequest_DeviceType_CHROME_BROWSER;
constexpr int DeviceServiceApiAccessRequest_DeviceType_DeviceType_ARRAYSIZE = DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX + 1;

const std::string& DeviceServiceApiAccessRequest_DeviceType_Name(DeviceServiceApiAccessRequest_DeviceType value);
template<typename T>
inline const std::string& DeviceServiceApiAccessRequest_DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceServiceApiAccessRequest_DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceServiceApiAccessRequest_DeviceType_Name.");
  return DeviceServiceApiAccessRequest_DeviceType_Name(static_cast<DeviceServiceApiAccessRequest_DeviceType>(enum_t_value));
}
bool DeviceServiceApiAccessRequest_DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceServiceApiAccessRequest_DeviceType* value);
enum PolicyFetchRequest_SignatureType : int {
  PolicyFetchRequest_SignatureType_NONE = 0,
  PolicyFetchRequest_SignatureType_SHA1_RSA = 1,
  PolicyFetchRequest_SignatureType_SHA256_RSA = 2
};
bool PolicyFetchRequest_SignatureType_IsValid(int value);
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest_SignatureType_SignatureType_MIN = PolicyFetchRequest_SignatureType_NONE;
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest_SignatureType_SignatureType_MAX = PolicyFetchRequest_SignatureType_SHA256_RSA;
constexpr int PolicyFetchRequest_SignatureType_SignatureType_ARRAYSIZE = PolicyFetchRequest_SignatureType_SignatureType_MAX + 1;

const std::string& PolicyFetchRequest_SignatureType_Name(PolicyFetchRequest_SignatureType value);
template<typename T>
inline const std::string& PolicyFetchRequest_SignatureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyFetchRequest_SignatureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyFetchRequest_SignatureType_Name.");
  return PolicyFetchRequest_SignatureType_Name(static_cast<PolicyFetchRequest_SignatureType>(enum_t_value));
}
bool PolicyFetchRequest_SignatureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyFetchRequest_SignatureType* value);
enum DeviceState_DeviceMode : int {
  DeviceState_DeviceMode_DEVICE_MODE_NORMAL = 0,
  DeviceState_DeviceMode_DEVICE_MODE_DISABLED = 1
};
bool DeviceState_DeviceMode_IsValid(int value);
constexpr DeviceState_DeviceMode DeviceState_DeviceMode_DeviceMode_MIN = DeviceState_DeviceMode_DEVICE_MODE_NORMAL;
constexpr DeviceState_DeviceMode DeviceState_DeviceMode_DeviceMode_MAX = DeviceState_DeviceMode_DEVICE_MODE_DISABLED;
constexpr int DeviceState_DeviceMode_DeviceMode_ARRAYSIZE = DeviceState_DeviceMode_DeviceMode_MAX + 1;

const std::string& DeviceState_DeviceMode_Name(DeviceState_DeviceMode value);
template<typename T>
inline const std::string& DeviceState_DeviceMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceState_DeviceMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceState_DeviceMode_Name.");
  return DeviceState_DeviceMode_Name(static_cast<DeviceState_DeviceMode>(enum_t_value));
}
bool DeviceState_DeviceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceState_DeviceMode* value);
enum PolicyData_AssociationState : int {
  PolicyData_AssociationState_ACTIVE = 0,
  PolicyData_AssociationState_UNMANAGED = 1,
  PolicyData_AssociationState_DEPROVISIONED = 2
};
bool PolicyData_AssociationState_IsValid(int value);
constexpr PolicyData_AssociationState PolicyData_AssociationState_AssociationState_MIN = PolicyData_AssociationState_ACTIVE;
constexpr PolicyData_AssociationState PolicyData_AssociationState_AssociationState_MAX = PolicyData_AssociationState_DEPROVISIONED;
constexpr int PolicyData_AssociationState_AssociationState_ARRAYSIZE = PolicyData_AssociationState_AssociationState_MAX + 1;

const std::string& PolicyData_AssociationState_Name(PolicyData_AssociationState value);
template<typename T>
inline const std::string& PolicyData_AssociationState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyData_AssociationState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyData_AssociationState_Name.");
  return PolicyData_AssociationState_Name(static_cast<PolicyData_AssociationState>(enum_t_value));
}
bool PolicyData_AssociationState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyData_AssociationState* value);
enum PolicyData_ManagementMode : int {
  PolicyData_ManagementMode_LOCAL_OWNER = 0,
  PolicyData_ManagementMode_ENTERPRISE_MANAGED = 1,
  PolicyData_ManagementMode_OBSOLETE_CONSUMER_MANAGED = 2
};
bool PolicyData_ManagementMode_IsValid(int value);
constexpr PolicyData_ManagementMode PolicyData_ManagementMode_ManagementMode_MIN = PolicyData_ManagementMode_LOCAL_OWNER;
constexpr PolicyData_ManagementMode PolicyData_ManagementMode_ManagementMode_MAX = PolicyData_ManagementMode_OBSOLETE_CONSUMER_MANAGED;
constexpr int PolicyData_ManagementMode_ManagementMode_ARRAYSIZE = PolicyData_ManagementMode_ManagementMode_MAX + 1;

const std::string& PolicyData_ManagementMode_Name(PolicyData_ManagementMode value);
template<typename T>
inline const std::string& PolicyData_ManagementMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyData_ManagementMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyData_ManagementMode_Name.");
  return PolicyData_ManagementMode_Name(static_cast<PolicyData_ManagementMode>(enum_t_value));
}
bool PolicyData_ManagementMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyData_ManagementMode* value);
enum PolicyData_MarketSegment : int {
  PolicyData_MarketSegment_MARKET_SEGMENT_UNSPECIFIED = 0,
  PolicyData_MarketSegment_ENROLLED_EDUCATION = 1,
  PolicyData_MarketSegment_ENROLLED_ENTERPRISE = 2
};
bool PolicyData_MarketSegment_IsValid(int value);
constexpr PolicyData_MarketSegment PolicyData_MarketSegment_MarketSegment_MIN = PolicyData_MarketSegment_MARKET_SEGMENT_UNSPECIFIED;
constexpr PolicyData_MarketSegment PolicyData_MarketSegment_MarketSegment_MAX = PolicyData_MarketSegment_ENROLLED_ENTERPRISE;
constexpr int PolicyData_MarketSegment_MarketSegment_ARRAYSIZE = PolicyData_MarketSegment_MarketSegment_MAX + 1;

const std::string& PolicyData_MarketSegment_Name(PolicyData_MarketSegment value);
template<typename T>
inline const std::string& PolicyData_MarketSegment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyData_MarketSegment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyData_MarketSegment_Name.");
  return PolicyData_MarketSegment_Name(static_cast<PolicyData_MarketSegment>(enum_t_value));
}
bool PolicyData_MarketSegment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyData_MarketSegment* value);
enum PolicyData_MetricsLogSegment : int {
  PolicyData_MetricsLogSegment_UNSPECIFIED = 0,
  PolicyData_MetricsLogSegment_K12 = 1,
  PolicyData_MetricsLogSegment_UNIVERSITY = 2,
  PolicyData_MetricsLogSegment_NONPROFIT = 3,
  PolicyData_MetricsLogSegment_ENTERPRISE = 4
};
bool PolicyData_MetricsLogSegment_IsValid(int value);
constexpr PolicyData_MetricsLogSegment PolicyData_MetricsLogSegment_MetricsLogSegment_MIN = PolicyData_MetricsLogSegment_UNSPECIFIED;
constexpr PolicyData_MetricsLogSegment PolicyData_MetricsLogSegment_MetricsLogSegment_MAX = PolicyData_MetricsLogSegment_ENTERPRISE;
constexpr int PolicyData_MetricsLogSegment_MetricsLogSegment_ARRAYSIZE = PolicyData_MetricsLogSegment_MetricsLogSegment_MAX + 1;

const std::string& PolicyData_MetricsLogSegment_Name(PolicyData_MetricsLogSegment value);
template<typename T>
inline const std::string& PolicyData_MetricsLogSegment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyData_MetricsLogSegment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyData_MetricsLogSegment_Name.");
  return PolicyData_MetricsLogSegment_Name(static_cast<PolicyData_MetricsLogSegment>(enum_t_value));
}
bool PolicyData_MetricsLogSegment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyData_MetricsLogSegment* value);
enum ActiveTimePeriod_SessionType : int {
  ActiveTimePeriod_SessionType_SESSION_UNKNOWN = 0,
  ActiveTimePeriod_SessionType_SESSION_AFFILIATED_USER = 1,
  ActiveTimePeriod_SessionType_SESSION_MANAGED_GUEST = 2,
  ActiveTimePeriod_SessionType_SESSION_KIOSK = 3,
  ActiveTimePeriod_SessionType_SESSION_ARC_KIOSK = 4,
  ActiveTimePeriod_SessionType_SESSION_WEB_KIOSK = 5
};
bool ActiveTimePeriod_SessionType_IsValid(int value);
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod_SessionType_SessionType_MIN = ActiveTimePeriod_SessionType_SESSION_UNKNOWN;
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod_SessionType_SessionType_MAX = ActiveTimePeriod_SessionType_SESSION_WEB_KIOSK;
constexpr int ActiveTimePeriod_SessionType_SessionType_ARRAYSIZE = ActiveTimePeriod_SessionType_SessionType_MAX + 1;

const std::string& ActiveTimePeriod_SessionType_Name(ActiveTimePeriod_SessionType value);
template<typename T>
inline const std::string& ActiveTimePeriod_SessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActiveTimePeriod_SessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActiveTimePeriod_SessionType_Name.");
  return ActiveTimePeriod_SessionType_Name(static_cast<ActiveTimePeriod_SessionType>(enum_t_value));
}
bool ActiveTimePeriod_SessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActiveTimePeriod_SessionType* value);
enum NetworkInterface_NetworkDeviceType : int {
  NetworkInterface_NetworkDeviceType_TYPE_ETHERNET = 0,
  NetworkInterface_NetworkDeviceType_TYPE_WIFI = 1,
  NetworkInterface_NetworkDeviceType_TYPE_BLUETOOTH = 3,
  NetworkInterface_NetworkDeviceType_TYPE_CELLULAR = 4
};
bool NetworkInterface_NetworkDeviceType_IsValid(int value);
constexpr NetworkInterface_NetworkDeviceType NetworkInterface_NetworkDeviceType_NetworkDeviceType_MIN = NetworkInterface_NetworkDeviceType_TYPE_ETHERNET;
constexpr NetworkInterface_NetworkDeviceType NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX = NetworkInterface_NetworkDeviceType_TYPE_CELLULAR;
constexpr int NetworkInterface_NetworkDeviceType_NetworkDeviceType_ARRAYSIZE = NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX + 1;

const std::string& NetworkInterface_NetworkDeviceType_Name(NetworkInterface_NetworkDeviceType value);
template<typename T>
inline const std::string& NetworkInterface_NetworkDeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetworkInterface_NetworkDeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetworkInterface_NetworkDeviceType_Name.");
  return NetworkInterface_NetworkDeviceType_Name(static_cast<NetworkInterface_NetworkDeviceType>(enum_t_value));
}
bool NetworkInterface_NetworkDeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkInterface_NetworkDeviceType* value);
enum NetworkState_ConnectionState : int {
  NetworkState_ConnectionState_IDLE = 0,
  NetworkState_ConnectionState_ASSOCIATION = 2,
  NetworkState_ConnectionState_CONFIGURATION = 3,
  NetworkState_ConnectionState_READY = 4,
  NetworkState_ConnectionState_PORTAL = 5,
  NetworkState_ConnectionState_ONLINE = 7,
  NetworkState_ConnectionState_DISCONNECT = 8,
  NetworkState_ConnectionState_FAILURE = 9,
  NetworkState_ConnectionState_UNKNOWN = 11
};
bool NetworkState_ConnectionState_IsValid(int value);
constexpr NetworkState_ConnectionState NetworkState_ConnectionState_ConnectionState_MIN = NetworkState_ConnectionState_IDLE;
constexpr NetworkState_ConnectionState NetworkState_ConnectionState_ConnectionState_MAX = NetworkState_ConnectionState_UNKNOWN;
constexpr int NetworkState_ConnectionState_ConnectionState_ARRAYSIZE = NetworkState_ConnectionState_ConnectionState_MAX + 1;

const std::string& NetworkState_ConnectionState_Name(NetworkState_ConnectionState value);
template<typename T>
inline const std::string& NetworkState_ConnectionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetworkState_ConnectionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetworkState_ConnectionState_Name.");
  return NetworkState_ConnectionState_Name(static_cast<NetworkState_ConnectionState>(enum_t_value));
}
bool NetworkState_ConnectionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkState_ConnectionState* value);
enum DeviceUser_UserType : int {
  DeviceUser_UserType_USER_TYPE_MANAGED = 0,
  DeviceUser_UserType_USER_TYPE_UNMANAGED = 1
};
bool DeviceUser_UserType_IsValid(int value);
constexpr DeviceUser_UserType DeviceUser_UserType_UserType_MIN = DeviceUser_UserType_USER_TYPE_MANAGED;
constexpr DeviceUser_UserType DeviceUser_UserType_UserType_MAX = DeviceUser_UserType_USER_TYPE_UNMANAGED;
constexpr int DeviceUser_UserType_UserType_ARRAYSIZE = DeviceUser_UserType_UserType_MAX + 1;

const std::string& DeviceUser_UserType_Name(DeviceUser_UserType value);
template<typename T>
inline const std::string& DeviceUser_UserType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceUser_UserType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceUser_UserType_Name.");
  return DeviceUser_UserType_Name(static_cast<DeviceUser_UserType>(enum_t_value));
}
bool DeviceUser_UserType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceUser_UserType* value);
enum PowerStatus_PowerSource : int {
  PowerStatus_PowerSource_POWER_UNKNOWN = 0,
  PowerStatus_PowerSource_POWER_AC = 1,
  PowerStatus_PowerSource_POWER_BATTERY = 2
};
bool PowerStatus_PowerSource_IsValid(int value);
constexpr PowerStatus_PowerSource PowerStatus_PowerSource_PowerSource_MIN = PowerStatus_PowerSource_POWER_UNKNOWN;
constexpr PowerStatus_PowerSource PowerStatus_PowerSource_PowerSource_MAX = PowerStatus_PowerSource_POWER_BATTERY;
constexpr int PowerStatus_PowerSource_PowerSource_ARRAYSIZE = PowerStatus_PowerSource_PowerSource_MAX + 1;

const std::string& PowerStatus_PowerSource_Name(PowerStatus_PowerSource value);
template<typename T>
inline const std::string& PowerStatus_PowerSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerStatus_PowerSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerStatus_PowerSource_Name.");
  return PowerStatus_PowerSource_Name(static_cast<PowerStatus_PowerSource>(enum_t_value));
}
bool PowerStatus_PowerSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerStatus_PowerSource* value);
enum DiskInfo_DevicePurpose : int {
  DiskInfo_DevicePurpose_PURPOSE_UNKNOWN = 0,
  DiskInfo_DevicePurpose_PURPOSE_BOOT = 1,
  DiskInfo_DevicePurpose_PURPOSE_SWAP = 2
};
bool DiskInfo_DevicePurpose_IsValid(int value);
constexpr DiskInfo_DevicePurpose DiskInfo_DevicePurpose_DevicePurpose_MIN = DiskInfo_DevicePurpose_PURPOSE_UNKNOWN;
constexpr DiskInfo_DevicePurpose DiskInfo_DevicePurpose_DevicePurpose_MAX = DiskInfo_DevicePurpose_PURPOSE_SWAP;
constexpr int DiskInfo_DevicePurpose_DevicePurpose_ARRAYSIZE = DiskInfo_DevicePurpose_DevicePurpose_MAX + 1;

const std::string& DiskInfo_DevicePurpose_Name(DiskInfo_DevicePurpose value);
template<typename T>
inline const std::string& DiskInfo_DevicePurpose_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DiskInfo_DevicePurpose>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DiskInfo_DevicePurpose_Name.");
  return DiskInfo_DevicePurpose_Name(static_cast<DiskInfo_DevicePurpose>(enum_t_value));
}
bool DiskInfo_DevicePurpose_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DiskInfo_DevicePurpose* value);
enum CpuInfo_Architecture : int {
  CpuInfo_Architecture_ARCHITECTURE_UNSPECIFIED = 0,
  CpuInfo_Architecture_X86_64 = 1,
  CpuInfo_Architecture_AARCH64 = 2,
  CpuInfo_Architecture_ARMV7L = 3
};
bool CpuInfo_Architecture_IsValid(int value);
constexpr CpuInfo_Architecture CpuInfo_Architecture_Architecture_MIN = CpuInfo_Architecture_ARCHITECTURE_UNSPECIFIED;
constexpr CpuInfo_Architecture CpuInfo_Architecture_Architecture_MAX = CpuInfo_Architecture_ARMV7L;
constexpr int CpuInfo_Architecture_Architecture_ARRAYSIZE = CpuInfo_Architecture_Architecture_MAX + 1;

const std::string& CpuInfo_Architecture_Name(CpuInfo_Architecture value);
template<typename T>
inline const std::string& CpuInfo_Architecture_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CpuInfo_Architecture>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CpuInfo_Architecture_Name.");
  return CpuInfo_Architecture_Name(static_cast<CpuInfo_Architecture>(enum_t_value));
}
bool CpuInfo_Architecture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CpuInfo_Architecture* value);
enum CrashReportInfo_CrashReportUploadStatus : int {
  CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UNKNOWN = 0,
  CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_NOT_UPLOADED = 1,
  CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_PENDING = 2,
  CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_PENDING_USER_REQUESTED = 3,
  CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UPLOADED = 4
};
bool CrashReportInfo_CrashReportUploadStatus_IsValid(int value);
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MIN = CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UNKNOWN;
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MAX = CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UPLOADED;
constexpr int CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_ARRAYSIZE = CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MAX + 1;

const std::string& CrashReportInfo_CrashReportUploadStatus_Name(CrashReportInfo_CrashReportUploadStatus value);
template<typename T>
inline const std::string& CrashReportInfo_CrashReportUploadStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CrashReportInfo_CrashReportUploadStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CrashReportInfo_CrashReportUploadStatus_Name.");
  return CrashReportInfo_CrashReportUploadStatus_Name(static_cast<CrashReportInfo_CrashReportUploadStatus>(enum_t_value));
}
bool CrashReportInfo_CrashReportUploadStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrashReportInfo_CrashReportUploadStatus* value);
enum BootInfo_BootMethod : int {
  BootInfo_BootMethod_UNKNOWN = 0,
  BootInfo_BootMethod_CROS_SECURE = 1,
  BootInfo_BootMethod_CROS_UEFI = 2,
  BootInfo_BootMethod_CROS_LEGACY = 3,
  BootInfo_BootMethod_CROS_EFI_SECURE = 4
};
bool BootInfo_BootMethod_IsValid(int value);
constexpr BootInfo_BootMethod BootInfo_BootMethod_BootMethod_MIN = BootInfo_BootMethod_UNKNOWN;
constexpr BootInfo_BootMethod BootInfo_BootMethod_BootMethod_MAX = BootInfo_BootMethod_CROS_EFI_SECURE;
constexpr int BootInfo_BootMethod_BootMethod_ARRAYSIZE = BootInfo_BootMethod_BootMethod_MAX + 1;

const std::string& BootInfo_BootMethod_Name(BootInfo_BootMethod value);
template<typename T>
inline const std::string& BootInfo_BootMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BootInfo_BootMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BootInfo_BootMethod_Name.");
  return BootInfo_BootMethod_Name(static_cast<BootInfo_BootMethod>(enum_t_value));
}
bool BootInfo_BootMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BootInfo_BootMethod* value);
enum OsUpdateStatus_UpdateStatus : int {
  OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE = 0,
  OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_NOT_STARTED = 1,
  OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_IN_PROGRESS = 2,
  OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT = 3
};
bool OsUpdateStatus_UpdateStatus_IsValid(int value);
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus_UpdateStatus_UpdateStatus_MIN = OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE;
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus_UpdateStatus_UpdateStatus_MAX = OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT;
constexpr int OsUpdateStatus_UpdateStatus_UpdateStatus_ARRAYSIZE = OsUpdateStatus_UpdateStatus_UpdateStatus_MAX + 1;

const std::string& OsUpdateStatus_UpdateStatus_Name(OsUpdateStatus_UpdateStatus value);
template<typename T>
inline const std::string& OsUpdateStatus_UpdateStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OsUpdateStatus_UpdateStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OsUpdateStatus_UpdateStatus_Name.");
  return OsUpdateStatus_UpdateStatus_Name(static_cast<OsUpdateStatus_UpdateStatus>(enum_t_value));
}
bool OsUpdateStatus_UpdateStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OsUpdateStatus_UpdateStatus* value);
enum AppInfo_AppType : int {
  AppInfo_AppType_TYPE_UNKNOWN = 0,
  AppInfo_AppType_TYPE_ARC = 1,
  AppInfo_AppType_TYPE_BUILTIN = 2,
  AppInfo_AppType_TYPE_CROSTINI = 3,
  AppInfo_AppType_TYPE_EXTENSION = 4,
  AppInfo_AppType_TYPE_WEB = 5,
  AppInfo_AppType_TYPE_PLUGINVM = 6,
  AppInfo_AppType_TYPE_BOREALIS = 7,
  AppInfo_AppType_TYPE_BRUSCHETTA = 8
};
bool AppInfo_AppType_IsValid(int value);
constexpr AppInfo_AppType AppInfo_AppType_AppType_MIN = AppInfo_AppType_TYPE_UNKNOWN;
constexpr AppInfo_AppType AppInfo_AppType_AppType_MAX = AppInfo_AppType_TYPE_BRUSCHETTA;
constexpr int AppInfo_AppType_AppType_ARRAYSIZE = AppInfo_AppType_AppType_MAX + 1;

const std::string& AppInfo_AppType_Name(AppInfo_AppType value);
template<typename T>
inline const std::string& AppInfo_AppType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppInfo_AppType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppInfo_AppType_Name.");
  return AppInfo_AppType_Name(static_cast<AppInfo_AppType>(enum_t_value));
}
bool AppInfo_AppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppInfo_AppType* value);
enum AppInfo_Status : int {
  AppInfo_Status_STATUS_UNKNOWN = 0,
  AppInfo_Status_STATUS_INSTALLED = 1,
  AppInfo_Status_STATUS_DISABLED = 2,
  AppInfo_Status_STATUS_UNINSTALLED = 3
};
bool AppInfo_Status_IsValid(int value);
constexpr AppInfo_Status AppInfo_Status_Status_MIN = AppInfo_Status_STATUS_UNKNOWN;
constexpr AppInfo_Status AppInfo_Status_Status_MAX = AppInfo_Status_STATUS_UNINSTALLED;
constexpr int AppInfo_Status_Status_ARRAYSIZE = AppInfo_Status_Status_MAX + 1;

const std::string& AppInfo_Status_Name(AppInfo_Status value);
template<typename T>
inline const std::string& AppInfo_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppInfo_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppInfo_Status_Name.");
  return AppInfo_Status_Name(static_cast<AppInfo_Status>(enum_t_value));
}
bool AppInfo_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppInfo_Status* value);
enum AndroidAppInfo_AndroidAppStatus : int {
  AndroidAppInfo_AndroidAppStatus_STATUS_UNKNOWN = 0,
  AndroidAppInfo_AndroidAppStatus_STATUS_ENABLED = 1,
  AndroidAppInfo_AndroidAppStatus_STATUS_SUSPENDED = 2,
  AndroidAppInfo_AndroidAppStatus_STATUS_DISABLED = 3
};
bool AndroidAppInfo_AndroidAppStatus_IsValid(int value);
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MIN = AndroidAppInfo_AndroidAppStatus_STATUS_UNKNOWN;
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MAX = AndroidAppInfo_AndroidAppStatus_STATUS_DISABLED;
constexpr int AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_ARRAYSIZE = AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MAX + 1;

const std::string& AndroidAppInfo_AndroidAppStatus_Name(AndroidAppInfo_AndroidAppStatus value);
template<typename T>
inline const std::string& AndroidAppInfo_AndroidAppStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AndroidAppInfo_AndroidAppStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AndroidAppInfo_AndroidAppStatus_Name.");
  return AndroidAppInfo_AndroidAppStatus_Name(static_cast<AndroidAppInfo_AndroidAppStatus>(enum_t_value));
}
bool AndroidAppInfo_AndroidAppStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AndroidAppInfo_AndroidAppStatus* value);
enum AndroidAppInfo_InstalledSource : int {
  AndroidAppInfo_InstalledSource_SOURCE_UNKNOWN = 0,
  AndroidAppInfo_InstalledSource_SOURCE_BY_ADMIN = 1,
  AndroidAppInfo_InstalledSource_SOURCE_BY_USER = 2,
  AndroidAppInfo_InstalledSource_SOURCE_NOT_INSTALLED = 3
};
bool AndroidAppInfo_InstalledSource_IsValid(int value);
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo_InstalledSource_InstalledSource_MIN = AndroidAppInfo_InstalledSource_SOURCE_UNKNOWN;
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo_InstalledSource_InstalledSource_MAX = AndroidAppInfo_InstalledSource_SOURCE_NOT_INSTALLED;
constexpr int AndroidAppInfo_InstalledSource_InstalledSource_ARRAYSIZE = AndroidAppInfo_InstalledSource_InstalledSource_MAX + 1;

const std::string& AndroidAppInfo_InstalledSource_Name(AndroidAppInfo_InstalledSource value);
template<typename T>
inline const std::string& AndroidAppInfo_InstalledSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AndroidAppInfo_InstalledSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AndroidAppInfo_InstalledSource_Name.");
  return AndroidAppInfo_InstalledSource_Name(static_cast<AndroidAppInfo_InstalledSource>(enum_t_value));
}
bool AndroidAppInfo_InstalledSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AndroidAppInfo_InstalledSource* value);
enum Extension_ExtensionType : int {
  Extension_ExtensionType_TYPE_UNKNOWN = 0,
  Extension_ExtensionType_TYPE_EXTENSION = 1,
  Extension_ExtensionType_TYPE_HOSTED_APP = 2,
  Extension_ExtensionType_TYPE_PACKAGED_APP = 3,
  Extension_ExtensionType_TYPE_LEGACY_PACKAGED_APP = 4,
  Extension_ExtensionType_TYPE_THEME = 5,
  Extension_ExtensionType_TYPE_USER_SCRIPT = 6,
  Extension_ExtensionType_TYPE_PLATFORM_APP = 7,
  Extension_ExtensionType_TYPE_LOGIN_SCREEN_EXTENSION = 8,
  Extension_ExtensionType_TYPE_CHROMEOS_SYSTEM_EXTENSION = 9
};
bool Extension_ExtensionType_IsValid(int value);
constexpr Extension_ExtensionType Extension_ExtensionType_ExtensionType_MIN = Extension_ExtensionType_TYPE_UNKNOWN;
constexpr Extension_ExtensionType Extension_ExtensionType_ExtensionType_MAX = Extension_ExtensionType_TYPE_CHROMEOS_SYSTEM_EXTENSION;
constexpr int Extension_ExtensionType_ExtensionType_ARRAYSIZE = Extension_ExtensionType_ExtensionType_MAX + 1;

const std::string& Extension_ExtensionType_Name(Extension_ExtensionType value);
template<typename T>
inline const std::string& Extension_ExtensionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Extension_ExtensionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Extension_ExtensionType_Name.");
  return Extension_ExtensionType_Name(static_cast<Extension_ExtensionType>(enum_t_value));
}
bool Extension_ExtensionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Extension_ExtensionType* value);
enum Extension_InstallType : int {
  Extension_InstallType_TYPE_NORMAL = 0,
  Extension_InstallType_TYPE_DEVELOPMENT = 1,
  Extension_InstallType_TYPE_SIDELOAD = 2,
  Extension_InstallType_TYPE_ADMIN = 3,
  Extension_InstallType_TYPE_OTHER = 4
};
bool Extension_InstallType_IsValid(int value);
constexpr Extension_InstallType Extension_InstallType_InstallType_MIN = Extension_InstallType_TYPE_NORMAL;
constexpr Extension_InstallType Extension_InstallType_InstallType_MAX = Extension_InstallType_TYPE_OTHER;
constexpr int Extension_InstallType_InstallType_ARRAYSIZE = Extension_InstallType_InstallType_MAX + 1;

const std::string& Extension_InstallType_Name(Extension_InstallType value);
template<typename T>
inline const std::string& Extension_InstallType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Extension_InstallType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Extension_InstallType_Name.");
  return Extension_InstallType_Name(static_cast<Extension_InstallType>(enum_t_value));
}
bool Extension_InstallType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Extension_InstallType* value);
enum Policy_PolicyLevel : int {
  Policy_PolicyLevel_LEVEL_UNKNOWN = 0,
  Policy_PolicyLevel_LEVEL_RECOMMENDED = 1,
  Policy_PolicyLevel_LEVEL_MANDATORY = 2
};
bool Policy_PolicyLevel_IsValid(int value);
constexpr Policy_PolicyLevel Policy_PolicyLevel_PolicyLevel_MIN = Policy_PolicyLevel_LEVEL_UNKNOWN;
constexpr Policy_PolicyLevel Policy_PolicyLevel_PolicyLevel_MAX = Policy_PolicyLevel_LEVEL_MANDATORY;
constexpr int Policy_PolicyLevel_PolicyLevel_ARRAYSIZE = Policy_PolicyLevel_PolicyLevel_MAX + 1;

const std::string& Policy_PolicyLevel_Name(Policy_PolicyLevel value);
template<typename T>
inline const std::string& Policy_PolicyLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Policy_PolicyLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Policy_PolicyLevel_Name.");
  return Policy_PolicyLevel_Name(static_cast<Policy_PolicyLevel>(enum_t_value));
}
bool Policy_PolicyLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Policy_PolicyLevel* value);
enum Policy_PolicyScope : int {
  Policy_PolicyScope_SCOPE_UNKNOWN = 0,
  Policy_PolicyScope_SCOPE_USER = 1,
  Policy_PolicyScope_SCOPE_MACHINE = 2
};
bool Policy_PolicyScope_IsValid(int value);
constexpr Policy_PolicyScope Policy_PolicyScope_PolicyScope_MIN = Policy_PolicyScope_SCOPE_UNKNOWN;
constexpr Policy_PolicyScope Policy_PolicyScope_PolicyScope_MAX = Policy_PolicyScope_SCOPE_MACHINE;
constexpr int Policy_PolicyScope_PolicyScope_ARRAYSIZE = Policy_PolicyScope_PolicyScope_MAX + 1;

const std::string& Policy_PolicyScope_Name(Policy_PolicyScope value);
template<typename T>
inline const std::string& Policy_PolicyScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Policy_PolicyScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Policy_PolicyScope_Name.");
  return Policy_PolicyScope_Name(static_cast<Policy_PolicyScope>(enum_t_value));
}
bool Policy_PolicyScope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Policy_PolicyScope* value);
enum Policy_PolicySource : int {
  Policy_PolicySource_SOURCE_UNKNOWN = 0,
  Policy_PolicySource_SOURCE_ENTERPRISE_DEFAULT = 1,
  Policy_PolicySource_SOURCE_CLOUD = 2,
  Policy_PolicySource_SOURCE_ACTIVE_DIRECTORY = 3,
  Policy_PolicySource_SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE_DEPRECATED = 4,
  Policy_PolicySource_SOURCE_PLATFORM = 5,
  Policy_PolicySource_SOURCE_PRIORITY_CLOUD_DEPRECATED = 6,
  Policy_PolicySource_SOURCE_MERGED = 7,
  Policy_PolicySource_SOURCE_COMMAND_LINE = 8,
  Policy_PolicySource_SOURCE_CLOUD_FROM_ASH = 9,
  Policy_PolicySource_SOURCE_RESTRICTED_MANAGED_GUEST_SESSION_OVERRIDE = 10
};
bool Policy_PolicySource_IsValid(int value);
constexpr Policy_PolicySource Policy_PolicySource_PolicySource_MIN = Policy_PolicySource_SOURCE_UNKNOWN;
constexpr Policy_PolicySource Policy_PolicySource_PolicySource_MAX = Policy_PolicySource_SOURCE_RESTRICTED_MANAGED_GUEST_SESSION_OVERRIDE;
constexpr int Policy_PolicySource_PolicySource_ARRAYSIZE = Policy_PolicySource_PolicySource_MAX + 1;

const std::string& Policy_PolicySource_Name(Policy_PolicySource value);
template<typename T>
inline const std::string& Policy_PolicySource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Policy_PolicySource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Policy_PolicySource_Name.");
  return Policy_PolicySource_Name(static_cast<Policy_PolicySource>(enum_t_value));
}
bool Policy_PolicySource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Policy_PolicySource* value);
enum OSReport_VersionType : int {
  OSReport_VersionType_UNKNOWN = 0,
  OSReport_VersionType_HOME = 1,
  OSReport_VersionType_PROFESSIONAL = 2,
  OSReport_VersionType_SERVER = 3,
  OSReport_VersionType_ENTERPRISE = 4,
  OSReport_VersionType_EDUCATION = 5,
  OSReport_VersionType_EDUCATION_PRO = 6
};
bool OSReport_VersionType_IsValid(int value);
constexpr OSReport_VersionType OSReport_VersionType_VersionType_MIN = OSReport_VersionType_UNKNOWN;
constexpr OSReport_VersionType OSReport_VersionType_VersionType_MAX = OSReport_VersionType_EDUCATION_PRO;
constexpr int OSReport_VersionType_VersionType_ARRAYSIZE = OSReport_VersionType_VersionType_MAX + 1;

const std::string& OSReport_VersionType_Name(OSReport_VersionType value);
template<typename T>
inline const std::string& OSReport_VersionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OSReport_VersionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OSReport_VersionType_Name.");
  return OSReport_VersionType_Name(static_cast<OSReport_VersionType>(enum_t_value));
}
bool OSReport_VersionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OSReport_VersionType* value);
enum PolicyValueValidationIssue_ValueValidationIssueSeverity : int {
  PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED = 0,
  PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_WARNING = 1,
  PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_ERROR = 2
};
bool PolicyValueValidationIssue_ValueValidationIssueSeverity_IsValid(int value);
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MIN = PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED;
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MAX = PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_ERROR;
constexpr int PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_ARRAYSIZE = PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MAX + 1;

const std::string& PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(PolicyValueValidationIssue_ValueValidationIssueSeverity value);
template<typename T>
inline const std::string& PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyValueValidationIssue_ValueValidationIssueSeverity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyValueValidationIssue_ValueValidationIssueSeverity_Name.");
  return PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(static_cast<PolicyValueValidationIssue_ValueValidationIssueSeverity>(enum_t_value));
}
bool PolicyValueValidationIssue_ValueValidationIssueSeverity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyValueValidationIssue_ValueValidationIssueSeverity* value);
enum PolicyValidationReportRequest_ValidationResultType : int {
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED = 0,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_SUCCESS = 1,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE = 2,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_SIGNATURE = 3,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT = 4,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR = 5,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE = 6,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID = 7,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_TIMESTAMP = 8,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_DM_TOKEN = 9,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_DEVICE_ID = 10,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_USER = 11,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR = 12,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE = 13,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_WARNING = 14,
  PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_ERROR = 15
};
bool PolicyValidationReportRequest_ValidationResultType_IsValid(int value);
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MIN = PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MAX = PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_ERROR;
constexpr int PolicyValidationReportRequest_ValidationResultType_ValidationResultType_ARRAYSIZE = PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MAX + 1;

const std::string& PolicyValidationReportRequest_ValidationResultType_Name(PolicyValidationReportRequest_ValidationResultType value);
template<typename T>
inline const std::string& PolicyValidationReportRequest_ValidationResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyValidationReportRequest_ValidationResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyValidationReportRequest_ValidationResultType_Name.");
  return PolicyValidationReportRequest_ValidationResultType_Name(static_cast<PolicyValidationReportRequest_ValidationResultType>(enum_t_value));
}
bool PolicyValidationReportRequest_ValidationResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyValidationReportRequest_ValidationResultType* value);
enum DeviceAutoEnrollmentRequest_EnrollmentCheckType : int {
  DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_UNSPECIFIED = 0,
  DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FRE = 1,
  DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT = 2
};
bool DeviceAutoEnrollmentRequest_EnrollmentCheckType_IsValid(int value);
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MIN = DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_UNSPECIFIED;
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MAX = DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT;
constexpr int DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_ARRAYSIZE = DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MAX + 1;

const std::string& DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(DeviceAutoEnrollmentRequest_EnrollmentCheckType value);
template<typename T>
inline const std::string& DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceAutoEnrollmentRequest_EnrollmentCheckType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name.");
  return DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(static_cast<DeviceAutoEnrollmentRequest_EnrollmentCheckType>(enum_t_value));
}
bool DeviceAutoEnrollmentRequest_EnrollmentCheckType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceAutoEnrollmentRequest_EnrollmentCheckType* value);
enum DeviceStateRetrievalResponse_RestoreMode : int {
  DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE = 0,
  DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_REQUESTED = 1,
  DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ENFORCED = 2,
  DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_DISABLED = 3,
  DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ZERO_TOUCH = 4
};
bool DeviceStateRetrievalResponse_RestoreMode_IsValid(int value);
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MIN = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE;
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX = DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ZERO_TOUCH;
constexpr int DeviceStateRetrievalResponse_RestoreMode_RestoreMode_ARRAYSIZE = DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX + 1;

const std::string& DeviceStateRetrievalResponse_RestoreMode_Name(DeviceStateRetrievalResponse_RestoreMode value);
template<typename T>
inline const std::string& DeviceStateRetrievalResponse_RestoreMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceStateRetrievalResponse_RestoreMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceStateRetrievalResponse_RestoreMode_Name.");
  return DeviceStateRetrievalResponse_RestoreMode_Name(static_cast<DeviceStateRetrievalResponse_RestoreMode>(enum_t_value));
}
bool DeviceStateRetrievalResponse_RestoreMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceStateRetrievalResponse_RestoreMode* value);
enum DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode : int {
  DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_NONE = 0,
  DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED = 1,
  DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED = 2,
  DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_DISABLED = 3
};
bool DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_IsValid(int value);
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MIN = DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_NONE;
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MAX = DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_DISABLED;
constexpr int DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_ARRAYSIZE = DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MAX + 1;

const std::string& DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value);
template<typename T>
inline const std::string& DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name.");
  return DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(static_cast<DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode>(enum_t_value));
}
bool DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode* value);
enum DeviceInitialEnrollmentStateResponse_LicensePackagingSKU : int {
  DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_NOT_EXIST = 0,
  DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_CHROME_ENTERPRISE = 1,
  DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_CHROME_EDUCATION = 2,
  DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_CHROME_TERMINAL = 3
};
bool DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_IsValid(int value);
constexpr DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_LicensePackagingSKU_MIN = DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_NOT_EXIST;
constexpr DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_LicensePackagingSKU_MAX = DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_CHROME_TERMINAL;
constexpr int DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_LicensePackagingSKU_ARRAYSIZE = DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_LicensePackagingSKU_MAX + 1;

const std::string& DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Name(DeviceInitialEnrollmentStateResponse_LicensePackagingSKU value);
template<typename T>
inline const std::string& DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInitialEnrollmentStateResponse_LicensePackagingSKU>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Name.");
  return DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Name(static_cast<DeviceInitialEnrollmentStateResponse_LicensePackagingSKU>(enum_t_value));
}
bool DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInitialEnrollmentStateResponse_LicensePackagingSKU* value);
enum DeviceInitialEnrollmentStateResponse_AssignedUpgradeType : int {
  DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_ASSIGNED_UPGRADE_TYPE_UNSPECIFIED = 0,
  DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_ASSIGNED_UPGRADE_TYPE_CHROME_ENTERPRISE = 1,
  DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_ASSIGNED_UPGRADE_TYPE_KIOSK_AND_SIGNAGE = 2
};
bool DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_IsValid(int value);
constexpr DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_AssignedUpgradeType_MIN = DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_ASSIGNED_UPGRADE_TYPE_UNSPECIFIED;
constexpr DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_AssignedUpgradeType_MAX = DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_ASSIGNED_UPGRADE_TYPE_KIOSK_AND_SIGNAGE;
constexpr int DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_AssignedUpgradeType_ARRAYSIZE = DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_AssignedUpgradeType_MAX + 1;

const std::string& DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Name(DeviceInitialEnrollmentStateResponse_AssignedUpgradeType value);
template<typename T>
inline const std::string& DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInitialEnrollmentStateResponse_AssignedUpgradeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Name.");
  return DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Name(static_cast<DeviceInitialEnrollmentStateResponse_AssignedUpgradeType>(enum_t_value));
}
bool DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInitialEnrollmentStateResponse_AssignedUpgradeType* value);
enum DevicePairingResponse_StatusCode : int {
  DevicePairingResponse_StatusCode_SUCCESS = 0,
  DevicePairingResponse_StatusCode_FAILED = 1,
  DevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND = 2,
  DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND = 3,
  DevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED = 4,
  DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED = 5
};
bool DevicePairingResponse_StatusCode_IsValid(int value);
constexpr DevicePairingResponse_StatusCode DevicePairingResponse_StatusCode_StatusCode_MIN = DevicePairingResponse_StatusCode_SUCCESS;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse_StatusCode_StatusCode_MAX = DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
constexpr int DevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE = DevicePairingResponse_StatusCode_StatusCode_MAX + 1;

const std::string& DevicePairingResponse_StatusCode_Name(DevicePairingResponse_StatusCode value);
template<typename T>
inline const std::string& DevicePairingResponse_StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DevicePairingResponse_StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DevicePairingResponse_StatusCode_Name.");
  return DevicePairingResponse_StatusCode_Name(static_cast<DevicePairingResponse_StatusCode>(enum_t_value));
}
bool DevicePairingResponse_StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DevicePairingResponse_StatusCode* value);
enum CheckDevicePairingResponse_StatusCode : int {
  CheckDevicePairingResponse_StatusCode_PAIRED = 0,
  CheckDevicePairingResponse_StatusCode_NOT_PAIRED = 1,
  CheckDevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND = 2,
  CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND = 3,
  CheckDevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED = 4,
  CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED = 5,
  CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY = 6
};
bool CheckDevicePairingResponse_StatusCode_IsValid(int value);
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse_StatusCode_StatusCode_MIN = CheckDevicePairingResponse_StatusCode_PAIRED;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse_StatusCode_StatusCode_MAX = CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY;
constexpr int CheckDevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE = CheckDevicePairingResponse_StatusCode_StatusCode_MAX + 1;

const std::string& CheckDevicePairingResponse_StatusCode_Name(CheckDevicePairingResponse_StatusCode value);
template<typename T>
inline const std::string& CheckDevicePairingResponse_StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckDevicePairingResponse_StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckDevicePairingResponse_StatusCode_Name.");
  return CheckDevicePairingResponse_StatusCode_Name(static_cast<CheckDevicePairingResponse_StatusCode>(enum_t_value));
}
bool CheckDevicePairingResponse_StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckDevicePairingResponse_StatusCode* value);
enum RemoteCommand_Type : int {
  RemoteCommand_Type_COMMAND_ECHO_TEST = -1,
  RemoteCommand_Type_DEVICE_REBOOT = 0,
  RemoteCommand_Type_DEVICE_SCREENSHOT = 1,
  RemoteCommand_Type_DEVICE_SET_VOLUME = 2,
  RemoteCommand_Type_DEVICE_FETCH_STATUS = 3,
  RemoteCommand_Type_USER_ARC_COMMAND = 4,
  RemoteCommand_Type_DEVICE_WIPE_USERS = 5,
  RemoteCommand_Type_DEVICE_START_CRD_SESSION = 6,
  RemoteCommand_Type_DEVICE_REMOTE_POWERWASH = 7,
  RemoteCommand_Type_DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE = 8,
  RemoteCommand_Type_DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES = 9,
  RemoteCommand_Type_DEVICE_RUN_DIAGNOSTIC_ROUTINE = 10,
  RemoteCommand_Type_DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE = 11,
  RemoteCommand_Type_BROWSER_CLEAR_BROWSING_DATA = 12,
  RemoteCommand_Type_DEVICE_RESET_EUICC = 13,
  RemoteCommand_Type_BROWSER_ROTATE_ATTESTATION_CREDENTIAL = 14,
  RemoteCommand_Type_FETCH_CRD_AVAILABILITY_INFO = 15,
  RemoteCommand_Type_FETCH_SUPPORT_PACKET = 16
};
bool RemoteCommand_Type_IsValid(int value);
constexpr RemoteCommand_Type RemoteCommand_Type_Type_MIN = RemoteCommand_Type_COMMAND_ECHO_TEST;
constexpr RemoteCommand_Type RemoteCommand_Type_Type_MAX = RemoteCommand_Type_FETCH_SUPPORT_PACKET;
constexpr int RemoteCommand_Type_Type_ARRAYSIZE = RemoteCommand_Type_Type_MAX + 1;

const std::string& RemoteCommand_Type_Name(RemoteCommand_Type value);
template<typename T>
inline const std::string& RemoteCommand_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RemoteCommand_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RemoteCommand_Type_Name.");
  return RemoteCommand_Type_Name(static_cast<RemoteCommand_Type>(enum_t_value));
}
bool RemoteCommand_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RemoteCommand_Type* value);
enum RemoteCommandResult_ResultType : int {
  RemoteCommandResult_ResultType_RESULT_IGNORED = 0,
  RemoteCommandResult_ResultType_RESULT_FAILURE = 1,
  RemoteCommandResult_ResultType_RESULT_SUCCESS = 2
};
bool RemoteCommandResult_ResultType_IsValid(int value);
constexpr RemoteCommandResult_ResultType RemoteCommandResult_ResultType_ResultType_MIN = RemoteCommandResult_ResultType_RESULT_IGNORED;
constexpr RemoteCommandResult_ResultType RemoteCommandResult_ResultType_ResultType_MAX = RemoteCommandResult_ResultType_RESULT_SUCCESS;
constexpr int RemoteCommandResult_ResultType_ResultType_ARRAYSIZE = RemoteCommandResult_ResultType_ResultType_MAX + 1;

const std::string& RemoteCommandResult_ResultType_Name(RemoteCommandResult_ResultType value);
template<typename T>
inline const std::string& RemoteCommandResult_ResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RemoteCommandResult_ResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RemoteCommandResult_ResultType_Name.");
  return RemoteCommandResult_ResultType_Name(static_cast<RemoteCommandResult_ResultType>(enum_t_value));
}
bool RemoteCommandResult_ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RemoteCommandResult_ResultType* value);
enum DeviceAttributeUpdatePermissionResponse_ResultType : int {
  DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED = 0,
  DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED = 1
};
bool DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(int value);
constexpr DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MIN = DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED;
constexpr DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX = DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED;
constexpr int DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_ARRAYSIZE = DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX + 1;

const std::string& DeviceAttributeUpdatePermissionResponse_ResultType_Name(DeviceAttributeUpdatePermissionResponse_ResultType value);
template<typename T>
inline const std::string& DeviceAttributeUpdatePermissionResponse_ResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceAttributeUpdatePermissionResponse_ResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceAttributeUpdatePermissionResponse_ResultType_Name.");
  return DeviceAttributeUpdatePermissionResponse_ResultType_Name(static_cast<DeviceAttributeUpdatePermissionResponse_ResultType>(enum_t_value));
}
bool DeviceAttributeUpdatePermissionResponse_ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceAttributeUpdatePermissionResponse_ResultType* value);
enum DeviceAttributeUpdateResponse_ResultType : int {
  DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR = 0,
  DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS = 1
};
bool DeviceAttributeUpdateResponse_ResultType_IsValid(int value);
constexpr DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse_ResultType_ResultType_MIN = DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR;
constexpr DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse_ResultType_ResultType_MAX = DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS;
constexpr int DeviceAttributeUpdateResponse_ResultType_ResultType_ARRAYSIZE = DeviceAttributeUpdateResponse_ResultType_ResultType_MAX + 1;

const std::string& DeviceAttributeUpdateResponse_ResultType_Name(DeviceAttributeUpdateResponse_ResultType value);
template<typename T>
inline const std::string& DeviceAttributeUpdateResponse_ResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceAttributeUpdateResponse_ResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceAttributeUpdateResponse_ResultType_Name.");
  return DeviceAttributeUpdateResponse_ResultType_Name(static_cast<DeviceAttributeUpdateResponse_ResultType>(enum_t_value));
}
bool DeviceAttributeUpdateResponse_ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceAttributeUpdateResponse_ResultType* value);
enum CertificateBasedDeviceRegistrationData_CertificateType : int {
  CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN = 0,
  CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE = 1
};
bool CertificateBasedDeviceRegistrationData_CertificateType_IsValid(int value);
constexpr CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MIN = CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN;
constexpr CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX = CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
constexpr int CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_ARRAYSIZE = CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX + 1;

const std::string& CertificateBasedDeviceRegistrationData_CertificateType_Name(CertificateBasedDeviceRegistrationData_CertificateType value);
template<typename T>
inline const std::string& CertificateBasedDeviceRegistrationData_CertificateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CertificateBasedDeviceRegistrationData_CertificateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CertificateBasedDeviceRegistrationData_CertificateType_Name.");
  return CertificateBasedDeviceRegistrationData_CertificateType_Name(static_cast<CertificateBasedDeviceRegistrationData_CertificateType>(enum_t_value));
}
bool CertificateBasedDeviceRegistrationData_CertificateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertificateBasedDeviceRegistrationData_CertificateType* value);
enum CheckDeviceLicenseResponse_LicenseSelectionMode : int {
  CheckDeviceLicenseResponse_LicenseSelectionMode_UNDEFINED = 0,
  CheckDeviceLicenseResponse_LicenseSelectionMode_USER_SELECTION = 1,
  CheckDeviceLicenseResponse_LicenseSelectionMode_ADMIN_SELECTION = 2
};
bool CheckDeviceLicenseResponse_LicenseSelectionMode_IsValid(int value);
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MIN = CheckDeviceLicenseResponse_LicenseSelectionMode_UNDEFINED;
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MAX = CheckDeviceLicenseResponse_LicenseSelectionMode_ADMIN_SELECTION;
constexpr int CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_ARRAYSIZE = CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MAX + 1;

const std::string& CheckDeviceLicenseResponse_LicenseSelectionMode_Name(CheckDeviceLicenseResponse_LicenseSelectionMode value);
template<typename T>
inline const std::string& CheckDeviceLicenseResponse_LicenseSelectionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckDeviceLicenseResponse_LicenseSelectionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckDeviceLicenseResponse_LicenseSelectionMode_Name.");
  return CheckDeviceLicenseResponse_LicenseSelectionMode_Name(static_cast<CheckDeviceLicenseResponse_LicenseSelectionMode>(enum_t_value));
}
bool CheckDeviceLicenseResponse_LicenseSelectionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckDeviceLicenseResponse_LicenseSelectionMode* value);
enum TpmVersionInfo_GscVersion : int {
  TpmVersionInfo_GscVersion_GSC_VERSION_UNSPECIFIED = 0,
  TpmVersionInfo_GscVersion_GSC_VERSION_NOT_GSC = 1,
  TpmVersionInfo_GscVersion_GSC_VERSION_CR50 = 2,
  TpmVersionInfo_GscVersion_GSC_VERSION_TI50 = 3
};
bool TpmVersionInfo_GscVersion_IsValid(int value);
constexpr TpmVersionInfo_GscVersion TpmVersionInfo_GscVersion_GscVersion_MIN = TpmVersionInfo_GscVersion_GSC_VERSION_UNSPECIFIED;
constexpr TpmVersionInfo_GscVersion TpmVersionInfo_GscVersion_GscVersion_MAX = TpmVersionInfo_GscVersion_GSC_VERSION_TI50;
constexpr int TpmVersionInfo_GscVersion_GscVersion_ARRAYSIZE = TpmVersionInfo_GscVersion_GscVersion_MAX + 1;

const std::string& TpmVersionInfo_GscVersion_Name(TpmVersionInfo_GscVersion value);
template<typename T>
inline const std::string& TpmVersionInfo_GscVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TpmVersionInfo_GscVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TpmVersionInfo_GscVersion_Name.");
  return TpmVersionInfo_GscVersion_Name(static_cast<TpmVersionInfo_GscVersion>(enum_t_value));
}
bool TpmVersionInfo_GscVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TpmVersionInfo_GscVersion* value);
enum ExtensionInstallReportLogEvent_EventType : int {
  ExtensionInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_EventType_POLICY_REQUEST = 1,
  ExtensionInstallReportLogEvent_EventType_SUCCESS = 2,
  ExtensionInstallReportLogEvent_EventType_CANCELED = 3,
  ExtensionInstallReportLogEvent_EventType_CONNECTIVITY_CHANGE = 4,
  ExtensionInstallReportLogEvent_EventType_SESSION_STATE_CHANGE = 5,
  ExtensionInstallReportLogEvent_EventType_INSTALLATION_FAILED = 6
};
bool ExtensionInstallReportLogEvent_EventType_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent_EventType_EventType_MIN = ExtensionInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent_EventType_EventType_MAX = ExtensionInstallReportLogEvent_EventType_INSTALLATION_FAILED;
constexpr int ExtensionInstallReportLogEvent_EventType_EventType_ARRAYSIZE = ExtensionInstallReportLogEvent_EventType_EventType_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_EventType_Name(ExtensionInstallReportLogEvent_EventType value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_EventType_Name.");
  return ExtensionInstallReportLogEvent_EventType_Name(static_cast<ExtensionInstallReportLogEvent_EventType>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_EventType* value);
enum ExtensionInstallReportLogEvent_SessionStateChangeType : int {
  ExtensionInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_SessionStateChangeType_LOGIN = 1,
  ExtensionInstallReportLogEvent_SessionStateChangeType_LOGOUT = 2,
  ExtensionInstallReportLogEvent_SessionStateChangeType_SUSPEND = 3,
  ExtensionInstallReportLogEvent_SessionStateChangeType_RESUME = 4
};
bool ExtensionInstallReportLogEvent_SessionStateChangeType_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MIN = ExtensionInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX = ExtensionInstallReportLogEvent_SessionStateChangeType_RESUME;
constexpr int ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_ARRAYSIZE = ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_SessionStateChangeType_Name(ExtensionInstallReportLogEvent_SessionStateChangeType value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_SessionStateChangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_SessionStateChangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_SessionStateChangeType_Name.");
  return ExtensionInstallReportLogEvent_SessionStateChangeType_Name(static_cast<ExtensionInstallReportLogEvent_SessionStateChangeType>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_SessionStateChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_SessionStateChangeType* value);
enum ExtensionInstallReportLogEvent_FailureReason : int {
  ExtensionInstallReportLogEvent_FailureReason_FAILURE_REASON_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_FailureReason_INVALID_ID = 1,
  ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_SETTINGS = 2,
  ExtensionInstallReportLogEvent_FailureReason_REPLACED_BY_ARC_APP = 3,
  ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_DICT = 4,
  ExtensionInstallReportLogEvent_FailureReason_NOT_SUPPORTED_EXTENSION_DICT = 5,
  ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_DICT_FILE_PATH = 6,
  ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_DICT_VERSION = 7,
  ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_DICT_UPDATE_URL = 8,
  ExtensionInstallReportLogEvent_FailureReason_LOCALE_NOT_SUPPORTED = 9,
  ExtensionInstallReportLogEvent_FailureReason_NOT_PERFORMING_NEW_INSTALL = 10,
  ExtensionInstallReportLogEvent_FailureReason_TOO_OLD_PROFILE = 11,
  ExtensionInstallReportLogEvent_FailureReason_DO_NOT_INSTALL_FOR_ENTERPRISE = 12,
  ExtensionInstallReportLogEvent_FailureReason_ALREADY_INSTALLED = 13,
  ExtensionInstallReportLogEvent_FailureReason_CRX_FETCH_FAILED = 14,
  ExtensionInstallReportLogEvent_FailureReason_MANIFEST_FETCH_FAILED = 15,
  ExtensionInstallReportLogEvent_FailureReason_MANIFEST_INVALID = 16,
  ExtensionInstallReportLogEvent_FailureReason_NO_UPDATE = 17,
  ExtensionInstallReportLogEvent_FailureReason_CRX_INSTALL_ERROR_DECLINED = 18,
  ExtensionInstallReportLogEvent_FailureReason_CRX_INSTALL_ERROR_SANDBOXED_UNPACKER_FAILURE = 19,
  ExtensionInstallReportLogEvent_FailureReason_CRX_INSTALL_ERROR_OTHER = 20,
  ExtensionInstallReportLogEvent_FailureReason_NO_UPDATE_URL = 21,
  ExtensionInstallReportLogEvent_FailureReason_PENDING_ADD_FAILED = 22,
  ExtensionInstallReportLogEvent_FailureReason_DOWNLOADER_ADD_FAILED = 23,
  ExtensionInstallReportLogEvent_FailureReason_IN_PROGRESS = 24,
  ExtensionInstallReportLogEvent_FailureReason_CRX_FETCH_URL_EMPTY = 25,
  ExtensionInstallReportLogEvent_FailureReason_CRX_FETCH_URL_INVALID = 26,
  ExtensionInstallReportLogEvent_FailureReason_OVERRIDDEN_BY_SETTINGS = 27,
  ExtensionInstallReportLogEvent_FailureReason_REPLACED_BY_SYSTEM_APP = 28
};
bool ExtensionInstallReportLogEvent_FailureReason_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent_FailureReason_FailureReason_MIN = ExtensionInstallReportLogEvent_FailureReason_FAILURE_REASON_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent_FailureReason_FailureReason_MAX = ExtensionInstallReportLogEvent_FailureReason_REPLACED_BY_SYSTEM_APP;
constexpr int ExtensionInstallReportLogEvent_FailureReason_FailureReason_ARRAYSIZE = ExtensionInstallReportLogEvent_FailureReason_FailureReason_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_FailureReason_Name(ExtensionInstallReportLogEvent_FailureReason value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_FailureReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_FailureReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_FailureReason_Name.");
  return ExtensionInstallReportLogEvent_FailureReason_Name(static_cast<ExtensionInstallReportLogEvent_FailureReason>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_FailureReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_FailureReason* value);
enum ExtensionInstallReportLogEvent_InstallationStage : int {
  ExtensionInstallReportLogEvent_InstallationStage_INSTALLATION_STAGE_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_InstallationStage_CREATED = 1,
  ExtensionInstallReportLogEvent_InstallationStage_PENDING = 2,
  ExtensionInstallReportLogEvent_InstallationStage_DOWNLOADING = 3,
  ExtensionInstallReportLogEvent_InstallationStage_INSTALLING = 4,
  ExtensionInstallReportLogEvent_InstallationStage_COMPLETE = 5
};
bool ExtensionInstallReportLogEvent_InstallationStage_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent_InstallationStage_InstallationStage_MIN = ExtensionInstallReportLogEvent_InstallationStage_INSTALLATION_STAGE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent_InstallationStage_InstallationStage_MAX = ExtensionInstallReportLogEvent_InstallationStage_COMPLETE;
constexpr int ExtensionInstallReportLogEvent_InstallationStage_InstallationStage_ARRAYSIZE = ExtensionInstallReportLogEvent_InstallationStage_InstallationStage_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_InstallationStage_Name(ExtensionInstallReportLogEvent_InstallationStage value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_InstallationStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_InstallationStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_InstallationStage_Name.");
  return ExtensionInstallReportLogEvent_InstallationStage_Name(static_cast<ExtensionInstallReportLogEvent_InstallationStage>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_InstallationStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_InstallationStage* value);
enum ExtensionInstallReportLogEvent_UserType : int {
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_REGULAR = 1,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_GUEST = 2,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_PUBLIC_ACCOUNT = 3,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_SUPERVISED_DEPRECATED PROTOBUF_DEPRECATED_ENUM = 4,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_KIOSK_APP = 5,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_CHILD = 6,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_ARC_KIOSK_APP = 7,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_ACTIVE_DIRECTORY = 8,
  ExtensionInstallReportLogEvent_UserType_USER_TYPE_WEB_KIOSK_APP = 9
};
bool ExtensionInstallReportLogEvent_UserType_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent_UserType_UserType_MIN = ExtensionInstallReportLogEvent_UserType_USER_TYPE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent_UserType_UserType_MAX = ExtensionInstallReportLogEvent_UserType_USER_TYPE_WEB_KIOSK_APP;
constexpr int ExtensionInstallReportLogEvent_UserType_UserType_ARRAYSIZE = ExtensionInstallReportLogEvent_UserType_UserType_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_UserType_Name(ExtensionInstallReportLogEvent_UserType value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_UserType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_UserType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_UserType_Name.");
  return ExtensionInstallReportLogEvent_UserType_Name(static_cast<ExtensionInstallReportLogEvent_UserType>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_UserType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_UserType* value);
enum ExtensionInstallReportLogEvent_DownloadingStage : int {
  ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_STAGE_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOAD_PENDING = 1,
  ExtensionInstallReportLogEvent_DownloadingStage_QUEUED_FOR_MANIFEST = 2,
  ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_MANIFEST = 3,
  ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_MANIFEST_RETRY = 4,
  ExtensionInstallReportLogEvent_DownloadingStage_PARSING_MANIFEST = 5,
  ExtensionInstallReportLogEvent_DownloadingStage_MANIFEST_LOADED = 6,
  ExtensionInstallReportLogEvent_DownloadingStage_QUEUED_FOR_CRX = 7,
  ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_CRX = 8,
  ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_CRX_RETRY = 9,
  ExtensionInstallReportLogEvent_DownloadingStage_FINISHED = 10
};
bool ExtensionInstallReportLogEvent_DownloadingStage_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent_DownloadingStage_DownloadingStage_MIN = ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_STAGE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent_DownloadingStage_DownloadingStage_MAX = ExtensionInstallReportLogEvent_DownloadingStage_FINISHED;
constexpr int ExtensionInstallReportLogEvent_DownloadingStage_DownloadingStage_ARRAYSIZE = ExtensionInstallReportLogEvent_DownloadingStage_DownloadingStage_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_DownloadingStage_Name(ExtensionInstallReportLogEvent_DownloadingStage value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_DownloadingStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_DownloadingStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_DownloadingStage_Name.");
  return ExtensionInstallReportLogEvent_DownloadingStage_Name(static_cast<ExtensionInstallReportLogEvent_DownloadingStage>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_DownloadingStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_DownloadingStage* value);
enum ExtensionInstallReportLogEvent_InstallCreationStage : int {
  ExtensionInstallReportLogEvent_InstallCreationStage_INSTALL_CREATION_STAGE_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_InstallCreationStage_CREATION_INITIATED = 1,
  ExtensionInstallReportLogEvent_InstallCreationStage_NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_FORCED = 2,
  ExtensionInstallReportLogEvent_InstallCreationStage_NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_NOT_FORCED = 3,
  ExtensionInstallReportLogEvent_InstallCreationStage_NOTIFIED_FROM_MANAGEMENT = 4,
  ExtensionInstallReportLogEvent_InstallCreationStage_NOTIFIED_FROM_MANAGEMENT_NOT_FORCED = 5,
  ExtensionInstallReportLogEvent_InstallCreationStage_SEEN_BY_POLICY_LOADER = 6,
  ExtensionInstallReportLogEvent_InstallCreationStage_SEEN_BY_EXTERNAL_PROVIDER = 7
};
bool ExtensionInstallReportLogEvent_InstallCreationStage_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent_InstallCreationStage_InstallCreationStage_MIN = ExtensionInstallReportLogEvent_InstallCreationStage_INSTALL_CREATION_STAGE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent_InstallCreationStage_InstallCreationStage_MAX = ExtensionInstallReportLogEvent_InstallCreationStage_SEEN_BY_EXTERNAL_PROVIDER;
constexpr int ExtensionInstallReportLogEvent_InstallCreationStage_InstallCreationStage_ARRAYSIZE = ExtensionInstallReportLogEvent_InstallCreationStage_InstallCreationStage_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_InstallCreationStage_Name(ExtensionInstallReportLogEvent_InstallCreationStage value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_InstallCreationStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_InstallCreationStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_InstallCreationStage_Name.");
  return ExtensionInstallReportLogEvent_InstallCreationStage_Name(static_cast<ExtensionInstallReportLogEvent_InstallCreationStage>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_InstallCreationStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_InstallCreationStage* value);
enum ExtensionInstallReportLogEvent_DownloadCacheStatus : int {
  ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_DISABLED = 1,
  ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_MISS = 2,
  ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_OUTDATED = 3,
  ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_HIT = 4,
  ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_HIT_ON_MANIFEST_FETCH_FAILURE = 5
};
bool ExtensionInstallReportLogEvent_DownloadCacheStatus_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent_DownloadCacheStatus_DownloadCacheStatus_MIN = ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent_DownloadCacheStatus_DownloadCacheStatus_MAX = ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_HIT_ON_MANIFEST_FETCH_FAILURE;
constexpr int ExtensionInstallReportLogEvent_DownloadCacheStatus_DownloadCacheStatus_ARRAYSIZE = ExtensionInstallReportLogEvent_DownloadCacheStatus_DownloadCacheStatus_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_DownloadCacheStatus_Name(ExtensionInstallReportLogEvent_DownloadCacheStatus value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_DownloadCacheStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_DownloadCacheStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_DownloadCacheStatus_Name.");
  return ExtensionInstallReportLogEvent_DownloadCacheStatus_Name(static_cast<ExtensionInstallReportLogEvent_DownloadCacheStatus>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_DownloadCacheStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_DownloadCacheStatus* value);
enum ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason : int {
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SANDBOXED_UNPACKER_FAILURE_REASON_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_GET_TEMP_DIRECTORY = 1,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_CREATE_TEMP_DIRECTORY = 2,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_FAILED_TO_COPY_EXTENSION_FILE_TO_TEMP_DIRECTORY = 3,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_GET_SANDBOX_FRIENDLY_PATH = 4,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_LOCALIZE_EXTENSION = 5,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_MANIFEST = 6,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_UNPACKER_CLIENT_FAILED = 7,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_UTILITY_PROCESS_CRASHED_WHILE_TRYING_TO_INSTALL = 8,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_FILE_NOT_READABLE = 9,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_HEADER_INVALID = 10,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_MAGIC_NUMBER_INVALID = 11,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_VERSION_NUMBER_INVALID = 12,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_EXCESSIVELY_LARGE_KEY_OR_SIGNATURE = 13,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_ZERO_KEY_LENGTH = 14,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_ZERO_SIGNATURE_LENGTH = 15,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_PUBLIC_KEY_INVALID = 16,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_SIGNATURE_INVALID = 17,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_SIGNATURE_VERIFICATION_INITIALIZATION_FAILED = 18,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_SIGNATURE_VERIFICATION_FAILED = 19,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SERIALIZING_MANIFEST_JSON = 20,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SAVING_MANIFEST_JSON = 21,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_READ_IMAGE_DATA_FROM_DISK_UNUSED = 22,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_DECODED_IMAGES_DO_NOT_MATCH_THE_MANIFEST_UNUSED = 23,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_PATH_FOR_BROWSER_IMAGE = 24,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_REMOVING_OLD_IMAGE_FILE = 25,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_PATH_FOR_BITMAP_IMAGE = 26,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_RE_ENCODING_THEME_IMAGE = 27,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SAVING_THEME_IMAGE = 28,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_DEPRECATED_ABORTED_DUE_TO_SHUTDOWN = 29,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_READ_CATALOG_DATA_FROM_DISK_UNUSED = 30,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_CATALOG_DATA = 31,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_PATH_FOR_CATALOG_UNUSED = 32,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SERIALIZING_CATALOG = 33,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SAVING_CATALOG = 34,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_HASH_VERIFICATION_FAILED = 35,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_UNZIP_FAILED = 36,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_DIRECTORY_MOVE_FAILED = 37,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_FILE_IS_DELTA_UPDATE = 38,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_EXPECTED_HASH_INVALID = 39,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_DEPRECATED_ERROR_PARSING_DNR_RULESET = 40,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_INDEXING_DNR_RULESET = 41,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_REQUIRED_PROOF_MISSING = 42,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_HEADER_VERIFIED_CONTENTS_UNCOMPRESSING_FAILURE = 43,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_MALFORMED_VERIFIED_CONTENTS = 44,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_CREATE_METADATA_DIRECTORY = 45,
  ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_WRITE_VERIFIED_CONTENTS_INTO_FILE = 46
};
bool ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SandboxedUnpackerFailureReason_MIN = ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SANDBOXED_UNPACKER_FAILURE_REASON_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SandboxedUnpackerFailureReason_MAX = ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_WRITE_VERIFIED_CONTENTS_INTO_FILE;
constexpr int ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SandboxedUnpackerFailureReason_ARRAYSIZE = ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SandboxedUnpackerFailureReason_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Name(ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Name.");
  return ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Name(static_cast<ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason* value);
enum ExtensionInstallReportLogEvent_ManifestInvalidError : int {
  ExtensionInstallReportLogEvent_ManifestInvalidError_MANIFEST_INVALID_ERROR_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_ManifestInvalidError_XML_PARSING_FAILED = 1,
  ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_XLMNS_ON_GUPDATE_TAG = 2,
  ExtensionInstallReportLogEvent_ManifestInvalidError_MISSING_GUPDATE_TAG = 3,
  ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_PROTOCOL_ON_GUPDATE_TAG = 4,
  ExtensionInstallReportLogEvent_ManifestInvalidError_MISSING_APP_ID = 5,
  ExtensionInstallReportLogEvent_ManifestInvalidError_MISSING_UPDATE_CHECK_TAGS = 6,
  ExtensionInstallReportLogEvent_ManifestInvalidError_MULTIPLE_UPDATE_CHECK_TAGS = 7,
  ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_PRODVERSION_MIN = 8,
  ExtensionInstallReportLogEvent_ManifestInvalidError_EMPTY_CODEBASE_URL = 9,
  ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_CODEBASE_URL = 10,
  ExtensionInstallReportLogEvent_ManifestInvalidError_MISSING_VERSION_FOR_UPDATE_CHECK = 11,
  ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_VERSION = 12,
  ExtensionInstallReportLogEvent_ManifestInvalidError_BAD_UPDATE_SPECIFICATION = 13,
  ExtensionInstallReportLogEvent_ManifestInvalidError_BAD_APP_STATUS = 14
};
bool ExtensionInstallReportLogEvent_ManifestInvalidError_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent_ManifestInvalidError_ManifestInvalidError_MIN = ExtensionInstallReportLogEvent_ManifestInvalidError_MANIFEST_INVALID_ERROR_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent_ManifestInvalidError_ManifestInvalidError_MAX = ExtensionInstallReportLogEvent_ManifestInvalidError_BAD_APP_STATUS;
constexpr int ExtensionInstallReportLogEvent_ManifestInvalidError_ManifestInvalidError_ARRAYSIZE = ExtensionInstallReportLogEvent_ManifestInvalidError_ManifestInvalidError_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_ManifestInvalidError_Name(ExtensionInstallReportLogEvent_ManifestInvalidError value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_ManifestInvalidError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_ManifestInvalidError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_ManifestInvalidError_Name.");
  return ExtensionInstallReportLogEvent_ManifestInvalidError_Name(static_cast<ExtensionInstallReportLogEvent_ManifestInvalidError>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_ManifestInvalidError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_ManifestInvalidError* value);
enum ExtensionInstallReportLogEvent_CrxInstallErrorDetail : int {
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CRX_INSTALL_ERROR_DETAIL_UNKNOWN = 0,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CONVERT_USER_SCRIPT_TO_EXTENSION_FAILED = 1,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UNEXPECTED_ID = 2,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UNEXPECTED_VERSION = 3,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_MISMATCHED_VERSION = 4,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CRX_ERROR_MANIFEST_INVALID = 5,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_INSTALL_NOT_ENABLED = 6,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_OFFSTORE_INSTALL_DISALLOWED = 7,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_INCORRECT_APP_CONTENT_TYPE = 8,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_NOT_INSTALLED_FROM_GALLERY = 9,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_INCORRECT_INSTALL_HOST = 10,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_DEPENDENCY_NOT_SHARED_MODULE = 11,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_DEPENDENCY_OLD_VERSION = 12,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_DEPENDENCY_NOT_ALLOWLISTED = 13,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UNSUPPORTED_REQUIREMENTS = 14,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_EXTENSION_IS_BLOCKLISTED = 15,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_DISALLOWED_BY_POLICY = 16,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_KIOSK_MODE_ONLY = 17,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_OVERLAPPING_WEB_EXTENT = 18,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CANT_DOWNGRADE_VERSION = 19,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_MOVE_DIRECTORY_TO_PROFILE_FAILED = 20,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CANT_LOAD_EXTENSION = 21,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_USER_CANCELED = 22,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_USER_ABORTED = 23,
  ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UPDATE_NON_EXISTING_EXTENSION = 24
};
bool ExtensionInstallReportLogEvent_CrxInstallErrorDetail_IsValid(int value);
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CrxInstallErrorDetail_MIN = ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CRX_INSTALL_ERROR_DETAIL_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CrxInstallErrorDetail_MAX = ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UPDATE_NON_EXISTING_EXTENSION;
constexpr int ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CrxInstallErrorDetail_ARRAYSIZE = ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CrxInstallErrorDetail_MAX + 1;

const std::string& ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Name(ExtensionInstallReportLogEvent_CrxInstallErrorDetail value);
template<typename T>
inline const std::string& ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionInstallReportLogEvent_CrxInstallErrorDetail>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Name.");
  return ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Name(static_cast<ExtensionInstallReportLogEvent_CrxInstallErrorDetail>(enum_t_value));
}
bool ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_CrxInstallErrorDetail* value);
enum AppInstallReportLogEvent_EventType : int {
  AppInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN = 0,
  AppInstallReportLogEvent_EventType_SERVER_REQUEST = 1,
  AppInstallReportLogEvent_EventType_CLOUDDPC_REQUEST = 2,
  AppInstallReportLogEvent_EventType_CLOUDDPS_REQUEST = 3,
  AppInstallReportLogEvent_EventType_CLOUDDPS_RESPONSE = 4,
  AppInstallReportLogEvent_EventType_PHONESKY_LOG = 5,
  AppInstallReportLogEvent_EventType_SUCCESS = 6,
  AppInstallReportLogEvent_EventType_CANCELED = 7,
  AppInstallReportLogEvent_EventType_CONNECTIVITY_CHANGE = 8,
  AppInstallReportLogEvent_EventType_SESSION_STATE_CHANGE = 9,
  AppInstallReportLogEvent_EventType_INSTALLATION_STARTED = 10,
  AppInstallReportLogEvent_EventType_INSTALLATION_FINISHED = 11,
  AppInstallReportLogEvent_EventType_INSTALLATION_FAILED = 12,
  AppInstallReportLogEvent_EventType_DIRECT_INSTALL = 13,
  AppInstallReportLogEvent_EventType_CLOUDDPC_MAIN_LOOP_FAILED = 14,
  AppInstallReportLogEvent_EventType_PLAYSTORE_LOCAL_POLICY_SET = 15
};
bool AppInstallReportLogEvent_EventType_IsValid(int value);
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent_EventType_EventType_MIN = AppInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent_EventType_EventType_MAX = AppInstallReportLogEvent_EventType_PLAYSTORE_LOCAL_POLICY_SET;
constexpr int AppInstallReportLogEvent_EventType_EventType_ARRAYSIZE = AppInstallReportLogEvent_EventType_EventType_MAX + 1;

const std::string& AppInstallReportLogEvent_EventType_Name(AppInstallReportLogEvent_EventType value);
template<typename T>
inline const std::string& AppInstallReportLogEvent_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppInstallReportLogEvent_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppInstallReportLogEvent_EventType_Name.");
  return AppInstallReportLogEvent_EventType_Name(static_cast<AppInstallReportLogEvent_EventType>(enum_t_value));
}
bool AppInstallReportLogEvent_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppInstallReportLogEvent_EventType* value);
enum AppInstallReportLogEvent_SessionStateChangeType : int {
  AppInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN = 0,
  AppInstallReportLogEvent_SessionStateChangeType_LOGIN = 1,
  AppInstallReportLogEvent_SessionStateChangeType_LOGOUT = 2,
  AppInstallReportLogEvent_SessionStateChangeType_SUSPEND = 3,
  AppInstallReportLogEvent_SessionStateChangeType_RESUME = 4
};
bool AppInstallReportLogEvent_SessionStateChangeType_IsValid(int value);
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MIN = AppInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN;
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX = AppInstallReportLogEvent_SessionStateChangeType_RESUME;
constexpr int AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_ARRAYSIZE = AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX + 1;

const std::string& AppInstallReportLogEvent_SessionStateChangeType_Name(AppInstallReportLogEvent_SessionStateChangeType value);
template<typename T>
inline const std::string& AppInstallReportLogEvent_SessionStateChangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppInstallReportLogEvent_SessionStateChangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppInstallReportLogEvent_SessionStateChangeType_Name.");
  return AppInstallReportLogEvent_SessionStateChangeType_Name(static_cast<AppInstallReportLogEvent_SessionStateChangeType>(enum_t_value));
}
bool AppInstallReportLogEvent_SessionStateChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppInstallReportLogEvent_SessionStateChangeType* value);
enum RefreshAccountRequest_AccountType : int {
  RefreshAccountRequest_AccountType_ACCOUNT_TYPE_UNSPECIFIED = 0,
  RefreshAccountRequest_AccountType_CHROME_OS_DEMO_MODE = 1
};
bool RefreshAccountRequest_AccountType_IsValid(int value);
constexpr RefreshAccountRequest_AccountType RefreshAccountRequest_AccountType_AccountType_MIN = RefreshAccountRequest_AccountType_ACCOUNT_TYPE_UNSPECIFIED;
constexpr RefreshAccountRequest_AccountType RefreshAccountRequest_AccountType_AccountType_MAX = RefreshAccountRequest_AccountType_CHROME_OS_DEMO_MODE;
constexpr int RefreshAccountRequest_AccountType_AccountType_ARRAYSIZE = RefreshAccountRequest_AccountType_AccountType_MAX + 1;

const std::string& RefreshAccountRequest_AccountType_Name(RefreshAccountRequest_AccountType value);
template<typename T>
inline const std::string& RefreshAccountRequest_AccountType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RefreshAccountRequest_AccountType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RefreshAccountRequest_AccountType_Name.");
  return RefreshAccountRequest_AccountType_Name(static_cast<RefreshAccountRequest_AccountType>(enum_t_value));
}
bool RefreshAccountRequest_AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RefreshAccountRequest_AccountType* value);
enum PrintJobEvent_PrintSettings_ColorMode : int {
  PrintJobEvent_PrintSettings_ColorMode_UNKNOWN_COLOR_MODE = 0,
  PrintJobEvent_PrintSettings_ColorMode_BLACK_AND_WHITE = 1,
  PrintJobEvent_PrintSettings_ColorMode_COLOR = 2
};
bool PrintJobEvent_PrintSettings_ColorMode_IsValid(int value);
constexpr PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings_ColorMode_ColorMode_MIN = PrintJobEvent_PrintSettings_ColorMode_UNKNOWN_COLOR_MODE;
constexpr PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings_ColorMode_ColorMode_MAX = PrintJobEvent_PrintSettings_ColorMode_COLOR;
constexpr int PrintJobEvent_PrintSettings_ColorMode_ColorMode_ARRAYSIZE = PrintJobEvent_PrintSettings_ColorMode_ColorMode_MAX + 1;

const std::string& PrintJobEvent_PrintSettings_ColorMode_Name(PrintJobEvent_PrintSettings_ColorMode value);
template<typename T>
inline const std::string& PrintJobEvent_PrintSettings_ColorMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrintJobEvent_PrintSettings_ColorMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrintJobEvent_PrintSettings_ColorMode_Name.");
  return PrintJobEvent_PrintSettings_ColorMode_Name(static_cast<PrintJobEvent_PrintSettings_ColorMode>(enum_t_value));
}
bool PrintJobEvent_PrintSettings_ColorMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrintJobEvent_PrintSettings_ColorMode* value);
enum PrintJobEvent_PrintSettings_DuplexMode : int {
  PrintJobEvent_PrintSettings_DuplexMode_UNKNOWN_DUPLEX_MODE = 0,
  PrintJobEvent_PrintSettings_DuplexMode_ONE_SIDED = 1,
  PrintJobEvent_PrintSettings_DuplexMode_TWO_SIDED_LONG_EDGE = 2,
  PrintJobEvent_PrintSettings_DuplexMode_TWO_SIDED_SHORT_EDGE = 3
};
bool PrintJobEvent_PrintSettings_DuplexMode_IsValid(int value);
constexpr PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings_DuplexMode_DuplexMode_MIN = PrintJobEvent_PrintSettings_DuplexMode_UNKNOWN_DUPLEX_MODE;
constexpr PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings_DuplexMode_DuplexMode_MAX = PrintJobEvent_PrintSettings_DuplexMode_TWO_SIDED_SHORT_EDGE;
constexpr int PrintJobEvent_PrintSettings_DuplexMode_DuplexMode_ARRAYSIZE = PrintJobEvent_PrintSettings_DuplexMode_DuplexMode_MAX + 1;

const std::string& PrintJobEvent_PrintSettings_DuplexMode_Name(PrintJobEvent_PrintSettings_DuplexMode value);
template<typename T>
inline const std::string& PrintJobEvent_PrintSettings_DuplexMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrintJobEvent_PrintSettings_DuplexMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrintJobEvent_PrintSettings_DuplexMode_Name.");
  return PrintJobEvent_PrintSettings_DuplexMode_Name(static_cast<PrintJobEvent_PrintSettings_DuplexMode>(enum_t_value));
}
bool PrintJobEvent_PrintSettings_DuplexMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrintJobEvent_PrintSettings_DuplexMode* value);
enum PrintJobEvent_UserType : int {
  PrintJobEvent_UserType_UNKNOWN_USER_TYPE = 0,
  PrintJobEvent_UserType_REGULAR = 1,
  PrintJobEvent_UserType_GUEST = 2,
  PrintJobEvent_UserType_KIOSK = 3
};
bool PrintJobEvent_UserType_IsValid(int value);
constexpr PrintJobEvent_UserType PrintJobEvent_UserType_UserType_MIN = PrintJobEvent_UserType_UNKNOWN_USER_TYPE;
constexpr PrintJobEvent_UserType PrintJobEvent_UserType_UserType_MAX = PrintJobEvent_UserType_KIOSK;
constexpr int PrintJobEvent_UserType_UserType_ARRAYSIZE = PrintJobEvent_UserType_UserType_MAX + 1;

const std::string& PrintJobEvent_UserType_Name(PrintJobEvent_UserType value);
template<typename T>
inline const std::string& PrintJobEvent_UserType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrintJobEvent_UserType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrintJobEvent_UserType_Name.");
  return PrintJobEvent_UserType_Name(static_cast<PrintJobEvent_UserType>(enum_t_value));
}
bool PrintJobEvent_UserType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrintJobEvent_UserType* value);
enum App_AppType : int {
  App_AppType_UNKNOWN = 0,
  App_AppType_ARC = 1,
  App_AppType_BUILT_IN = 2,
  App_AppType_CROSTINI = 3,
  App_AppType_EXTENSION = 4,
  App_AppType_WEB = 5,
  App_AppType_PLUGIN_VM = 6,
  App_AppType_BOREALIS = 7,
  App_AppType_BRUSCHETTA = 8
};
bool App_AppType_IsValid(int value);
constexpr App_AppType App_AppType_AppType_MIN = App_AppType_UNKNOWN;
constexpr App_AppType App_AppType_AppType_MAX = App_AppType_BRUSCHETTA;
constexpr int App_AppType_AppType_ARRAYSIZE = App_AppType_AppType_MAX + 1;

const std::string& App_AppType_Name(App_AppType value);
template<typename T>
inline const std::string& App_AppType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, App_AppType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function App_AppType_Name.");
  return App_AppType_Name(static_cast<App_AppType>(enum_t_value));
}
bool App_AppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, App_AppType* value);
enum AppActivity_AppState : int {
  AppActivity_AppState_UNKNOWN = 0,
  AppActivity_AppState_DEFAULT = 1,
  AppActivity_AppState_ALWAYS_AVAILABLE = 2,
  AppActivity_AppState_BLOCKED = 3,
  AppActivity_AppState_LIMIT_REACHED = 4,
  AppActivity_AppState_UNINSTALLED = 5
};
bool AppActivity_AppState_IsValid(int value);
constexpr AppActivity_AppState AppActivity_AppState_AppState_MIN = AppActivity_AppState_UNKNOWN;
constexpr AppActivity_AppState AppActivity_AppState_AppState_MAX = AppActivity_AppState_UNINSTALLED;
constexpr int AppActivity_AppState_AppState_ARRAYSIZE = AppActivity_AppState_AppState_MAX + 1;

const std::string& AppActivity_AppState_Name(AppActivity_AppState value);
template<typename T>
inline const std::string& AppActivity_AppState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppActivity_AppState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppActivity_AppState_Name.");
  return AppActivity_AppState_Name(static_cast<AppActivity_AppState>(enum_t_value));
}
bool AppActivity_AppState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppActivity_AppState* value);
enum ClientCertificateProvisioningResponse_Error : int {
  ClientCertificateProvisioningResponse_Error_UNDEFINED = 0,
  ClientCertificateProvisioningResponse_Error_TIMED_OUT = 1,
  ClientCertificateProvisioningResponse_Error_IDENTITY_VERIFICATION_ERROR = 2,
  ClientCertificateProvisioningResponse_Error_CA_ERROR = 3,
  ClientCertificateProvisioningResponse_Error_INCONSISTENT_DATA = 4,
  ClientCertificateProvisioningResponse_Error_BAD_PUBLIC_KEY = 5,
  ClientCertificateProvisioningResponse_Error_BAD_CA_CERTIFICATE_SPECIFIED = 6,
  ClientCertificateProvisioningResponse_Error_BAD_CLIENT_CERTIFICATE_RECEIVED = 7,
  ClientCertificateProvisioningResponse_Error_INVALID_CSR_SIGNATURE = 8,
  ClientCertificateProvisioningResponse_Error_CSR_ALREADY_SENT = 9
};
bool ClientCertificateProvisioningResponse_Error_IsValid(int value);
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse_Error_Error_MIN = ClientCertificateProvisioningResponse_Error_UNDEFINED;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse_Error_Error_MAX = ClientCertificateProvisioningResponse_Error_CSR_ALREADY_SENT;
constexpr int ClientCertificateProvisioningResponse_Error_Error_ARRAYSIZE = ClientCertificateProvisioningResponse_Error_Error_MAX + 1;

const std::string& ClientCertificateProvisioningResponse_Error_Name(ClientCertificateProvisioningResponse_Error value);
template<typename T>
inline const std::string& ClientCertificateProvisioningResponse_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientCertificateProvisioningResponse_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientCertificateProvisioningResponse_Error_Name.");
  return ClientCertificateProvisioningResponse_Error_Name(static_cast<ClientCertificateProvisioningResponse_Error>(enum_t_value));
}
bool ClientCertificateProvisioningResponse_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientCertificateProvisioningResponse_Error* value);
enum BrowserPublicKeyUploadRequest_KeyTrustLevel : int {
  BrowserPublicKeyUploadRequest_KeyTrustLevel_KEY_TRUST_LEVEL_UNSPECIFIED = 0,
  BrowserPublicKeyUploadRequest_KeyTrustLevel_CHROME_BROWSER_HW_KEY = 1,
  BrowserPublicKeyUploadRequest_KeyTrustLevel_CHROME_BROWSER_OS_KEY = 2
};
bool BrowserPublicKeyUploadRequest_KeyTrustLevel_IsValid(int value);
constexpr BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest_KeyTrustLevel_KeyTrustLevel_MIN = BrowserPublicKeyUploadRequest_KeyTrustLevel_KEY_TRUST_LEVEL_UNSPECIFIED;
constexpr BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest_KeyTrustLevel_KeyTrustLevel_MAX = BrowserPublicKeyUploadRequest_KeyTrustLevel_CHROME_BROWSER_OS_KEY;
constexpr int BrowserPublicKeyUploadRequest_KeyTrustLevel_KeyTrustLevel_ARRAYSIZE = BrowserPublicKeyUploadRequest_KeyTrustLevel_KeyTrustLevel_MAX + 1;

const std::string& BrowserPublicKeyUploadRequest_KeyTrustLevel_Name(BrowserPublicKeyUploadRequest_KeyTrustLevel value);
template<typename T>
inline const std::string& BrowserPublicKeyUploadRequest_KeyTrustLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrowserPublicKeyUploadRequest_KeyTrustLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrowserPublicKeyUploadRequest_KeyTrustLevel_Name.");
  return BrowserPublicKeyUploadRequest_KeyTrustLevel_Name(static_cast<BrowserPublicKeyUploadRequest_KeyTrustLevel>(enum_t_value));
}
bool BrowserPublicKeyUploadRequest_KeyTrustLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrowserPublicKeyUploadRequest_KeyTrustLevel* value);
enum BrowserPublicKeyUploadRequest_KeyType : int {
  BrowserPublicKeyUploadRequest_KeyType_KEY_TYPE_UNSPECIFIED = 0,
  BrowserPublicKeyUploadRequest_KeyType_RSA_KEY = 1,
  BrowserPublicKeyUploadRequest_KeyType_EC_KEY = 2
};
bool BrowserPublicKeyUploadRequest_KeyType_IsValid(int value);
constexpr BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest_KeyType_KeyType_MIN = BrowserPublicKeyUploadRequest_KeyType_KEY_TYPE_UNSPECIFIED;
constexpr BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest_KeyType_KeyType_MAX = BrowserPublicKeyUploadRequest_KeyType_EC_KEY;
constexpr int BrowserPublicKeyUploadRequest_KeyType_KeyType_ARRAYSIZE = BrowserPublicKeyUploadRequest_KeyType_KeyType_MAX + 1;

const std::string& BrowserPublicKeyUploadRequest_KeyType_Name(BrowserPublicKeyUploadRequest_KeyType value);
template<typename T>
inline const std::string& BrowserPublicKeyUploadRequest_KeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrowserPublicKeyUploadRequest_KeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrowserPublicKeyUploadRequest_KeyType_Name.");
  return BrowserPublicKeyUploadRequest_KeyType_Name(static_cast<BrowserPublicKeyUploadRequest_KeyType>(enum_t_value));
}
bool BrowserPublicKeyUploadRequest_KeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrowserPublicKeyUploadRequest_KeyType* value);
enum BrowserPublicKeyUploadResponse_ResponseCode : int {
  BrowserPublicKeyUploadResponse_ResponseCode_UNDEFINED = 0,
  BrowserPublicKeyUploadResponse_ResponseCode_SUCCESS = 1,
  BrowserPublicKeyUploadResponse_ResponseCode_INVALID_SIGNATURE = 2
};
bool BrowserPublicKeyUploadResponse_ResponseCode_IsValid(int value);
constexpr BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse_ResponseCode_ResponseCode_MIN = BrowserPublicKeyUploadResponse_ResponseCode_UNDEFINED;
constexpr BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse_ResponseCode_ResponseCode_MAX = BrowserPublicKeyUploadResponse_ResponseCode_INVALID_SIGNATURE;
constexpr int BrowserPublicKeyUploadResponse_ResponseCode_ResponseCode_ARRAYSIZE = BrowserPublicKeyUploadResponse_ResponseCode_ResponseCode_MAX + 1;

const std::string& BrowserPublicKeyUploadResponse_ResponseCode_Name(BrowserPublicKeyUploadResponse_ResponseCode value);
template<typename T>
inline const std::string& BrowserPublicKeyUploadResponse_ResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrowserPublicKeyUploadResponse_ResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrowserPublicKeyUploadResponse_ResponseCode_Name.");
  return BrowserPublicKeyUploadResponse_ResponseCode_Name(static_cast<BrowserPublicKeyUploadResponse_ResponseCode>(enum_t_value));
}
bool BrowserPublicKeyUploadResponse_ResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrowserPublicKeyUploadResponse_ResponseCode* value);
enum UserSessionType : int {
  USER_SESSION_TYPE_UNKNOWN = 0,
  AUTO_LAUNCHED_KIOSK_SESSION = 1,
  MANUALLY_LAUNCHED_KIOSK_SESSION = 2,
  AFFILIATED_USER_SESSION = 3,
  UNAFFILIATED_USER_SESSION = 4,
  MANAGED_GUEST_SESSION = 5,
  GUEST_SESSION = 6,
  NO_SESSION = 7
};
bool UserSessionType_IsValid(int value);
constexpr UserSessionType UserSessionType_MIN = USER_SESSION_TYPE_UNKNOWN;
constexpr UserSessionType UserSessionType_MAX = NO_SESSION;
constexpr int UserSessionType_ARRAYSIZE = UserSessionType_MAX + 1;

const std::string& UserSessionType_Name(UserSessionType value);
template<typename T>
inline const std::string& UserSessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserSessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserSessionType_Name.");
  return UserSessionType_Name(static_cast<UserSessionType>(enum_t_value));
}
bool UserSessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserSessionType* value);
enum CrdSessionType : int {
  CRD_SESSION_TYPE_UNKNOWN = 0,
  REMOTE_ACCESS_SESSION = 1,
  REMOTE_SUPPORT_SESSION = 2
};
bool CrdSessionType_IsValid(int value);
constexpr CrdSessionType CrdSessionType_MIN = CRD_SESSION_TYPE_UNKNOWN;
constexpr CrdSessionType CrdSessionType_MAX = REMOTE_SUPPORT_SESSION;
constexpr int CrdSessionType_ARRAYSIZE = CrdSessionType_MAX + 1;

const std::string& CrdSessionType_Name(CrdSessionType value);
template<typename T>
inline const std::string& CrdSessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CrdSessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CrdSessionType_Name.");
  return CrdSessionType_Name(static_cast<CrdSessionType>(enum_t_value));
}
bool CrdSessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrdSessionType* value);
enum CrdSessionAvailability : int {
  CRD_SESSION_AVAILABILITY_UNKNOWN = 0,
  AVAILABLE = 1,
  UNAVAILABLE_UNSUPPORTED_USER_SESSION_TYPE = 2,
  UNAVAILABLE_UNMANAGED_ENVIRONMENT = 3
};
bool CrdSessionAvailability_IsValid(int value);
constexpr CrdSessionAvailability CrdSessionAvailability_MIN = CRD_SESSION_AVAILABILITY_UNKNOWN;
constexpr CrdSessionAvailability CrdSessionAvailability_MAX = UNAVAILABLE_UNMANAGED_ENVIRONMENT;
constexpr int CrdSessionAvailability_ARRAYSIZE = CrdSessionAvailability_MAX + 1;

const std::string& CrdSessionAvailability_Name(CrdSessionAvailability value);
template<typename T>
inline const std::string& CrdSessionAvailability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CrdSessionAvailability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CrdSessionAvailability_Name.");
  return CrdSessionAvailability_Name(static_cast<CrdSessionAvailability>(enum_t_value));
}
bool CrdSessionAvailability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrdSessionAvailability* value);
enum Channel : int {
  CHANNEL_UNKNOWN = 0,
  CHANNEL_CANARY = 1,
  CHANNEL_DEV = 2,
  CHANNEL_BETA = 3,
  CHANNEL_STABLE = 4
};
bool Channel_IsValid(int value);
constexpr Channel Channel_MIN = CHANNEL_UNKNOWN;
constexpr Channel Channel_MAX = CHANNEL_STABLE;
constexpr int Channel_ARRAYSIZE = Channel_MAX + 1;

const std::string& Channel_Name(Channel value);
template<typename T>
inline const std::string& Channel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Channel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Channel_Name.");
  return Channel_Name(static_cast<Channel>(enum_t_value));
}
bool Channel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Channel* value);
enum BusDeviceClass : int {
  DEVICE_CLASS_UNSPECIFIED = 0,
  DISPLAY_CONTROLLER = 1,
  ETHERNET_CONTROLLER = 2,
  WIRELESS_CONTROLLER = 3,
  BLUETOOTH_ADAPTER = 4,
  THUNDERBOLT_CONTROLLER = 5
};
bool BusDeviceClass_IsValid(int value);
constexpr BusDeviceClass BusDeviceClass_MIN = DEVICE_CLASS_UNSPECIFIED;
constexpr BusDeviceClass BusDeviceClass_MAX = THUNDERBOLT_CONTROLLER;
constexpr int BusDeviceClass_ARRAYSIZE = BusDeviceClass_MAX + 1;

const std::string& BusDeviceClass_Name(BusDeviceClass value);
template<typename T>
inline const std::string& BusDeviceClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BusDeviceClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BusDeviceClass_Name.");
  return BusDeviceClass_Name(static_cast<BusDeviceClass>(enum_t_value));
}
bool BusDeviceClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BusDeviceClass* value);
enum BusType : int {
  BUS_TYPE_UNSPECIFIED = 0,
  PCI_BUS = 1,
  USB_BUS = 2,
  THUNDERBOLT_BUS = 3
};
bool BusType_IsValid(int value);
constexpr BusType BusType_MIN = BUS_TYPE_UNSPECIFIED;
constexpr BusType BusType_MAX = THUNDERBOLT_BUS;
constexpr int BusType_ARRAYSIZE = BusType_MAX + 1;

const std::string& BusType_Name(BusType value);
template<typename T>
inline const std::string& BusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BusType_Name.");
  return BusType_Name(static_cast<BusType>(enum_t_value));
}
bool BusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BusType* value);
enum PartialReportType : int {
  UNSPECIFIED = 0,
  EXTENSION_REQUEST = 1
};
bool PartialReportType_IsValid(int value);
constexpr PartialReportType PartialReportType_MIN = UNSPECIFIED;
constexpr PartialReportType PartialReportType_MAX = EXTENSION_REQUEST;
constexpr int PartialReportType_ARRAYSIZE = PartialReportType_MAX + 1;

const std::string& PartialReportType_Name(PartialReportType value);
template<typename T>
inline const std::string& PartialReportType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartialReportType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartialReportType_Name.");
  return PartialReportType_Name(static_cast<PartialReportType>(enum_t_value));
}
bool PartialReportType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PartialReportType* value);
enum CrostiniAppType : int {
  CROSTINI_APP_TYPE_TERMINAL = 0,
  CROSTINI_APP_TYPE_INTERACTIVE = 1,
  CROSTINI_APP_TYPE_OTHER = 2
};
bool CrostiniAppType_IsValid(int value);
constexpr CrostiniAppType CrostiniAppType_MIN = CROSTINI_APP_TYPE_TERMINAL;
constexpr CrostiniAppType CrostiniAppType_MAX = CROSTINI_APP_TYPE_OTHER;
constexpr int CrostiniAppType_ARRAYSIZE = CrostiniAppType_MAX + 1;

const std::string& CrostiniAppType_Name(CrostiniAppType value);
template<typename T>
inline const std::string& CrostiniAppType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CrostiniAppType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CrostiniAppType_Name.");
  return CrostiniAppType_Name(static_cast<CrostiniAppType>(enum_t_value));
}
bool CrostiniAppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrostiniAppType* value);
enum HashingAlgorithm : int {
  HASHING_ALGORITHM_UNSPECIFIED = 0,
  SHA1 = 1,
  SHA256 = 2,
  NO_HASH = 3
};
bool HashingAlgorithm_IsValid(int value);
constexpr HashingAlgorithm HashingAlgorithm_MIN = HASHING_ALGORITHM_UNSPECIFIED;
constexpr HashingAlgorithm HashingAlgorithm_MAX = NO_HASH;
constexpr int HashingAlgorithm_ARRAYSIZE = HashingAlgorithm_MAX + 1;

const std::string& HashingAlgorithm_Name(HashingAlgorithm value);
template<typename T>
inline const std::string& HashingAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HashingAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HashingAlgorithm_Name.");
  return HashingAlgorithm_Name(static_cast<HashingAlgorithm>(enum_t_value));
}
bool HashingAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HashingAlgorithm* value);
enum SigningAlgorithm : int {
  SIGNING_ALGORITHM_UNSPECIFIED = 0,
  RSA_PKCS1_V1_5 = 1
};
bool SigningAlgorithm_IsValid(int value);
constexpr SigningAlgorithm SigningAlgorithm_MIN = SIGNING_ALGORITHM_UNSPECIFIED;
constexpr SigningAlgorithm SigningAlgorithm_MAX = RSA_PKCS1_V1_5;
constexpr int SigningAlgorithm_ARRAYSIZE = SigningAlgorithm_MAX + 1;

const std::string& SigningAlgorithm_Name(SigningAlgorithm value);
template<typename T>
inline const std::string& SigningAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SigningAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SigningAlgorithm_Name.");
  return SigningAlgorithm_Name(static_cast<SigningAlgorithm>(enum_t_value));
}
bool SigningAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SigningAlgorithm* value);
enum DeviceManagementErrorDetail : int {
  NO_ERROR_DETAIL = 0,
  CBCM_DELETION_POLICY_PREFERENCE_DELETE_TOKEN = 1,
  CBCM_DELETION_POLICY_PREFERENCE_INVALIDATE_TOKEN = 2
};
bool DeviceManagementErrorDetail_IsValid(int value);
constexpr DeviceManagementErrorDetail DeviceManagementErrorDetail_MIN = NO_ERROR_DETAIL;
constexpr DeviceManagementErrorDetail DeviceManagementErrorDetail_MAX = CBCM_DELETION_POLICY_PREFERENCE_INVALIDATE_TOKEN;
constexpr int DeviceManagementErrorDetail_ARRAYSIZE = DeviceManagementErrorDetail_MAX + 1;

const std::string& DeviceManagementErrorDetail_Name(DeviceManagementErrorDetail value);
template<typename T>
inline const std::string& DeviceManagementErrorDetail_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceManagementErrorDetail>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceManagementErrorDetail_Name.");
  return DeviceManagementErrorDetail_Name(static_cast<DeviceManagementErrorDetail>(enum_t_value));
}
bool DeviceManagementErrorDetail_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceManagementErrorDetail* value);
// ===================================================================

class LicenseType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LicenseType) */ {
 public:
  inline LicenseType() : LicenseType(nullptr) {}
  ~LicenseType() override;
  explicit PROTOBUF_CONSTEXPR LicenseType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LicenseType(const LicenseType& from);
  LicenseType(LicenseType&& from) noexcept
    : LicenseType() {
    *this = ::std::move(from);
  }

  inline LicenseType& operator=(const LicenseType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicenseType& operator=(LicenseType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LicenseType& default_instance() {
    return *internal_default_instance();
  }
  static inline const LicenseType* internal_default_instance() {
    return reinterpret_cast<const LicenseType*>(
               &_LicenseType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LicenseType& a, LicenseType& b) {
    a.Swap(&b);
  }
  inline void Swap(LicenseType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicenseType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LicenseType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LicenseType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LicenseType& from);
  void MergeFrom(const LicenseType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LicenseType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LicenseType";
  }
  protected:
  explicit LicenseType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LicenseType_LicenseTypeEnum LicenseTypeEnum;
  static constexpr LicenseTypeEnum UNDEFINED =
    LicenseType_LicenseTypeEnum_UNDEFINED;
  static constexpr LicenseTypeEnum CDM_PERPETUAL =
    LicenseType_LicenseTypeEnum_CDM_PERPETUAL;
  static constexpr LicenseTypeEnum CDM_ANNUAL =
    LicenseType_LicenseTypeEnum_CDM_ANNUAL;
  static constexpr LicenseTypeEnum KIOSK =
    LicenseType_LicenseTypeEnum_KIOSK;
  static constexpr LicenseTypeEnum CDM_PACKAGED =
    LicenseType_LicenseTypeEnum_CDM_PACKAGED;
  static inline bool LicenseTypeEnum_IsValid(int value) {
    return LicenseType_LicenseTypeEnum_IsValid(value);
  }
  static constexpr LicenseTypeEnum LicenseTypeEnum_MIN =
    LicenseType_LicenseTypeEnum_LicenseTypeEnum_MIN;
  static constexpr LicenseTypeEnum LicenseTypeEnum_MAX =
    LicenseType_LicenseTypeEnum_LicenseTypeEnum_MAX;
  static constexpr int LicenseTypeEnum_ARRAYSIZE =
    LicenseType_LicenseTypeEnum_LicenseTypeEnum_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LicenseTypeEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LicenseTypeEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LicenseTypeEnum_Name.");
    return LicenseType_LicenseTypeEnum_Name(enum_t_value);
  }
  static inline bool LicenseTypeEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LicenseTypeEnum* value) {
    return LicenseType_LicenseTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseTypeFieldNumber = 1,
  };
  // optional .enterprise_management.LicenseType.LicenseTypeEnum license_type = 1;
  bool has_license_type() const;
  private:
  bool _internal_has_license_type() const;
  public:
  void clear_license_type();
  ::enterprise_management::LicenseType_LicenseTypeEnum license_type() const;
  void set_license_type(::enterprise_management::LicenseType_LicenseTypeEnum value);
  private:
  ::enterprise_management::LicenseType_LicenseTypeEnum _internal_license_type() const;
  void _internal_set_license_type(::enterprise_management::LicenseType_LicenseTypeEnum value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LicenseType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int license_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class SignedData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SignedData) */ {
 public:
  inline SignedData() : SignedData(nullptr) {}
  ~SignedData() override;
  explicit PROTOBUF_CONSTEXPR SignedData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedData(const SignedData& from);
  SignedData(SignedData&& from) noexcept
    : SignedData() {
    *this = ::std::move(from);
  }

  inline SignedData& operator=(const SignedData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedData& operator=(SignedData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SignedData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedData* internal_default_instance() {
    return reinterpret_cast<const SignedData*>(
               &_SignedData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignedData& a, SignedData& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SignedData& from);
  void MergeFrom(const SignedData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignedData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SignedData";
  }
  protected:
  explicit SignedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSignatureFieldNumber = 2,
    kExtraDataBytesFieldNumber = 3,
  };
  // optional bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bytes signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional int32 extra_data_bytes = 3;
  bool has_extra_data_bytes() const;
  private:
  bool _internal_has_extra_data_bytes() const;
  public:
  void clear_extra_data_bytes();
  int32_t extra_data_bytes() const;
  void set_extra_data_bytes(int32_t value);
  private:
  int32_t _internal_extra_data_bytes() const;
  void _internal_set_extra_data_bytes(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SignedData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    int32_t extra_data_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CheckUserAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckUserAccountRequest) */ {
 public:
  inline CheckUserAccountRequest() : CheckUserAccountRequest(nullptr) {}
  ~CheckUserAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckUserAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckUserAccountRequest(const CheckUserAccountRequest& from);
  CheckUserAccountRequest(CheckUserAccountRequest&& from) noexcept
    : CheckUserAccountRequest() {
    *this = ::std::move(from);
  }

  inline CheckUserAccountRequest& operator=(const CheckUserAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckUserAccountRequest& operator=(CheckUserAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckUserAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckUserAccountRequest* internal_default_instance() {
    return reinterpret_cast<const CheckUserAccountRequest*>(
               &_CheckUserAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CheckUserAccountRequest& a, CheckUserAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckUserAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckUserAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckUserAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckUserAccountRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckUserAccountRequest& from);
  void MergeFrom(const CheckUserAccountRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckUserAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CheckUserAccountRequest";
  }
  protected:
  explicit CheckUserAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserEmailFieldNumber = 1,
  };
  // optional string user_email = 1;
  bool has_user_email() const;
  private:
  bool _internal_has_user_email() const;
  public:
  void clear_user_email();
  const std::string& user_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_email();
  PROTOBUF_NODISCARD std::string* release_user_email();
  void set_allocated_user_email(std::string* user_email);
  private:
  const std::string& _internal_user_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_email(const std::string& value);
  std::string* _internal_mutable_user_email();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CheckUserAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_email_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceRegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRegisterRequest) */ {
 public:
  inline DeviceRegisterRequest() : DeviceRegisterRequest(nullptr) {}
  ~DeviceRegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceRegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRegisterRequest(const DeviceRegisterRequest& from);
  DeviceRegisterRequest(DeviceRegisterRequest&& from) noexcept
    : DeviceRegisterRequest() {
    *this = ::std::move(from);
  }

  inline DeviceRegisterRequest& operator=(const DeviceRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRegisterRequest& operator=(DeviceRegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceRegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRegisterRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceRegisterRequest*>(
               &_DeviceRegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeviceRegisterRequest& a, DeviceRegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRegisterRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceRegisterRequest& from);
  void MergeFrom(const DeviceRegisterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceRegisterRequest";
  }
  protected:
  explicit DeviceRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceRegisterRequest_Type Type;
  static constexpr Type TT =
    DeviceRegisterRequest_Type_TT;
  static constexpr Type USER =
    DeviceRegisterRequest_Type_USER;
  static constexpr Type DEVICE =
    DeviceRegisterRequest_Type_DEVICE;
  static constexpr Type BROWSER =
    DeviceRegisterRequest_Type_BROWSER;
  static constexpr Type ANDROID_BROWSER =
    DeviceRegisterRequest_Type_ANDROID_BROWSER;
  static constexpr Type IOS_BROWSER =
    DeviceRegisterRequest_Type_IOS_BROWSER;
  static inline bool Type_IsValid(int value) {
    return DeviceRegisterRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DeviceRegisterRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DeviceRegisterRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DeviceRegisterRequest_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DeviceRegisterRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DeviceRegisterRequest_Type_Parse(name, value);
  }

  typedef DeviceRegisterRequest_Flavor Flavor;
  static constexpr Flavor FLAVOR_ENROLLMENT_MANUAL =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL;
  static constexpr Flavor FLAVOR_ENROLLMENT_MANUAL_RENEW =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_MANUAL_RENEW;
  static constexpr Flavor FLAVOR_ENROLLMENT_LOCAL_FORCED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_FORCED;
  static constexpr Flavor FLAVOR_ENROLLMENT_LOCAL_ADVERTISED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_LOCAL_ADVERTISED;
  static constexpr Flavor FLAVOR_ENROLLMENT_SERVER_FORCED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_FORCED;
  static constexpr Flavor FLAVOR_ENROLLMENT_SERVER_ADVERTISED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_SERVER_ADVERTISED;
  static constexpr Flavor FLAVOR_ENROLLMENT_RECOVERY =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_RECOVERY;
  static constexpr Flavor FLAVOR_USER_REGISTRATION =
    DeviceRegisterRequest_Flavor_FLAVOR_USER_REGISTRATION;
  static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION;
  static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED;
  static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED;
  static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK;
  static constexpr Flavor FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED;
  static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED;
  static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK;
  static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_FORCED =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_FORCED;
  static constexpr Flavor FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_MANUAL_FALLBACK =
    DeviceRegisterRequest_Flavor_FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_MANUAL_FALLBACK;
  static inline bool Flavor_IsValid(int value) {
    return DeviceRegisterRequest_Flavor_IsValid(value);
  }
  static constexpr Flavor Flavor_MIN =
    DeviceRegisterRequest_Flavor_Flavor_MIN;
  static constexpr Flavor Flavor_MAX =
    DeviceRegisterRequest_Flavor_Flavor_MAX;
  static constexpr int Flavor_ARRAYSIZE =
    DeviceRegisterRequest_Flavor_Flavor_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flavor_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flavor>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flavor_Name.");
    return DeviceRegisterRequest_Flavor_Name(enum_t_value);
  }
  static inline bool Flavor_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flavor* value) {
    return DeviceRegisterRequest_Flavor_Parse(name, value);
  }

  typedef DeviceRegisterRequest_Lifetime Lifetime;
  static constexpr Lifetime LIFETIME_UNDEFINED =
    DeviceRegisterRequest_Lifetime_LIFETIME_UNDEFINED;
  static constexpr Lifetime LIFETIME_INDEFINITE =
    DeviceRegisterRequest_Lifetime_LIFETIME_INDEFINITE;
  static constexpr Lifetime LIFETIME_EPHEMERAL_USER =
    DeviceRegisterRequest_Lifetime_LIFETIME_EPHEMERAL_USER;
  static inline bool Lifetime_IsValid(int value) {
    return DeviceRegisterRequest_Lifetime_IsValid(value);
  }
  static constexpr Lifetime Lifetime_MIN =
    DeviceRegisterRequest_Lifetime_Lifetime_MIN;
  static constexpr Lifetime Lifetime_MAX =
    DeviceRegisterRequest_Lifetime_Lifetime_MAX;
  static constexpr int Lifetime_ARRAYSIZE =
    DeviceRegisterRequest_Lifetime_Lifetime_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Lifetime_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Lifetime>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Lifetime_Name.");
    return DeviceRegisterRequest_Lifetime_Name(enum_t_value);
  }
  static inline bool Lifetime_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Lifetime* value) {
    return DeviceRegisterRequest_Lifetime_Parse(name, value);
  }

  typedef DeviceRegisterRequest_PsmExecutionResult PsmExecutionResult;
  static constexpr PsmExecutionResult PSM_RESULT_UNKNOWN =
    DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_UNKNOWN;
  static constexpr PsmExecutionResult PSM_RESULT_SUCCESSFUL_WITH_STATE =
    DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_SUCCESSFUL_WITH_STATE;
  static constexpr PsmExecutionResult PSM_RESULT_SUCCESSFUL_WITHOUT_STATE =
    DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_SUCCESSFUL_WITHOUT_STATE;
  static constexpr PsmExecutionResult PSM_RESULT_ERROR =
    DeviceRegisterRequest_PsmExecutionResult_PSM_RESULT_ERROR;
  static inline bool PsmExecutionResult_IsValid(int value) {
    return DeviceRegisterRequest_PsmExecutionResult_IsValid(value);
  }
  static constexpr PsmExecutionResult PsmExecutionResult_MIN =
    DeviceRegisterRequest_PsmExecutionResult_PsmExecutionResult_MIN;
  static constexpr PsmExecutionResult PsmExecutionResult_MAX =
    DeviceRegisterRequest_PsmExecutionResult_PsmExecutionResult_MAX;
  static constexpr int PsmExecutionResult_ARRAYSIZE =
    DeviceRegisterRequest_PsmExecutionResult_PsmExecutionResult_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PsmExecutionResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PsmExecutionResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PsmExecutionResult_Name.");
    return DeviceRegisterRequest_PsmExecutionResult_Name(enum_t_value);
  }
  static inline bool PsmExecutionResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PsmExecutionResult* value) {
    return DeviceRegisterRequest_PsmExecutionResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMachineIdFieldNumber = 3,
    kMachineModelFieldNumber = 4,
    kRequisitionFieldNumber = 6,
    kServerBackedStateKeyFieldNumber = 7,
    kBrandCodeFieldNumber = 12,
    kReregistrationDmTokenFieldNumber = 13,
    kEthernetMacAddressFieldNumber = 14,
    kDockMacAddressFieldNumber = 15,
    kManufactureDateFieldNumber = 16,
    kExpectedEnrollmentDomainFieldNumber = 17,
    kLicenseTypeFieldNumber = 9,
    kDeviceRegisterIdentificationFieldNumber = 18,
    kReregisterFieldNumber = 1,
    kTypeFieldNumber = 2,
    kFlavorFieldNumber = 8,
    kPsmExecutionResultFieldNumber = 19,
    kPsmDeterminationTimestampMsFieldNumber = 20,
    kLifetimeFieldNumber = 11,
  };
  // optional string machine_id = 3;
  bool has_machine_id() const;
  private:
  bool _internal_has_machine_id() const;
  public:
  void clear_machine_id();
  const std::string& machine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_id();
  PROTOBUF_NODISCARD std::string* release_machine_id();
  void set_allocated_machine_id(std::string* machine_id);
  private:
  const std::string& _internal_machine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_id(const std::string& value);
  std::string* _internal_mutable_machine_id();
  public:

  // optional string machine_model = 4;
  bool has_machine_model() const;
  private:
  bool _internal_has_machine_model() const;
  public:
  void clear_machine_model();
  const std::string& machine_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_model();
  PROTOBUF_NODISCARD std::string* release_machine_model();
  void set_allocated_machine_model(std::string* machine_model);
  private:
  const std::string& _internal_machine_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_model(const std::string& value);
  std::string* _internal_mutable_machine_model();
  public:

  // optional string requisition = 6;
  bool has_requisition() const;
  private:
  bool _internal_has_requisition() const;
  public:
  void clear_requisition();
  const std::string& requisition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requisition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requisition();
  PROTOBUF_NODISCARD std::string* release_requisition();
  void set_allocated_requisition(std::string* requisition);
  private:
  const std::string& _internal_requisition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requisition(const std::string& value);
  std::string* _internal_mutable_requisition();
  public:

  // optional bytes server_backed_state_key = 7;
  bool has_server_backed_state_key() const;
  private:
  bool _internal_has_server_backed_state_key() const;
  public:
  void clear_server_backed_state_key();
  const std::string& server_backed_state_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_backed_state_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_backed_state_key();
  PROTOBUF_NODISCARD std::string* release_server_backed_state_key();
  void set_allocated_server_backed_state_key(std::string* server_backed_state_key);
  private:
  const std::string& _internal_server_backed_state_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_backed_state_key(const std::string& value);
  std::string* _internal_mutable_server_backed_state_key();
  public:

  // optional string brand_code = 12;
  bool has_brand_code() const;
  private:
  bool _internal_has_brand_code() const;
  public:
  void clear_brand_code();
  const std::string& brand_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brand_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brand_code();
  PROTOBUF_NODISCARD std::string* release_brand_code();
  void set_allocated_brand_code(std::string* brand_code);
  private:
  const std::string& _internal_brand_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brand_code(const std::string& value);
  std::string* _internal_mutable_brand_code();
  public:

  // optional string reregistration_dm_token = 13;
  bool has_reregistration_dm_token() const;
  private:
  bool _internal_has_reregistration_dm_token() const;
  public:
  void clear_reregistration_dm_token();
  const std::string& reregistration_dm_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reregistration_dm_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reregistration_dm_token();
  PROTOBUF_NODISCARD std::string* release_reregistration_dm_token();
  void set_allocated_reregistration_dm_token(std::string* reregistration_dm_token);
  private:
  const std::string& _internal_reregistration_dm_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reregistration_dm_token(const std::string& value);
  std::string* _internal_mutable_reregistration_dm_token();
  public:

  // optional string ethernet_mac_address = 14;
  bool has_ethernet_mac_address() const;
  private:
  bool _internal_has_ethernet_mac_address() const;
  public:
  void clear_ethernet_mac_address();
  const std::string& ethernet_mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ethernet_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ethernet_mac_address();
  PROTOBUF_NODISCARD std::string* release_ethernet_mac_address();
  void set_allocated_ethernet_mac_address(std::string* ethernet_mac_address);
  private:
  const std::string& _internal_ethernet_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ethernet_mac_address(const std::string& value);
  std::string* _internal_mutable_ethernet_mac_address();
  public:

  // optional string dock_mac_address = 15;
  bool has_dock_mac_address() const;
  private:
  bool _internal_has_dock_mac_address() const;
  public:
  void clear_dock_mac_address();
  const std::string& dock_mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dock_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dock_mac_address();
  PROTOBUF_NODISCARD std::string* release_dock_mac_address();
  void set_allocated_dock_mac_address(std::string* dock_mac_address);
  private:
  const std::string& _internal_dock_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dock_mac_address(const std::string& value);
  std::string* _internal_mutable_dock_mac_address();
  public:

  // optional string manufacture_date = 16;
  bool has_manufacture_date() const;
  private:
  bool _internal_has_manufacture_date() const;
  public:
  void clear_manufacture_date();
  const std::string& manufacture_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacture_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacture_date();
  PROTOBUF_NODISCARD std::string* release_manufacture_date();
  void set_allocated_manufacture_date(std::string* manufacture_date);
  private:
  const std::string& _internal_manufacture_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacture_date(const std::string& value);
  std::string* _internal_mutable_manufacture_date();
  public:

  // optional string expected_enrollment_domain = 17;
  bool has_expected_enrollment_domain() const;
  private:
  bool _internal_has_expected_enrollment_domain() const;
  public:
  void clear_expected_enrollment_domain();
  const std::string& expected_enrollment_domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expected_enrollment_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expected_enrollment_domain();
  PROTOBUF_NODISCARD std::string* release_expected_enrollment_domain();
  void set_allocated_expected_enrollment_domain(std::string* expected_enrollment_domain);
  private:
  const std::string& _internal_expected_enrollment_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expected_enrollment_domain(const std::string& value);
  std::string* _internal_mutable_expected_enrollment_domain();
  public:

  // optional .enterprise_management.LicenseType license_type = 9;
  bool has_license_type() const;
  private:
  bool _internal_has_license_type() const;
  public:
  void clear_license_type();
  const ::enterprise_management::LicenseType& license_type() const;
  PROTOBUF_NODISCARD ::enterprise_management::LicenseType* release_license_type();
  ::enterprise_management::LicenseType* mutable_license_type();
  void set_allocated_license_type(::enterprise_management::LicenseType* license_type);
  private:
  const ::enterprise_management::LicenseType& _internal_license_type() const;
  ::enterprise_management::LicenseType* _internal_mutable_license_type();
  public:
  void unsafe_arena_set_allocated_license_type(
      ::enterprise_management::LicenseType* license_type);
  ::enterprise_management::LicenseType* unsafe_arena_release_license_type();

  // optional .enterprise_management.DeviceRegisterIdentification device_register_identification = 18;
  bool has_device_register_identification() const;
  private:
  bool _internal_has_device_register_identification() const;
  public:
  void clear_device_register_identification();
  const ::enterprise_management::DeviceRegisterIdentification& device_register_identification() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRegisterIdentification* release_device_register_identification();
  ::enterprise_management::DeviceRegisterIdentification* mutable_device_register_identification();
  void set_allocated_device_register_identification(::enterprise_management::DeviceRegisterIdentification* device_register_identification);
  private:
  const ::enterprise_management::DeviceRegisterIdentification& _internal_device_register_identification() const;
  ::enterprise_management::DeviceRegisterIdentification* _internal_mutable_device_register_identification();
  public:
  void unsafe_arena_set_allocated_device_register_identification(
      ::enterprise_management::DeviceRegisterIdentification* device_register_identification);
  ::enterprise_management::DeviceRegisterIdentification* unsafe_arena_release_device_register_identification();

  // optional bool reregister = 1;
  bool has_reregister() const;
  private:
  bool _internal_has_reregister() const;
  public:
  void clear_reregister();
  bool reregister() const;
  void set_reregister(bool value);
  private:
  bool _internal_reregister() const;
  void _internal_set_reregister(bool value);
  public:

  // optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::enterprise_management::DeviceRegisterRequest_Type type() const;
  void set_type(::enterprise_management::DeviceRegisterRequest_Type value);
  private:
  ::enterprise_management::DeviceRegisterRequest_Type _internal_type() const;
  void _internal_set_type(::enterprise_management::DeviceRegisterRequest_Type value);
  public:

  // optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
  bool has_flavor() const;
  private:
  bool _internal_has_flavor() const;
  public:
  void clear_flavor();
  ::enterprise_management::DeviceRegisterRequest_Flavor flavor() const;
  void set_flavor(::enterprise_management::DeviceRegisterRequest_Flavor value);
  private:
  ::enterprise_management::DeviceRegisterRequest_Flavor _internal_flavor() const;
  void _internal_set_flavor(::enterprise_management::DeviceRegisterRequest_Flavor value);
  public:

  // optional .enterprise_management.DeviceRegisterRequest.PsmExecutionResult psm_execution_result = 19;
  bool has_psm_execution_result() const;
  private:
  bool _internal_has_psm_execution_result() const;
  public:
  void clear_psm_execution_result();
  ::enterprise_management::DeviceRegisterRequest_PsmExecutionResult psm_execution_result() const;
  void set_psm_execution_result(::enterprise_management::DeviceRegisterRequest_PsmExecutionResult value);
  private:
  ::enterprise_management::DeviceRegisterRequest_PsmExecutionResult _internal_psm_execution_result() const;
  void _internal_set_psm_execution_result(::enterprise_management::DeviceRegisterRequest_PsmExecutionResult value);
  public:

  // optional int64 psm_determination_timestamp_ms = 20;
  bool has_psm_determination_timestamp_ms() const;
  private:
  bool _internal_has_psm_determination_timestamp_ms() const;
  public:
  void clear_psm_determination_timestamp_ms();
  int64_t psm_determination_timestamp_ms() const;
  void set_psm_determination_timestamp_ms(int64_t value);
  private:
  int64_t _internal_psm_determination_timestamp_ms() const;
  void _internal_set_psm_determination_timestamp_ms(int64_t value);
  public:

  // optional .enterprise_management.DeviceRegisterRequest.Lifetime lifetime = 11 [default = LIFETIME_INDEFINITE];
  bool has_lifetime() const;
  private:
  bool _internal_has_lifetime() const;
  public:
  void clear_lifetime();
  ::enterprise_management::DeviceRegisterRequest_Lifetime lifetime() const;
  void set_lifetime(::enterprise_management::DeviceRegisterRequest_Lifetime value);
  private:
  ::enterprise_management::DeviceRegisterRequest_Lifetime _internal_lifetime() const;
  void _internal_set_lifetime(::enterprise_management::DeviceRegisterRequest_Lifetime value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requisition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_backed_state_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reregistration_dm_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ethernet_mac_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dock_mac_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacture_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expected_enrollment_domain_;
    ::enterprise_management::LicenseType* license_type_;
    ::enterprise_management::DeviceRegisterIdentification* device_register_identification_;
    bool reregister_;
    int type_;
    int flavor_;
    int psm_execution_result_;
    int64_t psm_determination_timestamp_ms_;
    int lifetime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceRegisterIdentification final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRegisterIdentification) */ {
 public:
  inline DeviceRegisterIdentification() : DeviceRegisterIdentification(nullptr) {}
  ~DeviceRegisterIdentification() override;
  explicit PROTOBUF_CONSTEXPR DeviceRegisterIdentification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRegisterIdentification(const DeviceRegisterIdentification& from);
  DeviceRegisterIdentification(DeviceRegisterIdentification&& from) noexcept
    : DeviceRegisterIdentification() {
    *this = ::std::move(from);
  }

  inline DeviceRegisterIdentification& operator=(const DeviceRegisterIdentification& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRegisterIdentification& operator=(DeviceRegisterIdentification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceRegisterIdentification& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRegisterIdentification* internal_default_instance() {
    return reinterpret_cast<const DeviceRegisterIdentification*>(
               &_DeviceRegisterIdentification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeviceRegisterIdentification& a, DeviceRegisterIdentification& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRegisterIdentification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRegisterIdentification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRegisterIdentification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRegisterIdentification>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceRegisterIdentification& from);
  void MergeFrom(const DeviceRegisterIdentification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRegisterIdentification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceRegisterIdentification";
  }
  protected:
  explicit DeviceRegisterIdentification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttestedDeviceIdFieldNumber = 1,
  };
  // optional string attested_device_id = 1;
  bool has_attested_device_id() const;
  private:
  bool _internal_has_attested_device_id() const;
  public:
  void clear_attested_device_id();
  const std::string& attested_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attested_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attested_device_id();
  PROTOBUF_NODISCARD std::string* release_attested_device_id();
  void set_allocated_attested_device_id(std::string* attested_device_id);
  private:
  const std::string& _internal_attested_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attested_device_id(const std::string& value);
  std::string* _internal_mutable_attested_device_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterIdentification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attested_device_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CheckUserAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckUserAccountResponse) */ {
 public:
  inline CheckUserAccountResponse() : CheckUserAccountResponse(nullptr) {}
  ~CheckUserAccountResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckUserAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckUserAccountResponse(const CheckUserAccountResponse& from);
  CheckUserAccountResponse(CheckUserAccountResponse&& from) noexcept
    : CheckUserAccountResponse() {
    *this = ::std::move(from);
  }

  inline CheckUserAccountResponse& operator=(const CheckUserAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckUserAccountResponse& operator=(CheckUserAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckUserAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckUserAccountResponse* internal_default_instance() {
    return reinterpret_cast<const CheckUserAccountResponse*>(
               &_CheckUserAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CheckUserAccountResponse& a, CheckUserAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckUserAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckUserAccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckUserAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckUserAccountResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckUserAccountResponse& from);
  void MergeFrom(const CheckUserAccountResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckUserAccountResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CheckUserAccountResponse";
  }
  protected:
  explicit CheckUserAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CheckUserAccountResponse_UserAccountType UserAccountType;
  static constexpr UserAccountType UNKNOWN_USER_ACCOUNT_TYPE =
    CheckUserAccountResponse_UserAccountType_UNKNOWN_USER_ACCOUNT_TYPE;
  static constexpr UserAccountType NOT_EXIST =
    CheckUserAccountResponse_UserAccountType_NOT_EXIST;
  static constexpr UserAccountType CONSUMER =
    CheckUserAccountResponse_UserAccountType_CONSUMER;
  static constexpr UserAccountType DASHER =
    CheckUserAccountResponse_UserAccountType_DASHER;
  static inline bool UserAccountType_IsValid(int value) {
    return CheckUserAccountResponse_UserAccountType_IsValid(value);
  }
  static constexpr UserAccountType UserAccountType_MIN =
    CheckUserAccountResponse_UserAccountType_UserAccountType_MIN;
  static constexpr UserAccountType UserAccountType_MAX =
    CheckUserAccountResponse_UserAccountType_UserAccountType_MAX;
  static constexpr int UserAccountType_ARRAYSIZE =
    CheckUserAccountResponse_UserAccountType_UserAccountType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& UserAccountType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UserAccountType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UserAccountType_Name.");
    return CheckUserAccountResponse_UserAccountType_Name(enum_t_value);
  }
  static inline bool UserAccountType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UserAccountType* value) {
    return CheckUserAccountResponse_UserAccountType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDomainVerifiedFieldNumber = 1,
    kUserAccountTypeFieldNumber = 2,
  };
  // optional bool domain_verified = 1;
  bool has_domain_verified() const;
  private:
  bool _internal_has_domain_verified() const;
  public:
  void clear_domain_verified();
  bool domain_verified() const;
  void set_domain_verified(bool value);
  private:
  bool _internal_domain_verified() const;
  void _internal_set_domain_verified(bool value);
  public:

  // optional .enterprise_management.CheckUserAccountResponse.UserAccountType user_account_type = 2;
  bool has_user_account_type() const;
  private:
  bool _internal_has_user_account_type() const;
  public:
  void clear_user_account_type();
  ::enterprise_management::CheckUserAccountResponse_UserAccountType user_account_type() const;
  void set_user_account_type(::enterprise_management::CheckUserAccountResponse_UserAccountType value);
  private:
  ::enterprise_management::CheckUserAccountResponse_UserAccountType _internal_user_account_type() const;
  void _internal_set_user_account_type(::enterprise_management::CheckUserAccountResponse_UserAccountType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CheckUserAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool domain_verified_;
    int user_account_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceRegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRegisterResponse) */ {
 public:
  inline DeviceRegisterResponse() : DeviceRegisterResponse(nullptr) {}
  ~DeviceRegisterResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceRegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRegisterResponse(const DeviceRegisterResponse& from);
  DeviceRegisterResponse(DeviceRegisterResponse&& from) noexcept
    : DeviceRegisterResponse() {
    *this = ::std::move(from);
  }

  inline DeviceRegisterResponse& operator=(const DeviceRegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRegisterResponse& operator=(DeviceRegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceRegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRegisterResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceRegisterResponse*>(
               &_DeviceRegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeviceRegisterResponse& a, DeviceRegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRegisterResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceRegisterResponse& from);
  void MergeFrom(const DeviceRegisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceRegisterResponse";
  }
  protected:
  explicit DeviceRegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceRegisterResponse_DeviceMode DeviceMode;
  static constexpr DeviceMode ENTERPRISE =
    DeviceRegisterResponse_DeviceMode_ENTERPRISE;
  static constexpr DeviceMode RETAIL_DEPRECATED =
    DeviceRegisterResponse_DeviceMode_RETAIL_DEPRECATED;
  static constexpr DeviceMode CHROME_AD =
    DeviceRegisterResponse_DeviceMode_CHROME_AD;
  static constexpr DeviceMode DEMO =
    DeviceRegisterResponse_DeviceMode_DEMO;
  static inline bool DeviceMode_IsValid(int value) {
    return DeviceRegisterResponse_DeviceMode_IsValid(value);
  }
  static constexpr DeviceMode DeviceMode_MIN =
    DeviceRegisterResponse_DeviceMode_DeviceMode_MIN;
  static constexpr DeviceMode DeviceMode_MAX =
    DeviceRegisterResponse_DeviceMode_DeviceMode_MAX;
  static constexpr int DeviceMode_ARRAYSIZE =
    DeviceRegisterResponse_DeviceMode_DeviceMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DeviceMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeviceMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeviceMode_Name.");
    return DeviceRegisterResponse_DeviceMode_Name(enum_t_value);
  }
  static inline bool DeviceMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeviceMode* value) {
    return DeviceRegisterResponse_DeviceMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserAffiliationIdsFieldNumber = 5,
    kDeviceManagementTokenFieldNumber = 1,
    kMachineNameFieldNumber = 2,
    kConfigurationSeedFieldNumber = 4,
    kDirectoryApiIdFieldNumber = 6,
    kEnrollmentTypeFieldNumber = 3,
  };
  // repeated string user_affiliation_ids = 5;
  int user_affiliation_ids_size() const;
  private:
  int _internal_user_affiliation_ids_size() const;
  public:
  void clear_user_affiliation_ids();
  const std::string& user_affiliation_ids(int index) const;
  std::string* mutable_user_affiliation_ids(int index);
  void set_user_affiliation_ids(int index, const std::string& value);
  void set_user_affiliation_ids(int index, std::string&& value);
  void set_user_affiliation_ids(int index, const char* value);
  void set_user_affiliation_ids(int index, const char* value, size_t size);
  std::string* add_user_affiliation_ids();
  void add_user_affiliation_ids(const std::string& value);
  void add_user_affiliation_ids(std::string&& value);
  void add_user_affiliation_ids(const char* value);
  void add_user_affiliation_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_affiliation_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_affiliation_ids();
  private:
  const std::string& _internal_user_affiliation_ids(int index) const;
  std::string* _internal_add_user_affiliation_ids();
  public:

  // required string device_management_token = 1;
  bool has_device_management_token() const;
  private:
  bool _internal_has_device_management_token() const;
  public:
  void clear_device_management_token();
  const std::string& device_management_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_management_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_management_token();
  PROTOBUF_NODISCARD std::string* release_device_management_token();
  void set_allocated_device_management_token(std::string* device_management_token);
  private:
  const std::string& _internal_device_management_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_management_token(const std::string& value);
  std::string* _internal_mutable_device_management_token();
  public:

  // optional string machine_name = 2;
  bool has_machine_name() const;
  private:
  bool _internal_has_machine_name() const;
  public:
  void clear_machine_name();
  const std::string& machine_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_name();
  PROTOBUF_NODISCARD std::string* release_machine_name();
  void set_allocated_machine_name(std::string* machine_name);
  private:
  const std::string& _internal_machine_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_name(const std::string& value);
  std::string* _internal_mutable_machine_name();
  public:

  // optional string configuration_seed = 4;
  bool has_configuration_seed() const;
  private:
  bool _internal_has_configuration_seed() const;
  public:
  void clear_configuration_seed();
  const std::string& configuration_seed() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configuration_seed(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configuration_seed();
  PROTOBUF_NODISCARD std::string* release_configuration_seed();
  void set_allocated_configuration_seed(std::string* configuration_seed);
  private:
  const std::string& _internal_configuration_seed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configuration_seed(const std::string& value);
  std::string* _internal_mutable_configuration_seed();
  public:

  // optional string directory_api_id = 6;
  bool has_directory_api_id() const;
  private:
  bool _internal_has_directory_api_id() const;
  public:
  void clear_directory_api_id();
  const std::string& directory_api_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directory_api_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directory_api_id();
  PROTOBUF_NODISCARD std::string* release_directory_api_id();
  void set_allocated_directory_api_id(std::string* directory_api_id);
  private:
  const std::string& _internal_directory_api_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory_api_id(const std::string& value);
  std::string* _internal_mutable_directory_api_id();
  public:

  // optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
  bool has_enrollment_type() const;
  private:
  bool _internal_has_enrollment_type() const;
  public:
  void clear_enrollment_type();
  ::enterprise_management::DeviceRegisterResponse_DeviceMode enrollment_type() const;
  void set_enrollment_type(::enterprise_management::DeviceRegisterResponse_DeviceMode value);
  private:
  ::enterprise_management::DeviceRegisterResponse_DeviceMode _internal_enrollment_type() const;
  void _internal_set_enrollment_type(::enterprise_management::DeviceRegisterResponse_DeviceMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_affiliation_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_management_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configuration_seed_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_api_id_;
    int enrollment_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceUnregisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUnregisterRequest) */ {
 public:
  inline DeviceUnregisterRequest() : DeviceUnregisterRequest(nullptr) {}
  ~DeviceUnregisterRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceUnregisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceUnregisterRequest(const DeviceUnregisterRequest& from);
  DeviceUnregisterRequest(DeviceUnregisterRequest&& from) noexcept
    : DeviceUnregisterRequest() {
    *this = ::std::move(from);
  }

  inline DeviceUnregisterRequest& operator=(const DeviceUnregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceUnregisterRequest& operator=(DeviceUnregisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceUnregisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceUnregisterRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceUnregisterRequest*>(
               &_DeviceUnregisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeviceUnregisterRequest& a, DeviceUnregisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceUnregisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceUnregisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceUnregisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceUnregisterRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceUnregisterRequest& from);
  void MergeFrom(const DeviceUnregisterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceUnregisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceUnregisterRequest";
  }
  protected:
  explicit DeviceUnregisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUnregisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceUnregisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUnregisterResponse) */ {
 public:
  inline DeviceUnregisterResponse() : DeviceUnregisterResponse(nullptr) {}
  ~DeviceUnregisterResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceUnregisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceUnregisterResponse(const DeviceUnregisterResponse& from);
  DeviceUnregisterResponse(DeviceUnregisterResponse&& from) noexcept
    : DeviceUnregisterResponse() {
    *this = ::std::move(from);
  }

  inline DeviceUnregisterResponse& operator=(const DeviceUnregisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceUnregisterResponse& operator=(DeviceUnregisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceUnregisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceUnregisterResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceUnregisterResponse*>(
               &_DeviceUnregisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeviceUnregisterResponse& a, DeviceUnregisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceUnregisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceUnregisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceUnregisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceUnregisterResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceUnregisterResponse& from);
  void MergeFrom(const DeviceUnregisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceUnregisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceUnregisterResponse";
  }
  protected:
  explicit DeviceUnregisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUnregisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceCertUploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceCertUploadRequest) */ {
 public:
  inline DeviceCertUploadRequest() : DeviceCertUploadRequest(nullptr) {}
  ~DeviceCertUploadRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceCertUploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceCertUploadRequest(const DeviceCertUploadRequest& from);
  DeviceCertUploadRequest(DeviceCertUploadRequest&& from) noexcept
    : DeviceCertUploadRequest() {
    *this = ::std::move(from);
  }

  inline DeviceCertUploadRequest& operator=(const DeviceCertUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceCertUploadRequest& operator=(DeviceCertUploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceCertUploadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceCertUploadRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceCertUploadRequest*>(
               &_DeviceCertUploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeviceCertUploadRequest& a, DeviceCertUploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceCertUploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceCertUploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceCertUploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceCertUploadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceCertUploadRequest& from);
  void MergeFrom(const DeviceCertUploadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceCertUploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceCertUploadRequest";
  }
  protected:
  explicit DeviceCertUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceCertUploadRequest_CertificateType CertificateType;
  static constexpr CertificateType CERTIFICATE_TYPE_UNSPECIFIED =
    DeviceCertUploadRequest_CertificateType_CERTIFICATE_TYPE_UNSPECIFIED;
  static constexpr CertificateType ENTERPRISE_MACHINE_CERTIFICATE =
    DeviceCertUploadRequest_CertificateType_ENTERPRISE_MACHINE_CERTIFICATE;
  static constexpr CertificateType ENTERPRISE_ENROLLMENT_CERTIFICATE =
    DeviceCertUploadRequest_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
  static inline bool CertificateType_IsValid(int value) {
    return DeviceCertUploadRequest_CertificateType_IsValid(value);
  }
  static constexpr CertificateType CertificateType_MIN =
    DeviceCertUploadRequest_CertificateType_CertificateType_MIN;
  static constexpr CertificateType CertificateType_MAX =
    DeviceCertUploadRequest_CertificateType_CertificateType_MAX;
  static constexpr int CertificateType_ARRAYSIZE =
    DeviceCertUploadRequest_CertificateType_CertificateType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CertificateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CertificateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CertificateType_Name.");
    return DeviceCertUploadRequest_CertificateType_Name(enum_t_value);
  }
  static inline bool CertificateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CertificateType* value) {
    return DeviceCertUploadRequest_CertificateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceCertificateFieldNumber = 1,
    kEnrollmentIdFieldNumber = 3,
    kCertificateTypeFieldNumber = 2,
  };
  // optional bytes device_certificate = 1;
  bool has_device_certificate() const;
  private:
  bool _internal_has_device_certificate() const;
  public:
  void clear_device_certificate();
  const std::string& device_certificate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_certificate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_certificate();
  PROTOBUF_NODISCARD std::string* release_device_certificate();
  void set_allocated_device_certificate(std::string* device_certificate);
  private:
  const std::string& _internal_device_certificate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_certificate(const std::string& value);
  std::string* _internal_mutable_device_certificate();
  public:

  // optional bytes enrollment_id = 3;
  bool has_enrollment_id() const;
  private:
  bool _internal_has_enrollment_id() const;
  public:
  void clear_enrollment_id();
  const std::string& enrollment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollment_id();
  PROTOBUF_NODISCARD std::string* release_enrollment_id();
  void set_allocated_enrollment_id(std::string* enrollment_id);
  private:
  const std::string& _internal_enrollment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollment_id(const std::string& value);
  std::string* _internal_mutable_enrollment_id();
  public:

  // optional .enterprise_management.DeviceCertUploadRequest.CertificateType certificate_type = 2;
  bool has_certificate_type() const;
  private:
  bool _internal_has_certificate_type() const;
  public:
  void clear_certificate_type();
  ::enterprise_management::DeviceCertUploadRequest_CertificateType certificate_type() const;
  void set_certificate_type(::enterprise_management::DeviceCertUploadRequest_CertificateType value);
  private:
  ::enterprise_management::DeviceCertUploadRequest_CertificateType _internal_certificate_type() const;
  void _internal_set_certificate_type(::enterprise_management::DeviceCertUploadRequest_CertificateType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceCertUploadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_certificate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollment_id_;
    int certificate_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceCertUploadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceCertUploadResponse) */ {
 public:
  inline DeviceCertUploadResponse() : DeviceCertUploadResponse(nullptr) {}
  ~DeviceCertUploadResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceCertUploadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceCertUploadResponse(const DeviceCertUploadResponse& from);
  DeviceCertUploadResponse(DeviceCertUploadResponse&& from) noexcept
    : DeviceCertUploadResponse() {
    *this = ::std::move(from);
  }

  inline DeviceCertUploadResponse& operator=(const DeviceCertUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceCertUploadResponse& operator=(DeviceCertUploadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceCertUploadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceCertUploadResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceCertUploadResponse*>(
               &_DeviceCertUploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeviceCertUploadResponse& a, DeviceCertUploadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceCertUploadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceCertUploadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceCertUploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceCertUploadResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceCertUploadResponse& from);
  void MergeFrom(const DeviceCertUploadResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceCertUploadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceCertUploadResponse";
  }
  protected:
  explicit DeviceCertUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceCertUploadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceServiceApiAccessRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceServiceApiAccessRequest) */ {
 public:
  inline DeviceServiceApiAccessRequest() : DeviceServiceApiAccessRequest(nullptr) {}
  ~DeviceServiceApiAccessRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceServiceApiAccessRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceServiceApiAccessRequest(const DeviceServiceApiAccessRequest& from);
  DeviceServiceApiAccessRequest(DeviceServiceApiAccessRequest&& from) noexcept
    : DeviceServiceApiAccessRequest() {
    *this = ::std::move(from);
  }

  inline DeviceServiceApiAccessRequest& operator=(const DeviceServiceApiAccessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceServiceApiAccessRequest& operator=(DeviceServiceApiAccessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceServiceApiAccessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceServiceApiAccessRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceServiceApiAccessRequest*>(
               &_DeviceServiceApiAccessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeviceServiceApiAccessRequest& a, DeviceServiceApiAccessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceServiceApiAccessRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceServiceApiAccessRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceServiceApiAccessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceServiceApiAccessRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceServiceApiAccessRequest& from);
  void MergeFrom(const DeviceServiceApiAccessRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceServiceApiAccessRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceServiceApiAccessRequest";
  }
  protected:
  explicit DeviceServiceApiAccessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceServiceApiAccessRequest_DeviceType DeviceType;
  static constexpr DeviceType CHROME_OS =
    DeviceServiceApiAccessRequest_DeviceType_CHROME_OS;
  static constexpr DeviceType ANDROID_OS =
    DeviceServiceApiAccessRequest_DeviceType_ANDROID_OS;
  static constexpr DeviceType CHROME_OS_DEMO_MODE =
    DeviceServiceApiAccessRequest_DeviceType_CHROME_OS_DEMO_MODE;
  static constexpr DeviceType CHROME_BROWSER =
    DeviceServiceApiAccessRequest_DeviceType_CHROME_BROWSER;
  static inline bool DeviceType_IsValid(int value) {
    return DeviceServiceApiAccessRequest_DeviceType_IsValid(value);
  }
  static constexpr DeviceType DeviceType_MIN =
    DeviceServiceApiAccessRequest_DeviceType_DeviceType_MIN;
  static constexpr DeviceType DeviceType_MAX =
    DeviceServiceApiAccessRequest_DeviceType_DeviceType_MAX;
  static constexpr int DeviceType_ARRAYSIZE =
    DeviceServiceApiAccessRequest_DeviceType_DeviceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DeviceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeviceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeviceType_Name.");
    return DeviceServiceApiAccessRequest_DeviceType_Name(enum_t_value);
  }
  static inline bool DeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeviceType* value) {
    return DeviceServiceApiAccessRequest_DeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAuthScopesFieldNumber = 1,
    kOauth2ClientIdFieldNumber = 2,
    kDeviceTypeFieldNumber = 3,
  };
  // repeated string auth_scopes = 1;
  int auth_scopes_size() const;
  private:
  int _internal_auth_scopes_size() const;
  public:
  void clear_auth_scopes();
  const std::string& auth_scopes(int index) const;
  std::string* mutable_auth_scopes(int index);
  void set_auth_scopes(int index, const std::string& value);
  void set_auth_scopes(int index, std::string&& value);
  void set_auth_scopes(int index, const char* value);
  void set_auth_scopes(int index, const char* value, size_t size);
  std::string* add_auth_scopes();
  void add_auth_scopes(const std::string& value);
  void add_auth_scopes(std::string&& value);
  void add_auth_scopes(const char* value);
  void add_auth_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& auth_scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_auth_scopes();
  private:
  const std::string& _internal_auth_scopes(int index) const;
  std::string* _internal_add_auth_scopes();
  public:

  // optional string oauth2_client_id = 2;
  bool has_oauth2_client_id() const;
  private:
  bool _internal_has_oauth2_client_id() const;
  public:
  void clear_oauth2_client_id();
  const std::string& oauth2_client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oauth2_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oauth2_client_id();
  PROTOBUF_NODISCARD std::string* release_oauth2_client_id();
  void set_allocated_oauth2_client_id(std::string* oauth2_client_id);
  private:
  const std::string& _internal_oauth2_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oauth2_client_id(const std::string& value);
  std::string* _internal_mutable_oauth2_client_id();
  public:

  // optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
  bool has_device_type() const;
  private:
  bool _internal_has_device_type() const;
  public:
  void clear_device_type();
  ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType device_type() const;
  void set_device_type(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType value);
  private:
  ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType _internal_device_type() const;
  void _internal_set_device_type(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceServiceApiAccessRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> auth_scopes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oauth2_client_id_;
    int device_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceServiceApiAccessResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceServiceApiAccessResponse) */ {
 public:
  inline DeviceServiceApiAccessResponse() : DeviceServiceApiAccessResponse(nullptr) {}
  ~DeviceServiceApiAccessResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceServiceApiAccessResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceServiceApiAccessResponse(const DeviceServiceApiAccessResponse& from);
  DeviceServiceApiAccessResponse(DeviceServiceApiAccessResponse&& from) noexcept
    : DeviceServiceApiAccessResponse() {
    *this = ::std::move(from);
  }

  inline DeviceServiceApiAccessResponse& operator=(const DeviceServiceApiAccessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceServiceApiAccessResponse& operator=(DeviceServiceApiAccessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceServiceApiAccessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceServiceApiAccessResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceServiceApiAccessResponse*>(
               &_DeviceServiceApiAccessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeviceServiceApiAccessResponse& a, DeviceServiceApiAccessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceServiceApiAccessResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceServiceApiAccessResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceServiceApiAccessResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceServiceApiAccessResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceServiceApiAccessResponse& from);
  void MergeFrom(const DeviceServiceApiAccessResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceServiceApiAccessResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceServiceApiAccessResponse";
  }
  protected:
  explicit DeviceServiceApiAccessResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthCodeFieldNumber = 1,
  };
  // optional string auth_code = 1;
  bool has_auth_code() const;
  private:
  bool _internal_has_auth_code() const;
  public:
  void clear_auth_code();
  const std::string& auth_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_code();
  PROTOBUF_NODISCARD std::string* release_auth_code();
  void set_allocated_auth_code(std::string* auth_code);
  private:
  const std::string& _internal_auth_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_code(const std::string& value);
  std::string* _internal_mutable_auth_code();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceServiceApiAccessResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BrowserDeviceIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BrowserDeviceIdentifier) */ {
 public:
  inline BrowserDeviceIdentifier() : BrowserDeviceIdentifier(nullptr) {}
  ~BrowserDeviceIdentifier() override;
  explicit PROTOBUF_CONSTEXPR BrowserDeviceIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrowserDeviceIdentifier(const BrowserDeviceIdentifier& from);
  BrowserDeviceIdentifier(BrowserDeviceIdentifier&& from) noexcept
    : BrowserDeviceIdentifier() {
    *this = ::std::move(from);
  }

  inline BrowserDeviceIdentifier& operator=(const BrowserDeviceIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrowserDeviceIdentifier& operator=(BrowserDeviceIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BrowserDeviceIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrowserDeviceIdentifier* internal_default_instance() {
    return reinterpret_cast<const BrowserDeviceIdentifier*>(
               &_BrowserDeviceIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BrowserDeviceIdentifier& a, BrowserDeviceIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(BrowserDeviceIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrowserDeviceIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrowserDeviceIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrowserDeviceIdentifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BrowserDeviceIdentifier& from);
  void MergeFrom(const BrowserDeviceIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrowserDeviceIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BrowserDeviceIdentifier";
  }
  protected:
  explicit BrowserDeviceIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComputerNameFieldNumber = 1,
    kSerialNumberFieldNumber = 2,
  };
  // optional string computer_name = 1;
  bool has_computer_name() const;
  private:
  bool _internal_has_computer_name() const;
  public:
  void clear_computer_name();
  const std::string& computer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_computer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_computer_name();
  PROTOBUF_NODISCARD std::string* release_computer_name();
  void set_allocated_computer_name(std::string* computer_name);
  private:
  const std::string& _internal_computer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_computer_name(const std::string& value);
  std::string* _internal_mutable_computer_name();
  public:

  // optional string serial_number = 2;
  bool has_serial_number() const;
  private:
  bool _internal_has_serial_number() const;
  public:
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BrowserDeviceIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr computer_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PolicyFetchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyFetchRequest) */ {
 public:
  inline PolicyFetchRequest() : PolicyFetchRequest(nullptr) {}
  ~PolicyFetchRequest() override;
  explicit PROTOBUF_CONSTEXPR PolicyFetchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyFetchRequest(const PolicyFetchRequest& from);
  PolicyFetchRequest(PolicyFetchRequest&& from) noexcept
    : PolicyFetchRequest() {
    *this = ::std::move(from);
  }

  inline PolicyFetchRequest& operator=(const PolicyFetchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyFetchRequest& operator=(PolicyFetchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PolicyFetchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyFetchRequest* internal_default_instance() {
    return reinterpret_cast<const PolicyFetchRequest*>(
               &_PolicyFetchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PolicyFetchRequest& a, PolicyFetchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyFetchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyFetchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyFetchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyFetchRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PolicyFetchRequest& from);
  void MergeFrom(const PolicyFetchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PolicyFetchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PolicyFetchRequest";
  }
  protected:
  explicit PolicyFetchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PolicyFetchRequest_SignatureType SignatureType;
  static constexpr SignatureType NONE =
    PolicyFetchRequest_SignatureType_NONE;
  static constexpr SignatureType SHA1_RSA =
    PolicyFetchRequest_SignatureType_SHA1_RSA;
  static constexpr SignatureType SHA256_RSA =
    PolicyFetchRequest_SignatureType_SHA256_RSA;
  static inline bool SignatureType_IsValid(int value) {
    return PolicyFetchRequest_SignatureType_IsValid(value);
  }
  static constexpr SignatureType SignatureType_MIN =
    PolicyFetchRequest_SignatureType_SignatureType_MIN;
  static constexpr SignatureType SignatureType_MAX =
    PolicyFetchRequest_SignatureType_SignatureType_MAX;
  static constexpr int SignatureType_ARRAYSIZE =
    PolicyFetchRequest_SignatureType_SignatureType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SignatureType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SignatureType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SignatureType_Name.");
    return PolicyFetchRequest_SignatureType_Name(enum_t_value);
  }
  static inline bool SignatureType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SignatureType* value) {
    return PolicyFetchRequest_SignatureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyTypeFieldNumber = 1,
    kSettingsEntityIdFieldNumber = 6,
    kInvalidationPayloadFieldNumber = 8,
    kVerificationKeyHashFieldNumber = 9,
    kPolicyInvalidationInfoFieldNumber = 10,
    kDeviceDmTokenFieldNumber = 12,
    kBrowserDeviceIdentifierFieldNumber = 13,
    kTimestampFieldNumber = 2,
    kSignatureTypeFieldNumber = 3,
    kPublicKeyVersionFieldNumber = 4,
    kInvalidationVersionFieldNumber = 7,
    kInvalidationTopicsOnlyFieldNumber = 11,
  };
  // optional string policy_type = 1;
  bool has_policy_type() const;
  private:
  bool _internal_has_policy_type() const;
  public:
  void clear_policy_type();
  const std::string& policy_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_type();
  PROTOBUF_NODISCARD std::string* release_policy_type();
  void set_allocated_policy_type(std::string* policy_type);
  private:
  const std::string& _internal_policy_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_type(const std::string& value);
  std::string* _internal_mutable_policy_type();
  public:

  // optional string settings_entity_id = 6;
  bool has_settings_entity_id() const;
  private:
  bool _internal_has_settings_entity_id() const;
  public:
  void clear_settings_entity_id();
  const std::string& settings_entity_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_settings_entity_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_settings_entity_id();
  PROTOBUF_NODISCARD std::string* release_settings_entity_id();
  void set_allocated_settings_entity_id(std::string* settings_entity_id);
  private:
  const std::string& _internal_settings_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settings_entity_id(const std::string& value);
  std::string* _internal_mutable_settings_entity_id();
  public:

  // optional bytes invalidation_payload = 8;
  bool has_invalidation_payload() const;
  private:
  bool _internal_has_invalidation_payload() const;
  public:
  void clear_invalidation_payload();
  const std::string& invalidation_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invalidation_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invalidation_payload();
  PROTOBUF_NODISCARD std::string* release_invalidation_payload();
  void set_allocated_invalidation_payload(std::string* invalidation_payload);
  private:
  const std::string& _internal_invalidation_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invalidation_payload(const std::string& value);
  std::string* _internal_mutable_invalidation_payload();
  public:

  // optional string verification_key_hash = 9;
  bool has_verification_key_hash() const;
  private:
  bool _internal_has_verification_key_hash() const;
  public:
  void clear_verification_key_hash();
  const std::string& verification_key_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verification_key_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verification_key_hash();
  PROTOBUF_NODISCARD std::string* release_verification_key_hash();
  void set_allocated_verification_key_hash(std::string* verification_key_hash);
  private:
  const std::string& _internal_verification_key_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_key_hash(const std::string& value);
  std::string* _internal_mutable_verification_key_hash();
  public:

  // optional string policy_invalidation_info = 10;
  bool has_policy_invalidation_info() const;
  private:
  bool _internal_has_policy_invalidation_info() const;
  public:
  void clear_policy_invalidation_info();
  const std::string& policy_invalidation_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_invalidation_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_invalidation_info();
  PROTOBUF_NODISCARD std::string* release_policy_invalidation_info();
  void set_allocated_policy_invalidation_info(std::string* policy_invalidation_info);
  private:
  const std::string& _internal_policy_invalidation_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_invalidation_info(const std::string& value);
  std::string* _internal_mutable_policy_invalidation_info();
  public:

  // optional string device_dm_token = 12;
  bool has_device_dm_token() const;
  private:
  bool _internal_has_device_dm_token() const;
  public:
  void clear_device_dm_token();
  const std::string& device_dm_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_dm_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_dm_token();
  PROTOBUF_NODISCARD std::string* release_device_dm_token();
  void set_allocated_device_dm_token(std::string* device_dm_token);
  private:
  const std::string& _internal_device_dm_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_dm_token(const std::string& value);
  std::string* _internal_mutable_device_dm_token();
  public:

  // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 13;
  bool has_browser_device_identifier() const;
  private:
  bool _internal_has_browser_device_identifier() const;
  public:
  void clear_browser_device_identifier();
  const ::enterprise_management::BrowserDeviceIdentifier& browser_device_identifier() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserDeviceIdentifier* release_browser_device_identifier();
  ::enterprise_management::BrowserDeviceIdentifier* mutable_browser_device_identifier();
  void set_allocated_browser_device_identifier(::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier);
  private:
  const ::enterprise_management::BrowserDeviceIdentifier& _internal_browser_device_identifier() const;
  ::enterprise_management::BrowserDeviceIdentifier* _internal_mutable_browser_device_identifier();
  public:
  void unsafe_arena_set_allocated_browser_device_identifier(
      ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier);
  ::enterprise_management::BrowserDeviceIdentifier* unsafe_arena_release_browser_device_identifier();

  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
  bool has_signature_type() const;
  private:
  bool _internal_has_signature_type() const;
  public:
  void clear_signature_type();
  ::enterprise_management::PolicyFetchRequest_SignatureType signature_type() const;
  void set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);
  private:
  ::enterprise_management::PolicyFetchRequest_SignatureType _internal_signature_type() const;
  void _internal_set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);
  public:

  // optional int32 public_key_version = 4;
  bool has_public_key_version() const;
  private:
  bool _internal_has_public_key_version() const;
  public:
  void clear_public_key_version();
  int32_t public_key_version() const;
  void set_public_key_version(int32_t value);
  private:
  int32_t _internal_public_key_version() const;
  void _internal_set_public_key_version(int32_t value);
  public:

  // optional int64 invalidation_version = 7;
  bool has_invalidation_version() const;
  private:
  bool _internal_has_invalidation_version() const;
  public:
  void clear_invalidation_version();
  int64_t invalidation_version() const;
  void set_invalidation_version(int64_t value);
  private:
  int64_t _internal_invalidation_version() const;
  void _internal_set_invalidation_version(int64_t value);
  public:

  // optional bool invalidation_topics_only = 11;
  bool has_invalidation_topics_only() const;
  private:
  bool _internal_has_invalidation_topics_only() const;
  public:
  void clear_invalidation_topics_only();
  bool invalidation_topics_only() const;
  void set_invalidation_topics_only(bool value);
  private:
  bool _internal_invalidation_topics_only() const;
  void _internal_set_invalidation_topics_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PolicyFetchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settings_entity_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidation_payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_key_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_invalidation_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_dm_token_;
    ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier_;
    int64_t timestamp_;
    int signature_type_;
    int32_t public_key_version_;
    int64_t invalidation_version_;
    bool invalidation_topics_only_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DisabledState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DisabledState) */ {
 public:
  inline DisabledState() : DisabledState(nullptr) {}
  ~DisabledState() override;
  explicit PROTOBUF_CONSTEXPR DisabledState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisabledState(const DisabledState& from);
  DisabledState(DisabledState&& from) noexcept
    : DisabledState() {
    *this = ::std::move(from);
  }

  inline DisabledState& operator=(const DisabledState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisabledState& operator=(DisabledState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisabledState& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisabledState* internal_default_instance() {
    return reinterpret_cast<const DisabledState*>(
               &_DisabledState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DisabledState& a, DisabledState& b) {
    a.Swap(&b);
  }
  inline void Swap(DisabledState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisabledState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisabledState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisabledState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DisabledState& from);
  void MergeFrom(const DisabledState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisabledState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DisabledState";
  }
  protected:
  explicit DisabledState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // optional string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DisabledState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceState) */ {
 public:
  inline DeviceState() : DeviceState(nullptr) {}
  ~DeviceState() override;
  explicit PROTOBUF_CONSTEXPR DeviceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceState(const DeviceState& from);
  DeviceState(DeviceState&& from) noexcept
    : DeviceState() {
    *this = ::std::move(from);
  }

  inline DeviceState& operator=(const DeviceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceState& operator=(DeviceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceState* internal_default_instance() {
    return reinterpret_cast<const DeviceState*>(
               &_DeviceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeviceState& a, DeviceState& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceState& from);
  void MergeFrom(const DeviceState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceState";
  }
  protected:
  explicit DeviceState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceState_DeviceMode DeviceMode;
  static constexpr DeviceMode DEVICE_MODE_NORMAL =
    DeviceState_DeviceMode_DEVICE_MODE_NORMAL;
  static constexpr DeviceMode DEVICE_MODE_DISABLED =
    DeviceState_DeviceMode_DEVICE_MODE_DISABLED;
  static inline bool DeviceMode_IsValid(int value) {
    return DeviceState_DeviceMode_IsValid(value);
  }
  static constexpr DeviceMode DeviceMode_MIN =
    DeviceState_DeviceMode_DeviceMode_MIN;
  static constexpr DeviceMode DeviceMode_MAX =
    DeviceState_DeviceMode_DeviceMode_MAX;
  static constexpr int DeviceMode_ARRAYSIZE =
    DeviceState_DeviceMode_DeviceMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DeviceMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeviceMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeviceMode_Name.");
    return DeviceState_DeviceMode_Name(enum_t_value);
  }
  static inline bool DeviceMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeviceMode* value) {
    return DeviceState_DeviceMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDisabledStateFieldNumber = 2,
    kDeviceModeFieldNumber = 1,
  };
  // optional .enterprise_management.DisabledState disabled_state = 2;
  bool has_disabled_state() const;
  private:
  bool _internal_has_disabled_state() const;
  public:
  void clear_disabled_state();
  const ::enterprise_management::DisabledState& disabled_state() const;
  PROTOBUF_NODISCARD ::enterprise_management::DisabledState* release_disabled_state();
  ::enterprise_management::DisabledState* mutable_disabled_state();
  void set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state);
  private:
  const ::enterprise_management::DisabledState& _internal_disabled_state() const;
  ::enterprise_management::DisabledState* _internal_mutable_disabled_state();
  public:
  void unsafe_arena_set_allocated_disabled_state(
      ::enterprise_management::DisabledState* disabled_state);
  ::enterprise_management::DisabledState* unsafe_arena_release_disabled_state();

  // optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
  bool has_device_mode() const;
  private:
  bool _internal_has_device_mode() const;
  public:
  void clear_device_mode();
  ::enterprise_management::DeviceState_DeviceMode device_mode() const;
  void set_device_mode(::enterprise_management::DeviceState_DeviceMode value);
  private:
  ::enterprise_management::DeviceState_DeviceMode _internal_device_mode() const;
  void _internal_set_device_mode(::enterprise_management::DeviceState_DeviceMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::DisabledState* disabled_state_;
    int device_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CustomerLogo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CustomerLogo) */ {
 public:
  inline CustomerLogo() : CustomerLogo(nullptr) {}
  ~CustomerLogo() override;
  explicit PROTOBUF_CONSTEXPR CustomerLogo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomerLogo(const CustomerLogo& from);
  CustomerLogo(CustomerLogo&& from) noexcept
    : CustomerLogo() {
    *this = ::std::move(from);
  }

  inline CustomerLogo& operator=(const CustomerLogo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomerLogo& operator=(CustomerLogo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CustomerLogo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomerLogo* internal_default_instance() {
    return reinterpret_cast<const CustomerLogo*>(
               &_CustomerLogo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CustomerLogo& a, CustomerLogo& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomerLogo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomerLogo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomerLogo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomerLogo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CustomerLogo& from);
  void MergeFrom(const CustomerLogo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CustomerLogo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CustomerLogo";
  }
  protected:
  explicit CustomerLogo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogoUrlFieldNumber = 1,
  };
  // optional string logo_url = 1;
  bool has_logo_url() const;
  private:
  bool _internal_has_logo_url() const;
  public:
  void clear_logo_url();
  const std::string& logo_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo_url();
  PROTOBUF_NODISCARD std::string* release_logo_url();
  void set_allocated_logo_url(std::string* logo_url);
  private:
  const std::string& _internal_logo_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo_url(const std::string& value);
  std::string* _internal_mutable_logo_url();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CustomerLogo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_url_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PolicyData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyData) */ {
 public:
  inline PolicyData() : PolicyData(nullptr) {}
  ~PolicyData() override;
  explicit PROTOBUF_CONSTEXPR PolicyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyData(const PolicyData& from);
  PolicyData(PolicyData&& from) noexcept
    : PolicyData() {
    *this = ::std::move(from);
  }

  inline PolicyData& operator=(const PolicyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyData& operator=(PolicyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PolicyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyData* internal_default_instance() {
    return reinterpret_cast<const PolicyData*>(
               &_PolicyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PolicyData& a, PolicyData& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PolicyData& from);
  void MergeFrom(const PolicyData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PolicyData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PolicyData";
  }
  protected:
  explicit PolicyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PolicyData_AssociationState AssociationState;
  static constexpr AssociationState ACTIVE =
    PolicyData_AssociationState_ACTIVE;
  static constexpr AssociationState UNMANAGED =
    PolicyData_AssociationState_UNMANAGED;
  static constexpr AssociationState DEPROVISIONED =
    PolicyData_AssociationState_DEPROVISIONED;
  static inline bool AssociationState_IsValid(int value) {
    return PolicyData_AssociationState_IsValid(value);
  }
  static constexpr AssociationState AssociationState_MIN =
    PolicyData_AssociationState_AssociationState_MIN;
  static constexpr AssociationState AssociationState_MAX =
    PolicyData_AssociationState_AssociationState_MAX;
  static constexpr int AssociationState_ARRAYSIZE =
    PolicyData_AssociationState_AssociationState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AssociationState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AssociationState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AssociationState_Name.");
    return PolicyData_AssociationState_Name(enum_t_value);
  }
  static inline bool AssociationState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AssociationState* value) {
    return PolicyData_AssociationState_Parse(name, value);
  }

  typedef PolicyData_ManagementMode ManagementMode;
  static constexpr ManagementMode LOCAL_OWNER =
    PolicyData_ManagementMode_LOCAL_OWNER;
  static constexpr ManagementMode ENTERPRISE_MANAGED =
    PolicyData_ManagementMode_ENTERPRISE_MANAGED;
  static constexpr ManagementMode OBSOLETE_CONSUMER_MANAGED =
    PolicyData_ManagementMode_OBSOLETE_CONSUMER_MANAGED;
  static inline bool ManagementMode_IsValid(int value) {
    return PolicyData_ManagementMode_IsValid(value);
  }
  static constexpr ManagementMode ManagementMode_MIN =
    PolicyData_ManagementMode_ManagementMode_MIN;
  static constexpr ManagementMode ManagementMode_MAX =
    PolicyData_ManagementMode_ManagementMode_MAX;
  static constexpr int ManagementMode_ARRAYSIZE =
    PolicyData_ManagementMode_ManagementMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ManagementMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ManagementMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ManagementMode_Name.");
    return PolicyData_ManagementMode_Name(enum_t_value);
  }
  static inline bool ManagementMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ManagementMode* value) {
    return PolicyData_ManagementMode_Parse(name, value);
  }

  typedef PolicyData_MarketSegment MarketSegment;
  static constexpr MarketSegment MARKET_SEGMENT_UNSPECIFIED =
    PolicyData_MarketSegment_MARKET_SEGMENT_UNSPECIFIED;
  static constexpr MarketSegment ENROLLED_EDUCATION =
    PolicyData_MarketSegment_ENROLLED_EDUCATION;
  static constexpr MarketSegment ENROLLED_ENTERPRISE =
    PolicyData_MarketSegment_ENROLLED_ENTERPRISE;
  static inline bool MarketSegment_IsValid(int value) {
    return PolicyData_MarketSegment_IsValid(value);
  }
  static constexpr MarketSegment MarketSegment_MIN =
    PolicyData_MarketSegment_MarketSegment_MIN;
  static constexpr MarketSegment MarketSegment_MAX =
    PolicyData_MarketSegment_MarketSegment_MAX;
  static constexpr int MarketSegment_ARRAYSIZE =
    PolicyData_MarketSegment_MarketSegment_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MarketSegment_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MarketSegment>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MarketSegment_Name.");
    return PolicyData_MarketSegment_Name(enum_t_value);
  }
  static inline bool MarketSegment_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MarketSegment* value) {
    return PolicyData_MarketSegment_Parse(name, value);
  }

  typedef PolicyData_MetricsLogSegment MetricsLogSegment;
  static constexpr MetricsLogSegment UNSPECIFIED =
    PolicyData_MetricsLogSegment_UNSPECIFIED;
  static constexpr MetricsLogSegment K12 =
    PolicyData_MetricsLogSegment_K12;
  static constexpr MetricsLogSegment UNIVERSITY =
    PolicyData_MetricsLogSegment_UNIVERSITY;
  static constexpr MetricsLogSegment NONPROFIT =
    PolicyData_MetricsLogSegment_NONPROFIT;
  static constexpr MetricsLogSegment ENTERPRISE =
    PolicyData_MetricsLogSegment_ENTERPRISE;
  static inline bool MetricsLogSegment_IsValid(int value) {
    return PolicyData_MetricsLogSegment_IsValid(value);
  }
  static constexpr MetricsLogSegment MetricsLogSegment_MIN =
    PolicyData_MetricsLogSegment_MetricsLogSegment_MIN;
  static constexpr MetricsLogSegment MetricsLogSegment_MAX =
    PolicyData_MetricsLogSegment_MetricsLogSegment_MAX;
  static constexpr int MetricsLogSegment_ARRAYSIZE =
    PolicyData_MetricsLogSegment_MetricsLogSegment_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MetricsLogSegment_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MetricsLogSegment>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MetricsLogSegment_Name.");
    return PolicyData_MetricsLogSegment_Name(enum_t_value);
  }
  static inline bool MetricsLogSegment_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MetricsLogSegment* value) {
    return PolicyData_MetricsLogSegment_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceAffiliationIdsFieldNumber = 23,
    kUserAffiliationIdsFieldNumber = 24,
    kPolicyTypeFieldNumber = 1,
    kRequestTokenFieldNumber = 3,
    kPolicyValueFieldNumber = 4,
    kMachineNameFieldNumber = 5,
    kUsernameFieldNumber = 7,
    kDeviceIdFieldNumber = 8,
    kSettingsEntityIdFieldNumber = 11,
    kServiceAccountIdentityFieldNumber = 12,
    kPolicyTokenFieldNumber = 15,
    kAnnotatedLocationFieldNumber = 20,
    kAnnotatedAssetIdFieldNumber = 21,
    kDirectoryApiIdFieldNumber = 22,
    kDisplayDomainFieldNumber = 25,
    kPolicyInvalidationTopicFieldNumber = 26,
    kCommandInvalidationTopicFieldNumber = 27,
    kGaiaIdFieldNumber = 29,
    kChangePasswordUriFieldNumber = 32,
    kObfuscatedCustomerIdFieldNumber = 34,
    kManagedByFieldNumber = 36,
    kSsoProfileFieldNumber = 37,
    kLicenseSkuFieldNumber = 38,
    kDeviceStateFieldNumber = 17,
    kCustomerLogoFieldNumber = 31,
    kClientActionRequiredFieldNumber = 33,
    kTimestampFieldNumber = 2,
    kPublicKeyVersionFieldNumber = 6,
    kStateFieldNumber = 9,
    kManagementModeFieldNumber = 16,
    kEnrollmentIdNeededFieldNumber = 28,
    kMarketSegmentFieldNumber = 30,
    kMetricsLogSegmentFieldNumber = 35,
  };
  // repeated string device_affiliation_ids = 23;
  int device_affiliation_ids_size() const;
  private:
  int _internal_device_affiliation_ids_size() const;
  public:
  void clear_device_affiliation_ids();
  const std::string& device_affiliation_ids(int index) const;
  std::string* mutable_device_affiliation_ids(int index);
  void set_device_affiliation_ids(int index, const std::string& value);
  void set_device_affiliation_ids(int index, std::string&& value);
  void set_device_affiliation_ids(int index, const char* value);
  void set_device_affiliation_ids(int index, const char* value, size_t size);
  std::string* add_device_affiliation_ids();
  void add_device_affiliation_ids(const std::string& value);
  void add_device_affiliation_ids(std::string&& value);
  void add_device_affiliation_ids(const char* value);
  void add_device_affiliation_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& device_affiliation_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_device_affiliation_ids();
  private:
  const std::string& _internal_device_affiliation_ids(int index) const;
  std::string* _internal_add_device_affiliation_ids();
  public:

  // repeated string user_affiliation_ids = 24;
  int user_affiliation_ids_size() const;
  private:
  int _internal_user_affiliation_ids_size() const;
  public:
  void clear_user_affiliation_ids();
  const std::string& user_affiliation_ids(int index) const;
  std::string* mutable_user_affiliation_ids(int index);
  void set_user_affiliation_ids(int index, const std::string& value);
  void set_user_affiliation_ids(int index, std::string&& value);
  void set_user_affiliation_ids(int index, const char* value);
  void set_user_affiliation_ids(int index, const char* value, size_t size);
  std::string* add_user_affiliation_ids();
  void add_user_affiliation_ids(const std::string& value);
  void add_user_affiliation_ids(std::string&& value);
  void add_user_affiliation_ids(const char* value);
  void add_user_affiliation_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_affiliation_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_affiliation_ids();
  private:
  const std::string& _internal_user_affiliation_ids(int index) const;
  std::string* _internal_add_user_affiliation_ids();
  public:

  // optional string policy_type = 1;
  bool has_policy_type() const;
  private:
  bool _internal_has_policy_type() const;
  public:
  void clear_policy_type();
  const std::string& policy_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_type();
  PROTOBUF_NODISCARD std::string* release_policy_type();
  void set_allocated_policy_type(std::string* policy_type);
  private:
  const std::string& _internal_policy_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_type(const std::string& value);
  std::string* _internal_mutable_policy_type();
  public:

  // optional string request_token = 3;
  bool has_request_token() const;
  private:
  bool _internal_has_request_token() const;
  public:
  void clear_request_token();
  const std::string& request_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_token();
  PROTOBUF_NODISCARD std::string* release_request_token();
  void set_allocated_request_token(std::string* request_token);
  private:
  const std::string& _internal_request_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_token(const std::string& value);
  std::string* _internal_mutable_request_token();
  public:

  // optional bytes policy_value = 4;
  bool has_policy_value() const;
  private:
  bool _internal_has_policy_value() const;
  public:
  void clear_policy_value();
  const std::string& policy_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_value();
  PROTOBUF_NODISCARD std::string* release_policy_value();
  void set_allocated_policy_value(std::string* policy_value);
  private:
  const std::string& _internal_policy_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_value(const std::string& value);
  std::string* _internal_mutable_policy_value();
  public:

  // optional string machine_name = 5;
  bool has_machine_name() const;
  private:
  bool _internal_has_machine_name() const;
  public:
  void clear_machine_name();
  const std::string& machine_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_name();
  PROTOBUF_NODISCARD std::string* release_machine_name();
  void set_allocated_machine_name(std::string* machine_name);
  private:
  const std::string& _internal_machine_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_name(const std::string& value);
  std::string* _internal_mutable_machine_name();
  public:

  // optional string username = 7;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string device_id = 8;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // optional string settings_entity_id = 11;
  bool has_settings_entity_id() const;
  private:
  bool _internal_has_settings_entity_id() const;
  public:
  void clear_settings_entity_id();
  const std::string& settings_entity_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_settings_entity_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_settings_entity_id();
  PROTOBUF_NODISCARD std::string* release_settings_entity_id();
  void set_allocated_settings_entity_id(std::string* settings_entity_id);
  private:
  const std::string& _internal_settings_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settings_entity_id(const std::string& value);
  std::string* _internal_mutable_settings_entity_id();
  public:

  // optional string service_account_identity = 12;
  bool has_service_account_identity() const;
  private:
  bool _internal_has_service_account_identity() const;
  public:
  void clear_service_account_identity();
  const std::string& service_account_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_account_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_account_identity();
  PROTOBUF_NODISCARD std::string* release_service_account_identity();
  void set_allocated_service_account_identity(std::string* service_account_identity);
  private:
  const std::string& _internal_service_account_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_account_identity(const std::string& value);
  std::string* _internal_mutable_service_account_identity();
  public:

  // optional string policy_token = 15;
  bool has_policy_token() const;
  private:
  bool _internal_has_policy_token() const;
  public:
  void clear_policy_token();
  const std::string& policy_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_token();
  PROTOBUF_NODISCARD std::string* release_policy_token();
  void set_allocated_policy_token(std::string* policy_token);
  private:
  const std::string& _internal_policy_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_token(const std::string& value);
  std::string* _internal_mutable_policy_token();
  public:

  // optional string annotated_location = 20;
  bool has_annotated_location() const;
  private:
  bool _internal_has_annotated_location() const;
  public:
  void clear_annotated_location();
  const std::string& annotated_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_annotated_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_annotated_location();
  PROTOBUF_NODISCARD std::string* release_annotated_location();
  void set_allocated_annotated_location(std::string* annotated_location);
  private:
  const std::string& _internal_annotated_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_annotated_location(const std::string& value);
  std::string* _internal_mutable_annotated_location();
  public:

  // optional string annotated_asset_id = 21;
  bool has_annotated_asset_id() const;
  private:
  bool _internal_has_annotated_asset_id() const;
  public:
  void clear_annotated_asset_id();
  const std::string& annotated_asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_annotated_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_annotated_asset_id();
  PROTOBUF_NODISCARD std::string* release_annotated_asset_id();
  void set_allocated_annotated_asset_id(std::string* annotated_asset_id);
  private:
  const std::string& _internal_annotated_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_annotated_asset_id(const std::string& value);
  std::string* _internal_mutable_annotated_asset_id();
  public:

  // optional string directory_api_id = 22;
  bool has_directory_api_id() const;
  private:
  bool _internal_has_directory_api_id() const;
  public:
  void clear_directory_api_id();
  const std::string& directory_api_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directory_api_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directory_api_id();
  PROTOBUF_NODISCARD std::string* release_directory_api_id();
  void set_allocated_directory_api_id(std::string* directory_api_id);
  private:
  const std::string& _internal_directory_api_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory_api_id(const std::string& value);
  std::string* _internal_mutable_directory_api_id();
  public:

  // optional string display_domain = 25;
  bool has_display_domain() const;
  private:
  bool _internal_has_display_domain() const;
  public:
  void clear_display_domain();
  const std::string& display_domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_domain();
  PROTOBUF_NODISCARD std::string* release_display_domain();
  void set_allocated_display_domain(std::string* display_domain);
  private:
  const std::string& _internal_display_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_domain(const std::string& value);
  std::string* _internal_mutable_display_domain();
  public:

  // optional string policy_invalidation_topic = 26;
  bool has_policy_invalidation_topic() const;
  private:
  bool _internal_has_policy_invalidation_topic() const;
  public:
  void clear_policy_invalidation_topic();
  const std::string& policy_invalidation_topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_invalidation_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_invalidation_topic();
  PROTOBUF_NODISCARD std::string* release_policy_invalidation_topic();
  void set_allocated_policy_invalidation_topic(std::string* policy_invalidation_topic);
  private:
  const std::string& _internal_policy_invalidation_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_invalidation_topic(const std::string& value);
  std::string* _internal_mutable_policy_invalidation_topic();
  public:

  // optional string command_invalidation_topic = 27;
  bool has_command_invalidation_topic() const;
  private:
  bool _internal_has_command_invalidation_topic() const;
  public:
  void clear_command_invalidation_topic();
  const std::string& command_invalidation_topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command_invalidation_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command_invalidation_topic();
  PROTOBUF_NODISCARD std::string* release_command_invalidation_topic();
  void set_allocated_command_invalidation_topic(std::string* command_invalidation_topic);
  private:
  const std::string& _internal_command_invalidation_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command_invalidation_topic(const std::string& value);
  std::string* _internal_mutable_command_invalidation_topic();
  public:

  // optional string gaia_id = 29;
  bool has_gaia_id() const;
  private:
  bool _internal_has_gaia_id() const;
  public:
  void clear_gaia_id();
  const std::string& gaia_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gaia_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gaia_id();
  PROTOBUF_NODISCARD std::string* release_gaia_id();
  void set_allocated_gaia_id(std::string* gaia_id);
  private:
  const std::string& _internal_gaia_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gaia_id(const std::string& value);
  std::string* _internal_mutable_gaia_id();
  public:

  // optional string change_password_uri = 32;
  bool has_change_password_uri() const;
  private:
  bool _internal_has_change_password_uri() const;
  public:
  void clear_change_password_uri();
  const std::string& change_password_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_change_password_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_change_password_uri();
  PROTOBUF_NODISCARD std::string* release_change_password_uri();
  void set_allocated_change_password_uri(std::string* change_password_uri);
  private:
  const std::string& _internal_change_password_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_change_password_uri(const std::string& value);
  std::string* _internal_mutable_change_password_uri();
  public:

  // optional string obfuscated_customer_id = 34;
  bool has_obfuscated_customer_id() const;
  private:
  bool _internal_has_obfuscated_customer_id() const;
  public:
  void clear_obfuscated_customer_id();
  const std::string& obfuscated_customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obfuscated_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obfuscated_customer_id();
  PROTOBUF_NODISCARD std::string* release_obfuscated_customer_id();
  void set_allocated_obfuscated_customer_id(std::string* obfuscated_customer_id);
  private:
  const std::string& _internal_obfuscated_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obfuscated_customer_id(const std::string& value);
  std::string* _internal_mutable_obfuscated_customer_id();
  public:

  // optional string managed_by = 36;
  bool has_managed_by() const;
  private:
  bool _internal_has_managed_by() const;
  public:
  void clear_managed_by();
  const std::string& managed_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_managed_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_managed_by();
  PROTOBUF_NODISCARD std::string* release_managed_by();
  void set_allocated_managed_by(std::string* managed_by);
  private:
  const std::string& _internal_managed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_managed_by(const std::string& value);
  std::string* _internal_mutable_managed_by();
  public:

  // optional string sso_profile = 37;
  bool has_sso_profile() const;
  private:
  bool _internal_has_sso_profile() const;
  public:
  void clear_sso_profile();
  const std::string& sso_profile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sso_profile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sso_profile();
  PROTOBUF_NODISCARD std::string* release_sso_profile();
  void set_allocated_sso_profile(std::string* sso_profile);
  private:
  const std::string& _internal_sso_profile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sso_profile(const std::string& value);
  std::string* _internal_mutable_sso_profile();
  public:

  // optional string license_sku = 38;
  bool has_license_sku() const;
  private:
  bool _internal_has_license_sku() const;
  public:
  void clear_license_sku();
  const std::string& license_sku() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license_sku(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license_sku();
  PROTOBUF_NODISCARD std::string* release_license_sku();
  void set_allocated_license_sku(std::string* license_sku);
  private:
  const std::string& _internal_license_sku() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license_sku(const std::string& value);
  std::string* _internal_mutable_license_sku();
  public:

  // optional .enterprise_management.DeviceState device_state = 17;
  bool has_device_state() const;
  private:
  bool _internal_has_device_state() const;
  public:
  void clear_device_state();
  const ::enterprise_management::DeviceState& device_state() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceState* release_device_state();
  ::enterprise_management::DeviceState* mutable_device_state();
  void set_allocated_device_state(::enterprise_management::DeviceState* device_state);
  private:
  const ::enterprise_management::DeviceState& _internal_device_state() const;
  ::enterprise_management::DeviceState* _internal_mutable_device_state();
  public:
  void unsafe_arena_set_allocated_device_state(
      ::enterprise_management::DeviceState* device_state);
  ::enterprise_management::DeviceState* unsafe_arena_release_device_state();

  // optional .enterprise_management.CustomerLogo customer_logo = 31;
  bool has_customer_logo() const;
  private:
  bool _internal_has_customer_logo() const;
  public:
  void clear_customer_logo();
  const ::enterprise_management::CustomerLogo& customer_logo() const;
  PROTOBUF_NODISCARD ::enterprise_management::CustomerLogo* release_customer_logo();
  ::enterprise_management::CustomerLogo* mutable_customer_logo();
  void set_allocated_customer_logo(::enterprise_management::CustomerLogo* customer_logo);
  private:
  const ::enterprise_management::CustomerLogo& _internal_customer_logo() const;
  ::enterprise_management::CustomerLogo* _internal_mutable_customer_logo();
  public:
  void unsafe_arena_set_allocated_customer_logo(
      ::enterprise_management::CustomerLogo* customer_logo);
  ::enterprise_management::CustomerLogo* unsafe_arena_release_customer_logo();

  // optional .enterprise_management.ClientActionRequired client_action_required = 33;
  bool has_client_action_required() const;
  private:
  bool _internal_has_client_action_required() const;
  public:
  void clear_client_action_required();
  const ::enterprise_management::ClientActionRequired& client_action_required() const;
  PROTOBUF_NODISCARD ::enterprise_management::ClientActionRequired* release_client_action_required();
  ::enterprise_management::ClientActionRequired* mutable_client_action_required();
  void set_allocated_client_action_required(::enterprise_management::ClientActionRequired* client_action_required);
  private:
  const ::enterprise_management::ClientActionRequired& _internal_client_action_required() const;
  ::enterprise_management::ClientActionRequired* _internal_mutable_client_action_required();
  public:
  void unsafe_arena_set_allocated_client_action_required(
      ::enterprise_management::ClientActionRequired* client_action_required);
  ::enterprise_management::ClientActionRequired* unsafe_arena_release_client_action_required();

  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int32 public_key_version = 6;
  bool has_public_key_version() const;
  private:
  bool _internal_has_public_key_version() const;
  public:
  void clear_public_key_version();
  int32_t public_key_version() const;
  void set_public_key_version(int32_t value);
  private:
  int32_t _internal_public_key_version() const;
  void _internal_set_public_key_version(int32_t value);
  public:

  // optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::enterprise_management::PolicyData_AssociationState state() const;
  void set_state(::enterprise_management::PolicyData_AssociationState value);
  private:
  ::enterprise_management::PolicyData_AssociationState _internal_state() const;
  void _internal_set_state(::enterprise_management::PolicyData_AssociationState value);
  public:

  // optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
  bool has_management_mode() const;
  private:
  bool _internal_has_management_mode() const;
  public:
  void clear_management_mode();
  ::enterprise_management::PolicyData_ManagementMode management_mode() const;
  void set_management_mode(::enterprise_management::PolicyData_ManagementMode value);
  private:
  ::enterprise_management::PolicyData_ManagementMode _internal_management_mode() const;
  void _internal_set_management_mode(::enterprise_management::PolicyData_ManagementMode value);
  public:

  // optional bool enrollment_id_needed = 28;
  bool has_enrollment_id_needed() const;
  private:
  bool _internal_has_enrollment_id_needed() const;
  public:
  void clear_enrollment_id_needed();
  bool enrollment_id_needed() const;
  void set_enrollment_id_needed(bool value);
  private:
  bool _internal_enrollment_id_needed() const;
  void _internal_set_enrollment_id_needed(bool value);
  public:

  // optional .enterprise_management.PolicyData.MarketSegment market_segment = 30;
  bool has_market_segment() const;
  private:
  bool _internal_has_market_segment() const;
  public:
  void clear_market_segment();
  ::enterprise_management::PolicyData_MarketSegment market_segment() const;
  void set_market_segment(::enterprise_management::PolicyData_MarketSegment value);
  private:
  ::enterprise_management::PolicyData_MarketSegment _internal_market_segment() const;
  void _internal_set_market_segment(::enterprise_management::PolicyData_MarketSegment value);
  public:

  // optional .enterprise_management.PolicyData.MetricsLogSegment metrics_log_segment = 35;
  bool has_metrics_log_segment() const;
  private:
  bool _internal_has_metrics_log_segment() const;
  public:
  void clear_metrics_log_segment();
  ::enterprise_management::PolicyData_MetricsLogSegment metrics_log_segment() const;
  void set_metrics_log_segment(::enterprise_management::PolicyData_MetricsLogSegment value);
  private:
  ::enterprise_management::PolicyData_MetricsLogSegment _internal_metrics_log_segment() const;
  void _internal_set_metrics_log_segment(::enterprise_management::PolicyData_MetricsLogSegment value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PolicyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> device_affiliation_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_affiliation_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settings_entity_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_account_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr annotated_location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr annotated_asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_api_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_domain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_invalidation_topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_invalidation_topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gaia_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr change_password_uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obfuscated_customer_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr managed_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sso_profile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_sku_;
    ::enterprise_management::DeviceState* device_state_;
    ::enterprise_management::CustomerLogo* customer_logo_;
    ::enterprise_management::ClientActionRequired* client_action_required_;
    int64_t timestamp_;
    int32_t public_key_version_;
    int state_;
    int management_mode_;
    bool enrollment_id_needed_;
    int market_segment_;
    int metrics_log_segment_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientActionRequired final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ClientActionRequired) */ {
 public:
  inline ClientActionRequired() : ClientActionRequired(nullptr) {}
  ~ClientActionRequired() override;
  explicit PROTOBUF_CONSTEXPR ClientActionRequired(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientActionRequired(const ClientActionRequired& from);
  ClientActionRequired(ClientActionRequired&& from) noexcept
    : ClientActionRequired() {
    *this = ::std::move(from);
  }

  inline ClientActionRequired& operator=(const ClientActionRequired& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientActionRequired& operator=(ClientActionRequired&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientActionRequired& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientActionRequired* internal_default_instance() {
    return reinterpret_cast<const ClientActionRequired*>(
               &_ClientActionRequired_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ClientActionRequired& a, ClientActionRequired& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientActionRequired* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientActionRequired* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientActionRequired* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientActionRequired>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientActionRequired& from);
  void MergeFrom(const ClientActionRequired& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientActionRequired* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ClientActionRequired";
  }
  protected:
  explicit ClientActionRequired(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentCertificateNeededFieldNumber = 1,
  };
  // optional bool enrollment_certificate_needed = 1;
  bool has_enrollment_certificate_needed() const;
  private:
  bool _internal_has_enrollment_certificate_needed() const;
  public:
  void clear_enrollment_certificate_needed();
  bool enrollment_certificate_needed() const;
  void set_enrollment_certificate_needed(bool value);
  private:
  bool _internal_enrollment_certificate_needed() const;
  void _internal_set_enrollment_certificate_needed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ClientActionRequired)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enrollment_certificate_needed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PolicyFetchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyFetchResponse) */ {
 public:
  inline PolicyFetchResponse() : PolicyFetchResponse(nullptr) {}
  ~PolicyFetchResponse() override;
  explicit PROTOBUF_CONSTEXPR PolicyFetchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyFetchResponse(const PolicyFetchResponse& from);
  PolicyFetchResponse(PolicyFetchResponse&& from) noexcept
    : PolicyFetchResponse() {
    *this = ::std::move(from);
  }

  inline PolicyFetchResponse& operator=(const PolicyFetchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyFetchResponse& operator=(PolicyFetchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PolicyFetchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyFetchResponse* internal_default_instance() {
    return reinterpret_cast<const PolicyFetchResponse*>(
               &_PolicyFetchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PolicyFetchResponse& a, PolicyFetchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyFetchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyFetchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyFetchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyFetchResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PolicyFetchResponse& from);
  void MergeFrom(const PolicyFetchResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PolicyFetchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PolicyFetchResponse";
  }
  protected:
  explicit PolicyFetchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kPolicyDataFieldNumber = 3,
    kPolicyDataSignatureFieldNumber = 4,
    kNewPublicKeyFieldNumber = 5,
    kNewPublicKeySignatureFieldNumber = 6,
    kNewPublicKeyVerificationSignatureDeprecatedFieldNumber = 7,
    kNewPublicKeyVerificationDataFieldNumber = 8,
    kNewPublicKeyVerificationDataSignatureFieldNumber = 9,
    kPolicyTypeFieldNumber = 10,
    kErrorCodeFieldNumber = 1,
    kPolicyDataSignatureTypeFieldNumber = 11,
  };
  // optional string error_message = 2;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional bytes policy_data = 3;
  bool has_policy_data() const;
  private:
  bool _internal_has_policy_data() const;
  public:
  void clear_policy_data();
  const std::string& policy_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_data();
  PROTOBUF_NODISCARD std::string* release_policy_data();
  void set_allocated_policy_data(std::string* policy_data);
  private:
  const std::string& _internal_policy_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_data(const std::string& value);
  std::string* _internal_mutable_policy_data();
  public:

  // optional bytes policy_data_signature = 4;
  bool has_policy_data_signature() const;
  private:
  bool _internal_has_policy_data_signature() const;
  public:
  void clear_policy_data_signature();
  const std::string& policy_data_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_data_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_data_signature();
  PROTOBUF_NODISCARD std::string* release_policy_data_signature();
  void set_allocated_policy_data_signature(std::string* policy_data_signature);
  private:
  const std::string& _internal_policy_data_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_data_signature(const std::string& value);
  std::string* _internal_mutable_policy_data_signature();
  public:

  // optional bytes new_public_key = 5;
  bool has_new_public_key() const;
  private:
  bool _internal_has_new_public_key() const;
  public:
  void clear_new_public_key();
  const std::string& new_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_public_key();
  PROTOBUF_NODISCARD std::string* release_new_public_key();
  void set_allocated_new_public_key(std::string* new_public_key);
  private:
  const std::string& _internal_new_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_key(const std::string& value);
  std::string* _internal_mutable_new_public_key();
  public:

  // optional bytes new_public_key_signature = 6;
  bool has_new_public_key_signature() const;
  private:
  bool _internal_has_new_public_key_signature() const;
  public:
  void clear_new_public_key_signature();
  const std::string& new_public_key_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_public_key_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_public_key_signature();
  PROTOBUF_NODISCARD std::string* release_new_public_key_signature();
  void set_allocated_new_public_key_signature(std::string* new_public_key_signature);
  private:
  const std::string& _internal_new_public_key_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_key_signature(const std::string& value);
  std::string* _internal_mutable_new_public_key_signature();
  public:

  // optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_new_public_key_verification_signature_deprecated() const;
  private:
  bool _internal_has_new_public_key_verification_signature_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_new_public_key_verification_signature_deprecated();
  PROTOBUF_DEPRECATED const std::string& new_public_key_verification_signature_deprecated() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_new_public_key_verification_signature_deprecated(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_new_public_key_verification_signature_deprecated();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_new_public_key_verification_signature_deprecated();
  PROTOBUF_DEPRECATED void set_allocated_new_public_key_verification_signature_deprecated(std::string* new_public_key_verification_signature_deprecated);
  private:
  const std::string& _internal_new_public_key_verification_signature_deprecated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_key_verification_signature_deprecated(const std::string& value);
  std::string* _internal_mutable_new_public_key_verification_signature_deprecated();
  public:

  // optional bytes new_public_key_verification_data = 8;
  bool has_new_public_key_verification_data() const;
  private:
  bool _internal_has_new_public_key_verification_data() const;
  public:
  void clear_new_public_key_verification_data();
  const std::string& new_public_key_verification_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_public_key_verification_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_public_key_verification_data();
  PROTOBUF_NODISCARD std::string* release_new_public_key_verification_data();
  void set_allocated_new_public_key_verification_data(std::string* new_public_key_verification_data);
  private:
  const std::string& _internal_new_public_key_verification_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_key_verification_data(const std::string& value);
  std::string* _internal_mutable_new_public_key_verification_data();
  public:

  // optional bytes new_public_key_verification_data_signature = 9;
  bool has_new_public_key_verification_data_signature() const;
  private:
  bool _internal_has_new_public_key_verification_data_signature() const;
  public:
  void clear_new_public_key_verification_data_signature();
  const std::string& new_public_key_verification_data_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_public_key_verification_data_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_public_key_verification_data_signature();
  PROTOBUF_NODISCARD std::string* release_new_public_key_verification_data_signature();
  void set_allocated_new_public_key_verification_data_signature(std::string* new_public_key_verification_data_signature);
  private:
  const std::string& _internal_new_public_key_verification_data_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_key_verification_data_signature(const std::string& value);
  std::string* _internal_mutable_new_public_key_verification_data_signature();
  public:

  // optional string policy_type = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_policy_type() const;
  private:
  bool _internal_has_policy_type() const;
  public:
  PROTOBUF_DEPRECATED void clear_policy_type();
  PROTOBUF_DEPRECATED const std::string& policy_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_policy_type(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_policy_type();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_policy_type();
  PROTOBUF_DEPRECATED void set_allocated_policy_type(std::string* policy_type);
  private:
  const std::string& _internal_policy_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_type(const std::string& value);
  std::string* _internal_mutable_policy_type();
  public:

  // optional int32 error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // optional .enterprise_management.PolicyFetchRequest.SignatureType policy_data_signature_type = 11;
  bool has_policy_data_signature_type() const;
  private:
  bool _internal_has_policy_data_signature_type() const;
  public:
  void clear_policy_data_signature_type();
  ::enterprise_management::PolicyFetchRequest_SignatureType policy_data_signature_type() const;
  void set_policy_data_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);
  private:
  ::enterprise_management::PolicyFetchRequest_SignatureType _internal_policy_data_signature_type() const;
  void _internal_set_policy_data_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PolicyFetchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_data_signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_verification_signature_deprecated_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_verification_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_verification_data_signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_type_;
    int32_t error_code_;
    int policy_data_signature_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DEPRECATEDPolicyPublicKeyAndDomain final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain) */ {
 public:
  inline DEPRECATEDPolicyPublicKeyAndDomain() : DEPRECATEDPolicyPublicKeyAndDomain(nullptr) {}
  ~DEPRECATEDPolicyPublicKeyAndDomain() override;
  explicit PROTOBUF_CONSTEXPR DEPRECATEDPolicyPublicKeyAndDomain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DEPRECATEDPolicyPublicKeyAndDomain(const DEPRECATEDPolicyPublicKeyAndDomain& from);
  DEPRECATEDPolicyPublicKeyAndDomain(DEPRECATEDPolicyPublicKeyAndDomain&& from) noexcept
    : DEPRECATEDPolicyPublicKeyAndDomain() {
    *this = ::std::move(from);
  }

  inline DEPRECATEDPolicyPublicKeyAndDomain& operator=(const DEPRECATEDPolicyPublicKeyAndDomain& from) {
    CopyFrom(from);
    return *this;
  }
  inline DEPRECATEDPolicyPublicKeyAndDomain& operator=(DEPRECATEDPolicyPublicKeyAndDomain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DEPRECATEDPolicyPublicKeyAndDomain& default_instance() {
    return *internal_default_instance();
  }
  static inline const DEPRECATEDPolicyPublicKeyAndDomain* internal_default_instance() {
    return reinterpret_cast<const DEPRECATEDPolicyPublicKeyAndDomain*>(
               &_DEPRECATEDPolicyPublicKeyAndDomain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DEPRECATEDPolicyPublicKeyAndDomain& a, DEPRECATEDPolicyPublicKeyAndDomain& b) {
    a.Swap(&b);
  }
  inline void Swap(DEPRECATEDPolicyPublicKeyAndDomain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DEPRECATEDPolicyPublicKeyAndDomain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DEPRECATEDPolicyPublicKeyAndDomain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DEPRECATEDPolicyPublicKeyAndDomain>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DEPRECATEDPolicyPublicKeyAndDomain& from);
  void MergeFrom(const DEPRECATEDPolicyPublicKeyAndDomain& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DEPRECATEDPolicyPublicKeyAndDomain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain";
  }
  protected:
  explicit DEPRECATEDPolicyPublicKeyAndDomain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPublicKeyFieldNumber = 1,
    kDomainFieldNumber = 2,
  };
  // optional bytes new_public_key = 1;
  bool has_new_public_key() const;
  private:
  bool _internal_has_new_public_key() const;
  public:
  void clear_new_public_key();
  const std::string& new_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_public_key();
  PROTOBUF_NODISCARD std::string* release_new_public_key();
  void set_allocated_new_public_key(std::string* new_public_key);
  private:
  const std::string& _internal_new_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_key(const std::string& value);
  std::string* _internal_mutable_new_public_key();
  public:

  // optional string domain = 2;
  bool has_domain() const;
  private:
  bool _internal_has_domain() const;
  public:
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PublicKeyVerificationData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PublicKeyVerificationData) */ {
 public:
  inline PublicKeyVerificationData() : PublicKeyVerificationData(nullptr) {}
  ~PublicKeyVerificationData() override;
  explicit PROTOBUF_CONSTEXPR PublicKeyVerificationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicKeyVerificationData(const PublicKeyVerificationData& from);
  PublicKeyVerificationData(PublicKeyVerificationData&& from) noexcept
    : PublicKeyVerificationData() {
    *this = ::std::move(from);
  }

  inline PublicKeyVerificationData& operator=(const PublicKeyVerificationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicKeyVerificationData& operator=(PublicKeyVerificationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PublicKeyVerificationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicKeyVerificationData* internal_default_instance() {
    return reinterpret_cast<const PublicKeyVerificationData*>(
               &_PublicKeyVerificationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PublicKeyVerificationData& a, PublicKeyVerificationData& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicKeyVerificationData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicKeyVerificationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicKeyVerificationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicKeyVerificationData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PublicKeyVerificationData& from);
  void MergeFrom(const PublicKeyVerificationData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicKeyVerificationData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PublicKeyVerificationData";
  }
  protected:
  explicit PublicKeyVerificationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPublicKeyFieldNumber = 1,
    kDomainFieldNumber = 2,
    kNewPublicKeyVersionFieldNumber = 3,
  };
  // optional bytes new_public_key = 1;
  bool has_new_public_key() const;
  private:
  bool _internal_has_new_public_key() const;
  public:
  void clear_new_public_key();
  const std::string& new_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_public_key();
  PROTOBUF_NODISCARD std::string* release_new_public_key();
  void set_allocated_new_public_key(std::string* new_public_key);
  private:
  const std::string& _internal_new_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_key(const std::string& value);
  std::string* _internal_mutable_new_public_key();
  public:

  // optional string domain = 2;
  bool has_domain() const;
  private:
  bool _internal_has_domain() const;
  public:
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // optional int32 new_public_key_version = 3;
  bool has_new_public_key_version() const;
  private:
  bool _internal_has_new_public_key_version() const;
  public:
  void clear_new_public_key_version();
  int32_t new_public_key_version() const;
  void set_new_public_key_version(int32_t value);
  private:
  int32_t _internal_new_public_key_version() const;
  void _internal_set_new_public_key_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PublicKeyVerificationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    int32_t new_public_key_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DevicePolicyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePolicyRequest) */ {
 public:
  inline DevicePolicyRequest() : DevicePolicyRequest(nullptr) {}
  ~DevicePolicyRequest() override;
  explicit PROTOBUF_CONSTEXPR DevicePolicyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePolicyRequest(const DevicePolicyRequest& from);
  DevicePolicyRequest(DevicePolicyRequest&& from) noexcept
    : DevicePolicyRequest() {
    *this = ::std::move(from);
  }

  inline DevicePolicyRequest& operator=(const DevicePolicyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePolicyRequest& operator=(DevicePolicyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePolicyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePolicyRequest* internal_default_instance() {
    return reinterpret_cast<const DevicePolicyRequest*>(
               &_DevicePolicyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DevicePolicyRequest& a, DevicePolicyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePolicyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePolicyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePolicyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePolicyRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePolicyRequest& from);
  void MergeFrom(const DevicePolicyRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePolicyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePolicyRequest";
  }
  protected:
  explicit DevicePolicyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 3,
  };
  // repeated .enterprise_management.PolicyFetchRequest requests = 3;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::enterprise_management::PolicyFetchRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest >*
      mutable_requests();
  private:
  const ::enterprise_management::PolicyFetchRequest& _internal_requests(int index) const;
  ::enterprise_management::PolicyFetchRequest* _internal_add_requests();
  public:
  const ::enterprise_management::PolicyFetchRequest& requests(int index) const;
  ::enterprise_management::PolicyFetchRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePolicyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DevicePolicyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePolicyResponse) */ {
 public:
  inline DevicePolicyResponse() : DevicePolicyResponse(nullptr) {}
  ~DevicePolicyResponse() override;
  explicit PROTOBUF_CONSTEXPR DevicePolicyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePolicyResponse(const DevicePolicyResponse& from);
  DevicePolicyResponse(DevicePolicyResponse&& from) noexcept
    : DevicePolicyResponse() {
    *this = ::std::move(from);
  }

  inline DevicePolicyResponse& operator=(const DevicePolicyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePolicyResponse& operator=(DevicePolicyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePolicyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePolicyResponse* internal_default_instance() {
    return reinterpret_cast<const DevicePolicyResponse*>(
               &_DevicePolicyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DevicePolicyResponse& a, DevicePolicyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePolicyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePolicyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePolicyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePolicyResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePolicyResponse& from);
  void MergeFrom(const DevicePolicyResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePolicyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePolicyResponse";
  }
  protected:
  explicit DevicePolicyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 3,
  };
  // repeated .enterprise_management.PolicyFetchResponse responses = 3;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::enterprise_management::PolicyFetchResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse >*
      mutable_responses();
  private:
  const ::enterprise_management::PolicyFetchResponse& _internal_responses(int index) const;
  ::enterprise_management::PolicyFetchResponse* _internal_add_responses();
  public:
  const ::enterprise_management::PolicyFetchResponse& responses(int index) const;
  ::enterprise_management::PolicyFetchResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePolicyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse > responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class TimePeriod final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TimePeriod) */ {
 public:
  inline TimePeriod() : TimePeriod(nullptr) {}
  ~TimePeriod() override;
  explicit PROTOBUF_CONSTEXPR TimePeriod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimePeriod(const TimePeriod& from);
  TimePeriod(TimePeriod&& from) noexcept
    : TimePeriod() {
    *this = ::std::move(from);
  }

  inline TimePeriod& operator=(const TimePeriod& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimePeriod& operator=(TimePeriod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimePeriod& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimePeriod* internal_default_instance() {
    return reinterpret_cast<const TimePeriod*>(
               &_TimePeriod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TimePeriod& a, TimePeriod& b) {
    a.Swap(&b);
  }
  inline void Swap(TimePeriod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimePeriod* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimePeriod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimePeriod>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimePeriod& from);
  void MergeFrom(const TimePeriod& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimePeriod* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.TimePeriod";
  }
  protected:
  explicit TimePeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimestampFieldNumber = 1,
    kEndTimestampFieldNumber = 2,
  };
  // optional int64 start_timestamp = 1;
  bool has_start_timestamp() const;
  private:
  bool _internal_has_start_timestamp() const;
  public:
  void clear_start_timestamp();
  int64_t start_timestamp() const;
  void set_start_timestamp(int64_t value);
  private:
  int64_t _internal_start_timestamp() const;
  void _internal_set_start_timestamp(int64_t value);
  public:

  // optional int64 end_timestamp = 2;
  bool has_end_timestamp() const;
  private:
  bool _internal_has_end_timestamp() const;
  public:
  void clear_end_timestamp();
  int64_t end_timestamp() const;
  void set_end_timestamp(int64_t value);
  private:
  int64_t _internal_end_timestamp() const;
  void _internal_set_end_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.TimePeriod)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t start_timestamp_;
    int64_t end_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ActiveTimePeriod final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveTimePeriod) */ {
 public:
  inline ActiveTimePeriod() : ActiveTimePeriod(nullptr) {}
  ~ActiveTimePeriod() override;
  explicit PROTOBUF_CONSTEXPR ActiveTimePeriod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveTimePeriod(const ActiveTimePeriod& from);
  ActiveTimePeriod(ActiveTimePeriod&& from) noexcept
    : ActiveTimePeriod() {
    *this = ::std::move(from);
  }

  inline ActiveTimePeriod& operator=(const ActiveTimePeriod& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveTimePeriod& operator=(ActiveTimePeriod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActiveTimePeriod& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveTimePeriod* internal_default_instance() {
    return reinterpret_cast<const ActiveTimePeriod*>(
               &_ActiveTimePeriod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ActiveTimePeriod& a, ActiveTimePeriod& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveTimePeriod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveTimePeriod* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveTimePeriod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveTimePeriod>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActiveTimePeriod& from);
  void MergeFrom(const ActiveTimePeriod& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActiveTimePeriod* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ActiveTimePeriod";
  }
  protected:
  explicit ActiveTimePeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ActiveTimePeriod_SessionType SessionType;
  static constexpr SessionType SESSION_UNKNOWN =
    ActiveTimePeriod_SessionType_SESSION_UNKNOWN;
  static constexpr SessionType SESSION_AFFILIATED_USER =
    ActiveTimePeriod_SessionType_SESSION_AFFILIATED_USER;
  static constexpr SessionType SESSION_MANAGED_GUEST =
    ActiveTimePeriod_SessionType_SESSION_MANAGED_GUEST;
  static constexpr SessionType SESSION_KIOSK =
    ActiveTimePeriod_SessionType_SESSION_KIOSK;
  static constexpr SessionType SESSION_ARC_KIOSK =
    ActiveTimePeriod_SessionType_SESSION_ARC_KIOSK;
  static constexpr SessionType SESSION_WEB_KIOSK =
    ActiveTimePeriod_SessionType_SESSION_WEB_KIOSK;
  static inline bool SessionType_IsValid(int value) {
    return ActiveTimePeriod_SessionType_IsValid(value);
  }
  static constexpr SessionType SessionType_MIN =
    ActiveTimePeriod_SessionType_SessionType_MIN;
  static constexpr SessionType SessionType_MAX =
    ActiveTimePeriod_SessionType_SessionType_MAX;
  static constexpr int SessionType_ARRAYSIZE =
    ActiveTimePeriod_SessionType_SessionType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SessionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SessionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SessionType_Name.");
    return ActiveTimePeriod_SessionType_Name(enum_t_value);
  }
  static inline bool SessionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SessionType* value) {
    return ActiveTimePeriod_SessionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserEmailFieldNumber = 3,
    kTimePeriodFieldNumber = 1,
    kActiveDurationFieldNumber = 2,
    kSessionTypeFieldNumber = 4,
  };
  // optional string user_email = 3;
  bool has_user_email() const;
  private:
  bool _internal_has_user_email() const;
  public:
  void clear_user_email();
  const std::string& user_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_email();
  PROTOBUF_NODISCARD std::string* release_user_email();
  void set_allocated_user_email(std::string* user_email);
  private:
  const std::string& _internal_user_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_email(const std::string& value);
  std::string* _internal_mutable_user_email();
  public:

  // optional .enterprise_management.TimePeriod time_period = 1;
  bool has_time_period() const;
  private:
  bool _internal_has_time_period() const;
  public:
  void clear_time_period();
  const ::enterprise_management::TimePeriod& time_period() const;
  PROTOBUF_NODISCARD ::enterprise_management::TimePeriod* release_time_period();
  ::enterprise_management::TimePeriod* mutable_time_period();
  void set_allocated_time_period(::enterprise_management::TimePeriod* time_period);
  private:
  const ::enterprise_management::TimePeriod& _internal_time_period() const;
  ::enterprise_management::TimePeriod* _internal_mutable_time_period();
  public:
  void unsafe_arena_set_allocated_time_period(
      ::enterprise_management::TimePeriod* time_period);
  ::enterprise_management::TimePeriod* unsafe_arena_release_time_period();

  // optional int32 active_duration = 2;
  bool has_active_duration() const;
  private:
  bool _internal_has_active_duration() const;
  public:
  void clear_active_duration();
  int32_t active_duration() const;
  void set_active_duration(int32_t value);
  private:
  int32_t _internal_active_duration() const;
  void _internal_set_active_duration(int32_t value);
  public:

  // optional .enterprise_management.ActiveTimePeriod.SessionType session_type = 4;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::enterprise_management::ActiveTimePeriod_SessionType session_type() const;
  void set_session_type(::enterprise_management::ActiveTimePeriod_SessionType value);
  private:
  ::enterprise_management::ActiveTimePeriod_SessionType _internal_session_type() const;
  void _internal_set_session_type(::enterprise_management::ActiveTimePeriod_SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ActiveTimePeriod)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_email_;
    ::enterprise_management::TimePeriod* time_period_;
    int32_t active_duration_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class NetworkInterface final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.NetworkInterface) */ {
 public:
  inline NetworkInterface() : NetworkInterface(nullptr) {}
  ~NetworkInterface() override;
  explicit PROTOBUF_CONSTEXPR NetworkInterface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkInterface(const NetworkInterface& from);
  NetworkInterface(NetworkInterface&& from) noexcept
    : NetworkInterface() {
    *this = ::std::move(from);
  }

  inline NetworkInterface& operator=(const NetworkInterface& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkInterface& operator=(NetworkInterface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NetworkInterface& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkInterface* internal_default_instance() {
    return reinterpret_cast<const NetworkInterface*>(
               &_NetworkInterface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(NetworkInterface& a, NetworkInterface& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkInterface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkInterface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkInterface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkInterface>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkInterface& from);
  void MergeFrom(const NetworkInterface& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkInterface* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.NetworkInterface";
  }
  protected:
  explicit NetworkInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NetworkInterface_NetworkDeviceType NetworkDeviceType;
  static constexpr NetworkDeviceType TYPE_ETHERNET =
    NetworkInterface_NetworkDeviceType_TYPE_ETHERNET;
  static constexpr NetworkDeviceType TYPE_WIFI =
    NetworkInterface_NetworkDeviceType_TYPE_WIFI;
  static constexpr NetworkDeviceType TYPE_BLUETOOTH =
    NetworkInterface_NetworkDeviceType_TYPE_BLUETOOTH;
  static constexpr NetworkDeviceType TYPE_CELLULAR =
    NetworkInterface_NetworkDeviceType_TYPE_CELLULAR;
  static inline bool NetworkDeviceType_IsValid(int value) {
    return NetworkInterface_NetworkDeviceType_IsValid(value);
  }
  static constexpr NetworkDeviceType NetworkDeviceType_MIN =
    NetworkInterface_NetworkDeviceType_NetworkDeviceType_MIN;
  static constexpr NetworkDeviceType NetworkDeviceType_MAX =
    NetworkInterface_NetworkDeviceType_NetworkDeviceType_MAX;
  static constexpr int NetworkDeviceType_ARRAYSIZE =
    NetworkInterface_NetworkDeviceType_NetworkDeviceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& NetworkDeviceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NetworkDeviceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NetworkDeviceType_Name.");
    return NetworkInterface_NetworkDeviceType_Name(enum_t_value);
  }
  static inline bool NetworkDeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NetworkDeviceType* value) {
    return NetworkInterface_NetworkDeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEidsFieldNumber = 8,
    kMacAddressFieldNumber = 2,
    kMeidFieldNumber = 3,
    kImeiFieldNumber = 4,
    kDevicePathFieldNumber = 5,
    kIccidFieldNumber = 6,
    kMdnFieldNumber = 7,
    kTypeFieldNumber = 1,
  };
  // repeated string eids = 8;
  int eids_size() const;
  private:
  int _internal_eids_size() const;
  public:
  void clear_eids();
  const std::string& eids(int index) const;
  std::string* mutable_eids(int index);
  void set_eids(int index, const std::string& value);
  void set_eids(int index, std::string&& value);
  void set_eids(int index, const char* value);
  void set_eids(int index, const char* value, size_t size);
  std::string* add_eids();
  void add_eids(const std::string& value);
  void add_eids(std::string&& value);
  void add_eids(const char* value);
  void add_eids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& eids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_eids();
  private:
  const std::string& _internal_eids(int index) const;
  std::string* _internal_add_eids();
  public:

  // optional string mac_address = 2;
  bool has_mac_address() const;
  private:
  bool _internal_has_mac_address() const;
  public:
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // optional string meid = 3;
  bool has_meid() const;
  private:
  bool _internal_has_meid() const;
  public:
  void clear_meid();
  const std::string& meid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meid();
  PROTOBUF_NODISCARD std::string* release_meid();
  void set_allocated_meid(std::string* meid);
  private:
  const std::string& _internal_meid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meid(const std::string& value);
  std::string* _internal_mutable_meid();
  public:

  // optional string imei = 4;
  bool has_imei() const;
  private:
  bool _internal_has_imei() const;
  public:
  void clear_imei();
  const std::string& imei() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imei(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imei();
  PROTOBUF_NODISCARD std::string* release_imei();
  void set_allocated_imei(std::string* imei);
  private:
  const std::string& _internal_imei() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imei(const std::string& value);
  std::string* _internal_mutable_imei();
  public:

  // optional string device_path = 5;
  bool has_device_path() const;
  private:
  bool _internal_has_device_path() const;
  public:
  void clear_device_path();
  const std::string& device_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_path();
  PROTOBUF_NODISCARD std::string* release_device_path();
  void set_allocated_device_path(std::string* device_path);
  private:
  const std::string& _internal_device_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_path(const std::string& value);
  std::string* _internal_mutable_device_path();
  public:

  // optional string iccid = 6;
  bool has_iccid() const;
  private:
  bool _internal_has_iccid() const;
  public:
  void clear_iccid();
  const std::string& iccid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iccid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iccid();
  PROTOBUF_NODISCARD std::string* release_iccid();
  void set_allocated_iccid(std::string* iccid);
  private:
  const std::string& _internal_iccid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iccid(const std::string& value);
  std::string* _internal_mutable_iccid();
  public:

  // optional string mdn = 7;
  bool has_mdn() const;
  private:
  bool _internal_has_mdn() const;
  public:
  void clear_mdn();
  const std::string& mdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mdn();
  PROTOBUF_NODISCARD std::string* release_mdn();
  void set_allocated_mdn(std::string* mdn);
  private:
  const std::string& _internal_mdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mdn(const std::string& value);
  std::string* _internal_mutable_mdn();
  public:

  // optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::enterprise_management::NetworkInterface_NetworkDeviceType type() const;
  void set_type(::enterprise_management::NetworkInterface_NetworkDeviceType value);
  private:
  ::enterprise_management::NetworkInterface_NetworkDeviceType _internal_type() const;
  void _internal_set_type(::enterprise_management::NetworkInterface_NetworkDeviceType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.NetworkInterface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> eids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imei_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iccid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mdn_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class NetworkState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.NetworkState) */ {
 public:
  inline NetworkState() : NetworkState(nullptr) {}
  ~NetworkState() override;
  explicit PROTOBUF_CONSTEXPR NetworkState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkState(const NetworkState& from);
  NetworkState(NetworkState&& from) noexcept
    : NetworkState() {
    *this = ::std::move(from);
  }

  inline NetworkState& operator=(const NetworkState& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkState& operator=(NetworkState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NetworkState& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkState* internal_default_instance() {
    return reinterpret_cast<const NetworkState*>(
               &_NetworkState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(NetworkState& a, NetworkState& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkState& from);
  void MergeFrom(const NetworkState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.NetworkState";
  }
  protected:
  explicit NetworkState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NetworkState_ConnectionState ConnectionState;
  static constexpr ConnectionState IDLE =
    NetworkState_ConnectionState_IDLE;
  static constexpr ConnectionState ASSOCIATION =
    NetworkState_ConnectionState_ASSOCIATION;
  static constexpr ConnectionState CONFIGURATION =
    NetworkState_ConnectionState_CONFIGURATION;
  static constexpr ConnectionState READY =
    NetworkState_ConnectionState_READY;
  static constexpr ConnectionState PORTAL =
    NetworkState_ConnectionState_PORTAL;
  static constexpr ConnectionState ONLINE =
    NetworkState_ConnectionState_ONLINE;
  static constexpr ConnectionState DISCONNECT =
    NetworkState_ConnectionState_DISCONNECT;
  static constexpr ConnectionState FAILURE =
    NetworkState_ConnectionState_FAILURE;
  static constexpr ConnectionState UNKNOWN =
    NetworkState_ConnectionState_UNKNOWN;
  static inline bool ConnectionState_IsValid(int value) {
    return NetworkState_ConnectionState_IsValid(value);
  }
  static constexpr ConnectionState ConnectionState_MIN =
    NetworkState_ConnectionState_ConnectionState_MIN;
  static constexpr ConnectionState ConnectionState_MAX =
    NetworkState_ConnectionState_ConnectionState_MAX;
  static constexpr int ConnectionState_ARRAYSIZE =
    NetworkState_ConnectionState_ConnectionState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ConnectionState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionState_Name.");
    return NetworkState_ConnectionState_Name(enum_t_value);
  }
  static inline bool ConnectionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionState* value) {
    return NetworkState_ConnectionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePathFieldNumber = 1,
    kIpAddressFieldNumber = 4,
    kGatewayFieldNumber = 5,
    kConnectionStateFieldNumber = 2,
    kSignalStrengthFieldNumber = 3,
  };
  // optional string device_path = 1;
  bool has_device_path() const;
  private:
  bool _internal_has_device_path() const;
  public:
  void clear_device_path();
  const std::string& device_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_path();
  PROTOBUF_NODISCARD std::string* release_device_path();
  void set_allocated_device_path(std::string* device_path);
  private:
  const std::string& _internal_device_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_path(const std::string& value);
  std::string* _internal_mutable_device_path();
  public:

  // optional string ip_address = 4;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // optional string gateway = 5;
  bool has_gateway() const;
  private:
  bool _internal_has_gateway() const;
  public:
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
  bool has_connection_state() const;
  private:
  bool _internal_has_connection_state() const;
  public:
  void clear_connection_state();
  ::enterprise_management::NetworkState_ConnectionState connection_state() const;
  void set_connection_state(::enterprise_management::NetworkState_ConnectionState value);
  private:
  ::enterprise_management::NetworkState_ConnectionState _internal_connection_state() const;
  void _internal_set_connection_state(::enterprise_management::NetworkState_ConnectionState value);
  public:

  // optional int32 signal_strength = 3;
  bool has_signal_strength() const;
  private:
  bool _internal_has_signal_strength() const;
  public:
  void clear_signal_strength();
  int32_t signal_strength() const;
  void set_signal_strength(int32_t value);
  private:
  int32_t _internal_signal_strength() const;
  void _internal_set_signal_strength(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.NetworkState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
    int connection_state_;
    int32_t signal_strength_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceUser final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceUser) */ {
 public:
  inline DeviceUser() : DeviceUser(nullptr) {}
  ~DeviceUser() override;
  explicit PROTOBUF_CONSTEXPR DeviceUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceUser(const DeviceUser& from);
  DeviceUser(DeviceUser&& from) noexcept
    : DeviceUser() {
    *this = ::std::move(from);
  }

  inline DeviceUser& operator=(const DeviceUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceUser& operator=(DeviceUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceUser* internal_default_instance() {
    return reinterpret_cast<const DeviceUser*>(
               &_DeviceUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DeviceUser& a, DeviceUser& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceUser>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceUser& from);
  void MergeFrom(const DeviceUser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceUser";
  }
  protected:
  explicit DeviceUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceUser_UserType UserType;
  static constexpr UserType USER_TYPE_MANAGED =
    DeviceUser_UserType_USER_TYPE_MANAGED;
  static constexpr UserType USER_TYPE_UNMANAGED =
    DeviceUser_UserType_USER_TYPE_UNMANAGED;
  static inline bool UserType_IsValid(int value) {
    return DeviceUser_UserType_IsValid(value);
  }
  static constexpr UserType UserType_MIN =
    DeviceUser_UserType_UserType_MIN;
  static constexpr UserType UserType_MAX =
    DeviceUser_UserType_UserType_MAX;
  static constexpr int UserType_ARRAYSIZE =
    DeviceUser_UserType_UserType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& UserType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UserType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UserType_Name.");
    return DeviceUser_UserType_Name(enum_t_value);
  }
  static inline bool UserType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UserType* value) {
    return DeviceUser_UserType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string email = 2;
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // required .enterprise_management.DeviceUser.UserType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::enterprise_management::DeviceUser_UserType type() const;
  void set_type(::enterprise_management::DeviceUser_UserType value);
  private:
  ::enterprise_management::DeviceUser_UserType _internal_type() const;
  void _internal_set_type(::enterprise_management::DeviceUser_UserType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class VolumeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.VolumeInfo) */ {
 public:
  inline VolumeInfo() : VolumeInfo(nullptr) {}
  ~VolumeInfo() override;
  explicit PROTOBUF_CONSTEXPR VolumeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VolumeInfo(const VolumeInfo& from);
  VolumeInfo(VolumeInfo&& from) noexcept
    : VolumeInfo() {
    *this = ::std::move(from);
  }

  inline VolumeInfo& operator=(const VolumeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeInfo& operator=(VolumeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VolumeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeInfo* internal_default_instance() {
    return reinterpret_cast<const VolumeInfo*>(
               &_VolumeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(VolumeInfo& a, VolumeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VolumeInfo& from);
  void MergeFrom(const VolumeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VolumeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.VolumeInfo";
  }
  protected:
  explicit VolumeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
    kStorageTotalFieldNumber = 2,
    kStorageFreeFieldNumber = 3,
  };
  // optional string volume_id = 1;
  bool has_volume_id() const;
  private:
  bool _internal_has_volume_id() const;
  public:
  void clear_volume_id();
  const std::string& volume_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_volume_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // optional int64 storage_total = 2;
  bool has_storage_total() const;
  private:
  bool _internal_has_storage_total() const;
  public:
  void clear_storage_total();
  int64_t storage_total() const;
  void set_storage_total(int64_t value);
  private:
  int64_t _internal_storage_total() const;
  void _internal_set_storage_total(int64_t value);
  public:

  // optional int64 storage_free = 3;
  bool has_storage_free() const;
  private:
  bool _internal_has_storage_free() const;
  public:
  void clear_storage_free();
  int64_t storage_free() const;
  void set_storage_free(int64_t value);
  private:
  int64_t _internal_storage_free() const;
  void _internal_set_storage_free(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.VolumeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
    int64_t storage_total_;
    int64_t storage_free_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CpuUtilizationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CpuUtilizationInfo) */ {
 public:
  inline CpuUtilizationInfo() : CpuUtilizationInfo(nullptr) {}
  ~CpuUtilizationInfo() override;
  explicit PROTOBUF_CONSTEXPR CpuUtilizationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CpuUtilizationInfo(const CpuUtilizationInfo& from);
  CpuUtilizationInfo(CpuUtilizationInfo&& from) noexcept
    : CpuUtilizationInfo() {
    *this = ::std::move(from);
  }

  inline CpuUtilizationInfo& operator=(const CpuUtilizationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpuUtilizationInfo& operator=(CpuUtilizationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CpuUtilizationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CpuUtilizationInfo* internal_default_instance() {
    return reinterpret_cast<const CpuUtilizationInfo*>(
               &_CpuUtilizationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CpuUtilizationInfo& a, CpuUtilizationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CpuUtilizationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpuUtilizationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CpuUtilizationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CpuUtilizationInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CpuUtilizationInfo& from);
  void MergeFrom(const CpuUtilizationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CpuUtilizationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CpuUtilizationInfo";
  }
  protected:
  explicit CpuUtilizationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kCpuUtilizationPctFieldNumber = 1,
  };
  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int32 cpu_utilization_pct = 1;
  bool has_cpu_utilization_pct() const;
  private:
  bool _internal_has_cpu_utilization_pct() const;
  public:
  void clear_cpu_utilization_pct();
  int32_t cpu_utilization_pct() const;
  void set_cpu_utilization_pct(int32_t value);
  private:
  int32_t _internal_cpu_utilization_pct() const;
  void _internal_set_cpu_utilization_pct(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CpuUtilizationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t timestamp_;
    int32_t cpu_utilization_pct_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class SystemFreeRamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemFreeRamInfo) */ {
 public:
  inline SystemFreeRamInfo() : SystemFreeRamInfo(nullptr) {}
  ~SystemFreeRamInfo() override;
  explicit PROTOBUF_CONSTEXPR SystemFreeRamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemFreeRamInfo(const SystemFreeRamInfo& from);
  SystemFreeRamInfo(SystemFreeRamInfo&& from) noexcept
    : SystemFreeRamInfo() {
    *this = ::std::move(from);
  }

  inline SystemFreeRamInfo& operator=(const SystemFreeRamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemFreeRamInfo& operator=(SystemFreeRamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SystemFreeRamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemFreeRamInfo* internal_default_instance() {
    return reinterpret_cast<const SystemFreeRamInfo*>(
               &_SystemFreeRamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SystemFreeRamInfo& a, SystemFreeRamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemFreeRamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemFreeRamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemFreeRamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemFreeRamInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemFreeRamInfo& from);
  void MergeFrom(const SystemFreeRamInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemFreeRamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SystemFreeRamInfo";
  }
  protected:
  explicit SystemFreeRamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeInBytesFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // optional int64 size_in_bytes = 1;
  bool has_size_in_bytes() const;
  private:
  bool _internal_has_size_in_bytes() const;
  public:
  void clear_size_in_bytes();
  int64_t size_in_bytes() const;
  void set_size_in_bytes(int64_t value);
  private:
  int64_t _internal_size_in_bytes() const;
  void _internal_set_size_in_bytes(int64_t value);
  public:

  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SystemFreeRamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t size_in_bytes_;
    int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CPUTempInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CPUTempInfo) */ {
 public:
  inline CPUTempInfo() : CPUTempInfo(nullptr) {}
  ~CPUTempInfo() override;
  explicit PROTOBUF_CONSTEXPR CPUTempInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPUTempInfo(const CPUTempInfo& from);
  CPUTempInfo(CPUTempInfo&& from) noexcept
    : CPUTempInfo() {
    *this = ::std::move(from);
  }

  inline CPUTempInfo& operator=(const CPUTempInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPUTempInfo& operator=(CPUTempInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CPUTempInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPUTempInfo* internal_default_instance() {
    return reinterpret_cast<const CPUTempInfo*>(
               &_CPUTempInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CPUTempInfo& a, CPUTempInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CPUTempInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPUTempInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPUTempInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CPUTempInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CPUTempInfo& from);
  void MergeFrom(const CPUTempInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CPUTempInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CPUTempInfo";
  }
  protected:
  explicit CPUTempInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpuLabelFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kCpuTempFieldNumber = 2,
  };
  // optional string cpu_label = 1;
  bool has_cpu_label() const;
  private:
  bool _internal_has_cpu_label() const;
  public:
  void clear_cpu_label();
  const std::string& cpu_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cpu_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cpu_label();
  PROTOBUF_NODISCARD std::string* release_cpu_label();
  void set_allocated_cpu_label(std::string* cpu_label);
  private:
  const std::string& _internal_cpu_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpu_label(const std::string& value);
  std::string* _internal_mutable_cpu_label();
  public:

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int32 cpu_temp = 2;
  bool has_cpu_temp() const;
  private:
  bool _internal_has_cpu_temp() const;
  public:
  void clear_cpu_temp();
  int32_t cpu_temp() const;
  void set_cpu_temp(int32_t value);
  private:
  int32_t _internal_cpu_temp() const;
  void _internal_set_cpu_temp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CPUTempInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpu_label_;
    int64_t timestamp_;
    int32_t cpu_temp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class StatefulPartitionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.StatefulPartitionInfo) */ {
 public:
  inline StatefulPartitionInfo() : StatefulPartitionInfo(nullptr) {}
  ~StatefulPartitionInfo() override;
  explicit PROTOBUF_CONSTEXPR StatefulPartitionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatefulPartitionInfo(const StatefulPartitionInfo& from);
  StatefulPartitionInfo(StatefulPartitionInfo&& from) noexcept
    : StatefulPartitionInfo() {
    *this = ::std::move(from);
  }

  inline StatefulPartitionInfo& operator=(const StatefulPartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatefulPartitionInfo& operator=(StatefulPartitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StatefulPartitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatefulPartitionInfo* internal_default_instance() {
    return reinterpret_cast<const StatefulPartitionInfo*>(
               &_StatefulPartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(StatefulPartitionInfo& a, StatefulPartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StatefulPartitionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatefulPartitionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatefulPartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatefulPartitionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StatefulPartitionInfo& from);
  void MergeFrom(const StatefulPartitionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatefulPartitionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.StatefulPartitionInfo";
  }
  protected:
  explicit StatefulPartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesystemFieldNumber = 3,
    kMountSourceFieldNumber = 4,
    kAvailableSpaceFieldNumber = 1,
    kTotalSpaceFieldNumber = 2,
  };
  // optional string filesystem = 3;
  bool has_filesystem() const;
  private:
  bool _internal_has_filesystem() const;
  public:
  void clear_filesystem();
  const std::string& filesystem() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesystem(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesystem();
  PROTOBUF_NODISCARD std::string* release_filesystem();
  void set_allocated_filesystem(std::string* filesystem);
  private:
  const std::string& _internal_filesystem() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesystem(const std::string& value);
  std::string* _internal_mutable_filesystem();
  public:

  // optional string mount_source = 4;
  bool has_mount_source() const;
  private:
  bool _internal_has_mount_source() const;
  public:
  void clear_mount_source();
  const std::string& mount_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mount_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mount_source();
  PROTOBUF_NODISCARD std::string* release_mount_source();
  void set_allocated_mount_source(std::string* mount_source);
  private:
  const std::string& _internal_mount_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mount_source(const std::string& value);
  std::string* _internal_mutable_mount_source();
  public:

  // optional uint64 available_space = 1;
  bool has_available_space() const;
  private:
  bool _internal_has_available_space() const;
  public:
  void clear_available_space();
  uint64_t available_space() const;
  void set_available_space(uint64_t value);
  private:
  uint64_t _internal_available_space() const;
  void _internal_set_available_space(uint64_t value);
  public:

  // optional uint64 total_space = 2;
  bool has_total_space() const;
  private:
  bool _internal_has_total_space() const;
  public:
  void clear_total_space();
  uint64_t total_space() const;
  void set_total_space(uint64_t value);
  private:
  uint64_t _internal_total_space() const;
  void _internal_set_total_space(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.StatefulPartitionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesystem_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mount_source_;
    uint64_t available_space_;
    uint64_t total_space_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BatterySample final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BatterySample) */ {
 public:
  inline BatterySample() : BatterySample(nullptr) {}
  ~BatterySample() override;
  explicit PROTOBUF_CONSTEXPR BatterySample(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatterySample(const BatterySample& from);
  BatterySample(BatterySample&& from) noexcept
    : BatterySample() {
    *this = ::std::move(from);
  }

  inline BatterySample& operator=(const BatterySample& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatterySample& operator=(BatterySample&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BatterySample& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatterySample* internal_default_instance() {
    return reinterpret_cast<const BatterySample*>(
               &_BatterySample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(BatterySample& a, BatterySample& b) {
    a.Swap(&b);
  }
  inline void Swap(BatterySample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatterySample* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatterySample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatterySample>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BatterySample& from);
  void MergeFrom(const BatterySample& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatterySample* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BatterySample";
  }
  protected:
  explicit BatterySample(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 8,
    kTimestampFieldNumber = 1,
    kVoltageFieldNumber = 2,
    kRemainingCapacityFieldNumber = 3,
    kTemperatureFieldNumber = 4,
    kDischargeRateFieldNumber = 5,
    kCurrentFieldNumber = 7,
    kChargeRateFieldNumber = 6,
  };
  // optional string status = 8;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int64 voltage = 2;
  bool has_voltage() const;
  private:
  bool _internal_has_voltage() const;
  public:
  void clear_voltage();
  int64_t voltage() const;
  void set_voltage(int64_t value);
  private:
  int64_t _internal_voltage() const;
  void _internal_set_voltage(int64_t value);
  public:

  // optional int64 remaining_capacity = 3;
  bool has_remaining_capacity() const;
  private:
  bool _internal_has_remaining_capacity() const;
  public:
  void clear_remaining_capacity();
  int64_t remaining_capacity() const;
  void set_remaining_capacity(int64_t value);
  private:
  int64_t _internal_remaining_capacity() const;
  void _internal_set_remaining_capacity(int64_t value);
  public:

  // optional int32 temperature = 4;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  int32_t temperature() const;
  void set_temperature(int32_t value);
  private:
  int32_t _internal_temperature() const;
  void _internal_set_temperature(int32_t value);
  public:

  // optional int32 discharge_rate = 5;
  bool has_discharge_rate() const;
  private:
  bool _internal_has_discharge_rate() const;
  public:
  void clear_discharge_rate();
  int32_t discharge_rate() const;
  void set_discharge_rate(int32_t value);
  private:
  int32_t _internal_discharge_rate() const;
  void _internal_set_discharge_rate(int32_t value);
  public:

  // optional int64 current = 7;
  bool has_current() const;
  private:
  bool _internal_has_current() const;
  public:
  void clear_current();
  int64_t current() const;
  void set_current(int64_t value);
  private:
  int64_t _internal_current() const;
  void _internal_set_current(int64_t value);
  public:

  // optional int32 charge_rate = 6;
  bool has_charge_rate() const;
  private:
  bool _internal_has_charge_rate() const;
  public:
  void clear_charge_rate();
  int32_t charge_rate() const;
  void set_charge_rate(int32_t value);
  private:
  int32_t _internal_charge_rate() const;
  void _internal_set_charge_rate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BatterySample)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    int64_t timestamp_;
    int64_t voltage_;
    int64_t remaining_capacity_;
    int32_t temperature_;
    int32_t discharge_rate_;
    int64_t current_;
    int32_t charge_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BatteryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BatteryInfo) */ {
 public:
  inline BatteryInfo() : BatteryInfo(nullptr) {}
  ~BatteryInfo() override;
  explicit PROTOBUF_CONSTEXPR BatteryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryInfo(const BatteryInfo& from);
  BatteryInfo(BatteryInfo&& from) noexcept
    : BatteryInfo() {
    *this = ::std::move(from);
  }

  inline BatteryInfo& operator=(const BatteryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryInfo& operator=(BatteryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BatteryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryInfo* internal_default_instance() {
    return reinterpret_cast<const BatteryInfo*>(
               &_BatteryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(BatteryInfo& a, BatteryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatteryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatteryInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BatteryInfo& from);
  void MergeFrom(const BatteryInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatteryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BatteryInfo";
  }
  protected:
  explicit BatteryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplesFieldNumber = 7,
    kSerialFieldNumber = 1,
    kManufacturerFieldNumber = 2,
    kBatteryHealthFieldNumber = 3,
    kManufactureDateFieldNumber = 10,
    kTechnologyFieldNumber = 11,
    kDesignCapacityFieldNumber = 4,
    kFullChargeCapacityFieldNumber = 5,
    kCycleCountFieldNumber = 6,
    kDesignMinVoltageFieldNumber = 9,
  };
  // repeated .enterprise_management.BatterySample samples = 7;
  int samples_size() const;
  private:
  int _internal_samples_size() const;
  public:
  void clear_samples();
  ::enterprise_management::BatterySample* mutable_samples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample >*
      mutable_samples();
  private:
  const ::enterprise_management::BatterySample& _internal_samples(int index) const;
  ::enterprise_management::BatterySample* _internal_add_samples();
  public:
  const ::enterprise_management::BatterySample& samples(int index) const;
  ::enterprise_management::BatterySample* add_samples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample >&
      samples() const;

  // optional string serial = 1;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // optional string manufacturer = 2;
  bool has_manufacturer() const;
  private:
  bool _internal_has_manufacturer() const;
  public:
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // optional string battery_health = 3;
  bool has_battery_health() const;
  private:
  bool _internal_has_battery_health() const;
  public:
  void clear_battery_health();
  const std::string& battery_health() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_battery_health(ArgT0&& arg0, ArgT... args);
  std::string* mutable_battery_health();
  PROTOBUF_NODISCARD std::string* release_battery_health();
  void set_allocated_battery_health(std::string* battery_health);
  private:
  const std::string& _internal_battery_health() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_battery_health(const std::string& value);
  std::string* _internal_mutable_battery_health();
  public:

  // optional string manufacture_date = 10;
  bool has_manufacture_date() const;
  private:
  bool _internal_has_manufacture_date() const;
  public:
  void clear_manufacture_date();
  const std::string& manufacture_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacture_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacture_date();
  PROTOBUF_NODISCARD std::string* release_manufacture_date();
  void set_allocated_manufacture_date(std::string* manufacture_date);
  private:
  const std::string& _internal_manufacture_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacture_date(const std::string& value);
  std::string* _internal_mutable_manufacture_date();
  public:

  // optional string technology = 11;
  bool has_technology() const;
  private:
  bool _internal_has_technology() const;
  public:
  void clear_technology();
  const std::string& technology() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_technology(ArgT0&& arg0, ArgT... args);
  std::string* mutable_technology();
  PROTOBUF_NODISCARD std::string* release_technology();
  void set_allocated_technology(std::string* technology);
  private:
  const std::string& _internal_technology() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_technology(const std::string& value);
  std::string* _internal_mutable_technology();
  public:

  // optional int64 design_capacity = 4;
  bool has_design_capacity() const;
  private:
  bool _internal_has_design_capacity() const;
  public:
  void clear_design_capacity();
  int64_t design_capacity() const;
  void set_design_capacity(int64_t value);
  private:
  int64_t _internal_design_capacity() const;
  void _internal_set_design_capacity(int64_t value);
  public:

  // optional int64 full_charge_capacity = 5;
  bool has_full_charge_capacity() const;
  private:
  bool _internal_has_full_charge_capacity() const;
  public:
  void clear_full_charge_capacity();
  int64_t full_charge_capacity() const;
  void set_full_charge_capacity(int64_t value);
  private:
  int64_t _internal_full_charge_capacity() const;
  void _internal_set_full_charge_capacity(int64_t value);
  public:

  // optional int32 cycle_count = 6;
  bool has_cycle_count() const;
  private:
  bool _internal_has_cycle_count() const;
  public:
  void clear_cycle_count();
  int32_t cycle_count() const;
  void set_cycle_count(int32_t value);
  private:
  int32_t _internal_cycle_count() const;
  void _internal_set_cycle_count(int32_t value);
  public:

  // optional int32 design_min_voltage = 9;
  bool has_design_min_voltage() const;
  private:
  bool _internal_has_design_min_voltage() const;
  public:
  void clear_design_min_voltage();
  int32_t design_min_voltage() const;
  void set_design_min_voltage(int32_t value);
  private:
  int32_t _internal_design_min_voltage() const;
  void _internal_set_design_min_voltage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BatteryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample > samples_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr battery_health_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacture_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr technology_;
    int64_t design_capacity_;
    int64_t full_charge_capacity_;
    int32_t cycle_count_;
    int32_t design_min_voltage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PowerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PowerStatus) */ {
 public:
  inline PowerStatus() : PowerStatus(nullptr) {}
  ~PowerStatus() override;
  explicit PROTOBUF_CONSTEXPR PowerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerStatus(const PowerStatus& from);
  PowerStatus(PowerStatus&& from) noexcept
    : PowerStatus() {
    *this = ::std::move(from);
  }

  inline PowerStatus& operator=(const PowerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerStatus& operator=(PowerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PowerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerStatus* internal_default_instance() {
    return reinterpret_cast<const PowerStatus*>(
               &_PowerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(PowerStatus& a, PowerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PowerStatus& from);
  void MergeFrom(const PowerStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PowerStatus";
  }
  protected:
  explicit PowerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PowerStatus_PowerSource PowerSource;
  static constexpr PowerSource POWER_UNKNOWN =
    PowerStatus_PowerSource_POWER_UNKNOWN;
  static constexpr PowerSource POWER_AC =
    PowerStatus_PowerSource_POWER_AC;
  static constexpr PowerSource POWER_BATTERY =
    PowerStatus_PowerSource_POWER_BATTERY;
  static inline bool PowerSource_IsValid(int value) {
    return PowerStatus_PowerSource_IsValid(value);
  }
  static constexpr PowerSource PowerSource_MIN =
    PowerStatus_PowerSource_PowerSource_MIN;
  static constexpr PowerSource PowerSource_MAX =
    PowerStatus_PowerSource_PowerSource_MAX;
  static constexpr int PowerSource_ARRAYSIZE =
    PowerStatus_PowerSource_PowerSource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PowerSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PowerSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PowerSource_Name.");
    return PowerStatus_PowerSource_Name(enum_t_value);
  }
  static inline bool PowerSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PowerSource* value) {
    return PowerStatus_PowerSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBatteriesFieldNumber = 2,
    kPowerSourceFieldNumber = 1,
  };
  // repeated .enterprise_management.BatteryInfo batteries = 2;
  int batteries_size() const;
  private:
  int _internal_batteries_size() const;
  public:
  void clear_batteries();
  ::enterprise_management::BatteryInfo* mutable_batteries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo >*
      mutable_batteries();
  private:
  const ::enterprise_management::BatteryInfo& _internal_batteries(int index) const;
  ::enterprise_management::BatteryInfo* _internal_add_batteries();
  public:
  const ::enterprise_management::BatteryInfo& batteries(int index) const;
  ::enterprise_management::BatteryInfo* add_batteries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo >&
      batteries() const;

  // optional .enterprise_management.PowerStatus.PowerSource power_source = 1;
  bool has_power_source() const;
  private:
  bool _internal_has_power_source() const;
  public:
  void clear_power_source();
  ::enterprise_management::PowerStatus_PowerSource power_source() const;
  void set_power_source(::enterprise_management::PowerStatus_PowerSource value);
  private:
  ::enterprise_management::PowerStatus_PowerSource _internal_power_source() const;
  void _internal_set_power_source(::enterprise_management::PowerStatus_PowerSource value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PowerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo > batteries_;
    int power_source_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DiskLifetimeEstimation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DiskLifetimeEstimation) */ {
 public:
  inline DiskLifetimeEstimation() : DiskLifetimeEstimation(nullptr) {}
  ~DiskLifetimeEstimation() override;
  explicit PROTOBUF_CONSTEXPR DiskLifetimeEstimation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskLifetimeEstimation(const DiskLifetimeEstimation& from);
  DiskLifetimeEstimation(DiskLifetimeEstimation&& from) noexcept
    : DiskLifetimeEstimation() {
    *this = ::std::move(from);
  }

  inline DiskLifetimeEstimation& operator=(const DiskLifetimeEstimation& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskLifetimeEstimation& operator=(DiskLifetimeEstimation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DiskLifetimeEstimation& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskLifetimeEstimation* internal_default_instance() {
    return reinterpret_cast<const DiskLifetimeEstimation*>(
               &_DiskLifetimeEstimation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DiskLifetimeEstimation& a, DiskLifetimeEstimation& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskLifetimeEstimation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskLifetimeEstimation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskLifetimeEstimation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskLifetimeEstimation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DiskLifetimeEstimation& from);
  void MergeFrom(const DiskLifetimeEstimation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DiskLifetimeEstimation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DiskLifetimeEstimation";
  }
  protected:
  explicit DiskLifetimeEstimation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlcFieldNumber = 1,
    kMlcFieldNumber = 2,
  };
  // optional int32 slc = 1;
  bool has_slc() const;
  private:
  bool _internal_has_slc() const;
  public:
  void clear_slc();
  int32_t slc() const;
  void set_slc(int32_t value);
  private:
  int32_t _internal_slc() const;
  void _internal_set_slc(int32_t value);
  public:

  // optional int32 mlc = 2;
  bool has_mlc() const;
  private:
  bool _internal_has_mlc() const;
  public:
  void clear_mlc();
  int32_t mlc() const;
  void set_mlc(int32_t value);
  private:
  int32_t _internal_mlc() const;
  void _internal_set_mlc(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DiskLifetimeEstimation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t slc_;
    int32_t mlc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DiskInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DiskInfo) */ {
 public:
  inline DiskInfo() : DiskInfo(nullptr) {}
  ~DiskInfo() override;
  explicit PROTOBUF_CONSTEXPR DiskInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskInfo(const DiskInfo& from);
  DiskInfo(DiskInfo&& from) noexcept
    : DiskInfo() {
    *this = ::std::move(from);
  }

  inline DiskInfo& operator=(const DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskInfo& operator=(DiskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DiskInfo& default_instance() {
    return *internal_default_instance();
  }
  enum VendorIdCase {
    kNvmeSubsystemVendor = 14,
    kEmmcOemid = 15,
    kOtherVendor = 16,
    kJedecManfid = 27,
    VENDOR_ID_NOT_SET = 0,
  };

  enum ProductIdCase {
    kNvmeSubsystemDevice = 17,
    kEmmcPnm = 18,
    kOtherProduct = 19,
    PRODUCT_ID_NOT_SET = 0,
  };

  enum HardwareRevisionCase {
    kNvmeHardwareRev = 20,
    kEmmcHardwareRev = 21,
    kOtherHardwareRev = 22,
    HARDWARE_REVISION_NOT_SET = 0,
  };

  enum FirmwareRevisionCase {
    kNvmeFirmwareRev = 23,
    kEmmcFirmwareRev = 24,
    kOtherFirmwareRev = 25,
    kUfsFirmwareRev = 28,
    FIRMWARE_REVISION_NOT_SET = 0,
  };

  static inline const DiskInfo* internal_default_instance() {
    return reinterpret_cast<const DiskInfo*>(
               &_DiskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(DiskInfo& a, DiskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DiskInfo& from);
  void MergeFrom(const DiskInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DiskInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DiskInfo";
  }
  protected:
  explicit DiskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DiskInfo_DevicePurpose DevicePurpose;
  static constexpr DevicePurpose PURPOSE_UNKNOWN =
    DiskInfo_DevicePurpose_PURPOSE_UNKNOWN;
  static constexpr DevicePurpose PURPOSE_BOOT =
    DiskInfo_DevicePurpose_PURPOSE_BOOT;
  static constexpr DevicePurpose PURPOSE_SWAP =
    DiskInfo_DevicePurpose_PURPOSE_SWAP;
  static inline bool DevicePurpose_IsValid(int value) {
    return DiskInfo_DevicePurpose_IsValid(value);
  }
  static constexpr DevicePurpose DevicePurpose_MIN =
    DiskInfo_DevicePurpose_DevicePurpose_MIN;
  static constexpr DevicePurpose DevicePurpose_MAX =
    DiskInfo_DevicePurpose_DevicePurpose_MAX;
  static constexpr int DevicePurpose_ARRAYSIZE =
    DiskInfo_DevicePurpose_DevicePurpose_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DevicePurpose_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DevicePurpose>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DevicePurpose_Name.");
    return DiskInfo_DevicePurpose_Name(enum_t_value);
  }
  static inline bool DevicePurpose_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DevicePurpose* value) {
    return DiskInfo_DevicePurpose_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVolumesFieldNumber = 7,
    kSerialFieldNumber = 1,
    kManufacturerFieldNumber = 2,
    kModelFieldNumber = 3,
    kTypeFieldNumber = 5,
    kHealthFieldNumber = 6,
    kSizeFieldNumber = 4,
    kBytesReadSinceLastBootFieldNumber = 8,
    kBytesWrittenSinceLastBootFieldNumber = 9,
    kReadTimeSecondsSinceLastBootFieldNumber = 10,
    kWriteTimeSecondsSinceLastBootFieldNumber = 11,
    kIoTimeSecondsSinceLastBootFieldNumber = 12,
    kDiscardTimeSecondsSinceLastBootFieldNumber = 13,
    kPurposeFieldNumber = 26,
    kNvmeSubsystemVendorFieldNumber = 14,
    kEmmcOemidFieldNumber = 15,
    kOtherVendorFieldNumber = 16,
    kJedecManfidFieldNumber = 27,
    kNvmeSubsystemDeviceFieldNumber = 17,
    kEmmcPnmFieldNumber = 18,
    kOtherProductFieldNumber = 19,
    kNvmeHardwareRevFieldNumber = 20,
    kEmmcHardwareRevFieldNumber = 21,
    kOtherHardwareRevFieldNumber = 22,
    kNvmeFirmwareRevFieldNumber = 23,
    kEmmcFirmwareRevFieldNumber = 24,
    kOtherFirmwareRevFieldNumber = 25,
    kUfsFirmwareRevFieldNumber = 28,
  };
  // repeated string volumes = 7;
  int volumes_size() const;
  private:
  int _internal_volumes_size() const;
  public:
  void clear_volumes();
  const std::string& volumes(int index) const;
  std::string* mutable_volumes(int index);
  void set_volumes(int index, const std::string& value);
  void set_volumes(int index, std::string&& value);
  void set_volumes(int index, const char* value);
  void set_volumes(int index, const char* value, size_t size);
  std::string* add_volumes();
  void add_volumes(const std::string& value);
  void add_volumes(std::string&& value);
  void add_volumes(const char* value);
  void add_volumes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& volumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_volumes();
  private:
  const std::string& _internal_volumes(int index) const;
  std::string* _internal_add_volumes();
  public:

  // optional string serial = 1;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // optional string manufacturer = 2;
  bool has_manufacturer() const;
  private:
  bool _internal_has_manufacturer() const;
  public:
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // optional string model = 3;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // optional string type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string health = 6;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  const std::string& health() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_health(ArgT0&& arg0, ArgT... args);
  std::string* mutable_health();
  PROTOBUF_NODISCARD std::string* release_health();
  void set_allocated_health(std::string* health);
  private:
  const std::string& _internal_health() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_health(const std::string& value);
  std::string* _internal_mutable_health();
  public:

  // optional int64 size = 4;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // optional uint64 bytes_read_since_last_boot = 8;
  bool has_bytes_read_since_last_boot() const;
  private:
  bool _internal_has_bytes_read_since_last_boot() const;
  public:
  void clear_bytes_read_since_last_boot();
  uint64_t bytes_read_since_last_boot() const;
  void set_bytes_read_since_last_boot(uint64_t value);
  private:
  uint64_t _internal_bytes_read_since_last_boot() const;
  void _internal_set_bytes_read_since_last_boot(uint64_t value);
  public:

  // optional uint64 bytes_written_since_last_boot = 9;
  bool has_bytes_written_since_last_boot() const;
  private:
  bool _internal_has_bytes_written_since_last_boot() const;
  public:
  void clear_bytes_written_since_last_boot();
  uint64_t bytes_written_since_last_boot() const;
  void set_bytes_written_since_last_boot(uint64_t value);
  private:
  uint64_t _internal_bytes_written_since_last_boot() const;
  void _internal_set_bytes_written_since_last_boot(uint64_t value);
  public:

  // optional uint64 read_time_seconds_since_last_boot = 10;
  bool has_read_time_seconds_since_last_boot() const;
  private:
  bool _internal_has_read_time_seconds_since_last_boot() const;
  public:
  void clear_read_time_seconds_since_last_boot();
  uint64_t read_time_seconds_since_last_boot() const;
  void set_read_time_seconds_since_last_boot(uint64_t value);
  private:
  uint64_t _internal_read_time_seconds_since_last_boot() const;
  void _internal_set_read_time_seconds_since_last_boot(uint64_t value);
  public:

  // optional uint64 write_time_seconds_since_last_boot = 11;
  bool has_write_time_seconds_since_last_boot() const;
  private:
  bool _internal_has_write_time_seconds_since_last_boot() const;
  public:
  void clear_write_time_seconds_since_last_boot();
  uint64_t write_time_seconds_since_last_boot() const;
  void set_write_time_seconds_since_last_boot(uint64_t value);
  private:
  uint64_t _internal_write_time_seconds_since_last_boot() const;
  void _internal_set_write_time_seconds_since_last_boot(uint64_t value);
  public:

  // optional uint64 io_time_seconds_since_last_boot = 12;
  bool has_io_time_seconds_since_last_boot() const;
  private:
  bool _internal_has_io_time_seconds_since_last_boot() const;
  public:
  void clear_io_time_seconds_since_last_boot();
  uint64_t io_time_seconds_since_last_boot() const;
  void set_io_time_seconds_since_last_boot(uint64_t value);
  private:
  uint64_t _internal_io_time_seconds_since_last_boot() const;
  void _internal_set_io_time_seconds_since_last_boot(uint64_t value);
  public:

  // optional uint64 discard_time_seconds_since_last_boot = 13;
  bool has_discard_time_seconds_since_last_boot() const;
  private:
  bool _internal_has_discard_time_seconds_since_last_boot() const;
  public:
  void clear_discard_time_seconds_since_last_boot();
  uint64_t discard_time_seconds_since_last_boot() const;
  void set_discard_time_seconds_since_last_boot(uint64_t value);
  private:
  uint64_t _internal_discard_time_seconds_since_last_boot() const;
  void _internal_set_discard_time_seconds_since_last_boot(uint64_t value);
  public:

  // optional .enterprise_management.DiskInfo.DevicePurpose purpose = 26;
  bool has_purpose() const;
  private:
  bool _internal_has_purpose() const;
  public:
  void clear_purpose();
  ::enterprise_management::DiskInfo_DevicePurpose purpose() const;
  void set_purpose(::enterprise_management::DiskInfo_DevicePurpose value);
  private:
  ::enterprise_management::DiskInfo_DevicePurpose _internal_purpose() const;
  void _internal_set_purpose(::enterprise_management::DiskInfo_DevicePurpose value);
  public:

  // uint32 nvme_subsystem_vendor = 14;
  bool has_nvme_subsystem_vendor() const;
  private:
  bool _internal_has_nvme_subsystem_vendor() const;
  public:
  void clear_nvme_subsystem_vendor();
  uint32_t nvme_subsystem_vendor() const;
  void set_nvme_subsystem_vendor(uint32_t value);
  private:
  uint32_t _internal_nvme_subsystem_vendor() const;
  void _internal_set_nvme_subsystem_vendor(uint32_t value);
  public:

  // uint32 emmc_oemid = 15;
  bool has_emmc_oemid() const;
  private:
  bool _internal_has_emmc_oemid() const;
  public:
  void clear_emmc_oemid();
  uint32_t emmc_oemid() const;
  void set_emmc_oemid(uint32_t value);
  private:
  uint32_t _internal_emmc_oemid() const;
  void _internal_set_emmc_oemid(uint32_t value);
  public:

  // uint32 other_vendor = 16;
  bool has_other_vendor() const;
  private:
  bool _internal_has_other_vendor() const;
  public:
  void clear_other_vendor();
  uint32_t other_vendor() const;
  void set_other_vendor(uint32_t value);
  private:
  uint32_t _internal_other_vendor() const;
  void _internal_set_other_vendor(uint32_t value);
  public:

  // uint32 jedec_manfid = 27;
  bool has_jedec_manfid() const;
  private:
  bool _internal_has_jedec_manfid() const;
  public:
  void clear_jedec_manfid();
  uint32_t jedec_manfid() const;
  void set_jedec_manfid(uint32_t value);
  private:
  uint32_t _internal_jedec_manfid() const;
  void _internal_set_jedec_manfid(uint32_t value);
  public:

  // uint32 nvme_subsystem_device = 17;
  bool has_nvme_subsystem_device() const;
  private:
  bool _internal_has_nvme_subsystem_device() const;
  public:
  void clear_nvme_subsystem_device();
  uint32_t nvme_subsystem_device() const;
  void set_nvme_subsystem_device(uint32_t value);
  private:
  uint32_t _internal_nvme_subsystem_device() const;
  void _internal_set_nvme_subsystem_device(uint32_t value);
  public:

  // uint32 emmc_pnm = 18;
  bool has_emmc_pnm() const;
  private:
  bool _internal_has_emmc_pnm() const;
  public:
  void clear_emmc_pnm();
  uint32_t emmc_pnm() const;
  void set_emmc_pnm(uint32_t value);
  private:
  uint32_t _internal_emmc_pnm() const;
  void _internal_set_emmc_pnm(uint32_t value);
  public:

  // uint32 other_product = 19;
  bool has_other_product() const;
  private:
  bool _internal_has_other_product() const;
  public:
  void clear_other_product();
  uint32_t other_product() const;
  void set_other_product(uint32_t value);
  private:
  uint32_t _internal_other_product() const;
  void _internal_set_other_product(uint32_t value);
  public:

  // uint32 nvme_hardware_rev = 20;
  bool has_nvme_hardware_rev() const;
  private:
  bool _internal_has_nvme_hardware_rev() const;
  public:
  void clear_nvme_hardware_rev();
  uint32_t nvme_hardware_rev() const;
  void set_nvme_hardware_rev(uint32_t value);
  private:
  uint32_t _internal_nvme_hardware_rev() const;
  void _internal_set_nvme_hardware_rev(uint32_t value);
  public:

  // uint32 emmc_hardware_rev = 21;
  bool has_emmc_hardware_rev() const;
  private:
  bool _internal_has_emmc_hardware_rev() const;
  public:
  void clear_emmc_hardware_rev();
  uint32_t emmc_hardware_rev() const;
  void set_emmc_hardware_rev(uint32_t value);
  private:
  uint32_t _internal_emmc_hardware_rev() const;
  void _internal_set_emmc_hardware_rev(uint32_t value);
  public:

  // uint32 other_hardware_rev = 22;
  bool has_other_hardware_rev() const;
  private:
  bool _internal_has_other_hardware_rev() const;
  public:
  void clear_other_hardware_rev();
  uint32_t other_hardware_rev() const;
  void set_other_hardware_rev(uint32_t value);
  private:
  uint32_t _internal_other_hardware_rev() const;
  void _internal_set_other_hardware_rev(uint32_t value);
  public:

  // uint64 nvme_firmware_rev = 23;
  bool has_nvme_firmware_rev() const;
  private:
  bool _internal_has_nvme_firmware_rev() const;
  public:
  void clear_nvme_firmware_rev();
  uint64_t nvme_firmware_rev() const;
  void set_nvme_firmware_rev(uint64_t value);
  private:
  uint64_t _internal_nvme_firmware_rev() const;
  void _internal_set_nvme_firmware_rev(uint64_t value);
  public:

  // uint64 emmc_firmware_rev = 24;
  bool has_emmc_firmware_rev() const;
  private:
  bool _internal_has_emmc_firmware_rev() const;
  public:
  void clear_emmc_firmware_rev();
  uint64_t emmc_firmware_rev() const;
  void set_emmc_firmware_rev(uint64_t value);
  private:
  uint64_t _internal_emmc_firmware_rev() const;
  void _internal_set_emmc_firmware_rev(uint64_t value);
  public:

  // uint32 other_firmware_rev = 25;
  bool has_other_firmware_rev() const;
  private:
  bool _internal_has_other_firmware_rev() const;
  public:
  void clear_other_firmware_rev();
  uint32_t other_firmware_rev() const;
  void set_other_firmware_rev(uint32_t value);
  private:
  uint32_t _internal_other_firmware_rev() const;
  void _internal_set_other_firmware_rev(uint32_t value);
  public:

  // uint32 ufs_firmware_rev = 28;
  bool has_ufs_firmware_rev() const;
  private:
  bool _internal_has_ufs_firmware_rev() const;
  public:
  void clear_ufs_firmware_rev();
  uint32_t ufs_firmware_rev() const;
  void set_ufs_firmware_rev(uint32_t value);
  private:
  uint32_t _internal_ufs_firmware_rev() const;
  void _internal_set_ufs_firmware_rev(uint32_t value);
  public:

  void clear_vendor_id();
  VendorIdCase vendor_id_case() const;
  void clear_product_id();
  ProductIdCase product_id_case() const;
  void clear_hardware_revision();
  HardwareRevisionCase hardware_revision_case() const;
  void clear_firmware_revision();
  FirmwareRevisionCase firmware_revision_case() const;
  // @@protoc_insertion_point(class_scope:enterprise_management.DiskInfo)
 private:
  class _Internal;
  void set_has_nvme_subsystem_vendor();
  void set_has_emmc_oemid();
  void set_has_other_vendor();
  void set_has_jedec_manfid();
  void set_has_nvme_subsystem_device();
  void set_has_emmc_pnm();
  void set_has_other_product();
  void set_has_nvme_hardware_rev();
  void set_has_emmc_hardware_rev();
  void set_has_other_hardware_rev();
  void set_has_nvme_firmware_rev();
  void set_has_emmc_firmware_rev();
  void set_has_other_firmware_rev();
  void set_has_ufs_firmware_rev();

  inline bool has_vendor_id() const;
  inline void clear_has_vendor_id();

  inline bool has_product_id() const;
  inline void clear_has_product_id();

  inline bool has_hardware_revision() const;
  inline void clear_has_hardware_revision();

  inline bool has_firmware_revision() const;
  inline void clear_has_firmware_revision();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> volumes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr health_;
    int64_t size_;
    uint64_t bytes_read_since_last_boot_;
    uint64_t bytes_written_since_last_boot_;
    uint64_t read_time_seconds_since_last_boot_;
    uint64_t write_time_seconds_since_last_boot_;
    uint64_t io_time_seconds_since_last_boot_;
    uint64_t discard_time_seconds_since_last_boot_;
    int purpose_;
    union VendorIdUnion {
      constexpr VendorIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t nvme_subsystem_vendor_;
      uint32_t emmc_oemid_;
      uint32_t other_vendor_;
      uint32_t jedec_manfid_;
    } vendor_id_;
    union ProductIdUnion {
      constexpr ProductIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t nvme_subsystem_device_;
      uint32_t emmc_pnm_;
      uint32_t other_product_;
    } product_id_;
    union HardwareRevisionUnion {
      constexpr HardwareRevisionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t nvme_hardware_rev_;
      uint32_t emmc_hardware_rev_;
      uint32_t other_hardware_rev_;
    } hardware_revision_;
    union FirmwareRevisionUnion {
      constexpr FirmwareRevisionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t nvme_firmware_rev_;
      uint64_t emmc_firmware_rev_;
      uint32_t other_firmware_rev_;
      uint32_t ufs_firmware_rev_;
    } firmware_revision_;
    uint32_t _oneof_case_[4];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class StorageStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.StorageStatus) */ {
 public:
  inline StorageStatus() : StorageStatus(nullptr) {}
  ~StorageStatus() override;
  explicit PROTOBUF_CONSTEXPR StorageStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageStatus(const StorageStatus& from);
  StorageStatus(StorageStatus&& from) noexcept
    : StorageStatus() {
    *this = ::std::move(from);
  }

  inline StorageStatus& operator=(const StorageStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageStatus& operator=(StorageStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StorageStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageStatus* internal_default_instance() {
    return reinterpret_cast<const StorageStatus*>(
               &_StorageStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(StorageStatus& a, StorageStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StorageStatus& from);
  void MergeFrom(const StorageStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StorageStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.StorageStatus";
  }
  protected:
  explicit StorageStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisksFieldNumber = 1,
    kLifetimeEstimationFieldNumber = 2,
  };
  // repeated .enterprise_management.DiskInfo disks = 1;
  int disks_size() const;
  private:
  int _internal_disks_size() const;
  public:
  void clear_disks();
  ::enterprise_management::DiskInfo* mutable_disks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo >*
      mutable_disks();
  private:
  const ::enterprise_management::DiskInfo& _internal_disks(int index) const;
  ::enterprise_management::DiskInfo* _internal_add_disks();
  public:
  const ::enterprise_management::DiskInfo& disks(int index) const;
  ::enterprise_management::DiskInfo* add_disks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo >&
      disks() const;

  // optional .enterprise_management.DiskLifetimeEstimation lifetime_estimation = 2;
  bool has_lifetime_estimation() const;
  private:
  bool _internal_has_lifetime_estimation() const;
  public:
  void clear_lifetime_estimation();
  const ::enterprise_management::DiskLifetimeEstimation& lifetime_estimation() const;
  PROTOBUF_NODISCARD ::enterprise_management::DiskLifetimeEstimation* release_lifetime_estimation();
  ::enterprise_management::DiskLifetimeEstimation* mutable_lifetime_estimation();
  void set_allocated_lifetime_estimation(::enterprise_management::DiskLifetimeEstimation* lifetime_estimation);
  private:
  const ::enterprise_management::DiskLifetimeEstimation& _internal_lifetime_estimation() const;
  ::enterprise_management::DiskLifetimeEstimation* _internal_mutable_lifetime_estimation();
  public:
  void unsafe_arena_set_allocated_lifetime_estimation(
      ::enterprise_management::DiskLifetimeEstimation* lifetime_estimation);
  ::enterprise_management::DiskLifetimeEstimation* unsafe_arena_release_lifetime_estimation();

  // @@protoc_insertion_point(class_scope:enterprise_management.StorageStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo > disks_;
    ::enterprise_management::DiskLifetimeEstimation* lifetime_estimation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ThermalSample final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ThermalSample) */ {
 public:
  inline ThermalSample() : ThermalSample(nullptr) {}
  ~ThermalSample() override;
  explicit PROTOBUF_CONSTEXPR ThermalSample(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThermalSample(const ThermalSample& from);
  ThermalSample(ThermalSample&& from) noexcept
    : ThermalSample() {
    *this = ::std::move(from);
  }

  inline ThermalSample& operator=(const ThermalSample& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThermalSample& operator=(ThermalSample&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThermalSample& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThermalSample* internal_default_instance() {
    return reinterpret_cast<const ThermalSample*>(
               &_ThermalSample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ThermalSample& a, ThermalSample& b) {
    a.Swap(&b);
  }
  inline void Swap(ThermalSample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThermalSample* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThermalSample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThermalSample>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThermalSample& from);
  void MergeFrom(const ThermalSample& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThermalSample* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ThermalSample";
  }
  protected:
  explicit ThermalSample(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kTemperatureFieldNumber = 2,
  };
  // optional int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int32 temperature = 2;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  int32_t temperature() const;
  void set_temperature(int32_t value);
  private:
  int32_t _internal_temperature() const;
  void _internal_set_temperature(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ThermalSample)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t timestamp_;
    int32_t temperature_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ThermalInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ThermalInfo) */ {
 public:
  inline ThermalInfo() : ThermalInfo(nullptr) {}
  ~ThermalInfo() override;
  explicit PROTOBUF_CONSTEXPR ThermalInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThermalInfo(const ThermalInfo& from);
  ThermalInfo(ThermalInfo&& from) noexcept
    : ThermalInfo() {
    *this = ::std::move(from);
  }

  inline ThermalInfo& operator=(const ThermalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThermalInfo& operator=(ThermalInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThermalInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThermalInfo* internal_default_instance() {
    return reinterpret_cast<const ThermalInfo*>(
               &_ThermalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ThermalInfo& a, ThermalInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ThermalInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThermalInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThermalInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThermalInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThermalInfo& from);
  void MergeFrom(const ThermalInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThermalInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ThermalInfo";
  }
  protected:
  explicit ThermalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplesFieldNumber = 3,
    kLabelFieldNumber = 1,
  };
  // repeated .enterprise_management.ThermalSample samples = 3;
  int samples_size() const;
  private:
  int _internal_samples_size() const;
  public:
  void clear_samples();
  ::enterprise_management::ThermalSample* mutable_samples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample >*
      mutable_samples();
  private:
  const ::enterprise_management::ThermalSample& _internal_samples(int index) const;
  ::enterprise_management::ThermalSample* _internal_add_samples();
  public:
  const ::enterprise_management::ThermalSample& samples(int index) const;
  ::enterprise_management::ThermalSample* add_samples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample >&
      samples() const;

  // optional string label = 1;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ThermalInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample > samples_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BoardStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BoardStatus) */ {
 public:
  inline BoardStatus() : BoardStatus(nullptr) {}
  ~BoardStatus() override;
  explicit PROTOBUF_CONSTEXPR BoardStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoardStatus(const BoardStatus& from);
  BoardStatus(BoardStatus&& from) noexcept
    : BoardStatus() {
    *this = ::std::move(from);
  }

  inline BoardStatus& operator=(const BoardStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoardStatus& operator=(BoardStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BoardStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoardStatus* internal_default_instance() {
    return reinterpret_cast<const BoardStatus*>(
               &_BoardStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(BoardStatus& a, BoardStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BoardStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoardStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoardStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoardStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BoardStatus& from);
  void MergeFrom(const BoardStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoardStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BoardStatus";
  }
  protected:
  explicit BoardStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThermalInfosFieldNumber = 1,
  };
  // repeated .enterprise_management.ThermalInfo thermal_infos = 1;
  int thermal_infos_size() const;
  private:
  int _internal_thermal_infos_size() const;
  public:
  void clear_thermal_infos();
  ::enterprise_management::ThermalInfo* mutable_thermal_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo >*
      mutable_thermal_infos();
  private:
  const ::enterprise_management::ThermalInfo& _internal_thermal_infos(int index) const;
  ::enterprise_management::ThermalInfo* _internal_add_thermal_infos();
  public:
  const ::enterprise_management::ThermalInfo& thermal_infos(int index) const;
  ::enterprise_management::ThermalInfo* add_thermal_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo >&
      thermal_infos() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.BoardStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo > thermal_infos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class SystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemStatus) */ {
 public:
  inline SystemStatus() : SystemStatus(nullptr) {}
  ~SystemStatus() override;
  explicit PROTOBUF_CONSTEXPR SystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemStatus(const SystemStatus& from);
  SystemStatus(SystemStatus&& from) noexcept
    : SystemStatus() {
    *this = ::std::move(from);
  }

  inline SystemStatus& operator=(const SystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemStatus& operator=(SystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemStatus* internal_default_instance() {
    return reinterpret_cast<const SystemStatus*>(
               &_SystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(SystemStatus& a, SystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemStatus& from);
  void MergeFrom(const SystemStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SystemStatus";
  }
  protected:
  explicit SystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVpdSkuNumberFieldNumber = 1,
    kFirstPowerDateFieldNumber = 2,
    kManufactureDateFieldNumber = 3,
    kMarketingNameFieldNumber = 4,
    kBiosVersionFieldNumber = 5,
    kBoardNameFieldNumber = 6,
    kBoardVersionFieldNumber = 7,
    kProductNameFieldNumber = 9,
    kVpdSerialNumberFieldNumber = 10,
    kChassisTypeFieldNumber = 8,
  };
  // optional string vpd_sku_number = 1;
  bool has_vpd_sku_number() const;
  private:
  bool _internal_has_vpd_sku_number() const;
  public:
  void clear_vpd_sku_number();
  const std::string& vpd_sku_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vpd_sku_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vpd_sku_number();
  PROTOBUF_NODISCARD std::string* release_vpd_sku_number();
  void set_allocated_vpd_sku_number(std::string* vpd_sku_number);
  private:
  const std::string& _internal_vpd_sku_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vpd_sku_number(const std::string& value);
  std::string* _internal_mutable_vpd_sku_number();
  public:

  // optional string first_power_date = 2;
  bool has_first_power_date() const;
  private:
  bool _internal_has_first_power_date() const;
  public:
  void clear_first_power_date();
  const std::string& first_power_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_power_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_power_date();
  PROTOBUF_NODISCARD std::string* release_first_power_date();
  void set_allocated_first_power_date(std::string* first_power_date);
  private:
  const std::string& _internal_first_power_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_power_date(const std::string& value);
  std::string* _internal_mutable_first_power_date();
  public:

  // optional string manufacture_date = 3;
  bool has_manufacture_date() const;
  private:
  bool _internal_has_manufacture_date() const;
  public:
  void clear_manufacture_date();
  const std::string& manufacture_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacture_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacture_date();
  PROTOBUF_NODISCARD std::string* release_manufacture_date();
  void set_allocated_manufacture_date(std::string* manufacture_date);
  private:
  const std::string& _internal_manufacture_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacture_date(const std::string& value);
  std::string* _internal_mutable_manufacture_date();
  public:

  // optional string marketing_name = 4;
  bool has_marketing_name() const;
  private:
  bool _internal_has_marketing_name() const;
  public:
  void clear_marketing_name();
  const std::string& marketing_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_marketing_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_marketing_name();
  PROTOBUF_NODISCARD std::string* release_marketing_name();
  void set_allocated_marketing_name(std::string* marketing_name);
  private:
  const std::string& _internal_marketing_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketing_name(const std::string& value);
  std::string* _internal_mutable_marketing_name();
  public:

  // optional string bios_version = 5;
  bool has_bios_version() const;
  private:
  bool _internal_has_bios_version() const;
  public:
  void clear_bios_version();
  const std::string& bios_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bios_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bios_version();
  PROTOBUF_NODISCARD std::string* release_bios_version();
  void set_allocated_bios_version(std::string* bios_version);
  private:
  const std::string& _internal_bios_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bios_version(const std::string& value);
  std::string* _internal_mutable_bios_version();
  public:

  // optional string board_name = 6;
  bool has_board_name() const;
  private:
  bool _internal_has_board_name() const;
  public:
  void clear_board_name();
  const std::string& board_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_board_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_board_name();
  PROTOBUF_NODISCARD std::string* release_board_name();
  void set_allocated_board_name(std::string* board_name);
  private:
  const std::string& _internal_board_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_board_name(const std::string& value);
  std::string* _internal_mutable_board_name();
  public:

  // optional string board_version = 7;
  bool has_board_version() const;
  private:
  bool _internal_has_board_version() const;
  public:
  void clear_board_version();
  const std::string& board_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_board_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_board_version();
  PROTOBUF_NODISCARD std::string* release_board_version();
  void set_allocated_board_version(std::string* board_version);
  private:
  const std::string& _internal_board_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_board_version(const std::string& value);
  std::string* _internal_mutable_board_version();
  public:

  // optional string product_name = 9;
  bool has_product_name() const;
  private:
  bool _internal_has_product_name() const;
  public:
  void clear_product_name();
  const std::string& product_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_name();
  PROTOBUF_NODISCARD std::string* release_product_name();
  void set_allocated_product_name(std::string* product_name);
  private:
  const std::string& _internal_product_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_name(const std::string& value);
  std::string* _internal_mutable_product_name();
  public:

  // optional string vpd_serial_number = 10;
  bool has_vpd_serial_number() const;
  private:
  bool _internal_has_vpd_serial_number() const;
  public:
  void clear_vpd_serial_number();
  const std::string& vpd_serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vpd_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vpd_serial_number();
  PROTOBUF_NODISCARD std::string* release_vpd_serial_number();
  void set_allocated_vpd_serial_number(std::string* vpd_serial_number);
  private:
  const std::string& _internal_vpd_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vpd_serial_number(const std::string& value);
  std::string* _internal_mutable_vpd_serial_number();
  public:

  // optional uint64 chassis_type = 8;
  bool has_chassis_type() const;
  private:
  bool _internal_has_chassis_type() const;
  public:
  void clear_chassis_type();
  uint64_t chassis_type() const;
  void set_chassis_type(uint64_t value);
  private:
  uint64_t _internal_chassis_type() const;
  void _internal_set_chassis_type(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpd_sku_number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_power_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacture_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marketing_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bios_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr board_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr board_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpd_serial_number_;
    uint64_t chassis_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CpuCStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CpuCStateInfo) */ {
 public:
  inline CpuCStateInfo() : CpuCStateInfo(nullptr) {}
  ~CpuCStateInfo() override;
  explicit PROTOBUF_CONSTEXPR CpuCStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CpuCStateInfo(const CpuCStateInfo& from);
  CpuCStateInfo(CpuCStateInfo&& from) noexcept
    : CpuCStateInfo() {
    *this = ::std::move(from);
  }

  inline CpuCStateInfo& operator=(const CpuCStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpuCStateInfo& operator=(CpuCStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CpuCStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CpuCStateInfo* internal_default_instance() {
    return reinterpret_cast<const CpuCStateInfo*>(
               &_CpuCStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CpuCStateInfo& a, CpuCStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CpuCStateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpuCStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CpuCStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CpuCStateInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CpuCStateInfo& from);
  void MergeFrom(const CpuCStateInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CpuCStateInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CpuCStateInfo";
  }
  protected:
  explicit CpuCStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTimeInStateSinceLastBootUsFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 time_in_state_since_last_boot_us = 2;
  bool has_time_in_state_since_last_boot_us() const;
  private:
  bool _internal_has_time_in_state_since_last_boot_us() const;
  public:
  void clear_time_in_state_since_last_boot_us();
  uint64_t time_in_state_since_last_boot_us() const;
  void set_time_in_state_since_last_boot_us(uint64_t value);
  private:
  uint64_t _internal_time_in_state_since_last_boot_us() const;
  void _internal_set_time_in_state_since_last_boot_us(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CpuCStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t time_in_state_since_last_boot_us_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class LogicalCpuInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LogicalCpuInfo) */ {
 public:
  inline LogicalCpuInfo() : LogicalCpuInfo(nullptr) {}
  ~LogicalCpuInfo() override;
  explicit PROTOBUF_CONSTEXPR LogicalCpuInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicalCpuInfo(const LogicalCpuInfo& from);
  LogicalCpuInfo(LogicalCpuInfo&& from) noexcept
    : LogicalCpuInfo() {
    *this = ::std::move(from);
  }

  inline LogicalCpuInfo& operator=(const LogicalCpuInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalCpuInfo& operator=(LogicalCpuInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LogicalCpuInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicalCpuInfo* internal_default_instance() {
    return reinterpret_cast<const LogicalCpuInfo*>(
               &_LogicalCpuInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(LogicalCpuInfo& a, LogicalCpuInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalCpuInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalCpuInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogicalCpuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogicalCpuInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LogicalCpuInfo& from);
  void MergeFrom(const LogicalCpuInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogicalCpuInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LogicalCpuInfo";
  }
  protected:
  explicit LogicalCpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCStatesFieldNumber = 4,
    kScalingMaxFrequencyKhzFieldNumber = 1,
    kScalingCurrentFrequencyKhzFieldNumber = 2,
    kIdleTimeSecondsFieldNumber = 3,
  };
  // repeated .enterprise_management.CpuCStateInfo c_states = 4;
  int c_states_size() const;
  private:
  int _internal_c_states_size() const;
  public:
  void clear_c_states();
  ::enterprise_management::CpuCStateInfo* mutable_c_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo >*
      mutable_c_states();
  private:
  const ::enterprise_management::CpuCStateInfo& _internal_c_states(int index) const;
  ::enterprise_management::CpuCStateInfo* _internal_add_c_states();
  public:
  const ::enterprise_management::CpuCStateInfo& c_states(int index) const;
  ::enterprise_management::CpuCStateInfo* add_c_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo >&
      c_states() const;

  // optional uint32 scaling_max_frequency_khz = 1;
  bool has_scaling_max_frequency_khz() const;
  private:
  bool _internal_has_scaling_max_frequency_khz() const;
  public:
  void clear_scaling_max_frequency_khz();
  uint32_t scaling_max_frequency_khz() const;
  void set_scaling_max_frequency_khz(uint32_t value);
  private:
  uint32_t _internal_scaling_max_frequency_khz() const;
  void _internal_set_scaling_max_frequency_khz(uint32_t value);
  public:

  // optional uint32 scaling_current_frequency_khz = 2;
  bool has_scaling_current_frequency_khz() const;
  private:
  bool _internal_has_scaling_current_frequency_khz() const;
  public:
  void clear_scaling_current_frequency_khz();
  uint32_t scaling_current_frequency_khz() const;
  void set_scaling_current_frequency_khz(uint32_t value);
  private:
  uint32_t _internal_scaling_current_frequency_khz() const;
  void _internal_set_scaling_current_frequency_khz(uint32_t value);
  public:

  // optional uint64 idle_time_seconds = 3;
  bool has_idle_time_seconds() const;
  private:
  bool _internal_has_idle_time_seconds() const;
  public:
  void clear_idle_time_seconds();
  uint64_t idle_time_seconds() const;
  void set_idle_time_seconds(uint64_t value);
  private:
  uint64_t _internal_idle_time_seconds() const;
  void _internal_set_idle_time_seconds(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LogicalCpuInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo > c_states_;
    uint32_t scaling_max_frequency_khz_;
    uint32_t scaling_current_frequency_khz_;
    uint64_t idle_time_seconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CpuInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CpuInfo) */ {
 public:
  inline CpuInfo() : CpuInfo(nullptr) {}
  ~CpuInfo() override;
  explicit PROTOBUF_CONSTEXPR CpuInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CpuInfo(const CpuInfo& from);
  CpuInfo(CpuInfo&& from) noexcept
    : CpuInfo() {
    *this = ::std::move(from);
  }

  inline CpuInfo& operator=(const CpuInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpuInfo& operator=(CpuInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CpuInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CpuInfo* internal_default_instance() {
    return reinterpret_cast<const CpuInfo*>(
               &_CpuInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CpuInfo& a, CpuInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CpuInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpuInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CpuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CpuInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CpuInfo& from);
  void MergeFrom(const CpuInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CpuInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CpuInfo";
  }
  protected:
  explicit CpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CpuInfo_Architecture Architecture;
  static constexpr Architecture ARCHITECTURE_UNSPECIFIED =
    CpuInfo_Architecture_ARCHITECTURE_UNSPECIFIED;
  static constexpr Architecture X86_64 =
    CpuInfo_Architecture_X86_64;
  static constexpr Architecture AARCH64 =
    CpuInfo_Architecture_AARCH64;
  static constexpr Architecture ARMV7L =
    CpuInfo_Architecture_ARMV7L;
  static inline bool Architecture_IsValid(int value) {
    return CpuInfo_Architecture_IsValid(value);
  }
  static constexpr Architecture Architecture_MIN =
    CpuInfo_Architecture_Architecture_MIN;
  static constexpr Architecture Architecture_MAX =
    CpuInfo_Architecture_Architecture_MAX;
  static constexpr int Architecture_ARRAYSIZE =
    CpuInfo_Architecture_Architecture_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Architecture_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Architecture>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Architecture_Name.");
    return CpuInfo_Architecture_Name(enum_t_value);
  }
  static inline bool Architecture_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Architecture* value) {
    return CpuInfo_Architecture_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalCpusFieldNumber = 4,
    kModelNameFieldNumber = 1,
    kArchitectureFieldNumber = 2,
    kMaxClockSpeedKhzFieldNumber = 3,
  };
  // repeated .enterprise_management.LogicalCpuInfo logical_cpus = 4;
  int logical_cpus_size() const;
  private:
  int _internal_logical_cpus_size() const;
  public:
  void clear_logical_cpus();
  ::enterprise_management::LogicalCpuInfo* mutable_logical_cpus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo >*
      mutable_logical_cpus();
  private:
  const ::enterprise_management::LogicalCpuInfo& _internal_logical_cpus(int index) const;
  ::enterprise_management::LogicalCpuInfo* _internal_add_logical_cpus();
  public:
  const ::enterprise_management::LogicalCpuInfo& logical_cpus(int index) const;
  ::enterprise_management::LogicalCpuInfo* add_logical_cpus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo >&
      logical_cpus() const;

  // optional string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // optional .enterprise_management.CpuInfo.Architecture architecture = 2;
  bool has_architecture() const;
  private:
  bool _internal_has_architecture() const;
  public:
  void clear_architecture();
  ::enterprise_management::CpuInfo_Architecture architecture() const;
  void set_architecture(::enterprise_management::CpuInfo_Architecture value);
  private:
  ::enterprise_management::CpuInfo_Architecture _internal_architecture() const;
  void _internal_set_architecture(::enterprise_management::CpuInfo_Architecture value);
  public:

  // optional uint32 max_clock_speed_khz = 3;
  bool has_max_clock_speed_khz() const;
  private:
  bool _internal_has_max_clock_speed_khz() const;
  public:
  void clear_max_clock_speed_khz();
  uint32_t max_clock_speed_khz() const;
  void set_max_clock_speed_khz(uint32_t value);
  private:
  uint32_t _internal_max_clock_speed_khz() const;
  void _internal_set_max_clock_speed_khz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CpuInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo > logical_cpus_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    int architecture_;
    uint32_t max_clock_speed_khz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class GlobalCpuInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GlobalCpuInfo) */ {
 public:
  inline GlobalCpuInfo() : GlobalCpuInfo(nullptr) {}
  ~GlobalCpuInfo() override;
  explicit PROTOBUF_CONSTEXPR GlobalCpuInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalCpuInfo(const GlobalCpuInfo& from);
  GlobalCpuInfo(GlobalCpuInfo&& from) noexcept
    : GlobalCpuInfo() {
    *this = ::std::move(from);
  }

  inline GlobalCpuInfo& operator=(const GlobalCpuInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalCpuInfo& operator=(GlobalCpuInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GlobalCpuInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalCpuInfo* internal_default_instance() {
    return reinterpret_cast<const GlobalCpuInfo*>(
               &_GlobalCpuInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GlobalCpuInfo& a, GlobalCpuInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalCpuInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalCpuInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalCpuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalCpuInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GlobalCpuInfo& from);
  void MergeFrom(const GlobalCpuInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GlobalCpuInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.GlobalCpuInfo";
  }
  protected:
  explicit GlobalCpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumTotalThreadsFieldNumber = 1,
  };
  // optional uint32 num_total_threads = 1;
  bool has_num_total_threads() const;
  private:
  bool _internal_has_num_total_threads() const;
  public:
  void clear_num_total_threads();
  uint32_t num_total_threads() const;
  void set_num_total_threads(uint32_t value);
  private:
  uint32_t _internal_num_total_threads() const;
  void _internal_set_num_total_threads(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.GlobalCpuInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t num_total_threads_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DisplayInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DisplayInfo) */ {
 public:
  inline DisplayInfo() : DisplayInfo(nullptr) {}
  ~DisplayInfo() override;
  explicit PROTOBUF_CONSTEXPR DisplayInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisplayInfo(const DisplayInfo& from);
  DisplayInfo(DisplayInfo&& from) noexcept
    : DisplayInfo() {
    *this = ::std::move(from);
  }

  inline DisplayInfo& operator=(const DisplayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisplayInfo& operator=(DisplayInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisplayInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisplayInfo* internal_default_instance() {
    return reinterpret_cast<const DisplayInfo*>(
               &_DisplayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(DisplayInfo& a, DisplayInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DisplayInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisplayInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisplayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisplayInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DisplayInfo& from);
  void MergeFrom(const DisplayInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisplayInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DisplayInfo";
  }
  protected:
  explicit DisplayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResolutionWidthFieldNumber = 1,
    kResolutionHeightFieldNumber = 2,
    kRefreshRateFieldNumber = 3,
    kIsInternalFieldNumber = 4,
  };
  // optional uint32 resolution_width = 1;
  bool has_resolution_width() const;
  private:
  bool _internal_has_resolution_width() const;
  public:
  void clear_resolution_width();
  uint32_t resolution_width() const;
  void set_resolution_width(uint32_t value);
  private:
  uint32_t _internal_resolution_width() const;
  void _internal_set_resolution_width(uint32_t value);
  public:

  // optional uint32 resolution_height = 2;
  bool has_resolution_height() const;
  private:
  bool _internal_has_resolution_height() const;
  public:
  void clear_resolution_height();
  uint32_t resolution_height() const;
  void set_resolution_height(uint32_t value);
  private:
  uint32_t _internal_resolution_height() const;
  void _internal_set_resolution_height(uint32_t value);
  public:

  // optional uint32 refresh_rate = 3;
  bool has_refresh_rate() const;
  private:
  bool _internal_has_refresh_rate() const;
  public:
  void clear_refresh_rate();
  uint32_t refresh_rate() const;
  void set_refresh_rate(uint32_t value);
  private:
  uint32_t _internal_refresh_rate() const;
  void _internal_set_refresh_rate(uint32_t value);
  public:

  // optional bool is_internal = 4;
  bool has_is_internal() const;
  private:
  bool _internal_has_is_internal() const;
  public:
  void clear_is_internal();
  bool is_internal() const;
  void set_is_internal(bool value);
  private:
  bool _internal_is_internal() const;
  void _internal_set_is_internal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DisplayInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t resolution_width_;
    uint32_t resolution_height_;
    uint32_t refresh_rate_;
    bool is_internal_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class GraphicsAdapterInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GraphicsAdapterInfo) */ {
 public:
  inline GraphicsAdapterInfo() : GraphicsAdapterInfo(nullptr) {}
  ~GraphicsAdapterInfo() override;
  explicit PROTOBUF_CONSTEXPR GraphicsAdapterInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicsAdapterInfo(const GraphicsAdapterInfo& from);
  GraphicsAdapterInfo(GraphicsAdapterInfo&& from) noexcept
    : GraphicsAdapterInfo() {
    *this = ::std::move(from);
  }

  inline GraphicsAdapterInfo& operator=(const GraphicsAdapterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicsAdapterInfo& operator=(GraphicsAdapterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GraphicsAdapterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicsAdapterInfo* internal_default_instance() {
    return reinterpret_cast<const GraphicsAdapterInfo*>(
               &_GraphicsAdapterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(GraphicsAdapterInfo& a, GraphicsAdapterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicsAdapterInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicsAdapterInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicsAdapterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicsAdapterInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GraphicsAdapterInfo& from);
  void MergeFrom(const GraphicsAdapterInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GraphicsAdapterInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.GraphicsAdapterInfo";
  }
  protected:
  explicit GraphicsAdapterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDriverVersionFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kSystemRamUsageFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string driver_version = 2;
  bool has_driver_version() const;
  private:
  bool _internal_has_driver_version() const;
  public:
  void clear_driver_version();
  const std::string& driver_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_version();
  PROTOBUF_NODISCARD std::string* release_driver_version();
  void set_allocated_driver_version(std::string* driver_version);
  private:
  const std::string& _internal_driver_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_version(const std::string& value);
  std::string* _internal_mutable_driver_version();
  public:

  // optional uint64 device_id = 3;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  uint64_t device_id() const;
  void set_device_id(uint64_t value);
  private:
  uint64_t _internal_device_id() const;
  void _internal_set_device_id(uint64_t value);
  public:

  // optional uint64 system_ram_usage = 4;
  bool has_system_ram_usage() const;
  private:
  bool _internal_has_system_ram_usage() const;
  public:
  void clear_system_ram_usage();
  uint64_t system_ram_usage() const;
  void set_system_ram_usage(uint64_t value);
  private:
  uint64_t _internal_system_ram_usage() const;
  void _internal_set_system_ram_usage(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.GraphicsAdapterInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_version_;
    uint64_t device_id_;
    uint64_t system_ram_usage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class GraphicsStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GraphicsStatus) */ {
 public:
  inline GraphicsStatus() : GraphicsStatus(nullptr) {}
  ~GraphicsStatus() override;
  explicit PROTOBUF_CONSTEXPR GraphicsStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphicsStatus(const GraphicsStatus& from);
  GraphicsStatus(GraphicsStatus&& from) noexcept
    : GraphicsStatus() {
    *this = ::std::move(from);
  }

  inline GraphicsStatus& operator=(const GraphicsStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphicsStatus& operator=(GraphicsStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GraphicsStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphicsStatus* internal_default_instance() {
    return reinterpret_cast<const GraphicsStatus*>(
               &_GraphicsStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(GraphicsStatus& a, GraphicsStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphicsStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphicsStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphicsStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphicsStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GraphicsStatus& from);
  void MergeFrom(const GraphicsStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GraphicsStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.GraphicsStatus";
  }
  protected:
  explicit GraphicsStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplaysFieldNumber = 2,
    kAdapterFieldNumber = 1,
  };
  // repeated .enterprise_management.DisplayInfo displays = 2;
  int displays_size() const;
  private:
  int _internal_displays_size() const;
  public:
  void clear_displays();
  ::enterprise_management::DisplayInfo* mutable_displays(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo >*
      mutable_displays();
  private:
  const ::enterprise_management::DisplayInfo& _internal_displays(int index) const;
  ::enterprise_management::DisplayInfo* _internal_add_displays();
  public:
  const ::enterprise_management::DisplayInfo& displays(int index) const;
  ::enterprise_management::DisplayInfo* add_displays();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo >&
      displays() const;

  // optional .enterprise_management.GraphicsAdapterInfo adapter = 1;
  bool has_adapter() const;
  private:
  bool _internal_has_adapter() const;
  public:
  void clear_adapter();
  const ::enterprise_management::GraphicsAdapterInfo& adapter() const;
  PROTOBUF_NODISCARD ::enterprise_management::GraphicsAdapterInfo* release_adapter();
  ::enterprise_management::GraphicsAdapterInfo* mutable_adapter();
  void set_allocated_adapter(::enterprise_management::GraphicsAdapterInfo* adapter);
  private:
  const ::enterprise_management::GraphicsAdapterInfo& _internal_adapter() const;
  ::enterprise_management::GraphicsAdapterInfo* _internal_mutable_adapter();
  public:
  void unsafe_arena_set_allocated_adapter(
      ::enterprise_management::GraphicsAdapterInfo* adapter);
  ::enterprise_management::GraphicsAdapterInfo* unsafe_arena_release_adapter();

  // @@protoc_insertion_point(class_scope:enterprise_management.GraphicsStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo > displays_;
    ::enterprise_management::GraphicsAdapterInfo* adapter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CrashReportInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CrashReportInfo) */ {
 public:
  inline CrashReportInfo() : CrashReportInfo(nullptr) {}
  ~CrashReportInfo() override;
  explicit PROTOBUF_CONSTEXPR CrashReportInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrashReportInfo(const CrashReportInfo& from);
  CrashReportInfo(CrashReportInfo&& from) noexcept
    : CrashReportInfo() {
    *this = ::std::move(from);
  }

  inline CrashReportInfo& operator=(const CrashReportInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrashReportInfo& operator=(CrashReportInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CrashReportInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrashReportInfo* internal_default_instance() {
    return reinterpret_cast<const CrashReportInfo*>(
               &_CrashReportInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CrashReportInfo& a, CrashReportInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CrashReportInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrashReportInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrashReportInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrashReportInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CrashReportInfo& from);
  void MergeFrom(const CrashReportInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CrashReportInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CrashReportInfo";
  }
  protected:
  explicit CrashReportInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CrashReportInfo_CrashReportUploadStatus CrashReportUploadStatus;
  static constexpr CrashReportUploadStatus UPLOAD_STATUS_UNKNOWN =
    CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UNKNOWN;
  static constexpr CrashReportUploadStatus UPLOAD_STATUS_NOT_UPLOADED =
    CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_NOT_UPLOADED;
  static constexpr CrashReportUploadStatus UPLOAD_STATUS_PENDING =
    CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_PENDING;
  static constexpr CrashReportUploadStatus UPLOAD_STATUS_PENDING_USER_REQUESTED =
    CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_PENDING_USER_REQUESTED;
  static constexpr CrashReportUploadStatus UPLOAD_STATUS_UPLOADED =
    CrashReportInfo_CrashReportUploadStatus_UPLOAD_STATUS_UPLOADED;
  static inline bool CrashReportUploadStatus_IsValid(int value) {
    return CrashReportInfo_CrashReportUploadStatus_IsValid(value);
  }
  static constexpr CrashReportUploadStatus CrashReportUploadStatus_MIN =
    CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MIN;
  static constexpr CrashReportUploadStatus CrashReportUploadStatus_MAX =
    CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_MAX;
  static constexpr int CrashReportUploadStatus_ARRAYSIZE =
    CrashReportInfo_CrashReportUploadStatus_CrashReportUploadStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CrashReportUploadStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CrashReportUploadStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CrashReportUploadStatus_Name.");
    return CrashReportInfo_CrashReportUploadStatus_Name(enum_t_value);
  }
  static inline bool CrashReportUploadStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CrashReportUploadStatus* value) {
    return CrashReportInfo_CrashReportUploadStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteIdFieldNumber = 1,
    kCauseFieldNumber = 3,
    kCaptureTimestampFieldNumber = 2,
    kUploadStatusFieldNumber = 4,
  };
  // optional string remote_id = 1;
  bool has_remote_id() const;
  private:
  bool _internal_has_remote_id() const;
  public:
  void clear_remote_id();
  const std::string& remote_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_id();
  PROTOBUF_NODISCARD std::string* release_remote_id();
  void set_allocated_remote_id(std::string* remote_id);
  private:
  const std::string& _internal_remote_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_id(const std::string& value);
  std::string* _internal_mutable_remote_id();
  public:

  // optional string cause = 3;
  bool has_cause() const;
  private:
  bool _internal_has_cause() const;
  public:
  void clear_cause();
  const std::string& cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cause();
  PROTOBUF_NODISCARD std::string* release_cause();
  void set_allocated_cause(std::string* cause);
  private:
  const std::string& _internal_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cause(const std::string& value);
  std::string* _internal_mutable_cause();
  public:

  // optional int64 capture_timestamp = 2;
  bool has_capture_timestamp() const;
  private:
  bool _internal_has_capture_timestamp() const;
  public:
  void clear_capture_timestamp();
  int64_t capture_timestamp() const;
  void set_capture_timestamp(int64_t value);
  private:
  int64_t _internal_capture_timestamp() const;
  void _internal_set_capture_timestamp(int64_t value);
  public:

  // optional .enterprise_management.CrashReportInfo.CrashReportUploadStatus upload_status = 4;
  bool has_upload_status() const;
  private:
  bool _internal_has_upload_status() const;
  public:
  void clear_upload_status();
  ::enterprise_management::CrashReportInfo_CrashReportUploadStatus upload_status() const;
  void set_upload_status(::enterprise_management::CrashReportInfo_CrashReportUploadStatus value);
  private:
  ::enterprise_management::CrashReportInfo_CrashReportUploadStatus _internal_upload_status() const;
  void _internal_set_upload_status(::enterprise_management::CrashReportInfo_CrashReportUploadStatus value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CrashReportInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cause_;
    int64_t capture_timestamp_;
    int upload_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class TimezoneInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TimezoneInfo) */ {
 public:
  inline TimezoneInfo() : TimezoneInfo(nullptr) {}
  ~TimezoneInfo() override;
  explicit PROTOBUF_CONSTEXPR TimezoneInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimezoneInfo(const TimezoneInfo& from);
  TimezoneInfo(TimezoneInfo&& from) noexcept
    : TimezoneInfo() {
    *this = ::std::move(from);
  }

  inline TimezoneInfo& operator=(const TimezoneInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimezoneInfo& operator=(TimezoneInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimezoneInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimezoneInfo* internal_default_instance() {
    return reinterpret_cast<const TimezoneInfo*>(
               &_TimezoneInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(TimezoneInfo& a, TimezoneInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TimezoneInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimezoneInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimezoneInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimezoneInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimezoneInfo& from);
  void MergeFrom(const TimezoneInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimezoneInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.TimezoneInfo";
  }
  protected:
  explicit TimezoneInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosixFieldNumber = 1,
    kRegionFieldNumber = 2,
  };
  // optional string posix = 1;
  bool has_posix() const;
  private:
  bool _internal_has_posix() const;
  public:
  void clear_posix();
  const std::string& posix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_posix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_posix();
  PROTOBUF_NODISCARD std::string* release_posix();
  void set_allocated_posix(std::string* posix);
  private:
  const std::string& _internal_posix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_posix(const std::string& value);
  std::string* _internal_mutable_posix();
  public:

  // optional string region = 2;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.TimezoneInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr posix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class MemoryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.MemoryInfo) */ {
 public:
  inline MemoryInfo() : MemoryInfo(nullptr) {}
  ~MemoryInfo() override;
  explicit PROTOBUF_CONSTEXPR MemoryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemoryInfo(const MemoryInfo& from);
  MemoryInfo(MemoryInfo&& from) noexcept
    : MemoryInfo() {
    *this = ::std::move(from);
  }

  inline MemoryInfo& operator=(const MemoryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryInfo& operator=(MemoryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MemoryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoryInfo* internal_default_instance() {
    return reinterpret_cast<const MemoryInfo*>(
               &_MemoryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(MemoryInfo& a, MemoryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoryInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MemoryInfo& from);
  void MergeFrom(const MemoryInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.MemoryInfo";
  }
  protected:
  explicit MemoryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalMemoryKibFieldNumber = 1,
    kFreeMemoryKibFieldNumber = 2,
    kPageFaultsSinceLastBootFieldNumber = 4,
    kAvailableMemoryKibFieldNumber = 3,
  };
  // optional uint32 total_memory_kib = 1;
  bool has_total_memory_kib() const;
  private:
  bool _internal_has_total_memory_kib() const;
  public:
  void clear_total_memory_kib();
  uint32_t total_memory_kib() const;
  void set_total_memory_kib(uint32_t value);
  private:
  uint32_t _internal_total_memory_kib() const;
  void _internal_set_total_memory_kib(uint32_t value);
  public:

  // optional uint32 free_memory_kib = 2;
  bool has_free_memory_kib() const;
  private:
  bool _internal_has_free_memory_kib() const;
  public:
  void clear_free_memory_kib();
  uint32_t free_memory_kib() const;
  void set_free_memory_kib(uint32_t value);
  private:
  uint32_t _internal_free_memory_kib() const;
  void _internal_set_free_memory_kib(uint32_t value);
  public:

  // optional uint64 page_faults_since_last_boot = 4;
  bool has_page_faults_since_last_boot() const;
  private:
  bool _internal_has_page_faults_since_last_boot() const;
  public:
  void clear_page_faults_since_last_boot();
  uint64_t page_faults_since_last_boot() const;
  void set_page_faults_since_last_boot(uint64_t value);
  private:
  uint64_t _internal_page_faults_since_last_boot() const;
  void _internal_set_page_faults_since_last_boot(uint64_t value);
  public:

  // optional uint32 available_memory_kib = 3;
  bool has_available_memory_kib() const;
  private:
  bool _internal_has_available_memory_kib() const;
  public:
  void clear_available_memory_kib();
  uint32_t available_memory_kib() const;
  void set_available_memory_kib(uint32_t value);
  private:
  uint32_t _internal_available_memory_kib() const;
  void _internal_set_available_memory_kib(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.MemoryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t total_memory_kib_;
    uint32_t free_memory_kib_;
    uint64_t page_faults_since_last_boot_;
    uint32_t available_memory_kib_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BacklightInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BacklightInfo) */ {
 public:
  inline BacklightInfo() : BacklightInfo(nullptr) {}
  ~BacklightInfo() override;
  explicit PROTOBUF_CONSTEXPR BacklightInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BacklightInfo(const BacklightInfo& from);
  BacklightInfo(BacklightInfo&& from) noexcept
    : BacklightInfo() {
    *this = ::std::move(from);
  }

  inline BacklightInfo& operator=(const BacklightInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BacklightInfo& operator=(BacklightInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BacklightInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BacklightInfo* internal_default_instance() {
    return reinterpret_cast<const BacklightInfo*>(
               &_BacklightInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(BacklightInfo& a, BacklightInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BacklightInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BacklightInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BacklightInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BacklightInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BacklightInfo& from);
  void MergeFrom(const BacklightInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BacklightInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BacklightInfo";
  }
  protected:
  explicit BacklightInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kMaxBrightnessFieldNumber = 2,
    kBrightnessFieldNumber = 3,
  };
  // optional string path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional uint32 max_brightness = 2;
  bool has_max_brightness() const;
  private:
  bool _internal_has_max_brightness() const;
  public:
  void clear_max_brightness();
  uint32_t max_brightness() const;
  void set_max_brightness(uint32_t value);
  private:
  uint32_t _internal_max_brightness() const;
  void _internal_set_max_brightness(uint32_t value);
  public:

  // optional uint32 brightness = 3;
  bool has_brightness() const;
  private:
  bool _internal_has_brightness() const;
  public:
  void clear_brightness();
  uint32_t brightness() const;
  void set_brightness(uint32_t value);
  private:
  uint32_t _internal_brightness() const;
  void _internal_set_brightness(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BacklightInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    uint32_t max_brightness_;
    uint32_t brightness_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class FanInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.FanInfo) */ {
 public:
  inline FanInfo() : FanInfo(nullptr) {}
  ~FanInfo() override;
  explicit PROTOBUF_CONSTEXPR FanInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FanInfo(const FanInfo& from);
  FanInfo(FanInfo&& from) noexcept
    : FanInfo() {
    *this = ::std::move(from);
  }

  inline FanInfo& operator=(const FanInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FanInfo& operator=(FanInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FanInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FanInfo* internal_default_instance() {
    return reinterpret_cast<const FanInfo*>(
               &_FanInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(FanInfo& a, FanInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FanInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FanInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FanInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FanInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FanInfo& from);
  void MergeFrom(const FanInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FanInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.FanInfo";
  }
  protected:
  explicit FanInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedRpmFieldNumber = 1,
  };
  // optional uint32 speed_rpm = 1;
  bool has_speed_rpm() const;
  private:
  bool _internal_has_speed_rpm() const;
  public:
  void clear_speed_rpm();
  uint32_t speed_rpm() const;
  void set_speed_rpm(uint32_t value);
  private:
  uint32_t _internal_speed_rpm() const;
  void _internal_set_speed_rpm(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.FanInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t speed_rpm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BluetoothAdapterInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BluetoothAdapterInfo) */ {
 public:
  inline BluetoothAdapterInfo() : BluetoothAdapterInfo(nullptr) {}
  ~BluetoothAdapterInfo() override;
  explicit PROTOBUF_CONSTEXPR BluetoothAdapterInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BluetoothAdapterInfo(const BluetoothAdapterInfo& from);
  BluetoothAdapterInfo(BluetoothAdapterInfo&& from) noexcept
    : BluetoothAdapterInfo() {
    *this = ::std::move(from);
  }

  inline BluetoothAdapterInfo& operator=(const BluetoothAdapterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothAdapterInfo& operator=(BluetoothAdapterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BluetoothAdapterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BluetoothAdapterInfo* internal_default_instance() {
    return reinterpret_cast<const BluetoothAdapterInfo*>(
               &_BluetoothAdapterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(BluetoothAdapterInfo& a, BluetoothAdapterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothAdapterInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothAdapterInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BluetoothAdapterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BluetoothAdapterInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BluetoothAdapterInfo& from);
  void MergeFrom(const BluetoothAdapterInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BluetoothAdapterInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BluetoothAdapterInfo";
  }
  protected:
  explicit BluetoothAdapterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
    kPoweredFieldNumber = 3,
    kNumConnectedDevicesFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string address = 2;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional bool powered = 3;
  bool has_powered() const;
  private:
  bool _internal_has_powered() const;
  public:
  void clear_powered();
  bool powered() const;
  void set_powered(bool value);
  private:
  bool _internal_powered() const;
  void _internal_set_powered(bool value);
  public:

  // optional uint32 num_connected_devices = 4;
  bool has_num_connected_devices() const;
  private:
  bool _internal_has_num_connected_devices() const;
  public:
  void clear_num_connected_devices();
  uint32_t num_connected_devices() const;
  void set_num_connected_devices(uint32_t value);
  private:
  uint32_t _internal_num_connected_devices() const;
  void _internal_set_num_connected_devices(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BluetoothAdapterInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    bool powered_;
    uint32_t num_connected_devices_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class SmbiosInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SmbiosInfo) */ {
 public:
  inline SmbiosInfo() : SmbiosInfo(nullptr) {}
  ~SmbiosInfo() override;
  explicit PROTOBUF_CONSTEXPR SmbiosInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmbiosInfo(const SmbiosInfo& from);
  SmbiosInfo(SmbiosInfo&& from) noexcept
    : SmbiosInfo() {
    *this = ::std::move(from);
  }

  inline SmbiosInfo& operator=(const SmbiosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmbiosInfo& operator=(SmbiosInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SmbiosInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmbiosInfo* internal_default_instance() {
    return reinterpret_cast<const SmbiosInfo*>(
               &_SmbiosInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(SmbiosInfo& a, SmbiosInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SmbiosInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmbiosInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmbiosInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmbiosInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SmbiosInfo& from);
  void MergeFrom(const SmbiosInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SmbiosInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SmbiosInfo";
  }
  protected:
  explicit SmbiosInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSysVendorFieldNumber = 1,
    kProductNameFieldNumber = 2,
    kProductVersionFieldNumber = 3,
    kBiosVersionFieldNumber = 4,
  };
  // optional string sys_vendor = 1;
  bool has_sys_vendor() const;
  private:
  bool _internal_has_sys_vendor() const;
  public:
  void clear_sys_vendor();
  const std::string& sys_vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sys_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sys_vendor();
  PROTOBUF_NODISCARD std::string* release_sys_vendor();
  void set_allocated_sys_vendor(std::string* sys_vendor);
  private:
  const std::string& _internal_sys_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sys_vendor(const std::string& value);
  std::string* _internal_mutable_sys_vendor();
  public:

  // optional string product_name = 2;
  bool has_product_name() const;
  private:
  bool _internal_has_product_name() const;
  public:
  void clear_product_name();
  const std::string& product_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_name();
  PROTOBUF_NODISCARD std::string* release_product_name();
  void set_allocated_product_name(std::string* product_name);
  private:
  const std::string& _internal_product_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_name(const std::string& value);
  std::string* _internal_mutable_product_name();
  public:

  // optional string product_version = 3;
  bool has_product_version() const;
  private:
  bool _internal_has_product_version() const;
  public:
  void clear_product_version();
  const std::string& product_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_version();
  PROTOBUF_NODISCARD std::string* release_product_version();
  void set_allocated_product_version(std::string* product_version);
  private:
  const std::string& _internal_product_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_version(const std::string& value);
  std::string* _internal_mutable_product_version();
  public:

  // optional string bios_version = 4;
  bool has_bios_version() const;
  private:
  bool _internal_has_bios_version() const;
  public:
  void clear_bios_version();
  const std::string& bios_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bios_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bios_version();
  PROTOBUF_NODISCARD std::string* release_bios_version();
  void set_allocated_bios_version(std::string* bios_version);
  private:
  const std::string& _internal_bios_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bios_version(const std::string& value);
  std::string* _internal_mutable_bios_version();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SmbiosInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sys_vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bios_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class KernelParameters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.KernelParameters) */ {
 public:
  inline KernelParameters() : KernelParameters(nullptr) {}
  ~KernelParameters() override;
  explicit PROTOBUF_CONSTEXPR KernelParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KernelParameters(const KernelParameters& from);
  KernelParameters(KernelParameters&& from) noexcept
    : KernelParameters() {
    *this = ::std::move(from);
  }

  inline KernelParameters& operator=(const KernelParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline KernelParameters& operator=(KernelParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KernelParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const KernelParameters* internal_default_instance() {
    return reinterpret_cast<const KernelParameters*>(
               &_KernelParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(KernelParameters& a, KernelParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(KernelParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KernelParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KernelParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KernelParameters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KernelParameters& from);
  void MergeFrom(const KernelParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KernelParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.KernelParameters";
  }
  protected:
  explicit KernelParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrosEfiFieldNumber = 1,
  };
  // optional bool cros_efi = 1;
  bool has_cros_efi() const;
  private:
  bool _internal_has_cros_efi() const;
  public:
  void clear_cros_efi();
  bool cros_efi() const;
  void set_cros_efi(bool value);
  private:
  bool _internal_cros_efi() const;
  void _internal_set_cros_efi(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.KernelParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool cros_efi_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class EFIVars final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.EFIVars) */ {
 public:
  inline EFIVars() : EFIVars(nullptr) {}
  ~EFIVars() override;
  explicit PROTOBUF_CONSTEXPR EFIVars(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EFIVars(const EFIVars& from);
  EFIVars(EFIVars&& from) noexcept
    : EFIVars() {
    *this = ::std::move(from);
  }

  inline EFIVars& operator=(const EFIVars& from) {
    CopyFrom(from);
    return *this;
  }
  inline EFIVars& operator=(EFIVars&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EFIVars& default_instance() {
    return *internal_default_instance();
  }
  static inline const EFIVars* internal_default_instance() {
    return reinterpret_cast<const EFIVars*>(
               &_EFIVars_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(EFIVars& a, EFIVars& b) {
    a.Swap(&b);
  }
  inline void Swap(EFIVars* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EFIVars* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EFIVars* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EFIVars>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EFIVars& from);
  void MergeFrom(const EFIVars& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EFIVars* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.EFIVars";
  }
  protected:
  explicit EFIVars(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecureBootFieldNumber = 1,
  };
  // optional bool secure_boot = 1;
  bool has_secure_boot() const;
  private:
  bool _internal_has_secure_boot() const;
  public:
  void clear_secure_boot();
  bool secure_boot() const;
  void set_secure_boot(bool value);
  private:
  bool _internal_secure_boot() const;
  void _internal_set_secure_boot(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.EFIVars)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool secure_boot_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BootInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BootInfo) */ {
 public:
  inline BootInfo() : BootInfo(nullptr) {}
  ~BootInfo() override;
  explicit PROTOBUF_CONSTEXPR BootInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BootInfo(const BootInfo& from);
  BootInfo(BootInfo&& from) noexcept
    : BootInfo() {
    *this = ::std::move(from);
  }

  inline BootInfo& operator=(const BootInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BootInfo& operator=(BootInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BootInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BootInfo* internal_default_instance() {
    return reinterpret_cast<const BootInfo*>(
               &_BootInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(BootInfo& a, BootInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BootInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BootInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BootInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BootInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BootInfo& from);
  void MergeFrom(const BootInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BootInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BootInfo";
  }
  protected:
  explicit BootInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BootInfo_BootMethod BootMethod;
  static constexpr BootMethod UNKNOWN =
    BootInfo_BootMethod_UNKNOWN;
  static constexpr BootMethod CROS_SECURE =
    BootInfo_BootMethod_CROS_SECURE;
  static constexpr BootMethod CROS_UEFI =
    BootInfo_BootMethod_CROS_UEFI;
  static constexpr BootMethod CROS_LEGACY =
    BootInfo_BootMethod_CROS_LEGACY;
  static constexpr BootMethod CROS_EFI_SECURE =
    BootInfo_BootMethod_CROS_EFI_SECURE;
  static inline bool BootMethod_IsValid(int value) {
    return BootInfo_BootMethod_IsValid(value);
  }
  static constexpr BootMethod BootMethod_MIN =
    BootInfo_BootMethod_BootMethod_MIN;
  static constexpr BootMethod BootMethod_MAX =
    BootInfo_BootMethod_BootMethod_MAX;
  static constexpr int BootMethod_ARRAYSIZE =
    BootInfo_BootMethod_BootMethod_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BootMethod_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BootMethod>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BootMethod_Name.");
    return BootInfo_BootMethod_Name(enum_t_value);
  }
  static inline bool BootMethod_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BootMethod* value) {
    return BootInfo_BootMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBootMethodFieldNumber = 1,
    kSecureBootFieldNumber = 2,
  };
  // optional .enterprise_management.BootInfo.BootMethod boot_method = 1;
  bool has_boot_method() const;
  private:
  bool _internal_has_boot_method() const;
  public:
  void clear_boot_method();
  ::enterprise_management::BootInfo_BootMethod boot_method() const;
  void set_boot_method(::enterprise_management::BootInfo_BootMethod value);
  private:
  ::enterprise_management::BootInfo_BootMethod _internal_boot_method() const;
  void _internal_set_boot_method(::enterprise_management::BootInfo_BootMethod value);
  public:

  // optional bool secure_boot = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_secure_boot() const;
  private:
  bool _internal_has_secure_boot() const;
  public:
  PROTOBUF_DEPRECATED void clear_secure_boot();
  PROTOBUF_DEPRECATED bool secure_boot() const;
  PROTOBUF_DEPRECATED void set_secure_boot(bool value);
  private:
  bool _internal_secure_boot() const;
  void _internal_set_secure_boot(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BootInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int boot_method_;
    bool secure_boot_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class NetworkAdapterInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.NetworkAdapterInfo) */ {
 public:
  inline NetworkAdapterInfo() : NetworkAdapterInfo(nullptr) {}
  ~NetworkAdapterInfo() override;
  explicit PROTOBUF_CONSTEXPR NetworkAdapterInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkAdapterInfo(const NetworkAdapterInfo& from);
  NetworkAdapterInfo(NetworkAdapterInfo&& from) noexcept
    : NetworkAdapterInfo() {
    *this = ::std::move(from);
  }

  inline NetworkAdapterInfo& operator=(const NetworkAdapterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkAdapterInfo& operator=(NetworkAdapterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NetworkAdapterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkAdapterInfo* internal_default_instance() {
    return reinterpret_cast<const NetworkAdapterInfo*>(
               &_NetworkAdapterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(NetworkAdapterInfo& a, NetworkAdapterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkAdapterInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkAdapterInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkAdapterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkAdapterInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkAdapterInfo& from);
  void MergeFrom(const NetworkAdapterInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkAdapterInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.NetworkAdapterInfo";
  }
  protected:
  explicit NetworkAdapterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriverFieldNumber = 7,
    kVendorNameFieldNumber = 4,
    kDeviceNameFieldNumber = 6,
    kDeviceClassFieldNumber = 1,
    kBusTypeFieldNumber = 2,
    kVendorIdFieldNumber = 3,
    kDeviceIdFieldNumber = 5,
  };
  // repeated string driver = 7;
  int driver_size() const;
  private:
  int _internal_driver_size() const;
  public:
  void clear_driver();
  const std::string& driver(int index) const;
  std::string* mutable_driver(int index);
  void set_driver(int index, const std::string& value);
  void set_driver(int index, std::string&& value);
  void set_driver(int index, const char* value);
  void set_driver(int index, const char* value, size_t size);
  std::string* add_driver();
  void add_driver(const std::string& value);
  void add_driver(std::string&& value);
  void add_driver(const char* value);
  void add_driver(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& driver() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_driver();
  private:
  const std::string& _internal_driver(int index) const;
  std::string* _internal_add_driver();
  public:

  // optional string vendor_name = 4;
  bool has_vendor_name() const;
  private:
  bool _internal_has_vendor_name() const;
  public:
  void clear_vendor_name();
  const std::string& vendor_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor_name();
  PROTOBUF_NODISCARD std::string* release_vendor_name();
  void set_allocated_vendor_name(std::string* vendor_name);
  private:
  const std::string& _internal_vendor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_name(const std::string& value);
  std::string* _internal_mutable_vendor_name();
  public:

  // optional string device_name = 6;
  bool has_device_name() const;
  private:
  bool _internal_has_device_name() const;
  public:
  void clear_device_name();
  const std::string& device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);
  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(const std::string& value);
  std::string* _internal_mutable_device_name();
  public:

  // optional .enterprise_management.BusDeviceClass device_class = 1;
  bool has_device_class() const;
  private:
  bool _internal_has_device_class() const;
  public:
  void clear_device_class();
  ::enterprise_management::BusDeviceClass device_class() const;
  void set_device_class(::enterprise_management::BusDeviceClass value);
  private:
  ::enterprise_management::BusDeviceClass _internal_device_class() const;
  void _internal_set_device_class(::enterprise_management::BusDeviceClass value);
  public:

  // optional .enterprise_management.BusType bus_type = 2;
  bool has_bus_type() const;
  private:
  bool _internal_has_bus_type() const;
  public:
  void clear_bus_type();
  ::enterprise_management::BusType bus_type() const;
  void set_bus_type(::enterprise_management::BusType value);
  private:
  ::enterprise_management::BusType _internal_bus_type() const;
  void _internal_set_bus_type(::enterprise_management::BusType value);
  public:

  // optional int32 vendor_id = 3;
  bool has_vendor_id() const;
  private:
  bool _internal_has_vendor_id() const;
  public:
  void clear_vendor_id();
  int32_t vendor_id() const;
  void set_vendor_id(int32_t value);
  private:
  int32_t _internal_vendor_id() const;
  void _internal_set_vendor_id(int32_t value);
  public:

  // optional int32 device_id = 5;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.NetworkAdapterInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> driver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
    int device_class_;
    int bus_type_;
    int32_t vendor_id_;
    int32_t device_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class LaCrOsBrowserReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LaCrOsBrowserReport) */ {
 public:
  inline LaCrOsBrowserReport() : LaCrOsBrowserReport(nullptr) {}
  ~LaCrOsBrowserReport() override;
  explicit PROTOBUF_CONSTEXPR LaCrOsBrowserReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaCrOsBrowserReport(const LaCrOsBrowserReport& from);
  LaCrOsBrowserReport(LaCrOsBrowserReport&& from) noexcept
    : LaCrOsBrowserReport() {
    *this = ::std::move(from);
  }

  inline LaCrOsBrowserReport& operator=(const LaCrOsBrowserReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaCrOsBrowserReport& operator=(LaCrOsBrowserReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LaCrOsBrowserReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaCrOsBrowserReport* internal_default_instance() {
    return reinterpret_cast<const LaCrOsBrowserReport*>(
               &_LaCrOsBrowserReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(LaCrOsBrowserReport& a, LaCrOsBrowserReport& b) {
    a.Swap(&b);
  }
  inline void Swap(LaCrOsBrowserReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaCrOsBrowserReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaCrOsBrowserReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaCrOsBrowserReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LaCrOsBrowserReport& from);
  void MergeFrom(const LaCrOsBrowserReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaCrOsBrowserReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LaCrOsBrowserReport";
  }
  protected:
  explicit LaCrOsBrowserReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceUserFieldNumber = 1,
    kBrowserReportFieldNumber = 2,
  };
  // optional .enterprise_management.DeviceUser device_user = 1;
  bool has_device_user() const;
  private:
  bool _internal_has_device_user() const;
  public:
  void clear_device_user();
  const ::enterprise_management::DeviceUser& device_user() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceUser* release_device_user();
  ::enterprise_management::DeviceUser* mutable_device_user();
  void set_allocated_device_user(::enterprise_management::DeviceUser* device_user);
  private:
  const ::enterprise_management::DeviceUser& _internal_device_user() const;
  ::enterprise_management::DeviceUser* _internal_mutable_device_user();
  public:
  void unsafe_arena_set_allocated_device_user(
      ::enterprise_management::DeviceUser* device_user);
  ::enterprise_management::DeviceUser* unsafe_arena_release_device_user();

  // optional .enterprise_management.BrowserReport browser_report = 2;
  bool has_browser_report() const;
  private:
  bool _internal_has_browser_report() const;
  public:
  void clear_browser_report();
  const ::enterprise_management::BrowserReport& browser_report() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserReport* release_browser_report();
  ::enterprise_management::BrowserReport* mutable_browser_report();
  void set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report);
  private:
  const ::enterprise_management::BrowserReport& _internal_browser_report() const;
  ::enterprise_management::BrowserReport* _internal_mutable_browser_report();
  public:
  void unsafe_arena_set_allocated_browser_report(
      ::enterprise_management::BrowserReport* browser_report);
  ::enterprise_management::BrowserReport* unsafe_arena_release_browser_report();

  // @@protoc_insertion_point(class_scope:enterprise_management.LaCrOsBrowserReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::DeviceUser* device_user_;
    ::enterprise_management::BrowserReport* browser_report_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceStatusReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStatusReportRequest) */ {
 public:
  inline DeviceStatusReportRequest() : DeviceStatusReportRequest(nullptr) {}
  ~DeviceStatusReportRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceStatusReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceStatusReportRequest(const DeviceStatusReportRequest& from);
  DeviceStatusReportRequest(DeviceStatusReportRequest&& from) noexcept
    : DeviceStatusReportRequest() {
    *this = ::std::move(from);
  }

  inline DeviceStatusReportRequest& operator=(const DeviceStatusReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStatusReportRequest& operator=(DeviceStatusReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceStatusReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStatusReportRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceStatusReportRequest*>(
               &_DeviceStatusReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(DeviceStatusReportRequest& a, DeviceStatusReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStatusReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStatusReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceStatusReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceStatusReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceStatusReportRequest& from);
  void MergeFrom(const DeviceStatusReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceStatusReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceStatusReportRequest";
  }
  protected:
  explicit DeviceStatusReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivePeriodsFieldNumber = 6,
    kNetworkInterfacesFieldNumber = 8,
    kUsersFieldNumber = 9,
    kVolumeInfosFieldNumber = 10,
    kNetworkStatesFieldNumber = 11,
    kCpuUtilizationPctSamplesFieldNumber = 12,
    kSystemRamFreeSamplesFieldNumber = 15,
    kCpuTempInfosFieldNumber = 16,
    kCpuUtilizationInfosFieldNumber = 30,
    kSystemRamFreeInfosFieldNumber = 31,
    kCpuInfoFieldNumber = 32,
    kCrashReportInfosFieldNumber = 34,
    kBacklightInfoFieldNumber = 37,
    kFanInfoFieldNumber = 38,
    kBluetoothAdapterInfoFieldNumber = 40,
    kNetworkAdapterInfoFieldNumber = 45,
    kLacrosBrowserReportFieldNumber = 46,
    kOsVersionFieldNumber = 1,
    kFirmwareVersionFieldNumber = 2,
    kBootModeFieldNumber = 3,
    kBrowserVersionFieldNumber = 5,
    kOsUpdateStatusFieldNumber = 17,
    kRunningKioskAppFieldNumber = 18,
    kTpmVersionInfoFieldNumber = 21,
    kTpmStatusInfoFieldNumber = 23,
    kPowerStatusFieldNumber = 25,
    kStorageStatusFieldNumber = 26,
    kBoardStatusFieldNumber = 27,
    kSystemStatusFieldNumber = 28,
    kStatefulPartitionInfoFieldNumber = 29,
    kGraphicsStatusFieldNumber = 33,
    kTimezoneInfoFieldNumber = 35,
    kMemoryInfoFieldNumber = 36,
    kGlobalCpuInfoFieldNumber = 39,
    kSmbiosInfoFieldNumber = 41,
    kKernelParametersFieldNumber = 42,
    kEfiVarsFieldNumber = 43,
    kBootInfoFieldNumber = 44,
    kSystemRamTotalFieldNumber = 14,
    kSoundVolumeFieldNumber = 19,
    kChannelFieldNumber = 22,
    kRootDeviceTotalStorageBytesFieldNumber = 47,
    kWriteProtectSwitchFieldNumber = 24,
  };
  // repeated .enterprise_management.ActiveTimePeriod active_periods = 6;
  int active_periods_size() const;
  private:
  int _internal_active_periods_size() const;
  public:
  void clear_active_periods();
  ::enterprise_management::ActiveTimePeriod* mutable_active_periods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod >*
      mutable_active_periods();
  private:
  const ::enterprise_management::ActiveTimePeriod& _internal_active_periods(int index) const;
  ::enterprise_management::ActiveTimePeriod* _internal_add_active_periods();
  public:
  const ::enterprise_management::ActiveTimePeriod& active_periods(int index) const;
  ::enterprise_management::ActiveTimePeriod* add_active_periods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod >&
      active_periods() const;

  // repeated .enterprise_management.NetworkInterface network_interfaces = 8;
  int network_interfaces_size() const;
  private:
  int _internal_network_interfaces_size() const;
  public:
  void clear_network_interfaces();
  ::enterprise_management::NetworkInterface* mutable_network_interfaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface >*
      mutable_network_interfaces();
  private:
  const ::enterprise_management::NetworkInterface& _internal_network_interfaces(int index) const;
  ::enterprise_management::NetworkInterface* _internal_add_network_interfaces();
  public:
  const ::enterprise_management::NetworkInterface& network_interfaces(int index) const;
  ::enterprise_management::NetworkInterface* add_network_interfaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface >&
      network_interfaces() const;

  // repeated .enterprise_management.DeviceUser users = 9;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::enterprise_management::DeviceUser* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser >*
      mutable_users();
  private:
  const ::enterprise_management::DeviceUser& _internal_users(int index) const;
  ::enterprise_management::DeviceUser* _internal_add_users();
  public:
  const ::enterprise_management::DeviceUser& users(int index) const;
  ::enterprise_management::DeviceUser* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser >&
      users() const;

  // repeated .enterprise_management.VolumeInfo volume_infos = 10;
  int volume_infos_size() const;
  private:
  int _internal_volume_infos_size() const;
  public:
  void clear_volume_infos();
  ::enterprise_management::VolumeInfo* mutable_volume_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >*
      mutable_volume_infos();
  private:
  const ::enterprise_management::VolumeInfo& _internal_volume_infos(int index) const;
  ::enterprise_management::VolumeInfo* _internal_add_volume_infos();
  public:
  const ::enterprise_management::VolumeInfo& volume_infos(int index) const;
  ::enterprise_management::VolumeInfo* add_volume_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >&
      volume_infos() const;

  // repeated .enterprise_management.NetworkState network_states = 11;
  int network_states_size() const;
  private:
  int _internal_network_states_size() const;
  public:
  void clear_network_states();
  ::enterprise_management::NetworkState* mutable_network_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState >*
      mutable_network_states();
  private:
  const ::enterprise_management::NetworkState& _internal_network_states(int index) const;
  ::enterprise_management::NetworkState* _internal_add_network_states();
  public:
  const ::enterprise_management::NetworkState& network_states(int index) const;
  ::enterprise_management::NetworkState* add_network_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState >&
      network_states() const;

  // repeated int32 cpu_utilization_pct_samples = 12 [deprecated = true];
  PROTOBUF_DEPRECATED int cpu_utilization_pct_samples_size() const;
  private:
  int _internal_cpu_utilization_pct_samples_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_cpu_utilization_pct_samples();
  private:
  int32_t _internal_cpu_utilization_pct_samples(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_cpu_utilization_pct_samples() const;
  void _internal_add_cpu_utilization_pct_samples(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_cpu_utilization_pct_samples();
  public:
  PROTOBUF_DEPRECATED int32_t cpu_utilization_pct_samples(int index) const;
  PROTOBUF_DEPRECATED void set_cpu_utilization_pct_samples(int index, int32_t value);
  PROTOBUF_DEPRECATED void add_cpu_utilization_pct_samples(int32_t value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      cpu_utilization_pct_samples() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_cpu_utilization_pct_samples();

  // repeated int64 system_ram_free_samples = 15 [deprecated = true];
  PROTOBUF_DEPRECATED int system_ram_free_samples_size() const;
  private:
  int _internal_system_ram_free_samples_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_system_ram_free_samples();
  private:
  int64_t _internal_system_ram_free_samples(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_system_ram_free_samples() const;
  void _internal_add_system_ram_free_samples(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_system_ram_free_samples();
  public:
  PROTOBUF_DEPRECATED int64_t system_ram_free_samples(int index) const;
  PROTOBUF_DEPRECATED void set_system_ram_free_samples(int index, int64_t value);
  PROTOBUF_DEPRECATED void add_system_ram_free_samples(int64_t value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      system_ram_free_samples() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_system_ram_free_samples();

  // repeated .enterprise_management.CPUTempInfo cpu_temp_infos = 16;
  int cpu_temp_infos_size() const;
  private:
  int _internal_cpu_temp_infos_size() const;
  public:
  void clear_cpu_temp_infos();
  ::enterprise_management::CPUTempInfo* mutable_cpu_temp_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo >*
      mutable_cpu_temp_infos();
  private:
  const ::enterprise_management::CPUTempInfo& _internal_cpu_temp_infos(int index) const;
  ::enterprise_management::CPUTempInfo* _internal_add_cpu_temp_infos();
  public:
  const ::enterprise_management::CPUTempInfo& cpu_temp_infos(int index) const;
  ::enterprise_management::CPUTempInfo* add_cpu_temp_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo >&
      cpu_temp_infos() const;

  // repeated .enterprise_management.CpuUtilizationInfo cpu_utilization_infos = 30;
  int cpu_utilization_infos_size() const;
  private:
  int _internal_cpu_utilization_infos_size() const;
  public:
  void clear_cpu_utilization_infos();
  ::enterprise_management::CpuUtilizationInfo* mutable_cpu_utilization_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo >*
      mutable_cpu_utilization_infos();
  private:
  const ::enterprise_management::CpuUtilizationInfo& _internal_cpu_utilization_infos(int index) const;
  ::enterprise_management::CpuUtilizationInfo* _internal_add_cpu_utilization_infos();
  public:
  const ::enterprise_management::CpuUtilizationInfo& cpu_utilization_infos(int index) const;
  ::enterprise_management::CpuUtilizationInfo* add_cpu_utilization_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo >&
      cpu_utilization_infos() const;

  // repeated .enterprise_management.SystemFreeRamInfo system_ram_free_infos = 31;
  int system_ram_free_infos_size() const;
  private:
  int _internal_system_ram_free_infos_size() const;
  public:
  void clear_system_ram_free_infos();
  ::enterprise_management::SystemFreeRamInfo* mutable_system_ram_free_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo >*
      mutable_system_ram_free_infos();
  private:
  const ::enterprise_management::SystemFreeRamInfo& _internal_system_ram_free_infos(int index) const;
  ::enterprise_management::SystemFreeRamInfo* _internal_add_system_ram_free_infos();
  public:
  const ::enterprise_management::SystemFreeRamInfo& system_ram_free_infos(int index) const;
  ::enterprise_management::SystemFreeRamInfo* add_system_ram_free_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo >&
      system_ram_free_infos() const;

  // repeated .enterprise_management.CpuInfo cpu_info = 32;
  int cpu_info_size() const;
  private:
  int _internal_cpu_info_size() const;
  public:
  void clear_cpu_info();
  ::enterprise_management::CpuInfo* mutable_cpu_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo >*
      mutable_cpu_info();
  private:
  const ::enterprise_management::CpuInfo& _internal_cpu_info(int index) const;
  ::enterprise_management::CpuInfo* _internal_add_cpu_info();
  public:
  const ::enterprise_management::CpuInfo& cpu_info(int index) const;
  ::enterprise_management::CpuInfo* add_cpu_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo >&
      cpu_info() const;

  // repeated .enterprise_management.CrashReportInfo crash_report_infos = 34;
  int crash_report_infos_size() const;
  private:
  int _internal_crash_report_infos_size() const;
  public:
  void clear_crash_report_infos();
  ::enterprise_management::CrashReportInfo* mutable_crash_report_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo >*
      mutable_crash_report_infos();
  private:
  const ::enterprise_management::CrashReportInfo& _internal_crash_report_infos(int index) const;
  ::enterprise_management::CrashReportInfo* _internal_add_crash_report_infos();
  public:
  const ::enterprise_management::CrashReportInfo& crash_report_infos(int index) const;
  ::enterprise_management::CrashReportInfo* add_crash_report_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo >&
      crash_report_infos() const;

  // repeated .enterprise_management.BacklightInfo backlight_info = 37;
  int backlight_info_size() const;
  private:
  int _internal_backlight_info_size() const;
  public:
  void clear_backlight_info();
  ::enterprise_management::BacklightInfo* mutable_backlight_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo >*
      mutable_backlight_info();
  private:
  const ::enterprise_management::BacklightInfo& _internal_backlight_info(int index) const;
  ::enterprise_management::BacklightInfo* _internal_add_backlight_info();
  public:
  const ::enterprise_management::BacklightInfo& backlight_info(int index) const;
  ::enterprise_management::BacklightInfo* add_backlight_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo >&
      backlight_info() const;

  // repeated .enterprise_management.FanInfo fan_info = 38;
  int fan_info_size() const;
  private:
  int _internal_fan_info_size() const;
  public:
  void clear_fan_info();
  ::enterprise_management::FanInfo* mutable_fan_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo >*
      mutable_fan_info();
  private:
  const ::enterprise_management::FanInfo& _internal_fan_info(int index) const;
  ::enterprise_management::FanInfo* _internal_add_fan_info();
  public:
  const ::enterprise_management::FanInfo& fan_info(int index) const;
  ::enterprise_management::FanInfo* add_fan_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo >&
      fan_info() const;

  // repeated .enterprise_management.BluetoothAdapterInfo bluetooth_adapter_info = 40;
  int bluetooth_adapter_info_size() const;
  private:
  int _internal_bluetooth_adapter_info_size() const;
  public:
  void clear_bluetooth_adapter_info();
  ::enterprise_management::BluetoothAdapterInfo* mutable_bluetooth_adapter_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo >*
      mutable_bluetooth_adapter_info();
  private:
  const ::enterprise_management::BluetoothAdapterInfo& _internal_bluetooth_adapter_info(int index) const;
  ::enterprise_management::BluetoothAdapterInfo* _internal_add_bluetooth_adapter_info();
  public:
  const ::enterprise_management::BluetoothAdapterInfo& bluetooth_adapter_info(int index) const;
  ::enterprise_management::BluetoothAdapterInfo* add_bluetooth_adapter_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo >&
      bluetooth_adapter_info() const;

  // repeated .enterprise_management.NetworkAdapterInfo network_adapter_info = 45;
  int network_adapter_info_size() const;
  private:
  int _internal_network_adapter_info_size() const;
  public:
  void clear_network_adapter_info();
  ::enterprise_management::NetworkAdapterInfo* mutable_network_adapter_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkAdapterInfo >*
      mutable_network_adapter_info();
  private:
  const ::enterprise_management::NetworkAdapterInfo& _internal_network_adapter_info(int index) const;
  ::enterprise_management::NetworkAdapterInfo* _internal_add_network_adapter_info();
  public:
  const ::enterprise_management::NetworkAdapterInfo& network_adapter_info(int index) const;
  ::enterprise_management::NetworkAdapterInfo* add_network_adapter_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkAdapterInfo >&
      network_adapter_info() const;

  // repeated .enterprise_management.LaCrOsBrowserReport lacros_browser_report = 46;
  int lacros_browser_report_size() const;
  private:
  int _internal_lacros_browser_report_size() const;
  public:
  void clear_lacros_browser_report();
  ::enterprise_management::LaCrOsBrowserReport* mutable_lacros_browser_report(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LaCrOsBrowserReport >*
      mutable_lacros_browser_report();
  private:
  const ::enterprise_management::LaCrOsBrowserReport& _internal_lacros_browser_report(int index) const;
  ::enterprise_management::LaCrOsBrowserReport* _internal_add_lacros_browser_report();
  public:
  const ::enterprise_management::LaCrOsBrowserReport& lacros_browser_report(int index) const;
  ::enterprise_management::LaCrOsBrowserReport* add_lacros_browser_report();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LaCrOsBrowserReport >&
      lacros_browser_report() const;

  // optional string os_version = 1;
  bool has_os_version() const;
  private:
  bool _internal_has_os_version() const;
  public:
  void clear_os_version();
  const std::string& os_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_version();
  PROTOBUF_NODISCARD std::string* release_os_version();
  void set_allocated_os_version(std::string* os_version);
  private:
  const std::string& _internal_os_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(const std::string& value);
  std::string* _internal_mutable_os_version();
  public:

  // optional string firmware_version = 2;
  bool has_firmware_version() const;
  private:
  bool _internal_has_firmware_version() const;
  public:
  void clear_firmware_version();
  const std::string& firmware_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firmware_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firmware_version();
  PROTOBUF_NODISCARD std::string* release_firmware_version();
  void set_allocated_firmware_version(std::string* firmware_version);
  private:
  const std::string& _internal_firmware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(const std::string& value);
  std::string* _internal_mutable_firmware_version();
  public:

  // optional string boot_mode = 3;
  bool has_boot_mode() const;
  private:
  bool _internal_has_boot_mode() const;
  public:
  void clear_boot_mode();
  const std::string& boot_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boot_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boot_mode();
  PROTOBUF_NODISCARD std::string* release_boot_mode();
  void set_allocated_boot_mode(std::string* boot_mode);
  private:
  const std::string& _internal_boot_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boot_mode(const std::string& value);
  std::string* _internal_mutable_boot_mode();
  public:

  // optional string browser_version = 5;
  bool has_browser_version() const;
  private:
  bool _internal_has_browser_version() const;
  public:
  void clear_browser_version();
  const std::string& browser_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_version();
  PROTOBUF_NODISCARD std::string* release_browser_version();
  void set_allocated_browser_version(std::string* browser_version);
  private:
  const std::string& _internal_browser_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_version(const std::string& value);
  std::string* _internal_mutable_browser_version();
  public:

  // optional .enterprise_management.OsUpdateStatus os_update_status = 17;
  bool has_os_update_status() const;
  private:
  bool _internal_has_os_update_status() const;
  public:
  void clear_os_update_status();
  const ::enterprise_management::OsUpdateStatus& os_update_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::OsUpdateStatus* release_os_update_status();
  ::enterprise_management::OsUpdateStatus* mutable_os_update_status();
  void set_allocated_os_update_status(::enterprise_management::OsUpdateStatus* os_update_status);
  private:
  const ::enterprise_management::OsUpdateStatus& _internal_os_update_status() const;
  ::enterprise_management::OsUpdateStatus* _internal_mutable_os_update_status();
  public:
  void unsafe_arena_set_allocated_os_update_status(
      ::enterprise_management::OsUpdateStatus* os_update_status);
  ::enterprise_management::OsUpdateStatus* unsafe_arena_release_os_update_status();

  // optional .enterprise_management.AppStatus running_kiosk_app = 18;
  bool has_running_kiosk_app() const;
  private:
  bool _internal_has_running_kiosk_app() const;
  public:
  void clear_running_kiosk_app();
  const ::enterprise_management::AppStatus& running_kiosk_app() const;
  PROTOBUF_NODISCARD ::enterprise_management::AppStatus* release_running_kiosk_app();
  ::enterprise_management::AppStatus* mutable_running_kiosk_app();
  void set_allocated_running_kiosk_app(::enterprise_management::AppStatus* running_kiosk_app);
  private:
  const ::enterprise_management::AppStatus& _internal_running_kiosk_app() const;
  ::enterprise_management::AppStatus* _internal_mutable_running_kiosk_app();
  public:
  void unsafe_arena_set_allocated_running_kiosk_app(
      ::enterprise_management::AppStatus* running_kiosk_app);
  ::enterprise_management::AppStatus* unsafe_arena_release_running_kiosk_app();

  // optional .enterprise_management.TpmVersionInfo tpm_version_info = 21;
  bool has_tpm_version_info() const;
  private:
  bool _internal_has_tpm_version_info() const;
  public:
  void clear_tpm_version_info();
  const ::enterprise_management::TpmVersionInfo& tpm_version_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::TpmVersionInfo* release_tpm_version_info();
  ::enterprise_management::TpmVersionInfo* mutable_tpm_version_info();
  void set_allocated_tpm_version_info(::enterprise_management::TpmVersionInfo* tpm_version_info);
  private:
  const ::enterprise_management::TpmVersionInfo& _internal_tpm_version_info() const;
  ::enterprise_management::TpmVersionInfo* _internal_mutable_tpm_version_info();
  public:
  void unsafe_arena_set_allocated_tpm_version_info(
      ::enterprise_management::TpmVersionInfo* tpm_version_info);
  ::enterprise_management::TpmVersionInfo* unsafe_arena_release_tpm_version_info();

  // optional .enterprise_management.TpmStatusInfo tpm_status_info = 23;
  bool has_tpm_status_info() const;
  private:
  bool _internal_has_tpm_status_info() const;
  public:
  void clear_tpm_status_info();
  const ::enterprise_management::TpmStatusInfo& tpm_status_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::TpmStatusInfo* release_tpm_status_info();
  ::enterprise_management::TpmStatusInfo* mutable_tpm_status_info();
  void set_allocated_tpm_status_info(::enterprise_management::TpmStatusInfo* tpm_status_info);
  private:
  const ::enterprise_management::TpmStatusInfo& _internal_tpm_status_info() const;
  ::enterprise_management::TpmStatusInfo* _internal_mutable_tpm_status_info();
  public:
  void unsafe_arena_set_allocated_tpm_status_info(
      ::enterprise_management::TpmStatusInfo* tpm_status_info);
  ::enterprise_management::TpmStatusInfo* unsafe_arena_release_tpm_status_info();

  // optional .enterprise_management.PowerStatus power_status = 25;
  bool has_power_status() const;
  private:
  bool _internal_has_power_status() const;
  public:
  void clear_power_status();
  const ::enterprise_management::PowerStatus& power_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::PowerStatus* release_power_status();
  ::enterprise_management::PowerStatus* mutable_power_status();
  void set_allocated_power_status(::enterprise_management::PowerStatus* power_status);
  private:
  const ::enterprise_management::PowerStatus& _internal_power_status() const;
  ::enterprise_management::PowerStatus* _internal_mutable_power_status();
  public:
  void unsafe_arena_set_allocated_power_status(
      ::enterprise_management::PowerStatus* power_status);
  ::enterprise_management::PowerStatus* unsafe_arena_release_power_status();

  // optional .enterprise_management.StorageStatus storage_status = 26;
  bool has_storage_status() const;
  private:
  bool _internal_has_storage_status() const;
  public:
  void clear_storage_status();
  const ::enterprise_management::StorageStatus& storage_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::StorageStatus* release_storage_status();
  ::enterprise_management::StorageStatus* mutable_storage_status();
  void set_allocated_storage_status(::enterprise_management::StorageStatus* storage_status);
  private:
  const ::enterprise_management::StorageStatus& _internal_storage_status() const;
  ::enterprise_management::StorageStatus* _internal_mutable_storage_status();
  public:
  void unsafe_arena_set_allocated_storage_status(
      ::enterprise_management::StorageStatus* storage_status);
  ::enterprise_management::StorageStatus* unsafe_arena_release_storage_status();

  // optional .enterprise_management.BoardStatus board_status = 27;
  bool has_board_status() const;
  private:
  bool _internal_has_board_status() const;
  public:
  void clear_board_status();
  const ::enterprise_management::BoardStatus& board_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::BoardStatus* release_board_status();
  ::enterprise_management::BoardStatus* mutable_board_status();
  void set_allocated_board_status(::enterprise_management::BoardStatus* board_status);
  private:
  const ::enterprise_management::BoardStatus& _internal_board_status() const;
  ::enterprise_management::BoardStatus* _internal_mutable_board_status();
  public:
  void unsafe_arena_set_allocated_board_status(
      ::enterprise_management::BoardStatus* board_status);
  ::enterprise_management::BoardStatus* unsafe_arena_release_board_status();

  // optional .enterprise_management.SystemStatus system_status = 28;
  bool has_system_status() const;
  private:
  bool _internal_has_system_status() const;
  public:
  void clear_system_status();
  const ::enterprise_management::SystemStatus& system_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::SystemStatus* release_system_status();
  ::enterprise_management::SystemStatus* mutable_system_status();
  void set_allocated_system_status(::enterprise_management::SystemStatus* system_status);
  private:
  const ::enterprise_management::SystemStatus& _internal_system_status() const;
  ::enterprise_management::SystemStatus* _internal_mutable_system_status();
  public:
  void unsafe_arena_set_allocated_system_status(
      ::enterprise_management::SystemStatus* system_status);
  ::enterprise_management::SystemStatus* unsafe_arena_release_system_status();

  // optional .enterprise_management.StatefulPartitionInfo stateful_partition_info = 29;
  bool has_stateful_partition_info() const;
  private:
  bool _internal_has_stateful_partition_info() const;
  public:
  void clear_stateful_partition_info();
  const ::enterprise_management::StatefulPartitionInfo& stateful_partition_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::StatefulPartitionInfo* release_stateful_partition_info();
  ::enterprise_management::StatefulPartitionInfo* mutable_stateful_partition_info();
  void set_allocated_stateful_partition_info(::enterprise_management::StatefulPartitionInfo* stateful_partition_info);
  private:
  const ::enterprise_management::StatefulPartitionInfo& _internal_stateful_partition_info() const;
  ::enterprise_management::StatefulPartitionInfo* _internal_mutable_stateful_partition_info();
  public:
  void unsafe_arena_set_allocated_stateful_partition_info(
      ::enterprise_management::StatefulPartitionInfo* stateful_partition_info);
  ::enterprise_management::StatefulPartitionInfo* unsafe_arena_release_stateful_partition_info();

  // optional .enterprise_management.GraphicsStatus graphics_status = 33;
  bool has_graphics_status() const;
  private:
  bool _internal_has_graphics_status() const;
  public:
  void clear_graphics_status();
  const ::enterprise_management::GraphicsStatus& graphics_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::GraphicsStatus* release_graphics_status();
  ::enterprise_management::GraphicsStatus* mutable_graphics_status();
  void set_allocated_graphics_status(::enterprise_management::GraphicsStatus* graphics_status);
  private:
  const ::enterprise_management::GraphicsStatus& _internal_graphics_status() const;
  ::enterprise_management::GraphicsStatus* _internal_mutable_graphics_status();
  public:
  void unsafe_arena_set_allocated_graphics_status(
      ::enterprise_management::GraphicsStatus* graphics_status);
  ::enterprise_management::GraphicsStatus* unsafe_arena_release_graphics_status();

  // optional .enterprise_management.TimezoneInfo timezone_info = 35;
  bool has_timezone_info() const;
  private:
  bool _internal_has_timezone_info() const;
  public:
  void clear_timezone_info();
  const ::enterprise_management::TimezoneInfo& timezone_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::TimezoneInfo* release_timezone_info();
  ::enterprise_management::TimezoneInfo* mutable_timezone_info();
  void set_allocated_timezone_info(::enterprise_management::TimezoneInfo* timezone_info);
  private:
  const ::enterprise_management::TimezoneInfo& _internal_timezone_info() const;
  ::enterprise_management::TimezoneInfo* _internal_mutable_timezone_info();
  public:
  void unsafe_arena_set_allocated_timezone_info(
      ::enterprise_management::TimezoneInfo* timezone_info);
  ::enterprise_management::TimezoneInfo* unsafe_arena_release_timezone_info();

  // optional .enterprise_management.MemoryInfo memory_info = 36;
  bool has_memory_info() const;
  private:
  bool _internal_has_memory_info() const;
  public:
  void clear_memory_info();
  const ::enterprise_management::MemoryInfo& memory_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::MemoryInfo* release_memory_info();
  ::enterprise_management::MemoryInfo* mutable_memory_info();
  void set_allocated_memory_info(::enterprise_management::MemoryInfo* memory_info);
  private:
  const ::enterprise_management::MemoryInfo& _internal_memory_info() const;
  ::enterprise_management::MemoryInfo* _internal_mutable_memory_info();
  public:
  void unsafe_arena_set_allocated_memory_info(
      ::enterprise_management::MemoryInfo* memory_info);
  ::enterprise_management::MemoryInfo* unsafe_arena_release_memory_info();

  // optional .enterprise_management.GlobalCpuInfo global_cpu_info = 39;
  bool has_global_cpu_info() const;
  private:
  bool _internal_has_global_cpu_info() const;
  public:
  void clear_global_cpu_info();
  const ::enterprise_management::GlobalCpuInfo& global_cpu_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::GlobalCpuInfo* release_global_cpu_info();
  ::enterprise_management::GlobalCpuInfo* mutable_global_cpu_info();
  void set_allocated_global_cpu_info(::enterprise_management::GlobalCpuInfo* global_cpu_info);
  private:
  const ::enterprise_management::GlobalCpuInfo& _internal_global_cpu_info() const;
  ::enterprise_management::GlobalCpuInfo* _internal_mutable_global_cpu_info();
  public:
  void unsafe_arena_set_allocated_global_cpu_info(
      ::enterprise_management::GlobalCpuInfo* global_cpu_info);
  ::enterprise_management::GlobalCpuInfo* unsafe_arena_release_global_cpu_info();

  // optional .enterprise_management.SmbiosInfo smbios_info = 41;
  bool has_smbios_info() const;
  private:
  bool _internal_has_smbios_info() const;
  public:
  void clear_smbios_info();
  const ::enterprise_management::SmbiosInfo& smbios_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::SmbiosInfo* release_smbios_info();
  ::enterprise_management::SmbiosInfo* mutable_smbios_info();
  void set_allocated_smbios_info(::enterprise_management::SmbiosInfo* smbios_info);
  private:
  const ::enterprise_management::SmbiosInfo& _internal_smbios_info() const;
  ::enterprise_management::SmbiosInfo* _internal_mutable_smbios_info();
  public:
  void unsafe_arena_set_allocated_smbios_info(
      ::enterprise_management::SmbiosInfo* smbios_info);
  ::enterprise_management::SmbiosInfo* unsafe_arena_release_smbios_info();

  // optional .enterprise_management.KernelParameters kernel_parameters = 42;
  bool has_kernel_parameters() const;
  private:
  bool _internal_has_kernel_parameters() const;
  public:
  void clear_kernel_parameters();
  const ::enterprise_management::KernelParameters& kernel_parameters() const;
  PROTOBUF_NODISCARD ::enterprise_management::KernelParameters* release_kernel_parameters();
  ::enterprise_management::KernelParameters* mutable_kernel_parameters();
  void set_allocated_kernel_parameters(::enterprise_management::KernelParameters* kernel_parameters);
  private:
  const ::enterprise_management::KernelParameters& _internal_kernel_parameters() const;
  ::enterprise_management::KernelParameters* _internal_mutable_kernel_parameters();
  public:
  void unsafe_arena_set_allocated_kernel_parameters(
      ::enterprise_management::KernelParameters* kernel_parameters);
  ::enterprise_management::KernelParameters* unsafe_arena_release_kernel_parameters();

  // optional .enterprise_management.EFIVars efi_vars = 43;
  bool has_efi_vars() const;
  private:
  bool _internal_has_efi_vars() const;
  public:
  void clear_efi_vars();
  const ::enterprise_management::EFIVars& efi_vars() const;
  PROTOBUF_NODISCARD ::enterprise_management::EFIVars* release_efi_vars();
  ::enterprise_management::EFIVars* mutable_efi_vars();
  void set_allocated_efi_vars(::enterprise_management::EFIVars* efi_vars);
  private:
  const ::enterprise_management::EFIVars& _internal_efi_vars() const;
  ::enterprise_management::EFIVars* _internal_mutable_efi_vars();
  public:
  void unsafe_arena_set_allocated_efi_vars(
      ::enterprise_management::EFIVars* efi_vars);
  ::enterprise_management::EFIVars* unsafe_arena_release_efi_vars();

  // optional .enterprise_management.BootInfo boot_info = 44;
  bool has_boot_info() const;
  private:
  bool _internal_has_boot_info() const;
  public:
  void clear_boot_info();
  const ::enterprise_management::BootInfo& boot_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::BootInfo* release_boot_info();
  ::enterprise_management::BootInfo* mutable_boot_info();
  void set_allocated_boot_info(::enterprise_management::BootInfo* boot_info);
  private:
  const ::enterprise_management::BootInfo& _internal_boot_info() const;
  ::enterprise_management::BootInfo* _internal_mutable_boot_info();
  public:
  void unsafe_arena_set_allocated_boot_info(
      ::enterprise_management::BootInfo* boot_info);
  ::enterprise_management::BootInfo* unsafe_arena_release_boot_info();

  // optional int64 system_ram_total = 14;
  bool has_system_ram_total() const;
  private:
  bool _internal_has_system_ram_total() const;
  public:
  void clear_system_ram_total();
  int64_t system_ram_total() const;
  void set_system_ram_total(int64_t value);
  private:
  int64_t _internal_system_ram_total() const;
  void _internal_set_system_ram_total(int64_t value);
  public:

  // optional int32 sound_volume = 19;
  bool has_sound_volume() const;
  private:
  bool _internal_has_sound_volume() const;
  public:
  void clear_sound_volume();
  int32_t sound_volume() const;
  void set_sound_volume(int32_t value);
  private:
  int32_t _internal_sound_volume() const;
  void _internal_set_sound_volume(int32_t value);
  public:

  // optional .enterprise_management.Channel channel = 22;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  ::enterprise_management::Channel channel() const;
  void set_channel(::enterprise_management::Channel value);
  private:
  ::enterprise_management::Channel _internal_channel() const;
  void _internal_set_channel(::enterprise_management::Channel value);
  public:

  // optional int64 root_device_total_storage_bytes = 47;
  bool has_root_device_total_storage_bytes() const;
  private:
  bool _internal_has_root_device_total_storage_bytes() const;
  public:
  void clear_root_device_total_storage_bytes();
  int64_t root_device_total_storage_bytes() const;
  void set_root_device_total_storage_bytes(int64_t value);
  private:
  int64_t _internal_root_device_total_storage_bytes() const;
  void _internal_set_root_device_total_storage_bytes(int64_t value);
  public:

  // optional bool write_protect_switch = 24;
  bool has_write_protect_switch() const;
  private:
  bool _internal_has_write_protect_switch() const;
  public:
  void clear_write_protect_switch();
  bool write_protect_switch() const;
  void set_write_protect_switch(bool value);
  private:
  bool _internal_write_protect_switch() const;
  void _internal_set_write_protect_switch(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStatusReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod > active_periods_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface > network_interfaces_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser > users_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo > volume_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState > network_states_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > cpu_utilization_pct_samples_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > system_ram_free_samples_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo > cpu_temp_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo > cpu_utilization_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo > system_ram_free_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo > cpu_info_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo > crash_report_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo > backlight_info_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo > fan_info_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo > bluetooth_adapter_info_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkAdapterInfo > network_adapter_info_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LaCrOsBrowserReport > lacros_browser_report_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boot_mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_version_;
    ::enterprise_management::OsUpdateStatus* os_update_status_;
    ::enterprise_management::AppStatus* running_kiosk_app_;
    ::enterprise_management::TpmVersionInfo* tpm_version_info_;
    ::enterprise_management::TpmStatusInfo* tpm_status_info_;
    ::enterprise_management::PowerStatus* power_status_;
    ::enterprise_management::StorageStatus* storage_status_;
    ::enterprise_management::BoardStatus* board_status_;
    ::enterprise_management::SystemStatus* system_status_;
    ::enterprise_management::StatefulPartitionInfo* stateful_partition_info_;
    ::enterprise_management::GraphicsStatus* graphics_status_;
    ::enterprise_management::TimezoneInfo* timezone_info_;
    ::enterprise_management::MemoryInfo* memory_info_;
    ::enterprise_management::GlobalCpuInfo* global_cpu_info_;
    ::enterprise_management::SmbiosInfo* smbios_info_;
    ::enterprise_management::KernelParameters* kernel_parameters_;
    ::enterprise_management::EFIVars* efi_vars_;
    ::enterprise_management::BootInfo* boot_info_;
    int64_t system_ram_total_;
    int32_t sound_volume_;
    int channel_;
    int64_t root_device_total_storage_bytes_;
    bool write_protect_switch_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class OsUpdateStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OsUpdateStatus) */ {
 public:
  inline OsUpdateStatus() : OsUpdateStatus(nullptr) {}
  ~OsUpdateStatus() override;
  explicit PROTOBUF_CONSTEXPR OsUpdateStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OsUpdateStatus(const OsUpdateStatus& from);
  OsUpdateStatus(OsUpdateStatus&& from) noexcept
    : OsUpdateStatus() {
    *this = ::std::move(from);
  }

  inline OsUpdateStatus& operator=(const OsUpdateStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OsUpdateStatus& operator=(OsUpdateStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OsUpdateStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const OsUpdateStatus* internal_default_instance() {
    return reinterpret_cast<const OsUpdateStatus*>(
               &_OsUpdateStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(OsUpdateStatus& a, OsUpdateStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OsUpdateStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OsUpdateStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OsUpdateStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OsUpdateStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OsUpdateStatus& from);
  void MergeFrom(const OsUpdateStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OsUpdateStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OsUpdateStatus";
  }
  protected:
  explicit OsUpdateStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef OsUpdateStatus_UpdateStatus UpdateStatus;
  static constexpr UpdateStatus OS_UP_TO_DATE =
    OsUpdateStatus_UpdateStatus_OS_UP_TO_DATE;
  static constexpr UpdateStatus OS_IMAGE_DOWNLOAD_NOT_STARTED =
    OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_NOT_STARTED;
  static constexpr UpdateStatus OS_IMAGE_DOWNLOAD_IN_PROGRESS =
    OsUpdateStatus_UpdateStatus_OS_IMAGE_DOWNLOAD_IN_PROGRESS;
  static constexpr UpdateStatus OS_UPDATE_NEED_REBOOT =
    OsUpdateStatus_UpdateStatus_OS_UPDATE_NEED_REBOOT;
  static inline bool UpdateStatus_IsValid(int value) {
    return OsUpdateStatus_UpdateStatus_IsValid(value);
  }
  static constexpr UpdateStatus UpdateStatus_MIN =
    OsUpdateStatus_UpdateStatus_UpdateStatus_MIN;
  static constexpr UpdateStatus UpdateStatus_MAX =
    OsUpdateStatus_UpdateStatus_UpdateStatus_MAX;
  static constexpr int UpdateStatus_ARRAYSIZE =
    OsUpdateStatus_UpdateStatus_UpdateStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& UpdateStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateStatus_Name.");
    return OsUpdateStatus_UpdateStatus_Name(enum_t_value);
  }
  static inline bool UpdateStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UpdateStatus* value) {
    return OsUpdateStatus_UpdateStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNewPlatformVersionFieldNumber = 2,
    kNewRequiredPlatformVersionFieldNumber = 3,
    kLastCheckedTimestampFieldNumber = 4,
    kLastRebootTimestampFieldNumber = 5,
    kUpdateStatusFieldNumber = 1,
  };
  // optional string new_platform_version = 2;
  bool has_new_platform_version() const;
  private:
  bool _internal_has_new_platform_version() const;
  public:
  void clear_new_platform_version();
  const std::string& new_platform_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_platform_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_platform_version();
  PROTOBUF_NODISCARD std::string* release_new_platform_version();
  void set_allocated_new_platform_version(std::string* new_platform_version);
  private:
  const std::string& _internal_new_platform_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_platform_version(const std::string& value);
  std::string* _internal_mutable_new_platform_version();
  public:

  // optional string new_required_platform_version = 3;
  bool has_new_required_platform_version() const;
  private:
  bool _internal_has_new_required_platform_version() const;
  public:
  void clear_new_required_platform_version();
  const std::string& new_required_platform_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_required_platform_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_required_platform_version();
  PROTOBUF_NODISCARD std::string* release_new_required_platform_version();
  void set_allocated_new_required_platform_version(std::string* new_required_platform_version);
  private:
  const std::string& _internal_new_required_platform_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_required_platform_version(const std::string& value);
  std::string* _internal_mutable_new_required_platform_version();
  public:

  // optional int64 last_checked_timestamp = 4;
  bool has_last_checked_timestamp() const;
  private:
  bool _internal_has_last_checked_timestamp() const;
  public:
  void clear_last_checked_timestamp();
  int64_t last_checked_timestamp() const;
  void set_last_checked_timestamp(int64_t value);
  private:
  int64_t _internal_last_checked_timestamp() const;
  void _internal_set_last_checked_timestamp(int64_t value);
  public:

  // optional int64 last_reboot_timestamp = 5;
  bool has_last_reboot_timestamp() const;
  private:
  bool _internal_has_last_reboot_timestamp() const;
  public:
  void clear_last_reboot_timestamp();
  int64_t last_reboot_timestamp() const;
  void set_last_reboot_timestamp(int64_t value);
  private:
  int64_t _internal_last_reboot_timestamp() const;
  void _internal_set_last_reboot_timestamp(int64_t value);
  public:

  // optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
  bool has_update_status() const;
  private:
  bool _internal_has_update_status() const;
  public:
  void clear_update_status();
  ::enterprise_management::OsUpdateStatus_UpdateStatus update_status() const;
  void set_update_status(::enterprise_management::OsUpdateStatus_UpdateStatus value);
  private:
  ::enterprise_management::OsUpdateStatus_UpdateStatus _internal_update_status() const;
  void _internal_set_update_status(::enterprise_management::OsUpdateStatus_UpdateStatus value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OsUpdateStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_platform_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_required_platform_version_;
    int64_t last_checked_timestamp_;
    int64_t last_reboot_timestamp_;
    int update_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AppStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppStatus) */ {
 public:
  inline AppStatus() : AppStatus(nullptr) {}
  ~AppStatus() override;
  explicit PROTOBUF_CONSTEXPR AppStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppStatus(const AppStatus& from);
  AppStatus(AppStatus&& from) noexcept
    : AppStatus() {
    *this = ::std::move(from);
  }

  inline AppStatus& operator=(const AppStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppStatus& operator=(AppStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppStatus* internal_default_instance() {
    return reinterpret_cast<const AppStatus*>(
               &_AppStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(AppStatus& a, AppStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(AppStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AppStatus& from);
  void MergeFrom(const AppStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AppStatus";
  }
  protected:
  explicit AppStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kExtensionVersionFieldNumber = 2,
    kStatusFieldNumber = 3,
    kRequiredPlatformVersionFieldNumber = 5,
    kErrorFieldNumber = 4,
  };
  // optional string app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // optional string extension_version = 2;
  bool has_extension_version() const;
  private:
  bool _internal_has_extension_version() const;
  public:
  void clear_extension_version();
  const std::string& extension_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension_version();
  PROTOBUF_NODISCARD std::string* release_extension_version();
  void set_allocated_extension_version(std::string* extension_version);
  private:
  const std::string& _internal_extension_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_version(const std::string& value);
  std::string* _internal_mutable_extension_version();
  public:

  // optional string status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string required_platform_version = 5;
  bool has_required_platform_version() const;
  private:
  bool _internal_has_required_platform_version() const;
  public:
  void clear_required_platform_version();
  const std::string& required_platform_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_required_platform_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_required_platform_version();
  PROTOBUF_NODISCARD std::string* release_required_platform_version();
  void set_allocated_required_platform_version(std::string* required_platform_version);
  private:
  const std::string& _internal_required_platform_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_required_platform_version(const std::string& value);
  std::string* _internal_mutable_required_platform_version();
  public:

  // optional bool error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  bool error() const;
  void set_error(bool value);
  private:
  bool _internal_error() const;
  void _internal_set_error(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AppStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_platform_version_;
    bool error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AppInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInfo) */ {
 public:
  inline AppInfo() : AppInfo(nullptr) {}
  ~AppInfo() override;
  explicit PROTOBUF_CONSTEXPR AppInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInfo(const AppInfo& from);
  AppInfo(AppInfo&& from) noexcept
    : AppInfo() {
    *this = ::std::move(from);
  }

  inline AppInfo& operator=(const AppInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInfo& operator=(AppInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInfo* internal_default_instance() {
    return reinterpret_cast<const AppInfo*>(
               &_AppInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(AppInfo& a, AppInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AppInfo& from);
  void MergeFrom(const AppInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AppInfo";
  }
  protected:
  explicit AppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AppInfo_AppType AppType;
  static constexpr AppType TYPE_UNKNOWN =
    AppInfo_AppType_TYPE_UNKNOWN;
  static constexpr AppType TYPE_ARC =
    AppInfo_AppType_TYPE_ARC;
  static constexpr AppType TYPE_BUILTIN =
    AppInfo_AppType_TYPE_BUILTIN;
  static constexpr AppType TYPE_CROSTINI =
    AppInfo_AppType_TYPE_CROSTINI;
  static constexpr AppType TYPE_EXTENSION =
    AppInfo_AppType_TYPE_EXTENSION;
  static constexpr AppType TYPE_WEB =
    AppInfo_AppType_TYPE_WEB;
  static constexpr AppType TYPE_PLUGINVM =
    AppInfo_AppType_TYPE_PLUGINVM;
  static constexpr AppType TYPE_BOREALIS =
    AppInfo_AppType_TYPE_BOREALIS;
  static constexpr AppType TYPE_BRUSCHETTA =
    AppInfo_AppType_TYPE_BRUSCHETTA;
  static inline bool AppType_IsValid(int value) {
    return AppInfo_AppType_IsValid(value);
  }
  static constexpr AppType AppType_MIN =
    AppInfo_AppType_AppType_MIN;
  static constexpr AppType AppType_MAX =
    AppInfo_AppType_AppType_MAX;
  static constexpr int AppType_ARRAYSIZE =
    AppInfo_AppType_AppType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AppType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AppType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AppType_Name.");
    return AppInfo_AppType_Name(enum_t_value);
  }
  static inline bool AppType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AppType* value) {
    return AppInfo_AppType_Parse(name, value);
  }

  typedef AppInfo_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    AppInfo_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_INSTALLED =
    AppInfo_Status_STATUS_INSTALLED;
  static constexpr Status STATUS_DISABLED =
    AppInfo_Status_STATUS_DISABLED;
  static constexpr Status STATUS_UNINSTALLED =
    AppInfo_Status_STATUS_UNINSTALLED;
  static inline bool Status_IsValid(int value) {
    return AppInfo_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    AppInfo_Status_Status_MIN;
  static constexpr Status Status_MAX =
    AppInfo_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    AppInfo_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return AppInfo_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return AppInfo_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActiveTimePeriodsFieldNumber = 8,
    kAppIdFieldNumber = 1,
    kAppNameFieldNumber = 3,
    kVersionFieldNumber = 7,
    kAppTypeFieldNumber = 2,
    kStatusFieldNumber = 4,
    kInstallTimeFieldNumber = 5,
  };
  // repeated .enterprise_management.TimePeriod active_time_periods = 8;
  int active_time_periods_size() const;
  private:
  int _internal_active_time_periods_size() const;
  public:
  void clear_active_time_periods();
  ::enterprise_management::TimePeriod* mutable_active_time_periods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >*
      mutable_active_time_periods();
  private:
  const ::enterprise_management::TimePeriod& _internal_active_time_periods(int index) const;
  ::enterprise_management::TimePeriod* _internal_add_active_time_periods();
  public:
  const ::enterprise_management::TimePeriod& active_time_periods(int index) const;
  ::enterprise_management::TimePeriod* add_active_time_periods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >&
      active_time_periods() const;

  // optional string app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // optional string app_name = 3;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // optional string version = 7;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional .enterprise_management.AppInfo.AppType app_type = 2;
  bool has_app_type() const;
  private:
  bool _internal_has_app_type() const;
  public:
  void clear_app_type();
  ::enterprise_management::AppInfo_AppType app_type() const;
  void set_app_type(::enterprise_management::AppInfo_AppType value);
  private:
  ::enterprise_management::AppInfo_AppType _internal_app_type() const;
  void _internal_set_app_type(::enterprise_management::AppInfo_AppType value);
  public:

  // optional .enterprise_management.AppInfo.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::enterprise_management::AppInfo_Status status() const;
  void set_status(::enterprise_management::AppInfo_Status value);
  private:
  ::enterprise_management::AppInfo_Status _internal_status() const;
  void _internal_set_status(::enterprise_management::AppInfo_Status value);
  public:

  // optional int64 install_time = 5;
  bool has_install_time() const;
  private:
  bool _internal_has_install_time() const;
  public:
  void clear_install_time();
  int64_t install_time() const;
  void set_install_time(int64_t value);
  private:
  int64_t _internal_install_time() const;
  void _internal_set_install_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AppInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod > active_time_periods_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    int app_type_;
    int status_;
    int64_t install_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AndroidAppPermission final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AndroidAppPermission) */ {
 public:
  inline AndroidAppPermission() : AndroidAppPermission(nullptr) {}
  ~AndroidAppPermission() override;
  explicit PROTOBUF_CONSTEXPR AndroidAppPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AndroidAppPermission(const AndroidAppPermission& from);
  AndroidAppPermission(AndroidAppPermission&& from) noexcept
    : AndroidAppPermission() {
    *this = ::std::move(from);
  }

  inline AndroidAppPermission& operator=(const AndroidAppPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndroidAppPermission& operator=(AndroidAppPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AndroidAppPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndroidAppPermission* internal_default_instance() {
    return reinterpret_cast<const AndroidAppPermission*>(
               &_AndroidAppPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(AndroidAppPermission& a, AndroidAppPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(AndroidAppPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndroidAppPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndroidAppPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AndroidAppPermission>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AndroidAppPermission& from);
  void MergeFrom(const AndroidAppPermission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidAppPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AndroidAppPermission";
  }
  protected:
  explicit AndroidAppPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kGrantedFieldNumber = 2,
    kManagedFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool granted = 2;
  bool has_granted() const;
  private:
  bool _internal_has_granted() const;
  public:
  void clear_granted();
  bool granted() const;
  void set_granted(bool value);
  private:
  bool _internal_granted() const;
  void _internal_set_granted(bool value);
  public:

  // optional bool managed = 3;
  bool has_managed() const;
  private:
  bool _internal_has_managed() const;
  public:
  void clear_managed();
  bool managed() const;
  void set_managed(bool value);
  private:
  bool _internal_managed() const;
  void _internal_set_managed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AndroidAppPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool granted_;
    bool managed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AndroidAppInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AndroidAppInfo) */ {
 public:
  inline AndroidAppInfo() : AndroidAppInfo(nullptr) {}
  ~AndroidAppInfo() override;
  explicit PROTOBUF_CONSTEXPR AndroidAppInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AndroidAppInfo(const AndroidAppInfo& from);
  AndroidAppInfo(AndroidAppInfo&& from) noexcept
    : AndroidAppInfo() {
    *this = ::std::move(from);
  }

  inline AndroidAppInfo& operator=(const AndroidAppInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndroidAppInfo& operator=(AndroidAppInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AndroidAppInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndroidAppInfo* internal_default_instance() {
    return reinterpret_cast<const AndroidAppInfo*>(
               &_AndroidAppInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(AndroidAppInfo& a, AndroidAppInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AndroidAppInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndroidAppInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndroidAppInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AndroidAppInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AndroidAppInfo& from);
  void MergeFrom(const AndroidAppInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidAppInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AndroidAppInfo";
  }
  protected:
  explicit AndroidAppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AndroidAppInfo_AndroidAppStatus AndroidAppStatus;
  static constexpr AndroidAppStatus STATUS_UNKNOWN =
    AndroidAppInfo_AndroidAppStatus_STATUS_UNKNOWN;
  static constexpr AndroidAppStatus STATUS_ENABLED =
    AndroidAppInfo_AndroidAppStatus_STATUS_ENABLED;
  static constexpr AndroidAppStatus STATUS_SUSPENDED =
    AndroidAppInfo_AndroidAppStatus_STATUS_SUSPENDED;
  static constexpr AndroidAppStatus STATUS_DISABLED =
    AndroidAppInfo_AndroidAppStatus_STATUS_DISABLED;
  static inline bool AndroidAppStatus_IsValid(int value) {
    return AndroidAppInfo_AndroidAppStatus_IsValid(value);
  }
  static constexpr AndroidAppStatus AndroidAppStatus_MIN =
    AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MIN;
  static constexpr AndroidAppStatus AndroidAppStatus_MAX =
    AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_MAX;
  static constexpr int AndroidAppStatus_ARRAYSIZE =
    AndroidAppInfo_AndroidAppStatus_AndroidAppStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AndroidAppStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AndroidAppStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AndroidAppStatus_Name.");
    return AndroidAppInfo_AndroidAppStatus_Name(enum_t_value);
  }
  static inline bool AndroidAppStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AndroidAppStatus* value) {
    return AndroidAppInfo_AndroidAppStatus_Parse(name, value);
  }

  typedef AndroidAppInfo_InstalledSource InstalledSource;
  static constexpr InstalledSource SOURCE_UNKNOWN =
    AndroidAppInfo_InstalledSource_SOURCE_UNKNOWN;
  static constexpr InstalledSource SOURCE_BY_ADMIN =
    AndroidAppInfo_InstalledSource_SOURCE_BY_ADMIN;
  static constexpr InstalledSource SOURCE_BY_USER =
    AndroidAppInfo_InstalledSource_SOURCE_BY_USER;
  static constexpr InstalledSource SOURCE_NOT_INSTALLED =
    AndroidAppInfo_InstalledSource_SOURCE_NOT_INSTALLED;
  static inline bool InstalledSource_IsValid(int value) {
    return AndroidAppInfo_InstalledSource_IsValid(value);
  }
  static constexpr InstalledSource InstalledSource_MIN =
    AndroidAppInfo_InstalledSource_InstalledSource_MIN;
  static constexpr InstalledSource InstalledSource_MAX =
    AndroidAppInfo_InstalledSource_InstalledSource_MAX;
  static constexpr int InstalledSource_ARRAYSIZE =
    AndroidAppInfo_InstalledSource_InstalledSource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InstalledSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InstalledSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InstalledSource_Name.");
    return AndroidAppInfo_InstalledSource_Name(enum_t_value);
  }
  static inline bool InstalledSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InstalledSource* value) {
    return AndroidAppInfo_InstalledSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 7,
    kAppIdFieldNumber = 1,
    kAppNameFieldNumber = 2,
    kPackageNameFieldNumber = 3,
    kStatusFieldNumber = 4,
    kInstalledSourceFieldNumber = 5,
    kVersionFieldNumber = 6,
  };
  // repeated .enterprise_management.AndroidAppPermission permissions = 7;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::enterprise_management::AndroidAppPermission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission >*
      mutable_permissions();
  private:
  const ::enterprise_management::AndroidAppPermission& _internal_permissions(int index) const;
  ::enterprise_management::AndroidAppPermission* _internal_add_permissions();
  public:
  const ::enterprise_management::AndroidAppPermission& permissions(int index) const;
  ::enterprise_management::AndroidAppPermission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission >&
      permissions() const;

  // optional string app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // optional string app_name = 2;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // optional string package_name = 3;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // optional .enterprise_management.AndroidAppInfo.AndroidAppStatus status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::enterprise_management::AndroidAppInfo_AndroidAppStatus status() const;
  void set_status(::enterprise_management::AndroidAppInfo_AndroidAppStatus value);
  private:
  ::enterprise_management::AndroidAppInfo_AndroidAppStatus _internal_status() const;
  void _internal_set_status(::enterprise_management::AndroidAppInfo_AndroidAppStatus value);
  public:

  // optional .enterprise_management.AndroidAppInfo.InstalledSource installed_source = 5;
  bool has_installed_source() const;
  private:
  bool _internal_has_installed_source() const;
  public:
  void clear_installed_source();
  ::enterprise_management::AndroidAppInfo_InstalledSource installed_source() const;
  void set_installed_source(::enterprise_management::AndroidAppInfo_InstalledSource value);
  private:
  ::enterprise_management::AndroidAppInfo_InstalledSource _internal_installed_source() const;
  void _internal_set_installed_source(::enterprise_management::AndroidAppInfo_InstalledSource value);
  public:

  // optional int32 version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AndroidAppInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission > permissions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int status_;
    int installed_source_;
    int32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeUserProfileReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeUserProfileReport) */ {
 public:
  inline ChromeUserProfileReport() : ChromeUserProfileReport(nullptr) {}
  ~ChromeUserProfileReport() override;
  explicit PROTOBUF_CONSTEXPR ChromeUserProfileReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeUserProfileReport(const ChromeUserProfileReport& from);
  ChromeUserProfileReport(ChromeUserProfileReport&& from) noexcept
    : ChromeUserProfileReport() {
    *this = ::std::move(from);
  }

  inline ChromeUserProfileReport& operator=(const ChromeUserProfileReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeUserProfileReport& operator=(ChromeUserProfileReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeUserProfileReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeUserProfileReport* internal_default_instance() {
    return reinterpret_cast<const ChromeUserProfileReport*>(
               &_ChromeUserProfileReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(ChromeUserProfileReport& a, ChromeUserProfileReport& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeUserProfileReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeUserProfileReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeUserProfileReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeUserProfileReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeUserProfileReport& from);
  void MergeFrom(const ChromeUserProfileReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeUserProfileReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeUserProfileReport";
  }
  protected:
  explicit ChromeUserProfileReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionRequestsFieldNumber = 10,
    kIdFieldNumber = 1,
    kChromeSignedInUserFieldNumber = 2,
    kExtensionDataFieldNumber = 3,
    kPluginsFieldNumber = 4,
    kPolicyDataFieldNumber = 5,
    kNameFieldNumber = 9,
    kPolicyFetchedTimestampFieldNumber = 6,
    kSafeBrowsingWarningsFieldNumber = 7,
    kSafeBrowsingWarningsClickThroughFieldNumber = 8,
  };
  // repeated .enterprise_management.ExtensionRequest extension_requests = 10;
  int extension_requests_size() const;
  private:
  int _internal_extension_requests_size() const;
  public:
  void clear_extension_requests();
  ::enterprise_management::ExtensionRequest* mutable_extension_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >*
      mutable_extension_requests();
  private:
  const ::enterprise_management::ExtensionRequest& _internal_extension_requests(int index) const;
  ::enterprise_management::ExtensionRequest* _internal_add_extension_requests();
  public:
  const ::enterprise_management::ExtensionRequest& extension_requests(int index) const;
  ::enterprise_management::ExtensionRequest* add_extension_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >&
      extension_requests() const;

  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string chrome_signed_in_user = 2;
  bool has_chrome_signed_in_user() const;
  private:
  bool _internal_has_chrome_signed_in_user() const;
  public:
  void clear_chrome_signed_in_user();
  const std::string& chrome_signed_in_user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chrome_signed_in_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chrome_signed_in_user();
  PROTOBUF_NODISCARD std::string* release_chrome_signed_in_user();
  void set_allocated_chrome_signed_in_user(std::string* chrome_signed_in_user);
  private:
  const std::string& _internal_chrome_signed_in_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chrome_signed_in_user(const std::string& value);
  std::string* _internal_mutable_chrome_signed_in_user();
  public:

  // optional string extension_data = 3;
  bool has_extension_data() const;
  private:
  bool _internal_has_extension_data() const;
  public:
  void clear_extension_data();
  const std::string& extension_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension_data();
  PROTOBUF_NODISCARD std::string* release_extension_data();
  void set_allocated_extension_data(std::string* extension_data);
  private:
  const std::string& _internal_extension_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_data(const std::string& value);
  std::string* _internal_mutable_extension_data();
  public:

  // optional string plugins = 4;
  bool has_plugins() const;
  private:
  bool _internal_has_plugins() const;
  public:
  void clear_plugins();
  const std::string& plugins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugins();
  PROTOBUF_NODISCARD std::string* release_plugins();
  void set_allocated_plugins(std::string* plugins);
  private:
  const std::string& _internal_plugins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugins(const std::string& value);
  std::string* _internal_mutable_plugins();
  public:

  // optional string policy_data = 5;
  bool has_policy_data() const;
  private:
  bool _internal_has_policy_data() const;
  public:
  void clear_policy_data();
  const std::string& policy_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_data();
  PROTOBUF_NODISCARD std::string* release_policy_data();
  void set_allocated_policy_data(std::string* policy_data);
  private:
  const std::string& _internal_policy_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_data(const std::string& value);
  std::string* _internal_mutable_policy_data();
  public:

  // optional string name = 9;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int64 policy_fetched_timestamp = 6;
  bool has_policy_fetched_timestamp() const;
  private:
  bool _internal_has_policy_fetched_timestamp() const;
  public:
  void clear_policy_fetched_timestamp();
  int64_t policy_fetched_timestamp() const;
  void set_policy_fetched_timestamp(int64_t value);
  private:
  int64_t _internal_policy_fetched_timestamp() const;
  void _internal_set_policy_fetched_timestamp(int64_t value);
  public:

  // optional uint64 safe_browsing_warnings = 7;
  bool has_safe_browsing_warnings() const;
  private:
  bool _internal_has_safe_browsing_warnings() const;
  public:
  void clear_safe_browsing_warnings();
  uint64_t safe_browsing_warnings() const;
  void set_safe_browsing_warnings(uint64_t value);
  private:
  uint64_t _internal_safe_browsing_warnings() const;
  void _internal_set_safe_browsing_warnings(uint64_t value);
  public:

  // optional uint64 safe_browsing_warnings_click_through = 8;
  bool has_safe_browsing_warnings_click_through() const;
  private:
  bool _internal_has_safe_browsing_warnings_click_through() const;
  public:
  void clear_safe_browsing_warnings_click_through();
  uint64_t safe_browsing_warnings_click_through() const;
  void set_safe_browsing_warnings_click_through(uint64_t value);
  private:
  uint64_t _internal_safe_browsing_warnings_click_through() const;
  void _internal_set_safe_browsing_warnings_click_through(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeUserProfileReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest > extension_requests_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chrome_signed_in_user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugins_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t policy_fetched_timestamp_;
    uint64_t safe_browsing_warnings_;
    uint64_t safe_browsing_warnings_click_through_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeSignedInUser final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeSignedInUser) */ {
 public:
  inline ChromeSignedInUser() : ChromeSignedInUser(nullptr) {}
  ~ChromeSignedInUser() override;
  explicit PROTOBUF_CONSTEXPR ChromeSignedInUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeSignedInUser(const ChromeSignedInUser& from);
  ChromeSignedInUser(ChromeSignedInUser&& from) noexcept
    : ChromeSignedInUser() {
    *this = ::std::move(from);
  }

  inline ChromeSignedInUser& operator=(const ChromeSignedInUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeSignedInUser& operator=(ChromeSignedInUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeSignedInUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeSignedInUser* internal_default_instance() {
    return reinterpret_cast<const ChromeSignedInUser*>(
               &_ChromeSignedInUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ChromeSignedInUser& a, ChromeSignedInUser& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeSignedInUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeSignedInUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeSignedInUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeSignedInUser>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeSignedInUser& from);
  void MergeFrom(const ChromeSignedInUser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeSignedInUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeSignedInUser";
  }
  protected:
  explicit ChromeSignedInUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kObfuscatedGaiaIdFieldNumber = 2,
  };
  // optional string email = 1;
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // optional string obfuscated_gaia_id = 2;
  bool has_obfuscated_gaia_id() const;
  private:
  bool _internal_has_obfuscated_gaia_id() const;
  public:
  void clear_obfuscated_gaia_id();
  const std::string& obfuscated_gaia_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obfuscated_gaia_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obfuscated_gaia_id();
  PROTOBUF_NODISCARD std::string* release_obfuscated_gaia_id();
  void set_allocated_obfuscated_gaia_id(std::string* obfuscated_gaia_id);
  private:
  const std::string& _internal_obfuscated_gaia_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obfuscated_gaia_id(const std::string& value);
  std::string* _internal_mutable_obfuscated_gaia_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeSignedInUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obfuscated_gaia_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ExtensionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionRequest) */ {
 public:
  inline ExtensionRequest() : ExtensionRequest(nullptr) {}
  ~ExtensionRequest() override;
  explicit PROTOBUF_CONSTEXPR ExtensionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionRequest(const ExtensionRequest& from);
  ExtensionRequest(ExtensionRequest&& from) noexcept
    : ExtensionRequest() {
    *this = ::std::move(from);
  }

  inline ExtensionRequest& operator=(const ExtensionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionRequest& operator=(ExtensionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionRequest* internal_default_instance() {
    return reinterpret_cast<const ExtensionRequest*>(
               &_ExtensionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ExtensionRequest& a, ExtensionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtensionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionRequest& from);
  void MergeFrom(const ExtensionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ExtensionRequest";
  }
  protected:
  explicit ExtensionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kJustificationFieldNumber = 3,
    kRequestTimestampFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string justification = 3;
  bool has_justification() const;
  private:
  bool _internal_has_justification() const;
  public:
  void clear_justification();
  const std::string& justification() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_justification(ArgT0&& arg0, ArgT... args);
  std::string* mutable_justification();
  PROTOBUF_NODISCARD std::string* release_justification();
  void set_allocated_justification(std::string* justification);
  private:
  const std::string& _internal_justification() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_justification(const std::string& value);
  std::string* _internal_mutable_justification();
  public:

  // optional int64 request_timestamp = 2;
  bool has_request_timestamp() const;
  private:
  bool _internal_has_request_timestamp() const;
  public:
  void clear_request_timestamp();
  int64_t request_timestamp() const;
  void set_request_timestamp(int64_t value);
  private:
  int64_t _internal_request_timestamp() const;
  void _internal_set_request_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ExtensionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr justification_;
    int64_t request_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class Extension final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.Extension) */ {
 public:
  inline Extension() : Extension(nullptr) {}
  ~Extension() override;
  explicit PROTOBUF_CONSTEXPR Extension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Extension(const Extension& from);
  Extension(Extension&& from) noexcept
    : Extension() {
    *this = ::std::move(from);
  }

  inline Extension& operator=(const Extension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extension& operator=(Extension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Extension& default_instance() {
    return *internal_default_instance();
  }
  static inline const Extension* internal_default_instance() {
    return reinterpret_cast<const Extension*>(
               &_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(Extension& a, Extension& b) {
    a.Swap(&b);
  }
  inline void Swap(Extension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Extension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Extension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Extension& from);
  void MergeFrom(const Extension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Extension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.Extension";
  }
  protected:
  explicit Extension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Extension_ExtensionType ExtensionType;
  static constexpr ExtensionType TYPE_UNKNOWN =
    Extension_ExtensionType_TYPE_UNKNOWN;
  static constexpr ExtensionType TYPE_EXTENSION =
    Extension_ExtensionType_TYPE_EXTENSION;
  static constexpr ExtensionType TYPE_HOSTED_APP =
    Extension_ExtensionType_TYPE_HOSTED_APP;
  static constexpr ExtensionType TYPE_PACKAGED_APP =
    Extension_ExtensionType_TYPE_PACKAGED_APP;
  static constexpr ExtensionType TYPE_LEGACY_PACKAGED_APP =
    Extension_ExtensionType_TYPE_LEGACY_PACKAGED_APP;
  static constexpr ExtensionType TYPE_THEME =
    Extension_ExtensionType_TYPE_THEME;
  static constexpr ExtensionType TYPE_USER_SCRIPT =
    Extension_ExtensionType_TYPE_USER_SCRIPT;
  static constexpr ExtensionType TYPE_PLATFORM_APP =
    Extension_ExtensionType_TYPE_PLATFORM_APP;
  static constexpr ExtensionType TYPE_LOGIN_SCREEN_EXTENSION =
    Extension_ExtensionType_TYPE_LOGIN_SCREEN_EXTENSION;
  static constexpr ExtensionType TYPE_CHROMEOS_SYSTEM_EXTENSION =
    Extension_ExtensionType_TYPE_CHROMEOS_SYSTEM_EXTENSION;
  static inline bool ExtensionType_IsValid(int value) {
    return Extension_ExtensionType_IsValid(value);
  }
  static constexpr ExtensionType ExtensionType_MIN =
    Extension_ExtensionType_ExtensionType_MIN;
  static constexpr ExtensionType ExtensionType_MAX =
    Extension_ExtensionType_ExtensionType_MAX;
  static constexpr int ExtensionType_ARRAYSIZE =
    Extension_ExtensionType_ExtensionType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ExtensionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExtensionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExtensionType_Name.");
    return Extension_ExtensionType_Name(enum_t_value);
  }
  static inline bool ExtensionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExtensionType* value) {
    return Extension_ExtensionType_Parse(name, value);
  }

  typedef Extension_InstallType InstallType;
  static constexpr InstallType TYPE_NORMAL =
    Extension_InstallType_TYPE_NORMAL;
  static constexpr InstallType TYPE_DEVELOPMENT =
    Extension_InstallType_TYPE_DEVELOPMENT;
  static constexpr InstallType TYPE_SIDELOAD =
    Extension_InstallType_TYPE_SIDELOAD;
  static constexpr InstallType TYPE_ADMIN =
    Extension_InstallType_TYPE_ADMIN;
  static constexpr InstallType TYPE_OTHER =
    Extension_InstallType_TYPE_OTHER;
  static inline bool InstallType_IsValid(int value) {
    return Extension_InstallType_IsValid(value);
  }
  static constexpr InstallType InstallType_MIN =
    Extension_InstallType_InstallType_MIN;
  static constexpr InstallType InstallType_MAX =
    Extension_InstallType_InstallType_MAX;
  static constexpr int InstallType_ARRAYSIZE =
    Extension_InstallType_InstallType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InstallType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InstallType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InstallType_Name.");
    return Extension_InstallType_Name(enum_t_value);
  }
  static inline bool InstallType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InstallType* value) {
    return Extension_InstallType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 10,
    kHostPermissionsFieldNumber = 11,
    kIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kHomepageUrlFieldNumber = 6,
    kAppTypeFieldNumber = 5,
    kInstallTypeFieldNumber = 8,
    kEnabledFieldNumber = 9,
    kFromWebstoreFieldNumber = 13,
    kManifestVersionFieldNumber = 14,
  };
  // repeated string permissions = 10;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  const std::string& permissions(int index) const;
  std::string* mutable_permissions(int index);
  void set_permissions(int index, const std::string& value);
  void set_permissions(int index, std::string&& value);
  void set_permissions(int index, const char* value);
  void set_permissions(int index, const char* value, size_t size);
  std::string* add_permissions();
  void add_permissions(const std::string& value);
  void add_permissions(std::string&& value);
  void add_permissions(const char* value);
  void add_permissions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_permissions();
  private:
  const std::string& _internal_permissions(int index) const;
  std::string* _internal_add_permissions();
  public:

  // repeated string host_permissions = 11;
  int host_permissions_size() const;
  private:
  int _internal_host_permissions_size() const;
  public:
  void clear_host_permissions();
  const std::string& host_permissions(int index) const;
  std::string* mutable_host_permissions(int index);
  void set_host_permissions(int index, const std::string& value);
  void set_host_permissions(int index, std::string&& value);
  void set_host_permissions(int index, const char* value);
  void set_host_permissions(int index, const char* value, size_t size);
  std::string* add_host_permissions();
  void add_host_permissions(const std::string& value);
  void add_host_permissions(std::string&& value);
  void add_host_permissions(const char* value);
  void add_host_permissions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& host_permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_host_permissions();
  private:
  const std::string& _internal_host_permissions(int index) const;
  std::string* _internal_add_host_permissions();
  public:

  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string homepage_url = 6;
  bool has_homepage_url() const;
  private:
  bool _internal_has_homepage_url() const;
  public:
  void clear_homepage_url();
  const std::string& homepage_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_homepage_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_homepage_url();
  PROTOBUF_NODISCARD std::string* release_homepage_url();
  void set_allocated_homepage_url(std::string* homepage_url);
  private:
  const std::string& _internal_homepage_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_homepage_url(const std::string& value);
  std::string* _internal_mutable_homepage_url();
  public:

  // optional .enterprise_management.Extension.ExtensionType app_type = 5;
  bool has_app_type() const;
  private:
  bool _internal_has_app_type() const;
  public:
  void clear_app_type();
  ::enterprise_management::Extension_ExtensionType app_type() const;
  void set_app_type(::enterprise_management::Extension_ExtensionType value);
  private:
  ::enterprise_management::Extension_ExtensionType _internal_app_type() const;
  void _internal_set_app_type(::enterprise_management::Extension_ExtensionType value);
  public:

  // optional .enterprise_management.Extension.InstallType install_type = 8;
  bool has_install_type() const;
  private:
  bool _internal_has_install_type() const;
  public:
  void clear_install_type();
  ::enterprise_management::Extension_InstallType install_type() const;
  void set_install_type(::enterprise_management::Extension_InstallType value);
  private:
  ::enterprise_management::Extension_InstallType _internal_install_type() const;
  void _internal_set_install_type(::enterprise_management::Extension_InstallType value);
  public:

  // optional bool enabled = 9;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional bool from_webstore = 13;
  bool has_from_webstore() const;
  private:
  bool _internal_has_from_webstore() const;
  public:
  void clear_from_webstore();
  bool from_webstore() const;
  void set_from_webstore(bool value);
  private:
  bool _internal_from_webstore() const;
  void _internal_set_from_webstore(bool value);
  public:

  // optional int32 manifest_version = 14;
  bool has_manifest_version() const;
  private:
  bool _internal_has_manifest_version() const;
  public:
  void clear_manifest_version();
  int32_t manifest_version() const;
  void set_manifest_version(int32_t value);
  private:
  int32_t _internal_manifest_version() const;
  void _internal_set_manifest_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.Extension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> permissions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> host_permissions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr homepage_url_;
    int app_type_;
    int install_type_;
    bool enabled_;
    bool from_webstore_;
    int32_t manifest_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class Plugin final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.Plugin) */ {
 public:
  inline Plugin() : Plugin(nullptr) {}
  ~Plugin() override;
  explicit PROTOBUF_CONSTEXPR Plugin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plugin(const Plugin& from);
  Plugin(Plugin&& from) noexcept
    : Plugin() {
    *this = ::std::move(from);
  }

  inline Plugin& operator=(const Plugin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plugin& operator=(Plugin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Plugin& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plugin* internal_default_instance() {
    return reinterpret_cast<const Plugin*>(
               &_Plugin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(Plugin& a, Plugin& b) {
    a.Swap(&b);
  }
  inline void Swap(Plugin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plugin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Plugin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Plugin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Plugin& from);
  void MergeFrom(const Plugin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Plugin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.Plugin";
  }
  protected:
  explicit Plugin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kFilenameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string filename = 3;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.Plugin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class Policy final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.Policy) */ {
 public:
  inline Policy() : Policy(nullptr) {}
  ~Policy() override;
  explicit PROTOBUF_CONSTEXPR Policy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Policy(const Policy& from);
  Policy(Policy&& from) noexcept
    : Policy() {
    *this = ::std::move(from);
  }

  inline Policy& operator=(const Policy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Policy& operator=(Policy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Policy& default_instance() {
    return *internal_default_instance();
  }
  static inline const Policy* internal_default_instance() {
    return reinterpret_cast<const Policy*>(
               &_Policy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(Policy& a, Policy& b) {
    a.Swap(&b);
  }
  inline void Swap(Policy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Policy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Policy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Policy>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Policy& from);
  void MergeFrom(const Policy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Policy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.Policy";
  }
  protected:
  explicit Policy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Policy_PolicyLevel PolicyLevel;
  static constexpr PolicyLevel LEVEL_UNKNOWN =
    Policy_PolicyLevel_LEVEL_UNKNOWN;
  static constexpr PolicyLevel LEVEL_RECOMMENDED =
    Policy_PolicyLevel_LEVEL_RECOMMENDED;
  static constexpr PolicyLevel LEVEL_MANDATORY =
    Policy_PolicyLevel_LEVEL_MANDATORY;
  static inline bool PolicyLevel_IsValid(int value) {
    return Policy_PolicyLevel_IsValid(value);
  }
  static constexpr PolicyLevel PolicyLevel_MIN =
    Policy_PolicyLevel_PolicyLevel_MIN;
  static constexpr PolicyLevel PolicyLevel_MAX =
    Policy_PolicyLevel_PolicyLevel_MAX;
  static constexpr int PolicyLevel_ARRAYSIZE =
    Policy_PolicyLevel_PolicyLevel_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PolicyLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PolicyLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PolicyLevel_Name.");
    return Policy_PolicyLevel_Name(enum_t_value);
  }
  static inline bool PolicyLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PolicyLevel* value) {
    return Policy_PolicyLevel_Parse(name, value);
  }

  typedef Policy_PolicyScope PolicyScope;
  static constexpr PolicyScope SCOPE_UNKNOWN =
    Policy_PolicyScope_SCOPE_UNKNOWN;
  static constexpr PolicyScope SCOPE_USER =
    Policy_PolicyScope_SCOPE_USER;
  static constexpr PolicyScope SCOPE_MACHINE =
    Policy_PolicyScope_SCOPE_MACHINE;
  static inline bool PolicyScope_IsValid(int value) {
    return Policy_PolicyScope_IsValid(value);
  }
  static constexpr PolicyScope PolicyScope_MIN =
    Policy_PolicyScope_PolicyScope_MIN;
  static constexpr PolicyScope PolicyScope_MAX =
    Policy_PolicyScope_PolicyScope_MAX;
  static constexpr int PolicyScope_ARRAYSIZE =
    Policy_PolicyScope_PolicyScope_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PolicyScope_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PolicyScope>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PolicyScope_Name.");
    return Policy_PolicyScope_Name(enum_t_value);
  }
  static inline bool PolicyScope_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PolicyScope* value) {
    return Policy_PolicyScope_Parse(name, value);
  }

  typedef Policy_PolicySource PolicySource;
  static constexpr PolicySource SOURCE_UNKNOWN =
    Policy_PolicySource_SOURCE_UNKNOWN;
  static constexpr PolicySource SOURCE_ENTERPRISE_DEFAULT =
    Policy_PolicySource_SOURCE_ENTERPRISE_DEFAULT;
  static constexpr PolicySource SOURCE_CLOUD =
    Policy_PolicySource_SOURCE_CLOUD;
  static constexpr PolicySource SOURCE_ACTIVE_DIRECTORY =
    Policy_PolicySource_SOURCE_ACTIVE_DIRECTORY;
  static constexpr PolicySource SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE_DEPRECATED =
    Policy_PolicySource_SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE_DEPRECATED;
  static constexpr PolicySource SOURCE_PLATFORM =
    Policy_PolicySource_SOURCE_PLATFORM;
  static constexpr PolicySource SOURCE_PRIORITY_CLOUD_DEPRECATED =
    Policy_PolicySource_SOURCE_PRIORITY_CLOUD_DEPRECATED;
  static constexpr PolicySource SOURCE_MERGED =
    Policy_PolicySource_SOURCE_MERGED;
  static constexpr PolicySource SOURCE_COMMAND_LINE =
    Policy_PolicySource_SOURCE_COMMAND_LINE;
  static constexpr PolicySource SOURCE_CLOUD_FROM_ASH =
    Policy_PolicySource_SOURCE_CLOUD_FROM_ASH;
  static constexpr PolicySource SOURCE_RESTRICTED_MANAGED_GUEST_SESSION_OVERRIDE =
    Policy_PolicySource_SOURCE_RESTRICTED_MANAGED_GUEST_SESSION_OVERRIDE;
  static inline bool PolicySource_IsValid(int value) {
    return Policy_PolicySource_IsValid(value);
  }
  static constexpr PolicySource PolicySource_MIN =
    Policy_PolicySource_PolicySource_MIN;
  static constexpr PolicySource PolicySource_MAX =
    Policy_PolicySource_PolicySource_MAX;
  static constexpr int PolicySource_ARRAYSIZE =
    Policy_PolicySource_PolicySource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PolicySource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PolicySource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PolicySource_Name.");
    return Policy_PolicySource_Name(enum_t_value);
  }
  static inline bool PolicySource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PolicySource* value) {
    return Policy_PolicySource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 5,
    kErrorFieldNumber = 6,
    kLevelFieldNumber = 2,
    kScopeFieldNumber = 3,
    kSourceFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string value = 5;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional string error = 6;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional .enterprise_management.Policy.PolicyLevel level = 2;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  ::enterprise_management::Policy_PolicyLevel level() const;
  void set_level(::enterprise_management::Policy_PolicyLevel value);
  private:
  ::enterprise_management::Policy_PolicyLevel _internal_level() const;
  void _internal_set_level(::enterprise_management::Policy_PolicyLevel value);
  public:

  // optional .enterprise_management.Policy.PolicyScope scope = 3;
  bool has_scope() const;
  private:
  bool _internal_has_scope() const;
  public:
  void clear_scope();
  ::enterprise_management::Policy_PolicyScope scope() const;
  void set_scope(::enterprise_management::Policy_PolicyScope value);
  private:
  ::enterprise_management::Policy_PolicyScope _internal_scope() const;
  void _internal_set_scope(::enterprise_management::Policy_PolicyScope value);
  public:

  // optional .enterprise_management.Policy.PolicySource source = 4;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  ::enterprise_management::Policy_PolicySource source() const;
  void set_source(::enterprise_management::Policy_PolicySource value);
  private:
  ::enterprise_management::Policy_PolicySource _internal_source() const;
  void _internal_set_source(::enterprise_management::Policy_PolicySource value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.Policy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int level_;
    int scope_;
    int source_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ExtensionPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionPolicy) */ {
 public:
  inline ExtensionPolicy() : ExtensionPolicy(nullptr) {}
  ~ExtensionPolicy() override;
  explicit PROTOBUF_CONSTEXPR ExtensionPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionPolicy(const ExtensionPolicy& from);
  ExtensionPolicy(ExtensionPolicy&& from) noexcept
    : ExtensionPolicy() {
    *this = ::std::move(from);
  }

  inline ExtensionPolicy& operator=(const ExtensionPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionPolicy& operator=(ExtensionPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionPolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionPolicy* internal_default_instance() {
    return reinterpret_cast<const ExtensionPolicy*>(
               &_ExtensionPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ExtensionPolicy& a, ExtensionPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtensionPolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionPolicy>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionPolicy& from);
  void MergeFrom(const ExtensionPolicy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionPolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ExtensionPolicy";
  }
  protected:
  explicit ExtensionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoliciesFieldNumber = 2,
    kExtensionIdFieldNumber = 1,
  };
  // repeated .enterprise_management.Policy policies = 2;
  int policies_size() const;
  private:
  int _internal_policies_size() const;
  public:
  void clear_policies();
  ::enterprise_management::Policy* mutable_policies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >*
      mutable_policies();
  private:
  const ::enterprise_management::Policy& _internal_policies(int index) const;
  ::enterprise_management::Policy* _internal_add_policies();
  public:
  const ::enterprise_management::Policy& policies(int index) const;
  ::enterprise_management::Policy* add_policies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >&
      policies() const;

  // optional string extension_id = 1;
  bool has_extension_id() const;
  private:
  bool _internal_has_extension_id() const;
  public:
  void clear_extension_id();
  const std::string& extension_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension_id();
  PROTOBUF_NODISCARD std::string* release_extension_id();
  void set_allocated_extension_id(std::string* extension_id);
  private:
  const std::string& _internal_extension_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_id(const std::string& value);
  std::string* _internal_mutable_extension_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ExtensionPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy > policies_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PolicyFetchTimestamp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyFetchTimestamp) */ {
 public:
  inline PolicyFetchTimestamp() : PolicyFetchTimestamp(nullptr) {}
  ~PolicyFetchTimestamp() override;
  explicit PROTOBUF_CONSTEXPR PolicyFetchTimestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyFetchTimestamp(const PolicyFetchTimestamp& from);
  PolicyFetchTimestamp(PolicyFetchTimestamp&& from) noexcept
    : PolicyFetchTimestamp() {
    *this = ::std::move(from);
  }

  inline PolicyFetchTimestamp& operator=(const PolicyFetchTimestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyFetchTimestamp& operator=(PolicyFetchTimestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PolicyFetchTimestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyFetchTimestamp* internal_default_instance() {
    return reinterpret_cast<const PolicyFetchTimestamp*>(
               &_PolicyFetchTimestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(PolicyFetchTimestamp& a, PolicyFetchTimestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyFetchTimestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyFetchTimestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyFetchTimestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyFetchTimestamp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PolicyFetchTimestamp& from);
  void MergeFrom(const PolicyFetchTimestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PolicyFetchTimestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PolicyFetchTimestamp";
  }
  protected:
  explicit PolicyFetchTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // optional string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PolicyFetchTimestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeUserProfileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeUserProfileInfo) */ {
 public:
  inline ChromeUserProfileInfo() : ChromeUserProfileInfo(nullptr) {}
  ~ChromeUserProfileInfo() override;
  explicit PROTOBUF_CONSTEXPR ChromeUserProfileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeUserProfileInfo(const ChromeUserProfileInfo& from);
  ChromeUserProfileInfo(ChromeUserProfileInfo&& from) noexcept
    : ChromeUserProfileInfo() {
    *this = ::std::move(from);
  }

  inline ChromeUserProfileInfo& operator=(const ChromeUserProfileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeUserProfileInfo& operator=(ChromeUserProfileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeUserProfileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeUserProfileInfo* internal_default_instance() {
    return reinterpret_cast<const ChromeUserProfileInfo*>(
               &_ChromeUserProfileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(ChromeUserProfileInfo& a, ChromeUserProfileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeUserProfileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeUserProfileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeUserProfileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeUserProfileInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeUserProfileInfo& from);
  void MergeFrom(const ChromeUserProfileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeUserProfileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeUserProfileInfo";
  }
  protected:
  explicit ChromeUserProfileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 5,
    kChromePoliciesFieldNumber = 7,
    kExtensionPoliciesFieldNumber = 8,
    kPolicyFetchedTimestampsFieldNumber = 9,
    kExtensionRequestsFieldNumber = 10,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kChromeSignedInUserFieldNumber = 4,
    kIsDetailAvailableFieldNumber = 3,
  };
  // repeated .enterprise_management.Extension extensions = 5;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  ::enterprise_management::Extension* mutable_extensions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension >*
      mutable_extensions();
  private:
  const ::enterprise_management::Extension& _internal_extensions(int index) const;
  ::enterprise_management::Extension* _internal_add_extensions();
  public:
  const ::enterprise_management::Extension& extensions(int index) const;
  ::enterprise_management::Extension* add_extensions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension >&
      extensions() const;

  // repeated .enterprise_management.Policy chrome_policies = 7;
  int chrome_policies_size() const;
  private:
  int _internal_chrome_policies_size() const;
  public:
  void clear_chrome_policies();
  ::enterprise_management::Policy* mutable_chrome_policies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >*
      mutable_chrome_policies();
  private:
  const ::enterprise_management::Policy& _internal_chrome_policies(int index) const;
  ::enterprise_management::Policy* _internal_add_chrome_policies();
  public:
  const ::enterprise_management::Policy& chrome_policies(int index) const;
  ::enterprise_management::Policy* add_chrome_policies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >&
      chrome_policies() const;

  // repeated .enterprise_management.ExtensionPolicy extension_policies = 8;
  int extension_policies_size() const;
  private:
  int _internal_extension_policies_size() const;
  public:
  void clear_extension_policies();
  ::enterprise_management::ExtensionPolicy* mutable_extension_policies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy >*
      mutable_extension_policies();
  private:
  const ::enterprise_management::ExtensionPolicy& _internal_extension_policies(int index) const;
  ::enterprise_management::ExtensionPolicy* _internal_add_extension_policies();
  public:
  const ::enterprise_management::ExtensionPolicy& extension_policies(int index) const;
  ::enterprise_management::ExtensionPolicy* add_extension_policies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy >&
      extension_policies() const;

  // repeated .enterprise_management.PolicyFetchTimestamp policy_fetched_timestamps = 9;
  int policy_fetched_timestamps_size() const;
  private:
  int _internal_policy_fetched_timestamps_size() const;
  public:
  void clear_policy_fetched_timestamps();
  ::enterprise_management::PolicyFetchTimestamp* mutable_policy_fetched_timestamps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp >*
      mutable_policy_fetched_timestamps();
  private:
  const ::enterprise_management::PolicyFetchTimestamp& _internal_policy_fetched_timestamps(int index) const;
  ::enterprise_management::PolicyFetchTimestamp* _internal_add_policy_fetched_timestamps();
  public:
  const ::enterprise_management::PolicyFetchTimestamp& policy_fetched_timestamps(int index) const;
  ::enterprise_management::PolicyFetchTimestamp* add_policy_fetched_timestamps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp >&
      policy_fetched_timestamps() const;

  // repeated .enterprise_management.ExtensionRequest extension_requests = 10;
  int extension_requests_size() const;
  private:
  int _internal_extension_requests_size() const;
  public:
  void clear_extension_requests();
  ::enterprise_management::ExtensionRequest* mutable_extension_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >*
      mutable_extension_requests();
  private:
  const ::enterprise_management::ExtensionRequest& _internal_extension_requests(int index) const;
  ::enterprise_management::ExtensionRequest* _internal_add_extension_requests();
  public:
  const ::enterprise_management::ExtensionRequest& extension_requests(int index) const;
  ::enterprise_management::ExtensionRequest* add_extension_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >&
      extension_requests() const;

  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .enterprise_management.ChromeSignedInUser chrome_signed_in_user = 4;
  bool has_chrome_signed_in_user() const;
  private:
  bool _internal_has_chrome_signed_in_user() const;
  public:
  void clear_chrome_signed_in_user();
  const ::enterprise_management::ChromeSignedInUser& chrome_signed_in_user() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChromeSignedInUser* release_chrome_signed_in_user();
  ::enterprise_management::ChromeSignedInUser* mutable_chrome_signed_in_user();
  void set_allocated_chrome_signed_in_user(::enterprise_management::ChromeSignedInUser* chrome_signed_in_user);
  private:
  const ::enterprise_management::ChromeSignedInUser& _internal_chrome_signed_in_user() const;
  ::enterprise_management::ChromeSignedInUser* _internal_mutable_chrome_signed_in_user();
  public:
  void unsafe_arena_set_allocated_chrome_signed_in_user(
      ::enterprise_management::ChromeSignedInUser* chrome_signed_in_user);
  ::enterprise_management::ChromeSignedInUser* unsafe_arena_release_chrome_signed_in_user();

  // optional bool is_detail_available = 3;
  bool has_is_detail_available() const;
  private:
  bool _internal_has_is_detail_available() const;
  public:
  void clear_is_detail_available();
  bool is_detail_available() const;
  void set_is_detail_available(bool value);
  private:
  bool _internal_is_detail_available() const;
  void _internal_set_is_detail_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeUserProfileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension > extensions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy > chrome_policies_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy > extension_policies_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp > policy_fetched_timestamps_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest > extension_requests_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::enterprise_management::ChromeSignedInUser* chrome_signed_in_user_;
    bool is_detail_available_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BrowserReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BrowserReport) */ {
 public:
  inline BrowserReport() : BrowserReport(nullptr) {}
  ~BrowserReport() override;
  explicit PROTOBUF_CONSTEXPR BrowserReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrowserReport(const BrowserReport& from);
  BrowserReport(BrowserReport&& from) noexcept
    : BrowserReport() {
    *this = ::std::move(from);
  }

  inline BrowserReport& operator=(const BrowserReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrowserReport& operator=(BrowserReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BrowserReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrowserReport* internal_default_instance() {
    return reinterpret_cast<const BrowserReport*>(
               &_BrowserReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(BrowserReport& a, BrowserReport& b) {
    a.Swap(&b);
  }
  inline void Swap(BrowserReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrowserReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrowserReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrowserReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BrowserReport& from);
  void MergeFrom(const BrowserReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrowserReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BrowserReport";
  }
  protected:
  explicit BrowserReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChromeUserProfileReportsFieldNumber = 4,
    kChromeUserProfileInfosFieldNumber = 6,
    kPluginsFieldNumber = 7,
    kBrowserVersionFieldNumber = 1,
    kExecutablePathFieldNumber = 3,
    kInstalledBrowserVersionFieldNumber = 8,
    kChannelFieldNumber = 2,
    kIsExtendedStableChannelFieldNumber = 9,
  };
  // repeated .enterprise_management.ChromeUserProfileReport chrome_user_profile_reports = 4;
  int chrome_user_profile_reports_size() const;
  private:
  int _internal_chrome_user_profile_reports_size() const;
  public:
  void clear_chrome_user_profile_reports();
  ::enterprise_management::ChromeUserProfileReport* mutable_chrome_user_profile_reports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport >*
      mutable_chrome_user_profile_reports();
  private:
  const ::enterprise_management::ChromeUserProfileReport& _internal_chrome_user_profile_reports(int index) const;
  ::enterprise_management::ChromeUserProfileReport* _internal_add_chrome_user_profile_reports();
  public:
  const ::enterprise_management::ChromeUserProfileReport& chrome_user_profile_reports(int index) const;
  ::enterprise_management::ChromeUserProfileReport* add_chrome_user_profile_reports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport >&
      chrome_user_profile_reports() const;

  // repeated .enterprise_management.ChromeUserProfileInfo chrome_user_profile_infos = 6;
  int chrome_user_profile_infos_size() const;
  private:
  int _internal_chrome_user_profile_infos_size() const;
  public:
  void clear_chrome_user_profile_infos();
  ::enterprise_management::ChromeUserProfileInfo* mutable_chrome_user_profile_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo >*
      mutable_chrome_user_profile_infos();
  private:
  const ::enterprise_management::ChromeUserProfileInfo& _internal_chrome_user_profile_infos(int index) const;
  ::enterprise_management::ChromeUserProfileInfo* _internal_add_chrome_user_profile_infos();
  public:
  const ::enterprise_management::ChromeUserProfileInfo& chrome_user_profile_infos(int index) const;
  ::enterprise_management::ChromeUserProfileInfo* add_chrome_user_profile_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo >&
      chrome_user_profile_infos() const;

  // repeated .enterprise_management.Plugin plugins = 7;
  int plugins_size() const;
  private:
  int _internal_plugins_size() const;
  public:
  void clear_plugins();
  ::enterprise_management::Plugin* mutable_plugins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin >*
      mutable_plugins();
  private:
  const ::enterprise_management::Plugin& _internal_plugins(int index) const;
  ::enterprise_management::Plugin* _internal_add_plugins();
  public:
  const ::enterprise_management::Plugin& plugins(int index) const;
  ::enterprise_management::Plugin* add_plugins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin >&
      plugins() const;

  // optional string browser_version = 1;
  bool has_browser_version() const;
  private:
  bool _internal_has_browser_version() const;
  public:
  void clear_browser_version();
  const std::string& browser_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_version();
  PROTOBUF_NODISCARD std::string* release_browser_version();
  void set_allocated_browser_version(std::string* browser_version);
  private:
  const std::string& _internal_browser_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_version(const std::string& value);
  std::string* _internal_mutable_browser_version();
  public:

  // optional string executable_path = 3;
  bool has_executable_path() const;
  private:
  bool _internal_has_executable_path() const;
  public:
  void clear_executable_path();
  const std::string& executable_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_executable_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_executable_path();
  PROTOBUF_NODISCARD std::string* release_executable_path();
  void set_allocated_executable_path(std::string* executable_path);
  private:
  const std::string& _internal_executable_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_executable_path(const std::string& value);
  std::string* _internal_mutable_executable_path();
  public:

  // optional string installed_browser_version = 8;
  bool has_installed_browser_version() const;
  private:
  bool _internal_has_installed_browser_version() const;
  public:
  void clear_installed_browser_version();
  const std::string& installed_browser_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_installed_browser_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_installed_browser_version();
  PROTOBUF_NODISCARD std::string* release_installed_browser_version();
  void set_allocated_installed_browser_version(std::string* installed_browser_version);
  private:
  const std::string& _internal_installed_browser_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installed_browser_version(const std::string& value);
  std::string* _internal_mutable_installed_browser_version();
  public:

  // optional .enterprise_management.Channel channel = 2;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  ::enterprise_management::Channel channel() const;
  void set_channel(::enterprise_management::Channel value);
  private:
  ::enterprise_management::Channel _internal_channel() const;
  void _internal_set_channel(::enterprise_management::Channel value);
  public:

  // optional bool is_extended_stable_channel = 9 [default = false];
  bool has_is_extended_stable_channel() const;
  private:
  bool _internal_has_is_extended_stable_channel() const;
  public:
  void clear_is_extended_stable_channel();
  bool is_extended_stable_channel() const;
  void set_is_extended_stable_channel(bool value);
  private:
  bool _internal_is_extended_stable_channel() const;
  void _internal_set_is_extended_stable_channel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BrowserReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport > chrome_user_profile_reports_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo > chrome_user_profile_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin > plugins_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr executable_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installed_browser_version_;
    int channel_;
    bool is_extended_stable_channel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class OSReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.OSReport) */ {
 public:
  inline OSReport() : OSReport(nullptr) {}
  ~OSReport() override;
  explicit PROTOBUF_CONSTEXPR OSReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OSReport(const OSReport& from);
  OSReport(OSReport&& from) noexcept
    : OSReport() {
    *this = ::std::move(from);
  }

  inline OSReport& operator=(const OSReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline OSReport& operator=(OSReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OSReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const OSReport* internal_default_instance() {
    return reinterpret_cast<const OSReport*>(
               &_OSReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(OSReport& a, OSReport& b) {
    a.Swap(&b);
  }
  inline void Swap(OSReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OSReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OSReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OSReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OSReport& from);
  void MergeFrom(const OSReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OSReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.OSReport";
  }
  protected:
  explicit OSReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef OSReport_VersionType VersionType;
  static constexpr VersionType UNKNOWN =
    OSReport_VersionType_UNKNOWN;
  static constexpr VersionType HOME =
    OSReport_VersionType_HOME;
  static constexpr VersionType PROFESSIONAL =
    OSReport_VersionType_PROFESSIONAL;
  static constexpr VersionType SERVER =
    OSReport_VersionType_SERVER;
  static constexpr VersionType ENTERPRISE =
    OSReport_VersionType_ENTERPRISE;
  static constexpr VersionType EDUCATION =
    OSReport_VersionType_EDUCATION;
  static constexpr VersionType EDUCATION_PRO =
    OSReport_VersionType_EDUCATION_PRO;
  static inline bool VersionType_IsValid(int value) {
    return OSReport_VersionType_IsValid(value);
  }
  static constexpr VersionType VersionType_MIN =
    OSReport_VersionType_VersionType_MIN;
  static constexpr VersionType VersionType_MAX =
    OSReport_VersionType_VersionType_MAX;
  static constexpr int VersionType_ARRAYSIZE =
    OSReport_VersionType_VersionType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& VersionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VersionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VersionType_Name.");
    return OSReport_VersionType_Name(enum_t_value);
  }
  static inline bool VersionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VersionType* value) {
    return OSReport_VersionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kArchFieldNumber = 2,
    kVersionFieldNumber = 3,
    kVersionTypeFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string arch = 2;
  bool has_arch() const;
  private:
  bool _internal_has_arch() const;
  public:
  void clear_arch();
  const std::string& arch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arch();
  PROTOBUF_NODISCARD std::string* release_arch();
  void set_allocated_arch(std::string* arch);
  private:
  const std::string& _internal_arch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arch(const std::string& value);
  std::string* _internal_mutable_arch();
  public:

  // optional string version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional .enterprise_management.OSReport.VersionType version_type = 4;
  bool has_version_type() const;
  private:
  bool _internal_has_version_type() const;
  public:
  void clear_version_type();
  ::enterprise_management::OSReport_VersionType version_type() const;
  void set_version_type(::enterprise_management::OSReport_VersionType value);
  private:
  ::enterprise_management::OSReport_VersionType _internal_version_type() const;
  void _internal_set_version_type(::enterprise_management::OSReport_VersionType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.OSReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    int version_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeDesktopReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeDesktopReportRequest) */ {
 public:
  inline ChromeDesktopReportRequest() : ChromeDesktopReportRequest(nullptr) {}
  ~ChromeDesktopReportRequest() override;
  explicit PROTOBUF_CONSTEXPR ChromeDesktopReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeDesktopReportRequest(const ChromeDesktopReportRequest& from);
  ChromeDesktopReportRequest(ChromeDesktopReportRequest&& from) noexcept
    : ChromeDesktopReportRequest() {
    *this = ::std::move(from);
  }

  inline ChromeDesktopReportRequest& operator=(const ChromeDesktopReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeDesktopReportRequest& operator=(ChromeDesktopReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeDesktopReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeDesktopReportRequest* internal_default_instance() {
    return reinterpret_cast<const ChromeDesktopReportRequest*>(
               &_ChromeDesktopReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(ChromeDesktopReportRequest& a, ChromeDesktopReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeDesktopReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeDesktopReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeDesktopReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeDesktopReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeDesktopReportRequest& from);
  void MergeFrom(const ChromeDesktopReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeDesktopReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeDesktopReportRequest";
  }
  protected:
  explicit ChromeDesktopReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartialReportTypesFieldNumber = 10,
    kMachineNameFieldNumber = 1,
    kOsInfoFieldNumber = 2,
    kOsUserFieldNumber = 3,
    kSerialNumberFieldNumber = 5,
    kComputerNameFieldNumber = 6,
    kOsUserNameFieldNumber = 8,
    kMachineAttestationKeyFieldNumber = 11,
    kDeviceModelFieldNumber = 12,
    kBrandNameFieldNumber = 13,
    kBrowserReportFieldNumber = 4,
    kOsReportFieldNumber = 7,
    kBrowserDeviceIdentifierFieldNumber = 9,
  };
  // repeated .enterprise_management.PartialReportType partial_report_types = 10;
  int partial_report_types_size() const;
  private:
  int _internal_partial_report_types_size() const;
  public:
  void clear_partial_report_types();
  private:
  ::enterprise_management::PartialReportType _internal_partial_report_types(int index) const;
  void _internal_add_partial_report_types(::enterprise_management::PartialReportType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_partial_report_types();
  public:
  ::enterprise_management::PartialReportType partial_report_types(int index) const;
  void set_partial_report_types(int index, ::enterprise_management::PartialReportType value);
  void add_partial_report_types(::enterprise_management::PartialReportType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& partial_report_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_partial_report_types();

  // optional string machine_name = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_machine_name() const;
  private:
  bool _internal_has_machine_name() const;
  public:
  PROTOBUF_DEPRECATED void clear_machine_name();
  PROTOBUF_DEPRECATED const std::string& machine_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_machine_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_machine_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_machine_name();
  PROTOBUF_DEPRECATED void set_allocated_machine_name(std::string* machine_name);
  private:
  const std::string& _internal_machine_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_name(const std::string& value);
  std::string* _internal_mutable_machine_name();
  public:

  // optional string os_info = 2;
  bool has_os_info() const;
  private:
  bool _internal_has_os_info() const;
  public:
  void clear_os_info();
  const std::string& os_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_info();
  PROTOBUF_NODISCARD std::string* release_os_info();
  void set_allocated_os_info(std::string* os_info);
  private:
  const std::string& _internal_os_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_info(const std::string& value);
  std::string* _internal_mutable_os_info();
  public:

  // optional string os_user = 3;
  bool has_os_user() const;
  private:
  bool _internal_has_os_user() const;
  public:
  void clear_os_user();
  const std::string& os_user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_user();
  PROTOBUF_NODISCARD std::string* release_os_user();
  void set_allocated_os_user(std::string* os_user);
  private:
  const std::string& _internal_os_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_user(const std::string& value);
  std::string* _internal_mutable_os_user();
  public:

  // optional string serial_number = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_serial_number() const;
  private:
  bool _internal_has_serial_number() const;
  public:
  PROTOBUF_DEPRECATED void clear_serial_number();
  PROTOBUF_DEPRECATED const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_serial_number(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_serial_number();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_serial_number();
  PROTOBUF_DEPRECATED void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // optional string computer_name = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_computer_name() const;
  private:
  bool _internal_has_computer_name() const;
  public:
  PROTOBUF_DEPRECATED void clear_computer_name();
  PROTOBUF_DEPRECATED const std::string& computer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_computer_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_computer_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_computer_name();
  PROTOBUF_DEPRECATED void set_allocated_computer_name(std::string* computer_name);
  private:
  const std::string& _internal_computer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_computer_name(const std::string& value);
  std::string* _internal_mutable_computer_name();
  public:

  // optional string os_user_name = 8;
  bool has_os_user_name() const;
  private:
  bool _internal_has_os_user_name() const;
  public:
  void clear_os_user_name();
  const std::string& os_user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_user_name();
  PROTOBUF_NODISCARD std::string* release_os_user_name();
  void set_allocated_os_user_name(std::string* os_user_name);
  private:
  const std::string& _internal_os_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_user_name(const std::string& value);
  std::string* _internal_mutable_os_user_name();
  public:

  // optional string machine_attestation_key = 11;
  bool has_machine_attestation_key() const;
  private:
  bool _internal_has_machine_attestation_key() const;
  public:
  void clear_machine_attestation_key();
  const std::string& machine_attestation_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_attestation_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_attestation_key();
  PROTOBUF_NODISCARD std::string* release_machine_attestation_key();
  void set_allocated_machine_attestation_key(std::string* machine_attestation_key);
  private:
  const std::string& _internal_machine_attestation_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_attestation_key(const std::string& value);
  std::string* _internal_mutable_machine_attestation_key();
  public:

  // optional string device_model = 12;
  bool has_device_model() const;
  private:
  bool _internal_has_device_model() const;
  public:
  void clear_device_model();
  const std::string& device_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_model();
  PROTOBUF_NODISCARD std::string* release_device_model();
  void set_allocated_device_model(std::string* device_model);
  private:
  const std::string& _internal_device_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_model(const std::string& value);
  std::string* _internal_mutable_device_model();
  public:

  // optional string brand_name = 13;
  bool has_brand_name() const;
  private:
  bool _internal_has_brand_name() const;
  public:
  void clear_brand_name();
  const std::string& brand_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brand_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brand_name();
  PROTOBUF_NODISCARD std::string* release_brand_name();
  void set_allocated_brand_name(std::string* brand_name);
  private:
  const std::string& _internal_brand_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brand_name(const std::string& value);
  std::string* _internal_mutable_brand_name();
  public:

  // optional .enterprise_management.BrowserReport browser_report = 4;
  bool has_browser_report() const;
  private:
  bool _internal_has_browser_report() const;
  public:
  void clear_browser_report();
  const ::enterprise_management::BrowserReport& browser_report() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserReport* release_browser_report();
  ::enterprise_management::BrowserReport* mutable_browser_report();
  void set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report);
  private:
  const ::enterprise_management::BrowserReport& _internal_browser_report() const;
  ::enterprise_management::BrowserReport* _internal_mutable_browser_report();
  public:
  void unsafe_arena_set_allocated_browser_report(
      ::enterprise_management::BrowserReport* browser_report);
  ::enterprise_management::BrowserReport* unsafe_arena_release_browser_report();

  // optional .enterprise_management.OSReport os_report = 7;
  bool has_os_report() const;
  private:
  bool _internal_has_os_report() const;
  public:
  void clear_os_report();
  const ::enterprise_management::OSReport& os_report() const;
  PROTOBUF_NODISCARD ::enterprise_management::OSReport* release_os_report();
  ::enterprise_management::OSReport* mutable_os_report();
  void set_allocated_os_report(::enterprise_management::OSReport* os_report);
  private:
  const ::enterprise_management::OSReport& _internal_os_report() const;
  ::enterprise_management::OSReport* _internal_mutable_os_report();
  public:
  void unsafe_arena_set_allocated_os_report(
      ::enterprise_management::OSReport* os_report);
  ::enterprise_management::OSReport* unsafe_arena_release_os_report();

  // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 9;
  bool has_browser_device_identifier() const;
  private:
  bool _internal_has_browser_device_identifier() const;
  public:
  void clear_browser_device_identifier();
  const ::enterprise_management::BrowserDeviceIdentifier& browser_device_identifier() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserDeviceIdentifier* release_browser_device_identifier();
  ::enterprise_management::BrowserDeviceIdentifier* mutable_browser_device_identifier();
  void set_allocated_browser_device_identifier(::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier);
  private:
  const ::enterprise_management::BrowserDeviceIdentifier& _internal_browser_device_identifier() const;
  ::enterprise_management::BrowserDeviceIdentifier* _internal_mutable_browser_device_identifier();
  public:
  void unsafe_arena_set_allocated_browser_device_identifier(
      ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier);
  ::enterprise_management::BrowserDeviceIdentifier* unsafe_arena_release_browser_device_identifier();

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeDesktopReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> partial_report_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr computer_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_attestation_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_name_;
    ::enterprise_management::BrowserReport* browser_report_;
    ::enterprise_management::OSReport* os_report_;
    ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeOsUserReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeOsUserReportRequest) */ {
 public:
  inline ChromeOsUserReportRequest() : ChromeOsUserReportRequest(nullptr) {}
  ~ChromeOsUserReportRequest() override;
  explicit PROTOBUF_CONSTEXPR ChromeOsUserReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeOsUserReportRequest(const ChromeOsUserReportRequest& from);
  ChromeOsUserReportRequest(ChromeOsUserReportRequest&& from) noexcept
    : ChromeOsUserReportRequest() {
    *this = ::std::move(from);
  }

  inline ChromeOsUserReportRequest& operator=(const ChromeOsUserReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeOsUserReportRequest& operator=(ChromeOsUserReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeOsUserReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeOsUserReportRequest* internal_default_instance() {
    return reinterpret_cast<const ChromeOsUserReportRequest*>(
               &_ChromeOsUserReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(ChromeOsUserReportRequest& a, ChromeOsUserReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeOsUserReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeOsUserReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeOsUserReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeOsUserReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeOsUserReportRequest& from);
  void MergeFrom(const ChromeOsUserReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeOsUserReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeOsUserReportRequest";
  }
  protected:
  explicit ChromeOsUserReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAndroidAppInfosFieldNumber = 2,
    kPartialReportTypesFieldNumber = 3,
    kBrowserReportFieldNumber = 1,
  };
  // repeated .enterprise_management.AndroidAppInfo android_app_infos = 2;
  int android_app_infos_size() const;
  private:
  int _internal_android_app_infos_size() const;
  public:
  void clear_android_app_infos();
  ::enterprise_management::AndroidAppInfo* mutable_android_app_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo >*
      mutable_android_app_infos();
  private:
  const ::enterprise_management::AndroidAppInfo& _internal_android_app_infos(int index) const;
  ::enterprise_management::AndroidAppInfo* _internal_add_android_app_infos();
  public:
  const ::enterprise_management::AndroidAppInfo& android_app_infos(int index) const;
  ::enterprise_management::AndroidAppInfo* add_android_app_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo >&
      android_app_infos() const;

  // repeated .enterprise_management.PartialReportType partial_report_types = 3;
  int partial_report_types_size() const;
  private:
  int _internal_partial_report_types_size() const;
  public:
  void clear_partial_report_types();
  private:
  ::enterprise_management::PartialReportType _internal_partial_report_types(int index) const;
  void _internal_add_partial_report_types(::enterprise_management::PartialReportType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_partial_report_types();
  public:
  ::enterprise_management::PartialReportType partial_report_types(int index) const;
  void set_partial_report_types(int index, ::enterprise_management::PartialReportType value);
  void add_partial_report_types(::enterprise_management::PartialReportType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& partial_report_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_partial_report_types();

  // optional .enterprise_management.BrowserReport browser_report = 1;
  bool has_browser_report() const;
  private:
  bool _internal_has_browser_report() const;
  public:
  void clear_browser_report();
  const ::enterprise_management::BrowserReport& browser_report() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserReport* release_browser_report();
  ::enterprise_management::BrowserReport* mutable_browser_report();
  void set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report);
  private:
  const ::enterprise_management::BrowserReport& _internal_browser_report() const;
  ::enterprise_management::BrowserReport* _internal_mutable_browser_report();
  public:
  void unsafe_arena_set_allocated_browser_report(
      ::enterprise_management::BrowserReport* browser_report);
  ::enterprise_management::BrowserReport* unsafe_arena_release_browser_report();

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeOsUserReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo > android_app_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> partial_report_types_;
    ::enterprise_management::BrowserReport* browser_report_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeProfileReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeProfileReportRequest) */ {
 public:
  inline ChromeProfileReportRequest() : ChromeProfileReportRequest(nullptr) {}
  ~ChromeProfileReportRequest() override;
  explicit PROTOBUF_CONSTEXPR ChromeProfileReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeProfileReportRequest(const ChromeProfileReportRequest& from);
  ChromeProfileReportRequest(ChromeProfileReportRequest&& from) noexcept
    : ChromeProfileReportRequest() {
    *this = ::std::move(from);
  }

  inline ChromeProfileReportRequest& operator=(const ChromeProfileReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeProfileReportRequest& operator=(ChromeProfileReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeProfileReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeProfileReportRequest* internal_default_instance() {
    return reinterpret_cast<const ChromeProfileReportRequest*>(
               &_ChromeProfileReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(ChromeProfileReportRequest& a, ChromeProfileReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeProfileReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeProfileReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeProfileReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeProfileReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeProfileReportRequest& from);
  void MergeFrom(const ChromeProfileReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeProfileReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeProfileReportRequest";
  }
  protected:
  explicit ChromeProfileReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBrowserReportFieldNumber = 1,
    kOsReportFieldNumber = 2,
  };
  // optional .enterprise_management.BrowserReport browser_report = 1;
  bool has_browser_report() const;
  private:
  bool _internal_has_browser_report() const;
  public:
  void clear_browser_report();
  const ::enterprise_management::BrowserReport& browser_report() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserReport* release_browser_report();
  ::enterprise_management::BrowserReport* mutable_browser_report();
  void set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report);
  private:
  const ::enterprise_management::BrowserReport& _internal_browser_report() const;
  ::enterprise_management::BrowserReport* _internal_mutable_browser_report();
  public:
  void unsafe_arena_set_allocated_browser_report(
      ::enterprise_management::BrowserReport* browser_report);
  ::enterprise_management::BrowserReport* unsafe_arena_release_browser_report();

  // optional .enterprise_management.OSReport os_report = 2;
  bool has_os_report() const;
  private:
  bool _internal_has_os_report() const;
  public:
  void clear_os_report();
  const ::enterprise_management::OSReport& os_report() const;
  PROTOBUF_NODISCARD ::enterprise_management::OSReport* release_os_report();
  ::enterprise_management::OSReport* mutable_os_report();
  void set_allocated_os_report(::enterprise_management::OSReport* os_report);
  private:
  const ::enterprise_management::OSReport& _internal_os_report() const;
  ::enterprise_management::OSReport* _internal_mutable_os_report();
  public:
  void unsafe_arena_set_allocated_os_report(
      ::enterprise_management::OSReport* os_report);
  ::enterprise_management::OSReport* unsafe_arena_release_os_report();

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeProfileReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::BrowserReport* browser_report_;
    ::enterprise_management::OSReport* os_report_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PolicyValueValidationIssue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyValueValidationIssue) */ {
 public:
  inline PolicyValueValidationIssue() : PolicyValueValidationIssue(nullptr) {}
  ~PolicyValueValidationIssue() override;
  explicit PROTOBUF_CONSTEXPR PolicyValueValidationIssue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyValueValidationIssue(const PolicyValueValidationIssue& from);
  PolicyValueValidationIssue(PolicyValueValidationIssue&& from) noexcept
    : PolicyValueValidationIssue() {
    *this = ::std::move(from);
  }

  inline PolicyValueValidationIssue& operator=(const PolicyValueValidationIssue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyValueValidationIssue& operator=(PolicyValueValidationIssue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PolicyValueValidationIssue& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyValueValidationIssue* internal_default_instance() {
    return reinterpret_cast<const PolicyValueValidationIssue*>(
               &_PolicyValueValidationIssue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(PolicyValueValidationIssue& a, PolicyValueValidationIssue& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyValueValidationIssue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyValueValidationIssue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyValueValidationIssue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyValueValidationIssue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PolicyValueValidationIssue& from);
  void MergeFrom(const PolicyValueValidationIssue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PolicyValueValidationIssue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PolicyValueValidationIssue";
  }
  protected:
  explicit PolicyValueValidationIssue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PolicyValueValidationIssue_ValueValidationIssueSeverity ValueValidationIssueSeverity;
  static constexpr ValueValidationIssueSeverity VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED =
    PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED;
  static constexpr ValueValidationIssueSeverity VALUE_VALIDATION_ISSUE_SEVERITY_WARNING =
    PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_WARNING;
  static constexpr ValueValidationIssueSeverity VALUE_VALIDATION_ISSUE_SEVERITY_ERROR =
    PolicyValueValidationIssue_ValueValidationIssueSeverity_VALUE_VALIDATION_ISSUE_SEVERITY_ERROR;
  static inline bool ValueValidationIssueSeverity_IsValid(int value) {
    return PolicyValueValidationIssue_ValueValidationIssueSeverity_IsValid(value);
  }
  static constexpr ValueValidationIssueSeverity ValueValidationIssueSeverity_MIN =
    PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MIN;
  static constexpr ValueValidationIssueSeverity ValueValidationIssueSeverity_MAX =
    PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_MAX;
  static constexpr int ValueValidationIssueSeverity_ARRAYSIZE =
    PolicyValueValidationIssue_ValueValidationIssueSeverity_ValueValidationIssueSeverity_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ValueValidationIssueSeverity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ValueValidationIssueSeverity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ValueValidationIssueSeverity_Name.");
    return PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(enum_t_value);
  }
  static inline bool ValueValidationIssueSeverity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ValueValidationIssueSeverity* value) {
    return PolicyValueValidationIssue_ValueValidationIssueSeverity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyNameFieldNumber = 1,
    kDebugMessageFieldNumber = 3,
    kSeverityFieldNumber = 2,
  };
  // optional string policy_name = 1;
  bool has_policy_name() const;
  private:
  bool _internal_has_policy_name() const;
  public:
  void clear_policy_name();
  const std::string& policy_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_name();
  PROTOBUF_NODISCARD std::string* release_policy_name();
  void set_allocated_policy_name(std::string* policy_name);
  private:
  const std::string& _internal_policy_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_name(const std::string& value);
  std::string* _internal_mutable_policy_name();
  public:

  // optional string debug_message = 3;
  bool has_debug_message() const;
  private:
  bool _internal_has_debug_message() const;
  public:
  void clear_debug_message();
  const std::string& debug_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debug_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debug_message();
  PROTOBUF_NODISCARD std::string* release_debug_message();
  void set_allocated_debug_message(std::string* debug_message);
  private:
  const std::string& _internal_debug_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug_message(const std::string& value);
  std::string* _internal_mutable_debug_message();
  public:

  // optional .enterprise_management.PolicyValueValidationIssue.ValueValidationIssueSeverity severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity severity() const;
  void set_severity(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity value);
  private:
  ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity _internal_severity() const;
  void _internal_set_severity(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PolicyValueValidationIssue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_message_;
    int severity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PolicyValidationReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyValidationReportRequest) */ {
 public:
  inline PolicyValidationReportRequest() : PolicyValidationReportRequest(nullptr) {}
  ~PolicyValidationReportRequest() override;
  explicit PROTOBUF_CONSTEXPR PolicyValidationReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyValidationReportRequest(const PolicyValidationReportRequest& from);
  PolicyValidationReportRequest(PolicyValidationReportRequest&& from) noexcept
    : PolicyValidationReportRequest() {
    *this = ::std::move(from);
  }

  inline PolicyValidationReportRequest& operator=(const PolicyValidationReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyValidationReportRequest& operator=(PolicyValidationReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PolicyValidationReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyValidationReportRequest* internal_default_instance() {
    return reinterpret_cast<const PolicyValidationReportRequest*>(
               &_PolicyValidationReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(PolicyValidationReportRequest& a, PolicyValidationReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyValidationReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyValidationReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyValidationReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyValidationReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PolicyValidationReportRequest& from);
  void MergeFrom(const PolicyValidationReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PolicyValidationReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PolicyValidationReportRequest";
  }
  protected:
  explicit PolicyValidationReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PolicyValidationReportRequest_ValidationResultType ValidationResultType;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_SUCCESS =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_SUCCESS;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_SIGNATURE =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_SIGNATURE;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_TIMESTAMP =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_TIMESTAMP;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_DM_TOKEN =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_DM_TOKEN;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_DEVICE_ID =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_DEVICE_ID;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_USER =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_USER;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_VALUE_WARNING =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_WARNING;
  static constexpr ValidationResultType VALIDATION_RESULT_TYPE_VALUE_ERROR =
    PolicyValidationReportRequest_ValidationResultType_VALIDATION_RESULT_TYPE_VALUE_ERROR;
  static inline bool ValidationResultType_IsValid(int value) {
    return PolicyValidationReportRequest_ValidationResultType_IsValid(value);
  }
  static constexpr ValidationResultType ValidationResultType_MIN =
    PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MIN;
  static constexpr ValidationResultType ValidationResultType_MAX =
    PolicyValidationReportRequest_ValidationResultType_ValidationResultType_MAX;
  static constexpr int ValidationResultType_ARRAYSIZE =
    PolicyValidationReportRequest_ValidationResultType_ValidationResultType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ValidationResultType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ValidationResultType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ValidationResultType_Name.");
    return PolicyValidationReportRequest_ValidationResultType_Name(enum_t_value);
  }
  static inline bool ValidationResultType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ValidationResultType* value) {
    return PolicyValidationReportRequest_ValidationResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyValueValidationIssuesFieldNumber = 4,
    kPolicyTypeFieldNumber = 1,
    kPolicyTokenFieldNumber = 2,
    kValidationResultTypeFieldNumber = 3,
  };
  // repeated .enterprise_management.PolicyValueValidationIssue policy_value_validation_issues = 4;
  int policy_value_validation_issues_size() const;
  private:
  int _internal_policy_value_validation_issues_size() const;
  public:
  void clear_policy_value_validation_issues();
  ::enterprise_management::PolicyValueValidationIssue* mutable_policy_value_validation_issues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue >*
      mutable_policy_value_validation_issues();
  private:
  const ::enterprise_management::PolicyValueValidationIssue& _internal_policy_value_validation_issues(int index) const;
  ::enterprise_management::PolicyValueValidationIssue* _internal_add_policy_value_validation_issues();
  public:
  const ::enterprise_management::PolicyValueValidationIssue& policy_value_validation_issues(int index) const;
  ::enterprise_management::PolicyValueValidationIssue* add_policy_value_validation_issues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue >&
      policy_value_validation_issues() const;

  // optional string policy_type = 1;
  bool has_policy_type() const;
  private:
  bool _internal_has_policy_type() const;
  public:
  void clear_policy_type();
  const std::string& policy_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_type();
  PROTOBUF_NODISCARD std::string* release_policy_type();
  void set_allocated_policy_type(std::string* policy_type);
  private:
  const std::string& _internal_policy_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_type(const std::string& value);
  std::string* _internal_mutable_policy_type();
  public:

  // optional string policy_token = 2;
  bool has_policy_token() const;
  private:
  bool _internal_has_policy_token() const;
  public:
  void clear_policy_token();
  const std::string& policy_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_token();
  PROTOBUF_NODISCARD std::string* release_policy_token();
  void set_allocated_policy_token(std::string* policy_token);
  private:
  const std::string& _internal_policy_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_token(const std::string& value);
  std::string* _internal_mutable_policy_token();
  public:

  // optional .enterprise_management.PolicyValidationReportRequest.ValidationResultType validation_result_type = 3;
  bool has_validation_result_type() const;
  private:
  bool _internal_has_validation_result_type() const;
  public:
  void clear_validation_result_type();
  ::enterprise_management::PolicyValidationReportRequest_ValidationResultType validation_result_type() const;
  void set_validation_result_type(::enterprise_management::PolicyValidationReportRequest_ValidationResultType value);
  private:
  ::enterprise_management::PolicyValidationReportRequest_ValidationResultType _internal_validation_result_type() const;
  void _internal_set_validation_result_type(::enterprise_management::PolicyValidationReportRequest_ValidationResultType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PolicyValidationReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue > policy_value_validation_issues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_token_;
    int validation_result_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PolicyValidationReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PolicyValidationReportResponse) */ {
 public:
  inline PolicyValidationReportResponse() : PolicyValidationReportResponse(nullptr) {}
  ~PolicyValidationReportResponse() override;
  explicit PROTOBUF_CONSTEXPR PolicyValidationReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyValidationReportResponse(const PolicyValidationReportResponse& from);
  PolicyValidationReportResponse(PolicyValidationReportResponse&& from) noexcept
    : PolicyValidationReportResponse() {
    *this = ::std::move(from);
  }

  inline PolicyValidationReportResponse& operator=(const PolicyValidationReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyValidationReportResponse& operator=(PolicyValidationReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PolicyValidationReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyValidationReportResponse* internal_default_instance() {
    return reinterpret_cast<const PolicyValidationReportResponse*>(
               &_PolicyValidationReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(PolicyValidationReportResponse& a, PolicyValidationReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyValidationReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyValidationReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyValidationReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyValidationReportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PolicyValidationReportResponse& from);
  void MergeFrom(const PolicyValidationReportResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PolicyValidationReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PolicyValidationReportResponse";
  }
  protected:
  explicit PolicyValidationReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.PolicyValidationReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AndroidStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AndroidStatus) */ {
 public:
  inline AndroidStatus() : AndroidStatus(nullptr) {}
  ~AndroidStatus() override;
  explicit PROTOBUF_CONSTEXPR AndroidStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AndroidStatus(const AndroidStatus& from);
  AndroidStatus(AndroidStatus&& from) noexcept
    : AndroidStatus() {
    *this = ::std::move(from);
  }

  inline AndroidStatus& operator=(const AndroidStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndroidStatus& operator=(AndroidStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AndroidStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndroidStatus* internal_default_instance() {
    return reinterpret_cast<const AndroidStatus*>(
               &_AndroidStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(AndroidStatus& a, AndroidStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(AndroidStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndroidStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndroidStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AndroidStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AndroidStatus& from);
  void MergeFrom(const AndroidStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AndroidStatus";
  }
  protected:
  explicit AndroidStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusPayloadFieldNumber = 1,
    kDroidGuardInfoFieldNumber = 2,
  };
  // optional string status_payload = 1;
  bool has_status_payload() const;
  private:
  bool _internal_has_status_payload() const;
  public:
  void clear_status_payload();
  const std::string& status_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_payload();
  PROTOBUF_NODISCARD std::string* release_status_payload();
  void set_allocated_status_payload(std::string* status_payload);
  private:
  const std::string& _internal_status_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_payload(const std::string& value);
  std::string* _internal_mutable_status_payload();
  public:

  // optional string droid_guard_info = 2;
  bool has_droid_guard_info() const;
  private:
  bool _internal_has_droid_guard_info() const;
  public:
  void clear_droid_guard_info();
  const std::string& droid_guard_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_droid_guard_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_droid_guard_info();
  PROTOBUF_NODISCARD std::string* release_droid_guard_info();
  void set_allocated_droid_guard_info(std::string* droid_guard_info);
  private:
  const std::string& _internal_droid_guard_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_droid_guard_info(const std::string& value);
  std::string* _internal_mutable_droid_guard_info();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AndroidStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr droid_guard_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CrostiniApp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CrostiniApp) */ {
 public:
  inline CrostiniApp() : CrostiniApp(nullptr) {}
  ~CrostiniApp() override;
  explicit PROTOBUF_CONSTEXPR CrostiniApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrostiniApp(const CrostiniApp& from);
  CrostiniApp(CrostiniApp&& from) noexcept
    : CrostiniApp() {
    *this = ::std::move(from);
  }

  inline CrostiniApp& operator=(const CrostiniApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrostiniApp& operator=(CrostiniApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CrostiniApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrostiniApp* internal_default_instance() {
    return reinterpret_cast<const CrostiniApp*>(
               &_CrostiniApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(CrostiniApp& a, CrostiniApp& b) {
    a.Swap(&b);
  }
  inline void Swap(CrostiniApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrostiniApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrostiniApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrostiniApp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CrostiniApp& from);
  void MergeFrom(const CrostiniApp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CrostiniApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CrostiniApp";
  }
  protected:
  explicit CrostiniApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 1,
    kPackageNameFieldNumber = 4,
    kPackageVersionFieldNumber = 5,
    kPackageHashFieldNumber = 6,
    kLastLaunchTimeWindowStartTimestampFieldNumber = 3,
    kAppTypeFieldNumber = 2,
  };
  // optional string app_name = 1;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // optional string package_name = 4;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // optional string package_version = 5;
  bool has_package_version() const;
  private:
  bool _internal_has_package_version() const;
  public:
  void clear_package_version();
  const std::string& package_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_version();
  PROTOBUF_NODISCARD std::string* release_package_version();
  void set_allocated_package_version(std::string* package_version);
  private:
  const std::string& _internal_package_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_version(const std::string& value);
  std::string* _internal_mutable_package_version();
  public:

  // optional string package_hash = 6;
  bool has_package_hash() const;
  private:
  bool _internal_has_package_hash() const;
  public:
  void clear_package_hash();
  const std::string& package_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_hash();
  PROTOBUF_NODISCARD std::string* release_package_hash();
  void set_allocated_package_hash(std::string* package_hash);
  private:
  const std::string& _internal_package_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_hash(const std::string& value);
  std::string* _internal_mutable_package_hash();
  public:

  // optional int64 last_launch_time_window_start_timestamp = 3;
  bool has_last_launch_time_window_start_timestamp() const;
  private:
  bool _internal_has_last_launch_time_window_start_timestamp() const;
  public:
  void clear_last_launch_time_window_start_timestamp();
  int64_t last_launch_time_window_start_timestamp() const;
  void set_last_launch_time_window_start_timestamp(int64_t value);
  private:
  int64_t _internal_last_launch_time_window_start_timestamp() const;
  void _internal_set_last_launch_time_window_start_timestamp(int64_t value);
  public:

  // optional .enterprise_management.CrostiniAppType app_type = 2;
  bool has_app_type() const;
  private:
  bool _internal_has_app_type() const;
  public:
  void clear_app_type();
  ::enterprise_management::CrostiniAppType app_type() const;
  void set_app_type(::enterprise_management::CrostiniAppType value);
  private:
  ::enterprise_management::CrostiniAppType _internal_app_type() const;
  void _internal_set_app_type(::enterprise_management::CrostiniAppType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CrostiniApp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_hash_;
    int64_t last_launch_time_window_start_timestamp_;
    int app_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CrostiniStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CrostiniStatus) */ {
 public:
  inline CrostiniStatus() : CrostiniStatus(nullptr) {}
  ~CrostiniStatus() override;
  explicit PROTOBUF_CONSTEXPR CrostiniStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrostiniStatus(const CrostiniStatus& from);
  CrostiniStatus(CrostiniStatus&& from) noexcept
    : CrostiniStatus() {
    *this = ::std::move(from);
  }

  inline CrostiniStatus& operator=(const CrostiniStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrostiniStatus& operator=(CrostiniStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CrostiniStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrostiniStatus* internal_default_instance() {
    return reinterpret_cast<const CrostiniStatus*>(
               &_CrostiniStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(CrostiniStatus& a, CrostiniStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CrostiniStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrostiniStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrostiniStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrostiniStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CrostiniStatus& from);
  void MergeFrom(const CrostiniStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CrostiniStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CrostiniStatus";
  }
  protected:
  explicit CrostiniStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstalledAppsFieldNumber = 4,
    kLastLaunchVmImageVersionFieldNumber = 2,
    kLastLaunchVmKernelVersionFieldNumber = 3,
    kLastLaunchTimeWindowStartTimestampFieldNumber = 1,
  };
  // repeated .enterprise_management.CrostiniApp installed_apps = 4;
  int installed_apps_size() const;
  private:
  int _internal_installed_apps_size() const;
  public:
  void clear_installed_apps();
  ::enterprise_management::CrostiniApp* mutable_installed_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp >*
      mutable_installed_apps();
  private:
  const ::enterprise_management::CrostiniApp& _internal_installed_apps(int index) const;
  ::enterprise_management::CrostiniApp* _internal_add_installed_apps();
  public:
  const ::enterprise_management::CrostiniApp& installed_apps(int index) const;
  ::enterprise_management::CrostiniApp* add_installed_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp >&
      installed_apps() const;

  // optional string last_launch_vm_image_version = 2;
  bool has_last_launch_vm_image_version() const;
  private:
  bool _internal_has_last_launch_vm_image_version() const;
  public:
  void clear_last_launch_vm_image_version();
  const std::string& last_launch_vm_image_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_launch_vm_image_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_launch_vm_image_version();
  PROTOBUF_NODISCARD std::string* release_last_launch_vm_image_version();
  void set_allocated_last_launch_vm_image_version(std::string* last_launch_vm_image_version);
  private:
  const std::string& _internal_last_launch_vm_image_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_launch_vm_image_version(const std::string& value);
  std::string* _internal_mutable_last_launch_vm_image_version();
  public:

  // optional string last_launch_vm_kernel_version = 3;
  bool has_last_launch_vm_kernel_version() const;
  private:
  bool _internal_has_last_launch_vm_kernel_version() const;
  public:
  void clear_last_launch_vm_kernel_version();
  const std::string& last_launch_vm_kernel_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_launch_vm_kernel_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_launch_vm_kernel_version();
  PROTOBUF_NODISCARD std::string* release_last_launch_vm_kernel_version();
  void set_allocated_last_launch_vm_kernel_version(std::string* last_launch_vm_kernel_version);
  private:
  const std::string& _internal_last_launch_vm_kernel_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_launch_vm_kernel_version(const std::string& value);
  std::string* _internal_mutable_last_launch_vm_kernel_version();
  public:

  // optional int64 last_launch_time_window_start_timestamp = 1;
  bool has_last_launch_time_window_start_timestamp() const;
  private:
  bool _internal_has_last_launch_time_window_start_timestamp() const;
  public:
  void clear_last_launch_time_window_start_timestamp();
  int64_t last_launch_time_window_start_timestamp() const;
  void set_last_launch_time_window_start_timestamp(int64_t value);
  private:
  int64_t _internal_last_launch_time_window_start_timestamp() const;
  void _internal_set_last_launch_time_window_start_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CrostiniStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp > installed_apps_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_launch_vm_image_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_launch_vm_kernel_version_;
    int64_t last_launch_time_window_start_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class SessionStatusReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SessionStatusReportRequest) */ {
 public:
  inline SessionStatusReportRequest() : SessionStatusReportRequest(nullptr) {}
  ~SessionStatusReportRequest() override;
  explicit PROTOBUF_CONSTEXPR SessionStatusReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionStatusReportRequest(const SessionStatusReportRequest& from);
  SessionStatusReportRequest(SessionStatusReportRequest&& from) noexcept
    : SessionStatusReportRequest() {
    *this = ::std::move(from);
  }

  inline SessionStatusReportRequest& operator=(const SessionStatusReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionStatusReportRequest& operator=(SessionStatusReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SessionStatusReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionStatusReportRequest* internal_default_instance() {
    return reinterpret_cast<const SessionStatusReportRequest*>(
               &_SessionStatusReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(SessionStatusReportRequest& a, SessionStatusReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionStatusReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionStatusReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionStatusReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionStatusReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionStatusReportRequest& from);
  void MergeFrom(const SessionStatusReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionStatusReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SessionStatusReportRequest";
  }
  protected:
  explicit SessionStatusReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstalledAppsFieldNumber = 5,
    kAppInfosFieldNumber = 11,
    kDeviceLocalAccountIdFieldNumber = 4,
    kUserDmTokenFieldNumber = 8,
    kTimeZoneFieldNumber = 9,
    kAndroidStatusFieldNumber = 7,
    kCrostiniStatusFieldNumber = 10,
  };
  // repeated .enterprise_management.AppStatus installed_apps = 5;
  int installed_apps_size() const;
  private:
  int _internal_installed_apps_size() const;
  public:
  void clear_installed_apps();
  ::enterprise_management::AppStatus* mutable_installed_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus >*
      mutable_installed_apps();
  private:
  const ::enterprise_management::AppStatus& _internal_installed_apps(int index) const;
  ::enterprise_management::AppStatus* _internal_add_installed_apps();
  public:
  const ::enterprise_management::AppStatus& installed_apps(int index) const;
  ::enterprise_management::AppStatus* add_installed_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus >&
      installed_apps() const;

  // repeated .enterprise_management.AppInfo app_infos = 11;
  int app_infos_size() const;
  private:
  int _internal_app_infos_size() const;
  public:
  void clear_app_infos();
  ::enterprise_management::AppInfo* mutable_app_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo >*
      mutable_app_infos();
  private:
  const ::enterprise_management::AppInfo& _internal_app_infos(int index) const;
  ::enterprise_management::AppInfo* _internal_add_app_infos();
  public:
  const ::enterprise_management::AppInfo& app_infos(int index) const;
  ::enterprise_management::AppInfo* add_app_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo >&
      app_infos() const;

  // optional string device_local_account_id = 4;
  bool has_device_local_account_id() const;
  private:
  bool _internal_has_device_local_account_id() const;
  public:
  void clear_device_local_account_id();
  const std::string& device_local_account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_local_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_local_account_id();
  PROTOBUF_NODISCARD std::string* release_device_local_account_id();
  void set_allocated_device_local_account_id(std::string* device_local_account_id);
  private:
  const std::string& _internal_device_local_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_local_account_id(const std::string& value);
  std::string* _internal_mutable_device_local_account_id();
  public:

  // optional string user_dm_token = 8;
  bool has_user_dm_token() const;
  private:
  bool _internal_has_user_dm_token() const;
  public:
  void clear_user_dm_token();
  const std::string& user_dm_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_dm_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_dm_token();
  PROTOBUF_NODISCARD std::string* release_user_dm_token();
  void set_allocated_user_dm_token(std::string* user_dm_token);
  private:
  const std::string& _internal_user_dm_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_dm_token(const std::string& value);
  std::string* _internal_mutable_user_dm_token();
  public:

  // optional string time_zone = 9;
  bool has_time_zone() const;
  private:
  bool _internal_has_time_zone() const;
  public:
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // optional .enterprise_management.AndroidStatus android_status = 7;
  bool has_android_status() const;
  private:
  bool _internal_has_android_status() const;
  public:
  void clear_android_status();
  const ::enterprise_management::AndroidStatus& android_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::AndroidStatus* release_android_status();
  ::enterprise_management::AndroidStatus* mutable_android_status();
  void set_allocated_android_status(::enterprise_management::AndroidStatus* android_status);
  private:
  const ::enterprise_management::AndroidStatus& _internal_android_status() const;
  ::enterprise_management::AndroidStatus* _internal_mutable_android_status();
  public:
  void unsafe_arena_set_allocated_android_status(
      ::enterprise_management::AndroidStatus* android_status);
  ::enterprise_management::AndroidStatus* unsafe_arena_release_android_status();

  // optional .enterprise_management.CrostiniStatus crostini_status = 10;
  bool has_crostini_status() const;
  private:
  bool _internal_has_crostini_status() const;
  public:
  void clear_crostini_status();
  const ::enterprise_management::CrostiniStatus& crostini_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::CrostiniStatus* release_crostini_status();
  ::enterprise_management::CrostiniStatus* mutable_crostini_status();
  void set_allocated_crostini_status(::enterprise_management::CrostiniStatus* crostini_status);
  private:
  const ::enterprise_management::CrostiniStatus& _internal_crostini_status() const;
  ::enterprise_management::CrostiniStatus* _internal_mutable_crostini_status();
  public:
  void unsafe_arena_set_allocated_crostini_status(
      ::enterprise_management::CrostiniStatus* crostini_status);
  ::enterprise_management::CrostiniStatus* unsafe_arena_release_crostini_status();

  // @@protoc_insertion_point(class_scope:enterprise_management.SessionStatusReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus > installed_apps_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo > app_infos_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_local_account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_dm_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::enterprise_management::AndroidStatus* android_status_;
    ::enterprise_management::CrostiniStatus* crostini_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceStatusReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStatusReportResponse) */ {
 public:
  inline DeviceStatusReportResponse() : DeviceStatusReportResponse(nullptr) {}
  ~DeviceStatusReportResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceStatusReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceStatusReportResponse(const DeviceStatusReportResponse& from);
  DeviceStatusReportResponse(DeviceStatusReportResponse&& from) noexcept
    : DeviceStatusReportResponse() {
    *this = ::std::move(from);
  }

  inline DeviceStatusReportResponse& operator=(const DeviceStatusReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStatusReportResponse& operator=(DeviceStatusReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceStatusReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStatusReportResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceStatusReportResponse*>(
               &_DeviceStatusReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(DeviceStatusReportResponse& a, DeviceStatusReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStatusReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStatusReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceStatusReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceStatusReportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceStatusReportResponse& from);
  void MergeFrom(const DeviceStatusReportResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceStatusReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceStatusReportResponse";
  }
  protected:
  explicit DeviceStatusReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // optional string error_message = 2;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional int32 error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStatusReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int32_t error_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeDesktopReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeDesktopReportResponse) */ {
 public:
  inline ChromeDesktopReportResponse() : ChromeDesktopReportResponse(nullptr) {}
  ~ChromeDesktopReportResponse() override;
  explicit PROTOBUF_CONSTEXPR ChromeDesktopReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeDesktopReportResponse(const ChromeDesktopReportResponse& from);
  ChromeDesktopReportResponse(ChromeDesktopReportResponse&& from) noexcept
    : ChromeDesktopReportResponse() {
    *this = ::std::move(from);
  }

  inline ChromeDesktopReportResponse& operator=(const ChromeDesktopReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeDesktopReportResponse& operator=(ChromeDesktopReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeDesktopReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeDesktopReportResponse* internal_default_instance() {
    return reinterpret_cast<const ChromeDesktopReportResponse*>(
               &_ChromeDesktopReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(ChromeDesktopReportResponse& a, ChromeDesktopReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeDesktopReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeDesktopReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeDesktopReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeDesktopReportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeDesktopReportResponse& from);
  void MergeFrom(const ChromeDesktopReportResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeDesktopReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeDesktopReportResponse";
  }
  protected:
  explicit ChromeDesktopReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeDesktopReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeOsUserReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeOsUserReportResponse) */ {
 public:
  inline ChromeOsUserReportResponse() : ChromeOsUserReportResponse(nullptr) {}
  ~ChromeOsUserReportResponse() override;
  explicit PROTOBUF_CONSTEXPR ChromeOsUserReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeOsUserReportResponse(const ChromeOsUserReportResponse& from);
  ChromeOsUserReportResponse(ChromeOsUserReportResponse&& from) noexcept
    : ChromeOsUserReportResponse() {
    *this = ::std::move(from);
  }

  inline ChromeOsUserReportResponse& operator=(const ChromeOsUserReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeOsUserReportResponse& operator=(ChromeOsUserReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeOsUserReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeOsUserReportResponse* internal_default_instance() {
    return reinterpret_cast<const ChromeOsUserReportResponse*>(
               &_ChromeOsUserReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(ChromeOsUserReportResponse& a, ChromeOsUserReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeOsUserReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeOsUserReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeOsUserReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeOsUserReportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeOsUserReportResponse& from);
  void MergeFrom(const ChromeOsUserReportResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeOsUserReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeOsUserReportResponse";
  }
  protected:
  explicit ChromeOsUserReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeOsUserReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChromeProfileReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChromeProfileReportResponse) */ {
 public:
  inline ChromeProfileReportResponse() : ChromeProfileReportResponse(nullptr) {}
  ~ChromeProfileReportResponse() override;
  explicit PROTOBUF_CONSTEXPR ChromeProfileReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeProfileReportResponse(const ChromeProfileReportResponse& from);
  ChromeProfileReportResponse(ChromeProfileReportResponse&& from) noexcept
    : ChromeProfileReportResponse() {
    *this = ::std::move(from);
  }

  inline ChromeProfileReportResponse& operator=(const ChromeProfileReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeProfileReportResponse& operator=(ChromeProfileReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeProfileReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeProfileReportResponse* internal_default_instance() {
    return reinterpret_cast<const ChromeProfileReportResponse*>(
               &_ChromeProfileReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(ChromeProfileReportResponse& a, ChromeProfileReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeProfileReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeProfileReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeProfileReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeProfileReportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeProfileReportResponse& from);
  void MergeFrom(const ChromeProfileReportResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeProfileReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChromeProfileReportResponse";
  }
  protected:
  explicit ChromeProfileReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.ChromeProfileReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class SessionStatusReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SessionStatusReportResponse) */ {
 public:
  inline SessionStatusReportResponse() : SessionStatusReportResponse(nullptr) {}
  ~SessionStatusReportResponse() override;
  explicit PROTOBUF_CONSTEXPR SessionStatusReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionStatusReportResponse(const SessionStatusReportResponse& from);
  SessionStatusReportResponse(SessionStatusReportResponse&& from) noexcept
    : SessionStatusReportResponse() {
    *this = ::std::move(from);
  }

  inline SessionStatusReportResponse& operator=(const SessionStatusReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionStatusReportResponse& operator=(SessionStatusReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SessionStatusReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionStatusReportResponse* internal_default_instance() {
    return reinterpret_cast<const SessionStatusReportResponse*>(
               &_SessionStatusReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(SessionStatusReportResponse& a, SessionStatusReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionStatusReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionStatusReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionStatusReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionStatusReportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionStatusReportResponse& from);
  void MergeFrom(const SessionStatusReportResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionStatusReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SessionStatusReportResponse";
  }
  protected:
  explicit SessionStatusReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // optional string error_message = 2;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional int32 error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SessionStatusReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int32_t error_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrivateSetMembershipRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrivateSetMembershipRequest) */ {
 public:
  inline PrivateSetMembershipRequest() : PrivateSetMembershipRequest(nullptr) {}
  ~PrivateSetMembershipRequest() override;
  explicit PROTOBUF_CONSTEXPR PrivateSetMembershipRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateSetMembershipRequest(const PrivateSetMembershipRequest& from);
  PrivateSetMembershipRequest(PrivateSetMembershipRequest&& from) noexcept
    : PrivateSetMembershipRequest() {
    *this = ::std::move(from);
  }

  inline PrivateSetMembershipRequest& operator=(const PrivateSetMembershipRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateSetMembershipRequest& operator=(PrivateSetMembershipRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrivateSetMembershipRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateSetMembershipRequest* internal_default_instance() {
    return reinterpret_cast<const PrivateSetMembershipRequest*>(
               &_PrivateSetMembershipRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(PrivateSetMembershipRequest& a, PrivateSetMembershipRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateSetMembershipRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateSetMembershipRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivateSetMembershipRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivateSetMembershipRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrivateSetMembershipRequest& from);
  void MergeFrom(const PrivateSetMembershipRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateSetMembershipRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrivateSetMembershipRequest";
  }
  protected:
  explicit PrivateSetMembershipRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRlweRequestFieldNumber = 1,
  };
  // optional .enterprise_management.PrivateSetMembershipRlweRequest rlwe_request = 1;
  bool has_rlwe_request() const;
  private:
  bool _internal_has_rlwe_request() const;
  public:
  void clear_rlwe_request();
  const ::enterprise_management::PrivateSetMembershipRlweRequest& rlwe_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::PrivateSetMembershipRlweRequest* release_rlwe_request();
  ::enterprise_management::PrivateSetMembershipRlweRequest* mutable_rlwe_request();
  void set_allocated_rlwe_request(::enterprise_management::PrivateSetMembershipRlweRequest* rlwe_request);
  private:
  const ::enterprise_management::PrivateSetMembershipRlweRequest& _internal_rlwe_request() const;
  ::enterprise_management::PrivateSetMembershipRlweRequest* _internal_mutable_rlwe_request();
  public:
  void unsafe_arena_set_allocated_rlwe_request(
      ::enterprise_management::PrivateSetMembershipRlweRequest* rlwe_request);
  ::enterprise_management::PrivateSetMembershipRlweRequest* unsafe_arena_release_rlwe_request();

  // @@protoc_insertion_point(class_scope:enterprise_management.PrivateSetMembershipRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::PrivateSetMembershipRlweRequest* rlwe_request_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrivateSetMembershipResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrivateSetMembershipResponse) */ {
 public:
  inline PrivateSetMembershipResponse() : PrivateSetMembershipResponse(nullptr) {}
  ~PrivateSetMembershipResponse() override;
  explicit PROTOBUF_CONSTEXPR PrivateSetMembershipResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateSetMembershipResponse(const PrivateSetMembershipResponse& from);
  PrivateSetMembershipResponse(PrivateSetMembershipResponse&& from) noexcept
    : PrivateSetMembershipResponse() {
    *this = ::std::move(from);
  }

  inline PrivateSetMembershipResponse& operator=(const PrivateSetMembershipResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateSetMembershipResponse& operator=(PrivateSetMembershipResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrivateSetMembershipResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateSetMembershipResponse* internal_default_instance() {
    return reinterpret_cast<const PrivateSetMembershipResponse*>(
               &_PrivateSetMembershipResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(PrivateSetMembershipResponse& a, PrivateSetMembershipResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateSetMembershipResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateSetMembershipResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivateSetMembershipResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivateSetMembershipResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrivateSetMembershipResponse& from);
  void MergeFrom(const PrivateSetMembershipResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateSetMembershipResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrivateSetMembershipResponse";
  }
  protected:
  explicit PrivateSetMembershipResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRlweResponseFieldNumber = 1,
  };
  // optional .enterprise_management.PrivateSetMembershipRlweResponse rlwe_response = 1;
  bool has_rlwe_response() const;
  private:
  bool _internal_has_rlwe_response() const;
  public:
  void clear_rlwe_response();
  const ::enterprise_management::PrivateSetMembershipRlweResponse& rlwe_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::PrivateSetMembershipRlweResponse* release_rlwe_response();
  ::enterprise_management::PrivateSetMembershipRlweResponse* mutable_rlwe_response();
  void set_allocated_rlwe_response(::enterprise_management::PrivateSetMembershipRlweResponse* rlwe_response);
  private:
  const ::enterprise_management::PrivateSetMembershipRlweResponse& _internal_rlwe_response() const;
  ::enterprise_management::PrivateSetMembershipRlweResponse* _internal_mutable_rlwe_response();
  public:
  void unsafe_arena_set_allocated_rlwe_response(
      ::enterprise_management::PrivateSetMembershipRlweResponse* rlwe_response);
  ::enterprise_management::PrivateSetMembershipRlweResponse* unsafe_arena_release_rlwe_response();

  // @@protoc_insertion_point(class_scope:enterprise_management.PrivateSetMembershipResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::PrivateSetMembershipRlweResponse* rlwe_response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrivateSetMembershipRlweRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrivateSetMembershipRlweRequest) */ {
 public:
  inline PrivateSetMembershipRlweRequest() : PrivateSetMembershipRlweRequest(nullptr) {}
  ~PrivateSetMembershipRlweRequest() override;
  explicit PROTOBUF_CONSTEXPR PrivateSetMembershipRlweRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateSetMembershipRlweRequest(const PrivateSetMembershipRlweRequest& from);
  PrivateSetMembershipRlweRequest(PrivateSetMembershipRlweRequest&& from) noexcept
    : PrivateSetMembershipRlweRequest() {
    *this = ::std::move(from);
  }

  inline PrivateSetMembershipRlweRequest& operator=(const PrivateSetMembershipRlweRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateSetMembershipRlweRequest& operator=(PrivateSetMembershipRlweRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrivateSetMembershipRlweRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateSetMembershipRlweRequest* internal_default_instance() {
    return reinterpret_cast<const PrivateSetMembershipRlweRequest*>(
               &_PrivateSetMembershipRlweRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(PrivateSetMembershipRlweRequest& a, PrivateSetMembershipRlweRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateSetMembershipRlweRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateSetMembershipRlweRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivateSetMembershipRlweRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivateSetMembershipRlweRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrivateSetMembershipRlweRequest& from);
  void MergeFrom(const PrivateSetMembershipRlweRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateSetMembershipRlweRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrivateSetMembershipRlweRequest";
  }
  protected:
  explicit PrivateSetMembershipRlweRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOprfRequestFieldNumber = 1,
    kQueryRequestFieldNumber = 2,
  };
  // optional .private_membership.rlwe.PrivateMembershipRlweOprfRequest oprf_request = 1;
  bool has_oprf_request() const;
  private:
  bool _internal_has_oprf_request() const;
  public:
  void clear_oprf_request();
  const ::private_membership::rlwe::PrivateMembershipRlweOprfRequest& oprf_request() const;
  PROTOBUF_NODISCARD ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* release_oprf_request();
  ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* mutable_oprf_request();
  void set_allocated_oprf_request(::private_membership::rlwe::PrivateMembershipRlweOprfRequest* oprf_request);
  private:
  const ::private_membership::rlwe::PrivateMembershipRlweOprfRequest& _internal_oprf_request() const;
  ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* _internal_mutable_oprf_request();
  public:
  void unsafe_arena_set_allocated_oprf_request(
      ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* oprf_request);
  ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* unsafe_arena_release_oprf_request();

  // optional .private_membership.rlwe.PrivateMembershipRlweQueryRequest query_request = 2;
  bool has_query_request() const;
  private:
  bool _internal_has_query_request() const;
  public:
  void clear_query_request();
  const ::private_membership::rlwe::PrivateMembershipRlweQueryRequest& query_request() const;
  PROTOBUF_NODISCARD ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* release_query_request();
  ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* mutable_query_request();
  void set_allocated_query_request(::private_membership::rlwe::PrivateMembershipRlweQueryRequest* query_request);
  private:
  const ::private_membership::rlwe::PrivateMembershipRlweQueryRequest& _internal_query_request() const;
  ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* _internal_mutable_query_request();
  public:
  void unsafe_arena_set_allocated_query_request(
      ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* query_request);
  ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* unsafe_arena_release_query_request();

  // @@protoc_insertion_point(class_scope:enterprise_management.PrivateSetMembershipRlweRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* oprf_request_;
    ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* query_request_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrivateSetMembershipRlweResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrivateSetMembershipRlweResponse) */ {
 public:
  inline PrivateSetMembershipRlweResponse() : PrivateSetMembershipRlweResponse(nullptr) {}
  ~PrivateSetMembershipRlweResponse() override;
  explicit PROTOBUF_CONSTEXPR PrivateSetMembershipRlweResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateSetMembershipRlweResponse(const PrivateSetMembershipRlweResponse& from);
  PrivateSetMembershipRlweResponse(PrivateSetMembershipRlweResponse&& from) noexcept
    : PrivateSetMembershipRlweResponse() {
    *this = ::std::move(from);
  }

  inline PrivateSetMembershipRlweResponse& operator=(const PrivateSetMembershipRlweResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateSetMembershipRlweResponse& operator=(PrivateSetMembershipRlweResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrivateSetMembershipRlweResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateSetMembershipRlweResponse* internal_default_instance() {
    return reinterpret_cast<const PrivateSetMembershipRlweResponse*>(
               &_PrivateSetMembershipRlweResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(PrivateSetMembershipRlweResponse& a, PrivateSetMembershipRlweResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateSetMembershipRlweResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateSetMembershipRlweResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivateSetMembershipRlweResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivateSetMembershipRlweResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrivateSetMembershipRlweResponse& from);
  void MergeFrom(const PrivateSetMembershipRlweResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateSetMembershipRlweResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrivateSetMembershipRlweResponse";
  }
  protected:
  explicit PrivateSetMembershipRlweResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOprfResponseFieldNumber = 1,
    kQueryResponseFieldNumber = 2,
  };
  // optional .private_membership.rlwe.PrivateMembershipRlweOprfResponse oprf_response = 1;
  bool has_oprf_response() const;
  private:
  bool _internal_has_oprf_response() const;
  public:
  void clear_oprf_response();
  const ::private_membership::rlwe::PrivateMembershipRlweOprfResponse& oprf_response() const;
  PROTOBUF_NODISCARD ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* release_oprf_response();
  ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* mutable_oprf_response();
  void set_allocated_oprf_response(::private_membership::rlwe::PrivateMembershipRlweOprfResponse* oprf_response);
  private:
  const ::private_membership::rlwe::PrivateMembershipRlweOprfResponse& _internal_oprf_response() const;
  ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* _internal_mutable_oprf_response();
  public:
  void unsafe_arena_set_allocated_oprf_response(
      ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* oprf_response);
  ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* unsafe_arena_release_oprf_response();

  // optional .private_membership.rlwe.PrivateMembershipRlweQueryResponse query_response = 2;
  bool has_query_response() const;
  private:
  bool _internal_has_query_response() const;
  public:
  void clear_query_response();
  const ::private_membership::rlwe::PrivateMembershipRlweQueryResponse& query_response() const;
  PROTOBUF_NODISCARD ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* release_query_response();
  ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* mutable_query_response();
  void set_allocated_query_response(::private_membership::rlwe::PrivateMembershipRlweQueryResponse* query_response);
  private:
  const ::private_membership::rlwe::PrivateMembershipRlweQueryResponse& _internal_query_response() const;
  ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* _internal_mutable_query_response();
  public:
  void unsafe_arena_set_allocated_query_response(
      ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* query_response);
  ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* unsafe_arena_release_query_response();

  // @@protoc_insertion_point(class_scope:enterprise_management.PrivateSetMembershipRlweResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* oprf_response_;
    ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* query_response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceAutoEnrollmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAutoEnrollmentRequest) */ {
 public:
  inline DeviceAutoEnrollmentRequest() : DeviceAutoEnrollmentRequest(nullptr) {}
  ~DeviceAutoEnrollmentRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceAutoEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAutoEnrollmentRequest(const DeviceAutoEnrollmentRequest& from);
  DeviceAutoEnrollmentRequest(DeviceAutoEnrollmentRequest&& from) noexcept
    : DeviceAutoEnrollmentRequest() {
    *this = ::std::move(from);
  }

  inline DeviceAutoEnrollmentRequest& operator=(const DeviceAutoEnrollmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAutoEnrollmentRequest& operator=(DeviceAutoEnrollmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAutoEnrollmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAutoEnrollmentRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceAutoEnrollmentRequest*>(
               &_DeviceAutoEnrollmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(DeviceAutoEnrollmentRequest& a, DeviceAutoEnrollmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAutoEnrollmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAutoEnrollmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAutoEnrollmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAutoEnrollmentRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAutoEnrollmentRequest& from);
  void MergeFrom(const DeviceAutoEnrollmentRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAutoEnrollmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAutoEnrollmentRequest";
  }
  protected:
  explicit DeviceAutoEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceAutoEnrollmentRequest_EnrollmentCheckType EnrollmentCheckType;
  static constexpr EnrollmentCheckType ENROLLMENT_CHECK_TYPE_UNSPECIFIED =
    DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_UNSPECIFIED;
  static constexpr EnrollmentCheckType ENROLLMENT_CHECK_TYPE_FRE =
    DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FRE;
  static constexpr EnrollmentCheckType ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT =
    DeviceAutoEnrollmentRequest_EnrollmentCheckType_ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT;
  static inline bool EnrollmentCheckType_IsValid(int value) {
    return DeviceAutoEnrollmentRequest_EnrollmentCheckType_IsValid(value);
  }
  static constexpr EnrollmentCheckType EnrollmentCheckType_MIN =
    DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MIN;
  static constexpr EnrollmentCheckType EnrollmentCheckType_MAX =
    DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_MAX;
  static constexpr int EnrollmentCheckType_ARRAYSIZE =
    DeviceAutoEnrollmentRequest_EnrollmentCheckType_EnrollmentCheckType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EnrollmentCheckType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnrollmentCheckType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnrollmentCheckType_Name.");
    return DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(enum_t_value);
  }
  static inline bool EnrollmentCheckType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnrollmentCheckType* value) {
    return DeviceAutoEnrollmentRequest_EnrollmentCheckType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRemainderFieldNumber = 1,
    kModulusFieldNumber = 2,
    kEnrollmentCheckTypeFieldNumber = 3,
  };
  // optional int64 remainder = 1;
  bool has_remainder() const;
  private:
  bool _internal_has_remainder() const;
  public:
  void clear_remainder();
  int64_t remainder() const;
  void set_remainder(int64_t value);
  private:
  int64_t _internal_remainder() const;
  void _internal_set_remainder(int64_t value);
  public:

  // optional int64 modulus = 2;
  bool has_modulus() const;
  private:
  bool _internal_has_modulus() const;
  public:
  void clear_modulus();
  int64_t modulus() const;
  void set_modulus(int64_t value);
  private:
  int64_t _internal_modulus() const;
  void _internal_set_modulus(int64_t value);
  public:

  // optional .enterprise_management.DeviceAutoEnrollmentRequest.EnrollmentCheckType enrollment_check_type = 3 [default = ENROLLMENT_CHECK_TYPE_FRE];
  bool has_enrollment_check_type() const;
  private:
  bool _internal_has_enrollment_check_type() const;
  public:
  void clear_enrollment_check_type();
  ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType enrollment_check_type() const;
  void set_enrollment_check_type(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType value);
  private:
  ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType _internal_enrollment_check_type() const;
  void _internal_set_enrollment_check_type(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAutoEnrollmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t remainder_;
    int64_t modulus_;
    int enrollment_check_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceAutoEnrollmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAutoEnrollmentResponse) */ {
 public:
  inline DeviceAutoEnrollmentResponse() : DeviceAutoEnrollmentResponse(nullptr) {}
  ~DeviceAutoEnrollmentResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceAutoEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAutoEnrollmentResponse(const DeviceAutoEnrollmentResponse& from);
  DeviceAutoEnrollmentResponse(DeviceAutoEnrollmentResponse&& from) noexcept
    : DeviceAutoEnrollmentResponse() {
    *this = ::std::move(from);
  }

  inline DeviceAutoEnrollmentResponse& operator=(const DeviceAutoEnrollmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAutoEnrollmentResponse& operator=(DeviceAutoEnrollmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAutoEnrollmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAutoEnrollmentResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceAutoEnrollmentResponse*>(
               &_DeviceAutoEnrollmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(DeviceAutoEnrollmentResponse& a, DeviceAutoEnrollmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAutoEnrollmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAutoEnrollmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAutoEnrollmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAutoEnrollmentResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAutoEnrollmentResponse& from);
  void MergeFrom(const DeviceAutoEnrollmentResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAutoEnrollmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAutoEnrollmentResponse";
  }
  protected:
  explicit DeviceAutoEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 2,
    kExpectedModulusFieldNumber = 1,
  };
  // repeated bytes hashes = 2;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;
  public:
  void clear_hashes();
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  void set_hashes(int index, const std::string& value);
  void set_hashes(int index, std::string&& value);
  void set_hashes(int index, const char* value);
  void set_hashes(int index, const void* value, size_t size);
  std::string* add_hashes();
  void add_hashes(const std::string& value);
  void add_hashes(std::string&& value);
  void add_hashes(const char* value);
  void add_hashes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();
  private:
  const std::string& _internal_hashes(int index) const;
  std::string* _internal_add_hashes();
  public:

  // optional int64 expected_modulus = 1;
  bool has_expected_modulus() const;
  private:
  bool _internal_has_expected_modulus() const;
  public:
  void clear_expected_modulus();
  int64_t expected_modulus() const;
  void set_expected_modulus(int64_t value);
  private:
  int64_t _internal_expected_modulus() const;
  void _internal_set_expected_modulus(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAutoEnrollmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
    int64_t expected_modulus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceStateRetrievalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStateRetrievalRequest) */ {
 public:
  inline DeviceStateRetrievalRequest() : DeviceStateRetrievalRequest(nullptr) {}
  ~DeviceStateRetrievalRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceStateRetrievalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceStateRetrievalRequest(const DeviceStateRetrievalRequest& from);
  DeviceStateRetrievalRequest(DeviceStateRetrievalRequest&& from) noexcept
    : DeviceStateRetrievalRequest() {
    *this = ::std::move(from);
  }

  inline DeviceStateRetrievalRequest& operator=(const DeviceStateRetrievalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStateRetrievalRequest& operator=(DeviceStateRetrievalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceStateRetrievalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStateRetrievalRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceStateRetrievalRequest*>(
               &_DeviceStateRetrievalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(DeviceStateRetrievalRequest& a, DeviceStateRetrievalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStateRetrievalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStateRetrievalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceStateRetrievalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceStateRetrievalRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceStateRetrievalRequest& from);
  void MergeFrom(const DeviceStateRetrievalRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceStateRetrievalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceStateRetrievalRequest";
  }
  protected:
  explicit DeviceStateRetrievalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerBackedStateKeyFieldNumber = 1,
  };
  // optional bytes server_backed_state_key = 1;
  bool has_server_backed_state_key() const;
  private:
  bool _internal_has_server_backed_state_key() const;
  public:
  void clear_server_backed_state_key();
  const std::string& server_backed_state_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_backed_state_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_backed_state_key();
  PROTOBUF_NODISCARD std::string* release_server_backed_state_key();
  void set_allocated_server_backed_state_key(std::string* server_backed_state_key);
  private:
  const std::string& _internal_server_backed_state_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_backed_state_key(const std::string& value);
  std::string* _internal_mutable_server_backed_state_key();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateRetrievalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_backed_state_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceStateKeyUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStateKeyUpdateRequest) */ {
 public:
  inline DeviceStateKeyUpdateRequest() : DeviceStateKeyUpdateRequest(nullptr) {}
  ~DeviceStateKeyUpdateRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceStateKeyUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceStateKeyUpdateRequest(const DeviceStateKeyUpdateRequest& from);
  DeviceStateKeyUpdateRequest(DeviceStateKeyUpdateRequest&& from) noexcept
    : DeviceStateKeyUpdateRequest() {
    *this = ::std::move(from);
  }

  inline DeviceStateKeyUpdateRequest& operator=(const DeviceStateKeyUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStateKeyUpdateRequest& operator=(DeviceStateKeyUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceStateKeyUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStateKeyUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceStateKeyUpdateRequest*>(
               &_DeviceStateKeyUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(DeviceStateKeyUpdateRequest& a, DeviceStateKeyUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStateKeyUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStateKeyUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceStateKeyUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceStateKeyUpdateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceStateKeyUpdateRequest& from);
  void MergeFrom(const DeviceStateKeyUpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceStateKeyUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceStateKeyUpdateRequest";
  }
  protected:
  explicit DeviceStateKeyUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerBackedStateKeysFieldNumber = 1,
  };
  // repeated bytes server_backed_state_keys = 1;
  int server_backed_state_keys_size() const;
  private:
  int _internal_server_backed_state_keys_size() const;
  public:
  void clear_server_backed_state_keys();
  const std::string& server_backed_state_keys(int index) const;
  std::string* mutable_server_backed_state_keys(int index);
  void set_server_backed_state_keys(int index, const std::string& value);
  void set_server_backed_state_keys(int index, std::string&& value);
  void set_server_backed_state_keys(int index, const char* value);
  void set_server_backed_state_keys(int index, const void* value, size_t size);
  std::string* add_server_backed_state_keys();
  void add_server_backed_state_keys(const std::string& value);
  void add_server_backed_state_keys(std::string&& value);
  void add_server_backed_state_keys(const char* value);
  void add_server_backed_state_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& server_backed_state_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_server_backed_state_keys();
  private:
  const std::string& _internal_server_backed_state_keys(int index) const;
  std::string* _internal_add_server_backed_state_keys();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateKeyUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> server_backed_state_keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceStateRetrievalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStateRetrievalResponse) */ {
 public:
  inline DeviceStateRetrievalResponse() : DeviceStateRetrievalResponse(nullptr) {}
  ~DeviceStateRetrievalResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceStateRetrievalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceStateRetrievalResponse(const DeviceStateRetrievalResponse& from);
  DeviceStateRetrievalResponse(DeviceStateRetrievalResponse&& from) noexcept
    : DeviceStateRetrievalResponse() {
    *this = ::std::move(from);
  }

  inline DeviceStateRetrievalResponse& operator=(const DeviceStateRetrievalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStateRetrievalResponse& operator=(DeviceStateRetrievalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceStateRetrievalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStateRetrievalResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceStateRetrievalResponse*>(
               &_DeviceStateRetrievalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(DeviceStateRetrievalResponse& a, DeviceStateRetrievalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStateRetrievalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStateRetrievalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceStateRetrievalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceStateRetrievalResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceStateRetrievalResponse& from);
  void MergeFrom(const DeviceStateRetrievalResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceStateRetrievalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceStateRetrievalResponse";
  }
  protected:
  explicit DeviceStateRetrievalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceStateRetrievalResponse_RestoreMode RestoreMode;
  static constexpr RestoreMode RESTORE_MODE_NONE =
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_NONE;
  static constexpr RestoreMode RESTORE_MODE_REENROLLMENT_REQUESTED =
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_REQUESTED;
  static constexpr RestoreMode RESTORE_MODE_REENROLLMENT_ENFORCED =
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ENFORCED;
  static constexpr RestoreMode RESTORE_MODE_DISABLED =
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_DISABLED;
  static constexpr RestoreMode RESTORE_MODE_REENROLLMENT_ZERO_TOUCH =
    DeviceStateRetrievalResponse_RestoreMode_RESTORE_MODE_REENROLLMENT_ZERO_TOUCH;
  static inline bool RestoreMode_IsValid(int value) {
    return DeviceStateRetrievalResponse_RestoreMode_IsValid(value);
  }
  static constexpr RestoreMode RestoreMode_MIN =
    DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MIN;
  static constexpr RestoreMode RestoreMode_MAX =
    DeviceStateRetrievalResponse_RestoreMode_RestoreMode_MAX;
  static constexpr int RestoreMode_ARRAYSIZE =
    DeviceStateRetrievalResponse_RestoreMode_RestoreMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RestoreMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RestoreMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RestoreMode_Name.");
    return DeviceStateRetrievalResponse_RestoreMode_Name(enum_t_value);
  }
  static inline bool RestoreMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RestoreMode* value) {
    return DeviceStateRetrievalResponse_RestoreMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kManagementDomainFieldNumber = 2,
    kDisabledStateFieldNumber = 3,
    kInitialStateResponseFieldNumber = 4,
    kLicenseTypeFieldNumber = 5,
    kRestoreModeFieldNumber = 1,
  };
  // optional string management_domain = 2;
  bool has_management_domain() const;
  private:
  bool _internal_has_management_domain() const;
  public:
  void clear_management_domain();
  const std::string& management_domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_management_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_management_domain();
  PROTOBUF_NODISCARD std::string* release_management_domain();
  void set_allocated_management_domain(std::string* management_domain);
  private:
  const std::string& _internal_management_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_management_domain(const std::string& value);
  std::string* _internal_mutable_management_domain();
  public:

  // optional .enterprise_management.DisabledState disabled_state = 3;
  bool has_disabled_state() const;
  private:
  bool _internal_has_disabled_state() const;
  public:
  void clear_disabled_state();
  const ::enterprise_management::DisabledState& disabled_state() const;
  PROTOBUF_NODISCARD ::enterprise_management::DisabledState* release_disabled_state();
  ::enterprise_management::DisabledState* mutable_disabled_state();
  void set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state);
  private:
  const ::enterprise_management::DisabledState& _internal_disabled_state() const;
  ::enterprise_management::DisabledState* _internal_mutable_disabled_state();
  public:
  void unsafe_arena_set_allocated_disabled_state(
      ::enterprise_management::DisabledState* disabled_state);
  ::enterprise_management::DisabledState* unsafe_arena_release_disabled_state();

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse initial_state_response = 4;
  bool has_initial_state_response() const;
  private:
  bool _internal_has_initial_state_response() const;
  public:
  void clear_initial_state_response();
  const ::enterprise_management::DeviceInitialEnrollmentStateResponse& initial_state_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceInitialEnrollmentStateResponse* release_initial_state_response();
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* mutable_initial_state_response();
  void set_allocated_initial_state_response(::enterprise_management::DeviceInitialEnrollmentStateResponse* initial_state_response);
  private:
  const ::enterprise_management::DeviceInitialEnrollmentStateResponse& _internal_initial_state_response() const;
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* _internal_mutable_initial_state_response();
  public:
  void unsafe_arena_set_allocated_initial_state_response(
      ::enterprise_management::DeviceInitialEnrollmentStateResponse* initial_state_response);
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* unsafe_arena_release_initial_state_response();

  // optional .enterprise_management.LicenseType license_type = 5;
  bool has_license_type() const;
  private:
  bool _internal_has_license_type() const;
  public:
  void clear_license_type();
  const ::enterprise_management::LicenseType& license_type() const;
  PROTOBUF_NODISCARD ::enterprise_management::LicenseType* release_license_type();
  ::enterprise_management::LicenseType* mutable_license_type();
  void set_allocated_license_type(::enterprise_management::LicenseType* license_type);
  private:
  const ::enterprise_management::LicenseType& _internal_license_type() const;
  ::enterprise_management::LicenseType* _internal_mutable_license_type();
  public:
  void unsafe_arena_set_allocated_license_type(
      ::enterprise_management::LicenseType* license_type);
  ::enterprise_management::LicenseType* unsafe_arena_release_license_type();

  // optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
  bool has_restore_mode() const;
  private:
  bool _internal_has_restore_mode() const;
  public:
  void clear_restore_mode();
  ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode restore_mode() const;
  void set_restore_mode(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode value);
  private:
  ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode _internal_restore_mode() const;
  void _internal_set_restore_mode(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateRetrievalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr management_domain_;
    ::enterprise_management::DisabledState* disabled_state_;
    ::enterprise_management::DeviceInitialEnrollmentStateResponse* initial_state_response_;
    ::enterprise_management::LicenseType* license_type_;
    int restore_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceInitialEnrollmentStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceInitialEnrollmentStateRequest) */ {
 public:
  inline DeviceInitialEnrollmentStateRequest() : DeviceInitialEnrollmentStateRequest(nullptr) {}
  ~DeviceInitialEnrollmentStateRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceInitialEnrollmentStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInitialEnrollmentStateRequest(const DeviceInitialEnrollmentStateRequest& from);
  DeviceInitialEnrollmentStateRequest(DeviceInitialEnrollmentStateRequest&& from) noexcept
    : DeviceInitialEnrollmentStateRequest() {
    *this = ::std::move(from);
  }

  inline DeviceInitialEnrollmentStateRequest& operator=(const DeviceInitialEnrollmentStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInitialEnrollmentStateRequest& operator=(DeviceInitialEnrollmentStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceInitialEnrollmentStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInitialEnrollmentStateRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceInitialEnrollmentStateRequest*>(
               &_DeviceInitialEnrollmentStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(DeviceInitialEnrollmentStateRequest& a, DeviceInitialEnrollmentStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInitialEnrollmentStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInitialEnrollmentStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInitialEnrollmentStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInitialEnrollmentStateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceInitialEnrollmentStateRequest& from);
  void MergeFrom(const DeviceInitialEnrollmentStateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceInitialEnrollmentStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceInitialEnrollmentStateRequest";
  }
  protected:
  explicit DeviceInitialEnrollmentStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialNumberFieldNumber = 1,
    kBrandCodeFieldNumber = 2,
  };
  // optional string serial_number = 1;
  bool has_serial_number() const;
  private:
  bool _internal_has_serial_number() const;
  public:
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // optional string brand_code = 2;
  bool has_brand_code() const;
  private:
  bool _internal_has_brand_code() const;
  public:
  void clear_brand_code();
  const std::string& brand_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brand_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brand_code();
  PROTOBUF_NODISCARD std::string* release_brand_code();
  void set_allocated_brand_code(std::string* brand_code);
  private:
  const std::string& _internal_brand_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brand_code(const std::string& value);
  std::string* _internal_mutable_brand_code();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceInitialEnrollmentStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceInitialEnrollmentStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceInitialEnrollmentStateResponse) */ {
 public:
  inline DeviceInitialEnrollmentStateResponse() : DeviceInitialEnrollmentStateResponse(nullptr) {}
  ~DeviceInitialEnrollmentStateResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceInitialEnrollmentStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInitialEnrollmentStateResponse(const DeviceInitialEnrollmentStateResponse& from);
  DeviceInitialEnrollmentStateResponse(DeviceInitialEnrollmentStateResponse&& from) noexcept
    : DeviceInitialEnrollmentStateResponse() {
    *this = ::std::move(from);
  }

  inline DeviceInitialEnrollmentStateResponse& operator=(const DeviceInitialEnrollmentStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInitialEnrollmentStateResponse& operator=(DeviceInitialEnrollmentStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceInitialEnrollmentStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInitialEnrollmentStateResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceInitialEnrollmentStateResponse*>(
               &_DeviceInitialEnrollmentStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(DeviceInitialEnrollmentStateResponse& a, DeviceInitialEnrollmentStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInitialEnrollmentStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInitialEnrollmentStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInitialEnrollmentStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInitialEnrollmentStateResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceInitialEnrollmentStateResponse& from);
  void MergeFrom(const DeviceInitialEnrollmentStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceInitialEnrollmentStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceInitialEnrollmentStateResponse";
  }
  protected:
  explicit DeviceInitialEnrollmentStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode InitialEnrollmentMode;
  static constexpr InitialEnrollmentMode INITIAL_ENROLLMENT_MODE_NONE =
    DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_NONE;
  static constexpr InitialEnrollmentMode INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED =
    DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED;
  static constexpr InitialEnrollmentMode INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED =
    DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED;
  static constexpr InitialEnrollmentMode INITIAL_ENROLLMENT_MODE_DISABLED =
    DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_INITIAL_ENROLLMENT_MODE_DISABLED;
  static inline bool InitialEnrollmentMode_IsValid(int value) {
    return DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_IsValid(value);
  }
  static constexpr InitialEnrollmentMode InitialEnrollmentMode_MIN =
    DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MIN;
  static constexpr InitialEnrollmentMode InitialEnrollmentMode_MAX =
    DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_MAX;
  static constexpr int InitialEnrollmentMode_ARRAYSIZE =
    DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_InitialEnrollmentMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InitialEnrollmentMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InitialEnrollmentMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InitialEnrollmentMode_Name.");
    return DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(enum_t_value);
  }
  static inline bool InitialEnrollmentMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InitialEnrollmentMode* value) {
    return DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Parse(name, value);
  }

  typedef DeviceInitialEnrollmentStateResponse_LicensePackagingSKU LicensePackagingSKU;
  static constexpr LicensePackagingSKU NOT_EXIST =
    DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_NOT_EXIST;
  static constexpr LicensePackagingSKU CHROME_ENTERPRISE =
    DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_CHROME_ENTERPRISE;
  static constexpr LicensePackagingSKU CHROME_EDUCATION =
    DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_CHROME_EDUCATION;
  static constexpr LicensePackagingSKU CHROME_TERMINAL =
    DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_CHROME_TERMINAL;
  static inline bool LicensePackagingSKU_IsValid(int value) {
    return DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_IsValid(value);
  }
  static constexpr LicensePackagingSKU LicensePackagingSKU_MIN =
    DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_LicensePackagingSKU_MIN;
  static constexpr LicensePackagingSKU LicensePackagingSKU_MAX =
    DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_LicensePackagingSKU_MAX;
  static constexpr int LicensePackagingSKU_ARRAYSIZE =
    DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_LicensePackagingSKU_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LicensePackagingSKU_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LicensePackagingSKU>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LicensePackagingSKU_Name.");
    return DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Name(enum_t_value);
  }
  static inline bool LicensePackagingSKU_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LicensePackagingSKU* value) {
    return DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Parse(name, value);
  }

  typedef DeviceInitialEnrollmentStateResponse_AssignedUpgradeType AssignedUpgradeType;
  static constexpr AssignedUpgradeType ASSIGNED_UPGRADE_TYPE_UNSPECIFIED =
    DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_ASSIGNED_UPGRADE_TYPE_UNSPECIFIED;
  static constexpr AssignedUpgradeType ASSIGNED_UPGRADE_TYPE_CHROME_ENTERPRISE =
    DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_ASSIGNED_UPGRADE_TYPE_CHROME_ENTERPRISE;
  static constexpr AssignedUpgradeType ASSIGNED_UPGRADE_TYPE_KIOSK_AND_SIGNAGE =
    DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_ASSIGNED_UPGRADE_TYPE_KIOSK_AND_SIGNAGE;
  static inline bool AssignedUpgradeType_IsValid(int value) {
    return DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_IsValid(value);
  }
  static constexpr AssignedUpgradeType AssignedUpgradeType_MIN =
    DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_AssignedUpgradeType_MIN;
  static constexpr AssignedUpgradeType AssignedUpgradeType_MAX =
    DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_AssignedUpgradeType_MAX;
  static constexpr int AssignedUpgradeType_ARRAYSIZE =
    DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_AssignedUpgradeType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AssignedUpgradeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AssignedUpgradeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AssignedUpgradeType_Name.");
    return DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Name(enum_t_value);
  }
  static inline bool AssignedUpgradeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AssignedUpgradeType* value) {
    return DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kManagementDomainFieldNumber = 2,
    kDisabledStateFieldNumber = 4,
    kInitialEnrollmentModeFieldNumber = 1,
    kIsLicensePackagedWithDeviceFieldNumber = 3,
    kLicensePackagingSkuFieldNumber = 5,
    kAssignedUpgradeTypeFieldNumber = 6,
  };
  // optional string management_domain = 2;
  bool has_management_domain() const;
  private:
  bool _internal_has_management_domain() const;
  public:
  void clear_management_domain();
  const std::string& management_domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_management_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_management_domain();
  PROTOBUF_NODISCARD std::string* release_management_domain();
  void set_allocated_management_domain(std::string* management_domain);
  private:
  const std::string& _internal_management_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_management_domain(const std::string& value);
  std::string* _internal_mutable_management_domain();
  public:

  // optional .enterprise_management.DisabledState disabled_state = 4;
  bool has_disabled_state() const;
  private:
  bool _internal_has_disabled_state() const;
  public:
  void clear_disabled_state();
  const ::enterprise_management::DisabledState& disabled_state() const;
  PROTOBUF_NODISCARD ::enterprise_management::DisabledState* release_disabled_state();
  ::enterprise_management::DisabledState* mutable_disabled_state();
  void set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state);
  private:
  const ::enterprise_management::DisabledState& _internal_disabled_state() const;
  ::enterprise_management::DisabledState* _internal_mutable_disabled_state();
  public:
  void unsafe_arena_set_allocated_disabled_state(
      ::enterprise_management::DisabledState* disabled_state);
  ::enterprise_management::DisabledState* unsafe_arena_release_disabled_state();

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.InitialEnrollmentMode initial_enrollment_mode = 1 [default = INITIAL_ENROLLMENT_MODE_NONE];
  bool has_initial_enrollment_mode() const;
  private:
  bool _internal_has_initial_enrollment_mode() const;
  public:
  void clear_initial_enrollment_mode();
  ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode initial_enrollment_mode() const;
  void set_initial_enrollment_mode(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value);
  private:
  ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode _internal_initial_enrollment_mode() const;
  void _internal_set_initial_enrollment_mode(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value);
  public:

  // optional bool is_license_packaged_with_device = 3;
  bool has_is_license_packaged_with_device() const;
  private:
  bool _internal_has_is_license_packaged_with_device() const;
  public:
  void clear_is_license_packaged_with_device();
  bool is_license_packaged_with_device() const;
  void set_is_license_packaged_with_device(bool value);
  private:
  bool _internal_is_license_packaged_with_device() const;
  void _internal_set_is_license_packaged_with_device(bool value);
  public:

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.LicensePackagingSKU license_packaging_sku = 5;
  bool has_license_packaging_sku() const;
  private:
  bool _internal_has_license_packaging_sku() const;
  public:
  void clear_license_packaging_sku();
  ::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU license_packaging_sku() const;
  void set_license_packaging_sku(::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU value);
  private:
  ::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU _internal_license_packaging_sku() const;
  void _internal_set_license_packaging_sku(::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU value);
  public:

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.AssignedUpgradeType assigned_upgrade_type = 6;
  bool has_assigned_upgrade_type() const;
  private:
  bool _internal_has_assigned_upgrade_type() const;
  public:
  void clear_assigned_upgrade_type();
  ::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType assigned_upgrade_type() const;
  void set_assigned_upgrade_type(::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType value);
  private:
  ::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType _internal_assigned_upgrade_type() const;
  void _internal_set_assigned_upgrade_type(::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceInitialEnrollmentStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr management_domain_;
    ::enterprise_management::DisabledState* disabled_state_;
    int initial_enrollment_mode_;
    bool is_license_packaged_with_device_;
    int license_packaging_sku_;
    int assigned_upgrade_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DevicePairingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePairingRequest) */ {
 public:
  inline DevicePairingRequest() : DevicePairingRequest(nullptr) {}
  ~DevicePairingRequest() override;
  explicit PROTOBUF_CONSTEXPR DevicePairingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePairingRequest(const DevicePairingRequest& from);
  DevicePairingRequest(DevicePairingRequest&& from) noexcept
    : DevicePairingRequest() {
    *this = ::std::move(from);
  }

  inline DevicePairingRequest& operator=(const DevicePairingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePairingRequest& operator=(DevicePairingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePairingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePairingRequest* internal_default_instance() {
    return reinterpret_cast<const DevicePairingRequest*>(
               &_DevicePairingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(DevicePairingRequest& a, DevicePairingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePairingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePairingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePairingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePairingRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePairingRequest& from);
  void MergeFrom(const DevicePairingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePairingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePairingRequest";
  }
  protected:
  explicit DevicePairingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostDeviceIdFieldNumber = 1,
    kControllerDeviceIdFieldNumber = 2,
  };
  // optional string host_device_id = 1;
  bool has_host_device_id() const;
  private:
  bool _internal_has_host_device_id() const;
  public:
  void clear_host_device_id();
  const std::string& host_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_device_id();
  PROTOBUF_NODISCARD std::string* release_host_device_id();
  void set_allocated_host_device_id(std::string* host_device_id);
  private:
  const std::string& _internal_host_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_device_id(const std::string& value);
  std::string* _internal_mutable_host_device_id();
  public:

  // optional string controller_device_id = 2;
  bool has_controller_device_id() const;
  private:
  bool _internal_has_controller_device_id() const;
  public:
  void clear_controller_device_id();
  const std::string& controller_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controller_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controller_device_id();
  PROTOBUF_NODISCARD std::string* release_controller_device_id();
  void set_allocated_controller_device_id(std::string* controller_device_id);
  private:
  const std::string& _internal_controller_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_device_id(const std::string& value);
  std::string* _internal_mutable_controller_device_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePairingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_device_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_device_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DevicePairingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DevicePairingResponse) */ {
 public:
  inline DevicePairingResponse() : DevicePairingResponse(nullptr) {}
  ~DevicePairingResponse() override;
  explicit PROTOBUF_CONSTEXPR DevicePairingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePairingResponse(const DevicePairingResponse& from);
  DevicePairingResponse(DevicePairingResponse&& from) noexcept
    : DevicePairingResponse() {
    *this = ::std::move(from);
  }

  inline DevicePairingResponse& operator=(const DevicePairingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePairingResponse& operator=(DevicePairingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicePairingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePairingResponse* internal_default_instance() {
    return reinterpret_cast<const DevicePairingResponse*>(
               &_DevicePairingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(DevicePairingResponse& a, DevicePairingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePairingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePairingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePairingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePairingResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicePairingResponse& from);
  void MergeFrom(const DevicePairingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicePairingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DevicePairingResponse";
  }
  protected:
  explicit DevicePairingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DevicePairingResponse_StatusCode StatusCode;
  static constexpr StatusCode SUCCESS =
    DevicePairingResponse_StatusCode_SUCCESS;
  static constexpr StatusCode FAILED =
    DevicePairingResponse_StatusCode_FAILED;
  static constexpr StatusCode HOST_DEVICE_NOT_FOUND =
    DevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND;
  static constexpr StatusCode CONTROLLER_DEVICE_NOT_FOUND =
    DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND;
  static constexpr StatusCode HOST_DEVICE_DEPROVISIONED =
    DevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED;
  static constexpr StatusCode CONTROLLER_DEVICE_DEPROVISIONED =
    DevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
  static inline bool StatusCode_IsValid(int value) {
    return DevicePairingResponse_StatusCode_IsValid(value);
  }
  static constexpr StatusCode StatusCode_MIN =
    DevicePairingResponse_StatusCode_StatusCode_MIN;
  static constexpr StatusCode StatusCode_MAX =
    DevicePairingResponse_StatusCode_StatusCode_MAX;
  static constexpr int StatusCode_ARRAYSIZE =
    DevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& StatusCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StatusCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StatusCode_Name.");
    return DevicePairingResponse_StatusCode_Name(enum_t_value);
  }
  static inline bool StatusCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StatusCode* value) {
    return DevicePairingResponse_StatusCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusCodeFieldNumber = 1,
  };
  // optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
  bool has_status_code() const;
  private:
  bool _internal_has_status_code() const;
  public:
  void clear_status_code();
  ::enterprise_management::DevicePairingResponse_StatusCode status_code() const;
  void set_status_code(::enterprise_management::DevicePairingResponse_StatusCode value);
  private:
  ::enterprise_management::DevicePairingResponse_StatusCode _internal_status_code() const;
  void _internal_set_status_code(::enterprise_management::DevicePairingResponse_StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DevicePairingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int status_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CheckDevicePairingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckDevicePairingRequest) */ {
 public:
  inline CheckDevicePairingRequest() : CheckDevicePairingRequest(nullptr) {}
  ~CheckDevicePairingRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckDevicePairingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckDevicePairingRequest(const CheckDevicePairingRequest& from);
  CheckDevicePairingRequest(CheckDevicePairingRequest&& from) noexcept
    : CheckDevicePairingRequest() {
    *this = ::std::move(from);
  }

  inline CheckDevicePairingRequest& operator=(const CheckDevicePairingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckDevicePairingRequest& operator=(CheckDevicePairingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckDevicePairingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckDevicePairingRequest* internal_default_instance() {
    return reinterpret_cast<const CheckDevicePairingRequest*>(
               &_CheckDevicePairingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(CheckDevicePairingRequest& a, CheckDevicePairingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckDevicePairingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckDevicePairingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckDevicePairingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckDevicePairingRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckDevicePairingRequest& from);
  void MergeFrom(const CheckDevicePairingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckDevicePairingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CheckDevicePairingRequest";
  }
  protected:
  explicit CheckDevicePairingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostDeviceIdFieldNumber = 1,
    kControllerDeviceIdFieldNumber = 2,
  };
  // optional string host_device_id = 1;
  bool has_host_device_id() const;
  private:
  bool _internal_has_host_device_id() const;
  public:
  void clear_host_device_id();
  const std::string& host_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_device_id();
  PROTOBUF_NODISCARD std::string* release_host_device_id();
  void set_allocated_host_device_id(std::string* host_device_id);
  private:
  const std::string& _internal_host_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_device_id(const std::string& value);
  std::string* _internal_mutable_host_device_id();
  public:

  // optional string controller_device_id = 2;
  bool has_controller_device_id() const;
  private:
  bool _internal_has_controller_device_id() const;
  public:
  void clear_controller_device_id();
  const std::string& controller_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controller_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controller_device_id();
  PROTOBUF_NODISCARD std::string* release_controller_device_id();
  void set_allocated_controller_device_id(std::string* controller_device_id);
  private:
  const std::string& _internal_controller_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_device_id(const std::string& value);
  std::string* _internal_mutable_controller_device_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CheckDevicePairingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_device_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_device_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CheckDevicePairingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckDevicePairingResponse) */ {
 public:
  inline CheckDevicePairingResponse() : CheckDevicePairingResponse(nullptr) {}
  ~CheckDevicePairingResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckDevicePairingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckDevicePairingResponse(const CheckDevicePairingResponse& from);
  CheckDevicePairingResponse(CheckDevicePairingResponse&& from) noexcept
    : CheckDevicePairingResponse() {
    *this = ::std::move(from);
  }

  inline CheckDevicePairingResponse& operator=(const CheckDevicePairingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckDevicePairingResponse& operator=(CheckDevicePairingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckDevicePairingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckDevicePairingResponse* internal_default_instance() {
    return reinterpret_cast<const CheckDevicePairingResponse*>(
               &_CheckDevicePairingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(CheckDevicePairingResponse& a, CheckDevicePairingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckDevicePairingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckDevicePairingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckDevicePairingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckDevicePairingResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckDevicePairingResponse& from);
  void MergeFrom(const CheckDevicePairingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckDevicePairingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CheckDevicePairingResponse";
  }
  protected:
  explicit CheckDevicePairingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CheckDevicePairingResponse_StatusCode StatusCode;
  static constexpr StatusCode PAIRED =
    CheckDevicePairingResponse_StatusCode_PAIRED;
  static constexpr StatusCode NOT_PAIRED =
    CheckDevicePairingResponse_StatusCode_NOT_PAIRED;
  static constexpr StatusCode HOST_DEVICE_NOT_FOUND =
    CheckDevicePairingResponse_StatusCode_HOST_DEVICE_NOT_FOUND;
  static constexpr StatusCode CONTROLLER_DEVICE_NOT_FOUND =
    CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_NOT_FOUND;
  static constexpr StatusCode HOST_DEVICE_DEPROVISIONED =
    CheckDevicePairingResponse_StatusCode_HOST_DEVICE_DEPROVISIONED;
  static constexpr StatusCode CONTROLLER_DEVICE_DEPROVISIONED =
    CheckDevicePairingResponse_StatusCode_CONTROLLER_DEVICE_DEPROVISIONED;
  static constexpr StatusCode INVALID_CONTROLLER_DEVICE_IDENTITY =
    CheckDevicePairingResponse_StatusCode_INVALID_CONTROLLER_DEVICE_IDENTITY;
  static inline bool StatusCode_IsValid(int value) {
    return CheckDevicePairingResponse_StatusCode_IsValid(value);
  }
  static constexpr StatusCode StatusCode_MIN =
    CheckDevicePairingResponse_StatusCode_StatusCode_MIN;
  static constexpr StatusCode StatusCode_MAX =
    CheckDevicePairingResponse_StatusCode_StatusCode_MAX;
  static constexpr int StatusCode_ARRAYSIZE =
    CheckDevicePairingResponse_StatusCode_StatusCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& StatusCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StatusCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StatusCode_Name.");
    return CheckDevicePairingResponse_StatusCode_Name(enum_t_value);
  }
  static inline bool StatusCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StatusCode* value) {
    return CheckDevicePairingResponse_StatusCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusCodeFieldNumber = 1,
  };
  // optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
  bool has_status_code() const;
  private:
  bool _internal_has_status_code() const;
  public:
  void clear_status_code();
  ::enterprise_management::CheckDevicePairingResponse_StatusCode status_code() const;
  void set_status_code(::enterprise_management::CheckDevicePairingResponse_StatusCode value);
  private:
  ::enterprise_management::CheckDevicePairingResponse_StatusCode _internal_status_code() const;
  void _internal_set_status_code(::enterprise_management::CheckDevicePairingResponse_StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CheckDevicePairingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int status_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class RemoteCommand final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RemoteCommand) */ {
 public:
  inline RemoteCommand() : RemoteCommand(nullptr) {}
  ~RemoteCommand() override;
  explicit PROTOBUF_CONSTEXPR RemoteCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteCommand(const RemoteCommand& from);
  RemoteCommand(RemoteCommand&& from) noexcept
    : RemoteCommand() {
    *this = ::std::move(from);
  }

  inline RemoteCommand& operator=(const RemoteCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteCommand& operator=(RemoteCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemoteCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteCommand* internal_default_instance() {
    return reinterpret_cast<const RemoteCommand*>(
               &_RemoteCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(RemoteCommand& a, RemoteCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RemoteCommand& from);
  void MergeFrom(const RemoteCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoteCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RemoteCommand";
  }
  protected:
  explicit RemoteCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RemoteCommand_Type Type;
  static constexpr Type COMMAND_ECHO_TEST =
    RemoteCommand_Type_COMMAND_ECHO_TEST;
  static constexpr Type DEVICE_REBOOT =
    RemoteCommand_Type_DEVICE_REBOOT;
  static constexpr Type DEVICE_SCREENSHOT =
    RemoteCommand_Type_DEVICE_SCREENSHOT;
  static constexpr Type DEVICE_SET_VOLUME =
    RemoteCommand_Type_DEVICE_SET_VOLUME;
  static constexpr Type DEVICE_FETCH_STATUS =
    RemoteCommand_Type_DEVICE_FETCH_STATUS;
  static constexpr Type USER_ARC_COMMAND =
    RemoteCommand_Type_USER_ARC_COMMAND;
  static constexpr Type DEVICE_WIPE_USERS =
    RemoteCommand_Type_DEVICE_WIPE_USERS;
  static constexpr Type DEVICE_START_CRD_SESSION =
    RemoteCommand_Type_DEVICE_START_CRD_SESSION;
  static constexpr Type DEVICE_REMOTE_POWERWASH =
    RemoteCommand_Type_DEVICE_REMOTE_POWERWASH;
  static constexpr Type DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE =
    RemoteCommand_Type_DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE;
  static constexpr Type DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES =
    RemoteCommand_Type_DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES;
  static constexpr Type DEVICE_RUN_DIAGNOSTIC_ROUTINE =
    RemoteCommand_Type_DEVICE_RUN_DIAGNOSTIC_ROUTINE;
  static constexpr Type DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE =
    RemoteCommand_Type_DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE;
  static constexpr Type BROWSER_CLEAR_BROWSING_DATA =
    RemoteCommand_Type_BROWSER_CLEAR_BROWSING_DATA;
  static constexpr Type DEVICE_RESET_EUICC =
    RemoteCommand_Type_DEVICE_RESET_EUICC;
  static constexpr Type BROWSER_ROTATE_ATTESTATION_CREDENTIAL =
    RemoteCommand_Type_BROWSER_ROTATE_ATTESTATION_CREDENTIAL;
  static constexpr Type FETCH_CRD_AVAILABILITY_INFO =
    RemoteCommand_Type_FETCH_CRD_AVAILABILITY_INFO;
  static constexpr Type FETCH_SUPPORT_PACKET =
    RemoteCommand_Type_FETCH_SUPPORT_PACKET;
  static inline bool Type_IsValid(int value) {
    return RemoteCommand_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    RemoteCommand_Type_Type_MIN;
  static constexpr Type Type_MAX =
    RemoteCommand_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    RemoteCommand_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return RemoteCommand_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return RemoteCommand_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 4,
    kTargetDeviceIdFieldNumber = 5,
    kCommandIdFieldNumber = 2,
    kAgeOfCommandFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string payload = 4;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // optional string target_device_id = 5;
  bool has_target_device_id() const;
  private:
  bool _internal_has_target_device_id() const;
  public:
  void clear_target_device_id();
  const std::string& target_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_device_id();
  PROTOBUF_NODISCARD std::string* release_target_device_id();
  void set_allocated_target_device_id(std::string* target_device_id);
  private:
  const std::string& _internal_target_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_device_id(const std::string& value);
  std::string* _internal_mutable_target_device_id();
  public:

  // optional int64 command_id = 2;
  bool has_command_id() const;
  private:
  bool _internal_has_command_id() const;
  public:
  void clear_command_id();
  int64_t command_id() const;
  void set_command_id(int64_t value);
  private:
  int64_t _internal_command_id() const;
  void _internal_set_command_id(int64_t value);
  public:

  // optional int64 age_of_command = 3;
  bool has_age_of_command() const;
  private:
  bool _internal_has_age_of_command() const;
  public:
  void clear_age_of_command();
  int64_t age_of_command() const;
  void set_age_of_command(int64_t value);
  private:
  int64_t _internal_age_of_command() const;
  void _internal_set_age_of_command(int64_t value);
  public:

  // optional .enterprise_management.RemoteCommand.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::enterprise_management::RemoteCommand_Type type() const;
  void set_type(::enterprise_management::RemoteCommand_Type value);
  private:
  ::enterprise_management::RemoteCommand_Type _internal_type() const;
  void _internal_set_type(::enterprise_management::RemoteCommand_Type value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.RemoteCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_device_id_;
    int64_t command_id_;
    int64_t age_of_command_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class RemoteCommandResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RemoteCommandResult) */ {
 public:
  inline RemoteCommandResult() : RemoteCommandResult(nullptr) {}
  ~RemoteCommandResult() override;
  explicit PROTOBUF_CONSTEXPR RemoteCommandResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteCommandResult(const RemoteCommandResult& from);
  RemoteCommandResult(RemoteCommandResult&& from) noexcept
    : RemoteCommandResult() {
    *this = ::std::move(from);
  }

  inline RemoteCommandResult& operator=(const RemoteCommandResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteCommandResult& operator=(RemoteCommandResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemoteCommandResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteCommandResult* internal_default_instance() {
    return reinterpret_cast<const RemoteCommandResult*>(
               &_RemoteCommandResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(RemoteCommandResult& a, RemoteCommandResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteCommandResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteCommandResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteCommandResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteCommandResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RemoteCommandResult& from);
  void MergeFrom(const RemoteCommandResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoteCommandResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RemoteCommandResult";
  }
  protected:
  explicit RemoteCommandResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RemoteCommandResult_ResultType ResultType;
  static constexpr ResultType RESULT_IGNORED =
    RemoteCommandResult_ResultType_RESULT_IGNORED;
  static constexpr ResultType RESULT_FAILURE =
    RemoteCommandResult_ResultType_RESULT_FAILURE;
  static constexpr ResultType RESULT_SUCCESS =
    RemoteCommandResult_ResultType_RESULT_SUCCESS;
  static inline bool ResultType_IsValid(int value) {
    return RemoteCommandResult_ResultType_IsValid(value);
  }
  static constexpr ResultType ResultType_MIN =
    RemoteCommandResult_ResultType_ResultType_MIN;
  static constexpr ResultType ResultType_MAX =
    RemoteCommandResult_ResultType_ResultType_MAX;
  static constexpr int ResultType_ARRAYSIZE =
    RemoteCommandResult_ResultType_ResultType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResultType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResultType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResultType_Name.");
    return RemoteCommandResult_ResultType_Name(enum_t_value);
  }
  static inline bool ResultType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResultType* value) {
    return RemoteCommandResult_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 4,
    kCommandIdFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kResultFieldNumber = 1,
  };
  // optional string payload = 4;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // optional int64 command_id = 2;
  bool has_command_id() const;
  private:
  bool _internal_has_command_id() const;
  public:
  void clear_command_id();
  int64_t command_id() const;
  void set_command_id(int64_t value);
  private:
  int64_t _internal_command_id() const;
  void _internal_set_command_id(int64_t value);
  public:

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::enterprise_management::RemoteCommandResult_ResultType result() const;
  void set_result(::enterprise_management::RemoteCommandResult_ResultType value);
  private:
  ::enterprise_management::RemoteCommandResult_ResultType _internal_result() const;
  void _internal_set_result(::enterprise_management::RemoteCommandResult_ResultType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.RemoteCommandResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    int64_t command_id_;
    int64_t timestamp_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceRemoteCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRemoteCommandRequest) */ {
 public:
  inline DeviceRemoteCommandRequest() : DeviceRemoteCommandRequest(nullptr) {}
  ~DeviceRemoteCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceRemoteCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRemoteCommandRequest(const DeviceRemoteCommandRequest& from);
  DeviceRemoteCommandRequest(DeviceRemoteCommandRequest&& from) noexcept
    : DeviceRemoteCommandRequest() {
    *this = ::std::move(from);
  }

  inline DeviceRemoteCommandRequest& operator=(const DeviceRemoteCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRemoteCommandRequest& operator=(DeviceRemoteCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceRemoteCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRemoteCommandRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceRemoteCommandRequest*>(
               &_DeviceRemoteCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(DeviceRemoteCommandRequest& a, DeviceRemoteCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRemoteCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRemoteCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRemoteCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRemoteCommandRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceRemoteCommandRequest& from);
  void MergeFrom(const DeviceRemoteCommandRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRemoteCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceRemoteCommandRequest";
  }
  protected:
  explicit DeviceRemoteCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandResultsFieldNumber = 2,
    kLastCommandUniqueIdFieldNumber = 1,
    kSendSecureCommandsFieldNumber = 3,
    kSignatureTypeFieldNumber = 4,
  };
  // repeated .enterprise_management.RemoteCommandResult command_results = 2;
  int command_results_size() const;
  private:
  int _internal_command_results_size() const;
  public:
  void clear_command_results();
  ::enterprise_management::RemoteCommandResult* mutable_command_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult >*
      mutable_command_results();
  private:
  const ::enterprise_management::RemoteCommandResult& _internal_command_results(int index) const;
  ::enterprise_management::RemoteCommandResult* _internal_add_command_results();
  public:
  const ::enterprise_management::RemoteCommandResult& command_results(int index) const;
  ::enterprise_management::RemoteCommandResult* add_command_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult >&
      command_results() const;

  // optional int64 last_command_unique_id = 1;
  bool has_last_command_unique_id() const;
  private:
  bool _internal_has_last_command_unique_id() const;
  public:
  void clear_last_command_unique_id();
  int64_t last_command_unique_id() const;
  void set_last_command_unique_id(int64_t value);
  private:
  int64_t _internal_last_command_unique_id() const;
  void _internal_set_last_command_unique_id(int64_t value);
  public:

  // optional bool send_secure_commands = 3;
  bool has_send_secure_commands() const;
  private:
  bool _internal_has_send_secure_commands() const;
  public:
  void clear_send_secure_commands();
  bool send_secure_commands() const;
  void set_send_secure_commands(bool value);
  private:
  bool _internal_send_secure_commands() const;
  void _internal_set_send_secure_commands(bool value);
  public:

  // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 4;
  bool has_signature_type() const;
  private:
  bool _internal_has_signature_type() const;
  public:
  void clear_signature_type();
  ::enterprise_management::PolicyFetchRequest_SignatureType signature_type() const;
  void set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);
  private:
  ::enterprise_management::PolicyFetchRequest_SignatureType _internal_signature_type() const;
  void _internal_set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRemoteCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult > command_results_;
    int64_t last_command_unique_id_;
    bool send_secure_commands_;
    int signature_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceRemoteCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRemoteCommandResponse) */ {
 public:
  inline DeviceRemoteCommandResponse() : DeviceRemoteCommandResponse(nullptr) {}
  ~DeviceRemoteCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceRemoteCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRemoteCommandResponse(const DeviceRemoteCommandResponse& from);
  DeviceRemoteCommandResponse(DeviceRemoteCommandResponse&& from) noexcept
    : DeviceRemoteCommandResponse() {
    *this = ::std::move(from);
  }

  inline DeviceRemoteCommandResponse& operator=(const DeviceRemoteCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRemoteCommandResponse& operator=(DeviceRemoteCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceRemoteCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRemoteCommandResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceRemoteCommandResponse*>(
               &_DeviceRemoteCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(DeviceRemoteCommandResponse& a, DeviceRemoteCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRemoteCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRemoteCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRemoteCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRemoteCommandResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceRemoteCommandResponse& from);
  void MergeFrom(const DeviceRemoteCommandResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRemoteCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceRemoteCommandResponse";
  }
  protected:
  explicit DeviceRemoteCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 1,
    kSecureCommandsFieldNumber = 2,
  };
  // repeated .enterprise_management.RemoteCommand commands = 1;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::enterprise_management::RemoteCommand* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand >*
      mutable_commands();
  private:
  const ::enterprise_management::RemoteCommand& _internal_commands(int index) const;
  ::enterprise_management::RemoteCommand* _internal_add_commands();
  public:
  const ::enterprise_management::RemoteCommand& commands(int index) const;
  ::enterprise_management::RemoteCommand* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand >&
      commands() const;

  // repeated .enterprise_management.SignedData secure_commands = 2;
  int secure_commands_size() const;
  private:
  int _internal_secure_commands_size() const;
  public:
  void clear_secure_commands();
  ::enterprise_management::SignedData* mutable_secure_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData >*
      mutable_secure_commands();
  private:
  const ::enterprise_management::SignedData& _internal_secure_commands(int index) const;
  ::enterprise_management::SignedData* _internal_add_secure_commands();
  public:
  const ::enterprise_management::SignedData& secure_commands(int index) const;
  ::enterprise_management::SignedData* add_secure_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData >&
      secure_commands() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRemoteCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand > commands_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData > secure_commands_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceAttributeUpdatePermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAttributeUpdatePermissionRequest) */ {
 public:
  inline DeviceAttributeUpdatePermissionRequest() : DeviceAttributeUpdatePermissionRequest(nullptr) {}
  ~DeviceAttributeUpdatePermissionRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceAttributeUpdatePermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAttributeUpdatePermissionRequest(const DeviceAttributeUpdatePermissionRequest& from);
  DeviceAttributeUpdatePermissionRequest(DeviceAttributeUpdatePermissionRequest&& from) noexcept
    : DeviceAttributeUpdatePermissionRequest() {
    *this = ::std::move(from);
  }

  inline DeviceAttributeUpdatePermissionRequest& operator=(const DeviceAttributeUpdatePermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAttributeUpdatePermissionRequest& operator=(DeviceAttributeUpdatePermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAttributeUpdatePermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAttributeUpdatePermissionRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceAttributeUpdatePermissionRequest*>(
               &_DeviceAttributeUpdatePermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(DeviceAttributeUpdatePermissionRequest& a, DeviceAttributeUpdatePermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAttributeUpdatePermissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAttributeUpdatePermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAttributeUpdatePermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAttributeUpdatePermissionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAttributeUpdatePermissionRequest& from);
  void MergeFrom(const DeviceAttributeUpdatePermissionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAttributeUpdatePermissionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAttributeUpdatePermissionRequest";
  }
  protected:
  explicit DeviceAttributeUpdatePermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdatePermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceAttributeUpdatePermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAttributeUpdatePermissionResponse) */ {
 public:
  inline DeviceAttributeUpdatePermissionResponse() : DeviceAttributeUpdatePermissionResponse(nullptr) {}
  ~DeviceAttributeUpdatePermissionResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceAttributeUpdatePermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAttributeUpdatePermissionResponse(const DeviceAttributeUpdatePermissionResponse& from);
  DeviceAttributeUpdatePermissionResponse(DeviceAttributeUpdatePermissionResponse&& from) noexcept
    : DeviceAttributeUpdatePermissionResponse() {
    *this = ::std::move(from);
  }

  inline DeviceAttributeUpdatePermissionResponse& operator=(const DeviceAttributeUpdatePermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAttributeUpdatePermissionResponse& operator=(DeviceAttributeUpdatePermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAttributeUpdatePermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAttributeUpdatePermissionResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceAttributeUpdatePermissionResponse*>(
               &_DeviceAttributeUpdatePermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(DeviceAttributeUpdatePermissionResponse& a, DeviceAttributeUpdatePermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAttributeUpdatePermissionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAttributeUpdatePermissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAttributeUpdatePermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAttributeUpdatePermissionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAttributeUpdatePermissionResponse& from);
  void MergeFrom(const DeviceAttributeUpdatePermissionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAttributeUpdatePermissionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAttributeUpdatePermissionResponse";
  }
  protected:
  explicit DeviceAttributeUpdatePermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceAttributeUpdatePermissionResponse_ResultType ResultType;
  static constexpr ResultType ATTRIBUTE_UPDATE_DISALLOWED =
    DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_DISALLOWED;
  static constexpr ResultType ATTRIBUTE_UPDATE_ALLOWED =
    DeviceAttributeUpdatePermissionResponse_ResultType_ATTRIBUTE_UPDATE_ALLOWED;
  static inline bool ResultType_IsValid(int value) {
    return DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(value);
  }
  static constexpr ResultType ResultType_MIN =
    DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MIN;
  static constexpr ResultType ResultType_MAX =
    DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_MAX;
  static constexpr int ResultType_ARRAYSIZE =
    DeviceAttributeUpdatePermissionResponse_ResultType_ResultType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResultType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResultType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResultType_Name.");
    return DeviceAttributeUpdatePermissionResponse_ResultType_Name(enum_t_value);
  }
  static inline bool ResultType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResultType* value) {
    return DeviceAttributeUpdatePermissionResponse_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType result() const;
  void set_result(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType value);
  private:
  ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType _internal_result() const;
  void _internal_set_result(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdatePermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceAttributeUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAttributeUpdateRequest) */ {
 public:
  inline DeviceAttributeUpdateRequest() : DeviceAttributeUpdateRequest(nullptr) {}
  ~DeviceAttributeUpdateRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceAttributeUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAttributeUpdateRequest(const DeviceAttributeUpdateRequest& from);
  DeviceAttributeUpdateRequest(DeviceAttributeUpdateRequest&& from) noexcept
    : DeviceAttributeUpdateRequest() {
    *this = ::std::move(from);
  }

  inline DeviceAttributeUpdateRequest& operator=(const DeviceAttributeUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAttributeUpdateRequest& operator=(DeviceAttributeUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAttributeUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAttributeUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceAttributeUpdateRequest*>(
               &_DeviceAttributeUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(DeviceAttributeUpdateRequest& a, DeviceAttributeUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAttributeUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAttributeUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAttributeUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAttributeUpdateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAttributeUpdateRequest& from);
  void MergeFrom(const DeviceAttributeUpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAttributeUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAttributeUpdateRequest";
  }
  protected:
  explicit DeviceAttributeUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // optional string asset_id = 1;
  bool has_asset_id() const;
  private:
  bool _internal_has_asset_id() const;
  public:
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // optional string location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceAttributeUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceAttributeUpdateResponse) */ {
 public:
  inline DeviceAttributeUpdateResponse() : DeviceAttributeUpdateResponse(nullptr) {}
  ~DeviceAttributeUpdateResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceAttributeUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAttributeUpdateResponse(const DeviceAttributeUpdateResponse& from);
  DeviceAttributeUpdateResponse(DeviceAttributeUpdateResponse&& from) noexcept
    : DeviceAttributeUpdateResponse() {
    *this = ::std::move(from);
  }

  inline DeviceAttributeUpdateResponse& operator=(const DeviceAttributeUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAttributeUpdateResponse& operator=(DeviceAttributeUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceAttributeUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAttributeUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceAttributeUpdateResponse*>(
               &_DeviceAttributeUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(DeviceAttributeUpdateResponse& a, DeviceAttributeUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAttributeUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAttributeUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAttributeUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAttributeUpdateResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceAttributeUpdateResponse& from);
  void MergeFrom(const DeviceAttributeUpdateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceAttributeUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceAttributeUpdateResponse";
  }
  protected:
  explicit DeviceAttributeUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceAttributeUpdateResponse_ResultType ResultType;
  static constexpr ResultType ATTRIBUTE_UPDATE_ERROR =
    DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_ERROR;
  static constexpr ResultType ATTRIBUTE_UPDATE_SUCCESS =
    DeviceAttributeUpdateResponse_ResultType_ATTRIBUTE_UPDATE_SUCCESS;
  static inline bool ResultType_IsValid(int value) {
    return DeviceAttributeUpdateResponse_ResultType_IsValid(value);
  }
  static constexpr ResultType ResultType_MIN =
    DeviceAttributeUpdateResponse_ResultType_ResultType_MIN;
  static constexpr ResultType ResultType_MAX =
    DeviceAttributeUpdateResponse_ResultType_ResultType_MAX;
  static constexpr int ResultType_ARRAYSIZE =
    DeviceAttributeUpdateResponse_ResultType_ResultType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResultType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResultType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResultType_Name.");
    return DeviceAttributeUpdateResponse_ResultType_Name(enum_t_value);
  }
  static inline bool ResultType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResultType* value) {
    return DeviceAttributeUpdateResponse_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::enterprise_management::DeviceAttributeUpdateResponse_ResultType result() const;
  void set_result(::enterprise_management::DeviceAttributeUpdateResponse_ResultType value);
  private:
  ::enterprise_management::DeviceAttributeUpdateResponse_ResultType _internal_result() const;
  void _internal_set_result(::enterprise_management::DeviceAttributeUpdateResponse_ResultType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceAttributeUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class GcmIdUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GcmIdUpdateRequest) */ {
 public:
  inline GcmIdUpdateRequest() : GcmIdUpdateRequest(nullptr) {}
  ~GcmIdUpdateRequest() override;
  explicit PROTOBUF_CONSTEXPR GcmIdUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GcmIdUpdateRequest(const GcmIdUpdateRequest& from);
  GcmIdUpdateRequest(GcmIdUpdateRequest&& from) noexcept
    : GcmIdUpdateRequest() {
    *this = ::std::move(from);
  }

  inline GcmIdUpdateRequest& operator=(const GcmIdUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GcmIdUpdateRequest& operator=(GcmIdUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GcmIdUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GcmIdUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const GcmIdUpdateRequest*>(
               &_GcmIdUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(GcmIdUpdateRequest& a, GcmIdUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GcmIdUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GcmIdUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GcmIdUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GcmIdUpdateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GcmIdUpdateRequest& from);
  void MergeFrom(const GcmIdUpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GcmIdUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.GcmIdUpdateRequest";
  }
  protected:
  explicit GcmIdUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGcmIdFieldNumber = 1,
  };
  // optional string gcm_id = 1;
  bool has_gcm_id() const;
  private:
  bool _internal_has_gcm_id() const;
  public:
  void clear_gcm_id();
  const std::string& gcm_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gcm_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gcm_id();
  PROTOBUF_NODISCARD std::string* release_gcm_id();
  void set_allocated_gcm_id(std::string* gcm_id);
  private:
  const std::string& _internal_gcm_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gcm_id(const std::string& value);
  std::string* _internal_mutable_gcm_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.GcmIdUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gcm_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class GcmIdUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.GcmIdUpdateResponse) */ {
 public:
  inline GcmIdUpdateResponse() : GcmIdUpdateResponse(nullptr) {}
  ~GcmIdUpdateResponse() override;
  explicit PROTOBUF_CONSTEXPR GcmIdUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GcmIdUpdateResponse(const GcmIdUpdateResponse& from);
  GcmIdUpdateResponse(GcmIdUpdateResponse&& from) noexcept
    : GcmIdUpdateResponse() {
    *this = ::std::move(from);
  }

  inline GcmIdUpdateResponse& operator=(const GcmIdUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GcmIdUpdateResponse& operator=(GcmIdUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GcmIdUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GcmIdUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const GcmIdUpdateResponse*>(
               &_GcmIdUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(GcmIdUpdateResponse& a, GcmIdUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GcmIdUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GcmIdUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GcmIdUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GcmIdUpdateResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GcmIdUpdateResponse& from);
  void MergeFrom(const GcmIdUpdateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GcmIdUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.GcmIdUpdateResponse";
  }
  protected:
  explicit GcmIdUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.GcmIdUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CheckAndroidManagementRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckAndroidManagementRequest) */ {
 public:
  inline CheckAndroidManagementRequest() : CheckAndroidManagementRequest(nullptr) {}
  ~CheckAndroidManagementRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckAndroidManagementRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckAndroidManagementRequest(const CheckAndroidManagementRequest& from);
  CheckAndroidManagementRequest(CheckAndroidManagementRequest&& from) noexcept
    : CheckAndroidManagementRequest() {
    *this = ::std::move(from);
  }

  inline CheckAndroidManagementRequest& operator=(const CheckAndroidManagementRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckAndroidManagementRequest& operator=(CheckAndroidManagementRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckAndroidManagementRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckAndroidManagementRequest* internal_default_instance() {
    return reinterpret_cast<const CheckAndroidManagementRequest*>(
               &_CheckAndroidManagementRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(CheckAndroidManagementRequest& a, CheckAndroidManagementRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckAndroidManagementRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckAndroidManagementRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckAndroidManagementRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckAndroidManagementRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckAndroidManagementRequest& from);
  void MergeFrom(const CheckAndroidManagementRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckAndroidManagementRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CheckAndroidManagementRequest";
  }
  protected:
  explicit CheckAndroidManagementRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.CheckAndroidManagementRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CheckAndroidManagementResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckAndroidManagementResponse) */ {
 public:
  inline CheckAndroidManagementResponse() : CheckAndroidManagementResponse(nullptr) {}
  ~CheckAndroidManagementResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckAndroidManagementResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckAndroidManagementResponse(const CheckAndroidManagementResponse& from);
  CheckAndroidManagementResponse(CheckAndroidManagementResponse&& from) noexcept
    : CheckAndroidManagementResponse() {
    *this = ::std::move(from);
  }

  inline CheckAndroidManagementResponse& operator=(const CheckAndroidManagementResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckAndroidManagementResponse& operator=(CheckAndroidManagementResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckAndroidManagementResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckAndroidManagementResponse* internal_default_instance() {
    return reinterpret_cast<const CheckAndroidManagementResponse*>(
               &_CheckAndroidManagementResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(CheckAndroidManagementResponse& a, CheckAndroidManagementResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckAndroidManagementResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckAndroidManagementResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckAndroidManagementResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckAndroidManagementResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckAndroidManagementResponse& from);
  void MergeFrom(const CheckAndroidManagementResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckAndroidManagementResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CheckAndroidManagementResponse";
  }
  protected:
  explicit CheckAndroidManagementResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.CheckAndroidManagementResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertificateBasedDeviceRegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertificateBasedDeviceRegisterRequest) */ {
 public:
  inline CertificateBasedDeviceRegisterRequest() : CertificateBasedDeviceRegisterRequest(nullptr) {}
  ~CertificateBasedDeviceRegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR CertificateBasedDeviceRegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateBasedDeviceRegisterRequest(const CertificateBasedDeviceRegisterRequest& from);
  CertificateBasedDeviceRegisterRequest(CertificateBasedDeviceRegisterRequest&& from) noexcept
    : CertificateBasedDeviceRegisterRequest() {
    *this = ::std::move(from);
  }

  inline CertificateBasedDeviceRegisterRequest& operator=(const CertificateBasedDeviceRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateBasedDeviceRegisterRequest& operator=(CertificateBasedDeviceRegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertificateBasedDeviceRegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateBasedDeviceRegisterRequest* internal_default_instance() {
    return reinterpret_cast<const CertificateBasedDeviceRegisterRequest*>(
               &_CertificateBasedDeviceRegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(CertificateBasedDeviceRegisterRequest& a, CertificateBasedDeviceRegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateBasedDeviceRegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateBasedDeviceRegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificateBasedDeviceRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificateBasedDeviceRegisterRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertificateBasedDeviceRegisterRequest& from);
  void MergeFrom(const CertificateBasedDeviceRegisterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertificateBasedDeviceRegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertificateBasedDeviceRegisterRequest";
  }
  protected:
  explicit CertificateBasedDeviceRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedRequestFieldNumber = 1,
  };
  // optional .enterprise_management.SignedData signed_request = 1;
  bool has_signed_request() const;
  private:
  bool _internal_has_signed_request() const;
  public:
  void clear_signed_request();
  const ::enterprise_management::SignedData& signed_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::SignedData* release_signed_request();
  ::enterprise_management::SignedData* mutable_signed_request();
  void set_allocated_signed_request(::enterprise_management::SignedData* signed_request);
  private:
  const ::enterprise_management::SignedData& _internal_signed_request() const;
  ::enterprise_management::SignedData* _internal_mutable_signed_request();
  public:
  void unsafe_arena_set_allocated_signed_request(
      ::enterprise_management::SignedData* signed_request);
  ::enterprise_management::SignedData* unsafe_arena_release_signed_request();

  // @@protoc_insertion_point(class_scope:enterprise_management.CertificateBasedDeviceRegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::SignedData* signed_request_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceRegisterConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceRegisterConfiguration) */ {
 public:
  inline DeviceRegisterConfiguration() : DeviceRegisterConfiguration(nullptr) {}
  ~DeviceRegisterConfiguration() override;
  explicit PROTOBUF_CONSTEXPR DeviceRegisterConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRegisterConfiguration(const DeviceRegisterConfiguration& from);
  DeviceRegisterConfiguration(DeviceRegisterConfiguration&& from) noexcept
    : DeviceRegisterConfiguration() {
    *this = ::std::move(from);
  }

  inline DeviceRegisterConfiguration& operator=(const DeviceRegisterConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRegisterConfiguration& operator=(DeviceRegisterConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceRegisterConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRegisterConfiguration* internal_default_instance() {
    return reinterpret_cast<const DeviceRegisterConfiguration*>(
               &_DeviceRegisterConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(DeviceRegisterConfiguration& a, DeviceRegisterConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRegisterConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRegisterConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRegisterConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRegisterConfiguration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceRegisterConfiguration& from);
  void MergeFrom(const DeviceRegisterConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRegisterConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceRegisterConfiguration";
  }
  protected:
  explicit DeviceRegisterConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceOwnerFieldNumber = 1,
  };
  // optional string device_owner = 1;
  bool has_device_owner() const;
  private:
  bool _internal_has_device_owner() const;
  public:
  void clear_device_owner();
  const std::string& device_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_owner();
  PROTOBUF_NODISCARD std::string* release_device_owner();
  void set_allocated_device_owner(std::string* device_owner);
  private:
  const std::string& _internal_device_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_owner(const std::string& value);
  std::string* _internal_mutable_device_owner();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceRegisterConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_owner_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertificateBasedDeviceRegistrationData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertificateBasedDeviceRegistrationData) */ {
 public:
  inline CertificateBasedDeviceRegistrationData() : CertificateBasedDeviceRegistrationData(nullptr) {}
  ~CertificateBasedDeviceRegistrationData() override;
  explicit PROTOBUF_CONSTEXPR CertificateBasedDeviceRegistrationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateBasedDeviceRegistrationData(const CertificateBasedDeviceRegistrationData& from);
  CertificateBasedDeviceRegistrationData(CertificateBasedDeviceRegistrationData&& from) noexcept
    : CertificateBasedDeviceRegistrationData() {
    *this = ::std::move(from);
  }

  inline CertificateBasedDeviceRegistrationData& operator=(const CertificateBasedDeviceRegistrationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateBasedDeviceRegistrationData& operator=(CertificateBasedDeviceRegistrationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertificateBasedDeviceRegistrationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateBasedDeviceRegistrationData* internal_default_instance() {
    return reinterpret_cast<const CertificateBasedDeviceRegistrationData*>(
               &_CertificateBasedDeviceRegistrationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(CertificateBasedDeviceRegistrationData& a, CertificateBasedDeviceRegistrationData& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateBasedDeviceRegistrationData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateBasedDeviceRegistrationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificateBasedDeviceRegistrationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificateBasedDeviceRegistrationData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertificateBasedDeviceRegistrationData& from);
  void MergeFrom(const CertificateBasedDeviceRegistrationData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertificateBasedDeviceRegistrationData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertificateBasedDeviceRegistrationData";
  }
  protected:
  explicit CertificateBasedDeviceRegistrationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CertificateBasedDeviceRegistrationData_CertificateType CertificateType;
  static constexpr CertificateType UNKNOWN =
    CertificateBasedDeviceRegistrationData_CertificateType_UNKNOWN;
  static constexpr CertificateType ENTERPRISE_ENROLLMENT_CERTIFICATE =
    CertificateBasedDeviceRegistrationData_CertificateType_ENTERPRISE_ENROLLMENT_CERTIFICATE;
  static inline bool CertificateType_IsValid(int value) {
    return CertificateBasedDeviceRegistrationData_CertificateType_IsValid(value);
  }
  static constexpr CertificateType CertificateType_MIN =
    CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MIN;
  static constexpr CertificateType CertificateType_MAX =
    CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_MAX;
  static constexpr int CertificateType_ARRAYSIZE =
    CertificateBasedDeviceRegistrationData_CertificateType_CertificateType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CertificateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CertificateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CertificateType_Name.");
    return CertificateBasedDeviceRegistrationData_CertificateType_Name(enum_t_value);
  }
  static inline bool CertificateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CertificateType* value) {
    return CertificateBasedDeviceRegistrationData_CertificateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceCertificateFieldNumber = 2,
    kDeviceRegisterRequestFieldNumber = 3,
    kDeviceRegisterConfigurationFieldNumber = 4,
    kCertificateTypeFieldNumber = 1,
  };
  // optional bytes device_certificate = 2;
  bool has_device_certificate() const;
  private:
  bool _internal_has_device_certificate() const;
  public:
  void clear_device_certificate();
  const std::string& device_certificate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_certificate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_certificate();
  PROTOBUF_NODISCARD std::string* release_device_certificate();
  void set_allocated_device_certificate(std::string* device_certificate);
  private:
  const std::string& _internal_device_certificate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_certificate(const std::string& value);
  std::string* _internal_mutable_device_certificate();
  public:

  // optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
  bool has_device_register_request() const;
  private:
  bool _internal_has_device_register_request() const;
  public:
  void clear_device_register_request();
  const ::enterprise_management::DeviceRegisterRequest& device_register_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRegisterRequest* release_device_register_request();
  ::enterprise_management::DeviceRegisterRequest* mutable_device_register_request();
  void set_allocated_device_register_request(::enterprise_management::DeviceRegisterRequest* device_register_request);
  private:
  const ::enterprise_management::DeviceRegisterRequest& _internal_device_register_request() const;
  ::enterprise_management::DeviceRegisterRequest* _internal_mutable_device_register_request();
  public:
  void unsafe_arena_set_allocated_device_register_request(
      ::enterprise_management::DeviceRegisterRequest* device_register_request);
  ::enterprise_management::DeviceRegisterRequest* unsafe_arena_release_device_register_request();

  // optional .enterprise_management.DeviceRegisterConfiguration device_register_configuration = 4;
  bool has_device_register_configuration() const;
  private:
  bool _internal_has_device_register_configuration() const;
  public:
  void clear_device_register_configuration();
  const ::enterprise_management::DeviceRegisterConfiguration& device_register_configuration() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRegisterConfiguration* release_device_register_configuration();
  ::enterprise_management::DeviceRegisterConfiguration* mutable_device_register_configuration();
  void set_allocated_device_register_configuration(::enterprise_management::DeviceRegisterConfiguration* device_register_configuration);
  private:
  const ::enterprise_management::DeviceRegisterConfiguration& _internal_device_register_configuration() const;
  ::enterprise_management::DeviceRegisterConfiguration* _internal_mutable_device_register_configuration();
  public:
  void unsafe_arena_set_allocated_device_register_configuration(
      ::enterprise_management::DeviceRegisterConfiguration* device_register_configuration);
  ::enterprise_management::DeviceRegisterConfiguration* unsafe_arena_release_device_register_configuration();

  // optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
  bool has_certificate_type() const;
  private:
  bool _internal_has_certificate_type() const;
  public:
  void clear_certificate_type();
  ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType certificate_type() const;
  void set_certificate_type(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType value);
  private:
  ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType _internal_certificate_type() const;
  void _internal_set_certificate_type(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CertificateBasedDeviceRegistrationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_certificate_;
    ::enterprise_management::DeviceRegisterRequest* device_register_request_;
    ::enterprise_management::DeviceRegisterConfiguration* device_register_configuration_;
    int certificate_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class RegisterBrowserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RegisterBrowserRequest) */ {
 public:
  inline RegisterBrowserRequest() : RegisterBrowserRequest(nullptr) {}
  ~RegisterBrowserRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterBrowserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterBrowserRequest(const RegisterBrowserRequest& from);
  RegisterBrowserRequest(RegisterBrowserRequest&& from) noexcept
    : RegisterBrowserRequest() {
    *this = ::std::move(from);
  }

  inline RegisterBrowserRequest& operator=(const RegisterBrowserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterBrowserRequest& operator=(RegisterBrowserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RegisterBrowserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterBrowserRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterBrowserRequest*>(
               &_RegisterBrowserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(RegisterBrowserRequest& a, RegisterBrowserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterBrowserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterBrowserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterBrowserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterBrowserRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RegisterBrowserRequest& from);
  void MergeFrom(const RegisterBrowserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterBrowserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RegisterBrowserRequest";
  }
  protected:
  explicit RegisterBrowserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachineNameFieldNumber = 1,
    kOsPlatformFieldNumber = 2,
    kOsVersionFieldNumber = 3,
    kDeviceModelFieldNumber = 5,
    kBrandNameFieldNumber = 6,
    kBrowserDeviceIdentifierFieldNumber = 4,
  };
  // optional string machine_name = 1;
  bool has_machine_name() const;
  private:
  bool _internal_has_machine_name() const;
  public:
  void clear_machine_name();
  const std::string& machine_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_name();
  PROTOBUF_NODISCARD std::string* release_machine_name();
  void set_allocated_machine_name(std::string* machine_name);
  private:
  const std::string& _internal_machine_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_name(const std::string& value);
  std::string* _internal_mutable_machine_name();
  public:

  // optional string os_platform = 2;
  bool has_os_platform() const;
  private:
  bool _internal_has_os_platform() const;
  public:
  void clear_os_platform();
  const std::string& os_platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_platform();
  PROTOBUF_NODISCARD std::string* release_os_platform();
  void set_allocated_os_platform(std::string* os_platform);
  private:
  const std::string& _internal_os_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_platform(const std::string& value);
  std::string* _internal_mutable_os_platform();
  public:

  // optional string os_version = 3;
  bool has_os_version() const;
  private:
  bool _internal_has_os_version() const;
  public:
  void clear_os_version();
  const std::string& os_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_version();
  PROTOBUF_NODISCARD std::string* release_os_version();
  void set_allocated_os_version(std::string* os_version);
  private:
  const std::string& _internal_os_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(const std::string& value);
  std::string* _internal_mutable_os_version();
  public:

  // optional string device_model = 5;
  bool has_device_model() const;
  private:
  bool _internal_has_device_model() const;
  public:
  void clear_device_model();
  const std::string& device_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_model();
  PROTOBUF_NODISCARD std::string* release_device_model();
  void set_allocated_device_model(std::string* device_model);
  private:
  const std::string& _internal_device_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_model(const std::string& value);
  std::string* _internal_mutable_device_model();
  public:

  // optional string brand_name = 6;
  bool has_brand_name() const;
  private:
  bool _internal_has_brand_name() const;
  public:
  void clear_brand_name();
  const std::string& brand_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brand_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brand_name();
  PROTOBUF_NODISCARD std::string* release_brand_name();
  void set_allocated_brand_name(std::string* brand_name);
  private:
  const std::string& _internal_brand_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brand_name(const std::string& value);
  std::string* _internal_mutable_brand_name();
  public:

  // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 4;
  bool has_browser_device_identifier() const;
  private:
  bool _internal_has_browser_device_identifier() const;
  public:
  void clear_browser_device_identifier();
  const ::enterprise_management::BrowserDeviceIdentifier& browser_device_identifier() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserDeviceIdentifier* release_browser_device_identifier();
  ::enterprise_management::BrowserDeviceIdentifier* mutable_browser_device_identifier();
  void set_allocated_browser_device_identifier(::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier);
  private:
  const ::enterprise_management::BrowserDeviceIdentifier& _internal_browser_device_identifier() const;
  ::enterprise_management::BrowserDeviceIdentifier* _internal_mutable_browser_device_identifier();
  public:
  void unsafe_arena_set_allocated_browser_device_identifier(
      ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier);
  ::enterprise_management::BrowserDeviceIdentifier* unsafe_arena_release_browser_device_identifier();

  // @@protoc_insertion_point(class_scope:enterprise_management.RegisterBrowserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_platform_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_name_;
    ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ActiveDirectoryEnrollPlayUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryEnrollPlayUserRequest) */ {
 public:
  inline ActiveDirectoryEnrollPlayUserRequest() : ActiveDirectoryEnrollPlayUserRequest(nullptr) {}
  ~ActiveDirectoryEnrollPlayUserRequest() override;
  explicit PROTOBUF_CONSTEXPR ActiveDirectoryEnrollPlayUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveDirectoryEnrollPlayUserRequest(const ActiveDirectoryEnrollPlayUserRequest& from);
  ActiveDirectoryEnrollPlayUserRequest(ActiveDirectoryEnrollPlayUserRequest&& from) noexcept
    : ActiveDirectoryEnrollPlayUserRequest() {
    *this = ::std::move(from);
  }

  inline ActiveDirectoryEnrollPlayUserRequest& operator=(const ActiveDirectoryEnrollPlayUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveDirectoryEnrollPlayUserRequest& operator=(ActiveDirectoryEnrollPlayUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActiveDirectoryEnrollPlayUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveDirectoryEnrollPlayUserRequest* internal_default_instance() {
    return reinterpret_cast<const ActiveDirectoryEnrollPlayUserRequest*>(
               &_ActiveDirectoryEnrollPlayUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(ActiveDirectoryEnrollPlayUserRequest& a, ActiveDirectoryEnrollPlayUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveDirectoryEnrollPlayUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveDirectoryEnrollPlayUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveDirectoryEnrollPlayUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveDirectoryEnrollPlayUserRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActiveDirectoryEnrollPlayUserRequest& from);
  void MergeFrom(const ActiveDirectoryEnrollPlayUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActiveDirectoryEnrollPlayUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ActiveDirectoryEnrollPlayUserRequest";
  }
  protected:
  explicit ActiveDirectoryEnrollPlayUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthSessionIdFieldNumber = 1,
  };
  // optional string auth_session_id = 1;
  bool has_auth_session_id() const;
  private:
  bool _internal_has_auth_session_id() const;
  public:
  void clear_auth_session_id();
  const std::string& auth_session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_session_id();
  PROTOBUF_NODISCARD std::string* release_auth_session_id();
  void set_allocated_auth_session_id(std::string* auth_session_id);
  private:
  const std::string& _internal_auth_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_session_id(const std::string& value);
  std::string* _internal_mutable_auth_session_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_session_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ActiveDirectoryEnrollPlayUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryEnrollPlayUserResponse) */ {
 public:
  inline ActiveDirectoryEnrollPlayUserResponse() : ActiveDirectoryEnrollPlayUserResponse(nullptr) {}
  ~ActiveDirectoryEnrollPlayUserResponse() override;
  explicit PROTOBUF_CONSTEXPR ActiveDirectoryEnrollPlayUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveDirectoryEnrollPlayUserResponse(const ActiveDirectoryEnrollPlayUserResponse& from);
  ActiveDirectoryEnrollPlayUserResponse(ActiveDirectoryEnrollPlayUserResponse&& from) noexcept
    : ActiveDirectoryEnrollPlayUserResponse() {
    *this = ::std::move(from);
  }

  inline ActiveDirectoryEnrollPlayUserResponse& operator=(const ActiveDirectoryEnrollPlayUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveDirectoryEnrollPlayUserResponse& operator=(ActiveDirectoryEnrollPlayUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActiveDirectoryEnrollPlayUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveDirectoryEnrollPlayUserResponse* internal_default_instance() {
    return reinterpret_cast<const ActiveDirectoryEnrollPlayUserResponse*>(
               &_ActiveDirectoryEnrollPlayUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(ActiveDirectoryEnrollPlayUserResponse& a, ActiveDirectoryEnrollPlayUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveDirectoryEnrollPlayUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveDirectoryEnrollPlayUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveDirectoryEnrollPlayUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveDirectoryEnrollPlayUserResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActiveDirectoryEnrollPlayUserResponse& from);
  void MergeFrom(const ActiveDirectoryEnrollPlayUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActiveDirectoryEnrollPlayUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ActiveDirectoryEnrollPlayUserResponse";
  }
  protected:
  explicit ActiveDirectoryEnrollPlayUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentTokenFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kSamlParametersFieldNumber = 3,
  };
  // optional string enrollment_token = 1;
  bool has_enrollment_token() const;
  private:
  bool _internal_has_enrollment_token() const;
  public:
  void clear_enrollment_token();
  const std::string& enrollment_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollment_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollment_token();
  PROTOBUF_NODISCARD std::string* release_enrollment_token();
  void set_allocated_enrollment_token(std::string* enrollment_token);
  private:
  const std::string& _internal_enrollment_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollment_token(const std::string& value);
  std::string* _internal_mutable_enrollment_token();
  public:

  // optional string user_id = 2;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional .enterprise_management.SamlParametersProto saml_parameters = 3;
  bool has_saml_parameters() const;
  private:
  bool _internal_has_saml_parameters() const;
  public:
  void clear_saml_parameters();
  const ::enterprise_management::SamlParametersProto& saml_parameters() const;
  PROTOBUF_NODISCARD ::enterprise_management::SamlParametersProto* release_saml_parameters();
  ::enterprise_management::SamlParametersProto* mutable_saml_parameters();
  void set_allocated_saml_parameters(::enterprise_management::SamlParametersProto* saml_parameters);
  private:
  const ::enterprise_management::SamlParametersProto& _internal_saml_parameters() const;
  ::enterprise_management::SamlParametersProto* _internal_mutable_saml_parameters();
  public:
  void unsafe_arena_set_allocated_saml_parameters(
      ::enterprise_management::SamlParametersProto* saml_parameters);
  ::enterprise_management::SamlParametersProto* unsafe_arena_release_saml_parameters();

  // @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollment_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::enterprise_management::SamlParametersProto* saml_parameters_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class SamlParametersProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SamlParametersProto) */ {
 public:
  inline SamlParametersProto() : SamlParametersProto(nullptr) {}
  ~SamlParametersProto() override;
  explicit PROTOBUF_CONSTEXPR SamlParametersProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SamlParametersProto(const SamlParametersProto& from);
  SamlParametersProto(SamlParametersProto&& from) noexcept
    : SamlParametersProto() {
    *this = ::std::move(from);
  }

  inline SamlParametersProto& operator=(const SamlParametersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SamlParametersProto& operator=(SamlParametersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SamlParametersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SamlParametersProto* internal_default_instance() {
    return reinterpret_cast<const SamlParametersProto*>(
               &_SamlParametersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(SamlParametersProto& a, SamlParametersProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SamlParametersProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SamlParametersProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SamlParametersProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SamlParametersProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SamlParametersProto& from);
  void MergeFrom(const SamlParametersProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SamlParametersProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SamlParametersProto";
  }
  protected:
  explicit SamlParametersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthRedirectUrlFieldNumber = 1,
    kAuthSessionIdFieldNumber = 2,
  };
  // optional string auth_redirect_url = 1;
  bool has_auth_redirect_url() const;
  private:
  bool _internal_has_auth_redirect_url() const;
  public:
  void clear_auth_redirect_url();
  const std::string& auth_redirect_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_redirect_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_redirect_url();
  PROTOBUF_NODISCARD std::string* release_auth_redirect_url();
  void set_allocated_auth_redirect_url(std::string* auth_redirect_url);
  private:
  const std::string& _internal_auth_redirect_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_redirect_url(const std::string& value);
  std::string* _internal_mutable_auth_redirect_url();
  public:

  // optional string auth_session_id = 2;
  bool has_auth_session_id() const;
  private:
  bool _internal_has_auth_session_id() const;
  public:
  void clear_auth_session_id();
  const std::string& auth_session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_session_id();
  PROTOBUF_NODISCARD std::string* release_auth_session_id();
  void set_allocated_auth_session_id(std::string* auth_session_id);
  private:
  const std::string& _internal_auth_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_session_id(const std::string& value);
  std::string* _internal_mutable_auth_session_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.SamlParametersProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_redirect_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_session_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PublicSamlUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PublicSamlUserRequest) */ {
 public:
  inline PublicSamlUserRequest() : PublicSamlUserRequest(nullptr) {}
  ~PublicSamlUserRequest() override;
  explicit PROTOBUF_CONSTEXPR PublicSamlUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicSamlUserRequest(const PublicSamlUserRequest& from);
  PublicSamlUserRequest(PublicSamlUserRequest&& from) noexcept
    : PublicSamlUserRequest() {
    *this = ::std::move(from);
  }

  inline PublicSamlUserRequest& operator=(const PublicSamlUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicSamlUserRequest& operator=(PublicSamlUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PublicSamlUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicSamlUserRequest* internal_default_instance() {
    return reinterpret_cast<const PublicSamlUserRequest*>(
               &_PublicSamlUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(PublicSamlUserRequest& a, PublicSamlUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicSamlUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicSamlUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicSamlUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicSamlUserRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PublicSamlUserRequest& from);
  void MergeFrom(const PublicSamlUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicSamlUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PublicSamlUserRequest";
  }
  protected:
  explicit PublicSamlUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
  };
  // optional string account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PublicSamlUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PublicSamlUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PublicSamlUserResponse) */ {
 public:
  inline PublicSamlUserResponse() : PublicSamlUserResponse(nullptr) {}
  ~PublicSamlUserResponse() override;
  explicit PROTOBUF_CONSTEXPR PublicSamlUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicSamlUserResponse(const PublicSamlUserResponse& from);
  PublicSamlUserResponse(PublicSamlUserResponse&& from) noexcept
    : PublicSamlUserResponse() {
    *this = ::std::move(from);
  }

  inline PublicSamlUserResponse& operator=(const PublicSamlUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicSamlUserResponse& operator=(PublicSamlUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PublicSamlUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicSamlUserResponse* internal_default_instance() {
    return reinterpret_cast<const PublicSamlUserResponse*>(
               &_PublicSamlUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(PublicSamlUserResponse& a, PublicSamlUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicSamlUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicSamlUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicSamlUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicSamlUserResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PublicSamlUserResponse& from);
  void MergeFrom(const PublicSamlUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicSamlUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PublicSamlUserResponse";
  }
  protected:
  explicit PublicSamlUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamlParametersFieldNumber = 1,
  };
  // optional .enterprise_management.SamlParametersProto saml_parameters = 1;
  bool has_saml_parameters() const;
  private:
  bool _internal_has_saml_parameters() const;
  public:
  void clear_saml_parameters();
  const ::enterprise_management::SamlParametersProto& saml_parameters() const;
  PROTOBUF_NODISCARD ::enterprise_management::SamlParametersProto* release_saml_parameters();
  ::enterprise_management::SamlParametersProto* mutable_saml_parameters();
  void set_allocated_saml_parameters(::enterprise_management::SamlParametersProto* saml_parameters);
  private:
  const ::enterprise_management::SamlParametersProto& _internal_saml_parameters() const;
  ::enterprise_management::SamlParametersProto* _internal_mutable_saml_parameters();
  public:
  void unsafe_arena_set_allocated_saml_parameters(
      ::enterprise_management::SamlParametersProto* saml_parameters);
  ::enterprise_management::SamlParametersProto* unsafe_arena_release_saml_parameters();

  // @@protoc_insertion_point(class_scope:enterprise_management.PublicSamlUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::SamlParametersProto* saml_parameters_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ActiveDirectoryPlayActivityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryPlayActivityRequest) */ {
 public:
  inline ActiveDirectoryPlayActivityRequest() : ActiveDirectoryPlayActivityRequest(nullptr) {}
  ~ActiveDirectoryPlayActivityRequest() override;
  explicit PROTOBUF_CONSTEXPR ActiveDirectoryPlayActivityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveDirectoryPlayActivityRequest(const ActiveDirectoryPlayActivityRequest& from);
  ActiveDirectoryPlayActivityRequest(ActiveDirectoryPlayActivityRequest&& from) noexcept
    : ActiveDirectoryPlayActivityRequest() {
    *this = ::std::move(from);
  }

  inline ActiveDirectoryPlayActivityRequest& operator=(const ActiveDirectoryPlayActivityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveDirectoryPlayActivityRequest& operator=(ActiveDirectoryPlayActivityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActiveDirectoryPlayActivityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveDirectoryPlayActivityRequest* internal_default_instance() {
    return reinterpret_cast<const ActiveDirectoryPlayActivityRequest*>(
               &_ActiveDirectoryPlayActivityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(ActiveDirectoryPlayActivityRequest& a, ActiveDirectoryPlayActivityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveDirectoryPlayActivityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveDirectoryPlayActivityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveDirectoryPlayActivityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveDirectoryPlayActivityRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActiveDirectoryPlayActivityRequest& from);
  void MergeFrom(const ActiveDirectoryPlayActivityRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActiveDirectoryPlayActivityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ActiveDirectoryPlayActivityRequest";
  }
  protected:
  explicit ActiveDirectoryPlayActivityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryPlayActivityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ActiveDirectoryPlayActivityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryPlayActivityResponse) */ {
 public:
  inline ActiveDirectoryPlayActivityResponse() : ActiveDirectoryPlayActivityResponse(nullptr) {}
  ~ActiveDirectoryPlayActivityResponse() override;
  explicit PROTOBUF_CONSTEXPR ActiveDirectoryPlayActivityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveDirectoryPlayActivityResponse(const ActiveDirectoryPlayActivityResponse& from);
  ActiveDirectoryPlayActivityResponse(ActiveDirectoryPlayActivityResponse&& from) noexcept
    : ActiveDirectoryPlayActivityResponse() {
    *this = ::std::move(from);
  }

  inline ActiveDirectoryPlayActivityResponse& operator=(const ActiveDirectoryPlayActivityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveDirectoryPlayActivityResponse& operator=(ActiveDirectoryPlayActivityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActiveDirectoryPlayActivityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveDirectoryPlayActivityResponse* internal_default_instance() {
    return reinterpret_cast<const ActiveDirectoryPlayActivityResponse*>(
               &_ActiveDirectoryPlayActivityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(ActiveDirectoryPlayActivityResponse& a, ActiveDirectoryPlayActivityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveDirectoryPlayActivityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveDirectoryPlayActivityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveDirectoryPlayActivityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveDirectoryPlayActivityResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActiveDirectoryPlayActivityResponse& from);
  void MergeFrom(const ActiveDirectoryPlayActivityResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActiveDirectoryPlayActivityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ActiveDirectoryPlayActivityResponse";
  }
  protected:
  explicit ActiveDirectoryPlayActivityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryPlayActivityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CheckDeviceLicenseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckDeviceLicenseRequest) */ {
 public:
  inline CheckDeviceLicenseRequest() : CheckDeviceLicenseRequest(nullptr) {}
  ~CheckDeviceLicenseRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckDeviceLicenseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckDeviceLicenseRequest(const CheckDeviceLicenseRequest& from);
  CheckDeviceLicenseRequest(CheckDeviceLicenseRequest&& from) noexcept
    : CheckDeviceLicenseRequest() {
    *this = ::std::move(from);
  }

  inline CheckDeviceLicenseRequest& operator=(const CheckDeviceLicenseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckDeviceLicenseRequest& operator=(CheckDeviceLicenseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckDeviceLicenseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckDeviceLicenseRequest* internal_default_instance() {
    return reinterpret_cast<const CheckDeviceLicenseRequest*>(
               &_CheckDeviceLicenseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(CheckDeviceLicenseRequest& a, CheckDeviceLicenseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckDeviceLicenseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckDeviceLicenseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckDeviceLicenseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckDeviceLicenseRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckDeviceLicenseRequest& from);
  void MergeFrom(const CheckDeviceLicenseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckDeviceLicenseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CheckDeviceLicenseRequest";
  }
  protected:
  explicit CheckDeviceLicenseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.CheckDeviceLicenseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class LicenseAvailability final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.LicenseAvailability) */ {
 public:
  inline LicenseAvailability() : LicenseAvailability(nullptr) {}
  ~LicenseAvailability() override;
  explicit PROTOBUF_CONSTEXPR LicenseAvailability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LicenseAvailability(const LicenseAvailability& from);
  LicenseAvailability(LicenseAvailability&& from) noexcept
    : LicenseAvailability() {
    *this = ::std::move(from);
  }

  inline LicenseAvailability& operator=(const LicenseAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicenseAvailability& operator=(LicenseAvailability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LicenseAvailability& default_instance() {
    return *internal_default_instance();
  }
  static inline const LicenseAvailability* internal_default_instance() {
    return reinterpret_cast<const LicenseAvailability*>(
               &_LicenseAvailability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(LicenseAvailability& a, LicenseAvailability& b) {
    a.Swap(&b);
  }
  inline void Swap(LicenseAvailability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicenseAvailability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LicenseAvailability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LicenseAvailability>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LicenseAvailability& from);
  void MergeFrom(const LicenseAvailability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LicenseAvailability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.LicenseAvailability";
  }
  protected:
  explicit LicenseAvailability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseTypeDeprecatedFieldNumber = 1,
    kAvailableLicensesDeprecatedFieldNumber = 2,
  };
  // optional .enterprise_management.LicenseType license_type_deprecated = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_license_type_deprecated() const;
  private:
  bool _internal_has_license_type_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_license_type_deprecated();
  PROTOBUF_DEPRECATED const ::enterprise_management::LicenseType& license_type_deprecated() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::LicenseType* release_license_type_deprecated();
  PROTOBUF_DEPRECATED ::enterprise_management::LicenseType* mutable_license_type_deprecated();
  PROTOBUF_DEPRECATED void set_allocated_license_type_deprecated(::enterprise_management::LicenseType* license_type_deprecated);
  private:
  const ::enterprise_management::LicenseType& _internal_license_type_deprecated() const;
  ::enterprise_management::LicenseType* _internal_mutable_license_type_deprecated();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_license_type_deprecated(
      ::enterprise_management::LicenseType* license_type_deprecated);
  PROTOBUF_DEPRECATED ::enterprise_management::LicenseType* unsafe_arena_release_license_type_deprecated();

  // optional int32 available_licenses_deprecated = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_available_licenses_deprecated() const;
  private:
  bool _internal_has_available_licenses_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_available_licenses_deprecated();
  PROTOBUF_DEPRECATED int32_t available_licenses_deprecated() const;
  PROTOBUF_DEPRECATED void set_available_licenses_deprecated(int32_t value);
  private:
  int32_t _internal_available_licenses_deprecated() const;
  void _internal_set_available_licenses_deprecated(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.LicenseAvailability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::LicenseType* license_type_deprecated_;
    int32_t available_licenses_deprecated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CheckDeviceLicenseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CheckDeviceLicenseResponse) */ {
 public:
  inline CheckDeviceLicenseResponse() : CheckDeviceLicenseResponse(nullptr) {}
  ~CheckDeviceLicenseResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckDeviceLicenseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckDeviceLicenseResponse(const CheckDeviceLicenseResponse& from);
  CheckDeviceLicenseResponse(CheckDeviceLicenseResponse&& from) noexcept
    : CheckDeviceLicenseResponse() {
    *this = ::std::move(from);
  }

  inline CheckDeviceLicenseResponse& operator=(const CheckDeviceLicenseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckDeviceLicenseResponse& operator=(CheckDeviceLicenseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckDeviceLicenseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckDeviceLicenseResponse* internal_default_instance() {
    return reinterpret_cast<const CheckDeviceLicenseResponse*>(
               &_CheckDeviceLicenseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(CheckDeviceLicenseResponse& a, CheckDeviceLicenseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckDeviceLicenseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckDeviceLicenseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckDeviceLicenseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckDeviceLicenseResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckDeviceLicenseResponse& from);
  void MergeFrom(const CheckDeviceLicenseResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckDeviceLicenseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CheckDeviceLicenseResponse";
  }
  protected:
  explicit CheckDeviceLicenseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CheckDeviceLicenseResponse_LicenseSelectionMode LicenseSelectionMode;
  static constexpr LicenseSelectionMode UNDEFINED =
    CheckDeviceLicenseResponse_LicenseSelectionMode_UNDEFINED;
  static constexpr LicenseSelectionMode USER_SELECTION =
    CheckDeviceLicenseResponse_LicenseSelectionMode_USER_SELECTION;
  static constexpr LicenseSelectionMode ADMIN_SELECTION =
    CheckDeviceLicenseResponse_LicenseSelectionMode_ADMIN_SELECTION;
  static inline bool LicenseSelectionMode_IsValid(int value) {
    return CheckDeviceLicenseResponse_LicenseSelectionMode_IsValid(value);
  }
  static constexpr LicenseSelectionMode LicenseSelectionMode_MIN =
    CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MIN;
  static constexpr LicenseSelectionMode LicenseSelectionMode_MAX =
    CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_MAX;
  static constexpr int LicenseSelectionMode_ARRAYSIZE =
    CheckDeviceLicenseResponse_LicenseSelectionMode_LicenseSelectionMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LicenseSelectionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LicenseSelectionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LicenseSelectionMode_Name.");
    return CheckDeviceLicenseResponse_LicenseSelectionMode_Name(enum_t_value);
  }
  static inline bool LicenseSelectionMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LicenseSelectionMode* value) {
    return CheckDeviceLicenseResponse_LicenseSelectionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseAvailabilitiesDeprecatedFieldNumber = 2,
    kLicenseSelectionModeDeprecatedFieldNumber = 1,
  };
  // repeated .enterprise_management.LicenseAvailability license_availabilities_deprecated = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int license_availabilities_deprecated_size() const;
  private:
  int _internal_license_availabilities_deprecated_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_license_availabilities_deprecated();
  PROTOBUF_DEPRECATED ::enterprise_management::LicenseAvailability* mutable_license_availabilities_deprecated(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability >*
      mutable_license_availabilities_deprecated();
  private:
  const ::enterprise_management::LicenseAvailability& _internal_license_availabilities_deprecated(int index) const;
  ::enterprise_management::LicenseAvailability* _internal_add_license_availabilities_deprecated();
  public:
  PROTOBUF_DEPRECATED const ::enterprise_management::LicenseAvailability& license_availabilities_deprecated(int index) const;
  PROTOBUF_DEPRECATED ::enterprise_management::LicenseAvailability* add_license_availabilities_deprecated();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability >&
      license_availabilities_deprecated() const;

  // optional .enterprise_management.CheckDeviceLicenseResponse.LicenseSelectionMode license_selection_mode_deprecated = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_license_selection_mode_deprecated() const;
  private:
  bool _internal_has_license_selection_mode_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_license_selection_mode_deprecated();
  PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode license_selection_mode_deprecated() const;
  PROTOBUF_DEPRECATED void set_license_selection_mode_deprecated(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode value);
  private:
  ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode _internal_license_selection_mode_deprecated() const;
  void _internal_set_license_selection_mode_deprecated(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CheckDeviceLicenseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability > license_availabilities_deprecated_;
    int license_selection_mode_deprecated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ActiveDirectoryUserSigninRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryUserSigninRequest) */ {
 public:
  inline ActiveDirectoryUserSigninRequest() : ActiveDirectoryUserSigninRequest(nullptr) {}
  ~ActiveDirectoryUserSigninRequest() override;
  explicit PROTOBUF_CONSTEXPR ActiveDirectoryUserSigninRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveDirectoryUserSigninRequest(const ActiveDirectoryUserSigninRequest& from);
  ActiveDirectoryUserSigninRequest(ActiveDirectoryUserSigninRequest&& from) noexcept
    : ActiveDirectoryUserSigninRequest() {
    *this = ::std::move(from);
  }

  inline ActiveDirectoryUserSigninRequest& operator=(const ActiveDirectoryUserSigninRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveDirectoryUserSigninRequest& operator=(ActiveDirectoryUserSigninRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActiveDirectoryUserSigninRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveDirectoryUserSigninRequest* internal_default_instance() {
    return reinterpret_cast<const ActiveDirectoryUserSigninRequest*>(
               &_ActiveDirectoryUserSigninRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(ActiveDirectoryUserSigninRequest& a, ActiveDirectoryUserSigninRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveDirectoryUserSigninRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveDirectoryUserSigninRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveDirectoryUserSigninRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveDirectoryUserSigninRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActiveDirectoryUserSigninRequest& from);
  void MergeFrom(const ActiveDirectoryUserSigninRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActiveDirectoryUserSigninRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ActiveDirectoryUserSigninRequest";
  }
  protected:
  explicit ActiveDirectoryUserSigninRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryUserSigninRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ActiveDirectoryUserSigninResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ActiveDirectoryUserSigninResponse) */ {
 public:
  inline ActiveDirectoryUserSigninResponse() : ActiveDirectoryUserSigninResponse(nullptr) {}
  ~ActiveDirectoryUserSigninResponse() override;
  explicit PROTOBUF_CONSTEXPR ActiveDirectoryUserSigninResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveDirectoryUserSigninResponse(const ActiveDirectoryUserSigninResponse& from);
  ActiveDirectoryUserSigninResponse(ActiveDirectoryUserSigninResponse&& from) noexcept
    : ActiveDirectoryUserSigninResponse() {
    *this = ::std::move(from);
  }

  inline ActiveDirectoryUserSigninResponse& operator=(const ActiveDirectoryUserSigninResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveDirectoryUserSigninResponse& operator=(ActiveDirectoryUserSigninResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActiveDirectoryUserSigninResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveDirectoryUserSigninResponse* internal_default_instance() {
    return reinterpret_cast<const ActiveDirectoryUserSigninResponse*>(
               &_ActiveDirectoryUserSigninResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(ActiveDirectoryUserSigninResponse& a, ActiveDirectoryUserSigninResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveDirectoryUserSigninResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveDirectoryUserSigninResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveDirectoryUserSigninResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveDirectoryUserSigninResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActiveDirectoryUserSigninResponse& from);
  void MergeFrom(const ActiveDirectoryUserSigninResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActiveDirectoryUserSigninResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ActiveDirectoryUserSigninResponse";
  }
  protected:
  explicit ActiveDirectoryUserSigninResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthRedirectUrlFieldNumber = 1,
  };
  // optional string auth_redirect_url = 1;
  bool has_auth_redirect_url() const;
  private:
  bool _internal_has_auth_redirect_url() const;
  public:
  void clear_auth_redirect_url();
  const std::string& auth_redirect_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_redirect_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_redirect_url();
  PROTOBUF_NODISCARD std::string* release_auth_redirect_url();
  void set_allocated_auth_redirect_url(std::string* auth_redirect_url);
  private:
  const std::string& _internal_auth_redirect_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_redirect_url(const std::string& value);
  std::string* _internal_mutable_auth_redirect_url();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ActiveDirectoryUserSigninResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_redirect_url_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class TpmVersionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TpmVersionInfo) */ {
 public:
  inline TpmVersionInfo() : TpmVersionInfo(nullptr) {}
  ~TpmVersionInfo() override;
  explicit PROTOBUF_CONSTEXPR TpmVersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TpmVersionInfo(const TpmVersionInfo& from);
  TpmVersionInfo(TpmVersionInfo&& from) noexcept
    : TpmVersionInfo() {
    *this = ::std::move(from);
  }

  inline TpmVersionInfo& operator=(const TpmVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TpmVersionInfo& operator=(TpmVersionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TpmVersionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TpmVersionInfo* internal_default_instance() {
    return reinterpret_cast<const TpmVersionInfo*>(
               &_TpmVersionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(TpmVersionInfo& a, TpmVersionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TpmVersionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TpmVersionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TpmVersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TpmVersionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TpmVersionInfo& from);
  void MergeFrom(const TpmVersionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TpmVersionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.TpmVersionInfo";
  }
  protected:
  explicit TpmVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TpmVersionInfo_GscVersion GscVersion;
  static constexpr GscVersion GSC_VERSION_UNSPECIFIED =
    TpmVersionInfo_GscVersion_GSC_VERSION_UNSPECIFIED;
  static constexpr GscVersion GSC_VERSION_NOT_GSC =
    TpmVersionInfo_GscVersion_GSC_VERSION_NOT_GSC;
  static constexpr GscVersion GSC_VERSION_CR50 =
    TpmVersionInfo_GscVersion_GSC_VERSION_CR50;
  static constexpr GscVersion GSC_VERSION_TI50 =
    TpmVersionInfo_GscVersion_GSC_VERSION_TI50;
  static inline bool GscVersion_IsValid(int value) {
    return TpmVersionInfo_GscVersion_IsValid(value);
  }
  static constexpr GscVersion GscVersion_MIN =
    TpmVersionInfo_GscVersion_GscVersion_MIN;
  static constexpr GscVersion GscVersion_MAX =
    TpmVersionInfo_GscVersion_GscVersion_MAX;
  static constexpr int GscVersion_ARRAYSIZE =
    TpmVersionInfo_GscVersion_GscVersion_ARRAYSIZE;
  template<typename T>
  static inline const std::string& GscVersion_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GscVersion>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GscVersion_Name.");
    return TpmVersionInfo_GscVersion_Name(enum_t_value);
  }
  static inline bool GscVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GscVersion* value) {
    return TpmVersionInfo_GscVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVendorSpecificFieldNumber = 6,
    kDidVidFieldNumber = 8,
    kSpecLevelFieldNumber = 2,
    kFamilyFieldNumber = 1,
    kManufacturerFieldNumber = 3,
    kFirmwareVersionFieldNumber = 5,
    kTpmModelFieldNumber = 4,
    kGscVersionFieldNumber = 7,
  };
  // optional string vendor_specific = 6;
  bool has_vendor_specific() const;
  private:
  bool _internal_has_vendor_specific() const;
  public:
  void clear_vendor_specific();
  const std::string& vendor_specific() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor_specific(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor_specific();
  PROTOBUF_NODISCARD std::string* release_vendor_specific();
  void set_allocated_vendor_specific(std::string* vendor_specific);
  private:
  const std::string& _internal_vendor_specific() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_specific(const std::string& value);
  std::string* _internal_mutable_vendor_specific();
  public:

  // optional string did_vid = 8;
  bool has_did_vid() const;
  private:
  bool _internal_has_did_vid() const;
  public:
  void clear_did_vid();
  const std::string& did_vid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_did_vid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_did_vid();
  PROTOBUF_NODISCARD std::string* release_did_vid();
  void set_allocated_did_vid(std::string* did_vid);
  private:
  const std::string& _internal_did_vid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_did_vid(const std::string& value);
  std::string* _internal_mutable_did_vid();
  public:

  // optional uint64 spec_level = 2;
  bool has_spec_level() const;
  private:
  bool _internal_has_spec_level() const;
  public:
  void clear_spec_level();
  uint64_t spec_level() const;
  void set_spec_level(uint64_t value);
  private:
  uint64_t _internal_spec_level() const;
  void _internal_set_spec_level(uint64_t value);
  public:

  // optional uint32 family = 1;
  bool has_family() const;
  private:
  bool _internal_has_family() const;
  public:
  void clear_family();
  uint32_t family() const;
  void set_family(uint32_t value);
  private:
  uint32_t _internal_family() const;
  void _internal_set_family(uint32_t value);
  public:

  // optional uint32 manufacturer = 3;
  bool has_manufacturer() const;
  private:
  bool _internal_has_manufacturer() const;
  public:
  void clear_manufacturer();
  uint32_t manufacturer() const;
  void set_manufacturer(uint32_t value);
  private:
  uint32_t _internal_manufacturer() const;
  void _internal_set_manufacturer(uint32_t value);
  public:

  // optional uint64 firmware_version = 5;
  bool has_firmware_version() const;
  private:
  bool _internal_has_firmware_version() const;
  public:
  void clear_firmware_version();
  uint64_t firmware_version() const;
  void set_firmware_version(uint64_t value);
  private:
  uint64_t _internal_firmware_version() const;
  void _internal_set_firmware_version(uint64_t value);
  public:

  // optional uint32 tpm_model = 4;
  bool has_tpm_model() const;
  private:
  bool _internal_has_tpm_model() const;
  public:
  void clear_tpm_model();
  uint32_t tpm_model() const;
  void set_tpm_model(uint32_t value);
  private:
  uint32_t _internal_tpm_model() const;
  void _internal_set_tpm_model(uint32_t value);
  public:

  // optional .enterprise_management.TpmVersionInfo.GscVersion gsc_version = 7;
  bool has_gsc_version() const;
  private:
  bool _internal_has_gsc_version() const;
  public:
  void clear_gsc_version();
  ::enterprise_management::TpmVersionInfo_GscVersion gsc_version() const;
  void set_gsc_version(::enterprise_management::TpmVersionInfo_GscVersion value);
  private:
  ::enterprise_management::TpmVersionInfo_GscVersion _internal_gsc_version() const;
  void _internal_set_gsc_version(::enterprise_management::TpmVersionInfo_GscVersion value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.TpmVersionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_specific_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr did_vid_;
    uint64_t spec_level_;
    uint32_t family_;
    uint32_t manufacturer_;
    uint64_t firmware_version_;
    uint32_t tpm_model_;
    int gsc_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class TpmStatusInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TpmStatusInfo) */ {
 public:
  inline TpmStatusInfo() : TpmStatusInfo(nullptr) {}
  ~TpmStatusInfo() override;
  explicit PROTOBUF_CONSTEXPR TpmStatusInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TpmStatusInfo(const TpmStatusInfo& from);
  TpmStatusInfo(TpmStatusInfo&& from) noexcept
    : TpmStatusInfo() {
    *this = ::std::move(from);
  }

  inline TpmStatusInfo& operator=(const TpmStatusInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TpmStatusInfo& operator=(TpmStatusInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TpmStatusInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TpmStatusInfo* internal_default_instance() {
    return reinterpret_cast<const TpmStatusInfo*>(
               &_TpmStatusInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(TpmStatusInfo& a, TpmStatusInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TpmStatusInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TpmStatusInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TpmStatusInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TpmStatusInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TpmStatusInfo& from);
  void MergeFrom(const TpmStatusInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TpmStatusInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.TpmStatusInfo";
  }
  protected:
  explicit TpmStatusInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpmSupportedFeaturesFieldNumber = 12,
    kEnabledFieldNumber = 1,
    kOwnedFieldNumber = 2,
    kTpmInitializedFieldNumber = 3,
    kAttestationPreparedFieldNumber = 4,
    kDictionaryAttackCounterFieldNumber = 6,
    kDictionaryAttackThresholdFieldNumber = 7,
    kAttestationEnrolledFieldNumber = 5,
    kDictionaryAttackLockoutInEffectFieldNumber = 8,
    kBootLockboxFinalizedFieldNumber = 10,
    kOwnerPasswordIsPresentFieldNumber = 11,
    kDictionaryAttackLockoutSecondsRemainingFieldNumber = 9,
  };
  // optional .enterprise_management.TpmSupportedFeatures tpm_supported_features = 12;
  bool has_tpm_supported_features() const;
  private:
  bool _internal_has_tpm_supported_features() const;
  public:
  void clear_tpm_supported_features();
  const ::enterprise_management::TpmSupportedFeatures& tpm_supported_features() const;
  PROTOBUF_NODISCARD ::enterprise_management::TpmSupportedFeatures* release_tpm_supported_features();
  ::enterprise_management::TpmSupportedFeatures* mutable_tpm_supported_features();
  void set_allocated_tpm_supported_features(::enterprise_management::TpmSupportedFeatures* tpm_supported_features);
  private:
  const ::enterprise_management::TpmSupportedFeatures& _internal_tpm_supported_features() const;
  ::enterprise_management::TpmSupportedFeatures* _internal_mutable_tpm_supported_features();
  public:
  void unsafe_arena_set_allocated_tpm_supported_features(
      ::enterprise_management::TpmSupportedFeatures* tpm_supported_features);
  ::enterprise_management::TpmSupportedFeatures* unsafe_arena_release_tpm_supported_features();

  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional bool owned = 2;
  bool has_owned() const;
  private:
  bool _internal_has_owned() const;
  public:
  void clear_owned();
  bool owned() const;
  void set_owned(bool value);
  private:
  bool _internal_owned() const;
  void _internal_set_owned(bool value);
  public:

  // optional bool tpm_initialized = 3;
  bool has_tpm_initialized() const;
  private:
  bool _internal_has_tpm_initialized() const;
  public:
  void clear_tpm_initialized();
  bool tpm_initialized() const;
  void set_tpm_initialized(bool value);
  private:
  bool _internal_tpm_initialized() const;
  void _internal_set_tpm_initialized(bool value);
  public:

  // optional bool attestation_prepared = 4;
  bool has_attestation_prepared() const;
  private:
  bool _internal_has_attestation_prepared() const;
  public:
  void clear_attestation_prepared();
  bool attestation_prepared() const;
  void set_attestation_prepared(bool value);
  private:
  bool _internal_attestation_prepared() const;
  void _internal_set_attestation_prepared(bool value);
  public:

  // optional int32 dictionary_attack_counter = 6;
  bool has_dictionary_attack_counter() const;
  private:
  bool _internal_has_dictionary_attack_counter() const;
  public:
  void clear_dictionary_attack_counter();
  int32_t dictionary_attack_counter() const;
  void set_dictionary_attack_counter(int32_t value);
  private:
  int32_t _internal_dictionary_attack_counter() const;
  void _internal_set_dictionary_attack_counter(int32_t value);
  public:

  // optional int32 dictionary_attack_threshold = 7;
  bool has_dictionary_attack_threshold() const;
  private:
  bool _internal_has_dictionary_attack_threshold() const;
  public:
  void clear_dictionary_attack_threshold();
  int32_t dictionary_attack_threshold() const;
  void set_dictionary_attack_threshold(int32_t value);
  private:
  int32_t _internal_dictionary_attack_threshold() const;
  void _internal_set_dictionary_attack_threshold(int32_t value);
  public:

  // optional bool attestation_enrolled = 5;
  bool has_attestation_enrolled() const;
  private:
  bool _internal_has_attestation_enrolled() const;
  public:
  void clear_attestation_enrolled();
  bool attestation_enrolled() const;
  void set_attestation_enrolled(bool value);
  private:
  bool _internal_attestation_enrolled() const;
  void _internal_set_attestation_enrolled(bool value);
  public:

  // optional bool dictionary_attack_lockout_in_effect = 8;
  bool has_dictionary_attack_lockout_in_effect() const;
  private:
  bool _internal_has_dictionary_attack_lockout_in_effect() const;
  public:
  void clear_dictionary_attack_lockout_in_effect();
  bool dictionary_attack_lockout_in_effect() const;
  void set_dictionary_attack_lockout_in_effect(bool value);
  private:
  bool _internal_dictionary_attack_lockout_in_effect() const;
  void _internal_set_dictionary_attack_lockout_in_effect(bool value);
  public:

  // optional bool boot_lockbox_finalized = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_boot_lockbox_finalized() const;
  private:
  bool _internal_has_boot_lockbox_finalized() const;
  public:
  PROTOBUF_DEPRECATED void clear_boot_lockbox_finalized();
  PROTOBUF_DEPRECATED bool boot_lockbox_finalized() const;
  PROTOBUF_DEPRECATED void set_boot_lockbox_finalized(bool value);
  private:
  bool _internal_boot_lockbox_finalized() const;
  void _internal_set_boot_lockbox_finalized(bool value);
  public:

  // optional bool owner_password_is_present = 11;
  bool has_owner_password_is_present() const;
  private:
  bool _internal_has_owner_password_is_present() const;
  public:
  void clear_owner_password_is_present();
  bool owner_password_is_present() const;
  void set_owner_password_is_present(bool value);
  private:
  bool _internal_owner_password_is_present() const;
  void _internal_set_owner_password_is_present(bool value);
  public:

  // optional int32 dictionary_attack_lockout_seconds_remaining = 9;
  bool has_dictionary_attack_lockout_seconds_remaining() const;
  private:
  bool _internal_has_dictionary_attack_lockout_seconds_remaining() const;
  public:
  void clear_dictionary_attack_lockout_seconds_remaining();
  int32_t dictionary_attack_lockout_seconds_remaining() const;
  void set_dictionary_attack_lockout_seconds_remaining(int32_t value);
  private:
  int32_t _internal_dictionary_attack_lockout_seconds_remaining() const;
  void _internal_set_dictionary_attack_lockout_seconds_remaining(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.TpmStatusInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::TpmSupportedFeatures* tpm_supported_features_;
    bool enabled_;
    bool owned_;
    bool tpm_initialized_;
    bool attestation_prepared_;
    int32_t dictionary_attack_counter_;
    int32_t dictionary_attack_threshold_;
    bool attestation_enrolled_;
    bool dictionary_attack_lockout_in_effect_;
    bool boot_lockbox_finalized_;
    bool owner_password_is_present_;
    int32_t dictionary_attack_lockout_seconds_remaining_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class TpmSupportedFeatures final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.TpmSupportedFeatures) */ {
 public:
  inline TpmSupportedFeatures() : TpmSupportedFeatures(nullptr) {}
  ~TpmSupportedFeatures() override;
  explicit PROTOBUF_CONSTEXPR TpmSupportedFeatures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TpmSupportedFeatures(const TpmSupportedFeatures& from);
  TpmSupportedFeatures(TpmSupportedFeatures&& from) noexcept
    : TpmSupportedFeatures() {
    *this = ::std::move(from);
  }

  inline TpmSupportedFeatures& operator=(const TpmSupportedFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline TpmSupportedFeatures& operator=(TpmSupportedFeatures&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TpmSupportedFeatures& default_instance() {
    return *internal_default_instance();
  }
  static inline const TpmSupportedFeatures* internal_default_instance() {
    return reinterpret_cast<const TpmSupportedFeatures*>(
               &_TpmSupportedFeatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(TpmSupportedFeatures& a, TpmSupportedFeatures& b) {
    a.Swap(&b);
  }
  inline void Swap(TpmSupportedFeatures* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TpmSupportedFeatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TpmSupportedFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TpmSupportedFeatures>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TpmSupportedFeatures& from);
  void MergeFrom(const TpmSupportedFeatures& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TpmSupportedFeatures* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.TpmSupportedFeatures";
  }
  protected:
  explicit TpmSupportedFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsAllowedFieldNumber = 1,
    kSupportPinweaverFieldNumber = 2,
    kSupportRuntimeSelectionFieldNumber = 3,
    kSupportU2FFieldNumber = 4,
  };
  // optional bool is_allowed = 1;
  bool has_is_allowed() const;
  private:
  bool _internal_has_is_allowed() const;
  public:
  void clear_is_allowed();
  bool is_allowed() const;
  void set_is_allowed(bool value);
  private:
  bool _internal_is_allowed() const;
  void _internal_set_is_allowed(bool value);
  public:

  // optional bool support_pinweaver = 2;
  bool has_support_pinweaver() const;
  private:
  bool _internal_has_support_pinweaver() const;
  public:
  void clear_support_pinweaver();
  bool support_pinweaver() const;
  void set_support_pinweaver(bool value);
  private:
  bool _internal_support_pinweaver() const;
  void _internal_set_support_pinweaver(bool value);
  public:

  // optional bool support_runtime_selection = 3;
  bool has_support_runtime_selection() const;
  private:
  bool _internal_has_support_runtime_selection() const;
  public:
  void clear_support_runtime_selection();
  bool support_runtime_selection() const;
  void set_support_runtime_selection(bool value);
  private:
  bool _internal_support_runtime_selection() const;
  void _internal_set_support_runtime_selection(bool value);
  public:

  // optional bool support_u2f = 4;
  bool has_support_u2f() const;
  private:
  bool _internal_has_support_u2f() const;
  public:
  void clear_support_u2f();
  bool support_u2f() const;
  void set_support_u2f(bool value);
  private:
  bool _internal_support_u2f() const;
  void _internal_set_support_u2f(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.TpmSupportedFeatures)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool is_allowed_;
    bool support_pinweaver_;
    bool support_runtime_selection_;
    bool support_u2f_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class SystemState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.SystemState) */ {
 public:
  inline SystemState() : SystemState(nullptr) {}
  ~SystemState() override;
  explicit PROTOBUF_CONSTEXPR SystemState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemState(const SystemState& from);
  SystemState(SystemState&& from) noexcept
    : SystemState() {
    *this = ::std::move(from);
  }

  inline SystemState& operator=(const SystemState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemState& operator=(SystemState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SystemState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemState* internal_default_instance() {
    return reinterpret_cast<const SystemState*>(
               &_SystemState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(SystemState& a, SystemState& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemState& from);
  void MergeFrom(const SystemState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.SystemState";
  }
  protected:
  explicit SystemState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeInfosFieldNumber = 1,
  };
  // repeated .enterprise_management.VolumeInfo volume_infos = 1;
  int volume_infos_size() const;
  private:
  int _internal_volume_infos_size() const;
  public:
  void clear_volume_infos();
  ::enterprise_management::VolumeInfo* mutable_volume_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >*
      mutable_volume_infos();
  private:
  const ::enterprise_management::VolumeInfo& _internal_volume_infos(int index) const;
  ::enterprise_management::VolumeInfo* _internal_add_volume_infos();
  public:
  const ::enterprise_management::VolumeInfo& volume_infos(int index) const;
  ::enterprise_management::VolumeInfo* add_volume_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >&
      volume_infos() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.SystemState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo > volume_infos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ExtensionInstallReportLogEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionInstallReportLogEvent) */ {
 public:
  inline ExtensionInstallReportLogEvent() : ExtensionInstallReportLogEvent(nullptr) {}
  ~ExtensionInstallReportLogEvent() override;
  explicit PROTOBUF_CONSTEXPR ExtensionInstallReportLogEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionInstallReportLogEvent(const ExtensionInstallReportLogEvent& from);
  ExtensionInstallReportLogEvent(ExtensionInstallReportLogEvent&& from) noexcept
    : ExtensionInstallReportLogEvent() {
    *this = ::std::move(from);
  }

  inline ExtensionInstallReportLogEvent& operator=(const ExtensionInstallReportLogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionInstallReportLogEvent& operator=(ExtensionInstallReportLogEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionInstallReportLogEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionInstallReportLogEvent* internal_default_instance() {
    return reinterpret_cast<const ExtensionInstallReportLogEvent*>(
               &_ExtensionInstallReportLogEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(ExtensionInstallReportLogEvent& a, ExtensionInstallReportLogEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtensionInstallReportLogEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionInstallReportLogEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionInstallReportLogEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionInstallReportLogEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionInstallReportLogEvent& from);
  void MergeFrom(const ExtensionInstallReportLogEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionInstallReportLogEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ExtensionInstallReportLogEvent";
  }
  protected:
  explicit ExtensionInstallReportLogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExtensionInstallReportLogEvent_EventType EventType;
  static constexpr EventType LOG_EVENT_TYPE_UNKNOWN =
    ExtensionInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN;
  static constexpr EventType POLICY_REQUEST =
    ExtensionInstallReportLogEvent_EventType_POLICY_REQUEST;
  static constexpr EventType SUCCESS =
    ExtensionInstallReportLogEvent_EventType_SUCCESS;
  static constexpr EventType CANCELED =
    ExtensionInstallReportLogEvent_EventType_CANCELED;
  static constexpr EventType CONNECTIVITY_CHANGE =
    ExtensionInstallReportLogEvent_EventType_CONNECTIVITY_CHANGE;
  static constexpr EventType SESSION_STATE_CHANGE =
    ExtensionInstallReportLogEvent_EventType_SESSION_STATE_CHANGE;
  static constexpr EventType INSTALLATION_FAILED =
    ExtensionInstallReportLogEvent_EventType_INSTALLATION_FAILED;
  static inline bool EventType_IsValid(int value) {
    return ExtensionInstallReportLogEvent_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    ExtensionInstallReportLogEvent_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    ExtensionInstallReportLogEvent_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    ExtensionInstallReportLogEvent_EventType_EventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return ExtensionInstallReportLogEvent_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventType* value) {
    return ExtensionInstallReportLogEvent_EventType_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_SessionStateChangeType SessionStateChangeType;
  static constexpr SessionStateChangeType SESSION_STATE_CHANGE_TYPE_UNKNOWN =
    ExtensionInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN;
  static constexpr SessionStateChangeType LOGIN =
    ExtensionInstallReportLogEvent_SessionStateChangeType_LOGIN;
  static constexpr SessionStateChangeType LOGOUT =
    ExtensionInstallReportLogEvent_SessionStateChangeType_LOGOUT;
  static constexpr SessionStateChangeType SUSPEND =
    ExtensionInstallReportLogEvent_SessionStateChangeType_SUSPEND;
  static constexpr SessionStateChangeType RESUME =
    ExtensionInstallReportLogEvent_SessionStateChangeType_RESUME;
  static inline bool SessionStateChangeType_IsValid(int value) {
    return ExtensionInstallReportLogEvent_SessionStateChangeType_IsValid(value);
  }
  static constexpr SessionStateChangeType SessionStateChangeType_MIN =
    ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MIN;
  static constexpr SessionStateChangeType SessionStateChangeType_MAX =
    ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX;
  static constexpr int SessionStateChangeType_ARRAYSIZE =
    ExtensionInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SessionStateChangeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SessionStateChangeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SessionStateChangeType_Name.");
    return ExtensionInstallReportLogEvent_SessionStateChangeType_Name(enum_t_value);
  }
  static inline bool SessionStateChangeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SessionStateChangeType* value) {
    return ExtensionInstallReportLogEvent_SessionStateChangeType_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_FailureReason FailureReason;
  static constexpr FailureReason FAILURE_REASON_UNKNOWN =
    ExtensionInstallReportLogEvent_FailureReason_FAILURE_REASON_UNKNOWN;
  static constexpr FailureReason INVALID_ID =
    ExtensionInstallReportLogEvent_FailureReason_INVALID_ID;
  static constexpr FailureReason MALFORMED_EXTENSION_SETTINGS =
    ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_SETTINGS;
  static constexpr FailureReason REPLACED_BY_ARC_APP =
    ExtensionInstallReportLogEvent_FailureReason_REPLACED_BY_ARC_APP;
  static constexpr FailureReason MALFORMED_EXTENSION_DICT =
    ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_DICT;
  static constexpr FailureReason NOT_SUPPORTED_EXTENSION_DICT =
    ExtensionInstallReportLogEvent_FailureReason_NOT_SUPPORTED_EXTENSION_DICT;
  static constexpr FailureReason MALFORMED_EXTENSION_DICT_FILE_PATH =
    ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_DICT_FILE_PATH;
  static constexpr FailureReason MALFORMED_EXTENSION_DICT_VERSION =
    ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_DICT_VERSION;
  static constexpr FailureReason MALFORMED_EXTENSION_DICT_UPDATE_URL =
    ExtensionInstallReportLogEvent_FailureReason_MALFORMED_EXTENSION_DICT_UPDATE_URL;
  static constexpr FailureReason LOCALE_NOT_SUPPORTED =
    ExtensionInstallReportLogEvent_FailureReason_LOCALE_NOT_SUPPORTED;
  static constexpr FailureReason NOT_PERFORMING_NEW_INSTALL =
    ExtensionInstallReportLogEvent_FailureReason_NOT_PERFORMING_NEW_INSTALL;
  static constexpr FailureReason TOO_OLD_PROFILE =
    ExtensionInstallReportLogEvent_FailureReason_TOO_OLD_PROFILE;
  static constexpr FailureReason DO_NOT_INSTALL_FOR_ENTERPRISE =
    ExtensionInstallReportLogEvent_FailureReason_DO_NOT_INSTALL_FOR_ENTERPRISE;
  static constexpr FailureReason ALREADY_INSTALLED =
    ExtensionInstallReportLogEvent_FailureReason_ALREADY_INSTALLED;
  static constexpr FailureReason CRX_FETCH_FAILED =
    ExtensionInstallReportLogEvent_FailureReason_CRX_FETCH_FAILED;
  static constexpr FailureReason MANIFEST_FETCH_FAILED =
    ExtensionInstallReportLogEvent_FailureReason_MANIFEST_FETCH_FAILED;
  static constexpr FailureReason MANIFEST_INVALID =
    ExtensionInstallReportLogEvent_FailureReason_MANIFEST_INVALID;
  static constexpr FailureReason NO_UPDATE =
    ExtensionInstallReportLogEvent_FailureReason_NO_UPDATE;
  static constexpr FailureReason CRX_INSTALL_ERROR_DECLINED =
    ExtensionInstallReportLogEvent_FailureReason_CRX_INSTALL_ERROR_DECLINED;
  static constexpr FailureReason CRX_INSTALL_ERROR_SANDBOXED_UNPACKER_FAILURE =
    ExtensionInstallReportLogEvent_FailureReason_CRX_INSTALL_ERROR_SANDBOXED_UNPACKER_FAILURE;
  static constexpr FailureReason CRX_INSTALL_ERROR_OTHER =
    ExtensionInstallReportLogEvent_FailureReason_CRX_INSTALL_ERROR_OTHER;
  static constexpr FailureReason NO_UPDATE_URL =
    ExtensionInstallReportLogEvent_FailureReason_NO_UPDATE_URL;
  static constexpr FailureReason PENDING_ADD_FAILED =
    ExtensionInstallReportLogEvent_FailureReason_PENDING_ADD_FAILED;
  static constexpr FailureReason DOWNLOADER_ADD_FAILED =
    ExtensionInstallReportLogEvent_FailureReason_DOWNLOADER_ADD_FAILED;
  static constexpr FailureReason IN_PROGRESS =
    ExtensionInstallReportLogEvent_FailureReason_IN_PROGRESS;
  static constexpr FailureReason CRX_FETCH_URL_EMPTY =
    ExtensionInstallReportLogEvent_FailureReason_CRX_FETCH_URL_EMPTY;
  static constexpr FailureReason CRX_FETCH_URL_INVALID =
    ExtensionInstallReportLogEvent_FailureReason_CRX_FETCH_URL_INVALID;
  static constexpr FailureReason OVERRIDDEN_BY_SETTINGS =
    ExtensionInstallReportLogEvent_FailureReason_OVERRIDDEN_BY_SETTINGS;
  static constexpr FailureReason REPLACED_BY_SYSTEM_APP =
    ExtensionInstallReportLogEvent_FailureReason_REPLACED_BY_SYSTEM_APP;
  static inline bool FailureReason_IsValid(int value) {
    return ExtensionInstallReportLogEvent_FailureReason_IsValid(value);
  }
  static constexpr FailureReason FailureReason_MIN =
    ExtensionInstallReportLogEvent_FailureReason_FailureReason_MIN;
  static constexpr FailureReason FailureReason_MAX =
    ExtensionInstallReportLogEvent_FailureReason_FailureReason_MAX;
  static constexpr int FailureReason_ARRAYSIZE =
    ExtensionInstallReportLogEvent_FailureReason_FailureReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FailureReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FailureReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FailureReason_Name.");
    return ExtensionInstallReportLogEvent_FailureReason_Name(enum_t_value);
  }
  static inline bool FailureReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FailureReason* value) {
    return ExtensionInstallReportLogEvent_FailureReason_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_InstallationStage InstallationStage;
  static constexpr InstallationStage INSTALLATION_STAGE_UNKNOWN =
    ExtensionInstallReportLogEvent_InstallationStage_INSTALLATION_STAGE_UNKNOWN;
  static constexpr InstallationStage CREATED =
    ExtensionInstallReportLogEvent_InstallationStage_CREATED;
  static constexpr InstallationStage PENDING =
    ExtensionInstallReportLogEvent_InstallationStage_PENDING;
  static constexpr InstallationStage DOWNLOADING =
    ExtensionInstallReportLogEvent_InstallationStage_DOWNLOADING;
  static constexpr InstallationStage INSTALLING =
    ExtensionInstallReportLogEvent_InstallationStage_INSTALLING;
  static constexpr InstallationStage COMPLETE =
    ExtensionInstallReportLogEvent_InstallationStage_COMPLETE;
  static inline bool InstallationStage_IsValid(int value) {
    return ExtensionInstallReportLogEvent_InstallationStage_IsValid(value);
  }
  static constexpr InstallationStage InstallationStage_MIN =
    ExtensionInstallReportLogEvent_InstallationStage_InstallationStage_MIN;
  static constexpr InstallationStage InstallationStage_MAX =
    ExtensionInstallReportLogEvent_InstallationStage_InstallationStage_MAX;
  static constexpr int InstallationStage_ARRAYSIZE =
    ExtensionInstallReportLogEvent_InstallationStage_InstallationStage_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InstallationStage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InstallationStage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InstallationStage_Name.");
    return ExtensionInstallReportLogEvent_InstallationStage_Name(enum_t_value);
  }
  static inline bool InstallationStage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InstallationStage* value) {
    return ExtensionInstallReportLogEvent_InstallationStage_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_UserType UserType;
  static constexpr UserType USER_TYPE_UNKNOWN =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_UNKNOWN;
  static constexpr UserType USER_TYPE_REGULAR =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_REGULAR;
  static constexpr UserType USER_TYPE_GUEST =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_GUEST;
  static constexpr UserType USER_TYPE_PUBLIC_ACCOUNT =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_PUBLIC_ACCOUNT;
  PROTOBUF_DEPRECATED_ENUM static constexpr UserType USER_TYPE_SUPERVISED_DEPRECATED =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_SUPERVISED_DEPRECATED;
  static constexpr UserType USER_TYPE_KIOSK_APP =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_KIOSK_APP;
  static constexpr UserType USER_TYPE_CHILD =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_CHILD;
  static constexpr UserType USER_TYPE_ARC_KIOSK_APP =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_ARC_KIOSK_APP;
  static constexpr UserType USER_TYPE_ACTIVE_DIRECTORY =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_ACTIVE_DIRECTORY;
  static constexpr UserType USER_TYPE_WEB_KIOSK_APP =
    ExtensionInstallReportLogEvent_UserType_USER_TYPE_WEB_KIOSK_APP;
  static inline bool UserType_IsValid(int value) {
    return ExtensionInstallReportLogEvent_UserType_IsValid(value);
  }
  static constexpr UserType UserType_MIN =
    ExtensionInstallReportLogEvent_UserType_UserType_MIN;
  static constexpr UserType UserType_MAX =
    ExtensionInstallReportLogEvent_UserType_UserType_MAX;
  static constexpr int UserType_ARRAYSIZE =
    ExtensionInstallReportLogEvent_UserType_UserType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& UserType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UserType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UserType_Name.");
    return ExtensionInstallReportLogEvent_UserType_Name(enum_t_value);
  }
  static inline bool UserType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UserType* value) {
    return ExtensionInstallReportLogEvent_UserType_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_DownloadingStage DownloadingStage;
  static constexpr DownloadingStage DOWNLOADING_STAGE_UNKNOWN =
    ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_STAGE_UNKNOWN;
  static constexpr DownloadingStage DOWNLOAD_PENDING =
    ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOAD_PENDING;
  static constexpr DownloadingStage QUEUED_FOR_MANIFEST =
    ExtensionInstallReportLogEvent_DownloadingStage_QUEUED_FOR_MANIFEST;
  static constexpr DownloadingStage DOWNLOADING_MANIFEST =
    ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_MANIFEST;
  static constexpr DownloadingStage DOWNLOADING_MANIFEST_RETRY =
    ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_MANIFEST_RETRY;
  static constexpr DownloadingStage PARSING_MANIFEST =
    ExtensionInstallReportLogEvent_DownloadingStage_PARSING_MANIFEST;
  static constexpr DownloadingStage MANIFEST_LOADED =
    ExtensionInstallReportLogEvent_DownloadingStage_MANIFEST_LOADED;
  static constexpr DownloadingStage QUEUED_FOR_CRX =
    ExtensionInstallReportLogEvent_DownloadingStage_QUEUED_FOR_CRX;
  static constexpr DownloadingStage DOWNLOADING_CRX =
    ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_CRX;
  static constexpr DownloadingStage DOWNLOADING_CRX_RETRY =
    ExtensionInstallReportLogEvent_DownloadingStage_DOWNLOADING_CRX_RETRY;
  static constexpr DownloadingStage FINISHED =
    ExtensionInstallReportLogEvent_DownloadingStage_FINISHED;
  static inline bool DownloadingStage_IsValid(int value) {
    return ExtensionInstallReportLogEvent_DownloadingStage_IsValid(value);
  }
  static constexpr DownloadingStage DownloadingStage_MIN =
    ExtensionInstallReportLogEvent_DownloadingStage_DownloadingStage_MIN;
  static constexpr DownloadingStage DownloadingStage_MAX =
    ExtensionInstallReportLogEvent_DownloadingStage_DownloadingStage_MAX;
  static constexpr int DownloadingStage_ARRAYSIZE =
    ExtensionInstallReportLogEvent_DownloadingStage_DownloadingStage_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DownloadingStage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DownloadingStage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DownloadingStage_Name.");
    return ExtensionInstallReportLogEvent_DownloadingStage_Name(enum_t_value);
  }
  static inline bool DownloadingStage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DownloadingStage* value) {
    return ExtensionInstallReportLogEvent_DownloadingStage_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_InstallCreationStage InstallCreationStage;
  static constexpr InstallCreationStage INSTALL_CREATION_STAGE_UNKNOWN =
    ExtensionInstallReportLogEvent_InstallCreationStage_INSTALL_CREATION_STAGE_UNKNOWN;
  static constexpr InstallCreationStage CREATION_INITIATED =
    ExtensionInstallReportLogEvent_InstallCreationStage_CREATION_INITIATED;
  static constexpr InstallCreationStage NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_FORCED =
    ExtensionInstallReportLogEvent_InstallCreationStage_NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_FORCED;
  static constexpr InstallCreationStage NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_NOT_FORCED =
    ExtensionInstallReportLogEvent_InstallCreationStage_NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_NOT_FORCED;
  static constexpr InstallCreationStage NOTIFIED_FROM_MANAGEMENT =
    ExtensionInstallReportLogEvent_InstallCreationStage_NOTIFIED_FROM_MANAGEMENT;
  static constexpr InstallCreationStage NOTIFIED_FROM_MANAGEMENT_NOT_FORCED =
    ExtensionInstallReportLogEvent_InstallCreationStage_NOTIFIED_FROM_MANAGEMENT_NOT_FORCED;
  static constexpr InstallCreationStage SEEN_BY_POLICY_LOADER =
    ExtensionInstallReportLogEvent_InstallCreationStage_SEEN_BY_POLICY_LOADER;
  static constexpr InstallCreationStage SEEN_BY_EXTERNAL_PROVIDER =
    ExtensionInstallReportLogEvent_InstallCreationStage_SEEN_BY_EXTERNAL_PROVIDER;
  static inline bool InstallCreationStage_IsValid(int value) {
    return ExtensionInstallReportLogEvent_InstallCreationStage_IsValid(value);
  }
  static constexpr InstallCreationStage InstallCreationStage_MIN =
    ExtensionInstallReportLogEvent_InstallCreationStage_InstallCreationStage_MIN;
  static constexpr InstallCreationStage InstallCreationStage_MAX =
    ExtensionInstallReportLogEvent_InstallCreationStage_InstallCreationStage_MAX;
  static constexpr int InstallCreationStage_ARRAYSIZE =
    ExtensionInstallReportLogEvent_InstallCreationStage_InstallCreationStage_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InstallCreationStage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InstallCreationStage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InstallCreationStage_Name.");
    return ExtensionInstallReportLogEvent_InstallCreationStage_Name(enum_t_value);
  }
  static inline bool InstallCreationStage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InstallCreationStage* value) {
    return ExtensionInstallReportLogEvent_InstallCreationStage_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_DownloadCacheStatus DownloadCacheStatus;
  static constexpr DownloadCacheStatus CACHE_UNKNOWN =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_UNKNOWN;
  static constexpr DownloadCacheStatus CACHE_DISABLED =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_DISABLED;
  static constexpr DownloadCacheStatus CACHE_MISS =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_MISS;
  static constexpr DownloadCacheStatus CACHE_OUTDATED =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_OUTDATED;
  static constexpr DownloadCacheStatus CACHE_HIT =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_HIT;
  static constexpr DownloadCacheStatus CACHE_HIT_ON_MANIFEST_FETCH_FAILURE =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_CACHE_HIT_ON_MANIFEST_FETCH_FAILURE;
  static inline bool DownloadCacheStatus_IsValid(int value) {
    return ExtensionInstallReportLogEvent_DownloadCacheStatus_IsValid(value);
  }
  static constexpr DownloadCacheStatus DownloadCacheStatus_MIN =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_DownloadCacheStatus_MIN;
  static constexpr DownloadCacheStatus DownloadCacheStatus_MAX =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_DownloadCacheStatus_MAX;
  static constexpr int DownloadCacheStatus_ARRAYSIZE =
    ExtensionInstallReportLogEvent_DownloadCacheStatus_DownloadCacheStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DownloadCacheStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DownloadCacheStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DownloadCacheStatus_Name.");
    return ExtensionInstallReportLogEvent_DownloadCacheStatus_Name(enum_t_value);
  }
  static inline bool DownloadCacheStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DownloadCacheStatus* value) {
    return ExtensionInstallReportLogEvent_DownloadCacheStatus_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason SandboxedUnpackerFailureReason;
  static constexpr SandboxedUnpackerFailureReason SANDBOXED_UNPACKER_FAILURE_REASON_UNKNOWN =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SANDBOXED_UNPACKER_FAILURE_REASON_UNKNOWN;
  static constexpr SandboxedUnpackerFailureReason COULD_NOT_GET_TEMP_DIRECTORY =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_GET_TEMP_DIRECTORY;
  static constexpr SandboxedUnpackerFailureReason COULD_NOT_CREATE_TEMP_DIRECTORY =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_CREATE_TEMP_DIRECTORY;
  static constexpr SandboxedUnpackerFailureReason FAILED_TO_COPY_EXTENSION_FILE_TO_TEMP_DIRECTORY =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_FAILED_TO_COPY_EXTENSION_FILE_TO_TEMP_DIRECTORY;
  static constexpr SandboxedUnpackerFailureReason COULD_NOT_GET_SANDBOX_FRIENDLY_PATH =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_GET_SANDBOX_FRIENDLY_PATH;
  static constexpr SandboxedUnpackerFailureReason COULD_NOT_LOCALIZE_EXTENSION =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_LOCALIZE_EXTENSION;
  static constexpr SandboxedUnpackerFailureReason INVALID_MANIFEST =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_MANIFEST;
  static constexpr SandboxedUnpackerFailureReason UNPACKER_CLIENT_FAILED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_UNPACKER_CLIENT_FAILED;
  static constexpr SandboxedUnpackerFailureReason UTILITY_PROCESS_CRASHED_WHILE_TRYING_TO_INSTALL =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_UTILITY_PROCESS_CRASHED_WHILE_TRYING_TO_INSTALL;
  static constexpr SandboxedUnpackerFailureReason CRX_FILE_NOT_READABLE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_FILE_NOT_READABLE;
  static constexpr SandboxedUnpackerFailureReason CRX_HEADER_INVALID =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_HEADER_INVALID;
  static constexpr SandboxedUnpackerFailureReason CRX_MAGIC_NUMBER_INVALID =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_MAGIC_NUMBER_INVALID;
  static constexpr SandboxedUnpackerFailureReason CRX_VERSION_NUMBER_INVALID =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_VERSION_NUMBER_INVALID;
  static constexpr SandboxedUnpackerFailureReason CRX_EXCESSIVELY_LARGE_KEY_OR_SIGNATURE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_EXCESSIVELY_LARGE_KEY_OR_SIGNATURE;
  static constexpr SandboxedUnpackerFailureReason CRX_ZERO_KEY_LENGTH =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_ZERO_KEY_LENGTH;
  static constexpr SandboxedUnpackerFailureReason CRX_ZERO_SIGNATURE_LENGTH =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_ZERO_SIGNATURE_LENGTH;
  static constexpr SandboxedUnpackerFailureReason CRX_PUBLIC_KEY_INVALID =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_PUBLIC_KEY_INVALID;
  static constexpr SandboxedUnpackerFailureReason CRX_SIGNATURE_INVALID =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_SIGNATURE_INVALID;
  static constexpr SandboxedUnpackerFailureReason CRX_SIGNATURE_VERIFICATION_INITIALIZATION_FAILED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_SIGNATURE_VERIFICATION_INITIALIZATION_FAILED;
  static constexpr SandboxedUnpackerFailureReason CRX_SIGNATURE_VERIFICATION_FAILED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_SIGNATURE_VERIFICATION_FAILED;
  static constexpr SandboxedUnpackerFailureReason ERROR_SERIALIZING_MANIFEST_JSON =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SERIALIZING_MANIFEST_JSON;
  static constexpr SandboxedUnpackerFailureReason ERROR_SAVING_MANIFEST_JSON =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SAVING_MANIFEST_JSON;
  static constexpr SandboxedUnpackerFailureReason COULD_NOT_READ_IMAGE_DATA_FROM_DISK_UNUSED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_READ_IMAGE_DATA_FROM_DISK_UNUSED;
  static constexpr SandboxedUnpackerFailureReason DECODED_IMAGES_DO_NOT_MATCH_THE_MANIFEST_UNUSED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_DECODED_IMAGES_DO_NOT_MATCH_THE_MANIFEST_UNUSED;
  static constexpr SandboxedUnpackerFailureReason INVALID_PATH_FOR_BROWSER_IMAGE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_PATH_FOR_BROWSER_IMAGE;
  static constexpr SandboxedUnpackerFailureReason ERROR_REMOVING_OLD_IMAGE_FILE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_REMOVING_OLD_IMAGE_FILE;
  static constexpr SandboxedUnpackerFailureReason INVALID_PATH_FOR_BITMAP_IMAGE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_PATH_FOR_BITMAP_IMAGE;
  static constexpr SandboxedUnpackerFailureReason ERROR_RE_ENCODING_THEME_IMAGE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_RE_ENCODING_THEME_IMAGE;
  static constexpr SandboxedUnpackerFailureReason ERROR_SAVING_THEME_IMAGE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SAVING_THEME_IMAGE;
  static constexpr SandboxedUnpackerFailureReason DEPRECATED_ABORTED_DUE_TO_SHUTDOWN =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_DEPRECATED_ABORTED_DUE_TO_SHUTDOWN;
  static constexpr SandboxedUnpackerFailureReason COULD_NOT_READ_CATALOG_DATA_FROM_DISK_UNUSED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_READ_CATALOG_DATA_FROM_DISK_UNUSED;
  static constexpr SandboxedUnpackerFailureReason INVALID_CATALOG_DATA =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_CATALOG_DATA;
  static constexpr SandboxedUnpackerFailureReason INVALID_PATH_FOR_CATALOG_UNUSED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_INVALID_PATH_FOR_CATALOG_UNUSED;
  static constexpr SandboxedUnpackerFailureReason ERROR_SERIALIZING_CATALOG =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SERIALIZING_CATALOG;
  static constexpr SandboxedUnpackerFailureReason ERROR_SAVING_CATALOG =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_SAVING_CATALOG;
  static constexpr SandboxedUnpackerFailureReason CRX_HASH_VERIFICATION_FAILED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_HASH_VERIFICATION_FAILED;
  static constexpr SandboxedUnpackerFailureReason UNZIP_FAILED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_UNZIP_FAILED;
  static constexpr SandboxedUnpackerFailureReason DIRECTORY_MOVE_FAILED =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_DIRECTORY_MOVE_FAILED;
  static constexpr SandboxedUnpackerFailureReason CRX_FILE_IS_DELTA_UPDATE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_FILE_IS_DELTA_UPDATE;
  static constexpr SandboxedUnpackerFailureReason CRX_EXPECTED_HASH_INVALID =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_EXPECTED_HASH_INVALID;
  static constexpr SandboxedUnpackerFailureReason DEPRECATED_ERROR_PARSING_DNR_RULESET =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_DEPRECATED_ERROR_PARSING_DNR_RULESET;
  static constexpr SandboxedUnpackerFailureReason ERROR_INDEXING_DNR_RULESET =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_ERROR_INDEXING_DNR_RULESET;
  static constexpr SandboxedUnpackerFailureReason CRX_REQUIRED_PROOF_MISSING =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_REQUIRED_PROOF_MISSING;
  static constexpr SandboxedUnpackerFailureReason CRX_HEADER_VERIFIED_CONTENTS_UNCOMPRESSING_FAILURE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_CRX_HEADER_VERIFIED_CONTENTS_UNCOMPRESSING_FAILURE;
  static constexpr SandboxedUnpackerFailureReason MALFORMED_VERIFIED_CONTENTS =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_MALFORMED_VERIFIED_CONTENTS;
  static constexpr SandboxedUnpackerFailureReason COULD_NOT_CREATE_METADATA_DIRECTORY =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_CREATE_METADATA_DIRECTORY;
  static constexpr SandboxedUnpackerFailureReason COULD_NOT_WRITE_VERIFIED_CONTENTS_INTO_FILE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_COULD_NOT_WRITE_VERIFIED_CONTENTS_INTO_FILE;
  static inline bool SandboxedUnpackerFailureReason_IsValid(int value) {
    return ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_IsValid(value);
  }
  static constexpr SandboxedUnpackerFailureReason SandboxedUnpackerFailureReason_MIN =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SandboxedUnpackerFailureReason_MIN;
  static constexpr SandboxedUnpackerFailureReason SandboxedUnpackerFailureReason_MAX =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SandboxedUnpackerFailureReason_MAX;
  static constexpr int SandboxedUnpackerFailureReason_ARRAYSIZE =
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_SandboxedUnpackerFailureReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SandboxedUnpackerFailureReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SandboxedUnpackerFailureReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SandboxedUnpackerFailureReason_Name.");
    return ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Name(enum_t_value);
  }
  static inline bool SandboxedUnpackerFailureReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SandboxedUnpackerFailureReason* value) {
    return ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_ManifestInvalidError ManifestInvalidError;
  static constexpr ManifestInvalidError MANIFEST_INVALID_ERROR_UNKNOWN =
    ExtensionInstallReportLogEvent_ManifestInvalidError_MANIFEST_INVALID_ERROR_UNKNOWN;
  static constexpr ManifestInvalidError XML_PARSING_FAILED =
    ExtensionInstallReportLogEvent_ManifestInvalidError_XML_PARSING_FAILED;
  static constexpr ManifestInvalidError INVALID_XLMNS_ON_GUPDATE_TAG =
    ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_XLMNS_ON_GUPDATE_TAG;
  static constexpr ManifestInvalidError MISSING_GUPDATE_TAG =
    ExtensionInstallReportLogEvent_ManifestInvalidError_MISSING_GUPDATE_TAG;
  static constexpr ManifestInvalidError INVALID_PROTOCOL_ON_GUPDATE_TAG =
    ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_PROTOCOL_ON_GUPDATE_TAG;
  static constexpr ManifestInvalidError MISSING_APP_ID =
    ExtensionInstallReportLogEvent_ManifestInvalidError_MISSING_APP_ID;
  static constexpr ManifestInvalidError MISSING_UPDATE_CHECK_TAGS =
    ExtensionInstallReportLogEvent_ManifestInvalidError_MISSING_UPDATE_CHECK_TAGS;
  static constexpr ManifestInvalidError MULTIPLE_UPDATE_CHECK_TAGS =
    ExtensionInstallReportLogEvent_ManifestInvalidError_MULTIPLE_UPDATE_CHECK_TAGS;
  static constexpr ManifestInvalidError INVALID_PRODVERSION_MIN =
    ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_PRODVERSION_MIN;
  static constexpr ManifestInvalidError EMPTY_CODEBASE_URL =
    ExtensionInstallReportLogEvent_ManifestInvalidError_EMPTY_CODEBASE_URL;
  static constexpr ManifestInvalidError INVALID_CODEBASE_URL =
    ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_CODEBASE_URL;
  static constexpr ManifestInvalidError MISSING_VERSION_FOR_UPDATE_CHECK =
    ExtensionInstallReportLogEvent_ManifestInvalidError_MISSING_VERSION_FOR_UPDATE_CHECK;
  static constexpr ManifestInvalidError INVALID_VERSION =
    ExtensionInstallReportLogEvent_ManifestInvalidError_INVALID_VERSION;
  static constexpr ManifestInvalidError BAD_UPDATE_SPECIFICATION =
    ExtensionInstallReportLogEvent_ManifestInvalidError_BAD_UPDATE_SPECIFICATION;
  static constexpr ManifestInvalidError BAD_APP_STATUS =
    ExtensionInstallReportLogEvent_ManifestInvalidError_BAD_APP_STATUS;
  static inline bool ManifestInvalidError_IsValid(int value) {
    return ExtensionInstallReportLogEvent_ManifestInvalidError_IsValid(value);
  }
  static constexpr ManifestInvalidError ManifestInvalidError_MIN =
    ExtensionInstallReportLogEvent_ManifestInvalidError_ManifestInvalidError_MIN;
  static constexpr ManifestInvalidError ManifestInvalidError_MAX =
    ExtensionInstallReportLogEvent_ManifestInvalidError_ManifestInvalidError_MAX;
  static constexpr int ManifestInvalidError_ARRAYSIZE =
    ExtensionInstallReportLogEvent_ManifestInvalidError_ManifestInvalidError_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ManifestInvalidError_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ManifestInvalidError>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ManifestInvalidError_Name.");
    return ExtensionInstallReportLogEvent_ManifestInvalidError_Name(enum_t_value);
  }
  static inline bool ManifestInvalidError_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ManifestInvalidError* value) {
    return ExtensionInstallReportLogEvent_ManifestInvalidError_Parse(name, value);
  }

  typedef ExtensionInstallReportLogEvent_CrxInstallErrorDetail CrxInstallErrorDetail;
  static constexpr CrxInstallErrorDetail CRX_INSTALL_ERROR_DETAIL_UNKNOWN =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CRX_INSTALL_ERROR_DETAIL_UNKNOWN;
  static constexpr CrxInstallErrorDetail CONVERT_USER_SCRIPT_TO_EXTENSION_FAILED =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CONVERT_USER_SCRIPT_TO_EXTENSION_FAILED;
  static constexpr CrxInstallErrorDetail UNEXPECTED_ID =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UNEXPECTED_ID;
  static constexpr CrxInstallErrorDetail UNEXPECTED_VERSION =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UNEXPECTED_VERSION;
  static constexpr CrxInstallErrorDetail MISMATCHED_VERSION =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_MISMATCHED_VERSION;
  static constexpr CrxInstallErrorDetail CRX_ERROR_MANIFEST_INVALID =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CRX_ERROR_MANIFEST_INVALID;
  static constexpr CrxInstallErrorDetail INSTALL_NOT_ENABLED =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_INSTALL_NOT_ENABLED;
  static constexpr CrxInstallErrorDetail OFFSTORE_INSTALL_DISALLOWED =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_OFFSTORE_INSTALL_DISALLOWED;
  static constexpr CrxInstallErrorDetail INCORRECT_APP_CONTENT_TYPE =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_INCORRECT_APP_CONTENT_TYPE;
  static constexpr CrxInstallErrorDetail NOT_INSTALLED_FROM_GALLERY =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_NOT_INSTALLED_FROM_GALLERY;
  static constexpr CrxInstallErrorDetail INCORRECT_INSTALL_HOST =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_INCORRECT_INSTALL_HOST;
  static constexpr CrxInstallErrorDetail DEPENDENCY_NOT_SHARED_MODULE =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_DEPENDENCY_NOT_SHARED_MODULE;
  static constexpr CrxInstallErrorDetail DEPENDENCY_OLD_VERSION =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_DEPENDENCY_OLD_VERSION;
  static constexpr CrxInstallErrorDetail DEPENDENCY_NOT_ALLOWLISTED =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_DEPENDENCY_NOT_ALLOWLISTED;
  static constexpr CrxInstallErrorDetail UNSUPPORTED_REQUIREMENTS =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UNSUPPORTED_REQUIREMENTS;
  static constexpr CrxInstallErrorDetail EXTENSION_IS_BLOCKLISTED =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_EXTENSION_IS_BLOCKLISTED;
  static constexpr CrxInstallErrorDetail DISALLOWED_BY_POLICY =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_DISALLOWED_BY_POLICY;
  static constexpr CrxInstallErrorDetail KIOSK_MODE_ONLY =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_KIOSK_MODE_ONLY;
  static constexpr CrxInstallErrorDetail OVERLAPPING_WEB_EXTENT =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_OVERLAPPING_WEB_EXTENT;
  static constexpr CrxInstallErrorDetail CANT_DOWNGRADE_VERSION =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CANT_DOWNGRADE_VERSION;
  static constexpr CrxInstallErrorDetail MOVE_DIRECTORY_TO_PROFILE_FAILED =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_MOVE_DIRECTORY_TO_PROFILE_FAILED;
  static constexpr CrxInstallErrorDetail CANT_LOAD_EXTENSION =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CANT_LOAD_EXTENSION;
  static constexpr CrxInstallErrorDetail USER_CANCELED =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_USER_CANCELED;
  static constexpr CrxInstallErrorDetail USER_ABORTED =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_USER_ABORTED;
  static constexpr CrxInstallErrorDetail UPDATE_NON_EXISTING_EXTENSION =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_UPDATE_NON_EXISTING_EXTENSION;
  static inline bool CrxInstallErrorDetail_IsValid(int value) {
    return ExtensionInstallReportLogEvent_CrxInstallErrorDetail_IsValid(value);
  }
  static constexpr CrxInstallErrorDetail CrxInstallErrorDetail_MIN =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CrxInstallErrorDetail_MIN;
  static constexpr CrxInstallErrorDetail CrxInstallErrorDetail_MAX =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CrxInstallErrorDetail_MAX;
  static constexpr int CrxInstallErrorDetail_ARRAYSIZE =
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail_CrxInstallErrorDetail_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CrxInstallErrorDetail_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CrxInstallErrorDetail>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CrxInstallErrorDetail_Name.");
    return ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Name(enum_t_value);
  }
  static inline bool CrxInstallErrorDetail_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CrxInstallErrorDetail* value) {
    return ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kStatefulTotalFieldNumber = 3,
    kStatefulFreeFieldNumber = 4,
    kEventTypeFieldNumber = 2,
    kSessionStateChangeTypeFieldNumber = 6,
    kFailureReasonFieldNumber = 7,
    kInstallationStageFieldNumber = 8,
    kDownloadingStageFieldNumber = 9,
    kExtensionTypeFieldNumber = 10,
    kOnlineFieldNumber = 5,
    kIsNewUserFieldNumber = 12,
    kIsMisconfigurationFailureFieldNumber = 13,
    kUserTypeFieldNumber = 11,
    kInstallCreationStageFieldNumber = 14,
    kDownloadCacheStatusFieldNumber = 15,
    kUnpackerFailureReasonFieldNumber = 16,
    kManifestInvalidErrorFieldNumber = 17,
    kCrxInstallErrorDetailFieldNumber = 18,
    kFetchErrorCodeFieldNumber = 19,
    kFetchTriesFieldNumber = 20,
  };
  // optional int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int64 stateful_total = 3;
  bool has_stateful_total() const;
  private:
  bool _internal_has_stateful_total() const;
  public:
  void clear_stateful_total();
  int64_t stateful_total() const;
  void set_stateful_total(int64_t value);
  private:
  int64_t _internal_stateful_total() const;
  void _internal_set_stateful_total(int64_t value);
  public:

  // optional int64 stateful_free = 4;
  bool has_stateful_free() const;
  private:
  bool _internal_has_stateful_free() const;
  public:
  void clear_stateful_free();
  int64_t stateful_free() const;
  void set_stateful_free(int64_t value);
  private:
  int64_t _internal_stateful_free() const;
  void _internal_set_stateful_free(int64_t value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.EventType event_type = 2;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  ::enterprise_management::ExtensionInstallReportLogEvent_EventType event_type() const;
  void set_event_type(::enterprise_management::ExtensionInstallReportLogEvent_EventType value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_EventType _internal_event_type() const;
  void _internal_set_event_type(::enterprise_management::ExtensionInstallReportLogEvent_EventType value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.SessionStateChangeType session_state_change_type = 6;
  bool has_session_state_change_type() const;
  private:
  bool _internal_has_session_state_change_type() const;
  public:
  void clear_session_state_change_type();
  ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType session_state_change_type() const;
  void set_session_state_change_type(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType _internal_session_state_change_type() const;
  void _internal_set_session_state_change_type(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.FailureReason failure_reason = 7;
  bool has_failure_reason() const;
  private:
  bool _internal_has_failure_reason() const;
  public:
  void clear_failure_reason();
  ::enterprise_management::ExtensionInstallReportLogEvent_FailureReason failure_reason() const;
  void set_failure_reason(::enterprise_management::ExtensionInstallReportLogEvent_FailureReason value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_FailureReason _internal_failure_reason() const;
  void _internal_set_failure_reason(::enterprise_management::ExtensionInstallReportLogEvent_FailureReason value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.InstallationStage installation_stage = 8;
  bool has_installation_stage() const;
  private:
  bool _internal_has_installation_stage() const;
  public:
  void clear_installation_stage();
  ::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage installation_stage() const;
  void set_installation_stage(::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage _internal_installation_stage() const;
  void _internal_set_installation_stage(::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadingStage downloading_stage = 9;
  bool has_downloading_stage() const;
  private:
  bool _internal_has_downloading_stage() const;
  public:
  void clear_downloading_stage();
  ::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage downloading_stage() const;
  void set_downloading_stage(::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage _internal_downloading_stage() const;
  void _internal_set_downloading_stage(::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage value);
  public:

  // optional .enterprise_management.Extension.ExtensionType extension_type = 10;
  bool has_extension_type() const;
  private:
  bool _internal_has_extension_type() const;
  public:
  void clear_extension_type();
  ::enterprise_management::Extension_ExtensionType extension_type() const;
  void set_extension_type(::enterprise_management::Extension_ExtensionType value);
  private:
  ::enterprise_management::Extension_ExtensionType _internal_extension_type() const;
  void _internal_set_extension_type(::enterprise_management::Extension_ExtensionType value);
  public:

  // optional bool online = 5;
  bool has_online() const;
  private:
  bool _internal_has_online() const;
  public:
  void clear_online();
  bool online() const;
  void set_online(bool value);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);
  public:

  // optional bool is_new_user = 12;
  bool has_is_new_user() const;
  private:
  bool _internal_has_is_new_user() const;
  public:
  void clear_is_new_user();
  bool is_new_user() const;
  void set_is_new_user(bool value);
  private:
  bool _internal_is_new_user() const;
  void _internal_set_is_new_user(bool value);
  public:

  // optional bool is_misconfiguration_failure = 13;
  bool has_is_misconfiguration_failure() const;
  private:
  bool _internal_has_is_misconfiguration_failure() const;
  public:
  void clear_is_misconfiguration_failure();
  bool is_misconfiguration_failure() const;
  void set_is_misconfiguration_failure(bool value);
  private:
  bool _internal_is_misconfiguration_failure() const;
  void _internal_set_is_misconfiguration_failure(bool value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.UserType user_type = 11;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  ::enterprise_management::ExtensionInstallReportLogEvent_UserType user_type() const;
  void set_user_type(::enterprise_management::ExtensionInstallReportLogEvent_UserType value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_UserType _internal_user_type() const;
  void _internal_set_user_type(::enterprise_management::ExtensionInstallReportLogEvent_UserType value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.InstallCreationStage install_creation_stage = 14;
  bool has_install_creation_stage() const;
  private:
  bool _internal_has_install_creation_stage() const;
  public:
  void clear_install_creation_stage();
  ::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage install_creation_stage() const;
  void set_install_creation_stage(::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage _internal_install_creation_stage() const;
  void _internal_set_install_creation_stage(::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadCacheStatus download_cache_status = 15;
  bool has_download_cache_status() const;
  private:
  bool _internal_has_download_cache_status() const;
  public:
  void clear_download_cache_status();
  ::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus download_cache_status() const;
  void set_download_cache_status(::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus _internal_download_cache_status() const;
  void _internal_set_download_cache_status(::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.SandboxedUnpackerFailureReason unpacker_failure_reason = 16;
  bool has_unpacker_failure_reason() const;
  private:
  bool _internal_has_unpacker_failure_reason() const;
  public:
  void clear_unpacker_failure_reason();
  ::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason unpacker_failure_reason() const;
  void set_unpacker_failure_reason(::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason _internal_unpacker_failure_reason() const;
  void _internal_set_unpacker_failure_reason(::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.ManifestInvalidError manifest_invalid_error = 17;
  bool has_manifest_invalid_error() const;
  private:
  bool _internal_has_manifest_invalid_error() const;
  public:
  void clear_manifest_invalid_error();
  ::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError manifest_invalid_error() const;
  void set_manifest_invalid_error(::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError _internal_manifest_invalid_error() const;
  void _internal_set_manifest_invalid_error(::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError value);
  public:

  // optional .enterprise_management.ExtensionInstallReportLogEvent.CrxInstallErrorDetail crx_install_error_detail = 18;
  bool has_crx_install_error_detail() const;
  private:
  bool _internal_has_crx_install_error_detail() const;
  public:
  void clear_crx_install_error_detail();
  ::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail crx_install_error_detail() const;
  void set_crx_install_error_detail(::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail value);
  private:
  ::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail _internal_crx_install_error_detail() const;
  void _internal_set_crx_install_error_detail(::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail value);
  public:

  // optional int32 fetch_error_code = 19;
  bool has_fetch_error_code() const;
  private:
  bool _internal_has_fetch_error_code() const;
  public:
  void clear_fetch_error_code();
  int32_t fetch_error_code() const;
  void set_fetch_error_code(int32_t value);
  private:
  int32_t _internal_fetch_error_code() const;
  void _internal_set_fetch_error_code(int32_t value);
  public:

  // optional int32 fetch_tries = 20;
  bool has_fetch_tries() const;
  private:
  bool _internal_has_fetch_tries() const;
  public:
  void clear_fetch_tries();
  int32_t fetch_tries() const;
  void set_fetch_tries(int32_t value);
  private:
  int32_t _internal_fetch_tries() const;
  void _internal_set_fetch_tries(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ExtensionInstallReportLogEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t timestamp_;
    int64_t stateful_total_;
    int64_t stateful_free_;
    int event_type_;
    int session_state_change_type_;
    int failure_reason_;
    int installation_stage_;
    int downloading_stage_;
    int extension_type_;
    bool online_;
    bool is_new_user_;
    bool is_misconfiguration_failure_;
    int user_type_;
    int install_creation_stage_;
    int download_cache_status_;
    int unpacker_failure_reason_;
    int manifest_invalid_error_;
    int crx_install_error_detail_;
    int32_t fetch_error_code_;
    int32_t fetch_tries_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AppInstallReportLogEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInstallReportLogEvent) */ {
 public:
  inline AppInstallReportLogEvent() : AppInstallReportLogEvent(nullptr) {}
  ~AppInstallReportLogEvent() override;
  explicit PROTOBUF_CONSTEXPR AppInstallReportLogEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInstallReportLogEvent(const AppInstallReportLogEvent& from);
  AppInstallReportLogEvent(AppInstallReportLogEvent&& from) noexcept
    : AppInstallReportLogEvent() {
    *this = ::std::move(from);
  }

  inline AppInstallReportLogEvent& operator=(const AppInstallReportLogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInstallReportLogEvent& operator=(AppInstallReportLogEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppInstallReportLogEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInstallReportLogEvent* internal_default_instance() {
    return reinterpret_cast<const AppInstallReportLogEvent*>(
               &_AppInstallReportLogEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(AppInstallReportLogEvent& a, AppInstallReportLogEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInstallReportLogEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInstallReportLogEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInstallReportLogEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInstallReportLogEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AppInstallReportLogEvent& from);
  void MergeFrom(const AppInstallReportLogEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppInstallReportLogEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AppInstallReportLogEvent";
  }
  protected:
  explicit AppInstallReportLogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AppInstallReportLogEvent_EventType EventType;
  static constexpr EventType LOG_EVENT_TYPE_UNKNOWN =
    AppInstallReportLogEvent_EventType_LOG_EVENT_TYPE_UNKNOWN;
  static constexpr EventType SERVER_REQUEST =
    AppInstallReportLogEvent_EventType_SERVER_REQUEST;
  static constexpr EventType CLOUDDPC_REQUEST =
    AppInstallReportLogEvent_EventType_CLOUDDPC_REQUEST;
  static constexpr EventType CLOUDDPS_REQUEST =
    AppInstallReportLogEvent_EventType_CLOUDDPS_REQUEST;
  static constexpr EventType CLOUDDPS_RESPONSE =
    AppInstallReportLogEvent_EventType_CLOUDDPS_RESPONSE;
  static constexpr EventType PHONESKY_LOG =
    AppInstallReportLogEvent_EventType_PHONESKY_LOG;
  static constexpr EventType SUCCESS =
    AppInstallReportLogEvent_EventType_SUCCESS;
  static constexpr EventType CANCELED =
    AppInstallReportLogEvent_EventType_CANCELED;
  static constexpr EventType CONNECTIVITY_CHANGE =
    AppInstallReportLogEvent_EventType_CONNECTIVITY_CHANGE;
  static constexpr EventType SESSION_STATE_CHANGE =
    AppInstallReportLogEvent_EventType_SESSION_STATE_CHANGE;
  static constexpr EventType INSTALLATION_STARTED =
    AppInstallReportLogEvent_EventType_INSTALLATION_STARTED;
  static constexpr EventType INSTALLATION_FINISHED =
    AppInstallReportLogEvent_EventType_INSTALLATION_FINISHED;
  static constexpr EventType INSTALLATION_FAILED =
    AppInstallReportLogEvent_EventType_INSTALLATION_FAILED;
  static constexpr EventType DIRECT_INSTALL =
    AppInstallReportLogEvent_EventType_DIRECT_INSTALL;
  static constexpr EventType CLOUDDPC_MAIN_LOOP_FAILED =
    AppInstallReportLogEvent_EventType_CLOUDDPC_MAIN_LOOP_FAILED;
  static constexpr EventType PLAYSTORE_LOCAL_POLICY_SET =
    AppInstallReportLogEvent_EventType_PLAYSTORE_LOCAL_POLICY_SET;
  static inline bool EventType_IsValid(int value) {
    return AppInstallReportLogEvent_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    AppInstallReportLogEvent_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    AppInstallReportLogEvent_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    AppInstallReportLogEvent_EventType_EventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return AppInstallReportLogEvent_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventType* value) {
    return AppInstallReportLogEvent_EventType_Parse(name, value);
  }

  typedef AppInstallReportLogEvent_SessionStateChangeType SessionStateChangeType;
  static constexpr SessionStateChangeType SESSION_STATE_CHANGE_TYPE_UNKNOWN =
    AppInstallReportLogEvent_SessionStateChangeType_SESSION_STATE_CHANGE_TYPE_UNKNOWN;
  static constexpr SessionStateChangeType LOGIN =
    AppInstallReportLogEvent_SessionStateChangeType_LOGIN;
  static constexpr SessionStateChangeType LOGOUT =
    AppInstallReportLogEvent_SessionStateChangeType_LOGOUT;
  static constexpr SessionStateChangeType SUSPEND =
    AppInstallReportLogEvent_SessionStateChangeType_SUSPEND;
  static constexpr SessionStateChangeType RESUME =
    AppInstallReportLogEvent_SessionStateChangeType_RESUME;
  static inline bool SessionStateChangeType_IsValid(int value) {
    return AppInstallReportLogEvent_SessionStateChangeType_IsValid(value);
  }
  static constexpr SessionStateChangeType SessionStateChangeType_MIN =
    AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MIN;
  static constexpr SessionStateChangeType SessionStateChangeType_MAX =
    AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_MAX;
  static constexpr int SessionStateChangeType_ARRAYSIZE =
    AppInstallReportLogEvent_SessionStateChangeType_SessionStateChangeType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SessionStateChangeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SessionStateChangeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SessionStateChangeType_Name.");
    return AppInstallReportLogEvent_SessionStateChangeType_Name(enum_t_value);
  }
  static inline bool SessionStateChangeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SessionStateChangeType* value) {
    return AppInstallReportLogEvent_SessionStateChangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneskyLogFieldNumber = 6,
    kTimestampFieldNumber = 1,
    kStatefulTotalFieldNumber = 3,
    kEventTypeFieldNumber = 2,
    kClouddpsResponseFieldNumber = 5,
    kStatefulFreeFieldNumber = 4,
    kOnlineFieldNumber = 7,
    kSessionStateChangeTypeFieldNumber = 8,
    kAndroidIdFieldNumber = 9,
  };
  // optional string phonesky_log = 6;
  bool has_phonesky_log() const;
  private:
  bool _internal_has_phonesky_log() const;
  public:
  void clear_phonesky_log();
  const std::string& phonesky_log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phonesky_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phonesky_log();
  PROTOBUF_NODISCARD std::string* release_phonesky_log();
  void set_allocated_phonesky_log(std::string* phonesky_log);
  private:
  const std::string& _internal_phonesky_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phonesky_log(const std::string& value);
  std::string* _internal_mutable_phonesky_log();
  public:

  // optional int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int64 stateful_total = 3;
  bool has_stateful_total() const;
  private:
  bool _internal_has_stateful_total() const;
  public:
  void clear_stateful_total();
  int64_t stateful_total() const;
  void set_stateful_total(int64_t value);
  private:
  int64_t _internal_stateful_total() const;
  void _internal_set_stateful_total(int64_t value);
  public:

  // optional .enterprise_management.AppInstallReportLogEvent.EventType event_type = 2;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  ::enterprise_management::AppInstallReportLogEvent_EventType event_type() const;
  void set_event_type(::enterprise_management::AppInstallReportLogEvent_EventType value);
  private:
  ::enterprise_management::AppInstallReportLogEvent_EventType _internal_event_type() const;
  void _internal_set_event_type(::enterprise_management::AppInstallReportLogEvent_EventType value);
  public:

  // optional int32 clouddps_response = 5;
  bool has_clouddps_response() const;
  private:
  bool _internal_has_clouddps_response() const;
  public:
  void clear_clouddps_response();
  int32_t clouddps_response() const;
  void set_clouddps_response(int32_t value);
  private:
  int32_t _internal_clouddps_response() const;
  void _internal_set_clouddps_response(int32_t value);
  public:

  // optional int64 stateful_free = 4;
  bool has_stateful_free() const;
  private:
  bool _internal_has_stateful_free() const;
  public:
  void clear_stateful_free();
  int64_t stateful_free() const;
  void set_stateful_free(int64_t value);
  private:
  int64_t _internal_stateful_free() const;
  void _internal_set_stateful_free(int64_t value);
  public:

  // optional bool online = 7;
  bool has_online() const;
  private:
  bool _internal_has_online() const;
  public:
  void clear_online();
  bool online() const;
  void set_online(bool value);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);
  public:

  // optional .enterprise_management.AppInstallReportLogEvent.SessionStateChangeType session_state_change_type = 8;
  bool has_session_state_change_type() const;
  private:
  bool _internal_has_session_state_change_type() const;
  public:
  void clear_session_state_change_type();
  ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType session_state_change_type() const;
  void set_session_state_change_type(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType value);
  private:
  ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType _internal_session_state_change_type() const;
  void _internal_set_session_state_change_type(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType value);
  public:

  // optional int64 android_id = 9;
  bool has_android_id() const;
  private:
  bool _internal_has_android_id() const;
  public:
  void clear_android_id();
  int64_t android_id() const;
  void set_android_id(int64_t value);
  private:
  int64_t _internal_android_id() const;
  void _internal_set_android_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AppInstallReportLogEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phonesky_log_;
    int64_t timestamp_;
    int64_t stateful_total_;
    int event_type_;
    int32_t clouddps_response_;
    int64_t stateful_free_;
    bool online_;
    int session_state_change_type_;
    int64_t android_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ExtensionInstallReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionInstallReport) */ {
 public:
  inline ExtensionInstallReport() : ExtensionInstallReport(nullptr) {}
  ~ExtensionInstallReport() override;
  explicit PROTOBUF_CONSTEXPR ExtensionInstallReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionInstallReport(const ExtensionInstallReport& from);
  ExtensionInstallReport(ExtensionInstallReport&& from) noexcept
    : ExtensionInstallReport() {
    *this = ::std::move(from);
  }

  inline ExtensionInstallReport& operator=(const ExtensionInstallReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionInstallReport& operator=(ExtensionInstallReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionInstallReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionInstallReport* internal_default_instance() {
    return reinterpret_cast<const ExtensionInstallReport*>(
               &_ExtensionInstallReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(ExtensionInstallReport& a, ExtensionInstallReport& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtensionInstallReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionInstallReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionInstallReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionInstallReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionInstallReport& from);
  void MergeFrom(const ExtensionInstallReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionInstallReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ExtensionInstallReport";
  }
  protected:
  explicit ExtensionInstallReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 3,
    kExtensionIdFieldNumber = 1,
    kIncompleteFieldNumber = 2,
  };
  // repeated .enterprise_management.ExtensionInstallReportLogEvent logs = 3;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::enterprise_management::ExtensionInstallReportLogEvent* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent >*
      mutable_logs();
  private:
  const ::enterprise_management::ExtensionInstallReportLogEvent& _internal_logs(int index) const;
  ::enterprise_management::ExtensionInstallReportLogEvent* _internal_add_logs();
  public:
  const ::enterprise_management::ExtensionInstallReportLogEvent& logs(int index) const;
  ::enterprise_management::ExtensionInstallReportLogEvent* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent >&
      logs() const;

  // optional string extension_id = 1;
  bool has_extension_id() const;
  private:
  bool _internal_has_extension_id() const;
  public:
  void clear_extension_id();
  const std::string& extension_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension_id();
  PROTOBUF_NODISCARD std::string* release_extension_id();
  void set_allocated_extension_id(std::string* extension_id);
  private:
  const std::string& _internal_extension_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_id(const std::string& value);
  std::string* _internal_mutable_extension_id();
  public:

  // optional bool incomplete = 2;
  bool has_incomplete() const;
  private:
  bool _internal_has_incomplete() const;
  public:
  void clear_incomplete();
  bool incomplete() const;
  void set_incomplete(bool value);
  private:
  bool _internal_incomplete() const;
  void _internal_set_incomplete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ExtensionInstallReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent > logs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_id_;
    bool incomplete_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AppInstallReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInstallReport) */ {
 public:
  inline AppInstallReport() : AppInstallReport(nullptr) {}
  ~AppInstallReport() override;
  explicit PROTOBUF_CONSTEXPR AppInstallReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInstallReport(const AppInstallReport& from);
  AppInstallReport(AppInstallReport&& from) noexcept
    : AppInstallReport() {
    *this = ::std::move(from);
  }

  inline AppInstallReport& operator=(const AppInstallReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInstallReport& operator=(AppInstallReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppInstallReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInstallReport* internal_default_instance() {
    return reinterpret_cast<const AppInstallReport*>(
               &_AppInstallReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(AppInstallReport& a, AppInstallReport& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInstallReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInstallReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInstallReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInstallReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AppInstallReport& from);
  void MergeFrom(const AppInstallReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppInstallReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AppInstallReport";
  }
  protected:
  explicit AppInstallReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 3,
    kPackageFieldNumber = 1,
    kIncompleteFieldNumber = 2,
  };
  // repeated .enterprise_management.AppInstallReportLogEvent logs = 3;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::enterprise_management::AppInstallReportLogEvent* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent >*
      mutable_logs();
  private:
  const ::enterprise_management::AppInstallReportLogEvent& _internal_logs(int index) const;
  ::enterprise_management::AppInstallReportLogEvent* _internal_add_logs();
  public:
  const ::enterprise_management::AppInstallReportLogEvent& logs(int index) const;
  ::enterprise_management::AppInstallReportLogEvent* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent >&
      logs() const;

  // optional string package = 1;
  bool has_package() const;
  private:
  bool _internal_has_package() const;
  public:
  void clear_package();
  const std::string& package() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package();
  PROTOBUF_NODISCARD std::string* release_package();
  void set_allocated_package(std::string* package);
  private:
  const std::string& _internal_package() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package(const std::string& value);
  std::string* _internal_mutable_package();
  public:

  // optional bool incomplete = 2;
  bool has_incomplete() const;
  private:
  bool _internal_has_incomplete() const;
  public:
  void clear_incomplete();
  bool incomplete() const;
  void set_incomplete(bool value);
  private:
  bool _internal_incomplete() const;
  void _internal_set_incomplete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AppInstallReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent > logs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_;
    bool incomplete_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AppInstallReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInstallReportRequest) */ {
 public:
  inline AppInstallReportRequest() : AppInstallReportRequest(nullptr) {}
  ~AppInstallReportRequest() override;
  explicit PROTOBUF_CONSTEXPR AppInstallReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInstallReportRequest(const AppInstallReportRequest& from);
  AppInstallReportRequest(AppInstallReportRequest&& from) noexcept
    : AppInstallReportRequest() {
    *this = ::std::move(from);
  }

  inline AppInstallReportRequest& operator=(const AppInstallReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInstallReportRequest& operator=(AppInstallReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppInstallReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInstallReportRequest* internal_default_instance() {
    return reinterpret_cast<const AppInstallReportRequest*>(
               &_AppInstallReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(AppInstallReportRequest& a, AppInstallReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInstallReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInstallReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInstallReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInstallReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AppInstallReportRequest& from);
  void MergeFrom(const AppInstallReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppInstallReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AppInstallReportRequest";
  }
  protected:
  explicit AppInstallReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppInstallReportsFieldNumber = 1,
  };
  // repeated .enterprise_management.AppInstallReport app_install_reports = 1;
  int app_install_reports_size() const;
  private:
  int _internal_app_install_reports_size() const;
  public:
  void clear_app_install_reports();
  ::enterprise_management::AppInstallReport* mutable_app_install_reports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport >*
      mutable_app_install_reports();
  private:
  const ::enterprise_management::AppInstallReport& _internal_app_install_reports(int index) const;
  ::enterprise_management::AppInstallReport* _internal_add_app_install_reports();
  public:
  const ::enterprise_management::AppInstallReport& app_install_reports(int index) const;
  ::enterprise_management::AppInstallReport* add_app_install_reports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport >&
      app_install_reports() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.AppInstallReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport > app_install_reports_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ExtensionInstallReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ExtensionInstallReportRequest) */ {
 public:
  inline ExtensionInstallReportRequest() : ExtensionInstallReportRequest(nullptr) {}
  ~ExtensionInstallReportRequest() override;
  explicit PROTOBUF_CONSTEXPR ExtensionInstallReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionInstallReportRequest(const ExtensionInstallReportRequest& from);
  ExtensionInstallReportRequest(ExtensionInstallReportRequest&& from) noexcept
    : ExtensionInstallReportRequest() {
    *this = ::std::move(from);
  }

  inline ExtensionInstallReportRequest& operator=(const ExtensionInstallReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionInstallReportRequest& operator=(ExtensionInstallReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionInstallReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionInstallReportRequest* internal_default_instance() {
    return reinterpret_cast<const ExtensionInstallReportRequest*>(
               &_ExtensionInstallReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(ExtensionInstallReportRequest& a, ExtensionInstallReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtensionInstallReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionInstallReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionInstallReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionInstallReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionInstallReportRequest& from);
  void MergeFrom(const ExtensionInstallReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionInstallReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ExtensionInstallReportRequest";
  }
  protected:
  explicit ExtensionInstallReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionInstallReportsFieldNumber = 1,
  };
  // repeated .enterprise_management.ExtensionInstallReport extension_install_reports = 1;
  int extension_install_reports_size() const;
  private:
  int _internal_extension_install_reports_size() const;
  public:
  void clear_extension_install_reports();
  ::enterprise_management::ExtensionInstallReport* mutable_extension_install_reports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport >*
      mutable_extension_install_reports();
  private:
  const ::enterprise_management::ExtensionInstallReport& _internal_extension_install_reports(int index) const;
  ::enterprise_management::ExtensionInstallReport* _internal_add_extension_install_reports();
  public:
  const ::enterprise_management::ExtensionInstallReport& extension_install_reports(int index) const;
  ::enterprise_management::ExtensionInstallReport* add_extension_install_reports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport >&
      extension_install_reports() const;

  // @@protoc_insertion_point(class_scope:enterprise_management.ExtensionInstallReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport > extension_install_reports_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AppInstallReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppInstallReportResponse) */ {
 public:
  inline AppInstallReportResponse() : AppInstallReportResponse(nullptr) {}
  ~AppInstallReportResponse() override;
  explicit PROTOBUF_CONSTEXPR AppInstallReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInstallReportResponse(const AppInstallReportResponse& from);
  AppInstallReportResponse(AppInstallReportResponse&& from) noexcept
    : AppInstallReportResponse() {
    *this = ::std::move(from);
  }

  inline AppInstallReportResponse& operator=(const AppInstallReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInstallReportResponse& operator=(AppInstallReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppInstallReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInstallReportResponse* internal_default_instance() {
    return reinterpret_cast<const AppInstallReportResponse*>(
               &_AppInstallReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(AppInstallReportResponse& a, AppInstallReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInstallReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInstallReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInstallReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInstallReportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AppInstallReportResponse& from);
  void MergeFrom(const AppInstallReportResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppInstallReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AppInstallReportResponse";
  }
  protected:
  explicit AppInstallReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.AppInstallReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class RefreshAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RefreshAccountRequest) */ {
 public:
  inline RefreshAccountRequest() : RefreshAccountRequest(nullptr) {}
  ~RefreshAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR RefreshAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshAccountRequest(const RefreshAccountRequest& from);
  RefreshAccountRequest(RefreshAccountRequest&& from) noexcept
    : RefreshAccountRequest() {
    *this = ::std::move(from);
  }

  inline RefreshAccountRequest& operator=(const RefreshAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshAccountRequest& operator=(RefreshAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RefreshAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshAccountRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshAccountRequest*>(
               &_RefreshAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(RefreshAccountRequest& a, RefreshAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshAccountRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RefreshAccountRequest& from);
  void MergeFrom(const RefreshAccountRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RefreshAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RefreshAccountRequest";
  }
  protected:
  explicit RefreshAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RefreshAccountRequest_AccountType AccountType;
  static constexpr AccountType ACCOUNT_TYPE_UNSPECIFIED =
    RefreshAccountRequest_AccountType_ACCOUNT_TYPE_UNSPECIFIED;
  static constexpr AccountType CHROME_OS_DEMO_MODE =
    RefreshAccountRequest_AccountType_CHROME_OS_DEMO_MODE;
  static inline bool AccountType_IsValid(int value) {
    return RefreshAccountRequest_AccountType_IsValid(value);
  }
  static constexpr AccountType AccountType_MIN =
    RefreshAccountRequest_AccountType_AccountType_MIN;
  static constexpr AccountType AccountType_MAX =
    RefreshAccountRequest_AccountType_AccountType_MAX;
  static constexpr int AccountType_ARRAYSIZE =
    RefreshAccountRequest_AccountType_AccountType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AccountType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AccountType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AccountType_Name.");
    return RefreshAccountRequest_AccountType_Name(enum_t_value);
  }
  static inline bool AccountType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AccountType* value) {
    return RefreshAccountRequest_AccountType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAccountTypeFieldNumber = 1,
  };
  // optional .enterprise_management.RefreshAccountRequest.AccountType account_type = 1;
  bool has_account_type() const;
  private:
  bool _internal_has_account_type() const;
  public:
  void clear_account_type();
  ::enterprise_management::RefreshAccountRequest_AccountType account_type() const;
  void set_account_type(::enterprise_management::RefreshAccountRequest_AccountType value);
  private:
  ::enterprise_management::RefreshAccountRequest_AccountType _internal_account_type() const;
  void _internal_set_account_type(::enterprise_management::RefreshAccountRequest_AccountType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.RefreshAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int account_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class RefreshAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RefreshAccountResponse) */ {
 public:
  inline RefreshAccountResponse() : RefreshAccountResponse(nullptr) {}
  ~RefreshAccountResponse() override;
  explicit PROTOBUF_CONSTEXPR RefreshAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshAccountResponse(const RefreshAccountResponse& from);
  RefreshAccountResponse(RefreshAccountResponse&& from) noexcept
    : RefreshAccountResponse() {
    *this = ::std::move(from);
  }

  inline RefreshAccountResponse& operator=(const RefreshAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshAccountResponse& operator=(RefreshAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RefreshAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshAccountResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshAccountResponse*>(
               &_RefreshAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(RefreshAccountResponse& a, RefreshAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshAccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshAccountResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RefreshAccountResponse& from);
  void MergeFrom(const RefreshAccountResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RefreshAccountResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RefreshAccountResponse";
  }
  protected:
  explicit RefreshAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.RefreshAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class RsuLookupKeyUploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RsuLookupKeyUploadRequest) */ {
 public:
  inline RsuLookupKeyUploadRequest() : RsuLookupKeyUploadRequest(nullptr) {}
  ~RsuLookupKeyUploadRequest() override;
  explicit PROTOBUF_CONSTEXPR RsuLookupKeyUploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RsuLookupKeyUploadRequest(const RsuLookupKeyUploadRequest& from);
  RsuLookupKeyUploadRequest(RsuLookupKeyUploadRequest&& from) noexcept
    : RsuLookupKeyUploadRequest() {
    *this = ::std::move(from);
  }

  inline RsuLookupKeyUploadRequest& operator=(const RsuLookupKeyUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RsuLookupKeyUploadRequest& operator=(RsuLookupKeyUploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RsuLookupKeyUploadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RsuLookupKeyUploadRequest* internal_default_instance() {
    return reinterpret_cast<const RsuLookupKeyUploadRequest*>(
               &_RsuLookupKeyUploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(RsuLookupKeyUploadRequest& a, RsuLookupKeyUploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RsuLookupKeyUploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RsuLookupKeyUploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RsuLookupKeyUploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RsuLookupKeyUploadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RsuLookupKeyUploadRequest& from);
  void MergeFrom(const RsuLookupKeyUploadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RsuLookupKeyUploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RsuLookupKeyUploadRequest";
  }
  protected:
  explicit RsuLookupKeyUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoardIdFieldNumber = 1,
    kCr50HashedDeviceIdFieldNumber = 2,
  };
  // optional bytes board_id = 1;
  bool has_board_id() const;
  private:
  bool _internal_has_board_id() const;
  public:
  void clear_board_id();
  const std::string& board_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_board_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_board_id();
  PROTOBUF_NODISCARD std::string* release_board_id();
  void set_allocated_board_id(std::string* board_id);
  private:
  const std::string& _internal_board_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_board_id(const std::string& value);
  std::string* _internal_mutable_board_id();
  public:

  // optional bytes cr50_hashed_device_id = 2;
  bool has_cr50_hashed_device_id() const;
  private:
  bool _internal_has_cr50_hashed_device_id() const;
  public:
  void clear_cr50_hashed_device_id();
  const std::string& cr50_hashed_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cr50_hashed_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cr50_hashed_device_id();
  PROTOBUF_NODISCARD std::string* release_cr50_hashed_device_id();
  void set_allocated_cr50_hashed_device_id(std::string* cr50_hashed_device_id);
  private:
  const std::string& _internal_cr50_hashed_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cr50_hashed_device_id(const std::string& value);
  std::string* _internal_mutable_cr50_hashed_device_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.RsuLookupKeyUploadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr board_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cr50_hashed_device_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class RsuLookupKeyUploadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.RsuLookupKeyUploadResponse) */ {
 public:
  inline RsuLookupKeyUploadResponse() : RsuLookupKeyUploadResponse(nullptr) {}
  ~RsuLookupKeyUploadResponse() override;
  explicit PROTOBUF_CONSTEXPR RsuLookupKeyUploadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RsuLookupKeyUploadResponse(const RsuLookupKeyUploadResponse& from);
  RsuLookupKeyUploadResponse(RsuLookupKeyUploadResponse&& from) noexcept
    : RsuLookupKeyUploadResponse() {
    *this = ::std::move(from);
  }

  inline RsuLookupKeyUploadResponse& operator=(const RsuLookupKeyUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RsuLookupKeyUploadResponse& operator=(RsuLookupKeyUploadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RsuLookupKeyUploadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RsuLookupKeyUploadResponse* internal_default_instance() {
    return reinterpret_cast<const RsuLookupKeyUploadResponse*>(
               &_RsuLookupKeyUploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(RsuLookupKeyUploadResponse& a, RsuLookupKeyUploadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RsuLookupKeyUploadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RsuLookupKeyUploadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RsuLookupKeyUploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RsuLookupKeyUploadResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RsuLookupKeyUploadResponse& from);
  void MergeFrom(const RsuLookupKeyUploadResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RsuLookupKeyUploadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.RsuLookupKeyUploadResponse";
  }
  protected:
  explicit RsuLookupKeyUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRsuLookupKeyUpdatedFieldNumber = 1,
  };
  // optional bool rsu_lookup_key_updated = 1;
  bool has_rsu_lookup_key_updated() const;
  private:
  bool _internal_has_rsu_lookup_key_updated() const;
  public:
  void clear_rsu_lookup_key_updated();
  bool rsu_lookup_key_updated() const;
  void set_rsu_lookup_key_updated(bool value);
  private:
  bool _internal_rsu_lookup_key_updated() const;
  void _internal_set_rsu_lookup_key_updated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.RsuLookupKeyUploadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool rsu_lookup_key_updated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ESimProfileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ESimProfileInfo) */ {
 public:
  inline ESimProfileInfo() : ESimProfileInfo(nullptr) {}
  ~ESimProfileInfo() override;
  explicit PROTOBUF_CONSTEXPR ESimProfileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESimProfileInfo(const ESimProfileInfo& from);
  ESimProfileInfo(ESimProfileInfo&& from) noexcept
    : ESimProfileInfo() {
    *this = ::std::move(from);
  }

  inline ESimProfileInfo& operator=(const ESimProfileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESimProfileInfo& operator=(ESimProfileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ESimProfileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESimProfileInfo* internal_default_instance() {
    return reinterpret_cast<const ESimProfileInfo*>(
               &_ESimProfileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(ESimProfileInfo& a, ESimProfileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ESimProfileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESimProfileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESimProfileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESimProfileInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ESimProfileInfo& from);
  void MergeFrom(const ESimProfileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ESimProfileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ESimProfileInfo";
  }
  protected:
  explicit ESimProfileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIccidFieldNumber = 1,
    kSmdpAddressFieldNumber = 2,
  };
  // optional string iccid = 1;
  bool has_iccid() const;
  private:
  bool _internal_has_iccid() const;
  public:
  void clear_iccid();
  const std::string& iccid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iccid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iccid();
  PROTOBUF_NODISCARD std::string* release_iccid();
  void set_allocated_iccid(std::string* iccid);
  private:
  const std::string& _internal_iccid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iccid(const std::string& value);
  std::string* _internal_mutable_iccid();
  public:

  // optional string smdp_address = 2;
  bool has_smdp_address() const;
  private:
  bool _internal_has_smdp_address() const;
  public:
  void clear_smdp_address();
  const std::string& smdp_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smdp_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smdp_address();
  PROTOBUF_NODISCARD std::string* release_smdp_address();
  void set_allocated_smdp_address(std::string* smdp_address);
  private:
  const std::string& _internal_smdp_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smdp_address(const std::string& value);
  std::string* _internal_mutable_smdp_address();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ESimProfileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iccid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smdp_address_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class UploadEuiccInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UploadEuiccInfoRequest) */ {
 public:
  inline UploadEuiccInfoRequest() : UploadEuiccInfoRequest(nullptr) {}
  ~UploadEuiccInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadEuiccInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadEuiccInfoRequest(const UploadEuiccInfoRequest& from);
  UploadEuiccInfoRequest(UploadEuiccInfoRequest&& from) noexcept
    : UploadEuiccInfoRequest() {
    *this = ::std::move(from);
  }

  inline UploadEuiccInfoRequest& operator=(const UploadEuiccInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadEuiccInfoRequest& operator=(UploadEuiccInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UploadEuiccInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadEuiccInfoRequest* internal_default_instance() {
    return reinterpret_cast<const UploadEuiccInfoRequest*>(
               &_UploadEuiccInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(UploadEuiccInfoRequest& a, UploadEuiccInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadEuiccInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadEuiccInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadEuiccInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadEuiccInfoRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UploadEuiccInfoRequest& from);
  void MergeFrom(const UploadEuiccInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadEuiccInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UploadEuiccInfoRequest";
  }
  protected:
  explicit UploadEuiccInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEsimProfilesFieldNumber = 2,
    kEuiccCountFieldNumber = 1,
    kClearProfileListFieldNumber = 3,
  };
  // repeated .enterprise_management.ESimProfileInfo esim_profiles = 2;
  int esim_profiles_size() const;
  private:
  int _internal_esim_profiles_size() const;
  public:
  void clear_esim_profiles();
  ::enterprise_management::ESimProfileInfo* mutable_esim_profiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ESimProfileInfo >*
      mutable_esim_profiles();
  private:
  const ::enterprise_management::ESimProfileInfo& _internal_esim_profiles(int index) const;
  ::enterprise_management::ESimProfileInfo* _internal_add_esim_profiles();
  public:
  const ::enterprise_management::ESimProfileInfo& esim_profiles(int index) const;
  ::enterprise_management::ESimProfileInfo* add_esim_profiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ESimProfileInfo >&
      esim_profiles() const;

  // optional uint32 euicc_count = 1;
  bool has_euicc_count() const;
  private:
  bool _internal_has_euicc_count() const;
  public:
  void clear_euicc_count();
  uint32_t euicc_count() const;
  void set_euicc_count(uint32_t value);
  private:
  uint32_t _internal_euicc_count() const;
  void _internal_set_euicc_count(uint32_t value);
  public:

  // optional bool clear_profile_list = 3;
  bool has_clear_profile_list() const;
  private:
  bool _internal_has_clear_profile_list() const;
  public:
  void clear_clear_profile_list();
  bool clear_profile_list() const;
  void set_clear_profile_list(bool value);
  private:
  bool _internal_clear_profile_list() const;
  void _internal_set_clear_profile_list(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.UploadEuiccInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ESimProfileInfo > esim_profiles_;
    uint32_t euicc_count_;
    bool clear_profile_list_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class UploadEuiccInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.UploadEuiccInfoResponse) */ {
 public:
  inline UploadEuiccInfoResponse() : UploadEuiccInfoResponse(nullptr) {}
  ~UploadEuiccInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadEuiccInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadEuiccInfoResponse(const UploadEuiccInfoResponse& from);
  UploadEuiccInfoResponse(UploadEuiccInfoResponse&& from) noexcept
    : UploadEuiccInfoResponse() {
    *this = ::std::move(from);
  }

  inline UploadEuiccInfoResponse& operator=(const UploadEuiccInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadEuiccInfoResponse& operator=(UploadEuiccInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UploadEuiccInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadEuiccInfoResponse* internal_default_instance() {
    return reinterpret_cast<const UploadEuiccInfoResponse*>(
               &_UploadEuiccInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    156;

  friend void swap(UploadEuiccInfoResponse& a, UploadEuiccInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadEuiccInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadEuiccInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadEuiccInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadEuiccInfoResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UploadEuiccInfoResponse& from);
  void MergeFrom(const UploadEuiccInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadEuiccInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.UploadEuiccInfoResponse";
  }
  protected:
  explicit UploadEuiccInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.UploadEuiccInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrintJobEvent_PrintJobConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrintJobEvent.PrintJobConfiguration) */ {
 public:
  inline PrintJobEvent_PrintJobConfiguration() : PrintJobEvent_PrintJobConfiguration(nullptr) {}
  ~PrintJobEvent_PrintJobConfiguration() override;
  explicit PROTOBUF_CONSTEXPR PrintJobEvent_PrintJobConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintJobEvent_PrintJobConfiguration(const PrintJobEvent_PrintJobConfiguration& from);
  PrintJobEvent_PrintJobConfiguration(PrintJobEvent_PrintJobConfiguration&& from) noexcept
    : PrintJobEvent_PrintJobConfiguration() {
    *this = ::std::move(from);
  }

  inline PrintJobEvent_PrintJobConfiguration& operator=(const PrintJobEvent_PrintJobConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintJobEvent_PrintJobConfiguration& operator=(PrintJobEvent_PrintJobConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrintJobEvent_PrintJobConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintJobEvent_PrintJobConfiguration* internal_default_instance() {
    return reinterpret_cast<const PrintJobEvent_PrintJobConfiguration*>(
               &_PrintJobEvent_PrintJobConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    157;

  friend void swap(PrintJobEvent_PrintJobConfiguration& a, PrintJobEvent_PrintJobConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintJobEvent_PrintJobConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintJobEvent_PrintJobConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintJobEvent_PrintJobConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintJobEvent_PrintJobConfiguration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrintJobEvent_PrintJobConfiguration& from);
  void MergeFrom(const PrintJobEvent_PrintJobConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrintJobEvent_PrintJobConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrintJobEvent.PrintJobConfiguration";
  }
  protected:
  explicit PrintJobEvent_PrintJobConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kSettingsFieldNumber = 7,
    kCreationTimestampMsFieldNumber = 4,
    kStatusFieldNumber = 3,
    kNumberOfPagesFieldNumber = 6,
    kCompletionTimestampMsFieldNumber = 5,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional .enterprise_management.PrintJobEvent.PrintSettings settings = 7;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::enterprise_management::PrintJobEvent_PrintSettings& settings() const;
  PROTOBUF_NODISCARD ::enterprise_management::PrintJobEvent_PrintSettings* release_settings();
  ::enterprise_management::PrintJobEvent_PrintSettings* mutable_settings();
  void set_allocated_settings(::enterprise_management::PrintJobEvent_PrintSettings* settings);
  private:
  const ::enterprise_management::PrintJobEvent_PrintSettings& _internal_settings() const;
  ::enterprise_management::PrintJobEvent_PrintSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::enterprise_management::PrintJobEvent_PrintSettings* settings);
  ::enterprise_management::PrintJobEvent_PrintSettings* unsafe_arena_release_settings();

  // optional int64 creation_timestamp_ms = 4;
  bool has_creation_timestamp_ms() const;
  private:
  bool _internal_has_creation_timestamp_ms() const;
  public:
  void clear_creation_timestamp_ms();
  int64_t creation_timestamp_ms() const;
  void set_creation_timestamp_ms(int64_t value);
  private:
  int64_t _internal_creation_timestamp_ms() const;
  void _internal_set_creation_timestamp_ms(int64_t value);
  public:

  // optional int32 status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // optional int32 number_of_pages = 6;
  bool has_number_of_pages() const;
  private:
  bool _internal_has_number_of_pages() const;
  public:
  void clear_number_of_pages();
  int32_t number_of_pages() const;
  void set_number_of_pages(int32_t value);
  private:
  int32_t _internal_number_of_pages() const;
  void _internal_set_number_of_pages(int32_t value);
  public:

  // optional int64 completion_timestamp_ms = 5;
  bool has_completion_timestamp_ms() const;
  private:
  bool _internal_has_completion_timestamp_ms() const;
  public:
  void clear_completion_timestamp_ms();
  int64_t completion_timestamp_ms() const;
  void set_completion_timestamp_ms(int64_t value);
  private:
  int64_t _internal_completion_timestamp_ms() const;
  void _internal_set_completion_timestamp_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PrintJobEvent.PrintJobConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::enterprise_management::PrintJobEvent_PrintSettings* settings_;
    int64_t creation_timestamp_ms_;
    int32_t status_;
    int32_t number_of_pages_;
    int64_t completion_timestamp_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrintJobEvent_Printer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrintJobEvent.Printer) */ {
 public:
  inline PrintJobEvent_Printer() : PrintJobEvent_Printer(nullptr) {}
  ~PrintJobEvent_Printer() override;
  explicit PROTOBUF_CONSTEXPR PrintJobEvent_Printer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintJobEvent_Printer(const PrintJobEvent_Printer& from);
  PrintJobEvent_Printer(PrintJobEvent_Printer&& from) noexcept
    : PrintJobEvent_Printer() {
    *this = ::std::move(from);
  }

  inline PrintJobEvent_Printer& operator=(const PrintJobEvent_Printer& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintJobEvent_Printer& operator=(PrintJobEvent_Printer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrintJobEvent_Printer& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintJobEvent_Printer* internal_default_instance() {
    return reinterpret_cast<const PrintJobEvent_Printer*>(
               &_PrintJobEvent_Printer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    158;

  friend void swap(PrintJobEvent_Printer& a, PrintJobEvent_Printer& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintJobEvent_Printer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintJobEvent_Printer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintJobEvent_Printer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintJobEvent_Printer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrintJobEvent_Printer& from);
  void MergeFrom(const PrintJobEvent_Printer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrintJobEvent_Printer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrintJobEvent.Printer";
  }
  protected:
  explicit PrintJobEvent_Printer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUriFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string uri = 2;
  bool has_uri() const;
  private:
  bool _internal_has_uri() const;
  public:
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // optional string id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PrintJobEvent.Printer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrintJobEvent_PrintSettings_MediaSize final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrintJobEvent.PrintSettings.MediaSize) */ {
 public:
  inline PrintJobEvent_PrintSettings_MediaSize() : PrintJobEvent_PrintSettings_MediaSize(nullptr) {}
  ~PrintJobEvent_PrintSettings_MediaSize() override;
  explicit PROTOBUF_CONSTEXPR PrintJobEvent_PrintSettings_MediaSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintJobEvent_PrintSettings_MediaSize(const PrintJobEvent_PrintSettings_MediaSize& from);
  PrintJobEvent_PrintSettings_MediaSize(PrintJobEvent_PrintSettings_MediaSize&& from) noexcept
    : PrintJobEvent_PrintSettings_MediaSize() {
    *this = ::std::move(from);
  }

  inline PrintJobEvent_PrintSettings_MediaSize& operator=(const PrintJobEvent_PrintSettings_MediaSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintJobEvent_PrintSettings_MediaSize& operator=(PrintJobEvent_PrintSettings_MediaSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrintJobEvent_PrintSettings_MediaSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintJobEvent_PrintSettings_MediaSize* internal_default_instance() {
    return reinterpret_cast<const PrintJobEvent_PrintSettings_MediaSize*>(
               &_PrintJobEvent_PrintSettings_MediaSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    159;

  friend void swap(PrintJobEvent_PrintSettings_MediaSize& a, PrintJobEvent_PrintSettings_MediaSize& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintJobEvent_PrintSettings_MediaSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintJobEvent_PrintSettings_MediaSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintJobEvent_PrintSettings_MediaSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintJobEvent_PrintSettings_MediaSize>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrintJobEvent_PrintSettings_MediaSize& from);
  void MergeFrom(const PrintJobEvent_PrintSettings_MediaSize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrintJobEvent_PrintSettings_MediaSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrintJobEvent.PrintSettings.MediaSize";
  }
  protected:
  explicit PrintJobEvent_PrintSettings_MediaSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorIdFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional string vendor_id = 3;
  bool has_vendor_id() const;
  private:
  bool _internal_has_vendor_id() const;
  public:
  void clear_vendor_id();
  const std::string& vendor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor_id();
  PROTOBUF_NODISCARD std::string* release_vendor_id();
  void set_allocated_vendor_id(std::string* vendor_id);
  private:
  const std::string& _internal_vendor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_id(const std::string& value);
  std::string* _internal_mutable_vendor_id();
  public:

  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_id_;
    int32_t width_;
    int32_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrintJobEvent_PrintSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrintJobEvent.PrintSettings) */ {
 public:
  inline PrintJobEvent_PrintSettings() : PrintJobEvent_PrintSettings(nullptr) {}
  ~PrintJobEvent_PrintSettings() override;
  explicit PROTOBUF_CONSTEXPR PrintJobEvent_PrintSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintJobEvent_PrintSettings(const PrintJobEvent_PrintSettings& from);
  PrintJobEvent_PrintSettings(PrintJobEvent_PrintSettings&& from) noexcept
    : PrintJobEvent_PrintSettings() {
    *this = ::std::move(from);
  }

  inline PrintJobEvent_PrintSettings& operator=(const PrintJobEvent_PrintSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintJobEvent_PrintSettings& operator=(PrintJobEvent_PrintSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrintJobEvent_PrintSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintJobEvent_PrintSettings* internal_default_instance() {
    return reinterpret_cast<const PrintJobEvent_PrintSettings*>(
               &_PrintJobEvent_PrintSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    160;

  friend void swap(PrintJobEvent_PrintSettings& a, PrintJobEvent_PrintSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintJobEvent_PrintSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintJobEvent_PrintSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintJobEvent_PrintSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintJobEvent_PrintSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrintJobEvent_PrintSettings& from);
  void MergeFrom(const PrintJobEvent_PrintSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrintJobEvent_PrintSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrintJobEvent.PrintSettings";
  }
  protected:
  explicit PrintJobEvent_PrintSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PrintJobEvent_PrintSettings_MediaSize MediaSize;

  typedef PrintJobEvent_PrintSettings_ColorMode ColorMode;
  static constexpr ColorMode UNKNOWN_COLOR_MODE =
    PrintJobEvent_PrintSettings_ColorMode_UNKNOWN_COLOR_MODE;
  static constexpr ColorMode BLACK_AND_WHITE =
    PrintJobEvent_PrintSettings_ColorMode_BLACK_AND_WHITE;
  static constexpr ColorMode COLOR =
    PrintJobEvent_PrintSettings_ColorMode_COLOR;
  static inline bool ColorMode_IsValid(int value) {
    return PrintJobEvent_PrintSettings_ColorMode_IsValid(value);
  }
  static constexpr ColorMode ColorMode_MIN =
    PrintJobEvent_PrintSettings_ColorMode_ColorMode_MIN;
  static constexpr ColorMode ColorMode_MAX =
    PrintJobEvent_PrintSettings_ColorMode_ColorMode_MAX;
  static constexpr int ColorMode_ARRAYSIZE =
    PrintJobEvent_PrintSettings_ColorMode_ColorMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ColorMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ColorMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ColorMode_Name.");
    return PrintJobEvent_PrintSettings_ColorMode_Name(enum_t_value);
  }
  static inline bool ColorMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ColorMode* value) {
    return PrintJobEvent_PrintSettings_ColorMode_Parse(name, value);
  }

  typedef PrintJobEvent_PrintSettings_DuplexMode DuplexMode;
  static constexpr DuplexMode UNKNOWN_DUPLEX_MODE =
    PrintJobEvent_PrintSettings_DuplexMode_UNKNOWN_DUPLEX_MODE;
  static constexpr DuplexMode ONE_SIDED =
    PrintJobEvent_PrintSettings_DuplexMode_ONE_SIDED;
  static constexpr DuplexMode TWO_SIDED_LONG_EDGE =
    PrintJobEvent_PrintSettings_DuplexMode_TWO_SIDED_LONG_EDGE;
  static constexpr DuplexMode TWO_SIDED_SHORT_EDGE =
    PrintJobEvent_PrintSettings_DuplexMode_TWO_SIDED_SHORT_EDGE;
  static inline bool DuplexMode_IsValid(int value) {
    return PrintJobEvent_PrintSettings_DuplexMode_IsValid(value);
  }
  static constexpr DuplexMode DuplexMode_MIN =
    PrintJobEvent_PrintSettings_DuplexMode_DuplexMode_MIN;
  static constexpr DuplexMode DuplexMode_MAX =
    PrintJobEvent_PrintSettings_DuplexMode_DuplexMode_MAX;
  static constexpr int DuplexMode_ARRAYSIZE =
    PrintJobEvent_PrintSettings_DuplexMode_DuplexMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DuplexMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DuplexMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DuplexMode_Name.");
    return PrintJobEvent_PrintSettings_DuplexMode_Name(enum_t_value);
  }
  static inline bool DuplexMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DuplexMode* value) {
    return PrintJobEvent_PrintSettings_DuplexMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMediaSizeFieldNumber = 3,
    kColorFieldNumber = 1,
    kDuplexFieldNumber = 2,
    kCopiesFieldNumber = 4,
  };
  // optional .enterprise_management.PrintJobEvent.PrintSettings.MediaSize media_size = 3;
  bool has_media_size() const;
  private:
  bool _internal_has_media_size() const;
  public:
  void clear_media_size();
  const ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize& media_size() const;
  PROTOBUF_NODISCARD ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* release_media_size();
  ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* mutable_media_size();
  void set_allocated_media_size(::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* media_size);
  private:
  const ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize& _internal_media_size() const;
  ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* _internal_mutable_media_size();
  public:
  void unsafe_arena_set_allocated_media_size(
      ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* media_size);
  ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* unsafe_arena_release_media_size();

  // optional .enterprise_management.PrintJobEvent.PrintSettings.ColorMode color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::enterprise_management::PrintJobEvent_PrintSettings_ColorMode color() const;
  void set_color(::enterprise_management::PrintJobEvent_PrintSettings_ColorMode value);
  private:
  ::enterprise_management::PrintJobEvent_PrintSettings_ColorMode _internal_color() const;
  void _internal_set_color(::enterprise_management::PrintJobEvent_PrintSettings_ColorMode value);
  public:

  // optional .enterprise_management.PrintJobEvent.PrintSettings.DuplexMode duplex = 2;
  bool has_duplex() const;
  private:
  bool _internal_has_duplex() const;
  public:
  void clear_duplex();
  ::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode duplex() const;
  void set_duplex(::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode value);
  private:
  ::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode _internal_duplex() const;
  void _internal_set_duplex(::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode value);
  public:

  // optional int32 copies = 4;
  bool has_copies() const;
  private:
  bool _internal_has_copies() const;
  public:
  void clear_copies();
  int32_t copies() const;
  void set_copies(int32_t value);
  private:
  int32_t _internal_copies() const;
  void _internal_set_copies(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PrintJobEvent.PrintSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* media_size_;
    int color_;
    int duplex_;
    int32_t copies_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class PrintJobEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.PrintJobEvent) */ {
 public:
  inline PrintJobEvent() : PrintJobEvent(nullptr) {}
  ~PrintJobEvent() override;
  explicit PROTOBUF_CONSTEXPR PrintJobEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintJobEvent(const PrintJobEvent& from);
  PrintJobEvent(PrintJobEvent&& from) noexcept
    : PrintJobEvent() {
    *this = ::std::move(from);
  }

  inline PrintJobEvent& operator=(const PrintJobEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintJobEvent& operator=(PrintJobEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PrintJobEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintJobEvent* internal_default_instance() {
    return reinterpret_cast<const PrintJobEvent*>(
               &_PrintJobEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    161;

  friend void swap(PrintJobEvent& a, PrintJobEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintJobEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintJobEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintJobEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintJobEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PrintJobEvent& from);
  void MergeFrom(const PrintJobEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrintJobEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.PrintJobEvent";
  }
  protected:
  explicit PrintJobEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PrintJobEvent_PrintJobConfiguration PrintJobConfiguration;
  typedef PrintJobEvent_Printer Printer;
  typedef PrintJobEvent_PrintSettings PrintSettings;

  typedef PrintJobEvent_UserType UserType;
  static constexpr UserType UNKNOWN_USER_TYPE =
    PrintJobEvent_UserType_UNKNOWN_USER_TYPE;
  static constexpr UserType REGULAR =
    PrintJobEvent_UserType_REGULAR;
  static constexpr UserType GUEST =
    PrintJobEvent_UserType_GUEST;
  static constexpr UserType KIOSK =
    PrintJobEvent_UserType_KIOSK;
  static inline bool UserType_IsValid(int value) {
    return PrintJobEvent_UserType_IsValid(value);
  }
  static constexpr UserType UserType_MIN =
    PrintJobEvent_UserType_UserType_MIN;
  static constexpr UserType UserType_MAX =
    PrintJobEvent_UserType_UserType_MAX;
  static constexpr int UserType_ARRAYSIZE =
    PrintJobEvent_UserType_UserType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& UserType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UserType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UserType_Name.");
    return PrintJobEvent_UserType_Name(enum_t_value);
  }
  static inline bool UserType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UserType* value) {
    return PrintJobEvent_UserType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJobConfigurationFieldNumber = 1,
    kPrinterFieldNumber = 3,
    kUserTypeFieldNumber = 2,
  };
  // optional .enterprise_management.PrintJobEvent.PrintJobConfiguration job_configuration = 1;
  bool has_job_configuration() const;
  private:
  bool _internal_has_job_configuration() const;
  public:
  void clear_job_configuration();
  const ::enterprise_management::PrintJobEvent_PrintJobConfiguration& job_configuration() const;
  PROTOBUF_NODISCARD ::enterprise_management::PrintJobEvent_PrintJobConfiguration* release_job_configuration();
  ::enterprise_management::PrintJobEvent_PrintJobConfiguration* mutable_job_configuration();
  void set_allocated_job_configuration(::enterprise_management::PrintJobEvent_PrintJobConfiguration* job_configuration);
  private:
  const ::enterprise_management::PrintJobEvent_PrintJobConfiguration& _internal_job_configuration() const;
  ::enterprise_management::PrintJobEvent_PrintJobConfiguration* _internal_mutable_job_configuration();
  public:
  void unsafe_arena_set_allocated_job_configuration(
      ::enterprise_management::PrintJobEvent_PrintJobConfiguration* job_configuration);
  ::enterprise_management::PrintJobEvent_PrintJobConfiguration* unsafe_arena_release_job_configuration();

  // optional .enterprise_management.PrintJobEvent.Printer printer = 3;
  bool has_printer() const;
  private:
  bool _internal_has_printer() const;
  public:
  void clear_printer();
  const ::enterprise_management::PrintJobEvent_Printer& printer() const;
  PROTOBUF_NODISCARD ::enterprise_management::PrintJobEvent_Printer* release_printer();
  ::enterprise_management::PrintJobEvent_Printer* mutable_printer();
  void set_allocated_printer(::enterprise_management::PrintJobEvent_Printer* printer);
  private:
  const ::enterprise_management::PrintJobEvent_Printer& _internal_printer() const;
  ::enterprise_management::PrintJobEvent_Printer* _internal_mutable_printer();
  public:
  void unsafe_arena_set_allocated_printer(
      ::enterprise_management::PrintJobEvent_Printer* printer);
  ::enterprise_management::PrintJobEvent_Printer* unsafe_arena_release_printer();

  // optional .enterprise_management.PrintJobEvent.UserType user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  ::enterprise_management::PrintJobEvent_UserType user_type() const;
  void set_user_type(::enterprise_management::PrintJobEvent_UserType value);
  private:
  ::enterprise_management::PrintJobEvent_UserType _internal_user_type() const;
  void _internal_set_user_type(::enterprise_management::PrintJobEvent_UserType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.PrintJobEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::PrintJobEvent_PrintJobConfiguration* job_configuration_;
    ::enterprise_management::PrintJobEvent_Printer* printer_;
    int user_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class App final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.App) */ {
 public:
  inline App() : App(nullptr) {}
  ~App() override;
  explicit PROTOBUF_CONSTEXPR App(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  App(const App& from);
  App(App&& from) noexcept
    : App() {
    *this = ::std::move(from);
  }

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  inline App& operator=(App&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const App& default_instance() {
    return *internal_default_instance();
  }
  static inline const App* internal_default_instance() {
    return reinterpret_cast<const App*>(
               &_App_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    162;

  friend void swap(App& a, App& b) {
    a.Swap(&b);
  }
  inline void Swap(App* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  App* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<App>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const App& from);
  void MergeFrom(const App& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(App* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.App";
  }
  protected:
  explicit App(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef App_AppType AppType;
  static constexpr AppType UNKNOWN =
    App_AppType_UNKNOWN;
  static constexpr AppType ARC =
    App_AppType_ARC;
  static constexpr AppType BUILT_IN =
    App_AppType_BUILT_IN;
  static constexpr AppType CROSTINI =
    App_AppType_CROSTINI;
  static constexpr AppType EXTENSION =
    App_AppType_EXTENSION;
  static constexpr AppType WEB =
    App_AppType_WEB;
  static constexpr AppType PLUGIN_VM =
    App_AppType_PLUGIN_VM;
  static constexpr AppType BOREALIS =
    App_AppType_BOREALIS;
  static constexpr AppType BRUSCHETTA =
    App_AppType_BRUSCHETTA;
  static inline bool AppType_IsValid(int value) {
    return App_AppType_IsValid(value);
  }
  static constexpr AppType AppType_MIN =
    App_AppType_AppType_MIN;
  static constexpr AppType AppType_MAX =
    App_AppType_AppType_MAX;
  static constexpr int AppType_ARRAYSIZE =
    App_AppType_AppType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AppType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AppType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AppType_Name.");
    return App_AppType_Name(enum_t_value);
  }
  static inline bool AppType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AppType* value) {
    return App_AppType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalAppIdFieldNumber = 3,
    kAppIdFieldNumber = 1,
    kAppTypeFieldNumber = 2,
  };
  // repeated string additional_app_id = 3;
  int additional_app_id_size() const;
  private:
  int _internal_additional_app_id_size() const;
  public:
  void clear_additional_app_id();
  const std::string& additional_app_id(int index) const;
  std::string* mutable_additional_app_id(int index);
  void set_additional_app_id(int index, const std::string& value);
  void set_additional_app_id(int index, std::string&& value);
  void set_additional_app_id(int index, const char* value);
  void set_additional_app_id(int index, const char* value, size_t size);
  std::string* add_additional_app_id();
  void add_additional_app_id(const std::string& value);
  void add_additional_app_id(std::string&& value);
  void add_additional_app_id(const char* value);
  void add_additional_app_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& additional_app_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_additional_app_id();
  private:
  const std::string& _internal_additional_app_id(int index) const;
  std::string* _internal_add_additional_app_id();
  public:

  // optional string app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // optional .enterprise_management.App.AppType app_type = 2;
  bool has_app_type() const;
  private:
  bool _internal_has_app_type() const;
  public:
  void clear_app_type();
  ::enterprise_management::App_AppType app_type() const;
  void set_app_type(::enterprise_management::App_AppType value);
  private:
  ::enterprise_management::App_AppType _internal_app_type() const;
  void _internal_set_app_type(::enterprise_management::App_AppType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.App)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> additional_app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    int app_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class AppActivity final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.AppActivity) */ {
 public:
  inline AppActivity() : AppActivity(nullptr) {}
  ~AppActivity() override;
  explicit PROTOBUF_CONSTEXPR AppActivity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppActivity(const AppActivity& from);
  AppActivity(AppActivity&& from) noexcept
    : AppActivity() {
    *this = ::std::move(from);
  }

  inline AppActivity& operator=(const AppActivity& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppActivity& operator=(AppActivity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppActivity& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppActivity* internal_default_instance() {
    return reinterpret_cast<const AppActivity*>(
               &_AppActivity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    163;

  friend void swap(AppActivity& a, AppActivity& b) {
    a.Swap(&b);
  }
  inline void Swap(AppActivity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppActivity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppActivity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppActivity>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AppActivity& from);
  void MergeFrom(const AppActivity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppActivity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.AppActivity";
  }
  protected:
  explicit AppActivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AppActivity_AppState AppState;
  static constexpr AppState UNKNOWN =
    AppActivity_AppState_UNKNOWN;
  static constexpr AppState DEFAULT =
    AppActivity_AppState_DEFAULT;
  static constexpr AppState ALWAYS_AVAILABLE =
    AppActivity_AppState_ALWAYS_AVAILABLE;
  static constexpr AppState BLOCKED =
    AppActivity_AppState_BLOCKED;
  static constexpr AppState LIMIT_REACHED =
    AppActivity_AppState_LIMIT_REACHED;
  static constexpr AppState UNINSTALLED =
    AppActivity_AppState_UNINSTALLED;
  static inline bool AppState_IsValid(int value) {
    return AppActivity_AppState_IsValid(value);
  }
  static constexpr AppState AppState_MIN =
    AppActivity_AppState_AppState_MIN;
  static constexpr AppState AppState_MAX =
    AppActivity_AppState_AppState_MAX;
  static constexpr int AppState_ARRAYSIZE =
    AppActivity_AppState_AppState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AppState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AppState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AppState_Name.");
    return AppActivity_AppState_Name(enum_t_value);
  }
  static inline bool AppState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AppState* value) {
    return AppActivity_AppState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActiveTimePeriodsFieldNumber = 2,
    kAppInfoFieldNumber = 1,
    kPopulatedAtFieldNumber = 3,
    kAppStateFieldNumber = 4,
  };
  // repeated .enterprise_management.TimePeriod active_time_periods = 2;
  int active_time_periods_size() const;
  private:
  int _internal_active_time_periods_size() const;
  public:
  void clear_active_time_periods();
  ::enterprise_management::TimePeriod* mutable_active_time_periods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >*
      mutable_active_time_periods();
  private:
  const ::enterprise_management::TimePeriod& _internal_active_time_periods(int index) const;
  ::enterprise_management::TimePeriod* _internal_add_active_time_periods();
  public:
  const ::enterprise_management::TimePeriod& active_time_periods(int index) const;
  ::enterprise_management::TimePeriod* add_active_time_periods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >&
      active_time_periods() const;

  // optional .enterprise_management.App app_info = 1;
  bool has_app_info() const;
  private:
  bool _internal_has_app_info() const;
  public:
  void clear_app_info();
  const ::enterprise_management::App& app_info() const;
  PROTOBUF_NODISCARD ::enterprise_management::App* release_app_info();
  ::enterprise_management::App* mutable_app_info();
  void set_allocated_app_info(::enterprise_management::App* app_info);
  private:
  const ::enterprise_management::App& _internal_app_info() const;
  ::enterprise_management::App* _internal_mutable_app_info();
  public:
  void unsafe_arena_set_allocated_app_info(
      ::enterprise_management::App* app_info);
  ::enterprise_management::App* unsafe_arena_release_app_info();

  // optional int64 populated_at = 3;
  bool has_populated_at() const;
  private:
  bool _internal_has_populated_at() const;
  public:
  void clear_populated_at();
  int64_t populated_at() const;
  void set_populated_at(int64_t value);
  private:
  int64_t _internal_populated_at() const;
  void _internal_set_populated_at(int64_t value);
  public:

  // optional .enterprise_management.AppActivity.AppState app_state = 4;
  bool has_app_state() const;
  private:
  bool _internal_has_app_state() const;
  public:
  void clear_app_state();
  ::enterprise_management::AppActivity_AppState app_state() const;
  void set_app_state(::enterprise_management::AppActivity_AppState value);
  private:
  ::enterprise_management::AppActivity_AppState _internal_app_state() const;
  void _internal_set_app_state(::enterprise_management::AppActivity_AppState value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.AppActivity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod > active_time_periods_;
    ::enterprise_management::App* app_info_;
    int64_t populated_at_;
    int app_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ScreenTimeSpan final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ScreenTimeSpan) */ {
 public:
  inline ScreenTimeSpan() : ScreenTimeSpan(nullptr) {}
  ~ScreenTimeSpan() override;
  explicit PROTOBUF_CONSTEXPR ScreenTimeSpan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScreenTimeSpan(const ScreenTimeSpan& from);
  ScreenTimeSpan(ScreenTimeSpan&& from) noexcept
    : ScreenTimeSpan() {
    *this = ::std::move(from);
  }

  inline ScreenTimeSpan& operator=(const ScreenTimeSpan& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScreenTimeSpan& operator=(ScreenTimeSpan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScreenTimeSpan& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScreenTimeSpan* internal_default_instance() {
    return reinterpret_cast<const ScreenTimeSpan*>(
               &_ScreenTimeSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    164;

  friend void swap(ScreenTimeSpan& a, ScreenTimeSpan& b) {
    a.Swap(&b);
  }
  inline void Swap(ScreenTimeSpan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScreenTimeSpan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScreenTimeSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScreenTimeSpan>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScreenTimeSpan& from);
  void MergeFrom(const ScreenTimeSpan& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScreenTimeSpan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ScreenTimeSpan";
  }
  protected:
  explicit ScreenTimeSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimePeriodFieldNumber = 1,
    kActiveDurationMsFieldNumber = 2,
  };
  // optional .enterprise_management.TimePeriod time_period = 1;
  bool has_time_period() const;
  private:
  bool _internal_has_time_period() const;
  public:
  void clear_time_period();
  const ::enterprise_management::TimePeriod& time_period() const;
  PROTOBUF_NODISCARD ::enterprise_management::TimePeriod* release_time_period();
  ::enterprise_management::TimePeriod* mutable_time_period();
  void set_allocated_time_period(::enterprise_management::TimePeriod* time_period);
  private:
  const ::enterprise_management::TimePeriod& _internal_time_period() const;
  ::enterprise_management::TimePeriod* _internal_mutable_time_period();
  public:
  void unsafe_arena_set_allocated_time_period(
      ::enterprise_management::TimePeriod* time_period);
  ::enterprise_management::TimePeriod* unsafe_arena_release_time_period();

  // optional int64 active_duration_ms = 2;
  bool has_active_duration_ms() const;
  private:
  bool _internal_has_active_duration_ms() const;
  public:
  void clear_active_duration_ms();
  int64_t active_duration_ms() const;
  void set_active_duration_ms(int64_t value);
  private:
  int64_t _internal_active_duration_ms() const;
  void _internal_set_active_duration_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ScreenTimeSpan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::TimePeriod* time_period_;
    int64_t active_duration_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChildStatusReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChildStatusReportRequest) */ {
 public:
  inline ChildStatusReportRequest() : ChildStatusReportRequest(nullptr) {}
  ~ChildStatusReportRequest() override;
  explicit PROTOBUF_CONSTEXPR ChildStatusReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChildStatusReportRequest(const ChildStatusReportRequest& from);
  ChildStatusReportRequest(ChildStatusReportRequest&& from) noexcept
    : ChildStatusReportRequest() {
    *this = ::std::move(from);
  }

  inline ChildStatusReportRequest& operator=(const ChildStatusReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChildStatusReportRequest& operator=(ChildStatusReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChildStatusReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChildStatusReportRequest* internal_default_instance() {
    return reinterpret_cast<const ChildStatusReportRequest*>(
               &_ChildStatusReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    165;

  friend void swap(ChildStatusReportRequest& a, ChildStatusReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChildStatusReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChildStatusReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChildStatusReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChildStatusReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChildStatusReportRequest& from);
  void MergeFrom(const ChildStatusReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChildStatusReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChildStatusReportRequest";
  }
  protected:
  explicit ChildStatusReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScreenTimeSpanFieldNumber = 4,
    kAppActivityFieldNumber = 8,
    kHiddenAppFieldNumber = 9,
    kUserDmTokenFieldNumber = 1,
    kTimeZoneFieldNumber = 3,
    kOsVersionFieldNumber = 6,
    kBootModeFieldNumber = 7,
    kAndroidStatusFieldNumber = 5,
    kTimestampMsFieldNumber = 2,
  };
  // repeated .enterprise_management.ScreenTimeSpan screen_time_span = 4;
  int screen_time_span_size() const;
  private:
  int _internal_screen_time_span_size() const;
  public:
  void clear_screen_time_span();
  ::enterprise_management::ScreenTimeSpan* mutable_screen_time_span(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan >*
      mutable_screen_time_span();
  private:
  const ::enterprise_management::ScreenTimeSpan& _internal_screen_time_span(int index) const;
  ::enterprise_management::ScreenTimeSpan* _internal_add_screen_time_span();
  public:
  const ::enterprise_management::ScreenTimeSpan& screen_time_span(int index) const;
  ::enterprise_management::ScreenTimeSpan* add_screen_time_span();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan >&
      screen_time_span() const;

  // repeated .enterprise_management.AppActivity app_activity = 8;
  int app_activity_size() const;
  private:
  int _internal_app_activity_size() const;
  public:
  void clear_app_activity();
  ::enterprise_management::AppActivity* mutable_app_activity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity >*
      mutable_app_activity();
  private:
  const ::enterprise_management::AppActivity& _internal_app_activity(int index) const;
  ::enterprise_management::AppActivity* _internal_add_app_activity();
  public:
  const ::enterprise_management::AppActivity& app_activity(int index) const;
  ::enterprise_management::AppActivity* add_app_activity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity >&
      app_activity() const;

  // repeated .enterprise_management.App hidden_app = 9;
  int hidden_app_size() const;
  private:
  int _internal_hidden_app_size() const;
  public:
  void clear_hidden_app();
  ::enterprise_management::App* mutable_hidden_app(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::App >*
      mutable_hidden_app();
  private:
  const ::enterprise_management::App& _internal_hidden_app(int index) const;
  ::enterprise_management::App* _internal_add_hidden_app();
  public:
  const ::enterprise_management::App& hidden_app(int index) const;
  ::enterprise_management::App* add_hidden_app();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::App >&
      hidden_app() const;

  // optional string user_dm_token = 1;
  bool has_user_dm_token() const;
  private:
  bool _internal_has_user_dm_token() const;
  public:
  void clear_user_dm_token();
  const std::string& user_dm_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_dm_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_dm_token();
  PROTOBUF_NODISCARD std::string* release_user_dm_token();
  void set_allocated_user_dm_token(std::string* user_dm_token);
  private:
  const std::string& _internal_user_dm_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_dm_token(const std::string& value);
  std::string* _internal_mutable_user_dm_token();
  public:

  // optional string time_zone = 3;
  bool has_time_zone() const;
  private:
  bool _internal_has_time_zone() const;
  public:
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // optional string os_version = 6;
  bool has_os_version() const;
  private:
  bool _internal_has_os_version() const;
  public:
  void clear_os_version();
  const std::string& os_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_version();
  PROTOBUF_NODISCARD std::string* release_os_version();
  void set_allocated_os_version(std::string* os_version);
  private:
  const std::string& _internal_os_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(const std::string& value);
  std::string* _internal_mutable_os_version();
  public:

  // optional string boot_mode = 7;
  bool has_boot_mode() const;
  private:
  bool _internal_has_boot_mode() const;
  public:
  void clear_boot_mode();
  const std::string& boot_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boot_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boot_mode();
  PROTOBUF_NODISCARD std::string* release_boot_mode();
  void set_allocated_boot_mode(std::string* boot_mode);
  private:
  const std::string& _internal_boot_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boot_mode(const std::string& value);
  std::string* _internal_mutable_boot_mode();
  public:

  // optional .enterprise_management.AndroidStatus android_status = 5;
  bool has_android_status() const;
  private:
  bool _internal_has_android_status() const;
  public:
  void clear_android_status();
  const ::enterprise_management::AndroidStatus& android_status() const;
  PROTOBUF_NODISCARD ::enterprise_management::AndroidStatus* release_android_status();
  ::enterprise_management::AndroidStatus* mutable_android_status();
  void set_allocated_android_status(::enterprise_management::AndroidStatus* android_status);
  private:
  const ::enterprise_management::AndroidStatus& _internal_android_status() const;
  ::enterprise_management::AndroidStatus* _internal_mutable_android_status();
  public:
  void unsafe_arena_set_allocated_android_status(
      ::enterprise_management::AndroidStatus* android_status);
  ::enterprise_management::AndroidStatus* unsafe_arena_release_android_status();

  // optional int64 timestamp_ms = 2;
  bool has_timestamp_ms() const;
  private:
  bool _internal_has_timestamp_ms() const;
  public:
  void clear_timestamp_ms();
  int64_t timestamp_ms() const;
  void set_timestamp_ms(int64_t value);
  private:
  int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ChildStatusReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan > screen_time_span_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity > app_activity_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::App > hidden_app_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_dm_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boot_mode_;
    ::enterprise_management::AndroidStatus* android_status_;
    int64_t timestamp_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ChildStatusReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ChildStatusReportResponse) */ {
 public:
  inline ChildStatusReportResponse() : ChildStatusReportResponse(nullptr) {}
  ~ChildStatusReportResponse() override;
  explicit PROTOBUF_CONSTEXPR ChildStatusReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChildStatusReportResponse(const ChildStatusReportResponse& from);
  ChildStatusReportResponse(ChildStatusReportResponse&& from) noexcept
    : ChildStatusReportResponse() {
    *this = ::std::move(from);
  }

  inline ChildStatusReportResponse& operator=(const ChildStatusReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChildStatusReportResponse& operator=(ChildStatusReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChildStatusReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChildStatusReportResponse* internal_default_instance() {
    return reinterpret_cast<const ChildStatusReportResponse*>(
               &_ChildStatusReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    166;

  friend void swap(ChildStatusReportResponse& a, ChildStatusReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChildStatusReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChildStatusReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChildStatusReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChildStatusReportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChildStatusReportResponse& from);
  void MergeFrom(const ChildStatusReportResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChildStatusReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ChildStatusReportResponse";
  }
  protected:
  explicit ChildStatusReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // optional string error_message = 2;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional int32 error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.ChildStatusReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int32_t error_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class StartCsrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.StartCsrRequest) */ {
 public:
  inline StartCsrRequest() : StartCsrRequest(nullptr) {}
  ~StartCsrRequest() override;
  explicit PROTOBUF_CONSTEXPR StartCsrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartCsrRequest(const StartCsrRequest& from);
  StartCsrRequest(StartCsrRequest&& from) noexcept
    : StartCsrRequest() {
    *this = ::std::move(from);
  }

  inline StartCsrRequest& operator=(const StartCsrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartCsrRequest& operator=(StartCsrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StartCsrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartCsrRequest* internal_default_instance() {
    return reinterpret_cast<const StartCsrRequest*>(
               &_StartCsrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    167;

  friend void swap(StartCsrRequest& a, StartCsrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartCsrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartCsrRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartCsrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartCsrRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StartCsrRequest& from);
  void MergeFrom(const StartCsrRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartCsrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.StartCsrRequest";
  }
  protected:
  explicit StartCsrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.StartCsrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class StartCsrResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.StartCsrResponse) */ {
 public:
  inline StartCsrResponse() : StartCsrResponse(nullptr) {}
  ~StartCsrResponse() override;
  explicit PROTOBUF_CONSTEXPR StartCsrResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartCsrResponse(const StartCsrResponse& from);
  StartCsrResponse(StartCsrResponse&& from) noexcept
    : StartCsrResponse() {
    *this = ::std::move(from);
  }

  inline StartCsrResponse& operator=(const StartCsrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartCsrResponse& operator=(StartCsrResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StartCsrResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartCsrResponse* internal_default_instance() {
    return reinterpret_cast<const StartCsrResponse*>(
               &_StartCsrResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    168;

  friend void swap(StartCsrResponse& a, StartCsrResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartCsrResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartCsrResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartCsrResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartCsrResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StartCsrResponse& from);
  void MergeFrom(const StartCsrResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartCsrResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.StartCsrResponse";
  }
  protected:
  explicit StartCsrResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvalidationTopicFieldNumber = 1,
    kVaChallengeFieldNumber = 2,
    kDataToSignFieldNumber = 4,
    kSigningAlgorithmFieldNumber = 3,
    kHashingAlgorithmFieldNumber = 5,
  };
  // optional string invalidation_topic = 1;
  bool has_invalidation_topic() const;
  private:
  bool _internal_has_invalidation_topic() const;
  public:
  void clear_invalidation_topic();
  const std::string& invalidation_topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invalidation_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invalidation_topic();
  PROTOBUF_NODISCARD std::string* release_invalidation_topic();
  void set_allocated_invalidation_topic(std::string* invalidation_topic);
  private:
  const std::string& _internal_invalidation_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invalidation_topic(const std::string& value);
  std::string* _internal_mutable_invalidation_topic();
  public:

  // optional bytes va_challenge = 2;
  bool has_va_challenge() const;
  private:
  bool _internal_has_va_challenge() const;
  public:
  void clear_va_challenge();
  const std::string& va_challenge() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_va_challenge(ArgT0&& arg0, ArgT... args);
  std::string* mutable_va_challenge();
  PROTOBUF_NODISCARD std::string* release_va_challenge();
  void set_allocated_va_challenge(std::string* va_challenge);
  private:
  const std::string& _internal_va_challenge() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_va_challenge(const std::string& value);
  std::string* _internal_mutable_va_challenge();
  public:

  // optional bytes data_to_sign = 4;
  bool has_data_to_sign() const;
  private:
  bool _internal_has_data_to_sign() const;
  public:
  void clear_data_to_sign();
  const std::string& data_to_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_to_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_to_sign();
  PROTOBUF_NODISCARD std::string* release_data_to_sign();
  void set_allocated_data_to_sign(std::string* data_to_sign);
  private:
  const std::string& _internal_data_to_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_to_sign(const std::string& value);
  std::string* _internal_mutable_data_to_sign();
  public:

  // optional .enterprise_management.SigningAlgorithm signing_algorithm = 3;
  bool has_signing_algorithm() const;
  private:
  bool _internal_has_signing_algorithm() const;
  public:
  void clear_signing_algorithm();
  ::enterprise_management::SigningAlgorithm signing_algorithm() const;
  void set_signing_algorithm(::enterprise_management::SigningAlgorithm value);
  private:
  ::enterprise_management::SigningAlgorithm _internal_signing_algorithm() const;
  void _internal_set_signing_algorithm(::enterprise_management::SigningAlgorithm value);
  public:

  // optional .enterprise_management.HashingAlgorithm hashing_algorithm = 5;
  bool has_hashing_algorithm() const;
  private:
  bool _internal_has_hashing_algorithm() const;
  public:
  void clear_hashing_algorithm();
  ::enterprise_management::HashingAlgorithm hashing_algorithm() const;
  void set_hashing_algorithm(::enterprise_management::HashingAlgorithm value);
  private:
  ::enterprise_management::HashingAlgorithm _internal_hashing_algorithm() const;
  void _internal_set_hashing_algorithm(::enterprise_management::HashingAlgorithm value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.StartCsrResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidation_topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr va_challenge_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_to_sign_;
    int signing_algorithm_;
    int hashing_algorithm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class FinishCsrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.FinishCsrRequest) */ {
 public:
  inline FinishCsrRequest() : FinishCsrRequest(nullptr) {}
  ~FinishCsrRequest() override;
  explicit PROTOBUF_CONSTEXPR FinishCsrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinishCsrRequest(const FinishCsrRequest& from);
  FinishCsrRequest(FinishCsrRequest&& from) noexcept
    : FinishCsrRequest() {
    *this = ::std::move(from);
  }

  inline FinishCsrRequest& operator=(const FinishCsrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishCsrRequest& operator=(FinishCsrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FinishCsrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinishCsrRequest* internal_default_instance() {
    return reinterpret_cast<const FinishCsrRequest*>(
               &_FinishCsrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    169;

  friend void swap(FinishCsrRequest& a, FinishCsrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FinishCsrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinishCsrRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinishCsrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinishCsrRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FinishCsrRequest& from);
  void MergeFrom(const FinishCsrRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FinishCsrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.FinishCsrRequest";
  }
  protected:
  explicit FinishCsrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVaChallengeResponseFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // optional bytes va_challenge_response = 1;
  bool has_va_challenge_response() const;
  private:
  bool _internal_has_va_challenge_response() const;
  public:
  void clear_va_challenge_response();
  const std::string& va_challenge_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_va_challenge_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_va_challenge_response();
  PROTOBUF_NODISCARD std::string* release_va_challenge_response();
  void set_allocated_va_challenge_response(std::string* va_challenge_response);
  private:
  const std::string& _internal_va_challenge_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_va_challenge_response(const std::string& value);
  std::string* _internal_mutable_va_challenge_response();
  public:

  // optional bytes signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.FinishCsrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr va_challenge_response_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class FinishCsrResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.FinishCsrResponse) */ {
 public:
  inline FinishCsrResponse() : FinishCsrResponse(nullptr) {}
  ~FinishCsrResponse() override;
  explicit PROTOBUF_CONSTEXPR FinishCsrResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinishCsrResponse(const FinishCsrResponse& from);
  FinishCsrResponse(FinishCsrResponse&& from) noexcept
    : FinishCsrResponse() {
    *this = ::std::move(from);
  }

  inline FinishCsrResponse& operator=(const FinishCsrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishCsrResponse& operator=(FinishCsrResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FinishCsrResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinishCsrResponse* internal_default_instance() {
    return reinterpret_cast<const FinishCsrResponse*>(
               &_FinishCsrResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    170;

  friend void swap(FinishCsrResponse& a, FinishCsrResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FinishCsrResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinishCsrResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinishCsrResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinishCsrResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FinishCsrResponse& from);
  void MergeFrom(const FinishCsrResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FinishCsrResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.FinishCsrResponse";
  }
  protected:
  explicit FinishCsrResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.FinishCsrResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DownloadCertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DownloadCertRequest) */ {
 public:
  inline DownloadCertRequest() : DownloadCertRequest(nullptr) {}
  ~DownloadCertRequest() override;
  explicit PROTOBUF_CONSTEXPR DownloadCertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadCertRequest(const DownloadCertRequest& from);
  DownloadCertRequest(DownloadCertRequest&& from) noexcept
    : DownloadCertRequest() {
    *this = ::std::move(from);
  }

  inline DownloadCertRequest& operator=(const DownloadCertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadCertRequest& operator=(DownloadCertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DownloadCertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadCertRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadCertRequest*>(
               &_DownloadCertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    171;

  friend void swap(DownloadCertRequest& a, DownloadCertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadCertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadCertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadCertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadCertRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadCertRequest& from);
  void MergeFrom(const DownloadCertRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadCertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DownloadCertRequest";
  }
  protected:
  explicit DownloadCertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.DownloadCertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DownloadCertResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DownloadCertResponse) */ {
 public:
  inline DownloadCertResponse() : DownloadCertResponse(nullptr) {}
  ~DownloadCertResponse() override;
  explicit PROTOBUF_CONSTEXPR DownloadCertResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadCertResponse(const DownloadCertResponse& from);
  DownloadCertResponse(DownloadCertResponse&& from) noexcept
    : DownloadCertResponse() {
    *this = ::std::move(from);
  }

  inline DownloadCertResponse& operator=(const DownloadCertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadCertResponse& operator=(DownloadCertResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DownloadCertResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadCertResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadCertResponse*>(
               &_DownloadCertResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    172;

  friend void swap(DownloadCertResponse& a, DownloadCertResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadCertResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadCertResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadCertResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadCertResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadCertResponse& from);
  void MergeFrom(const DownloadCertResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadCertResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DownloadCertResponse";
  }
  protected:
  explicit DownloadCertResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPemEncodedCertificateFieldNumber = 1,
  };
  // optional string pem_encoded_certificate = 1;
  bool has_pem_encoded_certificate() const;
  private:
  bool _internal_has_pem_encoded_certificate() const;
  public:
  void clear_pem_encoded_certificate();
  const std::string& pem_encoded_certificate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pem_encoded_certificate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pem_encoded_certificate();
  PROTOBUF_NODISCARD std::string* release_pem_encoded_certificate();
  void set_allocated_pem_encoded_certificate(std::string* pem_encoded_certificate);
  private:
  const std::string& _internal_pem_encoded_certificate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pem_encoded_certificate(const std::string& value);
  std::string* _internal_mutable_pem_encoded_certificate();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DownloadCertResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pem_encoded_certificate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertProvStartOrContinueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertProvStartOrContinueRequest) */ {
 public:
  inline CertProvStartOrContinueRequest() : CertProvStartOrContinueRequest(nullptr) {}
  ~CertProvStartOrContinueRequest() override;
  explicit PROTOBUF_CONSTEXPR CertProvStartOrContinueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertProvStartOrContinueRequest(const CertProvStartOrContinueRequest& from);
  CertProvStartOrContinueRequest(CertProvStartOrContinueRequest&& from) noexcept
    : CertProvStartOrContinueRequest() {
    *this = ::std::move(from);
  }

  inline CertProvStartOrContinueRequest& operator=(const CertProvStartOrContinueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertProvStartOrContinueRequest& operator=(CertProvStartOrContinueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertProvStartOrContinueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertProvStartOrContinueRequest* internal_default_instance() {
    return reinterpret_cast<const CertProvStartOrContinueRequest*>(
               &_CertProvStartOrContinueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    173;

  friend void swap(CertProvStartOrContinueRequest& a, CertProvStartOrContinueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CertProvStartOrContinueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertProvStartOrContinueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertProvStartOrContinueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertProvStartOrContinueRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertProvStartOrContinueRequest& from);
  void MergeFrom(const CertProvStartOrContinueRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertProvStartOrContinueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertProvStartOrContinueRequest";
  }
  protected:
  explicit CertProvStartOrContinueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:enterprise_management.CertProvStartOrContinueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertProvAuthorizeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertProvAuthorizeRequest) */ {
 public:
  inline CertProvAuthorizeRequest() : CertProvAuthorizeRequest(nullptr) {}
  ~CertProvAuthorizeRequest() override;
  explicit PROTOBUF_CONSTEXPR CertProvAuthorizeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertProvAuthorizeRequest(const CertProvAuthorizeRequest& from);
  CertProvAuthorizeRequest(CertProvAuthorizeRequest&& from) noexcept
    : CertProvAuthorizeRequest() {
    *this = ::std::move(from);
  }

  inline CertProvAuthorizeRequest& operator=(const CertProvAuthorizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertProvAuthorizeRequest& operator=(CertProvAuthorizeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertProvAuthorizeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertProvAuthorizeRequest* internal_default_instance() {
    return reinterpret_cast<const CertProvAuthorizeRequest*>(
               &_CertProvAuthorizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    174;

  friend void swap(CertProvAuthorizeRequest& a, CertProvAuthorizeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CertProvAuthorizeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertProvAuthorizeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertProvAuthorizeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertProvAuthorizeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertProvAuthorizeRequest& from);
  void MergeFrom(const CertProvAuthorizeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertProvAuthorizeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertProvAuthorizeRequest";
  }
  protected:
  explicit CertProvAuthorizeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVaChallengeResponseFieldNumber = 1,
  };
  // optional bytes va_challenge_response = 1;
  bool has_va_challenge_response() const;
  private:
  bool _internal_has_va_challenge_response() const;
  public:
  void clear_va_challenge_response();
  const std::string& va_challenge_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_va_challenge_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_va_challenge_response();
  PROTOBUF_NODISCARD std::string* release_va_challenge_response();
  void set_allocated_va_challenge_response(std::string* va_challenge_response);
  private:
  const std::string& _internal_va_challenge_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_va_challenge_response(const std::string& value);
  std::string* _internal_mutable_va_challenge_response();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CertProvAuthorizeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr va_challenge_response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertProvUploadProofOfPossessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertProvUploadProofOfPossessionRequest) */ {
 public:
  inline CertProvUploadProofOfPossessionRequest() : CertProvUploadProofOfPossessionRequest(nullptr) {}
  ~CertProvUploadProofOfPossessionRequest() override;
  explicit PROTOBUF_CONSTEXPR CertProvUploadProofOfPossessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertProvUploadProofOfPossessionRequest(const CertProvUploadProofOfPossessionRequest& from);
  CertProvUploadProofOfPossessionRequest(CertProvUploadProofOfPossessionRequest&& from) noexcept
    : CertProvUploadProofOfPossessionRequest() {
    *this = ::std::move(from);
  }

  inline CertProvUploadProofOfPossessionRequest& operator=(const CertProvUploadProofOfPossessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertProvUploadProofOfPossessionRequest& operator=(CertProvUploadProofOfPossessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertProvUploadProofOfPossessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertProvUploadProofOfPossessionRequest* internal_default_instance() {
    return reinterpret_cast<const CertProvUploadProofOfPossessionRequest*>(
               &_CertProvUploadProofOfPossessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    175;

  friend void swap(CertProvUploadProofOfPossessionRequest& a, CertProvUploadProofOfPossessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CertProvUploadProofOfPossessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertProvUploadProofOfPossessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertProvUploadProofOfPossessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertProvUploadProofOfPossessionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertProvUploadProofOfPossessionRequest& from);
  void MergeFrom(const CertProvUploadProofOfPossessionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertProvUploadProofOfPossessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertProvUploadProofOfPossessionRequest";
  }
  protected:
  explicit CertProvUploadProofOfPossessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
  };
  // optional bytes signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CertProvUploadProofOfPossessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertProvTryLaterInstruction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertProvTryLaterInstruction) */ {
 public:
  inline CertProvTryLaterInstruction() : CertProvTryLaterInstruction(nullptr) {}
  ~CertProvTryLaterInstruction() override;
  explicit PROTOBUF_CONSTEXPR CertProvTryLaterInstruction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertProvTryLaterInstruction(const CertProvTryLaterInstruction& from);
  CertProvTryLaterInstruction(CertProvTryLaterInstruction&& from) noexcept
    : CertProvTryLaterInstruction() {
    *this = ::std::move(from);
  }

  inline CertProvTryLaterInstruction& operator=(const CertProvTryLaterInstruction& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertProvTryLaterInstruction& operator=(CertProvTryLaterInstruction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertProvTryLaterInstruction& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertProvTryLaterInstruction* internal_default_instance() {
    return reinterpret_cast<const CertProvTryLaterInstruction*>(
               &_CertProvTryLaterInstruction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    176;

  friend void swap(CertProvTryLaterInstruction& a, CertProvTryLaterInstruction& b) {
    a.Swap(&b);
  }
  inline void Swap(CertProvTryLaterInstruction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertProvTryLaterInstruction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertProvTryLaterInstruction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertProvTryLaterInstruction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertProvTryLaterInstruction& from);
  void MergeFrom(const CertProvTryLaterInstruction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertProvTryLaterInstruction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertProvTryLaterInstruction";
  }
  protected:
  explicit CertProvTryLaterInstruction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelayMsFieldNumber = 1,
  };
  // optional int64 delay_ms = 1;
  bool has_delay_ms() const;
  private:
  bool _internal_has_delay_ms() const;
  public:
  void clear_delay_ms();
  int64_t delay_ms() const;
  void set_delay_ms(int64_t value);
  private:
  int64_t _internal_delay_ms() const;
  void _internal_set_delay_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CertProvTryLaterInstruction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t delay_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertProvAuthorizeInstruction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertProvAuthorizeInstruction) */ {
 public:
  inline CertProvAuthorizeInstruction() : CertProvAuthorizeInstruction(nullptr) {}
  ~CertProvAuthorizeInstruction() override;
  explicit PROTOBUF_CONSTEXPR CertProvAuthorizeInstruction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertProvAuthorizeInstruction(const CertProvAuthorizeInstruction& from);
  CertProvAuthorizeInstruction(CertProvAuthorizeInstruction&& from) noexcept
    : CertProvAuthorizeInstruction() {
    *this = ::std::move(from);
  }

  inline CertProvAuthorizeInstruction& operator=(const CertProvAuthorizeInstruction& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertProvAuthorizeInstruction& operator=(CertProvAuthorizeInstruction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertProvAuthorizeInstruction& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertProvAuthorizeInstruction* internal_default_instance() {
    return reinterpret_cast<const CertProvAuthorizeInstruction*>(
               &_CertProvAuthorizeInstruction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    177;

  friend void swap(CertProvAuthorizeInstruction& a, CertProvAuthorizeInstruction& b) {
    a.Swap(&b);
  }
  inline void Swap(CertProvAuthorizeInstruction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertProvAuthorizeInstruction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertProvAuthorizeInstruction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertProvAuthorizeInstruction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertProvAuthorizeInstruction& from);
  void MergeFrom(const CertProvAuthorizeInstruction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertProvAuthorizeInstruction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertProvAuthorizeInstruction";
  }
  protected:
  explicit CertProvAuthorizeInstruction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVaChallengeFieldNumber = 1,
  };
  // optional bytes va_challenge = 1;
  bool has_va_challenge() const;
  private:
  bool _internal_has_va_challenge() const;
  public:
  void clear_va_challenge();
  const std::string& va_challenge() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_va_challenge(ArgT0&& arg0, ArgT... args);
  std::string* mutable_va_challenge();
  PROTOBUF_NODISCARD std::string* release_va_challenge();
  void set_allocated_va_challenge(std::string* va_challenge);
  private:
  const std::string& _internal_va_challenge() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_va_challenge(const std::string& value);
  std::string* _internal_mutable_va_challenge();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CertProvAuthorizeInstruction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr va_challenge_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertProvProofOfPossessionInstruction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertProvProofOfPossessionInstruction) */ {
 public:
  inline CertProvProofOfPossessionInstruction() : CertProvProofOfPossessionInstruction(nullptr) {}
  ~CertProvProofOfPossessionInstruction() override;
  explicit PROTOBUF_CONSTEXPR CertProvProofOfPossessionInstruction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertProvProofOfPossessionInstruction(const CertProvProofOfPossessionInstruction& from);
  CertProvProofOfPossessionInstruction(CertProvProofOfPossessionInstruction&& from) noexcept
    : CertProvProofOfPossessionInstruction() {
    *this = ::std::move(from);
  }

  inline CertProvProofOfPossessionInstruction& operator=(const CertProvProofOfPossessionInstruction& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertProvProofOfPossessionInstruction& operator=(CertProvProofOfPossessionInstruction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertProvProofOfPossessionInstruction& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertProvProofOfPossessionInstruction* internal_default_instance() {
    return reinterpret_cast<const CertProvProofOfPossessionInstruction*>(
               &_CertProvProofOfPossessionInstruction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    178;

  friend void swap(CertProvProofOfPossessionInstruction& a, CertProvProofOfPossessionInstruction& b) {
    a.Swap(&b);
  }
  inline void Swap(CertProvProofOfPossessionInstruction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertProvProofOfPossessionInstruction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertProvProofOfPossessionInstruction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertProvProofOfPossessionInstruction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertProvProofOfPossessionInstruction& from);
  void MergeFrom(const CertProvProofOfPossessionInstruction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertProvProofOfPossessionInstruction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertProvProofOfPossessionInstruction";
  }
  protected:
  explicit CertProvProofOfPossessionInstruction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataToSignFieldNumber = 2,
  };
  // optional bytes data_to_sign = 2;
  bool has_data_to_sign() const;
  private:
  bool _internal_has_data_to_sign() const;
  public:
  void clear_data_to_sign();
  const std::string& data_to_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_to_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_to_sign();
  PROTOBUF_NODISCARD std::string* release_data_to_sign();
  void set_allocated_data_to_sign(std::string* data_to_sign);
  private:
  const std::string& _internal_data_to_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_to_sign(const std::string& value);
  std::string* _internal_mutable_data_to_sign();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CertProvProofOfPossessionInstruction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_to_sign_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertProvImportCertificateInstruction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertProvImportCertificateInstruction) */ {
 public:
  inline CertProvImportCertificateInstruction() : CertProvImportCertificateInstruction(nullptr) {}
  ~CertProvImportCertificateInstruction() override;
  explicit PROTOBUF_CONSTEXPR CertProvImportCertificateInstruction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertProvImportCertificateInstruction(const CertProvImportCertificateInstruction& from);
  CertProvImportCertificateInstruction(CertProvImportCertificateInstruction&& from) noexcept
    : CertProvImportCertificateInstruction() {
    *this = ::std::move(from);
  }

  inline CertProvImportCertificateInstruction& operator=(const CertProvImportCertificateInstruction& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertProvImportCertificateInstruction& operator=(CertProvImportCertificateInstruction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertProvImportCertificateInstruction& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertProvImportCertificateInstruction* internal_default_instance() {
    return reinterpret_cast<const CertProvImportCertificateInstruction*>(
               &_CertProvImportCertificateInstruction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    179;

  friend void swap(CertProvImportCertificateInstruction& a, CertProvImportCertificateInstruction& b) {
    a.Swap(&b);
  }
  inline void Swap(CertProvImportCertificateInstruction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertProvImportCertificateInstruction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertProvImportCertificateInstruction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertProvImportCertificateInstruction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertProvImportCertificateInstruction& from);
  void MergeFrom(const CertProvImportCertificateInstruction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertProvImportCertificateInstruction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertProvImportCertificateInstruction";
  }
  protected:
  explicit CertProvImportCertificateInstruction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPemEncodedCertificateFieldNumber = 1,
  };
  // optional string pem_encoded_certificate = 1;
  bool has_pem_encoded_certificate() const;
  private:
  bool _internal_has_pem_encoded_certificate() const;
  public:
  void clear_pem_encoded_certificate();
  const std::string& pem_encoded_certificate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pem_encoded_certificate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pem_encoded_certificate();
  PROTOBUF_NODISCARD std::string* release_pem_encoded_certificate();
  void set_allocated_pem_encoded_certificate(std::string* pem_encoded_certificate);
  private:
  const std::string& _internal_pem_encoded_certificate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pem_encoded_certificate(const std::string& value);
  std::string* _internal_mutable_pem_encoded_certificate();
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.CertProvImportCertificateInstruction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pem_encoded_certificate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class CertProvNextActionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.CertProvNextActionResponse) */ {
 public:
  inline CertProvNextActionResponse() : CertProvNextActionResponse(nullptr) {}
  ~CertProvNextActionResponse() override;
  explicit PROTOBUF_CONSTEXPR CertProvNextActionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertProvNextActionResponse(const CertProvNextActionResponse& from);
  CertProvNextActionResponse(CertProvNextActionResponse&& from) noexcept
    : CertProvNextActionResponse() {
    *this = ::std::move(from);
  }

  inline CertProvNextActionResponse& operator=(const CertProvNextActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertProvNextActionResponse& operator=(CertProvNextActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertProvNextActionResponse& default_instance() {
    return *internal_default_instance();
  }
  enum InstructionCase {
    kTryLaterInstruction = 5,
    kAuthorizeInstruction = 2,
    kProofOfPossessionInstruction = 3,
    kImportCertificateInstruction = 4,
    INSTRUCTION_NOT_SET = 0,
  };

  static inline const CertProvNextActionResponse* internal_default_instance() {
    return reinterpret_cast<const CertProvNextActionResponse*>(
               &_CertProvNextActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    180;

  friend void swap(CertProvNextActionResponse& a, CertProvNextActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CertProvNextActionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertProvNextActionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertProvNextActionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertProvNextActionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertProvNextActionResponse& from);
  void MergeFrom(const CertProvNextActionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertProvNextActionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.CertProvNextActionResponse";
  }
  protected:
  explicit CertProvNextActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvalidationTopicFieldNumber = 1,
    kTryLaterInstructionFieldNumber = 5,
    kAuthorizeInstructionFieldNumber = 2,
    kProofOfPossessionInstructionFieldNumber = 3,
    kImportCertificateInstructionFieldNumber = 4,
  };
  // optional string invalidation_topic = 1;
  bool has_invalidation_topic() const;
  private:
  bool _internal_has_invalidation_topic() const;
  public:
  void clear_invalidation_topic();
  const std::string& invalidation_topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invalidation_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invalidation_topic();
  PROTOBUF_NODISCARD std::string* release_invalidation_topic();
  void set_allocated_invalidation_topic(std::string* invalidation_topic);
  private:
  const std::string& _internal_invalidation_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invalidation_topic(const std::string& value);
  std::string* _internal_mutable_invalidation_topic();
  public:

  // .enterprise_management.CertProvTryLaterInstruction try_later_instruction = 5;
  bool has_try_later_instruction() const;
  private:
  bool _internal_has_try_later_instruction() const;
  public:
  void clear_try_later_instruction();
  const ::enterprise_management::CertProvTryLaterInstruction& try_later_instruction() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertProvTryLaterInstruction* release_try_later_instruction();
  ::enterprise_management::CertProvTryLaterInstruction* mutable_try_later_instruction();
  void set_allocated_try_later_instruction(::enterprise_management::CertProvTryLaterInstruction* try_later_instruction);
  private:
  const ::enterprise_management::CertProvTryLaterInstruction& _internal_try_later_instruction() const;
  ::enterprise_management::CertProvTryLaterInstruction* _internal_mutable_try_later_instruction();
  public:
  void unsafe_arena_set_allocated_try_later_instruction(
      ::enterprise_management::CertProvTryLaterInstruction* try_later_instruction);
  ::enterprise_management::CertProvTryLaterInstruction* unsafe_arena_release_try_later_instruction();

  // .enterprise_management.CertProvAuthorizeInstruction authorize_instruction = 2;
  bool has_authorize_instruction() const;
  private:
  bool _internal_has_authorize_instruction() const;
  public:
  void clear_authorize_instruction();
  const ::enterprise_management::CertProvAuthorizeInstruction& authorize_instruction() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertProvAuthorizeInstruction* release_authorize_instruction();
  ::enterprise_management::CertProvAuthorizeInstruction* mutable_authorize_instruction();
  void set_allocated_authorize_instruction(::enterprise_management::CertProvAuthorizeInstruction* authorize_instruction);
  private:
  const ::enterprise_management::CertProvAuthorizeInstruction& _internal_authorize_instruction() const;
  ::enterprise_management::CertProvAuthorizeInstruction* _internal_mutable_authorize_instruction();
  public:
  void unsafe_arena_set_allocated_authorize_instruction(
      ::enterprise_management::CertProvAuthorizeInstruction* authorize_instruction);
  ::enterprise_management::CertProvAuthorizeInstruction* unsafe_arena_release_authorize_instruction();

  // .enterprise_management.CertProvProofOfPossessionInstruction proof_of_possession_instruction = 3;
  bool has_proof_of_possession_instruction() const;
  private:
  bool _internal_has_proof_of_possession_instruction() const;
  public:
  void clear_proof_of_possession_instruction();
  const ::enterprise_management::CertProvProofOfPossessionInstruction& proof_of_possession_instruction() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertProvProofOfPossessionInstruction* release_proof_of_possession_instruction();
  ::enterprise_management::CertProvProofOfPossessionInstruction* mutable_proof_of_possession_instruction();
  void set_allocated_proof_of_possession_instruction(::enterprise_management::CertProvProofOfPossessionInstruction* proof_of_possession_instruction);
  private:
  const ::enterprise_management::CertProvProofOfPossessionInstruction& _internal_proof_of_possession_instruction() const;
  ::enterprise_management::CertProvProofOfPossessionInstruction* _internal_mutable_proof_of_possession_instruction();
  public:
  void unsafe_arena_set_allocated_proof_of_possession_instruction(
      ::enterprise_management::CertProvProofOfPossessionInstruction* proof_of_possession_instruction);
  ::enterprise_management::CertProvProofOfPossessionInstruction* unsafe_arena_release_proof_of_possession_instruction();

  // .enterprise_management.CertProvImportCertificateInstruction import_certificate_instruction = 4;
  bool has_import_certificate_instruction() const;
  private:
  bool _internal_has_import_certificate_instruction() const;
  public:
  void clear_import_certificate_instruction();
  const ::enterprise_management::CertProvImportCertificateInstruction& import_certificate_instruction() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertProvImportCertificateInstruction* release_import_certificate_instruction();
  ::enterprise_management::CertProvImportCertificateInstruction* mutable_import_certificate_instruction();
  void set_allocated_import_certificate_instruction(::enterprise_management::CertProvImportCertificateInstruction* import_certificate_instruction);
  private:
  const ::enterprise_management::CertProvImportCertificateInstruction& _internal_import_certificate_instruction() const;
  ::enterprise_management::CertProvImportCertificateInstruction* _internal_mutable_import_certificate_instruction();
  public:
  void unsafe_arena_set_allocated_import_certificate_instruction(
      ::enterprise_management::CertProvImportCertificateInstruction* import_certificate_instruction);
  ::enterprise_management::CertProvImportCertificateInstruction* unsafe_arena_release_import_certificate_instruction();

  void clear_instruction();
  InstructionCase instruction_case() const;
  // @@protoc_insertion_point(class_scope:enterprise_management.CertProvNextActionResponse)
 private:
  class _Internal;
  void set_has_try_later_instruction();
  void set_has_authorize_instruction();
  void set_has_proof_of_possession_instruction();
  void set_has_import_certificate_instruction();

  inline bool has_instruction() const;
  inline void clear_has_instruction();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidation_topic_;
    union InstructionUnion {
      constexpr InstructionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::enterprise_management::CertProvTryLaterInstruction* try_later_instruction_;
      ::enterprise_management::CertProvAuthorizeInstruction* authorize_instruction_;
      ::enterprise_management::CertProvProofOfPossessionInstruction* proof_of_possession_instruction_;
      ::enterprise_management::CertProvImportCertificateInstruction* import_certificate_instruction_;
    } instruction_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientCertificateProvisioningRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ClientCertificateProvisioningRequest) */ {
 public:
  inline ClientCertificateProvisioningRequest() : ClientCertificateProvisioningRequest(nullptr) {}
  ~ClientCertificateProvisioningRequest() override;
  explicit PROTOBUF_CONSTEXPR ClientCertificateProvisioningRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientCertificateProvisioningRequest(const ClientCertificateProvisioningRequest& from);
  ClientCertificateProvisioningRequest(ClientCertificateProvisioningRequest&& from) noexcept
    : ClientCertificateProvisioningRequest() {
    *this = ::std::move(from);
  }

  inline ClientCertificateProvisioningRequest& operator=(const ClientCertificateProvisioningRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientCertificateProvisioningRequest& operator=(ClientCertificateProvisioningRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientCertificateProvisioningRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kStartCsrRequest = 5,
    kFinishCsrRequest = 6,
    kDownloadCertRequest = 7,
    kStartOrContinueRequest = 9,
    kAuthorizeRequest = 10,
    kUploadProofOfPossessionRequest = 11,
    REQUEST_NOT_SET = 0,
  };

  static inline const ClientCertificateProvisioningRequest* internal_default_instance() {
    return reinterpret_cast<const ClientCertificateProvisioningRequest*>(
               &_ClientCertificateProvisioningRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    181;

  friend void swap(ClientCertificateProvisioningRequest& a, ClientCertificateProvisioningRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientCertificateProvisioningRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientCertificateProvisioningRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientCertificateProvisioningRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientCertificateProvisioningRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientCertificateProvisioningRequest& from);
  void MergeFrom(const ClientCertificateProvisioningRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientCertificateProvisioningRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ClientCertificateProvisioningRequest";
  }
  protected:
  explicit ClientCertificateProvisioningRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateScopeFieldNumber = 1,
    kCertProfileIdFieldNumber = 2,
    kPublicKeyFieldNumber = 3,
    kDeviceDmTokenFieldNumber = 4,
    kPolicyVersionFieldNumber = 8,
    kStartCsrRequestFieldNumber = 5,
    kFinishCsrRequestFieldNumber = 6,
    kDownloadCertRequestFieldNumber = 7,
    kStartOrContinueRequestFieldNumber = 9,
    kAuthorizeRequestFieldNumber = 10,
    kUploadProofOfPossessionRequestFieldNumber = 11,
  };
  // optional string certificate_scope = 1;
  bool has_certificate_scope() const;
  private:
  bool _internal_has_certificate_scope() const;
  public:
  void clear_certificate_scope();
  const std::string& certificate_scope() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_certificate_scope(ArgT0&& arg0, ArgT... args);
  std::string* mutable_certificate_scope();
  PROTOBUF_NODISCARD std::string* release_certificate_scope();
  void set_allocated_certificate_scope(std::string* certificate_scope);
  private:
  const std::string& _internal_certificate_scope() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_certificate_scope(const std::string& value);
  std::string* _internal_mutable_certificate_scope();
  public:

  // optional string cert_profile_id = 2;
  bool has_cert_profile_id() const;
  private:
  bool _internal_has_cert_profile_id() const;
  public:
  void clear_cert_profile_id();
  const std::string& cert_profile_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cert_profile_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cert_profile_id();
  PROTOBUF_NODISCARD std::string* release_cert_profile_id();
  void set_allocated_cert_profile_id(std::string* cert_profile_id);
  private:
  const std::string& _internal_cert_profile_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cert_profile_id(const std::string& value);
  std::string* _internal_mutable_cert_profile_id();
  public:

  // optional bytes public_key = 3;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // optional string device_dm_token = 4;
  bool has_device_dm_token() const;
  private:
  bool _internal_has_device_dm_token() const;
  public:
  void clear_device_dm_token();
  const std::string& device_dm_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_dm_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_dm_token();
  PROTOBUF_NODISCARD std::string* release_device_dm_token();
  void set_allocated_device_dm_token(std::string* device_dm_token);
  private:
  const std::string& _internal_device_dm_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_dm_token(const std::string& value);
  std::string* _internal_mutable_device_dm_token();
  public:

  // optional bytes policy_version = 8;
  bool has_policy_version() const;
  private:
  bool _internal_has_policy_version() const;
  public:
  void clear_policy_version();
  const std::string& policy_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy_version();
  PROTOBUF_NODISCARD std::string* release_policy_version();
  void set_allocated_policy_version(std::string* policy_version);
  private:
  const std::string& _internal_policy_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_version(const std::string& value);
  std::string* _internal_mutable_policy_version();
  public:

  // .enterprise_management.StartCsrRequest start_csr_request = 5;
  bool has_start_csr_request() const;
  private:
  bool _internal_has_start_csr_request() const;
  public:
  void clear_start_csr_request();
  const ::enterprise_management::StartCsrRequest& start_csr_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::StartCsrRequest* release_start_csr_request();
  ::enterprise_management::StartCsrRequest* mutable_start_csr_request();
  void set_allocated_start_csr_request(::enterprise_management::StartCsrRequest* start_csr_request);
  private:
  const ::enterprise_management::StartCsrRequest& _internal_start_csr_request() const;
  ::enterprise_management::StartCsrRequest* _internal_mutable_start_csr_request();
  public:
  void unsafe_arena_set_allocated_start_csr_request(
      ::enterprise_management::StartCsrRequest* start_csr_request);
  ::enterprise_management::StartCsrRequest* unsafe_arena_release_start_csr_request();

  // .enterprise_management.FinishCsrRequest finish_csr_request = 6;
  bool has_finish_csr_request() const;
  private:
  bool _internal_has_finish_csr_request() const;
  public:
  void clear_finish_csr_request();
  const ::enterprise_management::FinishCsrRequest& finish_csr_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::FinishCsrRequest* release_finish_csr_request();
  ::enterprise_management::FinishCsrRequest* mutable_finish_csr_request();
  void set_allocated_finish_csr_request(::enterprise_management::FinishCsrRequest* finish_csr_request);
  private:
  const ::enterprise_management::FinishCsrRequest& _internal_finish_csr_request() const;
  ::enterprise_management::FinishCsrRequest* _internal_mutable_finish_csr_request();
  public:
  void unsafe_arena_set_allocated_finish_csr_request(
      ::enterprise_management::FinishCsrRequest* finish_csr_request);
  ::enterprise_management::FinishCsrRequest* unsafe_arena_release_finish_csr_request();

  // .enterprise_management.DownloadCertRequest download_cert_request = 7;
  bool has_download_cert_request() const;
  private:
  bool _internal_has_download_cert_request() const;
  public:
  void clear_download_cert_request();
  const ::enterprise_management::DownloadCertRequest& download_cert_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DownloadCertRequest* release_download_cert_request();
  ::enterprise_management::DownloadCertRequest* mutable_download_cert_request();
  void set_allocated_download_cert_request(::enterprise_management::DownloadCertRequest* download_cert_request);
  private:
  const ::enterprise_management::DownloadCertRequest& _internal_download_cert_request() const;
  ::enterprise_management::DownloadCertRequest* _internal_mutable_download_cert_request();
  public:
  void unsafe_arena_set_allocated_download_cert_request(
      ::enterprise_management::DownloadCertRequest* download_cert_request);
  ::enterprise_management::DownloadCertRequest* unsafe_arena_release_download_cert_request();

  // .enterprise_management.CertProvStartOrContinueRequest start_or_continue_request = 9;
  bool has_start_or_continue_request() const;
  private:
  bool _internal_has_start_or_continue_request() const;
  public:
  void clear_start_or_continue_request();
  const ::enterprise_management::CertProvStartOrContinueRequest& start_or_continue_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertProvStartOrContinueRequest* release_start_or_continue_request();
  ::enterprise_management::CertProvStartOrContinueRequest* mutable_start_or_continue_request();
  void set_allocated_start_or_continue_request(::enterprise_management::CertProvStartOrContinueRequest* start_or_continue_request);
  private:
  const ::enterprise_management::CertProvStartOrContinueRequest& _internal_start_or_continue_request() const;
  ::enterprise_management::CertProvStartOrContinueRequest* _internal_mutable_start_or_continue_request();
  public:
  void unsafe_arena_set_allocated_start_or_continue_request(
      ::enterprise_management::CertProvStartOrContinueRequest* start_or_continue_request);
  ::enterprise_management::CertProvStartOrContinueRequest* unsafe_arena_release_start_or_continue_request();

  // .enterprise_management.CertProvAuthorizeRequest authorize_request = 10;
  bool has_authorize_request() const;
  private:
  bool _internal_has_authorize_request() const;
  public:
  void clear_authorize_request();
  const ::enterprise_management::CertProvAuthorizeRequest& authorize_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertProvAuthorizeRequest* release_authorize_request();
  ::enterprise_management::CertProvAuthorizeRequest* mutable_authorize_request();
  void set_allocated_authorize_request(::enterprise_management::CertProvAuthorizeRequest* authorize_request);
  private:
  const ::enterprise_management::CertProvAuthorizeRequest& _internal_authorize_request() const;
  ::enterprise_management::CertProvAuthorizeRequest* _internal_mutable_authorize_request();
  public:
  void unsafe_arena_set_allocated_authorize_request(
      ::enterprise_management::CertProvAuthorizeRequest* authorize_request);
  ::enterprise_management::CertProvAuthorizeRequest* unsafe_arena_release_authorize_request();

  // .enterprise_management.CertProvUploadProofOfPossessionRequest upload_proof_of_possession_request = 11;
  bool has_upload_proof_of_possession_request() const;
  private:
  bool _internal_has_upload_proof_of_possession_request() const;
  public:
  void clear_upload_proof_of_possession_request();
  const ::enterprise_management::CertProvUploadProofOfPossessionRequest& upload_proof_of_possession_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertProvUploadProofOfPossessionRequest* release_upload_proof_of_possession_request();
  ::enterprise_management::CertProvUploadProofOfPossessionRequest* mutable_upload_proof_of_possession_request();
  void set_allocated_upload_proof_of_possession_request(::enterprise_management::CertProvUploadProofOfPossessionRequest* upload_proof_of_possession_request);
  private:
  const ::enterprise_management::CertProvUploadProofOfPossessionRequest& _internal_upload_proof_of_possession_request() const;
  ::enterprise_management::CertProvUploadProofOfPossessionRequest* _internal_mutable_upload_proof_of_possession_request();
  public:
  void unsafe_arena_set_allocated_upload_proof_of_possession_request(
      ::enterprise_management::CertProvUploadProofOfPossessionRequest* upload_proof_of_possession_request);
  ::enterprise_management::CertProvUploadProofOfPossessionRequest* unsafe_arena_release_upload_proof_of_possession_request();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:enterprise_management.ClientCertificateProvisioningRequest)
 private:
  class _Internal;
  void set_has_start_csr_request();
  void set_has_finish_csr_request();
  void set_has_download_cert_request();
  void set_has_start_or_continue_request();
  void set_has_authorize_request();
  void set_has_upload_proof_of_possession_request();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr certificate_scope_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cert_profile_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_dm_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_version_;
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::enterprise_management::StartCsrRequest* start_csr_request_;
      ::enterprise_management::FinishCsrRequest* finish_csr_request_;
      ::enterprise_management::DownloadCertRequest* download_cert_request_;
      ::enterprise_management::CertProvStartOrContinueRequest* start_or_continue_request_;
      ::enterprise_management::CertProvAuthorizeRequest* authorize_request_;
      ::enterprise_management::CertProvUploadProofOfPossessionRequest* upload_proof_of_possession_request_;
    } request_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientCertificateProvisioningResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.ClientCertificateProvisioningResponse) */ {
 public:
  inline ClientCertificateProvisioningResponse() : ClientCertificateProvisioningResponse(nullptr) {}
  ~ClientCertificateProvisioningResponse() override;
  explicit PROTOBUF_CONSTEXPR ClientCertificateProvisioningResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientCertificateProvisioningResponse(const ClientCertificateProvisioningResponse& from);
  ClientCertificateProvisioningResponse(ClientCertificateProvisioningResponse&& from) noexcept
    : ClientCertificateProvisioningResponse() {
    *this = ::std::move(from);
  }

  inline ClientCertificateProvisioningResponse& operator=(const ClientCertificateProvisioningResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientCertificateProvisioningResponse& operator=(ClientCertificateProvisioningResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientCertificateProvisioningResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kError = 2,
    kStartCsrResponse = 3,
    kFinishCsrResponse = 4,
    kDownloadCertResponse = 5,
    kNextActionResponse = 6,
    RESPONSE_NOT_SET = 0,
  };

  static inline const ClientCertificateProvisioningResponse* internal_default_instance() {
    return reinterpret_cast<const ClientCertificateProvisioningResponse*>(
               &_ClientCertificateProvisioningResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    182;

  friend void swap(ClientCertificateProvisioningResponse& a, ClientCertificateProvisioningResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientCertificateProvisioningResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientCertificateProvisioningResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientCertificateProvisioningResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientCertificateProvisioningResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientCertificateProvisioningResponse& from);
  void MergeFrom(const ClientCertificateProvisioningResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientCertificateProvisioningResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.ClientCertificateProvisioningResponse";
  }
  protected:
  explicit ClientCertificateProvisioningResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientCertificateProvisioningResponse_Error Error;
  static constexpr Error UNDEFINED =
    ClientCertificateProvisioningResponse_Error_UNDEFINED;
  static constexpr Error TIMED_OUT =
    ClientCertificateProvisioningResponse_Error_TIMED_OUT;
  static constexpr Error IDENTITY_VERIFICATION_ERROR =
    ClientCertificateProvisioningResponse_Error_IDENTITY_VERIFICATION_ERROR;
  static constexpr Error CA_ERROR =
    ClientCertificateProvisioningResponse_Error_CA_ERROR;
  static constexpr Error INCONSISTENT_DATA =
    ClientCertificateProvisioningResponse_Error_INCONSISTENT_DATA;
  static constexpr Error BAD_PUBLIC_KEY =
    ClientCertificateProvisioningResponse_Error_BAD_PUBLIC_KEY;
  static constexpr Error BAD_CA_CERTIFICATE_SPECIFIED =
    ClientCertificateProvisioningResponse_Error_BAD_CA_CERTIFICATE_SPECIFIED;
  static constexpr Error BAD_CLIENT_CERTIFICATE_RECEIVED =
    ClientCertificateProvisioningResponse_Error_BAD_CLIENT_CERTIFICATE_RECEIVED;
  static constexpr Error INVALID_CSR_SIGNATURE =
    ClientCertificateProvisioningResponse_Error_INVALID_CSR_SIGNATURE;
  static constexpr Error CSR_ALREADY_SENT =
    ClientCertificateProvisioningResponse_Error_CSR_ALREADY_SENT;
  static inline bool Error_IsValid(int value) {
    return ClientCertificateProvisioningResponse_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ClientCertificateProvisioningResponse_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ClientCertificateProvisioningResponse_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ClientCertificateProvisioningResponse_Error_Error_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ClientCertificateProvisioningResponse_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return ClientCertificateProvisioningResponse_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTryAgainLaterFieldNumber = 1,
    kErrorFieldNumber = 2,
    kStartCsrResponseFieldNumber = 3,
    kFinishCsrResponseFieldNumber = 4,
    kDownloadCertResponseFieldNumber = 5,
    kNextActionResponseFieldNumber = 6,
  };
  // optional int64 try_again_later = 1;
  bool has_try_again_later() const;
  private:
  bool _internal_has_try_again_later() const;
  public:
  void clear_try_again_later();
  int64_t try_again_later() const;
  void set_try_again_later(int64_t value);
  private:
  int64_t _internal_try_again_later() const;
  void _internal_set_try_again_later(int64_t value);
  public:

  // .enterprise_management.ClientCertificateProvisioningResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::enterprise_management::ClientCertificateProvisioningResponse_Error error() const;
  void set_error(::enterprise_management::ClientCertificateProvisioningResponse_Error value);
  private:
  ::enterprise_management::ClientCertificateProvisioningResponse_Error _internal_error() const;
  void _internal_set_error(::enterprise_management::ClientCertificateProvisioningResponse_Error value);
  public:

  // .enterprise_management.StartCsrResponse start_csr_response = 3;
  bool has_start_csr_response() const;
  private:
  bool _internal_has_start_csr_response() const;
  public:
  void clear_start_csr_response();
  const ::enterprise_management::StartCsrResponse& start_csr_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::StartCsrResponse* release_start_csr_response();
  ::enterprise_management::StartCsrResponse* mutable_start_csr_response();
  void set_allocated_start_csr_response(::enterprise_management::StartCsrResponse* start_csr_response);
  private:
  const ::enterprise_management::StartCsrResponse& _internal_start_csr_response() const;
  ::enterprise_management::StartCsrResponse* _internal_mutable_start_csr_response();
  public:
  void unsafe_arena_set_allocated_start_csr_response(
      ::enterprise_management::StartCsrResponse* start_csr_response);
  ::enterprise_management::StartCsrResponse* unsafe_arena_release_start_csr_response();

  // .enterprise_management.FinishCsrResponse finish_csr_response = 4;
  bool has_finish_csr_response() const;
  private:
  bool _internal_has_finish_csr_response() const;
  public:
  void clear_finish_csr_response();
  const ::enterprise_management::FinishCsrResponse& finish_csr_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::FinishCsrResponse* release_finish_csr_response();
  ::enterprise_management::FinishCsrResponse* mutable_finish_csr_response();
  void set_allocated_finish_csr_response(::enterprise_management::FinishCsrResponse* finish_csr_response);
  private:
  const ::enterprise_management::FinishCsrResponse& _internal_finish_csr_response() const;
  ::enterprise_management::FinishCsrResponse* _internal_mutable_finish_csr_response();
  public:
  void unsafe_arena_set_allocated_finish_csr_response(
      ::enterprise_management::FinishCsrResponse* finish_csr_response);
  ::enterprise_management::FinishCsrResponse* unsafe_arena_release_finish_csr_response();

  // .enterprise_management.DownloadCertResponse download_cert_response = 5;
  bool has_download_cert_response() const;
  private:
  bool _internal_has_download_cert_response() const;
  public:
  void clear_download_cert_response();
  const ::enterprise_management::DownloadCertResponse& download_cert_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DownloadCertResponse* release_download_cert_response();
  ::enterprise_management::DownloadCertResponse* mutable_download_cert_response();
  void set_allocated_download_cert_response(::enterprise_management::DownloadCertResponse* download_cert_response);
  private:
  const ::enterprise_management::DownloadCertResponse& _internal_download_cert_response() const;
  ::enterprise_management::DownloadCertResponse* _internal_mutable_download_cert_response();
  public:
  void unsafe_arena_set_allocated_download_cert_response(
      ::enterprise_management::DownloadCertResponse* download_cert_response);
  ::enterprise_management::DownloadCertResponse* unsafe_arena_release_download_cert_response();

  // .enterprise_management.CertProvNextActionResponse next_action_response = 6;
  bool has_next_action_response() const;
  private:
  bool _internal_has_next_action_response() const;
  public:
  void clear_next_action_response();
  const ::enterprise_management::CertProvNextActionResponse& next_action_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertProvNextActionResponse* release_next_action_response();
  ::enterprise_management::CertProvNextActionResponse* mutable_next_action_response();
  void set_allocated_next_action_response(::enterprise_management::CertProvNextActionResponse* next_action_response);
  private:
  const ::enterprise_management::CertProvNextActionResponse& _internal_next_action_response() const;
  ::enterprise_management::CertProvNextActionResponse* _internal_mutable_next_action_response();
  public:
  void unsafe_arena_set_allocated_next_action_response(
      ::enterprise_management::CertProvNextActionResponse* next_action_response);
  ::enterprise_management::CertProvNextActionResponse* unsafe_arena_release_next_action_response();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:enterprise_management.ClientCertificateProvisioningResponse)
 private:
  class _Internal;
  void set_has_error();
  void set_has_start_csr_response();
  void set_has_finish_csr_response();
  void set_has_download_cert_response();
  void set_has_next_action_response();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t try_again_later_;
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int error_;
      ::enterprise_management::StartCsrResponse* start_csr_response_;
      ::enterprise_management::FinishCsrResponse* finish_csr_response_;
      ::enterprise_management::DownloadCertResponse* download_cert_response_;
      ::enterprise_management::CertProvNextActionResponse* next_action_response_;
    } response_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BrowserPublicKeyUploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BrowserPublicKeyUploadRequest) */ {
 public:
  inline BrowserPublicKeyUploadRequest() : BrowserPublicKeyUploadRequest(nullptr) {}
  ~BrowserPublicKeyUploadRequest() override;
  explicit PROTOBUF_CONSTEXPR BrowserPublicKeyUploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrowserPublicKeyUploadRequest(const BrowserPublicKeyUploadRequest& from);
  BrowserPublicKeyUploadRequest(BrowserPublicKeyUploadRequest&& from) noexcept
    : BrowserPublicKeyUploadRequest() {
    *this = ::std::move(from);
  }

  inline BrowserPublicKeyUploadRequest& operator=(const BrowserPublicKeyUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrowserPublicKeyUploadRequest& operator=(BrowserPublicKeyUploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BrowserPublicKeyUploadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrowserPublicKeyUploadRequest* internal_default_instance() {
    return reinterpret_cast<const BrowserPublicKeyUploadRequest*>(
               &_BrowserPublicKeyUploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    183;

  friend void swap(BrowserPublicKeyUploadRequest& a, BrowserPublicKeyUploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BrowserPublicKeyUploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrowserPublicKeyUploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrowserPublicKeyUploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrowserPublicKeyUploadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BrowserPublicKeyUploadRequest& from);
  void MergeFrom(const BrowserPublicKeyUploadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrowserPublicKeyUploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BrowserPublicKeyUploadRequest";
  }
  protected:
  explicit BrowserPublicKeyUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BrowserPublicKeyUploadRequest_KeyTrustLevel KeyTrustLevel;
  static constexpr KeyTrustLevel KEY_TRUST_LEVEL_UNSPECIFIED =
    BrowserPublicKeyUploadRequest_KeyTrustLevel_KEY_TRUST_LEVEL_UNSPECIFIED;
  static constexpr KeyTrustLevel CHROME_BROWSER_HW_KEY =
    BrowserPublicKeyUploadRequest_KeyTrustLevel_CHROME_BROWSER_HW_KEY;
  static constexpr KeyTrustLevel CHROME_BROWSER_OS_KEY =
    BrowserPublicKeyUploadRequest_KeyTrustLevel_CHROME_BROWSER_OS_KEY;
  static inline bool KeyTrustLevel_IsValid(int value) {
    return BrowserPublicKeyUploadRequest_KeyTrustLevel_IsValid(value);
  }
  static constexpr KeyTrustLevel KeyTrustLevel_MIN =
    BrowserPublicKeyUploadRequest_KeyTrustLevel_KeyTrustLevel_MIN;
  static constexpr KeyTrustLevel KeyTrustLevel_MAX =
    BrowserPublicKeyUploadRequest_KeyTrustLevel_KeyTrustLevel_MAX;
  static constexpr int KeyTrustLevel_ARRAYSIZE =
    BrowserPublicKeyUploadRequest_KeyTrustLevel_KeyTrustLevel_ARRAYSIZE;
  template<typename T>
  static inline const std::string& KeyTrustLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeyTrustLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeyTrustLevel_Name.");
    return BrowserPublicKeyUploadRequest_KeyTrustLevel_Name(enum_t_value);
  }
  static inline bool KeyTrustLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      KeyTrustLevel* value) {
    return BrowserPublicKeyUploadRequest_KeyTrustLevel_Parse(name, value);
  }

  typedef BrowserPublicKeyUploadRequest_KeyType KeyType;
  static constexpr KeyType KEY_TYPE_UNSPECIFIED =
    BrowserPublicKeyUploadRequest_KeyType_KEY_TYPE_UNSPECIFIED;
  static constexpr KeyType RSA_KEY =
    BrowserPublicKeyUploadRequest_KeyType_RSA_KEY;
  static constexpr KeyType EC_KEY =
    BrowserPublicKeyUploadRequest_KeyType_EC_KEY;
  static inline bool KeyType_IsValid(int value) {
    return BrowserPublicKeyUploadRequest_KeyType_IsValid(value);
  }
  static constexpr KeyType KeyType_MIN =
    BrowserPublicKeyUploadRequest_KeyType_KeyType_MIN;
  static constexpr KeyType KeyType_MAX =
    BrowserPublicKeyUploadRequest_KeyType_KeyType_MAX;
  static constexpr int KeyType_ARRAYSIZE =
    BrowserPublicKeyUploadRequest_KeyType_KeyType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& KeyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeyType_Name.");
    return BrowserPublicKeyUploadRequest_KeyType_Name(enum_t_value);
  }
  static inline bool KeyType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      KeyType* value) {
    return BrowserPublicKeyUploadRequest_KeyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kSignatureFieldNumber = 2,
    kKeyTrustLevelFieldNumber = 3,
    kKeyTypeFieldNumber = 4,
  };
  // optional bytes public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // optional bytes signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyTrustLevel key_trust_level = 3;
  bool has_key_trust_level() const;
  private:
  bool _internal_has_key_trust_level() const;
  public:
  void clear_key_trust_level();
  ::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel key_trust_level() const;
  void set_key_trust_level(::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel value);
  private:
  ::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel _internal_key_trust_level() const;
  void _internal_set_key_trust_level(::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel value);
  public:

  // optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyType key_type = 4;
  bool has_key_type() const;
  private:
  bool _internal_has_key_type() const;
  public:
  void clear_key_type();
  ::enterprise_management::BrowserPublicKeyUploadRequest_KeyType key_type() const;
  void set_key_type(::enterprise_management::BrowserPublicKeyUploadRequest_KeyType value);
  private:
  ::enterprise_management::BrowserPublicKeyUploadRequest_KeyType _internal_key_type() const;
  void _internal_set_key_type(::enterprise_management::BrowserPublicKeyUploadRequest_KeyType value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BrowserPublicKeyUploadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    int key_trust_level_;
    int key_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class BrowserPublicKeyUploadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.BrowserPublicKeyUploadResponse) */ {
 public:
  inline BrowserPublicKeyUploadResponse() : BrowserPublicKeyUploadResponse(nullptr) {}
  ~BrowserPublicKeyUploadResponse() override;
  explicit PROTOBUF_CONSTEXPR BrowserPublicKeyUploadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrowserPublicKeyUploadResponse(const BrowserPublicKeyUploadResponse& from);
  BrowserPublicKeyUploadResponse(BrowserPublicKeyUploadResponse&& from) noexcept
    : BrowserPublicKeyUploadResponse() {
    *this = ::std::move(from);
  }

  inline BrowserPublicKeyUploadResponse& operator=(const BrowserPublicKeyUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrowserPublicKeyUploadResponse& operator=(BrowserPublicKeyUploadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BrowserPublicKeyUploadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrowserPublicKeyUploadResponse* internal_default_instance() {
    return reinterpret_cast<const BrowserPublicKeyUploadResponse*>(
               &_BrowserPublicKeyUploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    184;

  friend void swap(BrowserPublicKeyUploadResponse& a, BrowserPublicKeyUploadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BrowserPublicKeyUploadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrowserPublicKeyUploadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrowserPublicKeyUploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrowserPublicKeyUploadResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BrowserPublicKeyUploadResponse& from);
  void MergeFrom(const BrowserPublicKeyUploadResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrowserPublicKeyUploadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.BrowserPublicKeyUploadResponse";
  }
  protected:
  explicit BrowserPublicKeyUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BrowserPublicKeyUploadResponse_ResponseCode ResponseCode;
  static constexpr ResponseCode UNDEFINED =
    BrowserPublicKeyUploadResponse_ResponseCode_UNDEFINED;
  static constexpr ResponseCode SUCCESS =
    BrowserPublicKeyUploadResponse_ResponseCode_SUCCESS;
  static constexpr ResponseCode INVALID_SIGNATURE =
    BrowserPublicKeyUploadResponse_ResponseCode_INVALID_SIGNATURE;
  static inline bool ResponseCode_IsValid(int value) {
    return BrowserPublicKeyUploadResponse_ResponseCode_IsValid(value);
  }
  static constexpr ResponseCode ResponseCode_MIN =
    BrowserPublicKeyUploadResponse_ResponseCode_ResponseCode_MIN;
  static constexpr ResponseCode ResponseCode_MAX =
    BrowserPublicKeyUploadResponse_ResponseCode_ResponseCode_MAX;
  static constexpr int ResponseCode_ARRAYSIZE =
    BrowserPublicKeyUploadResponse_ResponseCode_ResponseCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResponseCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseCode_Name.");
    return BrowserPublicKeyUploadResponse_ResponseCode_Name(enum_t_value);
  }
  static inline bool ResponseCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResponseCode* value) {
    return BrowserPublicKeyUploadResponse_ResponseCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseCodeFieldNumber = 1,
  };
  // optional .enterprise_management.BrowserPublicKeyUploadResponse.ResponseCode response_code = 1;
  bool has_response_code() const;
  private:
  bool _internal_has_response_code() const;
  public:
  void clear_response_code();
  ::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode response_code() const;
  void set_response_code(::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode value);
  private:
  ::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode _internal_response_code() const;
  void _internal_set_response_code(::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.BrowserPublicKeyUploadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceManagementRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceManagementRequest) */ {
 public:
  inline DeviceManagementRequest() : DeviceManagementRequest(nullptr) {}
  ~DeviceManagementRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceManagementRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceManagementRequest(const DeviceManagementRequest& from);
  DeviceManagementRequest(DeviceManagementRequest&& from) noexcept
    : DeviceManagementRequest() {
    *this = ::std::move(from);
  }

  inline DeviceManagementRequest& operator=(const DeviceManagementRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceManagementRequest& operator=(DeviceManagementRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceManagementRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceManagementRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceManagementRequest*>(
               &_DeviceManagementRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    185;

  friend void swap(DeviceManagementRequest& a, DeviceManagementRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceManagementRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceManagementRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceManagementRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceManagementRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceManagementRequest& from);
  void MergeFrom(const DeviceManagementRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceManagementRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceManagementRequest";
  }
  protected:
  explicit DeviceManagementRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterRequestFieldNumber = 1,
    kUnregisterRequestFieldNumber = 2,
    kPolicyRequestFieldNumber = 3,
    kDeviceStatusReportRequestFieldNumber = 4,
    kSessionStatusReportRequestFieldNumber = 5,
    kAutoEnrollmentRequestFieldNumber = 6,
    kCertUploadRequestFieldNumber = 7,
    kServiceApiAccessRequestFieldNumber = 8,
    kDeviceStateRetrievalRequestFieldNumber = 9,
    kDeviceStateKeyUpdateRequestFieldNumber = 10,
    kDevicePairingRequestFieldNumber = 11,
    kCheckDevicePairingRequestFieldNumber = 12,
    kRemoteCommandRequestFieldNumber = 13,
    kDeviceAttributeUpdatePermissionRequestFieldNumber = 14,
    kDeviceAttributeUpdateRequestFieldNumber = 15,
    kGcmIdUpdateRequestFieldNumber = 16,
    kCheckAndroidManagementRequestFieldNumber = 17,
    kCertificateBasedRegisterRequestFieldNumber = 18,
    kActiveDirectoryEnrollPlayUserRequestFieldNumber = 19,
    kActiveDirectoryPlayActivityRequestFieldNumber = 20,
    kCheckDeviceLicenseRequestDeprecatedFieldNumber = 21,
    kActiveDirectoryUserSigninRequestFieldNumber = 22,
    kRegisterBrowserRequestFieldNumber = 23,
    kAppInstallReportRequestFieldNumber = 25,
    kChromeDesktopReportRequestFieldNumber = 26,
    kPolicyValidationReportRequestFieldNumber = 27,
    kDeviceInitialEnrollmentStateRequestFieldNumber = 28,
    kRefreshAccountRequestFieldNumber = 29,
    kChildStatusReportRequestFieldNumber = 30,
    kRsuLookupKeyUploadRequestFieldNumber = 31,
    kPublicSamlUserRequestFieldNumber = 32,
    kChromeOsUserReportRequestFieldNumber = 33,
    kClientCertificateProvisioningRequestFieldNumber = 34,
    kExtensionInstallReportRequestFieldNumber = 35,
    kCheckUserAccountRequestFieldNumber = 36,
    kPrivateSetMembershipRequestFieldNumber = 37,
    kBrowserPublicKeyUploadRequestFieldNumber = 38,
    kUploadEuiccInfoRequestFieldNumber = 39,
    kChromeProfileReportRequestFieldNumber = 40,
  };
  // optional .enterprise_management.DeviceRegisterRequest register_request = 1;
  bool has_register_request() const;
  private:
  bool _internal_has_register_request() const;
  public:
  void clear_register_request();
  const ::enterprise_management::DeviceRegisterRequest& register_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRegisterRequest* release_register_request();
  ::enterprise_management::DeviceRegisterRequest* mutable_register_request();
  void set_allocated_register_request(::enterprise_management::DeviceRegisterRequest* register_request);
  private:
  const ::enterprise_management::DeviceRegisterRequest& _internal_register_request() const;
  ::enterprise_management::DeviceRegisterRequest* _internal_mutable_register_request();
  public:
  void unsafe_arena_set_allocated_register_request(
      ::enterprise_management::DeviceRegisterRequest* register_request);
  ::enterprise_management::DeviceRegisterRequest* unsafe_arena_release_register_request();

  // optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
  bool has_unregister_request() const;
  private:
  bool _internal_has_unregister_request() const;
  public:
  void clear_unregister_request();
  const ::enterprise_management::DeviceUnregisterRequest& unregister_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceUnregisterRequest* release_unregister_request();
  ::enterprise_management::DeviceUnregisterRequest* mutable_unregister_request();
  void set_allocated_unregister_request(::enterprise_management::DeviceUnregisterRequest* unregister_request);
  private:
  const ::enterprise_management::DeviceUnregisterRequest& _internal_unregister_request() const;
  ::enterprise_management::DeviceUnregisterRequest* _internal_mutable_unregister_request();
  public:
  void unsafe_arena_set_allocated_unregister_request(
      ::enterprise_management::DeviceUnregisterRequest* unregister_request);
  ::enterprise_management::DeviceUnregisterRequest* unsafe_arena_release_unregister_request();

  // optional .enterprise_management.DevicePolicyRequest policy_request = 3;
  bool has_policy_request() const;
  private:
  bool _internal_has_policy_request() const;
  public:
  void clear_policy_request();
  const ::enterprise_management::DevicePolicyRequest& policy_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePolicyRequest* release_policy_request();
  ::enterprise_management::DevicePolicyRequest* mutable_policy_request();
  void set_allocated_policy_request(::enterprise_management::DevicePolicyRequest* policy_request);
  private:
  const ::enterprise_management::DevicePolicyRequest& _internal_policy_request() const;
  ::enterprise_management::DevicePolicyRequest* _internal_mutable_policy_request();
  public:
  void unsafe_arena_set_allocated_policy_request(
      ::enterprise_management::DevicePolicyRequest* policy_request);
  ::enterprise_management::DevicePolicyRequest* unsafe_arena_release_policy_request();

  // optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
  bool has_device_status_report_request() const;
  private:
  bool _internal_has_device_status_report_request() const;
  public:
  void clear_device_status_report_request();
  const ::enterprise_management::DeviceStatusReportRequest& device_status_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceStatusReportRequest* release_device_status_report_request();
  ::enterprise_management::DeviceStatusReportRequest* mutable_device_status_report_request();
  void set_allocated_device_status_report_request(::enterprise_management::DeviceStatusReportRequest* device_status_report_request);
  private:
  const ::enterprise_management::DeviceStatusReportRequest& _internal_device_status_report_request() const;
  ::enterprise_management::DeviceStatusReportRequest* _internal_mutable_device_status_report_request();
  public:
  void unsafe_arena_set_allocated_device_status_report_request(
      ::enterprise_management::DeviceStatusReportRequest* device_status_report_request);
  ::enterprise_management::DeviceStatusReportRequest* unsafe_arena_release_device_status_report_request();

  // optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
  bool has_session_status_report_request() const;
  private:
  bool _internal_has_session_status_report_request() const;
  public:
  void clear_session_status_report_request();
  const ::enterprise_management::SessionStatusReportRequest& session_status_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::SessionStatusReportRequest* release_session_status_report_request();
  ::enterprise_management::SessionStatusReportRequest* mutable_session_status_report_request();
  void set_allocated_session_status_report_request(::enterprise_management::SessionStatusReportRequest* session_status_report_request);
  private:
  const ::enterprise_management::SessionStatusReportRequest& _internal_session_status_report_request() const;
  ::enterprise_management::SessionStatusReportRequest* _internal_mutable_session_status_report_request();
  public:
  void unsafe_arena_set_allocated_session_status_report_request(
      ::enterprise_management::SessionStatusReportRequest* session_status_report_request);
  ::enterprise_management::SessionStatusReportRequest* unsafe_arena_release_session_status_report_request();

  // optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
  bool has_auto_enrollment_request() const;
  private:
  bool _internal_has_auto_enrollment_request() const;
  public:
  void clear_auto_enrollment_request();
  const ::enterprise_management::DeviceAutoEnrollmentRequest& auto_enrollment_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAutoEnrollmentRequest* release_auto_enrollment_request();
  ::enterprise_management::DeviceAutoEnrollmentRequest* mutable_auto_enrollment_request();
  void set_allocated_auto_enrollment_request(::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request);
  private:
  const ::enterprise_management::DeviceAutoEnrollmentRequest& _internal_auto_enrollment_request() const;
  ::enterprise_management::DeviceAutoEnrollmentRequest* _internal_mutable_auto_enrollment_request();
  public:
  void unsafe_arena_set_allocated_auto_enrollment_request(
      ::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request);
  ::enterprise_management::DeviceAutoEnrollmentRequest* unsafe_arena_release_auto_enrollment_request();

  // optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
  bool has_cert_upload_request() const;
  private:
  bool _internal_has_cert_upload_request() const;
  public:
  void clear_cert_upload_request();
  const ::enterprise_management::DeviceCertUploadRequest& cert_upload_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceCertUploadRequest* release_cert_upload_request();
  ::enterprise_management::DeviceCertUploadRequest* mutable_cert_upload_request();
  void set_allocated_cert_upload_request(::enterprise_management::DeviceCertUploadRequest* cert_upload_request);
  private:
  const ::enterprise_management::DeviceCertUploadRequest& _internal_cert_upload_request() const;
  ::enterprise_management::DeviceCertUploadRequest* _internal_mutable_cert_upload_request();
  public:
  void unsafe_arena_set_allocated_cert_upload_request(
      ::enterprise_management::DeviceCertUploadRequest* cert_upload_request);
  ::enterprise_management::DeviceCertUploadRequest* unsafe_arena_release_cert_upload_request();

  // optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
  bool has_service_api_access_request() const;
  private:
  bool _internal_has_service_api_access_request() const;
  public:
  void clear_service_api_access_request();
  const ::enterprise_management::DeviceServiceApiAccessRequest& service_api_access_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceServiceApiAccessRequest* release_service_api_access_request();
  ::enterprise_management::DeviceServiceApiAccessRequest* mutable_service_api_access_request();
  void set_allocated_service_api_access_request(::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request);
  private:
  const ::enterprise_management::DeviceServiceApiAccessRequest& _internal_service_api_access_request() const;
  ::enterprise_management::DeviceServiceApiAccessRequest* _internal_mutable_service_api_access_request();
  public:
  void unsafe_arena_set_allocated_service_api_access_request(
      ::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request);
  ::enterprise_management::DeviceServiceApiAccessRequest* unsafe_arena_release_service_api_access_request();

  // optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
  bool has_device_state_retrieval_request() const;
  private:
  bool _internal_has_device_state_retrieval_request() const;
  public:
  void clear_device_state_retrieval_request();
  const ::enterprise_management::DeviceStateRetrievalRequest& device_state_retrieval_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceStateRetrievalRequest* release_device_state_retrieval_request();
  ::enterprise_management::DeviceStateRetrievalRequest* mutable_device_state_retrieval_request();
  void set_allocated_device_state_retrieval_request(::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request);
  private:
  const ::enterprise_management::DeviceStateRetrievalRequest& _internal_device_state_retrieval_request() const;
  ::enterprise_management::DeviceStateRetrievalRequest* _internal_mutable_device_state_retrieval_request();
  public:
  void unsafe_arena_set_allocated_device_state_retrieval_request(
      ::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request);
  ::enterprise_management::DeviceStateRetrievalRequest* unsafe_arena_release_device_state_retrieval_request();

  // optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
  bool has_device_state_key_update_request() const;
  private:
  bool _internal_has_device_state_key_update_request() const;
  public:
  void clear_device_state_key_update_request();
  const ::enterprise_management::DeviceStateKeyUpdateRequest& device_state_key_update_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceStateKeyUpdateRequest* release_device_state_key_update_request();
  ::enterprise_management::DeviceStateKeyUpdateRequest* mutable_device_state_key_update_request();
  void set_allocated_device_state_key_update_request(::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request);
  private:
  const ::enterprise_management::DeviceStateKeyUpdateRequest& _internal_device_state_key_update_request() const;
  ::enterprise_management::DeviceStateKeyUpdateRequest* _internal_mutable_device_state_key_update_request();
  public:
  void unsafe_arena_set_allocated_device_state_key_update_request(
      ::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request);
  ::enterprise_management::DeviceStateKeyUpdateRequest* unsafe_arena_release_device_state_key_update_request();

  // optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
  bool has_device_pairing_request() const;
  private:
  bool _internal_has_device_pairing_request() const;
  public:
  void clear_device_pairing_request();
  const ::enterprise_management::DevicePairingRequest& device_pairing_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePairingRequest* release_device_pairing_request();
  ::enterprise_management::DevicePairingRequest* mutable_device_pairing_request();
  void set_allocated_device_pairing_request(::enterprise_management::DevicePairingRequest* device_pairing_request);
  private:
  const ::enterprise_management::DevicePairingRequest& _internal_device_pairing_request() const;
  ::enterprise_management::DevicePairingRequest* _internal_mutable_device_pairing_request();
  public:
  void unsafe_arena_set_allocated_device_pairing_request(
      ::enterprise_management::DevicePairingRequest* device_pairing_request);
  ::enterprise_management::DevicePairingRequest* unsafe_arena_release_device_pairing_request();

  // optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
  bool has_check_device_pairing_request() const;
  private:
  bool _internal_has_check_device_pairing_request() const;
  public:
  void clear_check_device_pairing_request();
  const ::enterprise_management::CheckDevicePairingRequest& check_device_pairing_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::CheckDevicePairingRequest* release_check_device_pairing_request();
  ::enterprise_management::CheckDevicePairingRequest* mutable_check_device_pairing_request();
  void set_allocated_check_device_pairing_request(::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request);
  private:
  const ::enterprise_management::CheckDevicePairingRequest& _internal_check_device_pairing_request() const;
  ::enterprise_management::CheckDevicePairingRequest* _internal_mutable_check_device_pairing_request();
  public:
  void unsafe_arena_set_allocated_check_device_pairing_request(
      ::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request);
  ::enterprise_management::CheckDevicePairingRequest* unsafe_arena_release_check_device_pairing_request();

  // optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
  bool has_remote_command_request() const;
  private:
  bool _internal_has_remote_command_request() const;
  public:
  void clear_remote_command_request();
  const ::enterprise_management::DeviceRemoteCommandRequest& remote_command_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRemoteCommandRequest* release_remote_command_request();
  ::enterprise_management::DeviceRemoteCommandRequest* mutable_remote_command_request();
  void set_allocated_remote_command_request(::enterprise_management::DeviceRemoteCommandRequest* remote_command_request);
  private:
  const ::enterprise_management::DeviceRemoteCommandRequest& _internal_remote_command_request() const;
  ::enterprise_management::DeviceRemoteCommandRequest* _internal_mutable_remote_command_request();
  public:
  void unsafe_arena_set_allocated_remote_command_request(
      ::enterprise_management::DeviceRemoteCommandRequest* remote_command_request);
  ::enterprise_management::DeviceRemoteCommandRequest* unsafe_arena_release_remote_command_request();

  // optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
  bool has_device_attribute_update_permission_request() const;
  private:
  bool _internal_has_device_attribute_update_permission_request() const;
  public:
  void clear_device_attribute_update_permission_request();
  const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& device_attribute_update_permission_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAttributeUpdatePermissionRequest* release_device_attribute_update_permission_request();
  ::enterprise_management::DeviceAttributeUpdatePermissionRequest* mutable_device_attribute_update_permission_request();
  void set_allocated_device_attribute_update_permission_request(::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request);
  private:
  const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& _internal_device_attribute_update_permission_request() const;
  ::enterprise_management::DeviceAttributeUpdatePermissionRequest* _internal_mutable_device_attribute_update_permission_request();
  public:
  void unsafe_arena_set_allocated_device_attribute_update_permission_request(
      ::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request);
  ::enterprise_management::DeviceAttributeUpdatePermissionRequest* unsafe_arena_release_device_attribute_update_permission_request();

  // optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
  bool has_device_attribute_update_request() const;
  private:
  bool _internal_has_device_attribute_update_request() const;
  public:
  void clear_device_attribute_update_request();
  const ::enterprise_management::DeviceAttributeUpdateRequest& device_attribute_update_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAttributeUpdateRequest* release_device_attribute_update_request();
  ::enterprise_management::DeviceAttributeUpdateRequest* mutable_device_attribute_update_request();
  void set_allocated_device_attribute_update_request(::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request);
  private:
  const ::enterprise_management::DeviceAttributeUpdateRequest& _internal_device_attribute_update_request() const;
  ::enterprise_management::DeviceAttributeUpdateRequest* _internal_mutable_device_attribute_update_request();
  public:
  void unsafe_arena_set_allocated_device_attribute_update_request(
      ::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request);
  ::enterprise_management::DeviceAttributeUpdateRequest* unsafe_arena_release_device_attribute_update_request();

  // optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
  bool has_gcm_id_update_request() const;
  private:
  bool _internal_has_gcm_id_update_request() const;
  public:
  void clear_gcm_id_update_request();
  const ::enterprise_management::GcmIdUpdateRequest& gcm_id_update_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::GcmIdUpdateRequest* release_gcm_id_update_request();
  ::enterprise_management::GcmIdUpdateRequest* mutable_gcm_id_update_request();
  void set_allocated_gcm_id_update_request(::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request);
  private:
  const ::enterprise_management::GcmIdUpdateRequest& _internal_gcm_id_update_request() const;
  ::enterprise_management::GcmIdUpdateRequest* _internal_mutable_gcm_id_update_request();
  public:
  void unsafe_arena_set_allocated_gcm_id_update_request(
      ::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request);
  ::enterprise_management::GcmIdUpdateRequest* unsafe_arena_release_gcm_id_update_request();

  // optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
  bool has_check_android_management_request() const;
  private:
  bool _internal_has_check_android_management_request() const;
  public:
  void clear_check_android_management_request();
  const ::enterprise_management::CheckAndroidManagementRequest& check_android_management_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::CheckAndroidManagementRequest* release_check_android_management_request();
  ::enterprise_management::CheckAndroidManagementRequest* mutable_check_android_management_request();
  void set_allocated_check_android_management_request(::enterprise_management::CheckAndroidManagementRequest* check_android_management_request);
  private:
  const ::enterprise_management::CheckAndroidManagementRequest& _internal_check_android_management_request() const;
  ::enterprise_management::CheckAndroidManagementRequest* _internal_mutable_check_android_management_request();
  public:
  void unsafe_arena_set_allocated_check_android_management_request(
      ::enterprise_management::CheckAndroidManagementRequest* check_android_management_request);
  ::enterprise_management::CheckAndroidManagementRequest* unsafe_arena_release_check_android_management_request();

  // optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
  bool has_certificate_based_register_request() const;
  private:
  bool _internal_has_certificate_based_register_request() const;
  public:
  void clear_certificate_based_register_request();
  const ::enterprise_management::CertificateBasedDeviceRegisterRequest& certificate_based_register_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::CertificateBasedDeviceRegisterRequest* release_certificate_based_register_request();
  ::enterprise_management::CertificateBasedDeviceRegisterRequest* mutable_certificate_based_register_request();
  void set_allocated_certificate_based_register_request(::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request);
  private:
  const ::enterprise_management::CertificateBasedDeviceRegisterRequest& _internal_certificate_based_register_request() const;
  ::enterprise_management::CertificateBasedDeviceRegisterRequest* _internal_mutable_certificate_based_register_request();
  public:
  void unsafe_arena_set_allocated_certificate_based_register_request(
      ::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request);
  ::enterprise_management::CertificateBasedDeviceRegisterRequest* unsafe_arena_release_certificate_based_register_request();

  // optional .enterprise_management.ActiveDirectoryEnrollPlayUserRequest active_directory_enroll_play_user_request = 19;
  bool has_active_directory_enroll_play_user_request() const;
  private:
  bool _internal_has_active_directory_enroll_play_user_request() const;
  public:
  void clear_active_directory_enroll_play_user_request();
  const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest& active_directory_enroll_play_user_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* release_active_directory_enroll_play_user_request();
  ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* mutable_active_directory_enroll_play_user_request();
  void set_allocated_active_directory_enroll_play_user_request(::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* active_directory_enroll_play_user_request);
  private:
  const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest& _internal_active_directory_enroll_play_user_request() const;
  ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* _internal_mutable_active_directory_enroll_play_user_request();
  public:
  void unsafe_arena_set_allocated_active_directory_enroll_play_user_request(
      ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* active_directory_enroll_play_user_request);
  ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* unsafe_arena_release_active_directory_enroll_play_user_request();

  // optional .enterprise_management.ActiveDirectoryPlayActivityRequest active_directory_play_activity_request = 20;
  bool has_active_directory_play_activity_request() const;
  private:
  bool _internal_has_active_directory_play_activity_request() const;
  public:
  void clear_active_directory_play_activity_request();
  const ::enterprise_management::ActiveDirectoryPlayActivityRequest& active_directory_play_activity_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ActiveDirectoryPlayActivityRequest* release_active_directory_play_activity_request();
  ::enterprise_management::ActiveDirectoryPlayActivityRequest* mutable_active_directory_play_activity_request();
  void set_allocated_active_directory_play_activity_request(::enterprise_management::ActiveDirectoryPlayActivityRequest* active_directory_play_activity_request);
  private:
  const ::enterprise_management::ActiveDirectoryPlayActivityRequest& _internal_active_directory_play_activity_request() const;
  ::enterprise_management::ActiveDirectoryPlayActivityRequest* _internal_mutable_active_directory_play_activity_request();
  public:
  void unsafe_arena_set_allocated_active_directory_play_activity_request(
      ::enterprise_management::ActiveDirectoryPlayActivityRequest* active_directory_play_activity_request);
  ::enterprise_management::ActiveDirectoryPlayActivityRequest* unsafe_arena_release_active_directory_play_activity_request();

  // optional .enterprise_management.CheckDeviceLicenseRequest check_device_license_request_deprecated = 21 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_check_device_license_request_deprecated() const;
  private:
  bool _internal_has_check_device_license_request_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_check_device_license_request_deprecated();
  PROTOBUF_DEPRECATED const ::enterprise_management::CheckDeviceLicenseRequest& check_device_license_request_deprecated() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseRequest* release_check_device_license_request_deprecated();
  PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseRequest* mutable_check_device_license_request_deprecated();
  PROTOBUF_DEPRECATED void set_allocated_check_device_license_request_deprecated(::enterprise_management::CheckDeviceLicenseRequest* check_device_license_request_deprecated);
  private:
  const ::enterprise_management::CheckDeviceLicenseRequest& _internal_check_device_license_request_deprecated() const;
  ::enterprise_management::CheckDeviceLicenseRequest* _internal_mutable_check_device_license_request_deprecated();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_check_device_license_request_deprecated(
      ::enterprise_management::CheckDeviceLicenseRequest* check_device_license_request_deprecated);
  PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseRequest* unsafe_arena_release_check_device_license_request_deprecated();

  // optional .enterprise_management.ActiveDirectoryUserSigninRequest active_directory_user_signin_request = 22;
  bool has_active_directory_user_signin_request() const;
  private:
  bool _internal_has_active_directory_user_signin_request() const;
  public:
  void clear_active_directory_user_signin_request();
  const ::enterprise_management::ActiveDirectoryUserSigninRequest& active_directory_user_signin_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ActiveDirectoryUserSigninRequest* release_active_directory_user_signin_request();
  ::enterprise_management::ActiveDirectoryUserSigninRequest* mutable_active_directory_user_signin_request();
  void set_allocated_active_directory_user_signin_request(::enterprise_management::ActiveDirectoryUserSigninRequest* active_directory_user_signin_request);
  private:
  const ::enterprise_management::ActiveDirectoryUserSigninRequest& _internal_active_directory_user_signin_request() const;
  ::enterprise_management::ActiveDirectoryUserSigninRequest* _internal_mutable_active_directory_user_signin_request();
  public:
  void unsafe_arena_set_allocated_active_directory_user_signin_request(
      ::enterprise_management::ActiveDirectoryUserSigninRequest* active_directory_user_signin_request);
  ::enterprise_management::ActiveDirectoryUserSigninRequest* unsafe_arena_release_active_directory_user_signin_request();

  // optional .enterprise_management.RegisterBrowserRequest register_browser_request = 23;
  bool has_register_browser_request() const;
  private:
  bool _internal_has_register_browser_request() const;
  public:
  void clear_register_browser_request();
  const ::enterprise_management::RegisterBrowserRequest& register_browser_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::RegisterBrowserRequest* release_register_browser_request();
  ::enterprise_management::RegisterBrowserRequest* mutable_register_browser_request();
  void set_allocated_register_browser_request(::enterprise_management::RegisterBrowserRequest* register_browser_request);
  private:
  const ::enterprise_management::RegisterBrowserRequest& _internal_register_browser_request() const;
  ::enterprise_management::RegisterBrowserRequest* _internal_mutable_register_browser_request();
  public:
  void unsafe_arena_set_allocated_register_browser_request(
      ::enterprise_management::RegisterBrowserRequest* register_browser_request);
  ::enterprise_management::RegisterBrowserRequest* unsafe_arena_release_register_browser_request();

  // optional .enterprise_management.AppInstallReportRequest app_install_report_request = 25;
  bool has_app_install_report_request() const;
  private:
  bool _internal_has_app_install_report_request() const;
  public:
  void clear_app_install_report_request();
  const ::enterprise_management::AppInstallReportRequest& app_install_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::AppInstallReportRequest* release_app_install_report_request();
  ::enterprise_management::AppInstallReportRequest* mutable_app_install_report_request();
  void set_allocated_app_install_report_request(::enterprise_management::AppInstallReportRequest* app_install_report_request);
  private:
  const ::enterprise_management::AppInstallReportRequest& _internal_app_install_report_request() const;
  ::enterprise_management::AppInstallReportRequest* _internal_mutable_app_install_report_request();
  public:
  void unsafe_arena_set_allocated_app_install_report_request(
      ::enterprise_management::AppInstallReportRequest* app_install_report_request);
  ::enterprise_management::AppInstallReportRequest* unsafe_arena_release_app_install_report_request();

  // optional .enterprise_management.ChromeDesktopReportRequest chrome_desktop_report_request = 26;
  bool has_chrome_desktop_report_request() const;
  private:
  bool _internal_has_chrome_desktop_report_request() const;
  public:
  void clear_chrome_desktop_report_request();
  const ::enterprise_management::ChromeDesktopReportRequest& chrome_desktop_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChromeDesktopReportRequest* release_chrome_desktop_report_request();
  ::enterprise_management::ChromeDesktopReportRequest* mutable_chrome_desktop_report_request();
  void set_allocated_chrome_desktop_report_request(::enterprise_management::ChromeDesktopReportRequest* chrome_desktop_report_request);
  private:
  const ::enterprise_management::ChromeDesktopReportRequest& _internal_chrome_desktop_report_request() const;
  ::enterprise_management::ChromeDesktopReportRequest* _internal_mutable_chrome_desktop_report_request();
  public:
  void unsafe_arena_set_allocated_chrome_desktop_report_request(
      ::enterprise_management::ChromeDesktopReportRequest* chrome_desktop_report_request);
  ::enterprise_management::ChromeDesktopReportRequest* unsafe_arena_release_chrome_desktop_report_request();

  // optional .enterprise_management.PolicyValidationReportRequest policy_validation_report_request = 27;
  bool has_policy_validation_report_request() const;
  private:
  bool _internal_has_policy_validation_report_request() const;
  public:
  void clear_policy_validation_report_request();
  const ::enterprise_management::PolicyValidationReportRequest& policy_validation_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyValidationReportRequest* release_policy_validation_report_request();
  ::enterprise_management::PolicyValidationReportRequest* mutable_policy_validation_report_request();
  void set_allocated_policy_validation_report_request(::enterprise_management::PolicyValidationReportRequest* policy_validation_report_request);
  private:
  const ::enterprise_management::PolicyValidationReportRequest& _internal_policy_validation_report_request() const;
  ::enterprise_management::PolicyValidationReportRequest* _internal_mutable_policy_validation_report_request();
  public:
  void unsafe_arena_set_allocated_policy_validation_report_request(
      ::enterprise_management::PolicyValidationReportRequest* policy_validation_report_request);
  ::enterprise_management::PolicyValidationReportRequest* unsafe_arena_release_policy_validation_report_request();

  // optional .enterprise_management.DeviceInitialEnrollmentStateRequest device_initial_enrollment_state_request = 28;
  bool has_device_initial_enrollment_state_request() const;
  private:
  bool _internal_has_device_initial_enrollment_state_request() const;
  public:
  void clear_device_initial_enrollment_state_request();
  const ::enterprise_management::DeviceInitialEnrollmentStateRequest& device_initial_enrollment_state_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceInitialEnrollmentStateRequest* release_device_initial_enrollment_state_request();
  ::enterprise_management::DeviceInitialEnrollmentStateRequest* mutable_device_initial_enrollment_state_request();
  void set_allocated_device_initial_enrollment_state_request(::enterprise_management::DeviceInitialEnrollmentStateRequest* device_initial_enrollment_state_request);
  private:
  const ::enterprise_management::DeviceInitialEnrollmentStateRequest& _internal_device_initial_enrollment_state_request() const;
  ::enterprise_management::DeviceInitialEnrollmentStateRequest* _internal_mutable_device_initial_enrollment_state_request();
  public:
  void unsafe_arena_set_allocated_device_initial_enrollment_state_request(
      ::enterprise_management::DeviceInitialEnrollmentStateRequest* device_initial_enrollment_state_request);
  ::enterprise_management::DeviceInitialEnrollmentStateRequest* unsafe_arena_release_device_initial_enrollment_state_request();

  // optional .enterprise_management.RefreshAccountRequest refresh_account_request = 29;
  bool has_refresh_account_request() const;
  private:
  bool _internal_has_refresh_account_request() const;
  public:
  void clear_refresh_account_request();
  const ::enterprise_management::RefreshAccountRequest& refresh_account_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::RefreshAccountRequest* release_refresh_account_request();
  ::enterprise_management::RefreshAccountRequest* mutable_refresh_account_request();
  void set_allocated_refresh_account_request(::enterprise_management::RefreshAccountRequest* refresh_account_request);
  private:
  const ::enterprise_management::RefreshAccountRequest& _internal_refresh_account_request() const;
  ::enterprise_management::RefreshAccountRequest* _internal_mutable_refresh_account_request();
  public:
  void unsafe_arena_set_allocated_refresh_account_request(
      ::enterprise_management::RefreshAccountRequest* refresh_account_request);
  ::enterprise_management::RefreshAccountRequest* unsafe_arena_release_refresh_account_request();

  // optional .enterprise_management.ChildStatusReportRequest child_status_report_request = 30;
  bool has_child_status_report_request() const;
  private:
  bool _internal_has_child_status_report_request() const;
  public:
  void clear_child_status_report_request();
  const ::enterprise_management::ChildStatusReportRequest& child_status_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChildStatusReportRequest* release_child_status_report_request();
  ::enterprise_management::ChildStatusReportRequest* mutable_child_status_report_request();
  void set_allocated_child_status_report_request(::enterprise_management::ChildStatusReportRequest* child_status_report_request);
  private:
  const ::enterprise_management::ChildStatusReportRequest& _internal_child_status_report_request() const;
  ::enterprise_management::ChildStatusReportRequest* _internal_mutable_child_status_report_request();
  public:
  void unsafe_arena_set_allocated_child_status_report_request(
      ::enterprise_management::ChildStatusReportRequest* child_status_report_request);
  ::enterprise_management::ChildStatusReportRequest* unsafe_arena_release_child_status_report_request();

  // optional .enterprise_management.RsuLookupKeyUploadRequest rsu_lookup_key_upload_request = 31;
  bool has_rsu_lookup_key_upload_request() const;
  private:
  bool _internal_has_rsu_lookup_key_upload_request() const;
  public:
  void clear_rsu_lookup_key_upload_request();
  const ::enterprise_management::RsuLookupKeyUploadRequest& rsu_lookup_key_upload_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::RsuLookupKeyUploadRequest* release_rsu_lookup_key_upload_request();
  ::enterprise_management::RsuLookupKeyUploadRequest* mutable_rsu_lookup_key_upload_request();
  void set_allocated_rsu_lookup_key_upload_request(::enterprise_management::RsuLookupKeyUploadRequest* rsu_lookup_key_upload_request);
  private:
  const ::enterprise_management::RsuLookupKeyUploadRequest& _internal_rsu_lookup_key_upload_request() const;
  ::enterprise_management::RsuLookupKeyUploadRequest* _internal_mutable_rsu_lookup_key_upload_request();
  public:
  void unsafe_arena_set_allocated_rsu_lookup_key_upload_request(
      ::enterprise_management::RsuLookupKeyUploadRequest* rsu_lookup_key_upload_request);
  ::enterprise_management::RsuLookupKeyUploadRequest* unsafe_arena_release_rsu_lookup_key_upload_request();

  // optional .enterprise_management.PublicSamlUserRequest public_saml_user_request = 32;
  bool has_public_saml_user_request() const;
  private:
  bool _internal_has_public_saml_user_request() const;
  public:
  void clear_public_saml_user_request();
  const ::enterprise_management::PublicSamlUserRequest& public_saml_user_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::PublicSamlUserRequest* release_public_saml_user_request();
  ::enterprise_management::PublicSamlUserRequest* mutable_public_saml_user_request();
  void set_allocated_public_saml_user_request(::enterprise_management::PublicSamlUserRequest* public_saml_user_request);
  private:
  const ::enterprise_management::PublicSamlUserRequest& _internal_public_saml_user_request() const;
  ::enterprise_management::PublicSamlUserRequest* _internal_mutable_public_saml_user_request();
  public:
  void unsafe_arena_set_allocated_public_saml_user_request(
      ::enterprise_management::PublicSamlUserRequest* public_saml_user_request);
  ::enterprise_management::PublicSamlUserRequest* unsafe_arena_release_public_saml_user_request();

  // optional .enterprise_management.ChromeOsUserReportRequest chrome_os_user_report_request = 33;
  bool has_chrome_os_user_report_request() const;
  private:
  bool _internal_has_chrome_os_user_report_request() const;
  public:
  void clear_chrome_os_user_report_request();
  const ::enterprise_management::ChromeOsUserReportRequest& chrome_os_user_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChromeOsUserReportRequest* release_chrome_os_user_report_request();
  ::enterprise_management::ChromeOsUserReportRequest* mutable_chrome_os_user_report_request();
  void set_allocated_chrome_os_user_report_request(::enterprise_management::ChromeOsUserReportRequest* chrome_os_user_report_request);
  private:
  const ::enterprise_management::ChromeOsUserReportRequest& _internal_chrome_os_user_report_request() const;
  ::enterprise_management::ChromeOsUserReportRequest* _internal_mutable_chrome_os_user_report_request();
  public:
  void unsafe_arena_set_allocated_chrome_os_user_report_request(
      ::enterprise_management::ChromeOsUserReportRequest* chrome_os_user_report_request);
  ::enterprise_management::ChromeOsUserReportRequest* unsafe_arena_release_chrome_os_user_report_request();

  // optional .enterprise_management.ClientCertificateProvisioningRequest client_certificate_provisioning_request = 34;
  bool has_client_certificate_provisioning_request() const;
  private:
  bool _internal_has_client_certificate_provisioning_request() const;
  public:
  void clear_client_certificate_provisioning_request();
  const ::enterprise_management::ClientCertificateProvisioningRequest& client_certificate_provisioning_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ClientCertificateProvisioningRequest* release_client_certificate_provisioning_request();
  ::enterprise_management::ClientCertificateProvisioningRequest* mutable_client_certificate_provisioning_request();
  void set_allocated_client_certificate_provisioning_request(::enterprise_management::ClientCertificateProvisioningRequest* client_certificate_provisioning_request);
  private:
  const ::enterprise_management::ClientCertificateProvisioningRequest& _internal_client_certificate_provisioning_request() const;
  ::enterprise_management::ClientCertificateProvisioningRequest* _internal_mutable_client_certificate_provisioning_request();
  public:
  void unsafe_arena_set_allocated_client_certificate_provisioning_request(
      ::enterprise_management::ClientCertificateProvisioningRequest* client_certificate_provisioning_request);
  ::enterprise_management::ClientCertificateProvisioningRequest* unsafe_arena_release_client_certificate_provisioning_request();

  // optional .enterprise_management.ExtensionInstallReportRequest extension_install_report_request = 35;
  bool has_extension_install_report_request() const;
  private:
  bool _internal_has_extension_install_report_request() const;
  public:
  void clear_extension_install_report_request();
  const ::enterprise_management::ExtensionInstallReportRequest& extension_install_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ExtensionInstallReportRequest* release_extension_install_report_request();
  ::enterprise_management::ExtensionInstallReportRequest* mutable_extension_install_report_request();
  void set_allocated_extension_install_report_request(::enterprise_management::ExtensionInstallReportRequest* extension_install_report_request);
  private:
  const ::enterprise_management::ExtensionInstallReportRequest& _internal_extension_install_report_request() const;
  ::enterprise_management::ExtensionInstallReportRequest* _internal_mutable_extension_install_report_request();
  public:
  void unsafe_arena_set_allocated_extension_install_report_request(
      ::enterprise_management::ExtensionInstallReportRequest* extension_install_report_request);
  ::enterprise_management::ExtensionInstallReportRequest* unsafe_arena_release_extension_install_report_request();

  // optional .enterprise_management.CheckUserAccountRequest check_user_account_request = 36;
  bool has_check_user_account_request() const;
  private:
  bool _internal_has_check_user_account_request() const;
  public:
  void clear_check_user_account_request();
  const ::enterprise_management::CheckUserAccountRequest& check_user_account_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::CheckUserAccountRequest* release_check_user_account_request();
  ::enterprise_management::CheckUserAccountRequest* mutable_check_user_account_request();
  void set_allocated_check_user_account_request(::enterprise_management::CheckUserAccountRequest* check_user_account_request);
  private:
  const ::enterprise_management::CheckUserAccountRequest& _internal_check_user_account_request() const;
  ::enterprise_management::CheckUserAccountRequest* _internal_mutable_check_user_account_request();
  public:
  void unsafe_arena_set_allocated_check_user_account_request(
      ::enterprise_management::CheckUserAccountRequest* check_user_account_request);
  ::enterprise_management::CheckUserAccountRequest* unsafe_arena_release_check_user_account_request();

  // optional .enterprise_management.PrivateSetMembershipRequest private_set_membership_request = 37;
  bool has_private_set_membership_request() const;
  private:
  bool _internal_has_private_set_membership_request() const;
  public:
  void clear_private_set_membership_request();
  const ::enterprise_management::PrivateSetMembershipRequest& private_set_membership_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::PrivateSetMembershipRequest* release_private_set_membership_request();
  ::enterprise_management::PrivateSetMembershipRequest* mutable_private_set_membership_request();
  void set_allocated_private_set_membership_request(::enterprise_management::PrivateSetMembershipRequest* private_set_membership_request);
  private:
  const ::enterprise_management::PrivateSetMembershipRequest& _internal_private_set_membership_request() const;
  ::enterprise_management::PrivateSetMembershipRequest* _internal_mutable_private_set_membership_request();
  public:
  void unsafe_arena_set_allocated_private_set_membership_request(
      ::enterprise_management::PrivateSetMembershipRequest* private_set_membership_request);
  ::enterprise_management::PrivateSetMembershipRequest* unsafe_arena_release_private_set_membership_request();

  // optional .enterprise_management.BrowserPublicKeyUploadRequest browser_public_key_upload_request = 38;
  bool has_browser_public_key_upload_request() const;
  private:
  bool _internal_has_browser_public_key_upload_request() const;
  public:
  void clear_browser_public_key_upload_request();
  const ::enterprise_management::BrowserPublicKeyUploadRequest& browser_public_key_upload_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserPublicKeyUploadRequest* release_browser_public_key_upload_request();
  ::enterprise_management::BrowserPublicKeyUploadRequest* mutable_browser_public_key_upload_request();
  void set_allocated_browser_public_key_upload_request(::enterprise_management::BrowserPublicKeyUploadRequest* browser_public_key_upload_request);
  private:
  const ::enterprise_management::BrowserPublicKeyUploadRequest& _internal_browser_public_key_upload_request() const;
  ::enterprise_management::BrowserPublicKeyUploadRequest* _internal_mutable_browser_public_key_upload_request();
  public:
  void unsafe_arena_set_allocated_browser_public_key_upload_request(
      ::enterprise_management::BrowserPublicKeyUploadRequest* browser_public_key_upload_request);
  ::enterprise_management::BrowserPublicKeyUploadRequest* unsafe_arena_release_browser_public_key_upload_request();

  // optional .enterprise_management.UploadEuiccInfoRequest upload_euicc_info_request = 39;
  bool has_upload_euicc_info_request() const;
  private:
  bool _internal_has_upload_euicc_info_request() const;
  public:
  void clear_upload_euicc_info_request();
  const ::enterprise_management::UploadEuiccInfoRequest& upload_euicc_info_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::UploadEuiccInfoRequest* release_upload_euicc_info_request();
  ::enterprise_management::UploadEuiccInfoRequest* mutable_upload_euicc_info_request();
  void set_allocated_upload_euicc_info_request(::enterprise_management::UploadEuiccInfoRequest* upload_euicc_info_request);
  private:
  const ::enterprise_management::UploadEuiccInfoRequest& _internal_upload_euicc_info_request() const;
  ::enterprise_management::UploadEuiccInfoRequest* _internal_mutable_upload_euicc_info_request();
  public:
  void unsafe_arena_set_allocated_upload_euicc_info_request(
      ::enterprise_management::UploadEuiccInfoRequest* upload_euicc_info_request);
  ::enterprise_management::UploadEuiccInfoRequest* unsafe_arena_release_upload_euicc_info_request();

  // optional .enterprise_management.ChromeProfileReportRequest chrome_profile_report_request = 40;
  bool has_chrome_profile_report_request() const;
  private:
  bool _internal_has_chrome_profile_report_request() const;
  public:
  void clear_chrome_profile_report_request();
  const ::enterprise_management::ChromeProfileReportRequest& chrome_profile_report_request() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChromeProfileReportRequest* release_chrome_profile_report_request();
  ::enterprise_management::ChromeProfileReportRequest* mutable_chrome_profile_report_request();
  void set_allocated_chrome_profile_report_request(::enterprise_management::ChromeProfileReportRequest* chrome_profile_report_request);
  private:
  const ::enterprise_management::ChromeProfileReportRequest& _internal_chrome_profile_report_request() const;
  ::enterprise_management::ChromeProfileReportRequest* _internal_mutable_chrome_profile_report_request();
  public:
  void unsafe_arena_set_allocated_chrome_profile_report_request(
      ::enterprise_management::ChromeProfileReportRequest* chrome_profile_report_request);
  ::enterprise_management::ChromeProfileReportRequest* unsafe_arena_release_chrome_profile_report_request();

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceManagementRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::enterprise_management::DeviceRegisterRequest* register_request_;
    ::enterprise_management::DeviceUnregisterRequest* unregister_request_;
    ::enterprise_management::DevicePolicyRequest* policy_request_;
    ::enterprise_management::DeviceStatusReportRequest* device_status_report_request_;
    ::enterprise_management::SessionStatusReportRequest* session_status_report_request_;
    ::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request_;
    ::enterprise_management::DeviceCertUploadRequest* cert_upload_request_;
    ::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request_;
    ::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request_;
    ::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request_;
    ::enterprise_management::DevicePairingRequest* device_pairing_request_;
    ::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request_;
    ::enterprise_management::DeviceRemoteCommandRequest* remote_command_request_;
    ::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request_;
    ::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request_;
    ::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request_;
    ::enterprise_management::CheckAndroidManagementRequest* check_android_management_request_;
    ::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request_;
    ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* active_directory_enroll_play_user_request_;
    ::enterprise_management::ActiveDirectoryPlayActivityRequest* active_directory_play_activity_request_;
    ::enterprise_management::CheckDeviceLicenseRequest* check_device_license_request_deprecated_;
    ::enterprise_management::ActiveDirectoryUserSigninRequest* active_directory_user_signin_request_;
    ::enterprise_management::RegisterBrowserRequest* register_browser_request_;
    ::enterprise_management::AppInstallReportRequest* app_install_report_request_;
    ::enterprise_management::ChromeDesktopReportRequest* chrome_desktop_report_request_;
    ::enterprise_management::PolicyValidationReportRequest* policy_validation_report_request_;
    ::enterprise_management::DeviceInitialEnrollmentStateRequest* device_initial_enrollment_state_request_;
    ::enterprise_management::RefreshAccountRequest* refresh_account_request_;
    ::enterprise_management::ChildStatusReportRequest* child_status_report_request_;
    ::enterprise_management::RsuLookupKeyUploadRequest* rsu_lookup_key_upload_request_;
    ::enterprise_management::PublicSamlUserRequest* public_saml_user_request_;
    ::enterprise_management::ChromeOsUserReportRequest* chrome_os_user_report_request_;
    ::enterprise_management::ClientCertificateProvisioningRequest* client_certificate_provisioning_request_;
    ::enterprise_management::ExtensionInstallReportRequest* extension_install_report_request_;
    ::enterprise_management::CheckUserAccountRequest* check_user_account_request_;
    ::enterprise_management::PrivateSetMembershipRequest* private_set_membership_request_;
    ::enterprise_management::BrowserPublicKeyUploadRequest* browser_public_key_upload_request_;
    ::enterprise_management::UploadEuiccInfoRequest* upload_euicc_info_request_;
    ::enterprise_management::ChromeProfileReportRequest* chrome_profile_report_request_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceManagementResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceManagementResponse) */ {
 public:
  inline DeviceManagementResponse() : DeviceManagementResponse(nullptr) {}
  ~DeviceManagementResponse() override;
  explicit PROTOBUF_CONSTEXPR DeviceManagementResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceManagementResponse(const DeviceManagementResponse& from);
  DeviceManagementResponse(DeviceManagementResponse&& from) noexcept
    : DeviceManagementResponse() {
    *this = ::std::move(from);
  }

  inline DeviceManagementResponse& operator=(const DeviceManagementResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceManagementResponse& operator=(DeviceManagementResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceManagementResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceManagementResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceManagementResponse*>(
               &_DeviceManagementResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    186;

  friend void swap(DeviceManagementResponse& a, DeviceManagementResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceManagementResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceManagementResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceManagementResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceManagementResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceManagementResponse& from);
  void MergeFrom(const DeviceManagementResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceManagementResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceManagementResponse";
  }
  protected:
  explicit DeviceManagementResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDetailFieldNumber = 39,
    kErrorMessageFieldNumber = 2,
    kRegisterResponseFieldNumber = 3,
    kUnregisterResponseFieldNumber = 4,
    kPolicyResponseFieldNumber = 5,
    kDeviceStatusReportResponseFieldNumber = 6,
    kSessionStatusReportResponseFieldNumber = 7,
    kAutoEnrollmentResponseFieldNumber = 8,
    kCertUploadResponseFieldNumber = 9,
    kServiceApiAccessResponseFieldNumber = 10,
    kDeviceStateRetrievalResponseFieldNumber = 11,
    kDevicePairingResponseFieldNumber = 12,
    kCheckDevicePairingResponseFieldNumber = 13,
    kRemoteCommandResponseFieldNumber = 14,
    kDeviceAttributeUpdatePermissionResponseFieldNumber = 15,
    kDeviceAttributeUpdateResponseFieldNumber = 16,
    kGcmIdUpdateResponseFieldNumber = 17,
    kCheckAndroidManagementResponseFieldNumber = 18,
    kActiveDirectoryEnrollPlayUserResponseFieldNumber = 19,
    kActiveDirectoryPlayActivityResponseFieldNumber = 20,
    kCheckDeviceLicenseResponseDeprecatedFieldNumber = 21,
    kActiveDirectoryUserSigninResponseFieldNumber = 22,
    kChromeDesktopReportResponseFieldNumber = 23,
    kAppInstallReportResponseFieldNumber = 25,
    kPolicyValidationReportResponseFieldNumber = 26,
    kDeviceInitialEnrollmentStateResponseFieldNumber = 27,
    kRefreshAccountResponseFieldNumber = 28,
    kChildStatusReportResponseFieldNumber = 29,
    kRsuLookupKeyUploadResponseFieldNumber = 30,
    kPublicSamlUserResponseFieldNumber = 31,
    kChromeOsUserReportResponseFieldNumber = 32,
    kClientCertificateProvisioningResponseFieldNumber = 33,
    kCheckUserAccountResponseFieldNumber = 34,
    kPrivateSetMembershipResponseFieldNumber = 35,
    kBrowserPublicKeyUploadResponseFieldNumber = 36,
    kUploadEuiccInfoResponseFieldNumber = 37,
    kChromeProfileReportResponseFieldNumber = 38,
  };
  // repeated .enterprise_management.DeviceManagementErrorDetail error_detail = 39;
  int error_detail_size() const;
  private:
  int _internal_error_detail_size() const;
  public:
  void clear_error_detail();
  private:
  ::enterprise_management::DeviceManagementErrorDetail _internal_error_detail(int index) const;
  void _internal_add_error_detail(::enterprise_management::DeviceManagementErrorDetail value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_error_detail();
  public:
  ::enterprise_management::DeviceManagementErrorDetail error_detail(int index) const;
  void set_error_detail(int index, ::enterprise_management::DeviceManagementErrorDetail value);
  void add_error_detail(::enterprise_management::DeviceManagementErrorDetail value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& error_detail() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_error_detail();

  // optional string error_message = 2;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional .enterprise_management.DeviceRegisterResponse register_response = 3;
  bool has_register_response() const;
  private:
  bool _internal_has_register_response() const;
  public:
  void clear_register_response();
  const ::enterprise_management::DeviceRegisterResponse& register_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRegisterResponse* release_register_response();
  ::enterprise_management::DeviceRegisterResponse* mutable_register_response();
  void set_allocated_register_response(::enterprise_management::DeviceRegisterResponse* register_response);
  private:
  const ::enterprise_management::DeviceRegisterResponse& _internal_register_response() const;
  ::enterprise_management::DeviceRegisterResponse* _internal_mutable_register_response();
  public:
  void unsafe_arena_set_allocated_register_response(
      ::enterprise_management::DeviceRegisterResponse* register_response);
  ::enterprise_management::DeviceRegisterResponse* unsafe_arena_release_register_response();

  // optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
  bool has_unregister_response() const;
  private:
  bool _internal_has_unregister_response() const;
  public:
  void clear_unregister_response();
  const ::enterprise_management::DeviceUnregisterResponse& unregister_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceUnregisterResponse* release_unregister_response();
  ::enterprise_management::DeviceUnregisterResponse* mutable_unregister_response();
  void set_allocated_unregister_response(::enterprise_management::DeviceUnregisterResponse* unregister_response);
  private:
  const ::enterprise_management::DeviceUnregisterResponse& _internal_unregister_response() const;
  ::enterprise_management::DeviceUnregisterResponse* _internal_mutable_unregister_response();
  public:
  void unsafe_arena_set_allocated_unregister_response(
      ::enterprise_management::DeviceUnregisterResponse* unregister_response);
  ::enterprise_management::DeviceUnregisterResponse* unsafe_arena_release_unregister_response();

  // optional .enterprise_management.DevicePolicyResponse policy_response = 5;
  bool has_policy_response() const;
  private:
  bool _internal_has_policy_response() const;
  public:
  void clear_policy_response();
  const ::enterprise_management::DevicePolicyResponse& policy_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePolicyResponse* release_policy_response();
  ::enterprise_management::DevicePolicyResponse* mutable_policy_response();
  void set_allocated_policy_response(::enterprise_management::DevicePolicyResponse* policy_response);
  private:
  const ::enterprise_management::DevicePolicyResponse& _internal_policy_response() const;
  ::enterprise_management::DevicePolicyResponse* _internal_mutable_policy_response();
  public:
  void unsafe_arena_set_allocated_policy_response(
      ::enterprise_management::DevicePolicyResponse* policy_response);
  ::enterprise_management::DevicePolicyResponse* unsafe_arena_release_policy_response();

  // optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
  bool has_device_status_report_response() const;
  private:
  bool _internal_has_device_status_report_response() const;
  public:
  void clear_device_status_report_response();
  const ::enterprise_management::DeviceStatusReportResponse& device_status_report_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceStatusReportResponse* release_device_status_report_response();
  ::enterprise_management::DeviceStatusReportResponse* mutable_device_status_report_response();
  void set_allocated_device_status_report_response(::enterprise_management::DeviceStatusReportResponse* device_status_report_response);
  private:
  const ::enterprise_management::DeviceStatusReportResponse& _internal_device_status_report_response() const;
  ::enterprise_management::DeviceStatusReportResponse* _internal_mutable_device_status_report_response();
  public:
  void unsafe_arena_set_allocated_device_status_report_response(
      ::enterprise_management::DeviceStatusReportResponse* device_status_report_response);
  ::enterprise_management::DeviceStatusReportResponse* unsafe_arena_release_device_status_report_response();

  // optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
  bool has_session_status_report_response() const;
  private:
  bool _internal_has_session_status_report_response() const;
  public:
  void clear_session_status_report_response();
  const ::enterprise_management::SessionStatusReportResponse& session_status_report_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::SessionStatusReportResponse* release_session_status_report_response();
  ::enterprise_management::SessionStatusReportResponse* mutable_session_status_report_response();
  void set_allocated_session_status_report_response(::enterprise_management::SessionStatusReportResponse* session_status_report_response);
  private:
  const ::enterprise_management::SessionStatusReportResponse& _internal_session_status_report_response() const;
  ::enterprise_management::SessionStatusReportResponse* _internal_mutable_session_status_report_response();
  public:
  void unsafe_arena_set_allocated_session_status_report_response(
      ::enterprise_management::SessionStatusReportResponse* session_status_report_response);
  ::enterprise_management::SessionStatusReportResponse* unsafe_arena_release_session_status_report_response();

  // optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
  bool has_auto_enrollment_response() const;
  private:
  bool _internal_has_auto_enrollment_response() const;
  public:
  void clear_auto_enrollment_response();
  const ::enterprise_management::DeviceAutoEnrollmentResponse& auto_enrollment_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAutoEnrollmentResponse* release_auto_enrollment_response();
  ::enterprise_management::DeviceAutoEnrollmentResponse* mutable_auto_enrollment_response();
  void set_allocated_auto_enrollment_response(::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response);
  private:
  const ::enterprise_management::DeviceAutoEnrollmentResponse& _internal_auto_enrollment_response() const;
  ::enterprise_management::DeviceAutoEnrollmentResponse* _internal_mutable_auto_enrollment_response();
  public:
  void unsafe_arena_set_allocated_auto_enrollment_response(
      ::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response);
  ::enterprise_management::DeviceAutoEnrollmentResponse* unsafe_arena_release_auto_enrollment_response();

  // optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
  bool has_cert_upload_response() const;
  private:
  bool _internal_has_cert_upload_response() const;
  public:
  void clear_cert_upload_response();
  const ::enterprise_management::DeviceCertUploadResponse& cert_upload_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceCertUploadResponse* release_cert_upload_response();
  ::enterprise_management::DeviceCertUploadResponse* mutable_cert_upload_response();
  void set_allocated_cert_upload_response(::enterprise_management::DeviceCertUploadResponse* cert_upload_response);
  private:
  const ::enterprise_management::DeviceCertUploadResponse& _internal_cert_upload_response() const;
  ::enterprise_management::DeviceCertUploadResponse* _internal_mutable_cert_upload_response();
  public:
  void unsafe_arena_set_allocated_cert_upload_response(
      ::enterprise_management::DeviceCertUploadResponse* cert_upload_response);
  ::enterprise_management::DeviceCertUploadResponse* unsafe_arena_release_cert_upload_response();

  // optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
  bool has_service_api_access_response() const;
  private:
  bool _internal_has_service_api_access_response() const;
  public:
  void clear_service_api_access_response();
  const ::enterprise_management::DeviceServiceApiAccessResponse& service_api_access_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceServiceApiAccessResponse* release_service_api_access_response();
  ::enterprise_management::DeviceServiceApiAccessResponse* mutable_service_api_access_response();
  void set_allocated_service_api_access_response(::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response);
  private:
  const ::enterprise_management::DeviceServiceApiAccessResponse& _internal_service_api_access_response() const;
  ::enterprise_management::DeviceServiceApiAccessResponse* _internal_mutable_service_api_access_response();
  public:
  void unsafe_arena_set_allocated_service_api_access_response(
      ::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response);
  ::enterprise_management::DeviceServiceApiAccessResponse* unsafe_arena_release_service_api_access_response();

  // optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
  bool has_device_state_retrieval_response() const;
  private:
  bool _internal_has_device_state_retrieval_response() const;
  public:
  void clear_device_state_retrieval_response();
  const ::enterprise_management::DeviceStateRetrievalResponse& device_state_retrieval_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceStateRetrievalResponse* release_device_state_retrieval_response();
  ::enterprise_management::DeviceStateRetrievalResponse* mutable_device_state_retrieval_response();
  void set_allocated_device_state_retrieval_response(::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response);
  private:
  const ::enterprise_management::DeviceStateRetrievalResponse& _internal_device_state_retrieval_response() const;
  ::enterprise_management::DeviceStateRetrievalResponse* _internal_mutable_device_state_retrieval_response();
  public:
  void unsafe_arena_set_allocated_device_state_retrieval_response(
      ::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response);
  ::enterprise_management::DeviceStateRetrievalResponse* unsafe_arena_release_device_state_retrieval_response();

  // optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
  bool has_device_pairing_response() const;
  private:
  bool _internal_has_device_pairing_response() const;
  public:
  void clear_device_pairing_response();
  const ::enterprise_management::DevicePairingResponse& device_pairing_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DevicePairingResponse* release_device_pairing_response();
  ::enterprise_management::DevicePairingResponse* mutable_device_pairing_response();
  void set_allocated_device_pairing_response(::enterprise_management::DevicePairingResponse* device_pairing_response);
  private:
  const ::enterprise_management::DevicePairingResponse& _internal_device_pairing_response() const;
  ::enterprise_management::DevicePairingResponse* _internal_mutable_device_pairing_response();
  public:
  void unsafe_arena_set_allocated_device_pairing_response(
      ::enterprise_management::DevicePairingResponse* device_pairing_response);
  ::enterprise_management::DevicePairingResponse* unsafe_arena_release_device_pairing_response();

  // optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
  bool has_check_device_pairing_response() const;
  private:
  bool _internal_has_check_device_pairing_response() const;
  public:
  void clear_check_device_pairing_response();
  const ::enterprise_management::CheckDevicePairingResponse& check_device_pairing_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::CheckDevicePairingResponse* release_check_device_pairing_response();
  ::enterprise_management::CheckDevicePairingResponse* mutable_check_device_pairing_response();
  void set_allocated_check_device_pairing_response(::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response);
  private:
  const ::enterprise_management::CheckDevicePairingResponse& _internal_check_device_pairing_response() const;
  ::enterprise_management::CheckDevicePairingResponse* _internal_mutable_check_device_pairing_response();
  public:
  void unsafe_arena_set_allocated_check_device_pairing_response(
      ::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response);
  ::enterprise_management::CheckDevicePairingResponse* unsafe_arena_release_check_device_pairing_response();

  // optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
  bool has_remote_command_response() const;
  private:
  bool _internal_has_remote_command_response() const;
  public:
  void clear_remote_command_response();
  const ::enterprise_management::DeviceRemoteCommandResponse& remote_command_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceRemoteCommandResponse* release_remote_command_response();
  ::enterprise_management::DeviceRemoteCommandResponse* mutable_remote_command_response();
  void set_allocated_remote_command_response(::enterprise_management::DeviceRemoteCommandResponse* remote_command_response);
  private:
  const ::enterprise_management::DeviceRemoteCommandResponse& _internal_remote_command_response() const;
  ::enterprise_management::DeviceRemoteCommandResponse* _internal_mutable_remote_command_response();
  public:
  void unsafe_arena_set_allocated_remote_command_response(
      ::enterprise_management::DeviceRemoteCommandResponse* remote_command_response);
  ::enterprise_management::DeviceRemoteCommandResponse* unsafe_arena_release_remote_command_response();

  // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
  bool has_device_attribute_update_permission_response() const;
  private:
  bool _internal_has_device_attribute_update_permission_response() const;
  public:
  void clear_device_attribute_update_permission_response();
  const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& device_attribute_update_permission_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAttributeUpdatePermissionResponse* release_device_attribute_update_permission_response();
  ::enterprise_management::DeviceAttributeUpdatePermissionResponse* mutable_device_attribute_update_permission_response();
  void set_allocated_device_attribute_update_permission_response(::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response);
  private:
  const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& _internal_device_attribute_update_permission_response() const;
  ::enterprise_management::DeviceAttributeUpdatePermissionResponse* _internal_mutable_device_attribute_update_permission_response();
  public:
  void unsafe_arena_set_allocated_device_attribute_update_permission_response(
      ::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response);
  ::enterprise_management::DeviceAttributeUpdatePermissionResponse* unsafe_arena_release_device_attribute_update_permission_response();

  // optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
  bool has_device_attribute_update_response() const;
  private:
  bool _internal_has_device_attribute_update_response() const;
  public:
  void clear_device_attribute_update_response();
  const ::enterprise_management::DeviceAttributeUpdateResponse& device_attribute_update_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceAttributeUpdateResponse* release_device_attribute_update_response();
  ::enterprise_management::DeviceAttributeUpdateResponse* mutable_device_attribute_update_response();
  void set_allocated_device_attribute_update_response(::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response);
  private:
  const ::enterprise_management::DeviceAttributeUpdateResponse& _internal_device_attribute_update_response() const;
  ::enterprise_management::DeviceAttributeUpdateResponse* _internal_mutable_device_attribute_update_response();
  public:
  void unsafe_arena_set_allocated_device_attribute_update_response(
      ::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response);
  ::enterprise_management::DeviceAttributeUpdateResponse* unsafe_arena_release_device_attribute_update_response();

  // optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
  bool has_gcm_id_update_response() const;
  private:
  bool _internal_has_gcm_id_update_response() const;
  public:
  void clear_gcm_id_update_response();
  const ::enterprise_management::GcmIdUpdateResponse& gcm_id_update_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::GcmIdUpdateResponse* release_gcm_id_update_response();
  ::enterprise_management::GcmIdUpdateResponse* mutable_gcm_id_update_response();
  void set_allocated_gcm_id_update_response(::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response);
  private:
  const ::enterprise_management::GcmIdUpdateResponse& _internal_gcm_id_update_response() const;
  ::enterprise_management::GcmIdUpdateResponse* _internal_mutable_gcm_id_update_response();
  public:
  void unsafe_arena_set_allocated_gcm_id_update_response(
      ::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response);
  ::enterprise_management::GcmIdUpdateResponse* unsafe_arena_release_gcm_id_update_response();

  // optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
  bool has_check_android_management_response() const;
  private:
  bool _internal_has_check_android_management_response() const;
  public:
  void clear_check_android_management_response();
  const ::enterprise_management::CheckAndroidManagementResponse& check_android_management_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::CheckAndroidManagementResponse* release_check_android_management_response();
  ::enterprise_management::CheckAndroidManagementResponse* mutable_check_android_management_response();
  void set_allocated_check_android_management_response(::enterprise_management::CheckAndroidManagementResponse* check_android_management_response);
  private:
  const ::enterprise_management::CheckAndroidManagementResponse& _internal_check_android_management_response() const;
  ::enterprise_management::CheckAndroidManagementResponse* _internal_mutable_check_android_management_response();
  public:
  void unsafe_arena_set_allocated_check_android_management_response(
      ::enterprise_management::CheckAndroidManagementResponse* check_android_management_response);
  ::enterprise_management::CheckAndroidManagementResponse* unsafe_arena_release_check_android_management_response();

  // optional .enterprise_management.ActiveDirectoryEnrollPlayUserResponse active_directory_enroll_play_user_response = 19;
  bool has_active_directory_enroll_play_user_response() const;
  private:
  bool _internal_has_active_directory_enroll_play_user_response() const;
  public:
  void clear_active_directory_enroll_play_user_response();
  const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse& active_directory_enroll_play_user_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* release_active_directory_enroll_play_user_response();
  ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* mutable_active_directory_enroll_play_user_response();
  void set_allocated_active_directory_enroll_play_user_response(::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* active_directory_enroll_play_user_response);
  private:
  const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse& _internal_active_directory_enroll_play_user_response() const;
  ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* _internal_mutable_active_directory_enroll_play_user_response();
  public:
  void unsafe_arena_set_allocated_active_directory_enroll_play_user_response(
      ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* active_directory_enroll_play_user_response);
  ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* unsafe_arena_release_active_directory_enroll_play_user_response();

  // optional .enterprise_management.ActiveDirectoryPlayActivityResponse active_directory_play_activity_response = 20;
  bool has_active_directory_play_activity_response() const;
  private:
  bool _internal_has_active_directory_play_activity_response() const;
  public:
  void clear_active_directory_play_activity_response();
  const ::enterprise_management::ActiveDirectoryPlayActivityResponse& active_directory_play_activity_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::ActiveDirectoryPlayActivityResponse* release_active_directory_play_activity_response();
  ::enterprise_management::ActiveDirectoryPlayActivityResponse* mutable_active_directory_play_activity_response();
  void set_allocated_active_directory_play_activity_response(::enterprise_management::ActiveDirectoryPlayActivityResponse* active_directory_play_activity_response);
  private:
  const ::enterprise_management::ActiveDirectoryPlayActivityResponse& _internal_active_directory_play_activity_response() const;
  ::enterprise_management::ActiveDirectoryPlayActivityResponse* _internal_mutable_active_directory_play_activity_response();
  public:
  void unsafe_arena_set_allocated_active_directory_play_activity_response(
      ::enterprise_management::ActiveDirectoryPlayActivityResponse* active_directory_play_activity_response);
  ::enterprise_management::ActiveDirectoryPlayActivityResponse* unsafe_arena_release_active_directory_play_activity_response();

  // optional .enterprise_management.CheckDeviceLicenseResponse check_device_license_response_deprecated = 21 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_check_device_license_response_deprecated() const;
  private:
  bool _internal_has_check_device_license_response_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_check_device_license_response_deprecated();
  PROTOBUF_DEPRECATED const ::enterprise_management::CheckDeviceLicenseResponse& check_device_license_response_deprecated() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseResponse* release_check_device_license_response_deprecated();
  PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseResponse* mutable_check_device_license_response_deprecated();
  PROTOBUF_DEPRECATED void set_allocated_check_device_license_response_deprecated(::enterprise_management::CheckDeviceLicenseResponse* check_device_license_response_deprecated);
  private:
  const ::enterprise_management::CheckDeviceLicenseResponse& _internal_check_device_license_response_deprecated() const;
  ::enterprise_management::CheckDeviceLicenseResponse* _internal_mutable_check_device_license_response_deprecated();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_check_device_license_response_deprecated(
      ::enterprise_management::CheckDeviceLicenseResponse* check_device_license_response_deprecated);
  PROTOBUF_DEPRECATED ::enterprise_management::CheckDeviceLicenseResponse* unsafe_arena_release_check_device_license_response_deprecated();

  // optional .enterprise_management.ActiveDirectoryUserSigninResponse active_directory_user_signin_response = 22;
  bool has_active_directory_user_signin_response() const;
  private:
  bool _internal_has_active_directory_user_signin_response() const;
  public:
  void clear_active_directory_user_signin_response();
  const ::enterprise_management::ActiveDirectoryUserSigninResponse& active_directory_user_signin_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::ActiveDirectoryUserSigninResponse* release_active_directory_user_signin_response();
  ::enterprise_management::ActiveDirectoryUserSigninResponse* mutable_active_directory_user_signin_response();
  void set_allocated_active_directory_user_signin_response(::enterprise_management::ActiveDirectoryUserSigninResponse* active_directory_user_signin_response);
  private:
  const ::enterprise_management::ActiveDirectoryUserSigninResponse& _internal_active_directory_user_signin_response() const;
  ::enterprise_management::ActiveDirectoryUserSigninResponse* _internal_mutable_active_directory_user_signin_response();
  public:
  void unsafe_arena_set_allocated_active_directory_user_signin_response(
      ::enterprise_management::ActiveDirectoryUserSigninResponse* active_directory_user_signin_response);
  ::enterprise_management::ActiveDirectoryUserSigninResponse* unsafe_arena_release_active_directory_user_signin_response();

  // optional .enterprise_management.ChromeDesktopReportResponse chrome_desktop_report_response = 23;
  bool has_chrome_desktop_report_response() const;
  private:
  bool _internal_has_chrome_desktop_report_response() const;
  public:
  void clear_chrome_desktop_report_response();
  const ::enterprise_management::ChromeDesktopReportResponse& chrome_desktop_report_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChromeDesktopReportResponse* release_chrome_desktop_report_response();
  ::enterprise_management::ChromeDesktopReportResponse* mutable_chrome_desktop_report_response();
  void set_allocated_chrome_desktop_report_response(::enterprise_management::ChromeDesktopReportResponse* chrome_desktop_report_response);
  private:
  const ::enterprise_management::ChromeDesktopReportResponse& _internal_chrome_desktop_report_response() const;
  ::enterprise_management::ChromeDesktopReportResponse* _internal_mutable_chrome_desktop_report_response();
  public:
  void unsafe_arena_set_allocated_chrome_desktop_report_response(
      ::enterprise_management::ChromeDesktopReportResponse* chrome_desktop_report_response);
  ::enterprise_management::ChromeDesktopReportResponse* unsafe_arena_release_chrome_desktop_report_response();

  // optional .enterprise_management.AppInstallReportResponse app_install_report_response = 25;
  bool has_app_install_report_response() const;
  private:
  bool _internal_has_app_install_report_response() const;
  public:
  void clear_app_install_report_response();
  const ::enterprise_management::AppInstallReportResponse& app_install_report_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::AppInstallReportResponse* release_app_install_report_response();
  ::enterprise_management::AppInstallReportResponse* mutable_app_install_report_response();
  void set_allocated_app_install_report_response(::enterprise_management::AppInstallReportResponse* app_install_report_response);
  private:
  const ::enterprise_management::AppInstallReportResponse& _internal_app_install_report_response() const;
  ::enterprise_management::AppInstallReportResponse* _internal_mutable_app_install_report_response();
  public:
  void unsafe_arena_set_allocated_app_install_report_response(
      ::enterprise_management::AppInstallReportResponse* app_install_report_response);
  ::enterprise_management::AppInstallReportResponse* unsafe_arena_release_app_install_report_response();

  // optional .enterprise_management.PolicyValidationReportResponse policy_validation_report_response = 26;
  bool has_policy_validation_report_response() const;
  private:
  bool _internal_has_policy_validation_report_response() const;
  public:
  void clear_policy_validation_report_response();
  const ::enterprise_management::PolicyValidationReportResponse& policy_validation_report_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::PolicyValidationReportResponse* release_policy_validation_report_response();
  ::enterprise_management::PolicyValidationReportResponse* mutable_policy_validation_report_response();
  void set_allocated_policy_validation_report_response(::enterprise_management::PolicyValidationReportResponse* policy_validation_report_response);
  private:
  const ::enterprise_management::PolicyValidationReportResponse& _internal_policy_validation_report_response() const;
  ::enterprise_management::PolicyValidationReportResponse* _internal_mutable_policy_validation_report_response();
  public:
  void unsafe_arena_set_allocated_policy_validation_report_response(
      ::enterprise_management::PolicyValidationReportResponse* policy_validation_report_response);
  ::enterprise_management::PolicyValidationReportResponse* unsafe_arena_release_policy_validation_report_response();

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse device_initial_enrollment_state_response = 27;
  bool has_device_initial_enrollment_state_response() const;
  private:
  bool _internal_has_device_initial_enrollment_state_response() const;
  public:
  void clear_device_initial_enrollment_state_response();
  const ::enterprise_management::DeviceInitialEnrollmentStateResponse& device_initial_enrollment_state_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::DeviceInitialEnrollmentStateResponse* release_device_initial_enrollment_state_response();
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* mutable_device_initial_enrollment_state_response();
  void set_allocated_device_initial_enrollment_state_response(::enterprise_management::DeviceInitialEnrollmentStateResponse* device_initial_enrollment_state_response);
  private:
  const ::enterprise_management::DeviceInitialEnrollmentStateResponse& _internal_device_initial_enrollment_state_response() const;
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* _internal_mutable_device_initial_enrollment_state_response();
  public:
  void unsafe_arena_set_allocated_device_initial_enrollment_state_response(
      ::enterprise_management::DeviceInitialEnrollmentStateResponse* device_initial_enrollment_state_response);
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* unsafe_arena_release_device_initial_enrollment_state_response();

  // optional .enterprise_management.RefreshAccountResponse refresh_account_response = 28;
  bool has_refresh_account_response() const;
  private:
  bool _internal_has_refresh_account_response() const;
  public:
  void clear_refresh_account_response();
  const ::enterprise_management::RefreshAccountResponse& refresh_account_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::RefreshAccountResponse* release_refresh_account_response();
  ::enterprise_management::RefreshAccountResponse* mutable_refresh_account_response();
  void set_allocated_refresh_account_response(::enterprise_management::RefreshAccountResponse* refresh_account_response);
  private:
  const ::enterprise_management::RefreshAccountResponse& _internal_refresh_account_response() const;
  ::enterprise_management::RefreshAccountResponse* _internal_mutable_refresh_account_response();
  public:
  void unsafe_arena_set_allocated_refresh_account_response(
      ::enterprise_management::RefreshAccountResponse* refresh_account_response);
  ::enterprise_management::RefreshAccountResponse* unsafe_arena_release_refresh_account_response();

  // optional .enterprise_management.ChildStatusReportResponse child_status_report_response = 29;
  bool has_child_status_report_response() const;
  private:
  bool _internal_has_child_status_report_response() const;
  public:
  void clear_child_status_report_response();
  const ::enterprise_management::ChildStatusReportResponse& child_status_report_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChildStatusReportResponse* release_child_status_report_response();
  ::enterprise_management::ChildStatusReportResponse* mutable_child_status_report_response();
  void set_allocated_child_status_report_response(::enterprise_management::ChildStatusReportResponse* child_status_report_response);
  private:
  const ::enterprise_management::ChildStatusReportResponse& _internal_child_status_report_response() const;
  ::enterprise_management::ChildStatusReportResponse* _internal_mutable_child_status_report_response();
  public:
  void unsafe_arena_set_allocated_child_status_report_response(
      ::enterprise_management::ChildStatusReportResponse* child_status_report_response);
  ::enterprise_management::ChildStatusReportResponse* unsafe_arena_release_child_status_report_response();

  // optional .enterprise_management.RsuLookupKeyUploadResponse rsu_lookup_key_upload_response = 30;
  bool has_rsu_lookup_key_upload_response() const;
  private:
  bool _internal_has_rsu_lookup_key_upload_response() const;
  public:
  void clear_rsu_lookup_key_upload_response();
  const ::enterprise_management::RsuLookupKeyUploadResponse& rsu_lookup_key_upload_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::RsuLookupKeyUploadResponse* release_rsu_lookup_key_upload_response();
  ::enterprise_management::RsuLookupKeyUploadResponse* mutable_rsu_lookup_key_upload_response();
  void set_allocated_rsu_lookup_key_upload_response(::enterprise_management::RsuLookupKeyUploadResponse* rsu_lookup_key_upload_response);
  private:
  const ::enterprise_management::RsuLookupKeyUploadResponse& _internal_rsu_lookup_key_upload_response() const;
  ::enterprise_management::RsuLookupKeyUploadResponse* _internal_mutable_rsu_lookup_key_upload_response();
  public:
  void unsafe_arena_set_allocated_rsu_lookup_key_upload_response(
      ::enterprise_management::RsuLookupKeyUploadResponse* rsu_lookup_key_upload_response);
  ::enterprise_management::RsuLookupKeyUploadResponse* unsafe_arena_release_rsu_lookup_key_upload_response();

  // optional .enterprise_management.PublicSamlUserResponse public_saml_user_response = 31;
  bool has_public_saml_user_response() const;
  private:
  bool _internal_has_public_saml_user_response() const;
  public:
  void clear_public_saml_user_response();
  const ::enterprise_management::PublicSamlUserResponse& public_saml_user_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::PublicSamlUserResponse* release_public_saml_user_response();
  ::enterprise_management::PublicSamlUserResponse* mutable_public_saml_user_response();
  void set_allocated_public_saml_user_response(::enterprise_management::PublicSamlUserResponse* public_saml_user_response);
  private:
  const ::enterprise_management::PublicSamlUserResponse& _internal_public_saml_user_response() const;
  ::enterprise_management::PublicSamlUserResponse* _internal_mutable_public_saml_user_response();
  public:
  void unsafe_arena_set_allocated_public_saml_user_response(
      ::enterprise_management::PublicSamlUserResponse* public_saml_user_response);
  ::enterprise_management::PublicSamlUserResponse* unsafe_arena_release_public_saml_user_response();

  // optional .enterprise_management.ChromeOsUserReportResponse chrome_os_user_report_response = 32;
  bool has_chrome_os_user_report_response() const;
  private:
  bool _internal_has_chrome_os_user_report_response() const;
  public:
  void clear_chrome_os_user_report_response();
  const ::enterprise_management::ChromeOsUserReportResponse& chrome_os_user_report_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChromeOsUserReportResponse* release_chrome_os_user_report_response();
  ::enterprise_management::ChromeOsUserReportResponse* mutable_chrome_os_user_report_response();
  void set_allocated_chrome_os_user_report_response(::enterprise_management::ChromeOsUserReportResponse* chrome_os_user_report_response);
  private:
  const ::enterprise_management::ChromeOsUserReportResponse& _internal_chrome_os_user_report_response() const;
  ::enterprise_management::ChromeOsUserReportResponse* _internal_mutable_chrome_os_user_report_response();
  public:
  void unsafe_arena_set_allocated_chrome_os_user_report_response(
      ::enterprise_management::ChromeOsUserReportResponse* chrome_os_user_report_response);
  ::enterprise_management::ChromeOsUserReportResponse* unsafe_arena_release_chrome_os_user_report_response();

  // optional .enterprise_management.ClientCertificateProvisioningResponse client_certificate_provisioning_response = 33;
  bool has_client_certificate_provisioning_response() const;
  private:
  bool _internal_has_client_certificate_provisioning_response() const;
  public:
  void clear_client_certificate_provisioning_response();
  const ::enterprise_management::ClientCertificateProvisioningResponse& client_certificate_provisioning_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::ClientCertificateProvisioningResponse* release_client_certificate_provisioning_response();
  ::enterprise_management::ClientCertificateProvisioningResponse* mutable_client_certificate_provisioning_response();
  void set_allocated_client_certificate_provisioning_response(::enterprise_management::ClientCertificateProvisioningResponse* client_certificate_provisioning_response);
  private:
  const ::enterprise_management::ClientCertificateProvisioningResponse& _internal_client_certificate_provisioning_response() const;
  ::enterprise_management::ClientCertificateProvisioningResponse* _internal_mutable_client_certificate_provisioning_response();
  public:
  void unsafe_arena_set_allocated_client_certificate_provisioning_response(
      ::enterprise_management::ClientCertificateProvisioningResponse* client_certificate_provisioning_response);
  ::enterprise_management::ClientCertificateProvisioningResponse* unsafe_arena_release_client_certificate_provisioning_response();

  // optional .enterprise_management.CheckUserAccountResponse check_user_account_response = 34;
  bool has_check_user_account_response() const;
  private:
  bool _internal_has_check_user_account_response() const;
  public:
  void clear_check_user_account_response();
  const ::enterprise_management::CheckUserAccountResponse& check_user_account_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::CheckUserAccountResponse* release_check_user_account_response();
  ::enterprise_management::CheckUserAccountResponse* mutable_check_user_account_response();
  void set_allocated_check_user_account_response(::enterprise_management::CheckUserAccountResponse* check_user_account_response);
  private:
  const ::enterprise_management::CheckUserAccountResponse& _internal_check_user_account_response() const;
  ::enterprise_management::CheckUserAccountResponse* _internal_mutable_check_user_account_response();
  public:
  void unsafe_arena_set_allocated_check_user_account_response(
      ::enterprise_management::CheckUserAccountResponse* check_user_account_response);
  ::enterprise_management::CheckUserAccountResponse* unsafe_arena_release_check_user_account_response();

  // optional .enterprise_management.PrivateSetMembershipResponse private_set_membership_response = 35;
  bool has_private_set_membership_response() const;
  private:
  bool _internal_has_private_set_membership_response() const;
  public:
  void clear_private_set_membership_response();
  const ::enterprise_management::PrivateSetMembershipResponse& private_set_membership_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::PrivateSetMembershipResponse* release_private_set_membership_response();
  ::enterprise_management::PrivateSetMembershipResponse* mutable_private_set_membership_response();
  void set_allocated_private_set_membership_response(::enterprise_management::PrivateSetMembershipResponse* private_set_membership_response);
  private:
  const ::enterprise_management::PrivateSetMembershipResponse& _internal_private_set_membership_response() const;
  ::enterprise_management::PrivateSetMembershipResponse* _internal_mutable_private_set_membership_response();
  public:
  void unsafe_arena_set_allocated_private_set_membership_response(
      ::enterprise_management::PrivateSetMembershipResponse* private_set_membership_response);
  ::enterprise_management::PrivateSetMembershipResponse* unsafe_arena_release_private_set_membership_response();

  // optional .enterprise_management.BrowserPublicKeyUploadResponse browser_public_key_upload_response = 36;
  bool has_browser_public_key_upload_response() const;
  private:
  bool _internal_has_browser_public_key_upload_response() const;
  public:
  void clear_browser_public_key_upload_response();
  const ::enterprise_management::BrowserPublicKeyUploadResponse& browser_public_key_upload_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::BrowserPublicKeyUploadResponse* release_browser_public_key_upload_response();
  ::enterprise_management::BrowserPublicKeyUploadResponse* mutable_browser_public_key_upload_response();
  void set_allocated_browser_public_key_upload_response(::enterprise_management::BrowserPublicKeyUploadResponse* browser_public_key_upload_response);
  private:
  const ::enterprise_management::BrowserPublicKeyUploadResponse& _internal_browser_public_key_upload_response() const;
  ::enterprise_management::BrowserPublicKeyUploadResponse* _internal_mutable_browser_public_key_upload_response();
  public:
  void unsafe_arena_set_allocated_browser_public_key_upload_response(
      ::enterprise_management::BrowserPublicKeyUploadResponse* browser_public_key_upload_response);
  ::enterprise_management::BrowserPublicKeyUploadResponse* unsafe_arena_release_browser_public_key_upload_response();

  // optional .enterprise_management.UploadEuiccInfoResponse upload_euicc_info_response = 37;
  bool has_upload_euicc_info_response() const;
  private:
  bool _internal_has_upload_euicc_info_response() const;
  public:
  void clear_upload_euicc_info_response();
  const ::enterprise_management::UploadEuiccInfoResponse& upload_euicc_info_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::UploadEuiccInfoResponse* release_upload_euicc_info_response();
  ::enterprise_management::UploadEuiccInfoResponse* mutable_upload_euicc_info_response();
  void set_allocated_upload_euicc_info_response(::enterprise_management::UploadEuiccInfoResponse* upload_euicc_info_response);
  private:
  const ::enterprise_management::UploadEuiccInfoResponse& _internal_upload_euicc_info_response() const;
  ::enterprise_management::UploadEuiccInfoResponse* _internal_mutable_upload_euicc_info_response();
  public:
  void unsafe_arena_set_allocated_upload_euicc_info_response(
      ::enterprise_management::UploadEuiccInfoResponse* upload_euicc_info_response);
  ::enterprise_management::UploadEuiccInfoResponse* unsafe_arena_release_upload_euicc_info_response();

  // optional .enterprise_management.ChromeProfileReportResponse chrome_profile_report_response = 38;
  bool has_chrome_profile_report_response() const;
  private:
  bool _internal_has_chrome_profile_report_response() const;
  public:
  void clear_chrome_profile_report_response();
  const ::enterprise_management::ChromeProfileReportResponse& chrome_profile_report_response() const;
  PROTOBUF_NODISCARD ::enterprise_management::ChromeProfileReportResponse* release_chrome_profile_report_response();
  ::enterprise_management::ChromeProfileReportResponse* mutable_chrome_profile_report_response();
  void set_allocated_chrome_profile_report_response(::enterprise_management::ChromeProfileReportResponse* chrome_profile_report_response);
  private:
  const ::enterprise_management::ChromeProfileReportResponse& _internal_chrome_profile_report_response() const;
  ::enterprise_management::ChromeProfileReportResponse* _internal_mutable_chrome_profile_report_response();
  public:
  void unsafe_arena_set_allocated_chrome_profile_report_response(
      ::enterprise_management::ChromeProfileReportResponse* chrome_profile_report_response);
  ::enterprise_management::ChromeProfileReportResponse* unsafe_arena_release_chrome_profile_report_response();

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceManagementResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> error_detail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::enterprise_management::DeviceRegisterResponse* register_response_;
    ::enterprise_management::DeviceUnregisterResponse* unregister_response_;
    ::enterprise_management::DevicePolicyResponse* policy_response_;
    ::enterprise_management::DeviceStatusReportResponse* device_status_report_response_;
    ::enterprise_management::SessionStatusReportResponse* session_status_report_response_;
    ::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response_;
    ::enterprise_management::DeviceCertUploadResponse* cert_upload_response_;
    ::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response_;
    ::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response_;
    ::enterprise_management::DevicePairingResponse* device_pairing_response_;
    ::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response_;
    ::enterprise_management::DeviceRemoteCommandResponse* remote_command_response_;
    ::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response_;
    ::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response_;
    ::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response_;
    ::enterprise_management::CheckAndroidManagementResponse* check_android_management_response_;
    ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* active_directory_enroll_play_user_response_;
    ::enterprise_management::ActiveDirectoryPlayActivityResponse* active_directory_play_activity_response_;
    ::enterprise_management::CheckDeviceLicenseResponse* check_device_license_response_deprecated_;
    ::enterprise_management::ActiveDirectoryUserSigninResponse* active_directory_user_signin_response_;
    ::enterprise_management::ChromeDesktopReportResponse* chrome_desktop_report_response_;
    ::enterprise_management::AppInstallReportResponse* app_install_report_response_;
    ::enterprise_management::PolicyValidationReportResponse* policy_validation_report_response_;
    ::enterprise_management::DeviceInitialEnrollmentStateResponse* device_initial_enrollment_state_response_;
    ::enterprise_management::RefreshAccountResponse* refresh_account_response_;
    ::enterprise_management::ChildStatusReportResponse* child_status_report_response_;
    ::enterprise_management::RsuLookupKeyUploadResponse* rsu_lookup_key_upload_response_;
    ::enterprise_management::PublicSamlUserResponse* public_saml_user_response_;
    ::enterprise_management::ChromeOsUserReportResponse* chrome_os_user_report_response_;
    ::enterprise_management::ClientCertificateProvisioningResponse* client_certificate_provisioning_response_;
    ::enterprise_management::CheckUserAccountResponse* check_user_account_response_;
    ::enterprise_management::PrivateSetMembershipResponse* private_set_membership_response_;
    ::enterprise_management::BrowserPublicKeyUploadResponse* browser_public_key_upload_response_;
    ::enterprise_management::UploadEuiccInfoResponse* upload_euicc_info_response_;
    ::enterprise_management::ChromeProfileReportResponse* chrome_profile_report_response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// -------------------------------------------------------------------

class DeviceStateRetrievalInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_management.DeviceStateRetrievalInfo) */ {
 public:
  inline DeviceStateRetrievalInfo() : DeviceStateRetrievalInfo(nullptr) {}
  ~DeviceStateRetrievalInfo() override;
  explicit PROTOBUF_CONSTEXPR DeviceStateRetrievalInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceStateRetrievalInfo(const DeviceStateRetrievalInfo& from);
  DeviceStateRetrievalInfo(DeviceStateRetrievalInfo&& from) noexcept
    : DeviceStateRetrievalInfo() {
    *this = ::std::move(from);
  }

  inline DeviceStateRetrievalInfo& operator=(const DeviceStateRetrievalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStateRetrievalInfo& operator=(DeviceStateRetrievalInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceStateRetrievalInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStateRetrievalInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceStateRetrievalInfo*>(
               &_DeviceStateRetrievalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    187;

  friend void swap(DeviceStateRetrievalInfo& a, DeviceStateRetrievalInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStateRetrievalInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStateRetrievalInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceStateRetrievalInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceStateRetrievalInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceStateRetrievalInfo& from);
  void MergeFrom(const DeviceStateRetrievalInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceStateRetrievalInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "enterprise_management.DeviceStateRetrievalInfo";
  }
  protected:
  explicit DeviceStateRetrievalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasInitialStateFieldNumber = 1,
  };
  // optional bool has_initial_state = 1;
  bool has_has_initial_state() const;
  private:
  bool _internal_has_has_initial_state() const;
  public:
  void clear_has_initial_state();
  bool has_initial_state() const;
  void set_has_initial_state(bool value);
  private:
  bool _internal_has_initial_state() const;
  void _internal_set_has_initial_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:enterprise_management.DeviceStateRetrievalInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool has_initial_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmanagement_5fbackend_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LicenseType

// optional .enterprise_management.LicenseType.LicenseTypeEnum license_type = 1;
inline bool LicenseType::_internal_has_license_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LicenseType::has_license_type() const {
  return _internal_has_license_type();
}
inline void LicenseType::clear_license_type() {
  _impl_.license_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::LicenseType_LicenseTypeEnum LicenseType::_internal_license_type() const {
  return static_cast< ::enterprise_management::LicenseType_LicenseTypeEnum >(_impl_.license_type_);
}
inline ::enterprise_management::LicenseType_LicenseTypeEnum LicenseType::license_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LicenseType.license_type)
  return _internal_license_type();
}
inline void LicenseType::_internal_set_license_type(::enterprise_management::LicenseType_LicenseTypeEnum value) {
  assert(::enterprise_management::LicenseType_LicenseTypeEnum_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.license_type_ = value;
}
inline void LicenseType::set_license_type(::enterprise_management::LicenseType_LicenseTypeEnum value) {
  _internal_set_license_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LicenseType.license_type)
}

// -------------------------------------------------------------------

// SignedData

// optional bytes data = 1;
inline bool SignedData::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SignedData::has_data() const {
  return _internal_has_data();
}
inline void SignedData::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignedData::data() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SignedData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignedData::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SignedData.data)
}
inline std::string* SignedData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SignedData.data)
  return _s;
}
inline const std::string& SignedData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SignedData::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SignedData::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SignedData::release_data() {
  // @@protoc_insertion_point(field_release:enterprise_management.SignedData.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SignedData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SignedData.data)
}

// optional bytes signature = 2;
inline bool SignedData::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SignedData::has_signature() const {
  return _internal_has_signature();
}
inline void SignedData::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SignedData::signature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SignedData.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignedData::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SignedData.signature)
}
inline std::string* SignedData::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SignedData.signature)
  return _s;
}
inline const std::string& SignedData::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void SignedData::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* SignedData::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* SignedData::release_signature() {
  // @@protoc_insertion_point(field_release:enterprise_management.SignedData.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SignedData::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SignedData.signature)
}

// optional int32 extra_data_bytes = 3;
inline bool SignedData::_internal_has_extra_data_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SignedData::has_extra_data_bytes() const {
  return _internal_has_extra_data_bytes();
}
inline void SignedData::clear_extra_data_bytes() {
  _impl_.extra_data_bytes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SignedData::_internal_extra_data_bytes() const {
  return _impl_.extra_data_bytes_;
}
inline int32_t SignedData::extra_data_bytes() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SignedData.extra_data_bytes)
  return _internal_extra_data_bytes();
}
inline void SignedData::_internal_set_extra_data_bytes(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.extra_data_bytes_ = value;
}
inline void SignedData::set_extra_data_bytes(int32_t value) {
  _internal_set_extra_data_bytes(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SignedData.extra_data_bytes)
}

// -------------------------------------------------------------------

// CheckUserAccountRequest

// optional string user_email = 1;
inline bool CheckUserAccountRequest::_internal_has_user_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckUserAccountRequest::has_user_email() const {
  return _internal_has_user_email();
}
inline void CheckUserAccountRequest::clear_user_email() {
  _impl_.user_email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckUserAccountRequest::user_email() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CheckUserAccountRequest.user_email)
  return _internal_user_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckUserAccountRequest::set_user_email(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CheckUserAccountRequest.user_email)
}
inline std::string* CheckUserAccountRequest::mutable_user_email() {
  std::string* _s = _internal_mutable_user_email();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CheckUserAccountRequest.user_email)
  return _s;
}
inline const std::string& CheckUserAccountRequest::_internal_user_email() const {
  return _impl_.user_email_.Get();
}
inline void CheckUserAccountRequest::_internal_set_user_email(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_email_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckUserAccountRequest::_internal_mutable_user_email() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_email_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckUserAccountRequest::release_user_email() {
  // @@protoc_insertion_point(field_release:enterprise_management.CheckUserAccountRequest.user_email)
  if (!_internal_has_user_email()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_email_.IsDefault()) {
    _impl_.user_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CheckUserAccountRequest::set_allocated_user_email(std::string* user_email) {
  if (user_email != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_email_.SetAllocated(user_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_email_.IsDefault()) {
    _impl_.user_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CheckUserAccountRequest.user_email)
}

// -------------------------------------------------------------------

// DeviceRegisterRequest

// optional bool reregister = 1;
inline bool DeviceRegisterRequest::_internal_has_reregister() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_reregister() const {
  return _internal_has_reregister();
}
inline void DeviceRegisterRequest::clear_reregister() {
  _impl_.reregister_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool DeviceRegisterRequest::_internal_reregister() const {
  return _impl_.reregister_;
}
inline bool DeviceRegisterRequest::reregister() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.reregister)
  return _internal_reregister();
}
inline void DeviceRegisterRequest::_internal_set_reregister(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.reregister_ = value;
}
inline void DeviceRegisterRequest::set_reregister(bool value) {
  _internal_set_reregister(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.reregister)
}

// optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
inline bool DeviceRegisterRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_type() const {
  return _internal_has_type();
}
inline void DeviceRegisterRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::enterprise_management::DeviceRegisterRequest_Type DeviceRegisterRequest::_internal_type() const {
  return static_cast< ::enterprise_management::DeviceRegisterRequest_Type >(_impl_.type_);
}
inline ::enterprise_management::DeviceRegisterRequest_Type DeviceRegisterRequest::type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.type)
  return _internal_type();
}
inline void DeviceRegisterRequest::_internal_set_type(::enterprise_management::DeviceRegisterRequest_Type value) {
  assert(::enterprise_management::DeviceRegisterRequest_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.type_ = value;
}
inline void DeviceRegisterRequest::set_type(::enterprise_management::DeviceRegisterRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.type)
}

// optional string machine_id = 3;
inline bool DeviceRegisterRequest::_internal_has_machine_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_machine_id() const {
  return _internal_has_machine_id();
}
inline void DeviceRegisterRequest::clear_machine_id() {
  _impl_.machine_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceRegisterRequest::machine_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.machine_id)
  return _internal_machine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_machine_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.machine_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.machine_id)
}
inline std::string* DeviceRegisterRequest::mutable_machine_id() {
  std::string* _s = _internal_mutable_machine_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.machine_id)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_machine_id() const {
  return _impl_.machine_id_.Get();
}
inline void DeviceRegisterRequest::_internal_set_machine_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.machine_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_machine_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.machine_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_machine_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.machine_id)
  if (!_internal_has_machine_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.machine_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_id_.IsDefault()) {
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_machine_id(std::string* machine_id) {
  if (machine_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.machine_id_.SetAllocated(machine_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_id_.IsDefault()) {
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.machine_id)
}

// optional string machine_model = 4;
inline bool DeviceRegisterRequest::_internal_has_machine_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_machine_model() const {
  return _internal_has_machine_model();
}
inline void DeviceRegisterRequest::clear_machine_model() {
  _impl_.machine_model_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceRegisterRequest::machine_model() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.machine_model)
  return _internal_machine_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_machine_model(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.machine_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.machine_model)
}
inline std::string* DeviceRegisterRequest::mutable_machine_model() {
  std::string* _s = _internal_mutable_machine_model();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.machine_model)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_machine_model() const {
  return _impl_.machine_model_.Get();
}
inline void DeviceRegisterRequest::_internal_set_machine_model(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.machine_model_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_machine_model() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.machine_model_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_machine_model() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.machine_model)
  if (!_internal_has_machine_model()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.machine_model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_model_.IsDefault()) {
    _impl_.machine_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_machine_model(std::string* machine_model) {
  if (machine_model != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.machine_model_.SetAllocated(machine_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_model_.IsDefault()) {
    _impl_.machine_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.machine_model)
}

// optional string requisition = 6;
inline bool DeviceRegisterRequest::_internal_has_requisition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_requisition() const {
  return _internal_has_requisition();
}
inline void DeviceRegisterRequest::clear_requisition() {
  _impl_.requisition_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceRegisterRequest::requisition() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.requisition)
  return _internal_requisition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_requisition(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.requisition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.requisition)
}
inline std::string* DeviceRegisterRequest::mutable_requisition() {
  std::string* _s = _internal_mutable_requisition();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.requisition)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_requisition() const {
  return _impl_.requisition_.Get();
}
inline void DeviceRegisterRequest::_internal_set_requisition(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.requisition_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_requisition() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.requisition_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_requisition() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.requisition)
  if (!_internal_has_requisition()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.requisition_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requisition_.IsDefault()) {
    _impl_.requisition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_requisition(std::string* requisition) {
  if (requisition != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.requisition_.SetAllocated(requisition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requisition_.IsDefault()) {
    _impl_.requisition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.requisition)
}

// optional bytes server_backed_state_key = 7;
inline bool DeviceRegisterRequest::_internal_has_server_backed_state_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_server_backed_state_key() const {
  return _internal_has_server_backed_state_key();
}
inline void DeviceRegisterRequest::clear_server_backed_state_key() {
  _impl_.server_backed_state_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceRegisterRequest::server_backed_state_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
  return _internal_server_backed_state_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_server_backed_state_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.server_backed_state_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}
inline std::string* DeviceRegisterRequest::mutable_server_backed_state_key() {
  std::string* _s = _internal_mutable_server_backed_state_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_server_backed_state_key() const {
  return _impl_.server_backed_state_key_.Get();
}
inline void DeviceRegisterRequest::_internal_set_server_backed_state_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.server_backed_state_key_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_server_backed_state_key() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.server_backed_state_key_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_server_backed_state_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
  if (!_internal_has_server_backed_state_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.server_backed_state_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_backed_state_key_.IsDefault()) {
    _impl_.server_backed_state_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_server_backed_state_key(std::string* server_backed_state_key) {
  if (server_backed_state_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.server_backed_state_key_.SetAllocated(server_backed_state_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_backed_state_key_.IsDefault()) {
    _impl_.server_backed_state_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.server_backed_state_key)
}

// optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
inline bool DeviceRegisterRequest::_internal_has_flavor() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_flavor() const {
  return _internal_has_flavor();
}
inline void DeviceRegisterRequest::clear_flavor() {
  _impl_.flavor_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::enterprise_management::DeviceRegisterRequest_Flavor DeviceRegisterRequest::_internal_flavor() const {
  return static_cast< ::enterprise_management::DeviceRegisterRequest_Flavor >(_impl_.flavor_);
}
inline ::enterprise_management::DeviceRegisterRequest_Flavor DeviceRegisterRequest::flavor() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.flavor)
  return _internal_flavor();
}
inline void DeviceRegisterRequest::_internal_set_flavor(::enterprise_management::DeviceRegisterRequest_Flavor value) {
  assert(::enterprise_management::DeviceRegisterRequest_Flavor_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.flavor_ = value;
}
inline void DeviceRegisterRequest::set_flavor(::enterprise_management::DeviceRegisterRequest_Flavor value) {
  _internal_set_flavor(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.flavor)
}

// optional .enterprise_management.LicenseType license_type = 9;
inline bool DeviceRegisterRequest::_internal_has_license_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.license_type_ != nullptr);
  return value;
}
inline bool DeviceRegisterRequest::has_license_type() const {
  return _internal_has_license_type();
}
inline void DeviceRegisterRequest::clear_license_type() {
  if (_impl_.license_type_ != nullptr) _impl_.license_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::LicenseType& DeviceRegisterRequest::_internal_license_type() const {
  const ::enterprise_management::LicenseType* p = _impl_.license_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LicenseType&>(
      ::enterprise_management::_LicenseType_default_instance_);
}
inline const ::enterprise_management::LicenseType& DeviceRegisterRequest::license_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.license_type)
  return _internal_license_type();
}
inline void DeviceRegisterRequest::unsafe_arena_set_allocated_license_type(
    ::enterprise_management::LicenseType* license_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.license_type_);
  }
  _impl_.license_type_ = license_type;
  if (license_type) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceRegisterRequest.license_type)
}
inline ::enterprise_management::LicenseType* DeviceRegisterRequest::release_license_type() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::LicenseType* temp = _impl_.license_type_;
  _impl_.license_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LicenseType* DeviceRegisterRequest::unsafe_arena_release_license_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.license_type)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::LicenseType* temp = _impl_.license_type_;
  _impl_.license_type_ = nullptr;
  return temp;
}
inline ::enterprise_management::LicenseType* DeviceRegisterRequest::_internal_mutable_license_type() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.license_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LicenseType>(GetArenaForAllocation());
    _impl_.license_type_ = p;
  }
  return _impl_.license_type_;
}
inline ::enterprise_management::LicenseType* DeviceRegisterRequest::mutable_license_type() {
  ::enterprise_management::LicenseType* _msg = _internal_mutable_license_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.license_type)
  return _msg;
}
inline void DeviceRegisterRequest::set_allocated_license_type(::enterprise_management::LicenseType* license_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.license_type_;
  }
  if (license_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(license_type);
    if (message_arena != submessage_arena) {
      license_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, license_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.license_type_ = license_type;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.license_type)
}

// optional .enterprise_management.DeviceRegisterRequest.Lifetime lifetime = 11 [default = LIFETIME_INDEFINITE];
inline bool DeviceRegisterRequest::_internal_has_lifetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_lifetime() const {
  return _internal_has_lifetime();
}
inline void DeviceRegisterRequest::clear_lifetime() {
  _impl_.lifetime_ = 1;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::enterprise_management::DeviceRegisterRequest_Lifetime DeviceRegisterRequest::_internal_lifetime() const {
  return static_cast< ::enterprise_management::DeviceRegisterRequest_Lifetime >(_impl_.lifetime_);
}
inline ::enterprise_management::DeviceRegisterRequest_Lifetime DeviceRegisterRequest::lifetime() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.lifetime)
  return _internal_lifetime();
}
inline void DeviceRegisterRequest::_internal_set_lifetime(::enterprise_management::DeviceRegisterRequest_Lifetime value) {
  assert(::enterprise_management::DeviceRegisterRequest_Lifetime_IsValid(value));
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.lifetime_ = value;
}
inline void DeviceRegisterRequest::set_lifetime(::enterprise_management::DeviceRegisterRequest_Lifetime value) {
  _internal_set_lifetime(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.lifetime)
}

// optional string brand_code = 12;
inline bool DeviceRegisterRequest::_internal_has_brand_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_brand_code() const {
  return _internal_has_brand_code();
}
inline void DeviceRegisterRequest::clear_brand_code() {
  _impl_.brand_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DeviceRegisterRequest::brand_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.brand_code)
  return _internal_brand_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_brand_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.brand_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.brand_code)
}
inline std::string* DeviceRegisterRequest::mutable_brand_code() {
  std::string* _s = _internal_mutable_brand_code();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.brand_code)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_brand_code() const {
  return _impl_.brand_code_.Get();
}
inline void DeviceRegisterRequest::_internal_set_brand_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.brand_code_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_brand_code() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.brand_code_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_brand_code() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.brand_code)
  if (!_internal_has_brand_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.brand_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brand_code_.IsDefault()) {
    _impl_.brand_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_brand_code(std::string* brand_code) {
  if (brand_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.brand_code_.SetAllocated(brand_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brand_code_.IsDefault()) {
    _impl_.brand_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.brand_code)
}

// optional string reregistration_dm_token = 13;
inline bool DeviceRegisterRequest::_internal_has_reregistration_dm_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_reregistration_dm_token() const {
  return _internal_has_reregistration_dm_token();
}
inline void DeviceRegisterRequest::clear_reregistration_dm_token() {
  _impl_.reregistration_dm_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DeviceRegisterRequest::reregistration_dm_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
  return _internal_reregistration_dm_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_reregistration_dm_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.reregistration_dm_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
}
inline std::string* DeviceRegisterRequest::mutable_reregistration_dm_token() {
  std::string* _s = _internal_mutable_reregistration_dm_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_reregistration_dm_token() const {
  return _impl_.reregistration_dm_token_.Get();
}
inline void DeviceRegisterRequest::_internal_set_reregistration_dm_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.reregistration_dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_reregistration_dm_token() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.reregistration_dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_reregistration_dm_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
  if (!_internal_has_reregistration_dm_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.reregistration_dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reregistration_dm_token_.IsDefault()) {
    _impl_.reregistration_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_reregistration_dm_token(std::string* reregistration_dm_token) {
  if (reregistration_dm_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.reregistration_dm_token_.SetAllocated(reregistration_dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reregistration_dm_token_.IsDefault()) {
    _impl_.reregistration_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.reregistration_dm_token)
}

// optional string ethernet_mac_address = 14;
inline bool DeviceRegisterRequest::_internal_has_ethernet_mac_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_ethernet_mac_address() const {
  return _internal_has_ethernet_mac_address();
}
inline void DeviceRegisterRequest::clear_ethernet_mac_address() {
  _impl_.ethernet_mac_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DeviceRegisterRequest::ethernet_mac_address() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
  return _internal_ethernet_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_ethernet_mac_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.ethernet_mac_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
}
inline std::string* DeviceRegisterRequest::mutable_ethernet_mac_address() {
  std::string* _s = _internal_mutable_ethernet_mac_address();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_ethernet_mac_address() const {
  return _impl_.ethernet_mac_address_.Get();
}
inline void DeviceRegisterRequest::_internal_set_ethernet_mac_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ethernet_mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_ethernet_mac_address() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.ethernet_mac_address_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_ethernet_mac_address() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
  if (!_internal_has_ethernet_mac_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.ethernet_mac_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ethernet_mac_address_.IsDefault()) {
    _impl_.ethernet_mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_ethernet_mac_address(std::string* ethernet_mac_address) {
  if (ethernet_mac_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.ethernet_mac_address_.SetAllocated(ethernet_mac_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ethernet_mac_address_.IsDefault()) {
    _impl_.ethernet_mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.ethernet_mac_address)
}

// optional string dock_mac_address = 15;
inline bool DeviceRegisterRequest::_internal_has_dock_mac_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_dock_mac_address() const {
  return _internal_has_dock_mac_address();
}
inline void DeviceRegisterRequest::clear_dock_mac_address() {
  _impl_.dock_mac_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DeviceRegisterRequest::dock_mac_address() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.dock_mac_address)
  return _internal_dock_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_dock_mac_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.dock_mac_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.dock_mac_address)
}
inline std::string* DeviceRegisterRequest::mutable_dock_mac_address() {
  std::string* _s = _internal_mutable_dock_mac_address();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.dock_mac_address)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_dock_mac_address() const {
  return _impl_.dock_mac_address_.Get();
}
inline void DeviceRegisterRequest::_internal_set_dock_mac_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.dock_mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_dock_mac_address() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.dock_mac_address_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_dock_mac_address() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.dock_mac_address)
  if (!_internal_has_dock_mac_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.dock_mac_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dock_mac_address_.IsDefault()) {
    _impl_.dock_mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_dock_mac_address(std::string* dock_mac_address) {
  if (dock_mac_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.dock_mac_address_.SetAllocated(dock_mac_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dock_mac_address_.IsDefault()) {
    _impl_.dock_mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.dock_mac_address)
}

// optional string manufacture_date = 16;
inline bool DeviceRegisterRequest::_internal_has_manufacture_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_manufacture_date() const {
  return _internal_has_manufacture_date();
}
inline void DeviceRegisterRequest::clear_manufacture_date() {
  _impl_.manufacture_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& DeviceRegisterRequest::manufacture_date() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.manufacture_date)
  return _internal_manufacture_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_manufacture_date(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.manufacture_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.manufacture_date)
}
inline std::string* DeviceRegisterRequest::mutable_manufacture_date() {
  std::string* _s = _internal_mutable_manufacture_date();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.manufacture_date)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_manufacture_date() const {
  return _impl_.manufacture_date_.Get();
}
inline void DeviceRegisterRequest::_internal_set_manufacture_date(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.manufacture_date_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_manufacture_date() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.manufacture_date_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.manufacture_date)
  if (!_internal_has_manufacture_date()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.manufacture_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacture_date_.IsDefault()) {
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_manufacture_date(std::string* manufacture_date) {
  if (manufacture_date != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.manufacture_date_.SetAllocated(manufacture_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacture_date_.IsDefault()) {
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.manufacture_date)
}

// optional string expected_enrollment_domain = 17;
inline bool DeviceRegisterRequest::_internal_has_expected_enrollment_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_expected_enrollment_domain() const {
  return _internal_has_expected_enrollment_domain();
}
inline void DeviceRegisterRequest::clear_expected_enrollment_domain() {
  _impl_.expected_enrollment_domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& DeviceRegisterRequest::expected_enrollment_domain() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
  return _internal_expected_enrollment_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterRequest::set_expected_enrollment_domain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.expected_enrollment_domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
}
inline std::string* DeviceRegisterRequest::mutable_expected_enrollment_domain() {
  std::string* _s = _internal_mutable_expected_enrollment_domain();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
  return _s;
}
inline const std::string& DeviceRegisterRequest::_internal_expected_enrollment_domain() const {
  return _impl_.expected_enrollment_domain_.Get();
}
inline void DeviceRegisterRequest::_internal_set_expected_enrollment_domain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.expected_enrollment_domain_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::_internal_mutable_expected_enrollment_domain() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.expected_enrollment_domain_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterRequest::release_expected_enrollment_domain() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
  if (!_internal_has_expected_enrollment_domain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.expected_enrollment_domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expected_enrollment_domain_.IsDefault()) {
    _impl_.expected_enrollment_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterRequest::set_allocated_expected_enrollment_domain(std::string* expected_enrollment_domain) {
  if (expected_enrollment_domain != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.expected_enrollment_domain_.SetAllocated(expected_enrollment_domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expected_enrollment_domain_.IsDefault()) {
    _impl_.expected_enrollment_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.expected_enrollment_domain)
}

// optional .enterprise_management.DeviceRegisterIdentification device_register_identification = 18;
inline bool DeviceRegisterRequest::_internal_has_device_register_identification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_register_identification_ != nullptr);
  return value;
}
inline bool DeviceRegisterRequest::has_device_register_identification() const {
  return _internal_has_device_register_identification();
}
inline void DeviceRegisterRequest::clear_device_register_identification() {
  if (_impl_.device_register_identification_ != nullptr) _impl_.device_register_identification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::DeviceRegisterIdentification& DeviceRegisterRequest::_internal_device_register_identification() const {
  const ::enterprise_management::DeviceRegisterIdentification* p = _impl_.device_register_identification_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRegisterIdentification&>(
      ::enterprise_management::_DeviceRegisterIdentification_default_instance_);
}
inline const ::enterprise_management::DeviceRegisterIdentification& DeviceRegisterRequest::device_register_identification() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.device_register_identification)
  return _internal_device_register_identification();
}
inline void DeviceRegisterRequest::unsafe_arena_set_allocated_device_register_identification(
    ::enterprise_management::DeviceRegisterIdentification* device_register_identification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_register_identification_);
  }
  _impl_.device_register_identification_ = device_register_identification;
  if (device_register_identification) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceRegisterRequest.device_register_identification)
}
inline ::enterprise_management::DeviceRegisterIdentification* DeviceRegisterRequest::release_device_register_identification() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::DeviceRegisterIdentification* temp = _impl_.device_register_identification_;
  _impl_.device_register_identification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRegisterIdentification* DeviceRegisterRequest::unsafe_arena_release_device_register_identification() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterRequest.device_register_identification)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::DeviceRegisterIdentification* temp = _impl_.device_register_identification_;
  _impl_.device_register_identification_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRegisterIdentification* DeviceRegisterRequest::_internal_mutable_device_register_identification() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.device_register_identification_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterIdentification>(GetArenaForAllocation());
    _impl_.device_register_identification_ = p;
  }
  return _impl_.device_register_identification_;
}
inline ::enterprise_management::DeviceRegisterIdentification* DeviceRegisterRequest::mutable_device_register_identification() {
  ::enterprise_management::DeviceRegisterIdentification* _msg = _internal_mutable_device_register_identification();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterRequest.device_register_identification)
  return _msg;
}
inline void DeviceRegisterRequest::set_allocated_device_register_identification(::enterprise_management::DeviceRegisterIdentification* device_register_identification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_register_identification_;
  }
  if (device_register_identification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_register_identification);
    if (message_arena != submessage_arena) {
      device_register_identification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_register_identification, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.device_register_identification_ = device_register_identification;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterRequest.device_register_identification)
}

// optional .enterprise_management.DeviceRegisterRequest.PsmExecutionResult psm_execution_result = 19;
inline bool DeviceRegisterRequest::_internal_has_psm_execution_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_psm_execution_result() const {
  return _internal_has_psm_execution_result();
}
inline void DeviceRegisterRequest::clear_psm_execution_result() {
  _impl_.psm_execution_result_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::enterprise_management::DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest::_internal_psm_execution_result() const {
  return static_cast< ::enterprise_management::DeviceRegisterRequest_PsmExecutionResult >(_impl_.psm_execution_result_);
}
inline ::enterprise_management::DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest::psm_execution_result() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.psm_execution_result)
  return _internal_psm_execution_result();
}
inline void DeviceRegisterRequest::_internal_set_psm_execution_result(::enterprise_management::DeviceRegisterRequest_PsmExecutionResult value) {
  assert(::enterprise_management::DeviceRegisterRequest_PsmExecutionResult_IsValid(value));
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.psm_execution_result_ = value;
}
inline void DeviceRegisterRequest::set_psm_execution_result(::enterprise_management::DeviceRegisterRequest_PsmExecutionResult value) {
  _internal_set_psm_execution_result(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.psm_execution_result)
}

// optional int64 psm_determination_timestamp_ms = 20;
inline bool DeviceRegisterRequest::_internal_has_psm_determination_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool DeviceRegisterRequest::has_psm_determination_timestamp_ms() const {
  return _internal_has_psm_determination_timestamp_ms();
}
inline void DeviceRegisterRequest::clear_psm_determination_timestamp_ms() {
  _impl_.psm_determination_timestamp_ms_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int64_t DeviceRegisterRequest::_internal_psm_determination_timestamp_ms() const {
  return _impl_.psm_determination_timestamp_ms_;
}
inline int64_t DeviceRegisterRequest::psm_determination_timestamp_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterRequest.psm_determination_timestamp_ms)
  return _internal_psm_determination_timestamp_ms();
}
inline void DeviceRegisterRequest::_internal_set_psm_determination_timestamp_ms(int64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.psm_determination_timestamp_ms_ = value;
}
inline void DeviceRegisterRequest::set_psm_determination_timestamp_ms(int64_t value) {
  _internal_set_psm_determination_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterRequest.psm_determination_timestamp_ms)
}

// -------------------------------------------------------------------

// DeviceRegisterIdentification

// optional string attested_device_id = 1;
inline bool DeviceRegisterIdentification::_internal_has_attested_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceRegisterIdentification::has_attested_device_id() const {
  return _internal_has_attested_device_id();
}
inline void DeviceRegisterIdentification::clear_attested_device_id() {
  _impl_.attested_device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceRegisterIdentification::attested_device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterIdentification.attested_device_id)
  return _internal_attested_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterIdentification::set_attested_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attested_device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterIdentification.attested_device_id)
}
inline std::string* DeviceRegisterIdentification::mutable_attested_device_id() {
  std::string* _s = _internal_mutable_attested_device_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterIdentification.attested_device_id)
  return _s;
}
inline const std::string& DeviceRegisterIdentification::_internal_attested_device_id() const {
  return _impl_.attested_device_id_.Get();
}
inline void DeviceRegisterIdentification::_internal_set_attested_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attested_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterIdentification::_internal_mutable_attested_device_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attested_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterIdentification::release_attested_device_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterIdentification.attested_device_id)
  if (!_internal_has_attested_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attested_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attested_device_id_.IsDefault()) {
    _impl_.attested_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterIdentification::set_allocated_attested_device_id(std::string* attested_device_id) {
  if (attested_device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attested_device_id_.SetAllocated(attested_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attested_device_id_.IsDefault()) {
    _impl_.attested_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterIdentification.attested_device_id)
}

// -------------------------------------------------------------------

// CheckUserAccountResponse

// optional bool domain_verified = 1;
inline bool CheckUserAccountResponse::_internal_has_domain_verified() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckUserAccountResponse::has_domain_verified() const {
  return _internal_has_domain_verified();
}
inline void CheckUserAccountResponse::clear_domain_verified() {
  _impl_.domain_verified_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CheckUserAccountResponse::_internal_domain_verified() const {
  return _impl_.domain_verified_;
}
inline bool CheckUserAccountResponse::domain_verified() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CheckUserAccountResponse.domain_verified)
  return _internal_domain_verified();
}
inline void CheckUserAccountResponse::_internal_set_domain_verified(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.domain_verified_ = value;
}
inline void CheckUserAccountResponse::set_domain_verified(bool value) {
  _internal_set_domain_verified(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CheckUserAccountResponse.domain_verified)
}

// optional .enterprise_management.CheckUserAccountResponse.UserAccountType user_account_type = 2;
inline bool CheckUserAccountResponse::_internal_has_user_account_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CheckUserAccountResponse::has_user_account_type() const {
  return _internal_has_user_account_type();
}
inline void CheckUserAccountResponse::clear_user_account_type() {
  _impl_.user_account_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::CheckUserAccountResponse_UserAccountType CheckUserAccountResponse::_internal_user_account_type() const {
  return static_cast< ::enterprise_management::CheckUserAccountResponse_UserAccountType >(_impl_.user_account_type_);
}
inline ::enterprise_management::CheckUserAccountResponse_UserAccountType CheckUserAccountResponse::user_account_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CheckUserAccountResponse.user_account_type)
  return _internal_user_account_type();
}
inline void CheckUserAccountResponse::_internal_set_user_account_type(::enterprise_management::CheckUserAccountResponse_UserAccountType value) {
  assert(::enterprise_management::CheckUserAccountResponse_UserAccountType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_account_type_ = value;
}
inline void CheckUserAccountResponse::set_user_account_type(::enterprise_management::CheckUserAccountResponse_UserAccountType value) {
  _internal_set_user_account_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CheckUserAccountResponse.user_account_type)
}

// -------------------------------------------------------------------

// DeviceRegisterResponse

// required string device_management_token = 1;
inline bool DeviceRegisterResponse::_internal_has_device_management_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceRegisterResponse::has_device_management_token() const {
  return _internal_has_device_management_token();
}
inline void DeviceRegisterResponse::clear_device_management_token() {
  _impl_.device_management_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceRegisterResponse::device_management_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.device_management_token)
  return _internal_device_management_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterResponse::set_device_management_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_management_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.device_management_token)
}
inline std::string* DeviceRegisterResponse::mutable_device_management_token() {
  std::string* _s = _internal_mutable_device_management_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.device_management_token)
  return _s;
}
inline const std::string& DeviceRegisterResponse::_internal_device_management_token() const {
  return _impl_.device_management_token_.Get();
}
inline void DeviceRegisterResponse::_internal_set_device_management_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_management_token_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterResponse::_internal_mutable_device_management_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_management_token_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterResponse::release_device_management_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.device_management_token)
  if (!_internal_has_device_management_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_management_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_management_token_.IsDefault()) {
    _impl_.device_management_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterResponse::set_allocated_device_management_token(std::string* device_management_token) {
  if (device_management_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_management_token_.SetAllocated(device_management_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_management_token_.IsDefault()) {
    _impl_.device_management_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.device_management_token)
}

// optional string machine_name = 2;
inline bool DeviceRegisterResponse::_internal_has_machine_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceRegisterResponse::has_machine_name() const {
  return _internal_has_machine_name();
}
inline void DeviceRegisterResponse::clear_machine_name() {
  _impl_.machine_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceRegisterResponse::machine_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.machine_name)
  return _internal_machine_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterResponse::set_machine_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.machine_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.machine_name)
}
inline std::string* DeviceRegisterResponse::mutable_machine_name() {
  std::string* _s = _internal_mutable_machine_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.machine_name)
  return _s;
}
inline const std::string& DeviceRegisterResponse::_internal_machine_name() const {
  return _impl_.machine_name_.Get();
}
inline void DeviceRegisterResponse::_internal_set_machine_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.machine_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterResponse::_internal_mutable_machine_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.machine_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterResponse::release_machine_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.machine_name)
  if (!_internal_has_machine_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.machine_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterResponse::set_allocated_machine_name(std::string* machine_name) {
  if (machine_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.machine_name_.SetAllocated(machine_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.machine_name)
}

// optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
inline bool DeviceRegisterResponse::_internal_has_enrollment_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceRegisterResponse::has_enrollment_type() const {
  return _internal_has_enrollment_type();
}
inline void DeviceRegisterResponse::clear_enrollment_type() {
  _impl_.enrollment_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::_internal_enrollment_type() const {
  return static_cast< ::enterprise_management::DeviceRegisterResponse_DeviceMode >(_impl_.enrollment_type_);
}
inline ::enterprise_management::DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::enrollment_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.enrollment_type)
  return _internal_enrollment_type();
}
inline void DeviceRegisterResponse::_internal_set_enrollment_type(::enterprise_management::DeviceRegisterResponse_DeviceMode value) {
  assert(::enterprise_management::DeviceRegisterResponse_DeviceMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.enrollment_type_ = value;
}
inline void DeviceRegisterResponse::set_enrollment_type(::enterprise_management::DeviceRegisterResponse_DeviceMode value) {
  _internal_set_enrollment_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.enrollment_type)
}

// optional string configuration_seed = 4;
inline bool DeviceRegisterResponse::_internal_has_configuration_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceRegisterResponse::has_configuration_seed() const {
  return _internal_has_configuration_seed();
}
inline void DeviceRegisterResponse::clear_configuration_seed() {
  _impl_.configuration_seed_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceRegisterResponse::configuration_seed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.configuration_seed)
  return _internal_configuration_seed();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterResponse::set_configuration_seed(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.configuration_seed_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.configuration_seed)
}
inline std::string* DeviceRegisterResponse::mutable_configuration_seed() {
  std::string* _s = _internal_mutable_configuration_seed();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.configuration_seed)
  return _s;
}
inline const std::string& DeviceRegisterResponse::_internal_configuration_seed() const {
  return _impl_.configuration_seed_.Get();
}
inline void DeviceRegisterResponse::_internal_set_configuration_seed(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.configuration_seed_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterResponse::_internal_mutable_configuration_seed() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.configuration_seed_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterResponse::release_configuration_seed() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.configuration_seed)
  if (!_internal_has_configuration_seed()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.configuration_seed_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.configuration_seed_.IsDefault()) {
    _impl_.configuration_seed_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterResponse::set_allocated_configuration_seed(std::string* configuration_seed) {
  if (configuration_seed != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.configuration_seed_.SetAllocated(configuration_seed, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.configuration_seed_.IsDefault()) {
    _impl_.configuration_seed_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.configuration_seed)
}

// repeated string user_affiliation_ids = 5;
inline int DeviceRegisterResponse::_internal_user_affiliation_ids_size() const {
  return _impl_.user_affiliation_ids_.size();
}
inline int DeviceRegisterResponse::user_affiliation_ids_size() const {
  return _internal_user_affiliation_ids_size();
}
inline void DeviceRegisterResponse::clear_user_affiliation_ids() {
  _impl_.user_affiliation_ids_.Clear();
}
inline std::string* DeviceRegisterResponse::add_user_affiliation_ids() {
  std::string* _s = _internal_add_user_affiliation_ids();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
  return _s;
}
inline const std::string& DeviceRegisterResponse::_internal_user_affiliation_ids(int index) const {
  return _impl_.user_affiliation_ids_.Get(index);
}
inline const std::string& DeviceRegisterResponse::user_affiliation_ids(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
  return _internal_user_affiliation_ids(index);
}
inline std::string* DeviceRegisterResponse::mutable_user_affiliation_ids(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
  return _impl_.user_affiliation_ids_.Mutable(index);
}
inline void DeviceRegisterResponse::set_user_affiliation_ids(int index, const std::string& value) {
  _impl_.user_affiliation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::set_user_affiliation_ids(int index, std::string&& value) {
  _impl_.user_affiliation_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::set_user_affiliation_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_affiliation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::set_user_affiliation_ids(int index, const char* value, size_t size) {
  _impl_.user_affiliation_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline std::string* DeviceRegisterResponse::_internal_add_user_affiliation_ids() {
  return _impl_.user_affiliation_ids_.Add();
}
inline void DeviceRegisterResponse::add_user_affiliation_ids(const std::string& value) {
  _impl_.user_affiliation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::add_user_affiliation_ids(std::string&& value) {
  _impl_.user_affiliation_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::add_user_affiliation_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_affiliation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline void DeviceRegisterResponse::add_user_affiliation_ids(const char* value, size_t size) {
  _impl_.user_affiliation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceRegisterResponse::user_affiliation_ids() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
  return _impl_.user_affiliation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceRegisterResponse::mutable_user_affiliation_ids() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRegisterResponse.user_affiliation_ids)
  return &_impl_.user_affiliation_ids_;
}

// optional string directory_api_id = 6;
inline bool DeviceRegisterResponse::_internal_has_directory_api_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceRegisterResponse::has_directory_api_id() const {
  return _internal_has_directory_api_id();
}
inline void DeviceRegisterResponse::clear_directory_api_id() {
  _impl_.directory_api_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceRegisterResponse::directory_api_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterResponse.directory_api_id)
  return _internal_directory_api_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterResponse::set_directory_api_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.directory_api_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterResponse.directory_api_id)
}
inline std::string* DeviceRegisterResponse::mutable_directory_api_id() {
  std::string* _s = _internal_mutable_directory_api_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterResponse.directory_api_id)
  return _s;
}
inline const std::string& DeviceRegisterResponse::_internal_directory_api_id() const {
  return _impl_.directory_api_id_.Get();
}
inline void DeviceRegisterResponse::_internal_set_directory_api_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.directory_api_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterResponse::_internal_mutable_directory_api_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.directory_api_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterResponse::release_directory_api_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterResponse.directory_api_id)
  if (!_internal_has_directory_api_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.directory_api_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directory_api_id_.IsDefault()) {
    _impl_.directory_api_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterResponse::set_allocated_directory_api_id(std::string* directory_api_id) {
  if (directory_api_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.directory_api_id_.SetAllocated(directory_api_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directory_api_id_.IsDefault()) {
    _impl_.directory_api_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterResponse.directory_api_id)
}

// -------------------------------------------------------------------

// DeviceUnregisterRequest

// -------------------------------------------------------------------

// DeviceUnregisterResponse

// -------------------------------------------------------------------

// DeviceCertUploadRequest

// optional bytes device_certificate = 1;
inline bool DeviceCertUploadRequest::_internal_has_device_certificate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceCertUploadRequest::has_device_certificate() const {
  return _internal_has_device_certificate();
}
inline void DeviceCertUploadRequest::clear_device_certificate() {
  _impl_.device_certificate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceCertUploadRequest::device_certificate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceCertUploadRequest.device_certificate)
  return _internal_device_certificate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceCertUploadRequest::set_device_certificate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_certificate_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceCertUploadRequest.device_certificate)
}
inline std::string* DeviceCertUploadRequest::mutable_device_certificate() {
  std::string* _s = _internal_mutable_device_certificate();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceCertUploadRequest.device_certificate)
  return _s;
}
inline const std::string& DeviceCertUploadRequest::_internal_device_certificate() const {
  return _impl_.device_certificate_.Get();
}
inline void DeviceCertUploadRequest::_internal_set_device_certificate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_certificate_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceCertUploadRequest::_internal_mutable_device_certificate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_certificate_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceCertUploadRequest::release_device_certificate() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceCertUploadRequest.device_certificate)
  if (!_internal_has_device_certificate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_certificate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_certificate_.IsDefault()) {
    _impl_.device_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceCertUploadRequest::set_allocated_device_certificate(std::string* device_certificate) {
  if (device_certificate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_certificate_.SetAllocated(device_certificate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_certificate_.IsDefault()) {
    _impl_.device_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceCertUploadRequest.device_certificate)
}

// optional .enterprise_management.DeviceCertUploadRequest.CertificateType certificate_type = 2;
inline bool DeviceCertUploadRequest::_internal_has_certificate_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceCertUploadRequest::has_certificate_type() const {
  return _internal_has_certificate_type();
}
inline void DeviceCertUploadRequest::clear_certificate_type() {
  _impl_.certificate_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest::_internal_certificate_type() const {
  return static_cast< ::enterprise_management::DeviceCertUploadRequest_CertificateType >(_impl_.certificate_type_);
}
inline ::enterprise_management::DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest::certificate_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceCertUploadRequest.certificate_type)
  return _internal_certificate_type();
}
inline void DeviceCertUploadRequest::_internal_set_certificate_type(::enterprise_management::DeviceCertUploadRequest_CertificateType value) {
  assert(::enterprise_management::DeviceCertUploadRequest_CertificateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.certificate_type_ = value;
}
inline void DeviceCertUploadRequest::set_certificate_type(::enterprise_management::DeviceCertUploadRequest_CertificateType value) {
  _internal_set_certificate_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceCertUploadRequest.certificate_type)
}

// optional bytes enrollment_id = 3;
inline bool DeviceCertUploadRequest::_internal_has_enrollment_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceCertUploadRequest::has_enrollment_id() const {
  return _internal_has_enrollment_id();
}
inline void DeviceCertUploadRequest::clear_enrollment_id() {
  _impl_.enrollment_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceCertUploadRequest::enrollment_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceCertUploadRequest.enrollment_id)
  return _internal_enrollment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceCertUploadRequest::set_enrollment_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.enrollment_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceCertUploadRequest.enrollment_id)
}
inline std::string* DeviceCertUploadRequest::mutable_enrollment_id() {
  std::string* _s = _internal_mutable_enrollment_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceCertUploadRequest.enrollment_id)
  return _s;
}
inline const std::string& DeviceCertUploadRequest::_internal_enrollment_id() const {
  return _impl_.enrollment_id_.Get();
}
inline void DeviceCertUploadRequest::_internal_set_enrollment_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enrollment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceCertUploadRequest::_internal_mutable_enrollment_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.enrollment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceCertUploadRequest::release_enrollment_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceCertUploadRequest.enrollment_id)
  if (!_internal_has_enrollment_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.enrollment_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enrollment_id_.IsDefault()) {
    _impl_.enrollment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceCertUploadRequest::set_allocated_enrollment_id(std::string* enrollment_id) {
  if (enrollment_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.enrollment_id_.SetAllocated(enrollment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enrollment_id_.IsDefault()) {
    _impl_.enrollment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceCertUploadRequest.enrollment_id)
}

// -------------------------------------------------------------------

// DeviceCertUploadResponse

// -------------------------------------------------------------------

// DeviceServiceApiAccessRequest

// repeated string auth_scopes = 1;
inline int DeviceServiceApiAccessRequest::_internal_auth_scopes_size() const {
  return _impl_.auth_scopes_.size();
}
inline int DeviceServiceApiAccessRequest::auth_scopes_size() const {
  return _internal_auth_scopes_size();
}
inline void DeviceServiceApiAccessRequest::clear_auth_scopes() {
  _impl_.auth_scopes_.Clear();
}
inline std::string* DeviceServiceApiAccessRequest::add_auth_scopes() {
  std::string* _s = _internal_add_auth_scopes();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
  return _s;
}
inline const std::string& DeviceServiceApiAccessRequest::_internal_auth_scopes(int index) const {
  return _impl_.auth_scopes_.Get(index);
}
inline const std::string& DeviceServiceApiAccessRequest::auth_scopes(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
  return _internal_auth_scopes(index);
}
inline std::string* DeviceServiceApiAccessRequest::mutable_auth_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
  return _impl_.auth_scopes_.Mutable(index);
}
inline void DeviceServiceApiAccessRequest::set_auth_scopes(int index, const std::string& value) {
  _impl_.auth_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::set_auth_scopes(int index, std::string&& value) {
  _impl_.auth_scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::set_auth_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.auth_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::set_auth_scopes(int index, const char* value, size_t size) {
  _impl_.auth_scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline std::string* DeviceServiceApiAccessRequest::_internal_add_auth_scopes() {
  return _impl_.auth_scopes_.Add();
}
inline void DeviceServiceApiAccessRequest::add_auth_scopes(const std::string& value) {
  _impl_.auth_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::add_auth_scopes(std::string&& value) {
  _impl_.auth_scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::add_auth_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.auth_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline void DeviceServiceApiAccessRequest::add_auth_scopes(const char* value, size_t size) {
  _impl_.auth_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceServiceApiAccessRequest::auth_scopes() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
  return _impl_.auth_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceServiceApiAccessRequest::mutable_auth_scopes() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceServiceApiAccessRequest.auth_scopes)
  return &_impl_.auth_scopes_;
}

// optional string oauth2_client_id = 2;
inline bool DeviceServiceApiAccessRequest::_internal_has_oauth2_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceServiceApiAccessRequest::has_oauth2_client_id() const {
  return _internal_has_oauth2_client_id();
}
inline void DeviceServiceApiAccessRequest::clear_oauth2_client_id() {
  _impl_.oauth2_client_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceServiceApiAccessRequest::oauth2_client_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
  return _internal_oauth2_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceServiceApiAccessRequest::set_oauth2_client_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.oauth2_client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}
inline std::string* DeviceServiceApiAccessRequest::mutable_oauth2_client_id() {
  std::string* _s = _internal_mutable_oauth2_client_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
  return _s;
}
inline const std::string& DeviceServiceApiAccessRequest::_internal_oauth2_client_id() const {
  return _impl_.oauth2_client_id_.Get();
}
inline void DeviceServiceApiAccessRequest::_internal_set_oauth2_client_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.oauth2_client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceServiceApiAccessRequest::_internal_mutable_oauth2_client_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.oauth2_client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceServiceApiAccessRequest::release_oauth2_client_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
  if (!_internal_has_oauth2_client_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.oauth2_client_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oauth2_client_id_.IsDefault()) {
    _impl_.oauth2_client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceServiceApiAccessRequest::set_allocated_oauth2_client_id(std::string* oauth2_client_id) {
  if (oauth2_client_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.oauth2_client_id_.SetAllocated(oauth2_client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oauth2_client_id_.IsDefault()) {
    _impl_.oauth2_client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceServiceApiAccessRequest.oauth2_client_id)
}

// optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
inline bool DeviceServiceApiAccessRequest::_internal_has_device_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceServiceApiAccessRequest::has_device_type() const {
  return _internal_has_device_type();
}
inline void DeviceServiceApiAccessRequest::clear_device_type() {
  _impl_.device_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::_internal_device_type() const {
  return static_cast< ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType >(_impl_.device_type_);
}
inline ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::device_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessRequest.device_type)
  return _internal_device_type();
}
inline void DeviceServiceApiAccessRequest::_internal_set_device_type(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType value) {
  assert(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.device_type_ = value;
}
inline void DeviceServiceApiAccessRequest::set_device_type(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessRequest.device_type)
}

// -------------------------------------------------------------------

// DeviceServiceApiAccessResponse

// optional string auth_code = 1;
inline bool DeviceServiceApiAccessResponse::_internal_has_auth_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceServiceApiAccessResponse::has_auth_code() const {
  return _internal_has_auth_code();
}
inline void DeviceServiceApiAccessResponse::clear_auth_code() {
  _impl_.auth_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceServiceApiAccessResponse::auth_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
  return _internal_auth_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceServiceApiAccessResponse::set_auth_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.auth_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}
inline std::string* DeviceServiceApiAccessResponse::mutable_auth_code() {
  std::string* _s = _internal_mutable_auth_code();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
  return _s;
}
inline const std::string& DeviceServiceApiAccessResponse::_internal_auth_code() const {
  return _impl_.auth_code_.Get();
}
inline void DeviceServiceApiAccessResponse::_internal_set_auth_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_code_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceServiceApiAccessResponse::_internal_mutable_auth_code() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auth_code_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceServiceApiAccessResponse::release_auth_code() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
  if (!_internal_has_auth_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.auth_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_code_.IsDefault()) {
    _impl_.auth_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceServiceApiAccessResponse::set_allocated_auth_code(std::string* auth_code) {
  if (auth_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auth_code_.SetAllocated(auth_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_code_.IsDefault()) {
    _impl_.auth_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceServiceApiAccessResponse.auth_code)
}

// -------------------------------------------------------------------

// BrowserDeviceIdentifier

// optional string computer_name = 1;
inline bool BrowserDeviceIdentifier::_internal_has_computer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BrowserDeviceIdentifier::has_computer_name() const {
  return _internal_has_computer_name();
}
inline void BrowserDeviceIdentifier::clear_computer_name() {
  _impl_.computer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BrowserDeviceIdentifier::computer_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserDeviceIdentifier.computer_name)
  return _internal_computer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BrowserDeviceIdentifier::set_computer_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.computer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserDeviceIdentifier.computer_name)
}
inline std::string* BrowserDeviceIdentifier::mutable_computer_name() {
  std::string* _s = _internal_mutable_computer_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserDeviceIdentifier.computer_name)
  return _s;
}
inline const std::string& BrowserDeviceIdentifier::_internal_computer_name() const {
  return _impl_.computer_name_.Get();
}
inline void BrowserDeviceIdentifier::_internal_set_computer_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.computer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BrowserDeviceIdentifier::_internal_mutable_computer_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.computer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BrowserDeviceIdentifier::release_computer_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.BrowserDeviceIdentifier.computer_name)
  if (!_internal_has_computer_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.computer_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.computer_name_.IsDefault()) {
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BrowserDeviceIdentifier::set_allocated_computer_name(std::string* computer_name) {
  if (computer_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.computer_name_.SetAllocated(computer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.computer_name_.IsDefault()) {
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserDeviceIdentifier.computer_name)
}

// optional string serial_number = 2;
inline bool BrowserDeviceIdentifier::_internal_has_serial_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BrowserDeviceIdentifier::has_serial_number() const {
  return _internal_has_serial_number();
}
inline void BrowserDeviceIdentifier::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BrowserDeviceIdentifier::serial_number() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserDeviceIdentifier.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BrowserDeviceIdentifier::set_serial_number(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserDeviceIdentifier.serial_number)
}
inline std::string* BrowserDeviceIdentifier::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserDeviceIdentifier.serial_number)
  return _s;
}
inline const std::string& BrowserDeviceIdentifier::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void BrowserDeviceIdentifier::_internal_set_serial_number(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* BrowserDeviceIdentifier::_internal_mutable_serial_number() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* BrowserDeviceIdentifier::release_serial_number() {
  // @@protoc_insertion_point(field_release:enterprise_management.BrowserDeviceIdentifier.serial_number)
  if (!_internal_has_serial_number()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.serial_number_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BrowserDeviceIdentifier::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserDeviceIdentifier.serial_number)
}

// -------------------------------------------------------------------

// PolicyFetchRequest

// optional string policy_type = 1;
inline bool PolicyFetchRequest::_internal_has_policy_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_policy_type() const {
  return _internal_has_policy_type();
}
inline void PolicyFetchRequest::clear_policy_type() {
  _impl_.policy_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyFetchRequest::policy_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.policy_type)
  return _internal_policy_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchRequest::set_policy_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.policy_type)
}
inline std::string* PolicyFetchRequest::mutable_policy_type() {
  std::string* _s = _internal_mutable_policy_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.policy_type)
  return _s;
}
inline const std::string& PolicyFetchRequest::_internal_policy_type() const {
  return _impl_.policy_type_.Get();
}
inline void PolicyFetchRequest::_internal_set_policy_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::_internal_mutable_policy_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_type_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::release_policy_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.policy_type)
  if (!_internal_has_policy_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_type_.IsDefault()) {
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchRequest::set_allocated_policy_type(std::string* policy_type) {
  if (policy_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_type_.SetAllocated(policy_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_type_.IsDefault()) {
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.policy_type)
}

// optional int64 timestamp = 2;
inline bool PolicyFetchRequest::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void PolicyFetchRequest::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t PolicyFetchRequest::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t PolicyFetchRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.timestamp)
  return _internal_timestamp();
}
inline void PolicyFetchRequest::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.timestamp_ = value;
}
inline void PolicyFetchRequest::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.timestamp)
}

// optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
inline bool PolicyFetchRequest::_internal_has_signature_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_signature_type() const {
  return _internal_has_signature_type();
}
inline void PolicyFetchRequest::clear_signature_type() {
  _impl_.signature_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType PolicyFetchRequest::_internal_signature_type() const {
  return static_cast< ::enterprise_management::PolicyFetchRequest_SignatureType >(_impl_.signature_type_);
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType PolicyFetchRequest::signature_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.signature_type)
  return _internal_signature_type();
}
inline void PolicyFetchRequest::_internal_set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
  assert(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.signature_type_ = value;
}
inline void PolicyFetchRequest::set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
  _internal_set_signature_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.signature_type)
}

// optional int32 public_key_version = 4;
inline bool PolicyFetchRequest::_internal_has_public_key_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_public_key_version() const {
  return _internal_has_public_key_version();
}
inline void PolicyFetchRequest::clear_public_key_version() {
  _impl_.public_key_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t PolicyFetchRequest::_internal_public_key_version() const {
  return _impl_.public_key_version_;
}
inline int32_t PolicyFetchRequest::public_key_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.public_key_version)
  return _internal_public_key_version();
}
inline void PolicyFetchRequest::_internal_set_public_key_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.public_key_version_ = value;
}
inline void PolicyFetchRequest::set_public_key_version(int32_t value) {
  _internal_set_public_key_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.public_key_version)
}

// optional string settings_entity_id = 6;
inline bool PolicyFetchRequest::_internal_has_settings_entity_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_settings_entity_id() const {
  return _internal_has_settings_entity_id();
}
inline void PolicyFetchRequest::clear_settings_entity_id() {
  _impl_.settings_entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyFetchRequest::settings_entity_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.settings_entity_id)
  return _internal_settings_entity_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchRequest::set_settings_entity_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.settings_entity_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.settings_entity_id)
}
inline std::string* PolicyFetchRequest::mutable_settings_entity_id() {
  std::string* _s = _internal_mutable_settings_entity_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.settings_entity_id)
  return _s;
}
inline const std::string& PolicyFetchRequest::_internal_settings_entity_id() const {
  return _impl_.settings_entity_id_.Get();
}
inline void PolicyFetchRequest::_internal_set_settings_entity_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.settings_entity_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::_internal_mutable_settings_entity_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.settings_entity_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::release_settings_entity_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.settings_entity_id)
  if (!_internal_has_settings_entity_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.settings_entity_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.settings_entity_id_.IsDefault()) {
    _impl_.settings_entity_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchRequest::set_allocated_settings_entity_id(std::string* settings_entity_id) {
  if (settings_entity_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.settings_entity_id_.SetAllocated(settings_entity_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.settings_entity_id_.IsDefault()) {
    _impl_.settings_entity_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.settings_entity_id)
}

// optional int64 invalidation_version = 7;
inline bool PolicyFetchRequest::_internal_has_invalidation_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_invalidation_version() const {
  return _internal_has_invalidation_version();
}
inline void PolicyFetchRequest::clear_invalidation_version() {
  _impl_.invalidation_version_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t PolicyFetchRequest::_internal_invalidation_version() const {
  return _impl_.invalidation_version_;
}
inline int64_t PolicyFetchRequest::invalidation_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.invalidation_version)
  return _internal_invalidation_version();
}
inline void PolicyFetchRequest::_internal_set_invalidation_version(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.invalidation_version_ = value;
}
inline void PolicyFetchRequest::set_invalidation_version(int64_t value) {
  _internal_set_invalidation_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.invalidation_version)
}

// optional bytes invalidation_payload = 8;
inline bool PolicyFetchRequest::_internal_has_invalidation_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_invalidation_payload() const {
  return _internal_has_invalidation_payload();
}
inline void PolicyFetchRequest::clear_invalidation_payload() {
  _impl_.invalidation_payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PolicyFetchRequest::invalidation_payload() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.invalidation_payload)
  return _internal_invalidation_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchRequest::set_invalidation_payload(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.invalidation_payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.invalidation_payload)
}
inline std::string* PolicyFetchRequest::mutable_invalidation_payload() {
  std::string* _s = _internal_mutable_invalidation_payload();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.invalidation_payload)
  return _s;
}
inline const std::string& PolicyFetchRequest::_internal_invalidation_payload() const {
  return _impl_.invalidation_payload_.Get();
}
inline void PolicyFetchRequest::_internal_set_invalidation_payload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.invalidation_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::_internal_mutable_invalidation_payload() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.invalidation_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::release_invalidation_payload() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.invalidation_payload)
  if (!_internal_has_invalidation_payload()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.invalidation_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invalidation_payload_.IsDefault()) {
    _impl_.invalidation_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchRequest::set_allocated_invalidation_payload(std::string* invalidation_payload) {
  if (invalidation_payload != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.invalidation_payload_.SetAllocated(invalidation_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invalidation_payload_.IsDefault()) {
    _impl_.invalidation_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.invalidation_payload)
}

// optional string verification_key_hash = 9;
inline bool PolicyFetchRequest::_internal_has_verification_key_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_verification_key_hash() const {
  return _internal_has_verification_key_hash();
}
inline void PolicyFetchRequest::clear_verification_key_hash() {
  _impl_.verification_key_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PolicyFetchRequest::verification_key_hash() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.verification_key_hash)
  return _internal_verification_key_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchRequest::set_verification_key_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.verification_key_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.verification_key_hash)
}
inline std::string* PolicyFetchRequest::mutable_verification_key_hash() {
  std::string* _s = _internal_mutable_verification_key_hash();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.verification_key_hash)
  return _s;
}
inline const std::string& PolicyFetchRequest::_internal_verification_key_hash() const {
  return _impl_.verification_key_hash_.Get();
}
inline void PolicyFetchRequest::_internal_set_verification_key_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.verification_key_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::_internal_mutable_verification_key_hash() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.verification_key_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::release_verification_key_hash() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.verification_key_hash)
  if (!_internal_has_verification_key_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.verification_key_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verification_key_hash_.IsDefault()) {
    _impl_.verification_key_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchRequest::set_allocated_verification_key_hash(std::string* verification_key_hash) {
  if (verification_key_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.verification_key_hash_.SetAllocated(verification_key_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verification_key_hash_.IsDefault()) {
    _impl_.verification_key_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.verification_key_hash)
}

// optional string policy_invalidation_info = 10;
inline bool PolicyFetchRequest::_internal_has_policy_invalidation_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_policy_invalidation_info() const {
  return _internal_has_policy_invalidation_info();
}
inline void PolicyFetchRequest::clear_policy_invalidation_info() {
  _impl_.policy_invalidation_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PolicyFetchRequest::policy_invalidation_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
  return _internal_policy_invalidation_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchRequest::set_policy_invalidation_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.policy_invalidation_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
}
inline std::string* PolicyFetchRequest::mutable_policy_invalidation_info() {
  std::string* _s = _internal_mutable_policy_invalidation_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
  return _s;
}
inline const std::string& PolicyFetchRequest::_internal_policy_invalidation_info() const {
  return _impl_.policy_invalidation_info_.Get();
}
inline void PolicyFetchRequest::_internal_set_policy_invalidation_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.policy_invalidation_info_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::_internal_mutable_policy_invalidation_info() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.policy_invalidation_info_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::release_policy_invalidation_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
  if (!_internal_has_policy_invalidation_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.policy_invalidation_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_invalidation_info_.IsDefault()) {
    _impl_.policy_invalidation_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchRequest::set_allocated_policy_invalidation_info(std::string* policy_invalidation_info) {
  if (policy_invalidation_info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.policy_invalidation_info_.SetAllocated(policy_invalidation_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_invalidation_info_.IsDefault()) {
    _impl_.policy_invalidation_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.policy_invalidation_info)
}

// optional bool invalidation_topics_only = 11;
inline bool PolicyFetchRequest::_internal_has_invalidation_topics_only() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_invalidation_topics_only() const {
  return _internal_has_invalidation_topics_only();
}
inline void PolicyFetchRequest::clear_invalidation_topics_only() {
  _impl_.invalidation_topics_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool PolicyFetchRequest::_internal_invalidation_topics_only() const {
  return _impl_.invalidation_topics_only_;
}
inline bool PolicyFetchRequest::invalidation_topics_only() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.invalidation_topics_only)
  return _internal_invalidation_topics_only();
}
inline void PolicyFetchRequest::_internal_set_invalidation_topics_only(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.invalidation_topics_only_ = value;
}
inline void PolicyFetchRequest::set_invalidation_topics_only(bool value) {
  _internal_set_invalidation_topics_only(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.invalidation_topics_only)
}

// optional string device_dm_token = 12;
inline bool PolicyFetchRequest::_internal_has_device_dm_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PolicyFetchRequest::has_device_dm_token() const {
  return _internal_has_device_dm_token();
}
inline void PolicyFetchRequest::clear_device_dm_token() {
  _impl_.device_dm_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PolicyFetchRequest::device_dm_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.device_dm_token)
  return _internal_device_dm_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchRequest::set_device_dm_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.device_dm_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchRequest.device_dm_token)
}
inline std::string* PolicyFetchRequest::mutable_device_dm_token() {
  std::string* _s = _internal_mutable_device_dm_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.device_dm_token)
  return _s;
}
inline const std::string& PolicyFetchRequest::_internal_device_dm_token() const {
  return _impl_.device_dm_token_.Get();
}
inline void PolicyFetchRequest::_internal_set_device_dm_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.device_dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::_internal_mutable_device_dm_token() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.device_dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchRequest::release_device_dm_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.device_dm_token)
  if (!_internal_has_device_dm_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.device_dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_dm_token_.IsDefault()) {
    _impl_.device_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchRequest::set_allocated_device_dm_token(std::string* device_dm_token) {
  if (device_dm_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.device_dm_token_.SetAllocated(device_dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_dm_token_.IsDefault()) {
    _impl_.device_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.device_dm_token)
}

// optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 13;
inline bool PolicyFetchRequest::_internal_has_browser_device_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_device_identifier_ != nullptr);
  return value;
}
inline bool PolicyFetchRequest::has_browser_device_identifier() const {
  return _internal_has_browser_device_identifier();
}
inline void PolicyFetchRequest::clear_browser_device_identifier() {
  if (_impl_.browser_device_identifier_ != nullptr) _impl_.browser_device_identifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::BrowserDeviceIdentifier& PolicyFetchRequest::_internal_browser_device_identifier() const {
  const ::enterprise_management::BrowserDeviceIdentifier* p = _impl_.browser_device_identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserDeviceIdentifier&>(
      ::enterprise_management::_BrowserDeviceIdentifier_default_instance_);
}
inline const ::enterprise_management::BrowserDeviceIdentifier& PolicyFetchRequest::browser_device_identifier() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchRequest.browser_device_identifier)
  return _internal_browser_device_identifier();
}
inline void PolicyFetchRequest::unsafe_arena_set_allocated_browser_device_identifier(
    ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_device_identifier_);
  }
  _impl_.browser_device_identifier_ = browser_device_identifier;
  if (browser_device_identifier) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PolicyFetchRequest.browser_device_identifier)
}
inline ::enterprise_management::BrowserDeviceIdentifier* PolicyFetchRequest::release_browser_device_identifier() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::BrowserDeviceIdentifier* temp = _impl_.browser_device_identifier_;
  _impl_.browser_device_identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserDeviceIdentifier* PolicyFetchRequest::unsafe_arena_release_browser_device_identifier() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchRequest.browser_device_identifier)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::BrowserDeviceIdentifier* temp = _impl_.browser_device_identifier_;
  _impl_.browser_device_identifier_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserDeviceIdentifier* PolicyFetchRequest::_internal_mutable_browser_device_identifier() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.browser_device_identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserDeviceIdentifier>(GetArenaForAllocation());
    _impl_.browser_device_identifier_ = p;
  }
  return _impl_.browser_device_identifier_;
}
inline ::enterprise_management::BrowserDeviceIdentifier* PolicyFetchRequest::mutable_browser_device_identifier() {
  ::enterprise_management::BrowserDeviceIdentifier* _msg = _internal_mutable_browser_device_identifier();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchRequest.browser_device_identifier)
  return _msg;
}
inline void PolicyFetchRequest::set_allocated_browser_device_identifier(::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_device_identifier_;
  }
  if (browser_device_identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_device_identifier);
    if (message_arena != submessage_arena) {
      browser_device_identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_device_identifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.browser_device_identifier_ = browser_device_identifier;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchRequest.browser_device_identifier)
}

// -------------------------------------------------------------------

// DisabledState

// optional string message = 1;
inline bool DisabledState::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisabledState::has_message() const {
  return _internal_has_message();
}
inline void DisabledState::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DisabledState::message() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DisabledState.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisabledState::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DisabledState.message)
}
inline std::string* DisabledState::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DisabledState.message)
  return _s;
}
inline const std::string& DisabledState::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DisabledState::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DisabledState::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DisabledState::release_message() {
  // @@protoc_insertion_point(field_release:enterprise_management.DisabledState.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DisabledState::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DisabledState.message)
}

// -------------------------------------------------------------------

// DeviceState

// optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
inline bool DeviceState::_internal_has_device_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceState::has_device_mode() const {
  return _internal_has_device_mode();
}
inline void DeviceState::clear_device_mode() {
  _impl_.device_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::DeviceState_DeviceMode DeviceState::_internal_device_mode() const {
  return static_cast< ::enterprise_management::DeviceState_DeviceMode >(_impl_.device_mode_);
}
inline ::enterprise_management::DeviceState_DeviceMode DeviceState::device_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceState.device_mode)
  return _internal_device_mode();
}
inline void DeviceState::_internal_set_device_mode(::enterprise_management::DeviceState_DeviceMode value) {
  assert(::enterprise_management::DeviceState_DeviceMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.device_mode_ = value;
}
inline void DeviceState::set_device_mode(::enterprise_management::DeviceState_DeviceMode value) {
  _internal_set_device_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceState.device_mode)
}

// optional .enterprise_management.DisabledState disabled_state = 2;
inline bool DeviceState::_internal_has_disabled_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.disabled_state_ != nullptr);
  return value;
}
inline bool DeviceState::has_disabled_state() const {
  return _internal_has_disabled_state();
}
inline void DeviceState::clear_disabled_state() {
  if (_impl_.disabled_state_ != nullptr) _impl_.disabled_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::DisabledState& DeviceState::_internal_disabled_state() const {
  const ::enterprise_management::DisabledState* p = _impl_.disabled_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DisabledState&>(
      ::enterprise_management::_DisabledState_default_instance_);
}
inline const ::enterprise_management::DisabledState& DeviceState::disabled_state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceState.disabled_state)
  return _internal_disabled_state();
}
inline void DeviceState::unsafe_arena_set_allocated_disabled_state(
    ::enterprise_management::DisabledState* disabled_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.disabled_state_);
  }
  _impl_.disabled_state_ = disabled_state;
  if (disabled_state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceState.disabled_state)
}
inline ::enterprise_management::DisabledState* DeviceState::release_disabled_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DisabledState* temp = _impl_.disabled_state_;
  _impl_.disabled_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DisabledState* DeviceState::unsafe_arena_release_disabled_state() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceState.disabled_state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DisabledState* temp = _impl_.disabled_state_;
  _impl_.disabled_state_ = nullptr;
  return temp;
}
inline ::enterprise_management::DisabledState* DeviceState::_internal_mutable_disabled_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.disabled_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DisabledState>(GetArenaForAllocation());
    _impl_.disabled_state_ = p;
  }
  return _impl_.disabled_state_;
}
inline ::enterprise_management::DisabledState* DeviceState::mutable_disabled_state() {
  ::enterprise_management::DisabledState* _msg = _internal_mutable_disabled_state();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceState.disabled_state)
  return _msg;
}
inline void DeviceState::set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.disabled_state_;
  }
  if (disabled_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disabled_state);
    if (message_arena != submessage_arena) {
      disabled_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disabled_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.disabled_state_ = disabled_state;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceState.disabled_state)
}

// -------------------------------------------------------------------

// CustomerLogo

// optional string logo_url = 1;
inline bool CustomerLogo::_internal_has_logo_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomerLogo::has_logo_url() const {
  return _internal_has_logo_url();
}
inline void CustomerLogo::clear_logo_url() {
  _impl_.logo_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomerLogo::logo_url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CustomerLogo.logo_url)
  return _internal_logo_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomerLogo::set_logo_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.logo_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CustomerLogo.logo_url)
}
inline std::string* CustomerLogo::mutable_logo_url() {
  std::string* _s = _internal_mutable_logo_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CustomerLogo.logo_url)
  return _s;
}
inline const std::string& CustomerLogo::_internal_logo_url() const {
  return _impl_.logo_url_.Get();
}
inline void CustomerLogo::_internal_set_logo_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.logo_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomerLogo::_internal_mutable_logo_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.logo_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomerLogo::release_logo_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.CustomerLogo.logo_url)
  if (!_internal_has_logo_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.logo_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logo_url_.IsDefault()) {
    _impl_.logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomerLogo::set_allocated_logo_url(std::string* logo_url) {
  if (logo_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.logo_url_.SetAllocated(logo_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logo_url_.IsDefault()) {
    _impl_.logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CustomerLogo.logo_url)
}

// -------------------------------------------------------------------

// PolicyData

// optional string policy_type = 1;
inline bool PolicyData::_internal_has_policy_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolicyData::has_policy_type() const {
  return _internal_has_policy_type();
}
inline void PolicyData::clear_policy_type() {
  _impl_.policy_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyData::policy_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_type)
  return _internal_policy_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_policy_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_type)
}
inline std::string* PolicyData::mutable_policy_type() {
  std::string* _s = _internal_mutable_policy_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_type)
  return _s;
}
inline const std::string& PolicyData::_internal_policy_type() const {
  return _impl_.policy_type_.Get();
}
inline void PolicyData::_internal_set_policy_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_policy_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_type_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_policy_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_type)
  if (!_internal_has_policy_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_type_.IsDefault()) {
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_policy_type(std::string* policy_type) {
  if (policy_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_type_.SetAllocated(policy_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_type_.IsDefault()) {
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_type)
}

// optional int64 timestamp = 2;
inline bool PolicyData::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool PolicyData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void PolicyData::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline int64_t PolicyData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t PolicyData::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.timestamp)
  return _internal_timestamp();
}
inline void PolicyData::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.timestamp_ = value;
}
inline void PolicyData::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.timestamp)
}

// optional string request_token = 3;
inline bool PolicyData::_internal_has_request_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PolicyData::has_request_token() const {
  return _internal_has_request_token();
}
inline void PolicyData::clear_request_token() {
  _impl_.request_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyData::request_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.request_token)
  return _internal_request_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_request_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.request_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.request_token)
}
inline std::string* PolicyData::mutable_request_token() {
  std::string* _s = _internal_mutable_request_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.request_token)
  return _s;
}
inline const std::string& PolicyData::_internal_request_token() const {
  return _impl_.request_token_.Get();
}
inline void PolicyData::_internal_set_request_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_token_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_request_token() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.request_token_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_request_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.request_token)
  if (!_internal_has_request_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.request_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_token_.IsDefault()) {
    _impl_.request_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_request_token(std::string* request_token) {
  if (request_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.request_token_.SetAllocated(request_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_token_.IsDefault()) {
    _impl_.request_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.request_token)
}

// optional bytes policy_value = 4;
inline bool PolicyData::_internal_has_policy_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PolicyData::has_policy_value() const {
  return _internal_has_policy_value();
}
inline void PolicyData::clear_policy_value() {
  _impl_.policy_value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PolicyData::policy_value() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_value)
  return _internal_policy_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_policy_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.policy_value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_value)
}
inline std::string* PolicyData::mutable_policy_value() {
  std::string* _s = _internal_mutable_policy_value();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_value)
  return _s;
}
inline const std::string& PolicyData::_internal_policy_value() const {
  return _impl_.policy_value_.Get();
}
inline void PolicyData::_internal_set_policy_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.policy_value_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_policy_value() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.policy_value_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_policy_value() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_value)
  if (!_internal_has_policy_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.policy_value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_value_.IsDefault()) {
    _impl_.policy_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_policy_value(std::string* policy_value) {
  if (policy_value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.policy_value_.SetAllocated(policy_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_value_.IsDefault()) {
    _impl_.policy_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_value)
}

// optional string machine_name = 5;
inline bool PolicyData::_internal_has_machine_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PolicyData::has_machine_name() const {
  return _internal_has_machine_name();
}
inline void PolicyData::clear_machine_name() {
  _impl_.machine_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PolicyData::machine_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.machine_name)
  return _internal_machine_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_machine_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.machine_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.machine_name)
}
inline std::string* PolicyData::mutable_machine_name() {
  std::string* _s = _internal_mutable_machine_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.machine_name)
  return _s;
}
inline const std::string& PolicyData::_internal_machine_name() const {
  return _impl_.machine_name_.Get();
}
inline void PolicyData::_internal_set_machine_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.machine_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_machine_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.machine_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_machine_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.machine_name)
  if (!_internal_has_machine_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.machine_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_machine_name(std::string* machine_name) {
  if (machine_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.machine_name_.SetAllocated(machine_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.machine_name)
}

// optional int32 public_key_version = 6;
inline bool PolicyData::_internal_has_public_key_version() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool PolicyData::has_public_key_version() const {
  return _internal_has_public_key_version();
}
inline void PolicyData::clear_public_key_version() {
  _impl_.public_key_version_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline int32_t PolicyData::_internal_public_key_version() const {
  return _impl_.public_key_version_;
}
inline int32_t PolicyData::public_key_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.public_key_version)
  return _internal_public_key_version();
}
inline void PolicyData::_internal_set_public_key_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.public_key_version_ = value;
}
inline void PolicyData::set_public_key_version(int32_t value) {
  _internal_set_public_key_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.public_key_version)
}

// optional string username = 7;
inline bool PolicyData::_internal_has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PolicyData::has_username() const {
  return _internal_has_username();
}
inline void PolicyData::clear_username() {
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PolicyData::username() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.username)
}
inline std::string* PolicyData::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.username)
  return _s;
}
inline const std::string& PolicyData::_internal_username() const {
  return _impl_.username_.Get();
}
inline void PolicyData::_internal_set_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_username() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_username() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.username)
}

// optional string device_id = 8;
inline bool PolicyData::_internal_has_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PolicyData::has_device_id() const {
  return _internal_has_device_id();
}
inline void PolicyData::clear_device_id() {
  _impl_.device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PolicyData::device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.device_id)
}
inline std::string* PolicyData::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_id)
  return _s;
}
inline const std::string& PolicyData::_internal_device_id() const {
  return _impl_.device_id_.Get();
}
inline void PolicyData::_internal_set_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_device_id() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_device_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.device_id)
  if (!_internal_has_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.device_id)
}

// optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
inline bool PolicyData::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool PolicyData::has_state() const {
  return _internal_has_state();
}
inline void PolicyData::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::enterprise_management::PolicyData_AssociationState PolicyData::_internal_state() const {
  return static_cast< ::enterprise_management::PolicyData_AssociationState >(_impl_.state_);
}
inline ::enterprise_management::PolicyData_AssociationState PolicyData::state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.state)
  return _internal_state();
}
inline void PolicyData::_internal_set_state(::enterprise_management::PolicyData_AssociationState value) {
  assert(::enterprise_management::PolicyData_AssociationState_IsValid(value));
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.state_ = value;
}
inline void PolicyData::set_state(::enterprise_management::PolicyData_AssociationState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.state)
}

// optional string settings_entity_id = 11;
inline bool PolicyData::_internal_has_settings_entity_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PolicyData::has_settings_entity_id() const {
  return _internal_has_settings_entity_id();
}
inline void PolicyData::clear_settings_entity_id() {
  _impl_.settings_entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& PolicyData::settings_entity_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.settings_entity_id)
  return _internal_settings_entity_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_settings_entity_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.settings_entity_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.settings_entity_id)
}
inline std::string* PolicyData::mutable_settings_entity_id() {
  std::string* _s = _internal_mutable_settings_entity_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.settings_entity_id)
  return _s;
}
inline const std::string& PolicyData::_internal_settings_entity_id() const {
  return _impl_.settings_entity_id_.Get();
}
inline void PolicyData::_internal_set_settings_entity_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.settings_entity_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_settings_entity_id() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.settings_entity_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_settings_entity_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.settings_entity_id)
  if (!_internal_has_settings_entity_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.settings_entity_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.settings_entity_id_.IsDefault()) {
    _impl_.settings_entity_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_settings_entity_id(std::string* settings_entity_id) {
  if (settings_entity_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.settings_entity_id_.SetAllocated(settings_entity_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.settings_entity_id_.IsDefault()) {
    _impl_.settings_entity_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.settings_entity_id)
}

// optional string service_account_identity = 12;
inline bool PolicyData::_internal_has_service_account_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PolicyData::has_service_account_identity() const {
  return _internal_has_service_account_identity();
}
inline void PolicyData::clear_service_account_identity() {
  _impl_.service_account_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& PolicyData::service_account_identity() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.service_account_identity)
  return _internal_service_account_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_service_account_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.service_account_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.service_account_identity)
}
inline std::string* PolicyData::mutable_service_account_identity() {
  std::string* _s = _internal_mutable_service_account_identity();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.service_account_identity)
  return _s;
}
inline const std::string& PolicyData::_internal_service_account_identity() const {
  return _impl_.service_account_identity_.Get();
}
inline void PolicyData::_internal_set_service_account_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.service_account_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_service_account_identity() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.service_account_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_service_account_identity() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.service_account_identity)
  if (!_internal_has_service_account_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.service_account_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_account_identity_.IsDefault()) {
    _impl_.service_account_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_service_account_identity(std::string* service_account_identity) {
  if (service_account_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.service_account_identity_.SetAllocated(service_account_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_account_identity_.IsDefault()) {
    _impl_.service_account_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.service_account_identity)
}

// optional string policy_token = 15;
inline bool PolicyData::_internal_has_policy_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PolicyData::has_policy_token() const {
  return _internal_has_policy_token();
}
inline void PolicyData::clear_policy_token() {
  _impl_.policy_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& PolicyData::policy_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_token)
  return _internal_policy_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_policy_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.policy_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_token)
}
inline std::string* PolicyData::mutable_policy_token() {
  std::string* _s = _internal_mutable_policy_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_token)
  return _s;
}
inline const std::string& PolicyData::_internal_policy_token() const {
  return _impl_.policy_token_.Get();
}
inline void PolicyData::_internal_set_policy_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.policy_token_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_policy_token() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.policy_token_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_policy_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_token)
  if (!_internal_has_policy_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.policy_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_token_.IsDefault()) {
    _impl_.policy_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_policy_token(std::string* policy_token) {
  if (policy_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.policy_token_.SetAllocated(policy_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_token_.IsDefault()) {
    _impl_.policy_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_token)
}

// optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
inline bool PolicyData::_internal_has_management_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool PolicyData::has_management_mode() const {
  return _internal_has_management_mode();
}
inline void PolicyData::clear_management_mode() {
  _impl_.management_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::enterprise_management::PolicyData_ManagementMode PolicyData::_internal_management_mode() const {
  return static_cast< ::enterprise_management::PolicyData_ManagementMode >(_impl_.management_mode_);
}
inline ::enterprise_management::PolicyData_ManagementMode PolicyData::management_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.management_mode)
  return _internal_management_mode();
}
inline void PolicyData::_internal_set_management_mode(::enterprise_management::PolicyData_ManagementMode value) {
  assert(::enterprise_management::PolicyData_ManagementMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.management_mode_ = value;
}
inline void PolicyData::set_management_mode(::enterprise_management::PolicyData_ManagementMode value) {
  _internal_set_management_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.management_mode)
}

// optional .enterprise_management.DeviceState device_state = 17;
inline bool PolicyData::_internal_has_device_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_state_ != nullptr);
  return value;
}
inline bool PolicyData::has_device_state() const {
  return _internal_has_device_state();
}
inline void PolicyData::clear_device_state() {
  if (_impl_.device_state_ != nullptr) _impl_.device_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const ::enterprise_management::DeviceState& PolicyData::_internal_device_state() const {
  const ::enterprise_management::DeviceState* p = _impl_.device_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceState&>(
      ::enterprise_management::_DeviceState_default_instance_);
}
inline const ::enterprise_management::DeviceState& PolicyData::device_state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_state)
  return _internal_device_state();
}
inline void PolicyData::unsafe_arena_set_allocated_device_state(
    ::enterprise_management::DeviceState* device_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_state_);
  }
  _impl_.device_state_ = device_state;
  if (device_state) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PolicyData.device_state)
}
inline ::enterprise_management::DeviceState* PolicyData::release_device_state() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::enterprise_management::DeviceState* temp = _impl_.device_state_;
  _impl_.device_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceState* PolicyData::unsafe_arena_release_device_state() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.device_state)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::enterprise_management::DeviceState* temp = _impl_.device_state_;
  _impl_.device_state_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceState* PolicyData::_internal_mutable_device_state() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.device_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceState>(GetArenaForAllocation());
    _impl_.device_state_ = p;
  }
  return _impl_.device_state_;
}
inline ::enterprise_management::DeviceState* PolicyData::mutable_device_state() {
  ::enterprise_management::DeviceState* _msg = _internal_mutable_device_state();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_state)
  return _msg;
}
inline void PolicyData::set_allocated_device_state(::enterprise_management::DeviceState* device_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_state_;
  }
  if (device_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_state);
    if (message_arena != submessage_arena) {
      device_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.device_state_ = device_state;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.device_state)
}

// optional string annotated_location = 20;
inline bool PolicyData::_internal_has_annotated_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PolicyData::has_annotated_location() const {
  return _internal_has_annotated_location();
}
inline void PolicyData::clear_annotated_location() {
  _impl_.annotated_location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& PolicyData::annotated_location() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.annotated_location)
  return _internal_annotated_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_annotated_location(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.annotated_location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.annotated_location)
}
inline std::string* PolicyData::mutable_annotated_location() {
  std::string* _s = _internal_mutable_annotated_location();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.annotated_location)
  return _s;
}
inline const std::string& PolicyData::_internal_annotated_location() const {
  return _impl_.annotated_location_.Get();
}
inline void PolicyData::_internal_set_annotated_location(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.annotated_location_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_annotated_location() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.annotated_location_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_annotated_location() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.annotated_location)
  if (!_internal_has_annotated_location()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.annotated_location_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.annotated_location_.IsDefault()) {
    _impl_.annotated_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_annotated_location(std::string* annotated_location) {
  if (annotated_location != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.annotated_location_.SetAllocated(annotated_location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.annotated_location_.IsDefault()) {
    _impl_.annotated_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.annotated_location)
}

// optional string annotated_asset_id = 21;
inline bool PolicyData::_internal_has_annotated_asset_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PolicyData::has_annotated_asset_id() const {
  return _internal_has_annotated_asset_id();
}
inline void PolicyData::clear_annotated_asset_id() {
  _impl_.annotated_asset_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& PolicyData::annotated_asset_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.annotated_asset_id)
  return _internal_annotated_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_annotated_asset_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.annotated_asset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.annotated_asset_id)
}
inline std::string* PolicyData::mutable_annotated_asset_id() {
  std::string* _s = _internal_mutable_annotated_asset_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.annotated_asset_id)
  return _s;
}
inline const std::string& PolicyData::_internal_annotated_asset_id() const {
  return _impl_.annotated_asset_id_.Get();
}
inline void PolicyData::_internal_set_annotated_asset_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.annotated_asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_annotated_asset_id() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.annotated_asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_annotated_asset_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.annotated_asset_id)
  if (!_internal_has_annotated_asset_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.annotated_asset_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.annotated_asset_id_.IsDefault()) {
    _impl_.annotated_asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_annotated_asset_id(std::string* annotated_asset_id) {
  if (annotated_asset_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.annotated_asset_id_.SetAllocated(annotated_asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.annotated_asset_id_.IsDefault()) {
    _impl_.annotated_asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.annotated_asset_id)
}

// optional string directory_api_id = 22;
inline bool PolicyData::_internal_has_directory_api_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool PolicyData::has_directory_api_id() const {
  return _internal_has_directory_api_id();
}
inline void PolicyData::clear_directory_api_id() {
  _impl_.directory_api_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& PolicyData::directory_api_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.directory_api_id)
  return _internal_directory_api_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_directory_api_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.directory_api_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.directory_api_id)
}
inline std::string* PolicyData::mutable_directory_api_id() {
  std::string* _s = _internal_mutable_directory_api_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.directory_api_id)
  return _s;
}
inline const std::string& PolicyData::_internal_directory_api_id() const {
  return _impl_.directory_api_id_.Get();
}
inline void PolicyData::_internal_set_directory_api_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.directory_api_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_directory_api_id() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.directory_api_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_directory_api_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.directory_api_id)
  if (!_internal_has_directory_api_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.directory_api_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directory_api_id_.IsDefault()) {
    _impl_.directory_api_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_directory_api_id(std::string* directory_api_id) {
  if (directory_api_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.directory_api_id_.SetAllocated(directory_api_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directory_api_id_.IsDefault()) {
    _impl_.directory_api_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.directory_api_id)
}

// repeated string device_affiliation_ids = 23;
inline int PolicyData::_internal_device_affiliation_ids_size() const {
  return _impl_.device_affiliation_ids_.size();
}
inline int PolicyData::device_affiliation_ids_size() const {
  return _internal_device_affiliation_ids_size();
}
inline void PolicyData::clear_device_affiliation_ids() {
  _impl_.device_affiliation_ids_.Clear();
}
inline std::string* PolicyData::add_device_affiliation_ids() {
  std::string* _s = _internal_add_device_affiliation_ids();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.PolicyData.device_affiliation_ids)
  return _s;
}
inline const std::string& PolicyData::_internal_device_affiliation_ids(int index) const {
  return _impl_.device_affiliation_ids_.Get(index);
}
inline const std::string& PolicyData::device_affiliation_ids(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.device_affiliation_ids)
  return _internal_device_affiliation_ids(index);
}
inline std::string* PolicyData::mutable_device_affiliation_ids(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.device_affiliation_ids)
  return _impl_.device_affiliation_ids_.Mutable(index);
}
inline void PolicyData::set_device_affiliation_ids(int index, const std::string& value) {
  _impl_.device_affiliation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::set_device_affiliation_ids(int index, std::string&& value) {
  _impl_.device_affiliation_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::set_device_affiliation_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.device_affiliation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::set_device_affiliation_ids(int index, const char* value, size_t size) {
  _impl_.device_affiliation_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.device_affiliation_ids)
}
inline std::string* PolicyData::_internal_add_device_affiliation_ids() {
  return _impl_.device_affiliation_ids_.Add();
}
inline void PolicyData::add_device_affiliation_ids(const std::string& value) {
  _impl_.device_affiliation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::add_device_affiliation_ids(std::string&& value) {
  _impl_.device_affiliation_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::add_device_affiliation_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.device_affiliation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.PolicyData.device_affiliation_ids)
}
inline void PolicyData::add_device_affiliation_ids(const char* value, size_t size) {
  _impl_.device_affiliation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.PolicyData.device_affiliation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PolicyData::device_affiliation_ids() const {
  // @@protoc_insertion_point(field_list:enterprise_management.PolicyData.device_affiliation_ids)
  return _impl_.device_affiliation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PolicyData::mutable_device_affiliation_ids() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.PolicyData.device_affiliation_ids)
  return &_impl_.device_affiliation_ids_;
}

// repeated string user_affiliation_ids = 24;
inline int PolicyData::_internal_user_affiliation_ids_size() const {
  return _impl_.user_affiliation_ids_.size();
}
inline int PolicyData::user_affiliation_ids_size() const {
  return _internal_user_affiliation_ids_size();
}
inline void PolicyData::clear_user_affiliation_ids() {
  _impl_.user_affiliation_ids_.Clear();
}
inline std::string* PolicyData::add_user_affiliation_ids() {
  std::string* _s = _internal_add_user_affiliation_ids();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.PolicyData.user_affiliation_ids)
  return _s;
}
inline const std::string& PolicyData::_internal_user_affiliation_ids(int index) const {
  return _impl_.user_affiliation_ids_.Get(index);
}
inline const std::string& PolicyData::user_affiliation_ids(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.user_affiliation_ids)
  return _internal_user_affiliation_ids(index);
}
inline std::string* PolicyData::mutable_user_affiliation_ids(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.user_affiliation_ids)
  return _impl_.user_affiliation_ids_.Mutable(index);
}
inline void PolicyData::set_user_affiliation_ids(int index, const std::string& value) {
  _impl_.user_affiliation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::set_user_affiliation_ids(int index, std::string&& value) {
  _impl_.user_affiliation_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::set_user_affiliation_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_affiliation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::set_user_affiliation_ids(int index, const char* value, size_t size) {
  _impl_.user_affiliation_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.PolicyData.user_affiliation_ids)
}
inline std::string* PolicyData::_internal_add_user_affiliation_ids() {
  return _impl_.user_affiliation_ids_.Add();
}
inline void PolicyData::add_user_affiliation_ids(const std::string& value) {
  _impl_.user_affiliation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::add_user_affiliation_ids(std::string&& value) {
  _impl_.user_affiliation_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::add_user_affiliation_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_affiliation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.PolicyData.user_affiliation_ids)
}
inline void PolicyData::add_user_affiliation_ids(const char* value, size_t size) {
  _impl_.user_affiliation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.PolicyData.user_affiliation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PolicyData::user_affiliation_ids() const {
  // @@protoc_insertion_point(field_list:enterprise_management.PolicyData.user_affiliation_ids)
  return _impl_.user_affiliation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PolicyData::mutable_user_affiliation_ids() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.PolicyData.user_affiliation_ids)
  return &_impl_.user_affiliation_ids_;
}

// optional string display_domain = 25;
inline bool PolicyData::_internal_has_display_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool PolicyData::has_display_domain() const {
  return _internal_has_display_domain();
}
inline void PolicyData::clear_display_domain() {
  _impl_.display_domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& PolicyData::display_domain() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.display_domain)
  return _internal_display_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_display_domain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.display_domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.display_domain)
}
inline std::string* PolicyData::mutable_display_domain() {
  std::string* _s = _internal_mutable_display_domain();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.display_domain)
  return _s;
}
inline const std::string& PolicyData::_internal_display_domain() const {
  return _impl_.display_domain_.Get();
}
inline void PolicyData::_internal_set_display_domain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.display_domain_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_display_domain() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.display_domain_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_display_domain() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.display_domain)
  if (!_internal_has_display_domain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.display_domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_domain_.IsDefault()) {
    _impl_.display_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_display_domain(std::string* display_domain) {
  if (display_domain != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.display_domain_.SetAllocated(display_domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_domain_.IsDefault()) {
    _impl_.display_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.display_domain)
}

// optional string policy_invalidation_topic = 26;
inline bool PolicyData::_internal_has_policy_invalidation_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool PolicyData::has_policy_invalidation_topic() const {
  return _internal_has_policy_invalidation_topic();
}
inline void PolicyData::clear_policy_invalidation_topic() {
  _impl_.policy_invalidation_topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& PolicyData::policy_invalidation_topic() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.policy_invalidation_topic)
  return _internal_policy_invalidation_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_policy_invalidation_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.policy_invalidation_topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.policy_invalidation_topic)
}
inline std::string* PolicyData::mutable_policy_invalidation_topic() {
  std::string* _s = _internal_mutable_policy_invalidation_topic();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.policy_invalidation_topic)
  return _s;
}
inline const std::string& PolicyData::_internal_policy_invalidation_topic() const {
  return _impl_.policy_invalidation_topic_.Get();
}
inline void PolicyData::_internal_set_policy_invalidation_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.policy_invalidation_topic_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_policy_invalidation_topic() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.policy_invalidation_topic_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_policy_invalidation_topic() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.policy_invalidation_topic)
  if (!_internal_has_policy_invalidation_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.policy_invalidation_topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_invalidation_topic_.IsDefault()) {
    _impl_.policy_invalidation_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_policy_invalidation_topic(std::string* policy_invalidation_topic) {
  if (policy_invalidation_topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.policy_invalidation_topic_.SetAllocated(policy_invalidation_topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_invalidation_topic_.IsDefault()) {
    _impl_.policy_invalidation_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.policy_invalidation_topic)
}

// optional string command_invalidation_topic = 27;
inline bool PolicyData::_internal_has_command_invalidation_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool PolicyData::has_command_invalidation_topic() const {
  return _internal_has_command_invalidation_topic();
}
inline void PolicyData::clear_command_invalidation_topic() {
  _impl_.command_invalidation_topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& PolicyData::command_invalidation_topic() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.command_invalidation_topic)
  return _internal_command_invalidation_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_command_invalidation_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00004000u;
 _impl_.command_invalidation_topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.command_invalidation_topic)
}
inline std::string* PolicyData::mutable_command_invalidation_topic() {
  std::string* _s = _internal_mutable_command_invalidation_topic();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.command_invalidation_topic)
  return _s;
}
inline const std::string& PolicyData::_internal_command_invalidation_topic() const {
  return _impl_.command_invalidation_topic_.Get();
}
inline void PolicyData::_internal_set_command_invalidation_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.command_invalidation_topic_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_command_invalidation_topic() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.command_invalidation_topic_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_command_invalidation_topic() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.command_invalidation_topic)
  if (!_internal_has_command_invalidation_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* p = _impl_.command_invalidation_topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_invalidation_topic_.IsDefault()) {
    _impl_.command_invalidation_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_command_invalidation_topic(std::string* command_invalidation_topic) {
  if (command_invalidation_topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.command_invalidation_topic_.SetAllocated(command_invalidation_topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_invalidation_topic_.IsDefault()) {
    _impl_.command_invalidation_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.command_invalidation_topic)
}

// optional bool enrollment_id_needed = 28;
inline bool PolicyData::_internal_has_enrollment_id_needed() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool PolicyData::has_enrollment_id_needed() const {
  return _internal_has_enrollment_id_needed();
}
inline void PolicyData::clear_enrollment_id_needed() {
  _impl_.enrollment_id_needed_ = false;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline bool PolicyData::_internal_enrollment_id_needed() const {
  return _impl_.enrollment_id_needed_;
}
inline bool PolicyData::enrollment_id_needed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.enrollment_id_needed)
  return _internal_enrollment_id_needed();
}
inline void PolicyData::_internal_set_enrollment_id_needed(bool value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.enrollment_id_needed_ = value;
}
inline void PolicyData::set_enrollment_id_needed(bool value) {
  _internal_set_enrollment_id_needed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.enrollment_id_needed)
}

// optional string gaia_id = 29;
inline bool PolicyData::_internal_has_gaia_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool PolicyData::has_gaia_id() const {
  return _internal_has_gaia_id();
}
inline void PolicyData::clear_gaia_id() {
  _impl_.gaia_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const std::string& PolicyData::gaia_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.gaia_id)
  return _internal_gaia_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_gaia_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00008000u;
 _impl_.gaia_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.gaia_id)
}
inline std::string* PolicyData::mutable_gaia_id() {
  std::string* _s = _internal_mutable_gaia_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.gaia_id)
  return _s;
}
inline const std::string& PolicyData::_internal_gaia_id() const {
  return _impl_.gaia_id_.Get();
}
inline void PolicyData::_internal_set_gaia_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.gaia_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_gaia_id() {
  _impl_._has_bits_[0] |= 0x00008000u;
  return _impl_.gaia_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_gaia_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.gaia_id)
  if (!_internal_has_gaia_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00008000u;
  auto* p = _impl_.gaia_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gaia_id_.IsDefault()) {
    _impl_.gaia_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_gaia_id(std::string* gaia_id) {
  if (gaia_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.gaia_id_.SetAllocated(gaia_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gaia_id_.IsDefault()) {
    _impl_.gaia_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.gaia_id)
}

// optional .enterprise_management.PolicyData.MarketSegment market_segment = 30;
inline bool PolicyData::_internal_has_market_segment() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool PolicyData::has_market_segment() const {
  return _internal_has_market_segment();
}
inline void PolicyData::clear_market_segment() {
  _impl_.market_segment_ = 0;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline ::enterprise_management::PolicyData_MarketSegment PolicyData::_internal_market_segment() const {
  return static_cast< ::enterprise_management::PolicyData_MarketSegment >(_impl_.market_segment_);
}
inline ::enterprise_management::PolicyData_MarketSegment PolicyData::market_segment() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.market_segment)
  return _internal_market_segment();
}
inline void PolicyData::_internal_set_market_segment(::enterprise_management::PolicyData_MarketSegment value) {
  assert(::enterprise_management::PolicyData_MarketSegment_IsValid(value));
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.market_segment_ = value;
}
inline void PolicyData::set_market_segment(::enterprise_management::PolicyData_MarketSegment value) {
  _internal_set_market_segment(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.market_segment)
}

// optional .enterprise_management.CustomerLogo customer_logo = 31;
inline bool PolicyData::_internal_has_customer_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.customer_logo_ != nullptr);
  return value;
}
inline bool PolicyData::has_customer_logo() const {
  return _internal_has_customer_logo();
}
inline void PolicyData::clear_customer_logo() {
  if (_impl_.customer_logo_ != nullptr) _impl_.customer_logo_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::enterprise_management::CustomerLogo& PolicyData::_internal_customer_logo() const {
  const ::enterprise_management::CustomerLogo* p = _impl_.customer_logo_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CustomerLogo&>(
      ::enterprise_management::_CustomerLogo_default_instance_);
}
inline const ::enterprise_management::CustomerLogo& PolicyData::customer_logo() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.customer_logo)
  return _internal_customer_logo();
}
inline void PolicyData::unsafe_arena_set_allocated_customer_logo(
    ::enterprise_management::CustomerLogo* customer_logo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.customer_logo_);
  }
  _impl_.customer_logo_ = customer_logo;
  if (customer_logo) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PolicyData.customer_logo)
}
inline ::enterprise_management::CustomerLogo* PolicyData::release_customer_logo() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::enterprise_management::CustomerLogo* temp = _impl_.customer_logo_;
  _impl_.customer_logo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CustomerLogo* PolicyData::unsafe_arena_release_customer_logo() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.customer_logo)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::enterprise_management::CustomerLogo* temp = _impl_.customer_logo_;
  _impl_.customer_logo_ = nullptr;
  return temp;
}
inline ::enterprise_management::CustomerLogo* PolicyData::_internal_mutable_customer_logo() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.customer_logo_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CustomerLogo>(GetArenaForAllocation());
    _impl_.customer_logo_ = p;
  }
  return _impl_.customer_logo_;
}
inline ::enterprise_management::CustomerLogo* PolicyData::mutable_customer_logo() {
  ::enterprise_management::CustomerLogo* _msg = _internal_mutable_customer_logo();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.customer_logo)
  return _msg;
}
inline void PolicyData::set_allocated_customer_logo(::enterprise_management::CustomerLogo* customer_logo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.customer_logo_;
  }
  if (customer_logo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(customer_logo);
    if (message_arena != submessage_arena) {
      customer_logo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer_logo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.customer_logo_ = customer_logo;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.customer_logo)
}

// optional string change_password_uri = 32;
inline bool PolicyData::_internal_has_change_password_uri() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool PolicyData::has_change_password_uri() const {
  return _internal_has_change_password_uri();
}
inline void PolicyData::clear_change_password_uri() {
  _impl_.change_password_uri_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const std::string& PolicyData::change_password_uri() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.change_password_uri)
  return _internal_change_password_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_change_password_uri(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00010000u;
 _impl_.change_password_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.change_password_uri)
}
inline std::string* PolicyData::mutable_change_password_uri() {
  std::string* _s = _internal_mutable_change_password_uri();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.change_password_uri)
  return _s;
}
inline const std::string& PolicyData::_internal_change_password_uri() const {
  return _impl_.change_password_uri_.Get();
}
inline void PolicyData::_internal_set_change_password_uri(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.change_password_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_change_password_uri() {
  _impl_._has_bits_[0] |= 0x00010000u;
  return _impl_.change_password_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_change_password_uri() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.change_password_uri)
  if (!_internal_has_change_password_uri()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00010000u;
  auto* p = _impl_.change_password_uri_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.change_password_uri_.IsDefault()) {
    _impl_.change_password_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_change_password_uri(std::string* change_password_uri) {
  if (change_password_uri != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.change_password_uri_.SetAllocated(change_password_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.change_password_uri_.IsDefault()) {
    _impl_.change_password_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.change_password_uri)
}

// optional .enterprise_management.ClientActionRequired client_action_required = 33;
inline bool PolicyData::_internal_has_client_action_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_action_required_ != nullptr);
  return value;
}
inline bool PolicyData::has_client_action_required() const {
  return _internal_has_client_action_required();
}
inline void PolicyData::clear_client_action_required() {
  if (_impl_.client_action_required_ != nullptr) _impl_.client_action_required_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::enterprise_management::ClientActionRequired& PolicyData::_internal_client_action_required() const {
  const ::enterprise_management::ClientActionRequired* p = _impl_.client_action_required_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ClientActionRequired&>(
      ::enterprise_management::_ClientActionRequired_default_instance_);
}
inline const ::enterprise_management::ClientActionRequired& PolicyData::client_action_required() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.client_action_required)
  return _internal_client_action_required();
}
inline void PolicyData::unsafe_arena_set_allocated_client_action_required(
    ::enterprise_management::ClientActionRequired* client_action_required) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_action_required_);
  }
  _impl_.client_action_required_ = client_action_required;
  if (client_action_required) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PolicyData.client_action_required)
}
inline ::enterprise_management::ClientActionRequired* PolicyData::release_client_action_required() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::enterprise_management::ClientActionRequired* temp = _impl_.client_action_required_;
  _impl_.client_action_required_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ClientActionRequired* PolicyData::unsafe_arena_release_client_action_required() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.client_action_required)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::enterprise_management::ClientActionRequired* temp = _impl_.client_action_required_;
  _impl_.client_action_required_ = nullptr;
  return temp;
}
inline ::enterprise_management::ClientActionRequired* PolicyData::_internal_mutable_client_action_required() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.client_action_required_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ClientActionRequired>(GetArenaForAllocation());
    _impl_.client_action_required_ = p;
  }
  return _impl_.client_action_required_;
}
inline ::enterprise_management::ClientActionRequired* PolicyData::mutable_client_action_required() {
  ::enterprise_management::ClientActionRequired* _msg = _internal_mutable_client_action_required();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.client_action_required)
  return _msg;
}
inline void PolicyData::set_allocated_client_action_required(::enterprise_management::ClientActionRequired* client_action_required) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_action_required_;
  }
  if (client_action_required) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_action_required);
    if (message_arena != submessage_arena) {
      client_action_required = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_action_required, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.client_action_required_ = client_action_required;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.client_action_required)
}

// optional string obfuscated_customer_id = 34;
inline bool PolicyData::_internal_has_obfuscated_customer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool PolicyData::has_obfuscated_customer_id() const {
  return _internal_has_obfuscated_customer_id();
}
inline void PolicyData::clear_obfuscated_customer_id() {
  _impl_.obfuscated_customer_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const std::string& PolicyData::obfuscated_customer_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.obfuscated_customer_id)
  return _internal_obfuscated_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_obfuscated_customer_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00020000u;
 _impl_.obfuscated_customer_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.obfuscated_customer_id)
}
inline std::string* PolicyData::mutable_obfuscated_customer_id() {
  std::string* _s = _internal_mutable_obfuscated_customer_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.obfuscated_customer_id)
  return _s;
}
inline const std::string& PolicyData::_internal_obfuscated_customer_id() const {
  return _impl_.obfuscated_customer_id_.Get();
}
inline void PolicyData::_internal_set_obfuscated_customer_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.obfuscated_customer_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_obfuscated_customer_id() {
  _impl_._has_bits_[0] |= 0x00020000u;
  return _impl_.obfuscated_customer_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_obfuscated_customer_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.obfuscated_customer_id)
  if (!_internal_has_obfuscated_customer_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00020000u;
  auto* p = _impl_.obfuscated_customer_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obfuscated_customer_id_.IsDefault()) {
    _impl_.obfuscated_customer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_obfuscated_customer_id(std::string* obfuscated_customer_id) {
  if (obfuscated_customer_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.obfuscated_customer_id_.SetAllocated(obfuscated_customer_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obfuscated_customer_id_.IsDefault()) {
    _impl_.obfuscated_customer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.obfuscated_customer_id)
}

// optional .enterprise_management.PolicyData.MetricsLogSegment metrics_log_segment = 35;
inline bool PolicyData::_internal_has_metrics_log_segment() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool PolicyData::has_metrics_log_segment() const {
  return _internal_has_metrics_log_segment();
}
inline void PolicyData::clear_metrics_log_segment() {
  _impl_.metrics_log_segment_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline ::enterprise_management::PolicyData_MetricsLogSegment PolicyData::_internal_metrics_log_segment() const {
  return static_cast< ::enterprise_management::PolicyData_MetricsLogSegment >(_impl_.metrics_log_segment_);
}
inline ::enterprise_management::PolicyData_MetricsLogSegment PolicyData::metrics_log_segment() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.metrics_log_segment)
  return _internal_metrics_log_segment();
}
inline void PolicyData::_internal_set_metrics_log_segment(::enterprise_management::PolicyData_MetricsLogSegment value) {
  assert(::enterprise_management::PolicyData_MetricsLogSegment_IsValid(value));
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.metrics_log_segment_ = value;
}
inline void PolicyData::set_metrics_log_segment(::enterprise_management::PolicyData_MetricsLogSegment value) {
  _internal_set_metrics_log_segment(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.metrics_log_segment)
}

// optional string managed_by = 36;
inline bool PolicyData::_internal_has_managed_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool PolicyData::has_managed_by() const {
  return _internal_has_managed_by();
}
inline void PolicyData::clear_managed_by() {
  _impl_.managed_by_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const std::string& PolicyData::managed_by() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.managed_by)
  return _internal_managed_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_managed_by(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00040000u;
 _impl_.managed_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.managed_by)
}
inline std::string* PolicyData::mutable_managed_by() {
  std::string* _s = _internal_mutable_managed_by();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.managed_by)
  return _s;
}
inline const std::string& PolicyData::_internal_managed_by() const {
  return _impl_.managed_by_.Get();
}
inline void PolicyData::_internal_set_managed_by(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.managed_by_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_managed_by() {
  _impl_._has_bits_[0] |= 0x00040000u;
  return _impl_.managed_by_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_managed_by() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.managed_by)
  if (!_internal_has_managed_by()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00040000u;
  auto* p = _impl_.managed_by_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.managed_by_.IsDefault()) {
    _impl_.managed_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_managed_by(std::string* managed_by) {
  if (managed_by != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.managed_by_.SetAllocated(managed_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.managed_by_.IsDefault()) {
    _impl_.managed_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.managed_by)
}

// optional string sso_profile = 37;
inline bool PolicyData::_internal_has_sso_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool PolicyData::has_sso_profile() const {
  return _internal_has_sso_profile();
}
inline void PolicyData::clear_sso_profile() {
  _impl_.sso_profile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const std::string& PolicyData::sso_profile() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.sso_profile)
  return _internal_sso_profile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_sso_profile(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00080000u;
 _impl_.sso_profile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.sso_profile)
}
inline std::string* PolicyData::mutable_sso_profile() {
  std::string* _s = _internal_mutable_sso_profile();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.sso_profile)
  return _s;
}
inline const std::string& PolicyData::_internal_sso_profile() const {
  return _impl_.sso_profile_.Get();
}
inline void PolicyData::_internal_set_sso_profile(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.sso_profile_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_sso_profile() {
  _impl_._has_bits_[0] |= 0x00080000u;
  return _impl_.sso_profile_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_sso_profile() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.sso_profile)
  if (!_internal_has_sso_profile()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00080000u;
  auto* p = _impl_.sso_profile_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sso_profile_.IsDefault()) {
    _impl_.sso_profile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_sso_profile(std::string* sso_profile) {
  if (sso_profile != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.sso_profile_.SetAllocated(sso_profile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sso_profile_.IsDefault()) {
    _impl_.sso_profile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.sso_profile)
}

// optional string license_sku = 38;
inline bool PolicyData::_internal_has_license_sku() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool PolicyData::has_license_sku() const {
  return _internal_has_license_sku();
}
inline void PolicyData::clear_license_sku() {
  _impl_.license_sku_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const std::string& PolicyData::license_sku() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyData.license_sku)
  return _internal_license_sku();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyData::set_license_sku(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00100000u;
 _impl_.license_sku_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyData.license_sku)
}
inline std::string* PolicyData::mutable_license_sku() {
  std::string* _s = _internal_mutable_license_sku();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyData.license_sku)
  return _s;
}
inline const std::string& PolicyData::_internal_license_sku() const {
  return _impl_.license_sku_.Get();
}
inline void PolicyData::_internal_set_license_sku(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.license_sku_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyData::_internal_mutable_license_sku() {
  _impl_._has_bits_[0] |= 0x00100000u;
  return _impl_.license_sku_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyData::release_license_sku() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyData.license_sku)
  if (!_internal_has_license_sku()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00100000u;
  auto* p = _impl_.license_sku_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_sku_.IsDefault()) {
    _impl_.license_sku_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyData::set_allocated_license_sku(std::string* license_sku) {
  if (license_sku != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.license_sku_.SetAllocated(license_sku, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_sku_.IsDefault()) {
    _impl_.license_sku_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyData.license_sku)
}

// -------------------------------------------------------------------

// ClientActionRequired

// optional bool enrollment_certificate_needed = 1;
inline bool ClientActionRequired::_internal_has_enrollment_certificate_needed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientActionRequired::has_enrollment_certificate_needed() const {
  return _internal_has_enrollment_certificate_needed();
}
inline void ClientActionRequired::clear_enrollment_certificate_needed() {
  _impl_.enrollment_certificate_needed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ClientActionRequired::_internal_enrollment_certificate_needed() const {
  return _impl_.enrollment_certificate_needed_;
}
inline bool ClientActionRequired::enrollment_certificate_needed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientActionRequired.enrollment_certificate_needed)
  return _internal_enrollment_certificate_needed();
}
inline void ClientActionRequired::_internal_set_enrollment_certificate_needed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enrollment_certificate_needed_ = value;
}
inline void ClientActionRequired::set_enrollment_certificate_needed(bool value) {
  _internal_set_enrollment_certificate_needed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ClientActionRequired.enrollment_certificate_needed)
}

// -------------------------------------------------------------------

// PolicyFetchResponse

// optional int32 error_code = 1;
inline bool PolicyFetchResponse::_internal_has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void PolicyFetchResponse::clear_error_code() {
  _impl_.error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t PolicyFetchResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t PolicyFetchResponse::error_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.error_code)
  return _internal_error_code();
}
inline void PolicyFetchResponse::_internal_set_error_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.error_code_ = value;
}
inline void PolicyFetchResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.error_code)
}

// optional string error_message = 2;
inline bool PolicyFetchResponse::_internal_has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void PolicyFetchResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyFetchResponse::error_message() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.error_message)
}
inline std::string* PolicyFetchResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.error_message)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void PolicyFetchResponse::_internal_set_error_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_error_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.error_message)
}

// optional bytes policy_data = 3;
inline bool PolicyFetchResponse::_internal_has_policy_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_policy_data() const {
  return _internal_has_policy_data();
}
inline void PolicyFetchResponse::clear_policy_data() {
  _impl_.policy_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyFetchResponse::policy_data() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_data)
  return _internal_policy_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_policy_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.policy_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_data)
}
inline std::string* PolicyFetchResponse::mutable_policy_data() {
  std::string* _s = _internal_mutable_policy_data();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.policy_data)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_policy_data() const {
  return _impl_.policy_data_.Get();
}
inline void PolicyFetchResponse::_internal_set_policy_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.policy_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_policy_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.policy_data_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_policy_data() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.policy_data)
  if (!_internal_has_policy_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.policy_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_data_.IsDefault()) {
    _impl_.policy_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_policy_data(std::string* policy_data) {
  if (policy_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.policy_data_.SetAllocated(policy_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_data_.IsDefault()) {
    _impl_.policy_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.policy_data)
}

// optional bytes policy_data_signature = 4;
inline bool PolicyFetchResponse::_internal_has_policy_data_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_policy_data_signature() const {
  return _internal_has_policy_data_signature();
}
inline void PolicyFetchResponse::clear_policy_data_signature() {
  _impl_.policy_data_signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PolicyFetchResponse::policy_data_signature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_data_signature)
  return _internal_policy_data_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_policy_data_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.policy_data_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_data_signature)
}
inline std::string* PolicyFetchResponse::mutable_policy_data_signature() {
  std::string* _s = _internal_mutable_policy_data_signature();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.policy_data_signature)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_policy_data_signature() const {
  return _impl_.policy_data_signature_.Get();
}
inline void PolicyFetchResponse::_internal_set_policy_data_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.policy_data_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_policy_data_signature() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.policy_data_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_policy_data_signature() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.policy_data_signature)
  if (!_internal_has_policy_data_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.policy_data_signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_data_signature_.IsDefault()) {
    _impl_.policy_data_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_policy_data_signature(std::string* policy_data_signature) {
  if (policy_data_signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.policy_data_signature_.SetAllocated(policy_data_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_data_signature_.IsDefault()) {
    _impl_.policy_data_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.policy_data_signature)
}

// optional bytes new_public_key = 5;
inline bool PolicyFetchResponse::_internal_has_new_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_new_public_key() const {
  return _internal_has_new_public_key();
}
inline void PolicyFetchResponse::clear_new_public_key() {
  _impl_.new_public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PolicyFetchResponse::new_public_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key)
  return _internal_new_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_new_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.new_public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key() {
  std::string* _s = _internal_mutable_new_public_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_new_public_key() const {
  return _impl_.new_public_key_.Get();
}
inline void PolicyFetchResponse::_internal_set_new_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.new_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_new_public_key() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.new_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_new_public_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key)
  if (!_internal_has_new_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.new_public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_.IsDefault()) {
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_new_public_key(std::string* new_public_key) {
  if (new_public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.new_public_key_.SetAllocated(new_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_.IsDefault()) {
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key)
}

// optional bytes new_public_key_signature = 6;
inline bool PolicyFetchResponse::_internal_has_new_public_key_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_new_public_key_signature() const {
  return _internal_has_new_public_key_signature();
}
inline void PolicyFetchResponse::clear_new_public_key_signature() {
  _impl_.new_public_key_signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PolicyFetchResponse::new_public_key_signature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_signature)
  return _internal_new_public_key_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_new_public_key_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.new_public_key_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key_signature() {
  std::string* _s = _internal_mutable_new_public_key_signature();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_signature)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_new_public_key_signature() const {
  return _impl_.new_public_key_signature_.Get();
}
inline void PolicyFetchResponse::_internal_set_new_public_key_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.new_public_key_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_new_public_key_signature() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.new_public_key_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_new_public_key_signature() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_signature)
  if (!_internal_has_new_public_key_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.new_public_key_signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_signature_.IsDefault()) {
    _impl_.new_public_key_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_new_public_key_signature(std::string* new_public_key_signature) {
  if (new_public_key_signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.new_public_key_signature_.SetAllocated(new_public_key_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_signature_.IsDefault()) {
    _impl_.new_public_key_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_signature)
}

// optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
inline bool PolicyFetchResponse::_internal_has_new_public_key_verification_signature_deprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_new_public_key_verification_signature_deprecated() const {
  return _internal_has_new_public_key_verification_signature_deprecated();
}
inline void PolicyFetchResponse::clear_new_public_key_verification_signature_deprecated() {
  _impl_.new_public_key_verification_signature_deprecated_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PolicyFetchResponse::new_public_key_verification_signature_deprecated() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
  return _internal_new_public_key_verification_signature_deprecated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_new_public_key_verification_signature_deprecated(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.new_public_key_verification_signature_deprecated_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key_verification_signature_deprecated() {
  std::string* _s = _internal_mutable_new_public_key_verification_signature_deprecated();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_new_public_key_verification_signature_deprecated() const {
  return _impl_.new_public_key_verification_signature_deprecated_.Get();
}
inline void PolicyFetchResponse::_internal_set_new_public_key_verification_signature_deprecated(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.new_public_key_verification_signature_deprecated_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_new_public_key_verification_signature_deprecated() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.new_public_key_verification_signature_deprecated_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_new_public_key_verification_signature_deprecated() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
  if (!_internal_has_new_public_key_verification_signature_deprecated()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.new_public_key_verification_signature_deprecated_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_verification_signature_deprecated_.IsDefault()) {
    _impl_.new_public_key_verification_signature_deprecated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_signature_deprecated(std::string* new_public_key_verification_signature_deprecated) {
  if (new_public_key_verification_signature_deprecated != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.new_public_key_verification_signature_deprecated_.SetAllocated(new_public_key_verification_signature_deprecated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_verification_signature_deprecated_.IsDefault()) {
    _impl_.new_public_key_verification_signature_deprecated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_signature_deprecated)
}

// optional bytes new_public_key_verification_data = 8;
inline bool PolicyFetchResponse::_internal_has_new_public_key_verification_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_new_public_key_verification_data() const {
  return _internal_has_new_public_key_verification_data();
}
inline void PolicyFetchResponse::clear_new_public_key_verification_data() {
  _impl_.new_public_key_verification_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& PolicyFetchResponse::new_public_key_verification_data() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
  return _internal_new_public_key_verification_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_new_public_key_verification_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.new_public_key_verification_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key_verification_data() {
  std::string* _s = _internal_mutable_new_public_key_verification_data();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_new_public_key_verification_data() const {
  return _impl_.new_public_key_verification_data_.Get();
}
inline void PolicyFetchResponse::_internal_set_new_public_key_verification_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.new_public_key_verification_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_new_public_key_verification_data() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.new_public_key_verification_data_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_new_public_key_verification_data() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
  if (!_internal_has_new_public_key_verification_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.new_public_key_verification_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_verification_data_.IsDefault()) {
    _impl_.new_public_key_verification_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_data(std::string* new_public_key_verification_data) {
  if (new_public_key_verification_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.new_public_key_verification_data_.SetAllocated(new_public_key_verification_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_verification_data_.IsDefault()) {
    _impl_.new_public_key_verification_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_data)
}

// optional bytes new_public_key_verification_data_signature = 9;
inline bool PolicyFetchResponse::_internal_has_new_public_key_verification_data_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_new_public_key_verification_data_signature() const {
  return _internal_has_new_public_key_verification_data_signature();
}
inline void PolicyFetchResponse::clear_new_public_key_verification_data_signature() {
  _impl_.new_public_key_verification_data_signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& PolicyFetchResponse::new_public_key_verification_data_signature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
  return _internal_new_public_key_verification_data_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_new_public_key_verification_data_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.new_public_key_verification_data_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}
inline std::string* PolicyFetchResponse::mutable_new_public_key_verification_data_signature() {
  std::string* _s = _internal_mutable_new_public_key_verification_data_signature();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_new_public_key_verification_data_signature() const {
  return _impl_.new_public_key_verification_data_signature_.Get();
}
inline void PolicyFetchResponse::_internal_set_new_public_key_verification_data_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.new_public_key_verification_data_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_new_public_key_verification_data_signature() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.new_public_key_verification_data_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_new_public_key_verification_data_signature() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
  if (!_internal_has_new_public_key_verification_data_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.new_public_key_verification_data_signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_verification_data_signature_.IsDefault()) {
    _impl_.new_public_key_verification_data_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_new_public_key_verification_data_signature(std::string* new_public_key_verification_data_signature) {
  if (new_public_key_verification_data_signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.new_public_key_verification_data_signature_.SetAllocated(new_public_key_verification_data_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_verification_data_signature_.IsDefault()) {
    _impl_.new_public_key_verification_data_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.new_public_key_verification_data_signature)
}

// optional string policy_type = 10 [deprecated = true];
inline bool PolicyFetchResponse::_internal_has_policy_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_policy_type() const {
  return _internal_has_policy_type();
}
inline void PolicyFetchResponse::clear_policy_type() {
  _impl_.policy_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& PolicyFetchResponse::policy_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_type)
  return _internal_policy_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchResponse::set_policy_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.policy_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_type)
}
inline std::string* PolicyFetchResponse::mutable_policy_type() {
  std::string* _s = _internal_mutable_policy_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchResponse.policy_type)
  return _s;
}
inline const std::string& PolicyFetchResponse::_internal_policy_type() const {
  return _impl_.policy_type_.Get();
}
inline void PolicyFetchResponse::_internal_set_policy_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.policy_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::_internal_mutable_policy_type() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.policy_type_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchResponse::release_policy_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchResponse.policy_type)
  if (!_internal_has_policy_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.policy_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_type_.IsDefault()) {
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchResponse::set_allocated_policy_type(std::string* policy_type) {
  if (policy_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.policy_type_.SetAllocated(policy_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_type_.IsDefault()) {
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchResponse.policy_type)
}

// optional .enterprise_management.PolicyFetchRequest.SignatureType policy_data_signature_type = 11;
inline bool PolicyFetchResponse::_internal_has_policy_data_signature_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PolicyFetchResponse::has_policy_data_signature_type() const {
  return _internal_has_policy_data_signature_type();
}
inline void PolicyFetchResponse::clear_policy_data_signature_type() {
  _impl_.policy_data_signature_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType PolicyFetchResponse::_internal_policy_data_signature_type() const {
  return static_cast< ::enterprise_management::PolicyFetchRequest_SignatureType >(_impl_.policy_data_signature_type_);
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType PolicyFetchResponse::policy_data_signature_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchResponse.policy_data_signature_type)
  return _internal_policy_data_signature_type();
}
inline void PolicyFetchResponse::_internal_set_policy_data_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
  assert(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.policy_data_signature_type_ = value;
}
inline void PolicyFetchResponse::set_policy_data_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
  _internal_set_policy_data_signature_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchResponse.policy_data_signature_type)
}

// -------------------------------------------------------------------

// DEPRECATEDPolicyPublicKeyAndDomain

// optional bytes new_public_key = 1;
inline bool DEPRECATEDPolicyPublicKeyAndDomain::_internal_has_new_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DEPRECATEDPolicyPublicKeyAndDomain::has_new_public_key() const {
  return _internal_has_new_public_key();
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::clear_new_public_key() {
  _impl_.new_public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DEPRECATEDPolicyPublicKeyAndDomain::new_public_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
  return _internal_new_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DEPRECATEDPolicyPublicKeyAndDomain::set_new_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::mutable_new_public_key() {
  std::string* _s = _internal_mutable_new_public_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
  return _s;
}
inline const std::string& DEPRECATEDPolicyPublicKeyAndDomain::_internal_new_public_key() const {
  return _impl_.new_public_key_.Get();
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::_internal_set_new_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::_internal_mutable_new_public_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::release_new_public_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
  if (!_internal_has_new_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_.IsDefault()) {
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_allocated_new_public_key(std::string* new_public_key) {
  if (new_public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_public_key_.SetAllocated(new_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_.IsDefault()) {
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.new_public_key)
}

// optional string domain = 2;
inline bool DEPRECATEDPolicyPublicKeyAndDomain::_internal_has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DEPRECATEDPolicyPublicKeyAndDomain::has_domain() const {
  return _internal_has_domain();
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::clear_domain() {
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DEPRECATEDPolicyPublicKeyAndDomain::domain() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DEPRECATEDPolicyPublicKeyAndDomain::set_domain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
  return _s;
}
inline const std::string& DEPRECATEDPolicyPublicKeyAndDomain::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::_internal_set_domain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::_internal_mutable_domain() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* DEPRECATEDPolicyPublicKeyAndDomain::release_domain() {
  // @@protoc_insertion_point(field_release:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
  if (!_internal_has_domain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DEPRECATEDPolicyPublicKeyAndDomain::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain.domain)
}

// -------------------------------------------------------------------

// PublicKeyVerificationData

// optional bytes new_public_key = 1;
inline bool PublicKeyVerificationData::_internal_has_new_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublicKeyVerificationData::has_new_public_key() const {
  return _internal_has_new_public_key();
}
inline void PublicKeyVerificationData::clear_new_public_key() {
  _impl_.new_public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublicKeyVerificationData::new_public_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.new_public_key)
  return _internal_new_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicKeyVerificationData::set_new_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.new_public_key)
}
inline std::string* PublicKeyVerificationData::mutable_new_public_key() {
  std::string* _s = _internal_mutable_new_public_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PublicKeyVerificationData.new_public_key)
  return _s;
}
inline const std::string& PublicKeyVerificationData::_internal_new_public_key() const {
  return _impl_.new_public_key_.Get();
}
inline void PublicKeyVerificationData::_internal_set_new_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicKeyVerificationData::_internal_mutable_new_public_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicKeyVerificationData::release_new_public_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.PublicKeyVerificationData.new_public_key)
  if (!_internal_has_new_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_.IsDefault()) {
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublicKeyVerificationData::set_allocated_new_public_key(std::string* new_public_key) {
  if (new_public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_public_key_.SetAllocated(new_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_public_key_.IsDefault()) {
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicKeyVerificationData.new_public_key)
}

// optional string domain = 2;
inline bool PublicKeyVerificationData::_internal_has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublicKeyVerificationData::has_domain() const {
  return _internal_has_domain();
}
inline void PublicKeyVerificationData::clear_domain() {
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PublicKeyVerificationData::domain() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicKeyVerificationData::set_domain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.domain)
}
inline std::string* PublicKeyVerificationData::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PublicKeyVerificationData.domain)
  return _s;
}
inline const std::string& PublicKeyVerificationData::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void PublicKeyVerificationData::_internal_set_domain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicKeyVerificationData::_internal_mutable_domain() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicKeyVerificationData::release_domain() {
  // @@protoc_insertion_point(field_release:enterprise_management.PublicKeyVerificationData.domain)
  if (!_internal_has_domain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublicKeyVerificationData::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicKeyVerificationData.domain)
}

// optional int32 new_public_key_version = 3;
inline bool PublicKeyVerificationData::_internal_has_new_public_key_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PublicKeyVerificationData::has_new_public_key_version() const {
  return _internal_has_new_public_key_version();
}
inline void PublicKeyVerificationData::clear_new_public_key_version() {
  _impl_.new_public_key_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t PublicKeyVerificationData::_internal_new_public_key_version() const {
  return _impl_.new_public_key_version_;
}
inline int32_t PublicKeyVerificationData::new_public_key_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PublicKeyVerificationData.new_public_key_version)
  return _internal_new_public_key_version();
}
inline void PublicKeyVerificationData::_internal_set_new_public_key_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.new_public_key_version_ = value;
}
inline void PublicKeyVerificationData::set_new_public_key_version(int32_t value) {
  _internal_set_new_public_key_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PublicKeyVerificationData.new_public_key_version)
}

// -------------------------------------------------------------------

// DevicePolicyRequest

// repeated .enterprise_management.PolicyFetchRequest requests = 3;
inline int DevicePolicyRequest::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int DevicePolicyRequest::requests_size() const {
  return _internal_requests_size();
}
inline void DevicePolicyRequest::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::enterprise_management::PolicyFetchRequest* DevicePolicyRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePolicyRequest.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest >*
DevicePolicyRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DevicePolicyRequest.requests)
  return &_impl_.requests_;
}
inline const ::enterprise_management::PolicyFetchRequest& DevicePolicyRequest::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::enterprise_management::PolicyFetchRequest& DevicePolicyRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePolicyRequest.requests)
  return _internal_requests(index);
}
inline ::enterprise_management::PolicyFetchRequest* DevicePolicyRequest::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::enterprise_management::PolicyFetchRequest* DevicePolicyRequest::add_requests() {
  ::enterprise_management::PolicyFetchRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:enterprise_management.DevicePolicyRequest.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchRequest >&
DevicePolicyRequest::requests() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DevicePolicyRequest.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// DevicePolicyResponse

// repeated .enterprise_management.PolicyFetchResponse responses = 3;
inline int DevicePolicyResponse::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int DevicePolicyResponse::responses_size() const {
  return _internal_responses_size();
}
inline void DevicePolicyResponse::clear_responses() {
  _impl_.responses_.Clear();
}
inline ::enterprise_management::PolicyFetchResponse* DevicePolicyResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePolicyResponse.responses)
  return _impl_.responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse >*
DevicePolicyResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DevicePolicyResponse.responses)
  return &_impl_.responses_;
}
inline const ::enterprise_management::PolicyFetchResponse& DevicePolicyResponse::_internal_responses(int index) const {
  return _impl_.responses_.Get(index);
}
inline const ::enterprise_management::PolicyFetchResponse& DevicePolicyResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePolicyResponse.responses)
  return _internal_responses(index);
}
inline ::enterprise_management::PolicyFetchResponse* DevicePolicyResponse::_internal_add_responses() {
  return _impl_.responses_.Add();
}
inline ::enterprise_management::PolicyFetchResponse* DevicePolicyResponse::add_responses() {
  ::enterprise_management::PolicyFetchResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:enterprise_management.DevicePolicyResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchResponse >&
DevicePolicyResponse::responses() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DevicePolicyResponse.responses)
  return _impl_.responses_;
}

// -------------------------------------------------------------------

// TimePeriod

// optional int64 start_timestamp = 1;
inline bool TimePeriod::_internal_has_start_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimePeriod::has_start_timestamp() const {
  return _internal_has_start_timestamp();
}
inline void TimePeriod::clear_start_timestamp() {
  _impl_.start_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TimePeriod::_internal_start_timestamp() const {
  return _impl_.start_timestamp_;
}
inline int64_t TimePeriod::start_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TimePeriod.start_timestamp)
  return _internal_start_timestamp();
}
inline void TimePeriod::_internal_set_start_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_timestamp_ = value;
}
inline void TimePeriod::set_start_timestamp(int64_t value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TimePeriod.start_timestamp)
}

// optional int64 end_timestamp = 2;
inline bool TimePeriod::_internal_has_end_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimePeriod::has_end_timestamp() const {
  return _internal_has_end_timestamp();
}
inline void TimePeriod::clear_end_timestamp() {
  _impl_.end_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t TimePeriod::_internal_end_timestamp() const {
  return _impl_.end_timestamp_;
}
inline int64_t TimePeriod::end_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TimePeriod.end_timestamp)
  return _internal_end_timestamp();
}
inline void TimePeriod::_internal_set_end_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_timestamp_ = value;
}
inline void TimePeriod::set_end_timestamp(int64_t value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TimePeriod.end_timestamp)
}

// -------------------------------------------------------------------

// ActiveTimePeriod

// optional .enterprise_management.TimePeriod time_period = 1;
inline bool ActiveTimePeriod::_internal_has_time_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_period_ != nullptr);
  return value;
}
inline bool ActiveTimePeriod::has_time_period() const {
  return _internal_has_time_period();
}
inline void ActiveTimePeriod::clear_time_period() {
  if (_impl_.time_period_ != nullptr) _impl_.time_period_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::TimePeriod& ActiveTimePeriod::_internal_time_period() const {
  const ::enterprise_management::TimePeriod* p = _impl_.time_period_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::TimePeriod&>(
      ::enterprise_management::_TimePeriod_default_instance_);
}
inline const ::enterprise_management::TimePeriod& ActiveTimePeriod::time_period() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.time_period)
  return _internal_time_period();
}
inline void ActiveTimePeriod::unsafe_arena_set_allocated_time_period(
    ::enterprise_management::TimePeriod* time_period) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_period_);
  }
  _impl_.time_period_ = time_period;
  if (time_period) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ActiveTimePeriod.time_period)
}
inline ::enterprise_management::TimePeriod* ActiveTimePeriod::release_time_period() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::TimePeriod* temp = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::TimePeriod* ActiveTimePeriod::unsafe_arena_release_time_period() {
  // @@protoc_insertion_point(field_release:enterprise_management.ActiveTimePeriod.time_period)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::TimePeriod* temp = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
  return temp;
}
inline ::enterprise_management::TimePeriod* ActiveTimePeriod::_internal_mutable_time_period() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.time_period_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::TimePeriod>(GetArenaForAllocation());
    _impl_.time_period_ = p;
  }
  return _impl_.time_period_;
}
inline ::enterprise_management::TimePeriod* ActiveTimePeriod::mutable_time_period() {
  ::enterprise_management::TimePeriod* _msg = _internal_mutable_time_period();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveTimePeriod.time_period)
  return _msg;
}
inline void ActiveTimePeriod::set_allocated_time_period(::enterprise_management::TimePeriod* time_period) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_period_;
  }
  if (time_period) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time_period);
    if (message_arena != submessage_arena) {
      time_period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_period, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.time_period_ = time_period;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveTimePeriod.time_period)
}

// optional int32 active_duration = 2;
inline bool ActiveTimePeriod::_internal_has_active_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ActiveTimePeriod::has_active_duration() const {
  return _internal_has_active_duration();
}
inline void ActiveTimePeriod::clear_active_duration() {
  _impl_.active_duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t ActiveTimePeriod::_internal_active_duration() const {
  return _impl_.active_duration_;
}
inline int32_t ActiveTimePeriod::active_duration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.active_duration)
  return _internal_active_duration();
}
inline void ActiveTimePeriod::_internal_set_active_duration(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.active_duration_ = value;
}
inline void ActiveTimePeriod::set_active_duration(int32_t value) {
  _internal_set_active_duration(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ActiveTimePeriod.active_duration)
}

// optional string user_email = 3;
inline bool ActiveTimePeriod::_internal_has_user_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActiveTimePeriod::has_user_email() const {
  return _internal_has_user_email();
}
inline void ActiveTimePeriod::clear_user_email() {
  _impl_.user_email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveTimePeriod::user_email() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.user_email)
  return _internal_user_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveTimePeriod::set_user_email(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ActiveTimePeriod.user_email)
}
inline std::string* ActiveTimePeriod::mutable_user_email() {
  std::string* _s = _internal_mutable_user_email();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveTimePeriod.user_email)
  return _s;
}
inline const std::string& ActiveTimePeriod::_internal_user_email() const {
  return _impl_.user_email_.Get();
}
inline void ActiveTimePeriod::_internal_set_user_email(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_email_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveTimePeriod::_internal_mutable_user_email() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_email_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveTimePeriod::release_user_email() {
  // @@protoc_insertion_point(field_release:enterprise_management.ActiveTimePeriod.user_email)
  if (!_internal_has_user_email()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_email_.IsDefault()) {
    _impl_.user_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActiveTimePeriod::set_allocated_user_email(std::string* user_email) {
  if (user_email != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_email_.SetAllocated(user_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_email_.IsDefault()) {
    _impl_.user_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveTimePeriod.user_email)
}

// optional .enterprise_management.ActiveTimePeriod.SessionType session_type = 4;
inline bool ActiveTimePeriod::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ActiveTimePeriod::has_session_type() const {
  return _internal_has_session_type();
}
inline void ActiveTimePeriod::clear_session_type() {
  _impl_.session_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::ActiveTimePeriod_SessionType ActiveTimePeriod::_internal_session_type() const {
  return static_cast< ::enterprise_management::ActiveTimePeriod_SessionType >(_impl_.session_type_);
}
inline ::enterprise_management::ActiveTimePeriod_SessionType ActiveTimePeriod::session_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveTimePeriod.session_type)
  return _internal_session_type();
}
inline void ActiveTimePeriod::_internal_set_session_type(::enterprise_management::ActiveTimePeriod_SessionType value) {
  assert(::enterprise_management::ActiveTimePeriod_SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_type_ = value;
}
inline void ActiveTimePeriod::set_session_type(::enterprise_management::ActiveTimePeriod_SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ActiveTimePeriod.session_type)
}

// -------------------------------------------------------------------

// NetworkInterface

// optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
inline bool NetworkInterface::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool NetworkInterface::has_type() const {
  return _internal_has_type();
}
inline void NetworkInterface::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::enterprise_management::NetworkInterface_NetworkDeviceType NetworkInterface::_internal_type() const {
  return static_cast< ::enterprise_management::NetworkInterface_NetworkDeviceType >(_impl_.type_);
}
inline ::enterprise_management::NetworkInterface_NetworkDeviceType NetworkInterface::type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.type)
  return _internal_type();
}
inline void NetworkInterface::_internal_set_type(::enterprise_management::NetworkInterface_NetworkDeviceType value) {
  assert(::enterprise_management::NetworkInterface_NetworkDeviceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.type_ = value;
}
inline void NetworkInterface::set_type(::enterprise_management::NetworkInterface_NetworkDeviceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.type)
}

// optional string mac_address = 2;
inline bool NetworkInterface::_internal_has_mac_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetworkInterface::has_mac_address() const {
  return _internal_has_mac_address();
}
inline void NetworkInterface::clear_mac_address() {
  _impl_.mac_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkInterface::mac_address() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkInterface::set_mac_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mac_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.mac_address)
}
inline std::string* NetworkInterface::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.mac_address)
  return _s;
}
inline const std::string& NetworkInterface::_internal_mac_address() const {
  return _impl_.mac_address_.Get();
}
inline void NetworkInterface::_internal_set_mac_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_mac_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mac_address_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_mac_address() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.mac_address)
  if (!_internal_has_mac_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mac_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_address_.IsDefault()) {
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkInterface::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mac_address_.SetAllocated(mac_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_address_.IsDefault()) {
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.mac_address)
}

// optional string meid = 3;
inline bool NetworkInterface::_internal_has_meid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NetworkInterface::has_meid() const {
  return _internal_has_meid();
}
inline void NetworkInterface::clear_meid() {
  _impl_.meid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkInterface::meid() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.meid)
  return _internal_meid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkInterface::set_meid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.meid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.meid)
}
inline std::string* NetworkInterface::mutable_meid() {
  std::string* _s = _internal_mutable_meid();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.meid)
  return _s;
}
inline const std::string& NetworkInterface::_internal_meid() const {
  return _impl_.meid_.Get();
}
inline void NetworkInterface::_internal_set_meid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.meid_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_meid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.meid_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_meid() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.meid)
  if (!_internal_has_meid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.meid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meid_.IsDefault()) {
    _impl_.meid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkInterface::set_allocated_meid(std::string* meid) {
  if (meid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.meid_.SetAllocated(meid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meid_.IsDefault()) {
    _impl_.meid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.meid)
}

// optional string imei = 4;
inline bool NetworkInterface::_internal_has_imei() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NetworkInterface::has_imei() const {
  return _internal_has_imei();
}
inline void NetworkInterface::clear_imei() {
  _impl_.imei_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetworkInterface::imei() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.imei)
  return _internal_imei();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkInterface::set_imei(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.imei_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.imei)
}
inline std::string* NetworkInterface::mutable_imei() {
  std::string* _s = _internal_mutable_imei();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.imei)
  return _s;
}
inline const std::string& NetworkInterface::_internal_imei() const {
  return _impl_.imei_.Get();
}
inline void NetworkInterface::_internal_set_imei(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.imei_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_imei() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.imei_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_imei() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.imei)
  if (!_internal_has_imei()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.imei_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imei_.IsDefault()) {
    _impl_.imei_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkInterface::set_allocated_imei(std::string* imei) {
  if (imei != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.imei_.SetAllocated(imei, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imei_.IsDefault()) {
    _impl_.imei_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.imei)
}

// optional string device_path = 5;
inline bool NetworkInterface::_internal_has_device_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NetworkInterface::has_device_path() const {
  return _internal_has_device_path();
}
inline void NetworkInterface::clear_device_path() {
  _impl_.device_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NetworkInterface::device_path() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.device_path)
  return _internal_device_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkInterface::set_device_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.device_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.device_path)
}
inline std::string* NetworkInterface::mutable_device_path() {
  std::string* _s = _internal_mutable_device_path();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.device_path)
  return _s;
}
inline const std::string& NetworkInterface::_internal_device_path() const {
  return _impl_.device_path_.Get();
}
inline void NetworkInterface::_internal_set_device_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.device_path_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_device_path() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.device_path_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_device_path() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.device_path)
  if (!_internal_has_device_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.device_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_path_.IsDefault()) {
    _impl_.device_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkInterface::set_allocated_device_path(std::string* device_path) {
  if (device_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.device_path_.SetAllocated(device_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_path_.IsDefault()) {
    _impl_.device_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.device_path)
}

// optional string iccid = 6;
inline bool NetworkInterface::_internal_has_iccid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NetworkInterface::has_iccid() const {
  return _internal_has_iccid();
}
inline void NetworkInterface::clear_iccid() {
  _impl_.iccid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& NetworkInterface::iccid() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.iccid)
  return _internal_iccid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkInterface::set_iccid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.iccid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.iccid)
}
inline std::string* NetworkInterface::mutable_iccid() {
  std::string* _s = _internal_mutable_iccid();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.iccid)
  return _s;
}
inline const std::string& NetworkInterface::_internal_iccid() const {
  return _impl_.iccid_.Get();
}
inline void NetworkInterface::_internal_set_iccid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.iccid_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_iccid() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.iccid_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_iccid() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.iccid)
  if (!_internal_has_iccid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.iccid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iccid_.IsDefault()) {
    _impl_.iccid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkInterface::set_allocated_iccid(std::string* iccid) {
  if (iccid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.iccid_.SetAllocated(iccid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iccid_.IsDefault()) {
    _impl_.iccid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.iccid)
}

// optional string mdn = 7;
inline bool NetworkInterface::_internal_has_mdn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NetworkInterface::has_mdn() const {
  return _internal_has_mdn();
}
inline void NetworkInterface::clear_mdn() {
  _impl_.mdn_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& NetworkInterface::mdn() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.mdn)
  return _internal_mdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkInterface::set_mdn(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.mdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.mdn)
}
inline std::string* NetworkInterface::mutable_mdn() {
  std::string* _s = _internal_mutable_mdn();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.mdn)
  return _s;
}
inline const std::string& NetworkInterface::_internal_mdn() const {
  return _impl_.mdn_.Get();
}
inline void NetworkInterface::_internal_set_mdn(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.mdn_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_mdn() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.mdn_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_mdn() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkInterface.mdn)
  if (!_internal_has_mdn()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.mdn_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mdn_.IsDefault()) {
    _impl_.mdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkInterface::set_allocated_mdn(std::string* mdn) {
  if (mdn != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.mdn_.SetAllocated(mdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mdn_.IsDefault()) {
    _impl_.mdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkInterface.mdn)
}

// repeated string eids = 8;
inline int NetworkInterface::_internal_eids_size() const {
  return _impl_.eids_.size();
}
inline int NetworkInterface::eids_size() const {
  return _internal_eids_size();
}
inline void NetworkInterface::clear_eids() {
  _impl_.eids_.Clear();
}
inline std::string* NetworkInterface::add_eids() {
  std::string* _s = _internal_add_eids();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.NetworkInterface.eids)
  return _s;
}
inline const std::string& NetworkInterface::_internal_eids(int index) const {
  return _impl_.eids_.Get(index);
}
inline const std::string& NetworkInterface::eids(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkInterface.eids)
  return _internal_eids(index);
}
inline std::string* NetworkInterface::mutable_eids(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkInterface.eids)
  return _impl_.eids_.Mutable(index);
}
inline void NetworkInterface::set_eids(int index, const std::string& value) {
  _impl_.eids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.eids)
}
inline void NetworkInterface::set_eids(int index, std::string&& value) {
  _impl_.eids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkInterface.eids)
}
inline void NetworkInterface::set_eids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.eids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkInterface.eids)
}
inline void NetworkInterface::set_eids(int index, const char* value, size_t size) {
  _impl_.eids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkInterface.eids)
}
inline std::string* NetworkInterface::_internal_add_eids() {
  return _impl_.eids_.Add();
}
inline void NetworkInterface::add_eids(const std::string& value) {
  _impl_.eids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.NetworkInterface.eids)
}
inline void NetworkInterface::add_eids(std::string&& value) {
  _impl_.eids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.NetworkInterface.eids)
}
inline void NetworkInterface::add_eids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.eids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.NetworkInterface.eids)
}
inline void NetworkInterface::add_eids(const char* value, size_t size) {
  _impl_.eids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.NetworkInterface.eids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkInterface::eids() const {
  // @@protoc_insertion_point(field_list:enterprise_management.NetworkInterface.eids)
  return _impl_.eids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkInterface::mutable_eids() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.NetworkInterface.eids)
  return &_impl_.eids_;
}

// -------------------------------------------------------------------

// NetworkState

// optional string device_path = 1;
inline bool NetworkState::_internal_has_device_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetworkState::has_device_path() const {
  return _internal_has_device_path();
}
inline void NetworkState::clear_device_path() {
  _impl_.device_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkState::device_path() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.device_path)
  return _internal_device_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkState::set_device_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.device_path)
}
inline std::string* NetworkState::mutable_device_path() {
  std::string* _s = _internal_mutable_device_path();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.device_path)
  return _s;
}
inline const std::string& NetworkState::_internal_device_path() const {
  return _impl_.device_path_.Get();
}
inline void NetworkState::_internal_set_device_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_path_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkState::_internal_mutable_device_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_path_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkState::release_device_path() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkState.device_path)
  if (!_internal_has_device_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_path_.IsDefault()) {
    _impl_.device_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkState::set_allocated_device_path(std::string* device_path) {
  if (device_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_path_.SetAllocated(device_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_path_.IsDefault()) {
    _impl_.device_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.device_path)
}

// optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
inline bool NetworkState::_internal_has_connection_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NetworkState::has_connection_state() const {
  return _internal_has_connection_state();
}
inline void NetworkState::clear_connection_state() {
  _impl_.connection_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::NetworkState_ConnectionState NetworkState::_internal_connection_state() const {
  return static_cast< ::enterprise_management::NetworkState_ConnectionState >(_impl_.connection_state_);
}
inline ::enterprise_management::NetworkState_ConnectionState NetworkState::connection_state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.connection_state)
  return _internal_connection_state();
}
inline void NetworkState::_internal_set_connection_state(::enterprise_management::NetworkState_ConnectionState value) {
  assert(::enterprise_management::NetworkState_ConnectionState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.connection_state_ = value;
}
inline void NetworkState::set_connection_state(::enterprise_management::NetworkState_ConnectionState value) {
  _internal_set_connection_state(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.connection_state)
}

// optional int32 signal_strength = 3;
inline bool NetworkState::_internal_has_signal_strength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NetworkState::has_signal_strength() const {
  return _internal_has_signal_strength();
}
inline void NetworkState::clear_signal_strength() {
  _impl_.signal_strength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t NetworkState::_internal_signal_strength() const {
  return _impl_.signal_strength_;
}
inline int32_t NetworkState::signal_strength() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.signal_strength)
  return _internal_signal_strength();
}
inline void NetworkState::_internal_set_signal_strength(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.signal_strength_ = value;
}
inline void NetworkState::set_signal_strength(int32_t value) {
  _internal_set_signal_strength(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.signal_strength)
}

// optional string ip_address = 4;
inline bool NetworkState::_internal_has_ip_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NetworkState::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void NetworkState::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkState::ip_address() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkState::set_ip_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.ip_address)
}
inline std::string* NetworkState::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.ip_address)
  return _s;
}
inline const std::string& NetworkState::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void NetworkState::_internal_set_ip_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkState::_internal_mutable_ip_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkState::release_ip_address() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkState.ip_address)
  if (!_internal_has_ip_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ip_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkState::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.ip_address)
}

// optional string gateway = 5;
inline bool NetworkState::_internal_has_gateway() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NetworkState::has_gateway() const {
  return _internal_has_gateway();
}
inline void NetworkState::clear_gateway() {
  _impl_.gateway_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetworkState::gateway() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkState.gateway)
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkState::set_gateway(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.gateway_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkState.gateway)
}
inline std::string* NetworkState::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkState.gateway)
  return _s;
}
inline const std::string& NetworkState::_internal_gateway() const {
  return _impl_.gateway_.Get();
}
inline void NetworkState::_internal_set_gateway(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkState::_internal_mutable_gateway() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.gateway_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkState::release_gateway() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkState.gateway)
  if (!_internal_has_gateway()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.gateway_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_.IsDefault()) {
    _impl_.gateway_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkState::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.gateway_.SetAllocated(gateway, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_.IsDefault()) {
    _impl_.gateway_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkState.gateway)
}

// -------------------------------------------------------------------

// DeviceUser

// required .enterprise_management.DeviceUser.UserType type = 1;
inline bool DeviceUser::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceUser::has_type() const {
  return _internal_has_type();
}
inline void DeviceUser::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::DeviceUser_UserType DeviceUser::_internal_type() const {
  return static_cast< ::enterprise_management::DeviceUser_UserType >(_impl_.type_);
}
inline ::enterprise_management::DeviceUser_UserType DeviceUser::type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceUser.type)
  return _internal_type();
}
inline void DeviceUser::_internal_set_type(::enterprise_management::DeviceUser_UserType value) {
  assert(::enterprise_management::DeviceUser_UserType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void DeviceUser::set_type(::enterprise_management::DeviceUser_UserType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceUser.type)
}

// optional string email = 2;
inline bool DeviceUser::_internal_has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceUser::has_email() const {
  return _internal_has_email();
}
inline void DeviceUser::clear_email() {
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceUser::email() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceUser.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceUser::set_email(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceUser.email)
}
inline std::string* DeviceUser::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceUser.email)
  return _s;
}
inline const std::string& DeviceUser::_internal_email() const {
  return _impl_.email_.Get();
}
inline void DeviceUser::_internal_set_email(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceUser::_internal_mutable_email() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceUser::release_email() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceUser.email)
  if (!_internal_has_email()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceUser::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceUser.email)
}

// -------------------------------------------------------------------

// VolumeInfo

// optional string volume_id = 1;
inline bool VolumeInfo::_internal_has_volume_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VolumeInfo::has_volume_id() const {
  return _internal_has_volume_id();
}
inline void VolumeInfo::clear_volume_id() {
  _impl_.volume_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VolumeInfo::volume_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.volume_id)
  return _internal_volume_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VolumeInfo::set_volume_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.volume_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.volume_id)
}
inline std::string* VolumeInfo::mutable_volume_id() {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.VolumeInfo.volume_id)
  return _s;
}
inline const std::string& VolumeInfo::_internal_volume_id() const {
  return _impl_.volume_id_.Get();
}
inline void VolumeInfo::_internal_set_volume_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.volume_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VolumeInfo::_internal_mutable_volume_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.volume_id_.Mutable(GetArenaForAllocation());
}
inline std::string* VolumeInfo::release_volume_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.VolumeInfo.volume_id)
  if (!_internal_has_volume_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.volume_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.volume_id_.IsDefault()) {
    _impl_.volume_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VolumeInfo::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.volume_id_.SetAllocated(volume_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.volume_id_.IsDefault()) {
    _impl_.volume_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.VolumeInfo.volume_id)
}

// optional int64 storage_total = 2;
inline bool VolumeInfo::_internal_has_storage_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VolumeInfo::has_storage_total() const {
  return _internal_has_storage_total();
}
inline void VolumeInfo::clear_storage_total() {
  _impl_.storage_total_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t VolumeInfo::_internal_storage_total() const {
  return _impl_.storage_total_;
}
inline int64_t VolumeInfo::storage_total() const {
  // @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.storage_total)
  return _internal_storage_total();
}
inline void VolumeInfo::_internal_set_storage_total(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.storage_total_ = value;
}
inline void VolumeInfo::set_storage_total(int64_t value) {
  _internal_set_storage_total(value);
  // @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.storage_total)
}

// optional int64 storage_free = 3;
inline bool VolumeInfo::_internal_has_storage_free() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VolumeInfo::has_storage_free() const {
  return _internal_has_storage_free();
}
inline void VolumeInfo::clear_storage_free() {
  _impl_.storage_free_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t VolumeInfo::_internal_storage_free() const {
  return _impl_.storage_free_;
}
inline int64_t VolumeInfo::storage_free() const {
  // @@protoc_insertion_point(field_get:enterprise_management.VolumeInfo.storage_free)
  return _internal_storage_free();
}
inline void VolumeInfo::_internal_set_storage_free(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.storage_free_ = value;
}
inline void VolumeInfo::set_storage_free(int64_t value) {
  _internal_set_storage_free(value);
  // @@protoc_insertion_point(field_set:enterprise_management.VolumeInfo.storage_free)
}

// -------------------------------------------------------------------

// CpuUtilizationInfo

// optional int32 cpu_utilization_pct = 1;
inline bool CpuUtilizationInfo::_internal_has_cpu_utilization_pct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CpuUtilizationInfo::has_cpu_utilization_pct() const {
  return _internal_has_cpu_utilization_pct();
}
inline void CpuUtilizationInfo::clear_cpu_utilization_pct() {
  _impl_.cpu_utilization_pct_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CpuUtilizationInfo::_internal_cpu_utilization_pct() const {
  return _impl_.cpu_utilization_pct_;
}
inline int32_t CpuUtilizationInfo::cpu_utilization_pct() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CpuUtilizationInfo.cpu_utilization_pct)
  return _internal_cpu_utilization_pct();
}
inline void CpuUtilizationInfo::_internal_set_cpu_utilization_pct(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cpu_utilization_pct_ = value;
}
inline void CpuUtilizationInfo::set_cpu_utilization_pct(int32_t value) {
  _internal_set_cpu_utilization_pct(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CpuUtilizationInfo.cpu_utilization_pct)
}

// optional int64 timestamp = 2;
inline bool CpuUtilizationInfo::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CpuUtilizationInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CpuUtilizationInfo::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t CpuUtilizationInfo::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t CpuUtilizationInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CpuUtilizationInfo.timestamp)
  return _internal_timestamp();
}
inline void CpuUtilizationInfo::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void CpuUtilizationInfo::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CpuUtilizationInfo.timestamp)
}

// -------------------------------------------------------------------

// SystemFreeRamInfo

// optional int64 size_in_bytes = 1;
inline bool SystemFreeRamInfo::_internal_has_size_in_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemFreeRamInfo::has_size_in_bytes() const {
  return _internal_has_size_in_bytes();
}
inline void SystemFreeRamInfo::clear_size_in_bytes() {
  _impl_.size_in_bytes_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t SystemFreeRamInfo::_internal_size_in_bytes() const {
  return _impl_.size_in_bytes_;
}
inline int64_t SystemFreeRamInfo::size_in_bytes() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemFreeRamInfo.size_in_bytes)
  return _internal_size_in_bytes();
}
inline void SystemFreeRamInfo::_internal_set_size_in_bytes(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_in_bytes_ = value;
}
inline void SystemFreeRamInfo::set_size_in_bytes(int64_t value) {
  _internal_set_size_in_bytes(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SystemFreeRamInfo.size_in_bytes)
}

// optional int64 timestamp = 2;
inline bool SystemFreeRamInfo::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SystemFreeRamInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void SystemFreeRamInfo::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t SystemFreeRamInfo::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t SystemFreeRamInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemFreeRamInfo.timestamp)
  return _internal_timestamp();
}
inline void SystemFreeRamInfo::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void SystemFreeRamInfo::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SystemFreeRamInfo.timestamp)
}

// -------------------------------------------------------------------

// CPUTempInfo

// optional string cpu_label = 1;
inline bool CPUTempInfo::_internal_has_cpu_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CPUTempInfo::has_cpu_label() const {
  return _internal_has_cpu_label();
}
inline void CPUTempInfo::clear_cpu_label() {
  _impl_.cpu_label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CPUTempInfo::cpu_label() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CPUTempInfo.cpu_label)
  return _internal_cpu_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CPUTempInfo::set_cpu_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cpu_label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CPUTempInfo.cpu_label)
}
inline std::string* CPUTempInfo::mutable_cpu_label() {
  std::string* _s = _internal_mutable_cpu_label();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CPUTempInfo.cpu_label)
  return _s;
}
inline const std::string& CPUTempInfo::_internal_cpu_label() const {
  return _impl_.cpu_label_.Get();
}
inline void CPUTempInfo::_internal_set_cpu_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cpu_label_.Set(value, GetArenaForAllocation());
}
inline std::string* CPUTempInfo::_internal_mutable_cpu_label() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cpu_label_.Mutable(GetArenaForAllocation());
}
inline std::string* CPUTempInfo::release_cpu_label() {
  // @@protoc_insertion_point(field_release:enterprise_management.CPUTempInfo.cpu_label)
  if (!_internal_has_cpu_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cpu_label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cpu_label_.IsDefault()) {
    _impl_.cpu_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CPUTempInfo::set_allocated_cpu_label(std::string* cpu_label) {
  if (cpu_label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cpu_label_.SetAllocated(cpu_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cpu_label_.IsDefault()) {
    _impl_.cpu_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CPUTempInfo.cpu_label)
}

// optional int32 cpu_temp = 2;
inline bool CPUTempInfo::_internal_has_cpu_temp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CPUTempInfo::has_cpu_temp() const {
  return _internal_has_cpu_temp();
}
inline void CPUTempInfo::clear_cpu_temp() {
  _impl_.cpu_temp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CPUTempInfo::_internal_cpu_temp() const {
  return _impl_.cpu_temp_;
}
inline int32_t CPUTempInfo::cpu_temp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CPUTempInfo.cpu_temp)
  return _internal_cpu_temp();
}
inline void CPUTempInfo::_internal_set_cpu_temp(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cpu_temp_ = value;
}
inline void CPUTempInfo::set_cpu_temp(int32_t value) {
  _internal_set_cpu_temp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CPUTempInfo.cpu_temp)
}

// optional int64 timestamp = 3;
inline bool CPUTempInfo::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CPUTempInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CPUTempInfo::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t CPUTempInfo::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t CPUTempInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CPUTempInfo.timestamp)
  return _internal_timestamp();
}
inline void CPUTempInfo::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void CPUTempInfo::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CPUTempInfo.timestamp)
}

// -------------------------------------------------------------------

// StatefulPartitionInfo

// optional uint64 available_space = 1;
inline bool StatefulPartitionInfo::_internal_has_available_space() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StatefulPartitionInfo::has_available_space() const {
  return _internal_has_available_space();
}
inline void StatefulPartitionInfo::clear_available_space() {
  _impl_.available_space_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t StatefulPartitionInfo::_internal_available_space() const {
  return _impl_.available_space_;
}
inline uint64_t StatefulPartitionInfo::available_space() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StatefulPartitionInfo.available_space)
  return _internal_available_space();
}
inline void StatefulPartitionInfo::_internal_set_available_space(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.available_space_ = value;
}
inline void StatefulPartitionInfo::set_available_space(uint64_t value) {
  _internal_set_available_space(value);
  // @@protoc_insertion_point(field_set:enterprise_management.StatefulPartitionInfo.available_space)
}

// optional uint64 total_space = 2;
inline bool StatefulPartitionInfo::_internal_has_total_space() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StatefulPartitionInfo::has_total_space() const {
  return _internal_has_total_space();
}
inline void StatefulPartitionInfo::clear_total_space() {
  _impl_.total_space_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t StatefulPartitionInfo::_internal_total_space() const {
  return _impl_.total_space_;
}
inline uint64_t StatefulPartitionInfo::total_space() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StatefulPartitionInfo.total_space)
  return _internal_total_space();
}
inline void StatefulPartitionInfo::_internal_set_total_space(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.total_space_ = value;
}
inline void StatefulPartitionInfo::set_total_space(uint64_t value) {
  _internal_set_total_space(value);
  // @@protoc_insertion_point(field_set:enterprise_management.StatefulPartitionInfo.total_space)
}

// optional string filesystem = 3;
inline bool StatefulPartitionInfo::_internal_has_filesystem() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatefulPartitionInfo::has_filesystem() const {
  return _internal_has_filesystem();
}
inline void StatefulPartitionInfo::clear_filesystem() {
  _impl_.filesystem_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StatefulPartitionInfo::filesystem() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StatefulPartitionInfo.filesystem)
  return _internal_filesystem();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatefulPartitionInfo::set_filesystem(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filesystem_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.StatefulPartitionInfo.filesystem)
}
inline std::string* StatefulPartitionInfo::mutable_filesystem() {
  std::string* _s = _internal_mutable_filesystem();
  // @@protoc_insertion_point(field_mutable:enterprise_management.StatefulPartitionInfo.filesystem)
  return _s;
}
inline const std::string& StatefulPartitionInfo::_internal_filesystem() const {
  return _impl_.filesystem_.Get();
}
inline void StatefulPartitionInfo::_internal_set_filesystem(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filesystem_.Set(value, GetArenaForAllocation());
}
inline std::string* StatefulPartitionInfo::_internal_mutable_filesystem() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filesystem_.Mutable(GetArenaForAllocation());
}
inline std::string* StatefulPartitionInfo::release_filesystem() {
  // @@protoc_insertion_point(field_release:enterprise_management.StatefulPartitionInfo.filesystem)
  if (!_internal_has_filesystem()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filesystem_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesystem_.IsDefault()) {
    _impl_.filesystem_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatefulPartitionInfo::set_allocated_filesystem(std::string* filesystem) {
  if (filesystem != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filesystem_.SetAllocated(filesystem, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesystem_.IsDefault()) {
    _impl_.filesystem_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.StatefulPartitionInfo.filesystem)
}

// optional string mount_source = 4;
inline bool StatefulPartitionInfo::_internal_has_mount_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatefulPartitionInfo::has_mount_source() const {
  return _internal_has_mount_source();
}
inline void StatefulPartitionInfo::clear_mount_source() {
  _impl_.mount_source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StatefulPartitionInfo::mount_source() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StatefulPartitionInfo.mount_source)
  return _internal_mount_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatefulPartitionInfo::set_mount_source(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mount_source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.StatefulPartitionInfo.mount_source)
}
inline std::string* StatefulPartitionInfo::mutable_mount_source() {
  std::string* _s = _internal_mutable_mount_source();
  // @@protoc_insertion_point(field_mutable:enterprise_management.StatefulPartitionInfo.mount_source)
  return _s;
}
inline const std::string& StatefulPartitionInfo::_internal_mount_source() const {
  return _impl_.mount_source_.Get();
}
inline void StatefulPartitionInfo::_internal_set_mount_source(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mount_source_.Set(value, GetArenaForAllocation());
}
inline std::string* StatefulPartitionInfo::_internal_mutable_mount_source() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mount_source_.Mutable(GetArenaForAllocation());
}
inline std::string* StatefulPartitionInfo::release_mount_source() {
  // @@protoc_insertion_point(field_release:enterprise_management.StatefulPartitionInfo.mount_source)
  if (!_internal_has_mount_source()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mount_source_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mount_source_.IsDefault()) {
    _impl_.mount_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatefulPartitionInfo::set_allocated_mount_source(std::string* mount_source) {
  if (mount_source != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mount_source_.SetAllocated(mount_source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mount_source_.IsDefault()) {
    _impl_.mount_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.StatefulPartitionInfo.mount_source)
}

// -------------------------------------------------------------------

// BatterySample

// optional int64 timestamp = 1;
inline bool BatterySample::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BatterySample::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void BatterySample::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t BatterySample::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t BatterySample::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatterySample.timestamp)
  return _internal_timestamp();
}
inline void BatterySample::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void BatterySample::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatterySample.timestamp)
}

// optional int64 voltage = 2;
inline bool BatterySample::_internal_has_voltage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BatterySample::has_voltage() const {
  return _internal_has_voltage();
}
inline void BatterySample::clear_voltage() {
  _impl_.voltage_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t BatterySample::_internal_voltage() const {
  return _impl_.voltage_;
}
inline int64_t BatterySample::voltage() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatterySample.voltage)
  return _internal_voltage();
}
inline void BatterySample::_internal_set_voltage(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.voltage_ = value;
}
inline void BatterySample::set_voltage(int64_t value) {
  _internal_set_voltage(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatterySample.voltage)
}

// optional int64 remaining_capacity = 3;
inline bool BatterySample::_internal_has_remaining_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BatterySample::has_remaining_capacity() const {
  return _internal_has_remaining_capacity();
}
inline void BatterySample::clear_remaining_capacity() {
  _impl_.remaining_capacity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t BatterySample::_internal_remaining_capacity() const {
  return _impl_.remaining_capacity_;
}
inline int64_t BatterySample::remaining_capacity() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatterySample.remaining_capacity)
  return _internal_remaining_capacity();
}
inline void BatterySample::_internal_set_remaining_capacity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.remaining_capacity_ = value;
}
inline void BatterySample::set_remaining_capacity(int64_t value) {
  _internal_set_remaining_capacity(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatterySample.remaining_capacity)
}

// optional int32 temperature = 4;
inline bool BatterySample::_internal_has_temperature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BatterySample::has_temperature() const {
  return _internal_has_temperature();
}
inline void BatterySample::clear_temperature() {
  _impl_.temperature_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t BatterySample::_internal_temperature() const {
  return _impl_.temperature_;
}
inline int32_t BatterySample::temperature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatterySample.temperature)
  return _internal_temperature();
}
inline void BatterySample::_internal_set_temperature(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.temperature_ = value;
}
inline void BatterySample::set_temperature(int32_t value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatterySample.temperature)
}

// optional int32 discharge_rate = 5;
inline bool BatterySample::_internal_has_discharge_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BatterySample::has_discharge_rate() const {
  return _internal_has_discharge_rate();
}
inline void BatterySample::clear_discharge_rate() {
  _impl_.discharge_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t BatterySample::_internal_discharge_rate() const {
  return _impl_.discharge_rate_;
}
inline int32_t BatterySample::discharge_rate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatterySample.discharge_rate)
  return _internal_discharge_rate();
}
inline void BatterySample::_internal_set_discharge_rate(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.discharge_rate_ = value;
}
inline void BatterySample::set_discharge_rate(int32_t value) {
  _internal_set_discharge_rate(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatterySample.discharge_rate)
}

// optional int32 charge_rate = 6;
inline bool BatterySample::_internal_has_charge_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BatterySample::has_charge_rate() const {
  return _internal_has_charge_rate();
}
inline void BatterySample::clear_charge_rate() {
  _impl_.charge_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t BatterySample::_internal_charge_rate() const {
  return _impl_.charge_rate_;
}
inline int32_t BatterySample::charge_rate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatterySample.charge_rate)
  return _internal_charge_rate();
}
inline void BatterySample::_internal_set_charge_rate(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.charge_rate_ = value;
}
inline void BatterySample::set_charge_rate(int32_t value) {
  _internal_set_charge_rate(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatterySample.charge_rate)
}

// optional int64 current = 7;
inline bool BatterySample::_internal_has_current() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BatterySample::has_current() const {
  return _internal_has_current();
}
inline void BatterySample::clear_current() {
  _impl_.current_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t BatterySample::_internal_current() const {
  return _impl_.current_;
}
inline int64_t BatterySample::current() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatterySample.current)
  return _internal_current();
}
inline void BatterySample::_internal_set_current(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.current_ = value;
}
inline void BatterySample::set_current(int64_t value) {
  _internal_set_current(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatterySample.current)
}

// optional string status = 8;
inline bool BatterySample::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BatterySample::has_status() const {
  return _internal_has_status();
}
inline void BatterySample::clear_status() {
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BatterySample::status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatterySample.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatterySample::set_status(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BatterySample.status)
}
inline std::string* BatterySample::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BatterySample.status)
  return _s;
}
inline const std::string& BatterySample::_internal_status() const {
  return _impl_.status_.Get();
}
inline void BatterySample::_internal_set_status(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* BatterySample::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* BatterySample::release_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.BatterySample.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.status_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BatterySample::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BatterySample.status)
}

// -------------------------------------------------------------------

// BatteryInfo

// optional string serial = 1;
inline bool BatteryInfo::_internal_has_serial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BatteryInfo::has_serial() const {
  return _internal_has_serial();
}
inline void BatteryInfo::clear_serial() {
  _impl_.serial_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BatteryInfo::serial() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatteryInfo::set_serial(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.serial_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.serial)
}
inline std::string* BatteryInfo::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.serial)
  return _s;
}
inline const std::string& BatteryInfo::_internal_serial() const {
  return _impl_.serial_.Get();
}
inline void BatteryInfo::_internal_set_serial(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serial_.Set(value, GetArenaForAllocation());
}
inline std::string* BatteryInfo::_internal_mutable_serial() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.serial_.Mutable(GetArenaForAllocation());
}
inline std::string* BatteryInfo::release_serial() {
  // @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.serial)
  if (!_internal_has_serial()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.serial_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_.IsDefault()) {
    _impl_.serial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BatteryInfo::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.serial_.SetAllocated(serial, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_.IsDefault()) {
    _impl_.serial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.serial)
}

// optional string manufacturer = 2;
inline bool BatteryInfo::_internal_has_manufacturer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BatteryInfo::has_manufacturer() const {
  return _internal_has_manufacturer();
}
inline void BatteryInfo::clear_manufacturer() {
  _impl_.manufacturer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BatteryInfo::manufacturer() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatteryInfo::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.manufacturer)
}
inline std::string* BatteryInfo::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.manufacturer)
  return _s;
}
inline const std::string& BatteryInfo::_internal_manufacturer() const {
  return _impl_.manufacturer_.Get();
}
inline void BatteryInfo::_internal_set_manufacturer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* BatteryInfo::_internal_mutable_manufacturer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* BatteryInfo::release_manufacturer() {
  // @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.manufacturer)
  if (!_internal_has_manufacturer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.manufacturer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_.IsDefault()) {
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BatteryInfo::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_.IsDefault()) {
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.manufacturer)
}

// optional string battery_health = 3;
inline bool BatteryInfo::_internal_has_battery_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BatteryInfo::has_battery_health() const {
  return _internal_has_battery_health();
}
inline void BatteryInfo::clear_battery_health() {
  _impl_.battery_health_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BatteryInfo::battery_health() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.battery_health)
  return _internal_battery_health();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatteryInfo::set_battery_health(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.battery_health_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.battery_health)
}
inline std::string* BatteryInfo::mutable_battery_health() {
  std::string* _s = _internal_mutable_battery_health();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.battery_health)
  return _s;
}
inline const std::string& BatteryInfo::_internal_battery_health() const {
  return _impl_.battery_health_.Get();
}
inline void BatteryInfo::_internal_set_battery_health(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.battery_health_.Set(value, GetArenaForAllocation());
}
inline std::string* BatteryInfo::_internal_mutable_battery_health() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.battery_health_.Mutable(GetArenaForAllocation());
}
inline std::string* BatteryInfo::release_battery_health() {
  // @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.battery_health)
  if (!_internal_has_battery_health()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.battery_health_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.battery_health_.IsDefault()) {
    _impl_.battery_health_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BatteryInfo::set_allocated_battery_health(std::string* battery_health) {
  if (battery_health != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.battery_health_.SetAllocated(battery_health, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.battery_health_.IsDefault()) {
    _impl_.battery_health_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.battery_health)
}

// optional int64 design_capacity = 4;
inline bool BatteryInfo::_internal_has_design_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BatteryInfo::has_design_capacity() const {
  return _internal_has_design_capacity();
}
inline void BatteryInfo::clear_design_capacity() {
  _impl_.design_capacity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t BatteryInfo::_internal_design_capacity() const {
  return _impl_.design_capacity_;
}
inline int64_t BatteryInfo::design_capacity() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.design_capacity)
  return _internal_design_capacity();
}
inline void BatteryInfo::_internal_set_design_capacity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.design_capacity_ = value;
}
inline void BatteryInfo::set_design_capacity(int64_t value) {
  _internal_set_design_capacity(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.design_capacity)
}

// optional int64 full_charge_capacity = 5;
inline bool BatteryInfo::_internal_has_full_charge_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BatteryInfo::has_full_charge_capacity() const {
  return _internal_has_full_charge_capacity();
}
inline void BatteryInfo::clear_full_charge_capacity() {
  _impl_.full_charge_capacity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t BatteryInfo::_internal_full_charge_capacity() const {
  return _impl_.full_charge_capacity_;
}
inline int64_t BatteryInfo::full_charge_capacity() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.full_charge_capacity)
  return _internal_full_charge_capacity();
}
inline void BatteryInfo::_internal_set_full_charge_capacity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.full_charge_capacity_ = value;
}
inline void BatteryInfo::set_full_charge_capacity(int64_t value) {
  _internal_set_full_charge_capacity(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.full_charge_capacity)
}

// optional int32 cycle_count = 6;
inline bool BatteryInfo::_internal_has_cycle_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BatteryInfo::has_cycle_count() const {
  return _internal_has_cycle_count();
}
inline void BatteryInfo::clear_cycle_count() {
  _impl_.cycle_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t BatteryInfo::_internal_cycle_count() const {
  return _impl_.cycle_count_;
}
inline int32_t BatteryInfo::cycle_count() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.cycle_count)
  return _internal_cycle_count();
}
inline void BatteryInfo::_internal_set_cycle_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.cycle_count_ = value;
}
inline void BatteryInfo::set_cycle_count(int32_t value) {
  _internal_set_cycle_count(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.cycle_count)
}

// repeated .enterprise_management.BatterySample samples = 7;
inline int BatteryInfo::_internal_samples_size() const {
  return _impl_.samples_.size();
}
inline int BatteryInfo::samples_size() const {
  return _internal_samples_size();
}
inline void BatteryInfo::clear_samples() {
  _impl_.samples_.Clear();
}
inline ::enterprise_management::BatterySample* BatteryInfo::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.samples)
  return _impl_.samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample >*
BatteryInfo::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.BatteryInfo.samples)
  return &_impl_.samples_;
}
inline const ::enterprise_management::BatterySample& BatteryInfo::_internal_samples(int index) const {
  return _impl_.samples_.Get(index);
}
inline const ::enterprise_management::BatterySample& BatteryInfo::samples(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.samples)
  return _internal_samples(index);
}
inline ::enterprise_management::BatterySample* BatteryInfo::_internal_add_samples() {
  return _impl_.samples_.Add();
}
inline ::enterprise_management::BatterySample* BatteryInfo::add_samples() {
  ::enterprise_management::BatterySample* _add = _internal_add_samples();
  // @@protoc_insertion_point(field_add:enterprise_management.BatteryInfo.samples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatterySample >&
BatteryInfo::samples() const {
  // @@protoc_insertion_point(field_list:enterprise_management.BatteryInfo.samples)
  return _impl_.samples_;
}

// optional int32 design_min_voltage = 9;
inline bool BatteryInfo::_internal_has_design_min_voltage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BatteryInfo::has_design_min_voltage() const {
  return _internal_has_design_min_voltage();
}
inline void BatteryInfo::clear_design_min_voltage() {
  _impl_.design_min_voltage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t BatteryInfo::_internal_design_min_voltage() const {
  return _impl_.design_min_voltage_;
}
inline int32_t BatteryInfo::design_min_voltage() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.design_min_voltage)
  return _internal_design_min_voltage();
}
inline void BatteryInfo::_internal_set_design_min_voltage(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.design_min_voltage_ = value;
}
inline void BatteryInfo::set_design_min_voltage(int32_t value) {
  _internal_set_design_min_voltage(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.design_min_voltage)
}

// optional string manufacture_date = 10;
inline bool BatteryInfo::_internal_has_manufacture_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BatteryInfo::has_manufacture_date() const {
  return _internal_has_manufacture_date();
}
inline void BatteryInfo::clear_manufacture_date() {
  _impl_.manufacture_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BatteryInfo::manufacture_date() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.manufacture_date)
  return _internal_manufacture_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatteryInfo::set_manufacture_date(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.manufacture_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.manufacture_date)
}
inline std::string* BatteryInfo::mutable_manufacture_date() {
  std::string* _s = _internal_mutable_manufacture_date();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.manufacture_date)
  return _s;
}
inline const std::string& BatteryInfo::_internal_manufacture_date() const {
  return _impl_.manufacture_date_.Get();
}
inline void BatteryInfo::_internal_set_manufacture_date(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.manufacture_date_.Set(value, GetArenaForAllocation());
}
inline std::string* BatteryInfo::_internal_mutable_manufacture_date() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.manufacture_date_.Mutable(GetArenaForAllocation());
}
inline std::string* BatteryInfo::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.manufacture_date)
  if (!_internal_has_manufacture_date()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.manufacture_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacture_date_.IsDefault()) {
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BatteryInfo::set_allocated_manufacture_date(std::string* manufacture_date) {
  if (manufacture_date != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.manufacture_date_.SetAllocated(manufacture_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacture_date_.IsDefault()) {
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.manufacture_date)
}

// optional string technology = 11;
inline bool BatteryInfo::_internal_has_technology() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BatteryInfo::has_technology() const {
  return _internal_has_technology();
}
inline void BatteryInfo::clear_technology() {
  _impl_.technology_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BatteryInfo::technology() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BatteryInfo.technology)
  return _internal_technology();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatteryInfo::set_technology(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.technology_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BatteryInfo.technology)
}
inline std::string* BatteryInfo::mutable_technology() {
  std::string* _s = _internal_mutable_technology();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BatteryInfo.technology)
  return _s;
}
inline const std::string& BatteryInfo::_internal_technology() const {
  return _impl_.technology_.Get();
}
inline void BatteryInfo::_internal_set_technology(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.technology_.Set(value, GetArenaForAllocation());
}
inline std::string* BatteryInfo::_internal_mutable_technology() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.technology_.Mutable(GetArenaForAllocation());
}
inline std::string* BatteryInfo::release_technology() {
  // @@protoc_insertion_point(field_release:enterprise_management.BatteryInfo.technology)
  if (!_internal_has_technology()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.technology_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.technology_.IsDefault()) {
    _impl_.technology_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BatteryInfo::set_allocated_technology(std::string* technology) {
  if (technology != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.technology_.SetAllocated(technology, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.technology_.IsDefault()) {
    _impl_.technology_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BatteryInfo.technology)
}

// -------------------------------------------------------------------

// PowerStatus

// optional .enterprise_management.PowerStatus.PowerSource power_source = 1;
inline bool PowerStatus::_internal_has_power_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PowerStatus::has_power_source() const {
  return _internal_has_power_source();
}
inline void PowerStatus::clear_power_source() {
  _impl_.power_source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::PowerStatus_PowerSource PowerStatus::_internal_power_source() const {
  return static_cast< ::enterprise_management::PowerStatus_PowerSource >(_impl_.power_source_);
}
inline ::enterprise_management::PowerStatus_PowerSource PowerStatus::power_source() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PowerStatus.power_source)
  return _internal_power_source();
}
inline void PowerStatus::_internal_set_power_source(::enterprise_management::PowerStatus_PowerSource value) {
  assert(::enterprise_management::PowerStatus_PowerSource_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.power_source_ = value;
}
inline void PowerStatus::set_power_source(::enterprise_management::PowerStatus_PowerSource value) {
  _internal_set_power_source(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PowerStatus.power_source)
}

// repeated .enterprise_management.BatteryInfo batteries = 2;
inline int PowerStatus::_internal_batteries_size() const {
  return _impl_.batteries_.size();
}
inline int PowerStatus::batteries_size() const {
  return _internal_batteries_size();
}
inline void PowerStatus::clear_batteries() {
  _impl_.batteries_.Clear();
}
inline ::enterprise_management::BatteryInfo* PowerStatus::mutable_batteries(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.PowerStatus.batteries)
  return _impl_.batteries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo >*
PowerStatus::mutable_batteries() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.PowerStatus.batteries)
  return &_impl_.batteries_;
}
inline const ::enterprise_management::BatteryInfo& PowerStatus::_internal_batteries(int index) const {
  return _impl_.batteries_.Get(index);
}
inline const ::enterprise_management::BatteryInfo& PowerStatus::batteries(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.PowerStatus.batteries)
  return _internal_batteries(index);
}
inline ::enterprise_management::BatteryInfo* PowerStatus::_internal_add_batteries() {
  return _impl_.batteries_.Add();
}
inline ::enterprise_management::BatteryInfo* PowerStatus::add_batteries() {
  ::enterprise_management::BatteryInfo* _add = _internal_add_batteries();
  // @@protoc_insertion_point(field_add:enterprise_management.PowerStatus.batteries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BatteryInfo >&
PowerStatus::batteries() const {
  // @@protoc_insertion_point(field_list:enterprise_management.PowerStatus.batteries)
  return _impl_.batteries_;
}

// -------------------------------------------------------------------

// DiskLifetimeEstimation

// optional int32 slc = 1;
inline bool DiskLifetimeEstimation::_internal_has_slc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DiskLifetimeEstimation::has_slc() const {
  return _internal_has_slc();
}
inline void DiskLifetimeEstimation::clear_slc() {
  _impl_.slc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t DiskLifetimeEstimation::_internal_slc() const {
  return _impl_.slc_;
}
inline int32_t DiskLifetimeEstimation::slc() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskLifetimeEstimation.slc)
  return _internal_slc();
}
inline void DiskLifetimeEstimation::_internal_set_slc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.slc_ = value;
}
inline void DiskLifetimeEstimation::set_slc(int32_t value) {
  _internal_set_slc(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskLifetimeEstimation.slc)
}

// optional int32 mlc = 2;
inline bool DiskLifetimeEstimation::_internal_has_mlc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DiskLifetimeEstimation::has_mlc() const {
  return _internal_has_mlc();
}
inline void DiskLifetimeEstimation::clear_mlc() {
  _impl_.mlc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t DiskLifetimeEstimation::_internal_mlc() const {
  return _impl_.mlc_;
}
inline int32_t DiskLifetimeEstimation::mlc() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskLifetimeEstimation.mlc)
  return _internal_mlc();
}
inline void DiskLifetimeEstimation::_internal_set_mlc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mlc_ = value;
}
inline void DiskLifetimeEstimation::set_mlc(int32_t value) {
  _internal_set_mlc(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskLifetimeEstimation.mlc)
}

// -------------------------------------------------------------------

// DiskInfo

// optional string serial = 1;
inline bool DiskInfo::_internal_has_serial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DiskInfo::has_serial() const {
  return _internal_has_serial();
}
inline void DiskInfo::clear_serial() {
  _impl_.serial_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DiskInfo::serial() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskInfo::set_serial(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.serial_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.serial)
}
inline std::string* DiskInfo::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.serial)
  return _s;
}
inline const std::string& DiskInfo::_internal_serial() const {
  return _impl_.serial_.Get();
}
inline void DiskInfo::_internal_set_serial(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serial_.Set(value, GetArenaForAllocation());
}
inline std::string* DiskInfo::_internal_mutable_serial() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.serial_.Mutable(GetArenaForAllocation());
}
inline std::string* DiskInfo::release_serial() {
  // @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.serial)
  if (!_internal_has_serial()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.serial_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_.IsDefault()) {
    _impl_.serial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DiskInfo::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.serial_.SetAllocated(serial, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_.IsDefault()) {
    _impl_.serial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.serial)
}

// optional string manufacturer = 2;
inline bool DiskInfo::_internal_has_manufacturer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DiskInfo::has_manufacturer() const {
  return _internal_has_manufacturer();
}
inline void DiskInfo::clear_manufacturer() {
  _impl_.manufacturer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DiskInfo::manufacturer() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskInfo::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.manufacturer)
}
inline std::string* DiskInfo::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.manufacturer)
  return _s;
}
inline const std::string& DiskInfo::_internal_manufacturer() const {
  return _impl_.manufacturer_.Get();
}
inline void DiskInfo::_internal_set_manufacturer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* DiskInfo::_internal_mutable_manufacturer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* DiskInfo::release_manufacturer() {
  // @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.manufacturer)
  if (!_internal_has_manufacturer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.manufacturer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_.IsDefault()) {
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DiskInfo::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_.IsDefault()) {
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.manufacturer)
}

// optional string model = 3;
inline bool DiskInfo::_internal_has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DiskInfo::has_model() const {
  return _internal_has_model();
}
inline void DiskInfo::clear_model() {
  _impl_.model_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DiskInfo::model() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskInfo::set_model(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.model)
}
inline std::string* DiskInfo::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.model)
  return _s;
}
inline const std::string& DiskInfo::_internal_model() const {
  return _impl_.model_.Get();
}
inline void DiskInfo::_internal_set_model(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* DiskInfo::_internal_mutable_model() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* DiskInfo::release_model() {
  // @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.model)
  if (!_internal_has_model()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DiskInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.model)
}

// optional int64 size = 4;
inline bool DiskInfo::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DiskInfo::has_size() const {
  return _internal_has_size();
}
inline void DiskInfo::clear_size() {
  _impl_.size_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t DiskInfo::_internal_size() const {
  return _impl_.size_;
}
inline int64_t DiskInfo::size() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.size)
  return _internal_size();
}
inline void DiskInfo::_internal_set_size(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.size_ = value;
}
inline void DiskInfo::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.size)
}

// optional string type = 5;
inline bool DiskInfo::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DiskInfo::has_type() const {
  return _internal_has_type();
}
inline void DiskInfo::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DiskInfo::type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskInfo::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.type)
}
inline std::string* DiskInfo::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.type)
  return _s;
}
inline const std::string& DiskInfo::_internal_type() const {
  return _impl_.type_.Get();
}
inline void DiskInfo::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* DiskInfo::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* DiskInfo::release_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DiskInfo::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.type)
}

// optional string health = 6;
inline bool DiskInfo::_internal_has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DiskInfo::has_health() const {
  return _internal_has_health();
}
inline void DiskInfo::clear_health() {
  _impl_.health_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DiskInfo::health() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.health)
  return _internal_health();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskInfo::set_health(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.health_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.health)
}
inline std::string* DiskInfo::mutable_health() {
  std::string* _s = _internal_mutable_health();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.health)
  return _s;
}
inline const std::string& DiskInfo::_internal_health() const {
  return _impl_.health_.Get();
}
inline void DiskInfo::_internal_set_health(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.health_.Set(value, GetArenaForAllocation());
}
inline std::string* DiskInfo::_internal_mutable_health() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.health_.Mutable(GetArenaForAllocation());
}
inline std::string* DiskInfo::release_health() {
  // @@protoc_insertion_point(field_release:enterprise_management.DiskInfo.health)
  if (!_internal_has_health()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.health_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.health_.IsDefault()) {
    _impl_.health_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DiskInfo::set_allocated_health(std::string* health) {
  if (health != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.health_.SetAllocated(health, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.health_.IsDefault()) {
    _impl_.health_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DiskInfo.health)
}

// repeated string volumes = 7;
inline int DiskInfo::_internal_volumes_size() const {
  return _impl_.volumes_.size();
}
inline int DiskInfo::volumes_size() const {
  return _internal_volumes_size();
}
inline void DiskInfo::clear_volumes() {
  _impl_.volumes_.Clear();
}
inline std::string* DiskInfo::add_volumes() {
  std::string* _s = _internal_add_volumes();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DiskInfo.volumes)
  return _s;
}
inline const std::string& DiskInfo::_internal_volumes(int index) const {
  return _impl_.volumes_.Get(index);
}
inline const std::string& DiskInfo::volumes(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.volumes)
  return _internal_volumes(index);
}
inline std::string* DiskInfo::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DiskInfo.volumes)
  return _impl_.volumes_.Mutable(index);
}
inline void DiskInfo::set_volumes(int index, const std::string& value) {
  _impl_.volumes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::set_volumes(int index, std::string&& value) {
  _impl_.volumes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::set_volumes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.volumes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::set_volumes(int index, const char* value, size_t size) {
  _impl_.volumes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DiskInfo.volumes)
}
inline std::string* DiskInfo::_internal_add_volumes() {
  return _impl_.volumes_.Add();
}
inline void DiskInfo::add_volumes(const std::string& value) {
  _impl_.volumes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::add_volumes(std::string&& value) {
  _impl_.volumes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::add_volumes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.volumes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DiskInfo.volumes)
}
inline void DiskInfo::add_volumes(const char* value, size_t size) {
  _impl_.volumes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DiskInfo.volumes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DiskInfo::volumes() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DiskInfo.volumes)
  return _impl_.volumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DiskInfo::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DiskInfo.volumes)
  return &_impl_.volumes_;
}

// optional uint64 bytes_read_since_last_boot = 8;
inline bool DiskInfo::_internal_has_bytes_read_since_last_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DiskInfo::has_bytes_read_since_last_boot() const {
  return _internal_has_bytes_read_since_last_boot();
}
inline void DiskInfo::clear_bytes_read_since_last_boot() {
  _impl_.bytes_read_since_last_boot_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t DiskInfo::_internal_bytes_read_since_last_boot() const {
  return _impl_.bytes_read_since_last_boot_;
}
inline uint64_t DiskInfo::bytes_read_since_last_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.bytes_read_since_last_boot)
  return _internal_bytes_read_since_last_boot();
}
inline void DiskInfo::_internal_set_bytes_read_since_last_boot(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.bytes_read_since_last_boot_ = value;
}
inline void DiskInfo::set_bytes_read_since_last_boot(uint64_t value) {
  _internal_set_bytes_read_since_last_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.bytes_read_since_last_boot)
}

// optional uint64 bytes_written_since_last_boot = 9;
inline bool DiskInfo::_internal_has_bytes_written_since_last_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DiskInfo::has_bytes_written_since_last_boot() const {
  return _internal_has_bytes_written_since_last_boot();
}
inline void DiskInfo::clear_bytes_written_since_last_boot() {
  _impl_.bytes_written_since_last_boot_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t DiskInfo::_internal_bytes_written_since_last_boot() const {
  return _impl_.bytes_written_since_last_boot_;
}
inline uint64_t DiskInfo::bytes_written_since_last_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.bytes_written_since_last_boot)
  return _internal_bytes_written_since_last_boot();
}
inline void DiskInfo::_internal_set_bytes_written_since_last_boot(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.bytes_written_since_last_boot_ = value;
}
inline void DiskInfo::set_bytes_written_since_last_boot(uint64_t value) {
  _internal_set_bytes_written_since_last_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.bytes_written_since_last_boot)
}

// optional uint64 read_time_seconds_since_last_boot = 10;
inline bool DiskInfo::_internal_has_read_time_seconds_since_last_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DiskInfo::has_read_time_seconds_since_last_boot() const {
  return _internal_has_read_time_seconds_since_last_boot();
}
inline void DiskInfo::clear_read_time_seconds_since_last_boot() {
  _impl_.read_time_seconds_since_last_boot_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint64_t DiskInfo::_internal_read_time_seconds_since_last_boot() const {
  return _impl_.read_time_seconds_since_last_boot_;
}
inline uint64_t DiskInfo::read_time_seconds_since_last_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.read_time_seconds_since_last_boot)
  return _internal_read_time_seconds_since_last_boot();
}
inline void DiskInfo::_internal_set_read_time_seconds_since_last_boot(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.read_time_seconds_since_last_boot_ = value;
}
inline void DiskInfo::set_read_time_seconds_since_last_boot(uint64_t value) {
  _internal_set_read_time_seconds_since_last_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.read_time_seconds_since_last_boot)
}

// optional uint64 write_time_seconds_since_last_boot = 11;
inline bool DiskInfo::_internal_has_write_time_seconds_since_last_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DiskInfo::has_write_time_seconds_since_last_boot() const {
  return _internal_has_write_time_seconds_since_last_boot();
}
inline void DiskInfo::clear_write_time_seconds_since_last_boot() {
  _impl_.write_time_seconds_since_last_boot_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint64_t DiskInfo::_internal_write_time_seconds_since_last_boot() const {
  return _impl_.write_time_seconds_since_last_boot_;
}
inline uint64_t DiskInfo::write_time_seconds_since_last_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.write_time_seconds_since_last_boot)
  return _internal_write_time_seconds_since_last_boot();
}
inline void DiskInfo::_internal_set_write_time_seconds_since_last_boot(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.write_time_seconds_since_last_boot_ = value;
}
inline void DiskInfo::set_write_time_seconds_since_last_boot(uint64_t value) {
  _internal_set_write_time_seconds_since_last_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.write_time_seconds_since_last_boot)
}

// optional uint64 io_time_seconds_since_last_boot = 12;
inline bool DiskInfo::_internal_has_io_time_seconds_since_last_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DiskInfo::has_io_time_seconds_since_last_boot() const {
  return _internal_has_io_time_seconds_since_last_boot();
}
inline void DiskInfo::clear_io_time_seconds_since_last_boot() {
  _impl_.io_time_seconds_since_last_boot_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint64_t DiskInfo::_internal_io_time_seconds_since_last_boot() const {
  return _impl_.io_time_seconds_since_last_boot_;
}
inline uint64_t DiskInfo::io_time_seconds_since_last_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.io_time_seconds_since_last_boot)
  return _internal_io_time_seconds_since_last_boot();
}
inline void DiskInfo::_internal_set_io_time_seconds_since_last_boot(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.io_time_seconds_since_last_boot_ = value;
}
inline void DiskInfo::set_io_time_seconds_since_last_boot(uint64_t value) {
  _internal_set_io_time_seconds_since_last_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.io_time_seconds_since_last_boot)
}

// optional uint64 discard_time_seconds_since_last_boot = 13;
inline bool DiskInfo::_internal_has_discard_time_seconds_since_last_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DiskInfo::has_discard_time_seconds_since_last_boot() const {
  return _internal_has_discard_time_seconds_since_last_boot();
}
inline void DiskInfo::clear_discard_time_seconds_since_last_boot() {
  _impl_.discard_time_seconds_since_last_boot_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint64_t DiskInfo::_internal_discard_time_seconds_since_last_boot() const {
  return _impl_.discard_time_seconds_since_last_boot_;
}
inline uint64_t DiskInfo::discard_time_seconds_since_last_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.discard_time_seconds_since_last_boot)
  return _internal_discard_time_seconds_since_last_boot();
}
inline void DiskInfo::_internal_set_discard_time_seconds_since_last_boot(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.discard_time_seconds_since_last_boot_ = value;
}
inline void DiskInfo::set_discard_time_seconds_since_last_boot(uint64_t value) {
  _internal_set_discard_time_seconds_since_last_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.discard_time_seconds_since_last_boot)
}

// uint32 nvme_subsystem_vendor = 14;
inline bool DiskInfo::_internal_has_nvme_subsystem_vendor() const {
  return vendor_id_case() == kNvmeSubsystemVendor;
}
inline bool DiskInfo::has_nvme_subsystem_vendor() const {
  return _internal_has_nvme_subsystem_vendor();
}
inline void DiskInfo::set_has_nvme_subsystem_vendor() {
  _impl_._oneof_case_[0] = kNvmeSubsystemVendor;
}
inline void DiskInfo::clear_nvme_subsystem_vendor() {
  if (_internal_has_nvme_subsystem_vendor()) {
    _impl_.vendor_id_.nvme_subsystem_vendor_ = 0u;
    clear_has_vendor_id();
  }
}
inline uint32_t DiskInfo::_internal_nvme_subsystem_vendor() const {
  if (_internal_has_nvme_subsystem_vendor()) {
    return _impl_.vendor_id_.nvme_subsystem_vendor_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_nvme_subsystem_vendor(uint32_t value) {
  if (!_internal_has_nvme_subsystem_vendor()) {
    clear_vendor_id();
    set_has_nvme_subsystem_vendor();
  }
  _impl_.vendor_id_.nvme_subsystem_vendor_ = value;
}
inline uint32_t DiskInfo::nvme_subsystem_vendor() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.nvme_subsystem_vendor)
  return _internal_nvme_subsystem_vendor();
}
inline void DiskInfo::set_nvme_subsystem_vendor(uint32_t value) {
  _internal_set_nvme_subsystem_vendor(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.nvme_subsystem_vendor)
}

// uint32 emmc_oemid = 15;
inline bool DiskInfo::_internal_has_emmc_oemid() const {
  return vendor_id_case() == kEmmcOemid;
}
inline bool DiskInfo::has_emmc_oemid() const {
  return _internal_has_emmc_oemid();
}
inline void DiskInfo::set_has_emmc_oemid() {
  _impl_._oneof_case_[0] = kEmmcOemid;
}
inline void DiskInfo::clear_emmc_oemid() {
  if (_internal_has_emmc_oemid()) {
    _impl_.vendor_id_.emmc_oemid_ = 0u;
    clear_has_vendor_id();
  }
}
inline uint32_t DiskInfo::_internal_emmc_oemid() const {
  if (_internal_has_emmc_oemid()) {
    return _impl_.vendor_id_.emmc_oemid_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_emmc_oemid(uint32_t value) {
  if (!_internal_has_emmc_oemid()) {
    clear_vendor_id();
    set_has_emmc_oemid();
  }
  _impl_.vendor_id_.emmc_oemid_ = value;
}
inline uint32_t DiskInfo::emmc_oemid() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.emmc_oemid)
  return _internal_emmc_oemid();
}
inline void DiskInfo::set_emmc_oemid(uint32_t value) {
  _internal_set_emmc_oemid(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.emmc_oemid)
}

// uint32 other_vendor = 16;
inline bool DiskInfo::_internal_has_other_vendor() const {
  return vendor_id_case() == kOtherVendor;
}
inline bool DiskInfo::has_other_vendor() const {
  return _internal_has_other_vendor();
}
inline void DiskInfo::set_has_other_vendor() {
  _impl_._oneof_case_[0] = kOtherVendor;
}
inline void DiskInfo::clear_other_vendor() {
  if (_internal_has_other_vendor()) {
    _impl_.vendor_id_.other_vendor_ = 0u;
    clear_has_vendor_id();
  }
}
inline uint32_t DiskInfo::_internal_other_vendor() const {
  if (_internal_has_other_vendor()) {
    return _impl_.vendor_id_.other_vendor_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_other_vendor(uint32_t value) {
  if (!_internal_has_other_vendor()) {
    clear_vendor_id();
    set_has_other_vendor();
  }
  _impl_.vendor_id_.other_vendor_ = value;
}
inline uint32_t DiskInfo::other_vendor() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.other_vendor)
  return _internal_other_vendor();
}
inline void DiskInfo::set_other_vendor(uint32_t value) {
  _internal_set_other_vendor(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.other_vendor)
}

// uint32 jedec_manfid = 27;
inline bool DiskInfo::_internal_has_jedec_manfid() const {
  return vendor_id_case() == kJedecManfid;
}
inline bool DiskInfo::has_jedec_manfid() const {
  return _internal_has_jedec_manfid();
}
inline void DiskInfo::set_has_jedec_manfid() {
  _impl_._oneof_case_[0] = kJedecManfid;
}
inline void DiskInfo::clear_jedec_manfid() {
  if (_internal_has_jedec_manfid()) {
    _impl_.vendor_id_.jedec_manfid_ = 0u;
    clear_has_vendor_id();
  }
}
inline uint32_t DiskInfo::_internal_jedec_manfid() const {
  if (_internal_has_jedec_manfid()) {
    return _impl_.vendor_id_.jedec_manfid_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_jedec_manfid(uint32_t value) {
  if (!_internal_has_jedec_manfid()) {
    clear_vendor_id();
    set_has_jedec_manfid();
  }
  _impl_.vendor_id_.jedec_manfid_ = value;
}
inline uint32_t DiskInfo::jedec_manfid() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.jedec_manfid)
  return _internal_jedec_manfid();
}
inline void DiskInfo::set_jedec_manfid(uint32_t value) {
  _internal_set_jedec_manfid(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.jedec_manfid)
}

// uint32 nvme_subsystem_device = 17;
inline bool DiskInfo::_internal_has_nvme_subsystem_device() const {
  return product_id_case() == kNvmeSubsystemDevice;
}
inline bool DiskInfo::has_nvme_subsystem_device() const {
  return _internal_has_nvme_subsystem_device();
}
inline void DiskInfo::set_has_nvme_subsystem_device() {
  _impl_._oneof_case_[1] = kNvmeSubsystemDevice;
}
inline void DiskInfo::clear_nvme_subsystem_device() {
  if (_internal_has_nvme_subsystem_device()) {
    _impl_.product_id_.nvme_subsystem_device_ = 0u;
    clear_has_product_id();
  }
}
inline uint32_t DiskInfo::_internal_nvme_subsystem_device() const {
  if (_internal_has_nvme_subsystem_device()) {
    return _impl_.product_id_.nvme_subsystem_device_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_nvme_subsystem_device(uint32_t value) {
  if (!_internal_has_nvme_subsystem_device()) {
    clear_product_id();
    set_has_nvme_subsystem_device();
  }
  _impl_.product_id_.nvme_subsystem_device_ = value;
}
inline uint32_t DiskInfo::nvme_subsystem_device() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.nvme_subsystem_device)
  return _internal_nvme_subsystem_device();
}
inline void DiskInfo::set_nvme_subsystem_device(uint32_t value) {
  _internal_set_nvme_subsystem_device(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.nvme_subsystem_device)
}

// uint32 emmc_pnm = 18;
inline bool DiskInfo::_internal_has_emmc_pnm() const {
  return product_id_case() == kEmmcPnm;
}
inline bool DiskInfo::has_emmc_pnm() const {
  return _internal_has_emmc_pnm();
}
inline void DiskInfo::set_has_emmc_pnm() {
  _impl_._oneof_case_[1] = kEmmcPnm;
}
inline void DiskInfo::clear_emmc_pnm() {
  if (_internal_has_emmc_pnm()) {
    _impl_.product_id_.emmc_pnm_ = 0u;
    clear_has_product_id();
  }
}
inline uint32_t DiskInfo::_internal_emmc_pnm() const {
  if (_internal_has_emmc_pnm()) {
    return _impl_.product_id_.emmc_pnm_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_emmc_pnm(uint32_t value) {
  if (!_internal_has_emmc_pnm()) {
    clear_product_id();
    set_has_emmc_pnm();
  }
  _impl_.product_id_.emmc_pnm_ = value;
}
inline uint32_t DiskInfo::emmc_pnm() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.emmc_pnm)
  return _internal_emmc_pnm();
}
inline void DiskInfo::set_emmc_pnm(uint32_t value) {
  _internal_set_emmc_pnm(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.emmc_pnm)
}

// uint32 other_product = 19;
inline bool DiskInfo::_internal_has_other_product() const {
  return product_id_case() == kOtherProduct;
}
inline bool DiskInfo::has_other_product() const {
  return _internal_has_other_product();
}
inline void DiskInfo::set_has_other_product() {
  _impl_._oneof_case_[1] = kOtherProduct;
}
inline void DiskInfo::clear_other_product() {
  if (_internal_has_other_product()) {
    _impl_.product_id_.other_product_ = 0u;
    clear_has_product_id();
  }
}
inline uint32_t DiskInfo::_internal_other_product() const {
  if (_internal_has_other_product()) {
    return _impl_.product_id_.other_product_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_other_product(uint32_t value) {
  if (!_internal_has_other_product()) {
    clear_product_id();
    set_has_other_product();
  }
  _impl_.product_id_.other_product_ = value;
}
inline uint32_t DiskInfo::other_product() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.other_product)
  return _internal_other_product();
}
inline void DiskInfo::set_other_product(uint32_t value) {
  _internal_set_other_product(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.other_product)
}

// uint32 nvme_hardware_rev = 20;
inline bool DiskInfo::_internal_has_nvme_hardware_rev() const {
  return hardware_revision_case() == kNvmeHardwareRev;
}
inline bool DiskInfo::has_nvme_hardware_rev() const {
  return _internal_has_nvme_hardware_rev();
}
inline void DiskInfo::set_has_nvme_hardware_rev() {
  _impl_._oneof_case_[2] = kNvmeHardwareRev;
}
inline void DiskInfo::clear_nvme_hardware_rev() {
  if (_internal_has_nvme_hardware_rev()) {
    _impl_.hardware_revision_.nvme_hardware_rev_ = 0u;
    clear_has_hardware_revision();
  }
}
inline uint32_t DiskInfo::_internal_nvme_hardware_rev() const {
  if (_internal_has_nvme_hardware_rev()) {
    return _impl_.hardware_revision_.nvme_hardware_rev_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_nvme_hardware_rev(uint32_t value) {
  if (!_internal_has_nvme_hardware_rev()) {
    clear_hardware_revision();
    set_has_nvme_hardware_rev();
  }
  _impl_.hardware_revision_.nvme_hardware_rev_ = value;
}
inline uint32_t DiskInfo::nvme_hardware_rev() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.nvme_hardware_rev)
  return _internal_nvme_hardware_rev();
}
inline void DiskInfo::set_nvme_hardware_rev(uint32_t value) {
  _internal_set_nvme_hardware_rev(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.nvme_hardware_rev)
}

// uint32 emmc_hardware_rev = 21;
inline bool DiskInfo::_internal_has_emmc_hardware_rev() const {
  return hardware_revision_case() == kEmmcHardwareRev;
}
inline bool DiskInfo::has_emmc_hardware_rev() const {
  return _internal_has_emmc_hardware_rev();
}
inline void DiskInfo::set_has_emmc_hardware_rev() {
  _impl_._oneof_case_[2] = kEmmcHardwareRev;
}
inline void DiskInfo::clear_emmc_hardware_rev() {
  if (_internal_has_emmc_hardware_rev()) {
    _impl_.hardware_revision_.emmc_hardware_rev_ = 0u;
    clear_has_hardware_revision();
  }
}
inline uint32_t DiskInfo::_internal_emmc_hardware_rev() const {
  if (_internal_has_emmc_hardware_rev()) {
    return _impl_.hardware_revision_.emmc_hardware_rev_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_emmc_hardware_rev(uint32_t value) {
  if (!_internal_has_emmc_hardware_rev()) {
    clear_hardware_revision();
    set_has_emmc_hardware_rev();
  }
  _impl_.hardware_revision_.emmc_hardware_rev_ = value;
}
inline uint32_t DiskInfo::emmc_hardware_rev() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.emmc_hardware_rev)
  return _internal_emmc_hardware_rev();
}
inline void DiskInfo::set_emmc_hardware_rev(uint32_t value) {
  _internal_set_emmc_hardware_rev(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.emmc_hardware_rev)
}

// uint32 other_hardware_rev = 22;
inline bool DiskInfo::_internal_has_other_hardware_rev() const {
  return hardware_revision_case() == kOtherHardwareRev;
}
inline bool DiskInfo::has_other_hardware_rev() const {
  return _internal_has_other_hardware_rev();
}
inline void DiskInfo::set_has_other_hardware_rev() {
  _impl_._oneof_case_[2] = kOtherHardwareRev;
}
inline void DiskInfo::clear_other_hardware_rev() {
  if (_internal_has_other_hardware_rev()) {
    _impl_.hardware_revision_.other_hardware_rev_ = 0u;
    clear_has_hardware_revision();
  }
}
inline uint32_t DiskInfo::_internal_other_hardware_rev() const {
  if (_internal_has_other_hardware_rev()) {
    return _impl_.hardware_revision_.other_hardware_rev_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_other_hardware_rev(uint32_t value) {
  if (!_internal_has_other_hardware_rev()) {
    clear_hardware_revision();
    set_has_other_hardware_rev();
  }
  _impl_.hardware_revision_.other_hardware_rev_ = value;
}
inline uint32_t DiskInfo::other_hardware_rev() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.other_hardware_rev)
  return _internal_other_hardware_rev();
}
inline void DiskInfo::set_other_hardware_rev(uint32_t value) {
  _internal_set_other_hardware_rev(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.other_hardware_rev)
}

// uint64 nvme_firmware_rev = 23;
inline bool DiskInfo::_internal_has_nvme_firmware_rev() const {
  return firmware_revision_case() == kNvmeFirmwareRev;
}
inline bool DiskInfo::has_nvme_firmware_rev() const {
  return _internal_has_nvme_firmware_rev();
}
inline void DiskInfo::set_has_nvme_firmware_rev() {
  _impl_._oneof_case_[3] = kNvmeFirmwareRev;
}
inline void DiskInfo::clear_nvme_firmware_rev() {
  if (_internal_has_nvme_firmware_rev()) {
    _impl_.firmware_revision_.nvme_firmware_rev_ = uint64_t{0u};
    clear_has_firmware_revision();
  }
}
inline uint64_t DiskInfo::_internal_nvme_firmware_rev() const {
  if (_internal_has_nvme_firmware_rev()) {
    return _impl_.firmware_revision_.nvme_firmware_rev_;
  }
  return uint64_t{0u};
}
inline void DiskInfo::_internal_set_nvme_firmware_rev(uint64_t value) {
  if (!_internal_has_nvme_firmware_rev()) {
    clear_firmware_revision();
    set_has_nvme_firmware_rev();
  }
  _impl_.firmware_revision_.nvme_firmware_rev_ = value;
}
inline uint64_t DiskInfo::nvme_firmware_rev() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.nvme_firmware_rev)
  return _internal_nvme_firmware_rev();
}
inline void DiskInfo::set_nvme_firmware_rev(uint64_t value) {
  _internal_set_nvme_firmware_rev(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.nvme_firmware_rev)
}

// uint64 emmc_firmware_rev = 24;
inline bool DiskInfo::_internal_has_emmc_firmware_rev() const {
  return firmware_revision_case() == kEmmcFirmwareRev;
}
inline bool DiskInfo::has_emmc_firmware_rev() const {
  return _internal_has_emmc_firmware_rev();
}
inline void DiskInfo::set_has_emmc_firmware_rev() {
  _impl_._oneof_case_[3] = kEmmcFirmwareRev;
}
inline void DiskInfo::clear_emmc_firmware_rev() {
  if (_internal_has_emmc_firmware_rev()) {
    _impl_.firmware_revision_.emmc_firmware_rev_ = uint64_t{0u};
    clear_has_firmware_revision();
  }
}
inline uint64_t DiskInfo::_internal_emmc_firmware_rev() const {
  if (_internal_has_emmc_firmware_rev()) {
    return _impl_.firmware_revision_.emmc_firmware_rev_;
  }
  return uint64_t{0u};
}
inline void DiskInfo::_internal_set_emmc_firmware_rev(uint64_t value) {
  if (!_internal_has_emmc_firmware_rev()) {
    clear_firmware_revision();
    set_has_emmc_firmware_rev();
  }
  _impl_.firmware_revision_.emmc_firmware_rev_ = value;
}
inline uint64_t DiskInfo::emmc_firmware_rev() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.emmc_firmware_rev)
  return _internal_emmc_firmware_rev();
}
inline void DiskInfo::set_emmc_firmware_rev(uint64_t value) {
  _internal_set_emmc_firmware_rev(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.emmc_firmware_rev)
}

// uint32 other_firmware_rev = 25;
inline bool DiskInfo::_internal_has_other_firmware_rev() const {
  return firmware_revision_case() == kOtherFirmwareRev;
}
inline bool DiskInfo::has_other_firmware_rev() const {
  return _internal_has_other_firmware_rev();
}
inline void DiskInfo::set_has_other_firmware_rev() {
  _impl_._oneof_case_[3] = kOtherFirmwareRev;
}
inline void DiskInfo::clear_other_firmware_rev() {
  if (_internal_has_other_firmware_rev()) {
    _impl_.firmware_revision_.other_firmware_rev_ = 0u;
    clear_has_firmware_revision();
  }
}
inline uint32_t DiskInfo::_internal_other_firmware_rev() const {
  if (_internal_has_other_firmware_rev()) {
    return _impl_.firmware_revision_.other_firmware_rev_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_other_firmware_rev(uint32_t value) {
  if (!_internal_has_other_firmware_rev()) {
    clear_firmware_revision();
    set_has_other_firmware_rev();
  }
  _impl_.firmware_revision_.other_firmware_rev_ = value;
}
inline uint32_t DiskInfo::other_firmware_rev() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.other_firmware_rev)
  return _internal_other_firmware_rev();
}
inline void DiskInfo::set_other_firmware_rev(uint32_t value) {
  _internal_set_other_firmware_rev(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.other_firmware_rev)
}

// uint32 ufs_firmware_rev = 28;
inline bool DiskInfo::_internal_has_ufs_firmware_rev() const {
  return firmware_revision_case() == kUfsFirmwareRev;
}
inline bool DiskInfo::has_ufs_firmware_rev() const {
  return _internal_has_ufs_firmware_rev();
}
inline void DiskInfo::set_has_ufs_firmware_rev() {
  _impl_._oneof_case_[3] = kUfsFirmwareRev;
}
inline void DiskInfo::clear_ufs_firmware_rev() {
  if (_internal_has_ufs_firmware_rev()) {
    _impl_.firmware_revision_.ufs_firmware_rev_ = 0u;
    clear_has_firmware_revision();
  }
}
inline uint32_t DiskInfo::_internal_ufs_firmware_rev() const {
  if (_internal_has_ufs_firmware_rev()) {
    return _impl_.firmware_revision_.ufs_firmware_rev_;
  }
  return 0u;
}
inline void DiskInfo::_internal_set_ufs_firmware_rev(uint32_t value) {
  if (!_internal_has_ufs_firmware_rev()) {
    clear_firmware_revision();
    set_has_ufs_firmware_rev();
  }
  _impl_.firmware_revision_.ufs_firmware_rev_ = value;
}
inline uint32_t DiskInfo::ufs_firmware_rev() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.ufs_firmware_rev)
  return _internal_ufs_firmware_rev();
}
inline void DiskInfo::set_ufs_firmware_rev(uint32_t value) {
  _internal_set_ufs_firmware_rev(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.ufs_firmware_rev)
}

// optional .enterprise_management.DiskInfo.DevicePurpose purpose = 26;
inline bool DiskInfo::_internal_has_purpose() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DiskInfo::has_purpose() const {
  return _internal_has_purpose();
}
inline void DiskInfo::clear_purpose() {
  _impl_.purpose_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::enterprise_management::DiskInfo_DevicePurpose DiskInfo::_internal_purpose() const {
  return static_cast< ::enterprise_management::DiskInfo_DevicePurpose >(_impl_.purpose_);
}
inline ::enterprise_management::DiskInfo_DevicePurpose DiskInfo::purpose() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DiskInfo.purpose)
  return _internal_purpose();
}
inline void DiskInfo::_internal_set_purpose(::enterprise_management::DiskInfo_DevicePurpose value) {
  assert(::enterprise_management::DiskInfo_DevicePurpose_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.purpose_ = value;
}
inline void DiskInfo::set_purpose(::enterprise_management::DiskInfo_DevicePurpose value) {
  _internal_set_purpose(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DiskInfo.purpose)
}

inline bool DiskInfo::has_vendor_id() const {
  return vendor_id_case() != VENDOR_ID_NOT_SET;
}
inline void DiskInfo::clear_has_vendor_id() {
  _impl_._oneof_case_[0] = VENDOR_ID_NOT_SET;
}
inline bool DiskInfo::has_product_id() const {
  return product_id_case() != PRODUCT_ID_NOT_SET;
}
inline void DiskInfo::clear_has_product_id() {
  _impl_._oneof_case_[1] = PRODUCT_ID_NOT_SET;
}
inline bool DiskInfo::has_hardware_revision() const {
  return hardware_revision_case() != HARDWARE_REVISION_NOT_SET;
}
inline void DiskInfo::clear_has_hardware_revision() {
  _impl_._oneof_case_[2] = HARDWARE_REVISION_NOT_SET;
}
inline bool DiskInfo::has_firmware_revision() const {
  return firmware_revision_case() != FIRMWARE_REVISION_NOT_SET;
}
inline void DiskInfo::clear_has_firmware_revision() {
  _impl_._oneof_case_[3] = FIRMWARE_REVISION_NOT_SET;
}
inline DiskInfo::VendorIdCase DiskInfo::vendor_id_case() const {
  return DiskInfo::VendorIdCase(_impl_._oneof_case_[0]);
}
inline DiskInfo::ProductIdCase DiskInfo::product_id_case() const {
  return DiskInfo::ProductIdCase(_impl_._oneof_case_[1]);
}
inline DiskInfo::HardwareRevisionCase DiskInfo::hardware_revision_case() const {
  return DiskInfo::HardwareRevisionCase(_impl_._oneof_case_[2]);
}
inline DiskInfo::FirmwareRevisionCase DiskInfo::firmware_revision_case() const {
  return DiskInfo::FirmwareRevisionCase(_impl_._oneof_case_[3]);
}
// -------------------------------------------------------------------

// StorageStatus

// repeated .enterprise_management.DiskInfo disks = 1;
inline int StorageStatus::_internal_disks_size() const {
  return _impl_.disks_.size();
}
inline int StorageStatus::disks_size() const {
  return _internal_disks_size();
}
inline void StorageStatus::clear_disks() {
  _impl_.disks_.Clear();
}
inline ::enterprise_management::DiskInfo* StorageStatus::mutable_disks(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.StorageStatus.disks)
  return _impl_.disks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo >*
StorageStatus::mutable_disks() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.StorageStatus.disks)
  return &_impl_.disks_;
}
inline const ::enterprise_management::DiskInfo& StorageStatus::_internal_disks(int index) const {
  return _impl_.disks_.Get(index);
}
inline const ::enterprise_management::DiskInfo& StorageStatus::disks(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.StorageStatus.disks)
  return _internal_disks(index);
}
inline ::enterprise_management::DiskInfo* StorageStatus::_internal_add_disks() {
  return _impl_.disks_.Add();
}
inline ::enterprise_management::DiskInfo* StorageStatus::add_disks() {
  ::enterprise_management::DiskInfo* _add = _internal_add_disks();
  // @@protoc_insertion_point(field_add:enterprise_management.StorageStatus.disks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DiskInfo >&
StorageStatus::disks() const {
  // @@protoc_insertion_point(field_list:enterprise_management.StorageStatus.disks)
  return _impl_.disks_;
}

// optional .enterprise_management.DiskLifetimeEstimation lifetime_estimation = 2;
inline bool StorageStatus::_internal_has_lifetime_estimation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lifetime_estimation_ != nullptr);
  return value;
}
inline bool StorageStatus::has_lifetime_estimation() const {
  return _internal_has_lifetime_estimation();
}
inline void StorageStatus::clear_lifetime_estimation() {
  if (_impl_.lifetime_estimation_ != nullptr) _impl_.lifetime_estimation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::DiskLifetimeEstimation& StorageStatus::_internal_lifetime_estimation() const {
  const ::enterprise_management::DiskLifetimeEstimation* p = _impl_.lifetime_estimation_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DiskLifetimeEstimation&>(
      ::enterprise_management::_DiskLifetimeEstimation_default_instance_);
}
inline const ::enterprise_management::DiskLifetimeEstimation& StorageStatus::lifetime_estimation() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StorageStatus.lifetime_estimation)
  return _internal_lifetime_estimation();
}
inline void StorageStatus::unsafe_arena_set_allocated_lifetime_estimation(
    ::enterprise_management::DiskLifetimeEstimation* lifetime_estimation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lifetime_estimation_);
  }
  _impl_.lifetime_estimation_ = lifetime_estimation;
  if (lifetime_estimation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.StorageStatus.lifetime_estimation)
}
inline ::enterprise_management::DiskLifetimeEstimation* StorageStatus::release_lifetime_estimation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DiskLifetimeEstimation* temp = _impl_.lifetime_estimation_;
  _impl_.lifetime_estimation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DiskLifetimeEstimation* StorageStatus::unsafe_arena_release_lifetime_estimation() {
  // @@protoc_insertion_point(field_release:enterprise_management.StorageStatus.lifetime_estimation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DiskLifetimeEstimation* temp = _impl_.lifetime_estimation_;
  _impl_.lifetime_estimation_ = nullptr;
  return temp;
}
inline ::enterprise_management::DiskLifetimeEstimation* StorageStatus::_internal_mutable_lifetime_estimation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lifetime_estimation_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DiskLifetimeEstimation>(GetArenaForAllocation());
    _impl_.lifetime_estimation_ = p;
  }
  return _impl_.lifetime_estimation_;
}
inline ::enterprise_management::DiskLifetimeEstimation* StorageStatus::mutable_lifetime_estimation() {
  ::enterprise_management::DiskLifetimeEstimation* _msg = _internal_mutable_lifetime_estimation();
  // @@protoc_insertion_point(field_mutable:enterprise_management.StorageStatus.lifetime_estimation)
  return _msg;
}
inline void StorageStatus::set_allocated_lifetime_estimation(::enterprise_management::DiskLifetimeEstimation* lifetime_estimation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lifetime_estimation_;
  }
  if (lifetime_estimation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lifetime_estimation);
    if (message_arena != submessage_arena) {
      lifetime_estimation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lifetime_estimation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lifetime_estimation_ = lifetime_estimation;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.StorageStatus.lifetime_estimation)
}

// -------------------------------------------------------------------

// ThermalSample

// optional int64 timestamp = 1;
inline bool ThermalSample::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThermalSample::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ThermalSample::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ThermalSample::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t ThermalSample::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ThermalSample.timestamp)
  return _internal_timestamp();
}
inline void ThermalSample::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void ThermalSample::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ThermalSample.timestamp)
}

// optional int32 temperature = 2;
inline bool ThermalSample::_internal_has_temperature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ThermalSample::has_temperature() const {
  return _internal_has_temperature();
}
inline void ThermalSample::clear_temperature() {
  _impl_.temperature_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ThermalSample::_internal_temperature() const {
  return _impl_.temperature_;
}
inline int32_t ThermalSample::temperature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ThermalSample.temperature)
  return _internal_temperature();
}
inline void ThermalSample::_internal_set_temperature(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.temperature_ = value;
}
inline void ThermalSample::set_temperature(int32_t value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ThermalSample.temperature)
}

// -------------------------------------------------------------------

// ThermalInfo

// optional string label = 1;
inline bool ThermalInfo::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThermalInfo::has_label() const {
  return _internal_has_label();
}
inline void ThermalInfo::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThermalInfo::label() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ThermalInfo.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThermalInfo::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ThermalInfo.label)
}
inline std::string* ThermalInfo::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ThermalInfo.label)
  return _s;
}
inline const std::string& ThermalInfo::_internal_label() const {
  return _impl_.label_.Get();
}
inline void ThermalInfo::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* ThermalInfo::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* ThermalInfo::release_label() {
  // @@protoc_insertion_point(field_release:enterprise_management.ThermalInfo.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThermalInfo::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ThermalInfo.label)
}

// repeated .enterprise_management.ThermalSample samples = 3;
inline int ThermalInfo::_internal_samples_size() const {
  return _impl_.samples_.size();
}
inline int ThermalInfo::samples_size() const {
  return _internal_samples_size();
}
inline void ThermalInfo::clear_samples() {
  _impl_.samples_.Clear();
}
inline ::enterprise_management::ThermalSample* ThermalInfo::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ThermalInfo.samples)
  return _impl_.samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample >*
ThermalInfo::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ThermalInfo.samples)
  return &_impl_.samples_;
}
inline const ::enterprise_management::ThermalSample& ThermalInfo::_internal_samples(int index) const {
  return _impl_.samples_.Get(index);
}
inline const ::enterprise_management::ThermalSample& ThermalInfo::samples(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ThermalInfo.samples)
  return _internal_samples(index);
}
inline ::enterprise_management::ThermalSample* ThermalInfo::_internal_add_samples() {
  return _impl_.samples_.Add();
}
inline ::enterprise_management::ThermalSample* ThermalInfo::add_samples() {
  ::enterprise_management::ThermalSample* _add = _internal_add_samples();
  // @@protoc_insertion_point(field_add:enterprise_management.ThermalInfo.samples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalSample >&
ThermalInfo::samples() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ThermalInfo.samples)
  return _impl_.samples_;
}

// -------------------------------------------------------------------

// BoardStatus

// repeated .enterprise_management.ThermalInfo thermal_infos = 1;
inline int BoardStatus::_internal_thermal_infos_size() const {
  return _impl_.thermal_infos_.size();
}
inline int BoardStatus::thermal_infos_size() const {
  return _internal_thermal_infos_size();
}
inline void BoardStatus::clear_thermal_infos() {
  _impl_.thermal_infos_.Clear();
}
inline ::enterprise_management::ThermalInfo* BoardStatus::mutable_thermal_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.BoardStatus.thermal_infos)
  return _impl_.thermal_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo >*
BoardStatus::mutable_thermal_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.BoardStatus.thermal_infos)
  return &_impl_.thermal_infos_;
}
inline const ::enterprise_management::ThermalInfo& BoardStatus::_internal_thermal_infos(int index) const {
  return _impl_.thermal_infos_.Get(index);
}
inline const ::enterprise_management::ThermalInfo& BoardStatus::thermal_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.BoardStatus.thermal_infos)
  return _internal_thermal_infos(index);
}
inline ::enterprise_management::ThermalInfo* BoardStatus::_internal_add_thermal_infos() {
  return _impl_.thermal_infos_.Add();
}
inline ::enterprise_management::ThermalInfo* BoardStatus::add_thermal_infos() {
  ::enterprise_management::ThermalInfo* _add = _internal_add_thermal_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.BoardStatus.thermal_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ThermalInfo >&
BoardStatus::thermal_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.BoardStatus.thermal_infos)
  return _impl_.thermal_infos_;
}

// -------------------------------------------------------------------

// SystemStatus

// optional string vpd_sku_number = 1;
inline bool SystemStatus::_internal_has_vpd_sku_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemStatus::has_vpd_sku_number() const {
  return _internal_has_vpd_sku_number();
}
inline void SystemStatus::clear_vpd_sku_number() {
  _impl_.vpd_sku_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SystemStatus::vpd_sku_number() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.vpd_sku_number)
  return _internal_vpd_sku_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_vpd_sku_number(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vpd_sku_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.vpd_sku_number)
}
inline std::string* SystemStatus::mutable_vpd_sku_number() {
  std::string* _s = _internal_mutable_vpd_sku_number();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.vpd_sku_number)
  return _s;
}
inline const std::string& SystemStatus::_internal_vpd_sku_number() const {
  return _impl_.vpd_sku_number_.Get();
}
inline void SystemStatus::_internal_set_vpd_sku_number(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vpd_sku_number_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_vpd_sku_number() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vpd_sku_number_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_vpd_sku_number() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.vpd_sku_number)
  if (!_internal_has_vpd_sku_number()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vpd_sku_number_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vpd_sku_number_.IsDefault()) {
    _impl_.vpd_sku_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_vpd_sku_number(std::string* vpd_sku_number) {
  if (vpd_sku_number != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vpd_sku_number_.SetAllocated(vpd_sku_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vpd_sku_number_.IsDefault()) {
    _impl_.vpd_sku_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.vpd_sku_number)
}

// optional string first_power_date = 2;
inline bool SystemStatus::_internal_has_first_power_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SystemStatus::has_first_power_date() const {
  return _internal_has_first_power_date();
}
inline void SystemStatus::clear_first_power_date() {
  _impl_.first_power_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SystemStatus::first_power_date() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.first_power_date)
  return _internal_first_power_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_first_power_date(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.first_power_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.first_power_date)
}
inline std::string* SystemStatus::mutable_first_power_date() {
  std::string* _s = _internal_mutable_first_power_date();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.first_power_date)
  return _s;
}
inline const std::string& SystemStatus::_internal_first_power_date() const {
  return _impl_.first_power_date_.Get();
}
inline void SystemStatus::_internal_set_first_power_date(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.first_power_date_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_first_power_date() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.first_power_date_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_first_power_date() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.first_power_date)
  if (!_internal_has_first_power_date()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.first_power_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_power_date_.IsDefault()) {
    _impl_.first_power_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_first_power_date(std::string* first_power_date) {
  if (first_power_date != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.first_power_date_.SetAllocated(first_power_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_power_date_.IsDefault()) {
    _impl_.first_power_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.first_power_date)
}

// optional string manufacture_date = 3;
inline bool SystemStatus::_internal_has_manufacture_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SystemStatus::has_manufacture_date() const {
  return _internal_has_manufacture_date();
}
inline void SystemStatus::clear_manufacture_date() {
  _impl_.manufacture_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SystemStatus::manufacture_date() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.manufacture_date)
  return _internal_manufacture_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_manufacture_date(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.manufacture_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.manufacture_date)
}
inline std::string* SystemStatus::mutable_manufacture_date() {
  std::string* _s = _internal_mutable_manufacture_date();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.manufacture_date)
  return _s;
}
inline const std::string& SystemStatus::_internal_manufacture_date() const {
  return _impl_.manufacture_date_.Get();
}
inline void SystemStatus::_internal_set_manufacture_date(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.manufacture_date_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_manufacture_date() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.manufacture_date_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.manufacture_date)
  if (!_internal_has_manufacture_date()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.manufacture_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacture_date_.IsDefault()) {
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_manufacture_date(std::string* manufacture_date) {
  if (manufacture_date != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.manufacture_date_.SetAllocated(manufacture_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacture_date_.IsDefault()) {
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.manufacture_date)
}

// optional string marketing_name = 4;
inline bool SystemStatus::_internal_has_marketing_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SystemStatus::has_marketing_name() const {
  return _internal_has_marketing_name();
}
inline void SystemStatus::clear_marketing_name() {
  _impl_.marketing_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SystemStatus::marketing_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.marketing_name)
  return _internal_marketing_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_marketing_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.marketing_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.marketing_name)
}
inline std::string* SystemStatus::mutable_marketing_name() {
  std::string* _s = _internal_mutable_marketing_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.marketing_name)
  return _s;
}
inline const std::string& SystemStatus::_internal_marketing_name() const {
  return _impl_.marketing_name_.Get();
}
inline void SystemStatus::_internal_set_marketing_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.marketing_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_marketing_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.marketing_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_marketing_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.marketing_name)
  if (!_internal_has_marketing_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.marketing_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketing_name_.IsDefault()) {
    _impl_.marketing_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_marketing_name(std::string* marketing_name) {
  if (marketing_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.marketing_name_.SetAllocated(marketing_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketing_name_.IsDefault()) {
    _impl_.marketing_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.marketing_name)
}

// optional string bios_version = 5;
inline bool SystemStatus::_internal_has_bios_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SystemStatus::has_bios_version() const {
  return _internal_has_bios_version();
}
inline void SystemStatus::clear_bios_version() {
  _impl_.bios_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SystemStatus::bios_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.bios_version)
  return _internal_bios_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_bios_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.bios_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.bios_version)
}
inline std::string* SystemStatus::mutable_bios_version() {
  std::string* _s = _internal_mutable_bios_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.bios_version)
  return _s;
}
inline const std::string& SystemStatus::_internal_bios_version() const {
  return _impl_.bios_version_.Get();
}
inline void SystemStatus::_internal_set_bios_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bios_version_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_bios_version() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.bios_version_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_bios_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.bios_version)
  if (!_internal_has_bios_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.bios_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bios_version_.IsDefault()) {
    _impl_.bios_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_bios_version(std::string* bios_version) {
  if (bios_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.bios_version_.SetAllocated(bios_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bios_version_.IsDefault()) {
    _impl_.bios_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.bios_version)
}

// optional string board_name = 6;
inline bool SystemStatus::_internal_has_board_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SystemStatus::has_board_name() const {
  return _internal_has_board_name();
}
inline void SystemStatus::clear_board_name() {
  _impl_.board_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SystemStatus::board_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.board_name)
  return _internal_board_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_board_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.board_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.board_name)
}
inline std::string* SystemStatus::mutable_board_name() {
  std::string* _s = _internal_mutable_board_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.board_name)
  return _s;
}
inline const std::string& SystemStatus::_internal_board_name() const {
  return _impl_.board_name_.Get();
}
inline void SystemStatus::_internal_set_board_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.board_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_board_name() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.board_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_board_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.board_name)
  if (!_internal_has_board_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.board_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.board_name_.IsDefault()) {
    _impl_.board_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_board_name(std::string* board_name) {
  if (board_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.board_name_.SetAllocated(board_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.board_name_.IsDefault()) {
    _impl_.board_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.board_name)
}

// optional string board_version = 7;
inline bool SystemStatus::_internal_has_board_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SystemStatus::has_board_version() const {
  return _internal_has_board_version();
}
inline void SystemStatus::clear_board_version() {
  _impl_.board_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& SystemStatus::board_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.board_version)
  return _internal_board_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_board_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.board_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.board_version)
}
inline std::string* SystemStatus::mutable_board_version() {
  std::string* _s = _internal_mutable_board_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.board_version)
  return _s;
}
inline const std::string& SystemStatus::_internal_board_version() const {
  return _impl_.board_version_.Get();
}
inline void SystemStatus::_internal_set_board_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.board_version_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_board_version() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.board_version_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_board_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.board_version)
  if (!_internal_has_board_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.board_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.board_version_.IsDefault()) {
    _impl_.board_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_board_version(std::string* board_version) {
  if (board_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.board_version_.SetAllocated(board_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.board_version_.IsDefault()) {
    _impl_.board_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.board_version)
}

// optional uint64 chassis_type = 8;
inline bool SystemStatus::_internal_has_chassis_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SystemStatus::has_chassis_type() const {
  return _internal_has_chassis_type();
}
inline void SystemStatus::clear_chassis_type() {
  _impl_.chassis_type_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint64_t SystemStatus::_internal_chassis_type() const {
  return _impl_.chassis_type_;
}
inline uint64_t SystemStatus::chassis_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.chassis_type)
  return _internal_chassis_type();
}
inline void SystemStatus::_internal_set_chassis_type(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.chassis_type_ = value;
}
inline void SystemStatus::set_chassis_type(uint64_t value) {
  _internal_set_chassis_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.chassis_type)
}

// optional string product_name = 9;
inline bool SystemStatus::_internal_has_product_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SystemStatus::has_product_name() const {
  return _internal_has_product_name();
}
inline void SystemStatus::clear_product_name() {
  _impl_.product_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& SystemStatus::product_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.product_name)
  return _internal_product_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_product_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.product_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.product_name)
}
inline std::string* SystemStatus::mutable_product_name() {
  std::string* _s = _internal_mutable_product_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.product_name)
  return _s;
}
inline const std::string& SystemStatus::_internal_product_name() const {
  return _impl_.product_name_.Get();
}
inline void SystemStatus::_internal_set_product_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.product_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_product_name() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.product_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_product_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.product_name)
  if (!_internal_has_product_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.product_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_name_.IsDefault()) {
    _impl_.product_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_product_name(std::string* product_name) {
  if (product_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.product_name_.SetAllocated(product_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_name_.IsDefault()) {
    _impl_.product_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.product_name)
}

// optional string vpd_serial_number = 10;
inline bool SystemStatus::_internal_has_vpd_serial_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SystemStatus::has_vpd_serial_number() const {
  return _internal_has_vpd_serial_number();
}
inline void SystemStatus::clear_vpd_serial_number() {
  _impl_.vpd_serial_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& SystemStatus::vpd_serial_number() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemStatus.vpd_serial_number)
  return _internal_vpd_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_vpd_serial_number(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.vpd_serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SystemStatus.vpd_serial_number)
}
inline std::string* SystemStatus::mutable_vpd_serial_number() {
  std::string* _s = _internal_mutable_vpd_serial_number();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemStatus.vpd_serial_number)
  return _s;
}
inline const std::string& SystemStatus::_internal_vpd_serial_number() const {
  return _impl_.vpd_serial_number_.Get();
}
inline void SystemStatus::_internal_set_vpd_serial_number(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.vpd_serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_vpd_serial_number() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.vpd_serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_vpd_serial_number() {
  // @@protoc_insertion_point(field_release:enterprise_management.SystemStatus.vpd_serial_number)
  if (!_internal_has_vpd_serial_number()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.vpd_serial_number_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vpd_serial_number_.IsDefault()) {
    _impl_.vpd_serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemStatus::set_allocated_vpd_serial_number(std::string* vpd_serial_number) {
  if (vpd_serial_number != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.vpd_serial_number_.SetAllocated(vpd_serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vpd_serial_number_.IsDefault()) {
    _impl_.vpd_serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SystemStatus.vpd_serial_number)
}

// -------------------------------------------------------------------

// CpuCStateInfo

// optional string name = 1;
inline bool CpuCStateInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CpuCStateInfo::has_name() const {
  return _internal_has_name();
}
inline void CpuCStateInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CpuCStateInfo::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CpuCStateInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CpuCStateInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CpuCStateInfo.name)
}
inline std::string* CpuCStateInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CpuCStateInfo.name)
  return _s;
}
inline const std::string& CpuCStateInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CpuCStateInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CpuCStateInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CpuCStateInfo::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.CpuCStateInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CpuCStateInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CpuCStateInfo.name)
}

// optional uint64 time_in_state_since_last_boot_us = 2;
inline bool CpuCStateInfo::_internal_has_time_in_state_since_last_boot_us() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CpuCStateInfo::has_time_in_state_since_last_boot_us() const {
  return _internal_has_time_in_state_since_last_boot_us();
}
inline void CpuCStateInfo::clear_time_in_state_since_last_boot_us() {
  _impl_.time_in_state_since_last_boot_us_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CpuCStateInfo::_internal_time_in_state_since_last_boot_us() const {
  return _impl_.time_in_state_since_last_boot_us_;
}
inline uint64_t CpuCStateInfo::time_in_state_since_last_boot_us() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CpuCStateInfo.time_in_state_since_last_boot_us)
  return _internal_time_in_state_since_last_boot_us();
}
inline void CpuCStateInfo::_internal_set_time_in_state_since_last_boot_us(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.time_in_state_since_last_boot_us_ = value;
}
inline void CpuCStateInfo::set_time_in_state_since_last_boot_us(uint64_t value) {
  _internal_set_time_in_state_since_last_boot_us(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CpuCStateInfo.time_in_state_since_last_boot_us)
}

// -------------------------------------------------------------------

// LogicalCpuInfo

// optional uint32 scaling_max_frequency_khz = 1;
inline bool LogicalCpuInfo::_internal_has_scaling_max_frequency_khz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogicalCpuInfo::has_scaling_max_frequency_khz() const {
  return _internal_has_scaling_max_frequency_khz();
}
inline void LogicalCpuInfo::clear_scaling_max_frequency_khz() {
  _impl_.scaling_max_frequency_khz_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t LogicalCpuInfo::_internal_scaling_max_frequency_khz() const {
  return _impl_.scaling_max_frequency_khz_;
}
inline uint32_t LogicalCpuInfo::scaling_max_frequency_khz() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LogicalCpuInfo.scaling_max_frequency_khz)
  return _internal_scaling_max_frequency_khz();
}
inline void LogicalCpuInfo::_internal_set_scaling_max_frequency_khz(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scaling_max_frequency_khz_ = value;
}
inline void LogicalCpuInfo::set_scaling_max_frequency_khz(uint32_t value) {
  _internal_set_scaling_max_frequency_khz(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LogicalCpuInfo.scaling_max_frequency_khz)
}

// optional uint32 scaling_current_frequency_khz = 2;
inline bool LogicalCpuInfo::_internal_has_scaling_current_frequency_khz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LogicalCpuInfo::has_scaling_current_frequency_khz() const {
  return _internal_has_scaling_current_frequency_khz();
}
inline void LogicalCpuInfo::clear_scaling_current_frequency_khz() {
  _impl_.scaling_current_frequency_khz_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t LogicalCpuInfo::_internal_scaling_current_frequency_khz() const {
  return _impl_.scaling_current_frequency_khz_;
}
inline uint32_t LogicalCpuInfo::scaling_current_frequency_khz() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LogicalCpuInfo.scaling_current_frequency_khz)
  return _internal_scaling_current_frequency_khz();
}
inline void LogicalCpuInfo::_internal_set_scaling_current_frequency_khz(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.scaling_current_frequency_khz_ = value;
}
inline void LogicalCpuInfo::set_scaling_current_frequency_khz(uint32_t value) {
  _internal_set_scaling_current_frequency_khz(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LogicalCpuInfo.scaling_current_frequency_khz)
}

// optional uint64 idle_time_seconds = 3;
inline bool LogicalCpuInfo::_internal_has_idle_time_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LogicalCpuInfo::has_idle_time_seconds() const {
  return _internal_has_idle_time_seconds();
}
inline void LogicalCpuInfo::clear_idle_time_seconds() {
  _impl_.idle_time_seconds_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t LogicalCpuInfo::_internal_idle_time_seconds() const {
  return _impl_.idle_time_seconds_;
}
inline uint64_t LogicalCpuInfo::idle_time_seconds() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LogicalCpuInfo.idle_time_seconds)
  return _internal_idle_time_seconds();
}
inline void LogicalCpuInfo::_internal_set_idle_time_seconds(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.idle_time_seconds_ = value;
}
inline void LogicalCpuInfo::set_idle_time_seconds(uint64_t value) {
  _internal_set_idle_time_seconds(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LogicalCpuInfo.idle_time_seconds)
}

// repeated .enterprise_management.CpuCStateInfo c_states = 4;
inline int LogicalCpuInfo::_internal_c_states_size() const {
  return _impl_.c_states_.size();
}
inline int LogicalCpuInfo::c_states_size() const {
  return _internal_c_states_size();
}
inline void LogicalCpuInfo::clear_c_states() {
  _impl_.c_states_.Clear();
}
inline ::enterprise_management::CpuCStateInfo* LogicalCpuInfo::mutable_c_states(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.LogicalCpuInfo.c_states)
  return _impl_.c_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo >*
LogicalCpuInfo::mutable_c_states() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.LogicalCpuInfo.c_states)
  return &_impl_.c_states_;
}
inline const ::enterprise_management::CpuCStateInfo& LogicalCpuInfo::_internal_c_states(int index) const {
  return _impl_.c_states_.Get(index);
}
inline const ::enterprise_management::CpuCStateInfo& LogicalCpuInfo::c_states(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.LogicalCpuInfo.c_states)
  return _internal_c_states(index);
}
inline ::enterprise_management::CpuCStateInfo* LogicalCpuInfo::_internal_add_c_states() {
  return _impl_.c_states_.Add();
}
inline ::enterprise_management::CpuCStateInfo* LogicalCpuInfo::add_c_states() {
  ::enterprise_management::CpuCStateInfo* _add = _internal_add_c_states();
  // @@protoc_insertion_point(field_add:enterprise_management.LogicalCpuInfo.c_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuCStateInfo >&
LogicalCpuInfo::c_states() const {
  // @@protoc_insertion_point(field_list:enterprise_management.LogicalCpuInfo.c_states)
  return _impl_.c_states_;
}

// -------------------------------------------------------------------

// CpuInfo

// optional string model_name = 1;
inline bool CpuInfo::_internal_has_model_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CpuInfo::has_model_name() const {
  return _internal_has_model_name();
}
inline void CpuInfo::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CpuInfo::model_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CpuInfo.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CpuInfo::set_model_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CpuInfo.model_name)
}
inline std::string* CpuInfo::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CpuInfo.model_name)
  return _s;
}
inline const std::string& CpuInfo::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void CpuInfo::_internal_set_model_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CpuInfo::_internal_mutable_model_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CpuInfo::release_model_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.CpuInfo.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.model_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CpuInfo::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CpuInfo.model_name)
}

// optional .enterprise_management.CpuInfo.Architecture architecture = 2;
inline bool CpuInfo::_internal_has_architecture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CpuInfo::has_architecture() const {
  return _internal_has_architecture();
}
inline void CpuInfo::clear_architecture() {
  _impl_.architecture_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::CpuInfo_Architecture CpuInfo::_internal_architecture() const {
  return static_cast< ::enterprise_management::CpuInfo_Architecture >(_impl_.architecture_);
}
inline ::enterprise_management::CpuInfo_Architecture CpuInfo::architecture() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CpuInfo.architecture)
  return _internal_architecture();
}
inline void CpuInfo::_internal_set_architecture(::enterprise_management::CpuInfo_Architecture value) {
  assert(::enterprise_management::CpuInfo_Architecture_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.architecture_ = value;
}
inline void CpuInfo::set_architecture(::enterprise_management::CpuInfo_Architecture value) {
  _internal_set_architecture(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CpuInfo.architecture)
}

// optional uint32 max_clock_speed_khz = 3;
inline bool CpuInfo::_internal_has_max_clock_speed_khz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CpuInfo::has_max_clock_speed_khz() const {
  return _internal_has_max_clock_speed_khz();
}
inline void CpuInfo::clear_max_clock_speed_khz() {
  _impl_.max_clock_speed_khz_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CpuInfo::_internal_max_clock_speed_khz() const {
  return _impl_.max_clock_speed_khz_;
}
inline uint32_t CpuInfo::max_clock_speed_khz() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CpuInfo.max_clock_speed_khz)
  return _internal_max_clock_speed_khz();
}
inline void CpuInfo::_internal_set_max_clock_speed_khz(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_clock_speed_khz_ = value;
}
inline void CpuInfo::set_max_clock_speed_khz(uint32_t value) {
  _internal_set_max_clock_speed_khz(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CpuInfo.max_clock_speed_khz)
}

// repeated .enterprise_management.LogicalCpuInfo logical_cpus = 4;
inline int CpuInfo::_internal_logical_cpus_size() const {
  return _impl_.logical_cpus_.size();
}
inline int CpuInfo::logical_cpus_size() const {
  return _internal_logical_cpus_size();
}
inline void CpuInfo::clear_logical_cpus() {
  _impl_.logical_cpus_.Clear();
}
inline ::enterprise_management::LogicalCpuInfo* CpuInfo::mutable_logical_cpus(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.CpuInfo.logical_cpus)
  return _impl_.logical_cpus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo >*
CpuInfo::mutable_logical_cpus() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.CpuInfo.logical_cpus)
  return &_impl_.logical_cpus_;
}
inline const ::enterprise_management::LogicalCpuInfo& CpuInfo::_internal_logical_cpus(int index) const {
  return _impl_.logical_cpus_.Get(index);
}
inline const ::enterprise_management::LogicalCpuInfo& CpuInfo::logical_cpus(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.CpuInfo.logical_cpus)
  return _internal_logical_cpus(index);
}
inline ::enterprise_management::LogicalCpuInfo* CpuInfo::_internal_add_logical_cpus() {
  return _impl_.logical_cpus_.Add();
}
inline ::enterprise_management::LogicalCpuInfo* CpuInfo::add_logical_cpus() {
  ::enterprise_management::LogicalCpuInfo* _add = _internal_add_logical_cpus();
  // @@protoc_insertion_point(field_add:enterprise_management.CpuInfo.logical_cpus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LogicalCpuInfo >&
CpuInfo::logical_cpus() const {
  // @@protoc_insertion_point(field_list:enterprise_management.CpuInfo.logical_cpus)
  return _impl_.logical_cpus_;
}

// -------------------------------------------------------------------

// GlobalCpuInfo

// optional uint32 num_total_threads = 1;
inline bool GlobalCpuInfo::_internal_has_num_total_threads() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GlobalCpuInfo::has_num_total_threads() const {
  return _internal_has_num_total_threads();
}
inline void GlobalCpuInfo::clear_num_total_threads() {
  _impl_.num_total_threads_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GlobalCpuInfo::_internal_num_total_threads() const {
  return _impl_.num_total_threads_;
}
inline uint32_t GlobalCpuInfo::num_total_threads() const {
  // @@protoc_insertion_point(field_get:enterprise_management.GlobalCpuInfo.num_total_threads)
  return _internal_num_total_threads();
}
inline void GlobalCpuInfo::_internal_set_num_total_threads(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.num_total_threads_ = value;
}
inline void GlobalCpuInfo::set_num_total_threads(uint32_t value) {
  _internal_set_num_total_threads(value);
  // @@protoc_insertion_point(field_set:enterprise_management.GlobalCpuInfo.num_total_threads)
}

// -------------------------------------------------------------------

// DisplayInfo

// optional uint32 resolution_width = 1;
inline bool DisplayInfo::_internal_has_resolution_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisplayInfo::has_resolution_width() const {
  return _internal_has_resolution_width();
}
inline void DisplayInfo::clear_resolution_width() {
  _impl_.resolution_width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t DisplayInfo::_internal_resolution_width() const {
  return _impl_.resolution_width_;
}
inline uint32_t DisplayInfo::resolution_width() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DisplayInfo.resolution_width)
  return _internal_resolution_width();
}
inline void DisplayInfo::_internal_set_resolution_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.resolution_width_ = value;
}
inline void DisplayInfo::set_resolution_width(uint32_t value) {
  _internal_set_resolution_width(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DisplayInfo.resolution_width)
}

// optional uint32 resolution_height = 2;
inline bool DisplayInfo::_internal_has_resolution_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DisplayInfo::has_resolution_height() const {
  return _internal_has_resolution_height();
}
inline void DisplayInfo::clear_resolution_height() {
  _impl_.resolution_height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DisplayInfo::_internal_resolution_height() const {
  return _impl_.resolution_height_;
}
inline uint32_t DisplayInfo::resolution_height() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DisplayInfo.resolution_height)
  return _internal_resolution_height();
}
inline void DisplayInfo::_internal_set_resolution_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resolution_height_ = value;
}
inline void DisplayInfo::set_resolution_height(uint32_t value) {
  _internal_set_resolution_height(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DisplayInfo.resolution_height)
}

// optional uint32 refresh_rate = 3;
inline bool DisplayInfo::_internal_has_refresh_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DisplayInfo::has_refresh_rate() const {
  return _internal_has_refresh_rate();
}
inline void DisplayInfo::clear_refresh_rate() {
  _impl_.refresh_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t DisplayInfo::_internal_refresh_rate() const {
  return _impl_.refresh_rate_;
}
inline uint32_t DisplayInfo::refresh_rate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DisplayInfo.refresh_rate)
  return _internal_refresh_rate();
}
inline void DisplayInfo::_internal_set_refresh_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.refresh_rate_ = value;
}
inline void DisplayInfo::set_refresh_rate(uint32_t value) {
  _internal_set_refresh_rate(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DisplayInfo.refresh_rate)
}

// optional bool is_internal = 4;
inline bool DisplayInfo::_internal_has_is_internal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DisplayInfo::has_is_internal() const {
  return _internal_has_is_internal();
}
inline void DisplayInfo::clear_is_internal() {
  _impl_.is_internal_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DisplayInfo::_internal_is_internal() const {
  return _impl_.is_internal_;
}
inline bool DisplayInfo::is_internal() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DisplayInfo.is_internal)
  return _internal_is_internal();
}
inline void DisplayInfo::_internal_set_is_internal(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_internal_ = value;
}
inline void DisplayInfo::set_is_internal(bool value) {
  _internal_set_is_internal(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DisplayInfo.is_internal)
}

// -------------------------------------------------------------------

// GraphicsAdapterInfo

// optional string name = 1;
inline bool GraphicsAdapterInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GraphicsAdapterInfo::has_name() const {
  return _internal_has_name();
}
inline void GraphicsAdapterInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GraphicsAdapterInfo::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.GraphicsAdapterInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphicsAdapterInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.GraphicsAdapterInfo.name)
}
inline std::string* GraphicsAdapterInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.GraphicsAdapterInfo.name)
  return _s;
}
inline const std::string& GraphicsAdapterInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GraphicsAdapterInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphicsAdapterInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphicsAdapterInfo::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.GraphicsAdapterInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GraphicsAdapterInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.GraphicsAdapterInfo.name)
}

// optional string driver_version = 2;
inline bool GraphicsAdapterInfo::_internal_has_driver_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GraphicsAdapterInfo::has_driver_version() const {
  return _internal_has_driver_version();
}
inline void GraphicsAdapterInfo::clear_driver_version() {
  _impl_.driver_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GraphicsAdapterInfo::driver_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.GraphicsAdapterInfo.driver_version)
  return _internal_driver_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphicsAdapterInfo::set_driver_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.driver_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.GraphicsAdapterInfo.driver_version)
}
inline std::string* GraphicsAdapterInfo::mutable_driver_version() {
  std::string* _s = _internal_mutable_driver_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.GraphicsAdapterInfo.driver_version)
  return _s;
}
inline const std::string& GraphicsAdapterInfo::_internal_driver_version() const {
  return _impl_.driver_version_.Get();
}
inline void GraphicsAdapterInfo::_internal_set_driver_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.driver_version_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphicsAdapterInfo::_internal_mutable_driver_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.driver_version_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphicsAdapterInfo::release_driver_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.GraphicsAdapterInfo.driver_version)
  if (!_internal_has_driver_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.driver_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_version_.IsDefault()) {
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GraphicsAdapterInfo::set_allocated_driver_version(std::string* driver_version) {
  if (driver_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.driver_version_.SetAllocated(driver_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_version_.IsDefault()) {
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.GraphicsAdapterInfo.driver_version)
}

// optional uint64 device_id = 3;
inline bool GraphicsAdapterInfo::_internal_has_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GraphicsAdapterInfo::has_device_id() const {
  return _internal_has_device_id();
}
inline void GraphicsAdapterInfo::clear_device_id() {
  _impl_.device_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t GraphicsAdapterInfo::_internal_device_id() const {
  return _impl_.device_id_;
}
inline uint64_t GraphicsAdapterInfo::device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.GraphicsAdapterInfo.device_id)
  return _internal_device_id();
}
inline void GraphicsAdapterInfo::_internal_set_device_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.device_id_ = value;
}
inline void GraphicsAdapterInfo::set_device_id(uint64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.GraphicsAdapterInfo.device_id)
}

// optional uint64 system_ram_usage = 4;
inline bool GraphicsAdapterInfo::_internal_has_system_ram_usage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GraphicsAdapterInfo::has_system_ram_usage() const {
  return _internal_has_system_ram_usage();
}
inline void GraphicsAdapterInfo::clear_system_ram_usage() {
  _impl_.system_ram_usage_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t GraphicsAdapterInfo::_internal_system_ram_usage() const {
  return _impl_.system_ram_usage_;
}
inline uint64_t GraphicsAdapterInfo::system_ram_usage() const {
  // @@protoc_insertion_point(field_get:enterprise_management.GraphicsAdapterInfo.system_ram_usage)
  return _internal_system_ram_usage();
}
inline void GraphicsAdapterInfo::_internal_set_system_ram_usage(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.system_ram_usage_ = value;
}
inline void GraphicsAdapterInfo::set_system_ram_usage(uint64_t value) {
  _internal_set_system_ram_usage(value);
  // @@protoc_insertion_point(field_set:enterprise_management.GraphicsAdapterInfo.system_ram_usage)
}

// -------------------------------------------------------------------

// GraphicsStatus

// optional .enterprise_management.GraphicsAdapterInfo adapter = 1;
inline bool GraphicsStatus::_internal_has_adapter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.adapter_ != nullptr);
  return value;
}
inline bool GraphicsStatus::has_adapter() const {
  return _internal_has_adapter();
}
inline void GraphicsStatus::clear_adapter() {
  if (_impl_.adapter_ != nullptr) _impl_.adapter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::GraphicsAdapterInfo& GraphicsStatus::_internal_adapter() const {
  const ::enterprise_management::GraphicsAdapterInfo* p = _impl_.adapter_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::GraphicsAdapterInfo&>(
      ::enterprise_management::_GraphicsAdapterInfo_default_instance_);
}
inline const ::enterprise_management::GraphicsAdapterInfo& GraphicsStatus::adapter() const {
  // @@protoc_insertion_point(field_get:enterprise_management.GraphicsStatus.adapter)
  return _internal_adapter();
}
inline void GraphicsStatus::unsafe_arena_set_allocated_adapter(
    ::enterprise_management::GraphicsAdapterInfo* adapter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adapter_);
  }
  _impl_.adapter_ = adapter;
  if (adapter) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.GraphicsStatus.adapter)
}
inline ::enterprise_management::GraphicsAdapterInfo* GraphicsStatus::release_adapter() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::GraphicsAdapterInfo* temp = _impl_.adapter_;
  _impl_.adapter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::GraphicsAdapterInfo* GraphicsStatus::unsafe_arena_release_adapter() {
  // @@protoc_insertion_point(field_release:enterprise_management.GraphicsStatus.adapter)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::GraphicsAdapterInfo* temp = _impl_.adapter_;
  _impl_.adapter_ = nullptr;
  return temp;
}
inline ::enterprise_management::GraphicsAdapterInfo* GraphicsStatus::_internal_mutable_adapter() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.adapter_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::GraphicsAdapterInfo>(GetArenaForAllocation());
    _impl_.adapter_ = p;
  }
  return _impl_.adapter_;
}
inline ::enterprise_management::GraphicsAdapterInfo* GraphicsStatus::mutable_adapter() {
  ::enterprise_management::GraphicsAdapterInfo* _msg = _internal_mutable_adapter();
  // @@protoc_insertion_point(field_mutable:enterprise_management.GraphicsStatus.adapter)
  return _msg;
}
inline void GraphicsStatus::set_allocated_adapter(::enterprise_management::GraphicsAdapterInfo* adapter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.adapter_;
  }
  if (adapter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(adapter);
    if (message_arena != submessage_arena) {
      adapter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adapter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.adapter_ = adapter;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.GraphicsStatus.adapter)
}

// repeated .enterprise_management.DisplayInfo displays = 2;
inline int GraphicsStatus::_internal_displays_size() const {
  return _impl_.displays_.size();
}
inline int GraphicsStatus::displays_size() const {
  return _internal_displays_size();
}
inline void GraphicsStatus::clear_displays() {
  _impl_.displays_.Clear();
}
inline ::enterprise_management::DisplayInfo* GraphicsStatus::mutable_displays(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.GraphicsStatus.displays)
  return _impl_.displays_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo >*
GraphicsStatus::mutable_displays() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.GraphicsStatus.displays)
  return &_impl_.displays_;
}
inline const ::enterprise_management::DisplayInfo& GraphicsStatus::_internal_displays(int index) const {
  return _impl_.displays_.Get(index);
}
inline const ::enterprise_management::DisplayInfo& GraphicsStatus::displays(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.GraphicsStatus.displays)
  return _internal_displays(index);
}
inline ::enterprise_management::DisplayInfo* GraphicsStatus::_internal_add_displays() {
  return _impl_.displays_.Add();
}
inline ::enterprise_management::DisplayInfo* GraphicsStatus::add_displays() {
  ::enterprise_management::DisplayInfo* _add = _internal_add_displays();
  // @@protoc_insertion_point(field_add:enterprise_management.GraphicsStatus.displays)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DisplayInfo >&
GraphicsStatus::displays() const {
  // @@protoc_insertion_point(field_list:enterprise_management.GraphicsStatus.displays)
  return _impl_.displays_;
}

// -------------------------------------------------------------------

// CrashReportInfo

// optional string remote_id = 1;
inline bool CrashReportInfo::_internal_has_remote_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrashReportInfo::has_remote_id() const {
  return _internal_has_remote_id();
}
inline void CrashReportInfo::clear_remote_id() {
  _impl_.remote_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrashReportInfo::remote_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrashReportInfo.remote_id)
  return _internal_remote_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrashReportInfo::set_remote_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.remote_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CrashReportInfo.remote_id)
}
inline std::string* CrashReportInfo::mutable_remote_id() {
  std::string* _s = _internal_mutable_remote_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrashReportInfo.remote_id)
  return _s;
}
inline const std::string& CrashReportInfo::_internal_remote_id() const {
  return _impl_.remote_id_.Get();
}
inline void CrashReportInfo::_internal_set_remote_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.remote_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CrashReportInfo::_internal_mutable_remote_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.remote_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CrashReportInfo::release_remote_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.CrashReportInfo.remote_id)
  if (!_internal_has_remote_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.remote_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_id_.IsDefault()) {
    _impl_.remote_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrashReportInfo::set_allocated_remote_id(std::string* remote_id) {
  if (remote_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.remote_id_.SetAllocated(remote_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_id_.IsDefault()) {
    _impl_.remote_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CrashReportInfo.remote_id)
}

// optional int64 capture_timestamp = 2;
inline bool CrashReportInfo::_internal_has_capture_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrashReportInfo::has_capture_timestamp() const {
  return _internal_has_capture_timestamp();
}
inline void CrashReportInfo::clear_capture_timestamp() {
  _impl_.capture_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t CrashReportInfo::_internal_capture_timestamp() const {
  return _impl_.capture_timestamp_;
}
inline int64_t CrashReportInfo::capture_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrashReportInfo.capture_timestamp)
  return _internal_capture_timestamp();
}
inline void CrashReportInfo::_internal_set_capture_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.capture_timestamp_ = value;
}
inline void CrashReportInfo::set_capture_timestamp(int64_t value) {
  _internal_set_capture_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CrashReportInfo.capture_timestamp)
}

// optional string cause = 3;
inline bool CrashReportInfo::_internal_has_cause() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrashReportInfo::has_cause() const {
  return _internal_has_cause();
}
inline void CrashReportInfo::clear_cause() {
  _impl_.cause_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CrashReportInfo::cause() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrashReportInfo.cause)
  return _internal_cause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrashReportInfo::set_cause(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cause_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CrashReportInfo.cause)
}
inline std::string* CrashReportInfo::mutable_cause() {
  std::string* _s = _internal_mutable_cause();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrashReportInfo.cause)
  return _s;
}
inline const std::string& CrashReportInfo::_internal_cause() const {
  return _impl_.cause_.Get();
}
inline void CrashReportInfo::_internal_set_cause(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cause_.Set(value, GetArenaForAllocation());
}
inline std::string* CrashReportInfo::_internal_mutable_cause() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cause_.Mutable(GetArenaForAllocation());
}
inline std::string* CrashReportInfo::release_cause() {
  // @@protoc_insertion_point(field_release:enterprise_management.CrashReportInfo.cause)
  if (!_internal_has_cause()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cause_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cause_.IsDefault()) {
    _impl_.cause_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrashReportInfo::set_allocated_cause(std::string* cause) {
  if (cause != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cause_.SetAllocated(cause, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cause_.IsDefault()) {
    _impl_.cause_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CrashReportInfo.cause)
}

// optional .enterprise_management.CrashReportInfo.CrashReportUploadStatus upload_status = 4;
inline bool CrashReportInfo::_internal_has_upload_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrashReportInfo::has_upload_status() const {
  return _internal_has_upload_status();
}
inline void CrashReportInfo::clear_upload_status() {
  _impl_.upload_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::CrashReportInfo_CrashReportUploadStatus CrashReportInfo::_internal_upload_status() const {
  return static_cast< ::enterprise_management::CrashReportInfo_CrashReportUploadStatus >(_impl_.upload_status_);
}
inline ::enterprise_management::CrashReportInfo_CrashReportUploadStatus CrashReportInfo::upload_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrashReportInfo.upload_status)
  return _internal_upload_status();
}
inline void CrashReportInfo::_internal_set_upload_status(::enterprise_management::CrashReportInfo_CrashReportUploadStatus value) {
  assert(::enterprise_management::CrashReportInfo_CrashReportUploadStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.upload_status_ = value;
}
inline void CrashReportInfo::set_upload_status(::enterprise_management::CrashReportInfo_CrashReportUploadStatus value) {
  _internal_set_upload_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CrashReportInfo.upload_status)
}

// -------------------------------------------------------------------

// TimezoneInfo

// optional string posix = 1;
inline bool TimezoneInfo::_internal_has_posix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimezoneInfo::has_posix() const {
  return _internal_has_posix();
}
inline void TimezoneInfo::clear_posix() {
  _impl_.posix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TimezoneInfo::posix() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TimezoneInfo.posix)
  return _internal_posix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimezoneInfo::set_posix(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.posix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.TimezoneInfo.posix)
}
inline std::string* TimezoneInfo::mutable_posix() {
  std::string* _s = _internal_mutable_posix();
  // @@protoc_insertion_point(field_mutable:enterprise_management.TimezoneInfo.posix)
  return _s;
}
inline const std::string& TimezoneInfo::_internal_posix() const {
  return _impl_.posix_.Get();
}
inline void TimezoneInfo::_internal_set_posix(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.posix_.Set(value, GetArenaForAllocation());
}
inline std::string* TimezoneInfo::_internal_mutable_posix() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.posix_.Mutable(GetArenaForAllocation());
}
inline std::string* TimezoneInfo::release_posix() {
  // @@protoc_insertion_point(field_release:enterprise_management.TimezoneInfo.posix)
  if (!_internal_has_posix()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.posix_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.posix_.IsDefault()) {
    _impl_.posix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TimezoneInfo::set_allocated_posix(std::string* posix) {
  if (posix != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.posix_.SetAllocated(posix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.posix_.IsDefault()) {
    _impl_.posix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.TimezoneInfo.posix)
}

// optional string region = 2;
inline bool TimezoneInfo::_internal_has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimezoneInfo::has_region() const {
  return _internal_has_region();
}
inline void TimezoneInfo::clear_region() {
  _impl_.region_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TimezoneInfo::region() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TimezoneInfo.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimezoneInfo::set_region(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.TimezoneInfo.region)
}
inline std::string* TimezoneInfo::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:enterprise_management.TimezoneInfo.region)
  return _s;
}
inline const std::string& TimezoneInfo::_internal_region() const {
  return _impl_.region_.Get();
}
inline void TimezoneInfo::_internal_set_region(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* TimezoneInfo::_internal_mutable_region() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* TimezoneInfo::release_region() {
  // @@protoc_insertion_point(field_release:enterprise_management.TimezoneInfo.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TimezoneInfo::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.TimezoneInfo.region)
}

// -------------------------------------------------------------------

// MemoryInfo

// optional uint32 total_memory_kib = 1;
inline bool MemoryInfo::_internal_has_total_memory_kib() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MemoryInfo::has_total_memory_kib() const {
  return _internal_has_total_memory_kib();
}
inline void MemoryInfo::clear_total_memory_kib() {
  _impl_.total_memory_kib_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MemoryInfo::_internal_total_memory_kib() const {
  return _impl_.total_memory_kib_;
}
inline uint32_t MemoryInfo::total_memory_kib() const {
  // @@protoc_insertion_point(field_get:enterprise_management.MemoryInfo.total_memory_kib)
  return _internal_total_memory_kib();
}
inline void MemoryInfo::_internal_set_total_memory_kib(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.total_memory_kib_ = value;
}
inline void MemoryInfo::set_total_memory_kib(uint32_t value) {
  _internal_set_total_memory_kib(value);
  // @@protoc_insertion_point(field_set:enterprise_management.MemoryInfo.total_memory_kib)
}

// optional uint32 free_memory_kib = 2;
inline bool MemoryInfo::_internal_has_free_memory_kib() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MemoryInfo::has_free_memory_kib() const {
  return _internal_has_free_memory_kib();
}
inline void MemoryInfo::clear_free_memory_kib() {
  _impl_.free_memory_kib_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MemoryInfo::_internal_free_memory_kib() const {
  return _impl_.free_memory_kib_;
}
inline uint32_t MemoryInfo::free_memory_kib() const {
  // @@protoc_insertion_point(field_get:enterprise_management.MemoryInfo.free_memory_kib)
  return _internal_free_memory_kib();
}
inline void MemoryInfo::_internal_set_free_memory_kib(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.free_memory_kib_ = value;
}
inline void MemoryInfo::set_free_memory_kib(uint32_t value) {
  _internal_set_free_memory_kib(value);
  // @@protoc_insertion_point(field_set:enterprise_management.MemoryInfo.free_memory_kib)
}

// optional uint32 available_memory_kib = 3;
inline bool MemoryInfo::_internal_has_available_memory_kib() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MemoryInfo::has_available_memory_kib() const {
  return _internal_has_available_memory_kib();
}
inline void MemoryInfo::clear_available_memory_kib() {
  _impl_.available_memory_kib_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MemoryInfo::_internal_available_memory_kib() const {
  return _impl_.available_memory_kib_;
}
inline uint32_t MemoryInfo::available_memory_kib() const {
  // @@protoc_insertion_point(field_get:enterprise_management.MemoryInfo.available_memory_kib)
  return _internal_available_memory_kib();
}
inline void MemoryInfo::_internal_set_available_memory_kib(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.available_memory_kib_ = value;
}
inline void MemoryInfo::set_available_memory_kib(uint32_t value) {
  _internal_set_available_memory_kib(value);
  // @@protoc_insertion_point(field_set:enterprise_management.MemoryInfo.available_memory_kib)
}

// optional uint64 page_faults_since_last_boot = 4;
inline bool MemoryInfo::_internal_has_page_faults_since_last_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MemoryInfo::has_page_faults_since_last_boot() const {
  return _internal_has_page_faults_since_last_boot();
}
inline void MemoryInfo::clear_page_faults_since_last_boot() {
  _impl_.page_faults_since_last_boot_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t MemoryInfo::_internal_page_faults_since_last_boot() const {
  return _impl_.page_faults_since_last_boot_;
}
inline uint64_t MemoryInfo::page_faults_since_last_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.MemoryInfo.page_faults_since_last_boot)
  return _internal_page_faults_since_last_boot();
}
inline void MemoryInfo::_internal_set_page_faults_since_last_boot(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.page_faults_since_last_boot_ = value;
}
inline void MemoryInfo::set_page_faults_since_last_boot(uint64_t value) {
  _internal_set_page_faults_since_last_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.MemoryInfo.page_faults_since_last_boot)
}

// -------------------------------------------------------------------

// BacklightInfo

// optional string path = 1;
inline bool BacklightInfo::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BacklightInfo::has_path() const {
  return _internal_has_path();
}
inline void BacklightInfo::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BacklightInfo::path() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BacklightInfo.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BacklightInfo::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BacklightInfo.path)
}
inline std::string* BacklightInfo::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BacklightInfo.path)
  return _s;
}
inline const std::string& BacklightInfo::_internal_path() const {
  return _impl_.path_.Get();
}
inline void BacklightInfo::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* BacklightInfo::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* BacklightInfo::release_path() {
  // @@protoc_insertion_point(field_release:enterprise_management.BacklightInfo.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BacklightInfo::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BacklightInfo.path)
}

// optional uint32 max_brightness = 2;
inline bool BacklightInfo::_internal_has_max_brightness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BacklightInfo::has_max_brightness() const {
  return _internal_has_max_brightness();
}
inline void BacklightInfo::clear_max_brightness() {
  _impl_.max_brightness_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t BacklightInfo::_internal_max_brightness() const {
  return _impl_.max_brightness_;
}
inline uint32_t BacklightInfo::max_brightness() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BacklightInfo.max_brightness)
  return _internal_max_brightness();
}
inline void BacklightInfo::_internal_set_max_brightness(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_brightness_ = value;
}
inline void BacklightInfo::set_max_brightness(uint32_t value) {
  _internal_set_max_brightness(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BacklightInfo.max_brightness)
}

// optional uint32 brightness = 3;
inline bool BacklightInfo::_internal_has_brightness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BacklightInfo::has_brightness() const {
  return _internal_has_brightness();
}
inline void BacklightInfo::clear_brightness() {
  _impl_.brightness_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t BacklightInfo::_internal_brightness() const {
  return _impl_.brightness_;
}
inline uint32_t BacklightInfo::brightness() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BacklightInfo.brightness)
  return _internal_brightness();
}
inline void BacklightInfo::_internal_set_brightness(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.brightness_ = value;
}
inline void BacklightInfo::set_brightness(uint32_t value) {
  _internal_set_brightness(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BacklightInfo.brightness)
}

// -------------------------------------------------------------------

// FanInfo

// optional uint32 speed_rpm = 1;
inline bool FanInfo::_internal_has_speed_rpm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FanInfo::has_speed_rpm() const {
  return _internal_has_speed_rpm();
}
inline void FanInfo::clear_speed_rpm() {
  _impl_.speed_rpm_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t FanInfo::_internal_speed_rpm() const {
  return _impl_.speed_rpm_;
}
inline uint32_t FanInfo::speed_rpm() const {
  // @@protoc_insertion_point(field_get:enterprise_management.FanInfo.speed_rpm)
  return _internal_speed_rpm();
}
inline void FanInfo::_internal_set_speed_rpm(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.speed_rpm_ = value;
}
inline void FanInfo::set_speed_rpm(uint32_t value) {
  _internal_set_speed_rpm(value);
  // @@protoc_insertion_point(field_set:enterprise_management.FanInfo.speed_rpm)
}

// -------------------------------------------------------------------

// BluetoothAdapterInfo

// optional string name = 1;
inline bool BluetoothAdapterInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BluetoothAdapterInfo::has_name() const {
  return _internal_has_name();
}
inline void BluetoothAdapterInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothAdapterInfo::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BluetoothAdapterInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BluetoothAdapterInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BluetoothAdapterInfo.name)
}
inline std::string* BluetoothAdapterInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BluetoothAdapterInfo.name)
  return _s;
}
inline const std::string& BluetoothAdapterInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void BluetoothAdapterInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* BluetoothAdapterInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* BluetoothAdapterInfo::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.BluetoothAdapterInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BluetoothAdapterInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BluetoothAdapterInfo.name)
}

// optional string address = 2;
inline bool BluetoothAdapterInfo::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BluetoothAdapterInfo::has_address() const {
  return _internal_has_address();
}
inline void BluetoothAdapterInfo::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BluetoothAdapterInfo::address() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BluetoothAdapterInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BluetoothAdapterInfo::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BluetoothAdapterInfo.address)
}
inline std::string* BluetoothAdapterInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BluetoothAdapterInfo.address)
  return _s;
}
inline const std::string& BluetoothAdapterInfo::_internal_address() const {
  return _impl_.address_.Get();
}
inline void BluetoothAdapterInfo::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* BluetoothAdapterInfo::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* BluetoothAdapterInfo::release_address() {
  // @@protoc_insertion_point(field_release:enterprise_management.BluetoothAdapterInfo.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BluetoothAdapterInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BluetoothAdapterInfo.address)
}

// optional bool powered = 3;
inline bool BluetoothAdapterInfo::_internal_has_powered() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BluetoothAdapterInfo::has_powered() const {
  return _internal_has_powered();
}
inline void BluetoothAdapterInfo::clear_powered() {
  _impl_.powered_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool BluetoothAdapterInfo::_internal_powered() const {
  return _impl_.powered_;
}
inline bool BluetoothAdapterInfo::powered() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BluetoothAdapterInfo.powered)
  return _internal_powered();
}
inline void BluetoothAdapterInfo::_internal_set_powered(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.powered_ = value;
}
inline void BluetoothAdapterInfo::set_powered(bool value) {
  _internal_set_powered(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BluetoothAdapterInfo.powered)
}

// optional uint32 num_connected_devices = 4;
inline bool BluetoothAdapterInfo::_internal_has_num_connected_devices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BluetoothAdapterInfo::has_num_connected_devices() const {
  return _internal_has_num_connected_devices();
}
inline void BluetoothAdapterInfo::clear_num_connected_devices() {
  _impl_.num_connected_devices_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t BluetoothAdapterInfo::_internal_num_connected_devices() const {
  return _impl_.num_connected_devices_;
}
inline uint32_t BluetoothAdapterInfo::num_connected_devices() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BluetoothAdapterInfo.num_connected_devices)
  return _internal_num_connected_devices();
}
inline void BluetoothAdapterInfo::_internal_set_num_connected_devices(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.num_connected_devices_ = value;
}
inline void BluetoothAdapterInfo::set_num_connected_devices(uint32_t value) {
  _internal_set_num_connected_devices(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BluetoothAdapterInfo.num_connected_devices)
}

// -------------------------------------------------------------------

// SmbiosInfo

// optional string sys_vendor = 1;
inline bool SmbiosInfo::_internal_has_sys_vendor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SmbiosInfo::has_sys_vendor() const {
  return _internal_has_sys_vendor();
}
inline void SmbiosInfo::clear_sys_vendor() {
  _impl_.sys_vendor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SmbiosInfo::sys_vendor() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SmbiosInfo.sys_vendor)
  return _internal_sys_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmbiosInfo::set_sys_vendor(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sys_vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SmbiosInfo.sys_vendor)
}
inline std::string* SmbiosInfo::mutable_sys_vendor() {
  std::string* _s = _internal_mutable_sys_vendor();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SmbiosInfo.sys_vendor)
  return _s;
}
inline const std::string& SmbiosInfo::_internal_sys_vendor() const {
  return _impl_.sys_vendor_.Get();
}
inline void SmbiosInfo::_internal_set_sys_vendor(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sys_vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* SmbiosInfo::_internal_mutable_sys_vendor() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sys_vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* SmbiosInfo::release_sys_vendor() {
  // @@protoc_insertion_point(field_release:enterprise_management.SmbiosInfo.sys_vendor)
  if (!_internal_has_sys_vendor()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sys_vendor_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sys_vendor_.IsDefault()) {
    _impl_.sys_vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SmbiosInfo::set_allocated_sys_vendor(std::string* sys_vendor) {
  if (sys_vendor != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sys_vendor_.SetAllocated(sys_vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sys_vendor_.IsDefault()) {
    _impl_.sys_vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SmbiosInfo.sys_vendor)
}

// optional string product_name = 2;
inline bool SmbiosInfo::_internal_has_product_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SmbiosInfo::has_product_name() const {
  return _internal_has_product_name();
}
inline void SmbiosInfo::clear_product_name() {
  _impl_.product_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SmbiosInfo::product_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SmbiosInfo.product_name)
  return _internal_product_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmbiosInfo::set_product_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.product_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SmbiosInfo.product_name)
}
inline std::string* SmbiosInfo::mutable_product_name() {
  std::string* _s = _internal_mutable_product_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SmbiosInfo.product_name)
  return _s;
}
inline const std::string& SmbiosInfo::_internal_product_name() const {
  return _impl_.product_name_.Get();
}
inline void SmbiosInfo::_internal_set_product_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.product_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SmbiosInfo::_internal_mutable_product_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.product_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SmbiosInfo::release_product_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.SmbiosInfo.product_name)
  if (!_internal_has_product_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.product_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_name_.IsDefault()) {
    _impl_.product_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SmbiosInfo::set_allocated_product_name(std::string* product_name) {
  if (product_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.product_name_.SetAllocated(product_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_name_.IsDefault()) {
    _impl_.product_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SmbiosInfo.product_name)
}

// optional string product_version = 3;
inline bool SmbiosInfo::_internal_has_product_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SmbiosInfo::has_product_version() const {
  return _internal_has_product_version();
}
inline void SmbiosInfo::clear_product_version() {
  _impl_.product_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SmbiosInfo::product_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SmbiosInfo.product_version)
  return _internal_product_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmbiosInfo::set_product_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.product_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SmbiosInfo.product_version)
}
inline std::string* SmbiosInfo::mutable_product_version() {
  std::string* _s = _internal_mutable_product_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SmbiosInfo.product_version)
  return _s;
}
inline const std::string& SmbiosInfo::_internal_product_version() const {
  return _impl_.product_version_.Get();
}
inline void SmbiosInfo::_internal_set_product_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.product_version_.Set(value, GetArenaForAllocation());
}
inline std::string* SmbiosInfo::_internal_mutable_product_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.product_version_.Mutable(GetArenaForAllocation());
}
inline std::string* SmbiosInfo::release_product_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.SmbiosInfo.product_version)
  if (!_internal_has_product_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.product_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_version_.IsDefault()) {
    _impl_.product_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SmbiosInfo::set_allocated_product_version(std::string* product_version) {
  if (product_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.product_version_.SetAllocated(product_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_version_.IsDefault()) {
    _impl_.product_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SmbiosInfo.product_version)
}

// optional string bios_version = 4;
inline bool SmbiosInfo::_internal_has_bios_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SmbiosInfo::has_bios_version() const {
  return _internal_has_bios_version();
}
inline void SmbiosInfo::clear_bios_version() {
  _impl_.bios_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SmbiosInfo::bios_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SmbiosInfo.bios_version)
  return _internal_bios_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmbiosInfo::set_bios_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.bios_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SmbiosInfo.bios_version)
}
inline std::string* SmbiosInfo::mutable_bios_version() {
  std::string* _s = _internal_mutable_bios_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SmbiosInfo.bios_version)
  return _s;
}
inline const std::string& SmbiosInfo::_internal_bios_version() const {
  return _impl_.bios_version_.Get();
}
inline void SmbiosInfo::_internal_set_bios_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bios_version_.Set(value, GetArenaForAllocation());
}
inline std::string* SmbiosInfo::_internal_mutable_bios_version() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.bios_version_.Mutable(GetArenaForAllocation());
}
inline std::string* SmbiosInfo::release_bios_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.SmbiosInfo.bios_version)
  if (!_internal_has_bios_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.bios_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bios_version_.IsDefault()) {
    _impl_.bios_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SmbiosInfo::set_allocated_bios_version(std::string* bios_version) {
  if (bios_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.bios_version_.SetAllocated(bios_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bios_version_.IsDefault()) {
    _impl_.bios_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SmbiosInfo.bios_version)
}

// -------------------------------------------------------------------

// KernelParameters

// optional bool cros_efi = 1;
inline bool KernelParameters::_internal_has_cros_efi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KernelParameters::has_cros_efi() const {
  return _internal_has_cros_efi();
}
inline void KernelParameters::clear_cros_efi() {
  _impl_.cros_efi_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool KernelParameters::_internal_cros_efi() const {
  return _impl_.cros_efi_;
}
inline bool KernelParameters::cros_efi() const {
  // @@protoc_insertion_point(field_get:enterprise_management.KernelParameters.cros_efi)
  return _internal_cros_efi();
}
inline void KernelParameters::_internal_set_cros_efi(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cros_efi_ = value;
}
inline void KernelParameters::set_cros_efi(bool value) {
  _internal_set_cros_efi(value);
  // @@protoc_insertion_point(field_set:enterprise_management.KernelParameters.cros_efi)
}

// -------------------------------------------------------------------

// EFIVars

// optional bool secure_boot = 1;
inline bool EFIVars::_internal_has_secure_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EFIVars::has_secure_boot() const {
  return _internal_has_secure_boot();
}
inline void EFIVars::clear_secure_boot() {
  _impl_.secure_boot_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EFIVars::_internal_secure_boot() const {
  return _impl_.secure_boot_;
}
inline bool EFIVars::secure_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.EFIVars.secure_boot)
  return _internal_secure_boot();
}
inline void EFIVars::_internal_set_secure_boot(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.secure_boot_ = value;
}
inline void EFIVars::set_secure_boot(bool value) {
  _internal_set_secure_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.EFIVars.secure_boot)
}

// -------------------------------------------------------------------

// BootInfo

// optional .enterprise_management.BootInfo.BootMethod boot_method = 1;
inline bool BootInfo::_internal_has_boot_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BootInfo::has_boot_method() const {
  return _internal_has_boot_method();
}
inline void BootInfo::clear_boot_method() {
  _impl_.boot_method_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::BootInfo_BootMethod BootInfo::_internal_boot_method() const {
  return static_cast< ::enterprise_management::BootInfo_BootMethod >(_impl_.boot_method_);
}
inline ::enterprise_management::BootInfo_BootMethod BootInfo::boot_method() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BootInfo.boot_method)
  return _internal_boot_method();
}
inline void BootInfo::_internal_set_boot_method(::enterprise_management::BootInfo_BootMethod value) {
  assert(::enterprise_management::BootInfo_BootMethod_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.boot_method_ = value;
}
inline void BootInfo::set_boot_method(::enterprise_management::BootInfo_BootMethod value) {
  _internal_set_boot_method(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BootInfo.boot_method)
}

// optional bool secure_boot = 2 [deprecated = true];
inline bool BootInfo::_internal_has_secure_boot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BootInfo::has_secure_boot() const {
  return _internal_has_secure_boot();
}
inline void BootInfo::clear_secure_boot() {
  _impl_.secure_boot_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool BootInfo::_internal_secure_boot() const {
  return _impl_.secure_boot_;
}
inline bool BootInfo::secure_boot() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BootInfo.secure_boot)
  return _internal_secure_boot();
}
inline void BootInfo::_internal_set_secure_boot(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.secure_boot_ = value;
}
inline void BootInfo::set_secure_boot(bool value) {
  _internal_set_secure_boot(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BootInfo.secure_boot)
}

// -------------------------------------------------------------------

// NetworkAdapterInfo

// optional .enterprise_management.BusDeviceClass device_class = 1;
inline bool NetworkAdapterInfo::_internal_has_device_class() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NetworkAdapterInfo::has_device_class() const {
  return _internal_has_device_class();
}
inline void NetworkAdapterInfo::clear_device_class() {
  _impl_.device_class_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::BusDeviceClass NetworkAdapterInfo::_internal_device_class() const {
  return static_cast< ::enterprise_management::BusDeviceClass >(_impl_.device_class_);
}
inline ::enterprise_management::BusDeviceClass NetworkAdapterInfo::device_class() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkAdapterInfo.device_class)
  return _internal_device_class();
}
inline void NetworkAdapterInfo::_internal_set_device_class(::enterprise_management::BusDeviceClass value) {
  assert(::enterprise_management::BusDeviceClass_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.device_class_ = value;
}
inline void NetworkAdapterInfo::set_device_class(::enterprise_management::BusDeviceClass value) {
  _internal_set_device_class(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkAdapterInfo.device_class)
}

// optional .enterprise_management.BusType bus_type = 2;
inline bool NetworkAdapterInfo::_internal_has_bus_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NetworkAdapterInfo::has_bus_type() const {
  return _internal_has_bus_type();
}
inline void NetworkAdapterInfo::clear_bus_type() {
  _impl_.bus_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::BusType NetworkAdapterInfo::_internal_bus_type() const {
  return static_cast< ::enterprise_management::BusType >(_impl_.bus_type_);
}
inline ::enterprise_management::BusType NetworkAdapterInfo::bus_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkAdapterInfo.bus_type)
  return _internal_bus_type();
}
inline void NetworkAdapterInfo::_internal_set_bus_type(::enterprise_management::BusType value) {
  assert(::enterprise_management::BusType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bus_type_ = value;
}
inline void NetworkAdapterInfo::set_bus_type(::enterprise_management::BusType value) {
  _internal_set_bus_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkAdapterInfo.bus_type)
}

// optional int32 vendor_id = 3;
inline bool NetworkAdapterInfo::_internal_has_vendor_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NetworkAdapterInfo::has_vendor_id() const {
  return _internal_has_vendor_id();
}
inline void NetworkAdapterInfo::clear_vendor_id() {
  _impl_.vendor_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t NetworkAdapterInfo::_internal_vendor_id() const {
  return _impl_.vendor_id_;
}
inline int32_t NetworkAdapterInfo::vendor_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkAdapterInfo.vendor_id)
  return _internal_vendor_id();
}
inline void NetworkAdapterInfo::_internal_set_vendor_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.vendor_id_ = value;
}
inline void NetworkAdapterInfo::set_vendor_id(int32_t value) {
  _internal_set_vendor_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkAdapterInfo.vendor_id)
}

// optional string vendor_name = 4;
inline bool NetworkAdapterInfo::_internal_has_vendor_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetworkAdapterInfo::has_vendor_name() const {
  return _internal_has_vendor_name();
}
inline void NetworkAdapterInfo::clear_vendor_name() {
  _impl_.vendor_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkAdapterInfo::vendor_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkAdapterInfo.vendor_name)
  return _internal_vendor_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkAdapterInfo::set_vendor_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vendor_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkAdapterInfo.vendor_name)
}
inline std::string* NetworkAdapterInfo::mutable_vendor_name() {
  std::string* _s = _internal_mutable_vendor_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkAdapterInfo.vendor_name)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_vendor_name() const {
  return _impl_.vendor_name_.Get();
}
inline void NetworkAdapterInfo::_internal_set_vendor_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vendor_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkAdapterInfo::_internal_mutable_vendor_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vendor_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkAdapterInfo::release_vendor_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkAdapterInfo.vendor_name)
  if (!_internal_has_vendor_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vendor_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_name_.IsDefault()) {
    _impl_.vendor_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkAdapterInfo::set_allocated_vendor_name(std::string* vendor_name) {
  if (vendor_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vendor_name_.SetAllocated(vendor_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_name_.IsDefault()) {
    _impl_.vendor_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkAdapterInfo.vendor_name)
}

// optional int32 device_id = 5;
inline bool NetworkAdapterInfo::_internal_has_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NetworkAdapterInfo::has_device_id() const {
  return _internal_has_device_id();
}
inline void NetworkAdapterInfo::clear_device_id() {
  _impl_.device_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t NetworkAdapterInfo::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t NetworkAdapterInfo::device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkAdapterInfo.device_id)
  return _internal_device_id();
}
inline void NetworkAdapterInfo::_internal_set_device_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.device_id_ = value;
}
inline void NetworkAdapterInfo::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkAdapterInfo.device_id)
}

// optional string device_name = 6;
inline bool NetworkAdapterInfo::_internal_has_device_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NetworkAdapterInfo::has_device_name() const {
  return _internal_has_device_name();
}
inline void NetworkAdapterInfo::clear_device_name() {
  _impl_.device_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkAdapterInfo::device_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkAdapterInfo.device_name)
  return _internal_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkAdapterInfo::set_device_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.device_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkAdapterInfo.device_name)
}
inline std::string* NetworkAdapterInfo::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkAdapterInfo.device_name)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_device_name() const {
  return _impl_.device_name_.Get();
}
inline void NetworkAdapterInfo::_internal_set_device_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.device_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkAdapterInfo::_internal_mutable_device_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.device_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkAdapterInfo::release_device_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.NetworkAdapterInfo.device_name)
  if (!_internal_has_device_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.device_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_name_.IsDefault()) {
    _impl_.device_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NetworkAdapterInfo::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.device_name_.SetAllocated(device_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_name_.IsDefault()) {
    _impl_.device_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.NetworkAdapterInfo.device_name)
}

// repeated string driver = 7;
inline int NetworkAdapterInfo::_internal_driver_size() const {
  return _impl_.driver_.size();
}
inline int NetworkAdapterInfo::driver_size() const {
  return _internal_driver_size();
}
inline void NetworkAdapterInfo::clear_driver() {
  _impl_.driver_.Clear();
}
inline std::string* NetworkAdapterInfo::add_driver() {
  std::string* _s = _internal_add_driver();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.NetworkAdapterInfo.driver)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_driver(int index) const {
  return _impl_.driver_.Get(index);
}
inline const std::string& NetworkAdapterInfo::driver(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.NetworkAdapterInfo.driver)
  return _internal_driver(index);
}
inline std::string* NetworkAdapterInfo::mutable_driver(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.NetworkAdapterInfo.driver)
  return _impl_.driver_.Mutable(index);
}
inline void NetworkAdapterInfo::set_driver(int index, const std::string& value) {
  _impl_.driver_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkAdapterInfo.driver)
}
inline void NetworkAdapterInfo::set_driver(int index, std::string&& value) {
  _impl_.driver_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.NetworkAdapterInfo.driver)
}
inline void NetworkAdapterInfo::set_driver(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.driver_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.NetworkAdapterInfo.driver)
}
inline void NetworkAdapterInfo::set_driver(int index, const char* value, size_t size) {
  _impl_.driver_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.NetworkAdapterInfo.driver)
}
inline std::string* NetworkAdapterInfo::_internal_add_driver() {
  return _impl_.driver_.Add();
}
inline void NetworkAdapterInfo::add_driver(const std::string& value) {
  _impl_.driver_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.NetworkAdapterInfo.driver)
}
inline void NetworkAdapterInfo::add_driver(std::string&& value) {
  _impl_.driver_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.NetworkAdapterInfo.driver)
}
inline void NetworkAdapterInfo::add_driver(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.driver_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.NetworkAdapterInfo.driver)
}
inline void NetworkAdapterInfo::add_driver(const char* value, size_t size) {
  _impl_.driver_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.NetworkAdapterInfo.driver)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkAdapterInfo::driver() const {
  // @@protoc_insertion_point(field_list:enterprise_management.NetworkAdapterInfo.driver)
  return _impl_.driver_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkAdapterInfo::mutable_driver() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.NetworkAdapterInfo.driver)
  return &_impl_.driver_;
}

// -------------------------------------------------------------------

// LaCrOsBrowserReport

// optional .enterprise_management.DeviceUser device_user = 1;
inline bool LaCrOsBrowserReport::_internal_has_device_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_user_ != nullptr);
  return value;
}
inline bool LaCrOsBrowserReport::has_device_user() const {
  return _internal_has_device_user();
}
inline void LaCrOsBrowserReport::clear_device_user() {
  if (_impl_.device_user_ != nullptr) _impl_.device_user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::DeviceUser& LaCrOsBrowserReport::_internal_device_user() const {
  const ::enterprise_management::DeviceUser* p = _impl_.device_user_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceUser&>(
      ::enterprise_management::_DeviceUser_default_instance_);
}
inline const ::enterprise_management::DeviceUser& LaCrOsBrowserReport::device_user() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LaCrOsBrowserReport.device_user)
  return _internal_device_user();
}
inline void LaCrOsBrowserReport::unsafe_arena_set_allocated_device_user(
    ::enterprise_management::DeviceUser* device_user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_user_);
  }
  _impl_.device_user_ = device_user;
  if (device_user) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.LaCrOsBrowserReport.device_user)
}
inline ::enterprise_management::DeviceUser* LaCrOsBrowserReport::release_device_user() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DeviceUser* temp = _impl_.device_user_;
  _impl_.device_user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceUser* LaCrOsBrowserReport::unsafe_arena_release_device_user() {
  // @@protoc_insertion_point(field_release:enterprise_management.LaCrOsBrowserReport.device_user)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DeviceUser* temp = _impl_.device_user_;
  _impl_.device_user_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceUser* LaCrOsBrowserReport::_internal_mutable_device_user() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.device_user_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceUser>(GetArenaForAllocation());
    _impl_.device_user_ = p;
  }
  return _impl_.device_user_;
}
inline ::enterprise_management::DeviceUser* LaCrOsBrowserReport::mutable_device_user() {
  ::enterprise_management::DeviceUser* _msg = _internal_mutable_device_user();
  // @@protoc_insertion_point(field_mutable:enterprise_management.LaCrOsBrowserReport.device_user)
  return _msg;
}
inline void LaCrOsBrowserReport::set_allocated_device_user(::enterprise_management::DeviceUser* device_user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_user_;
  }
  if (device_user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_user);
    if (message_arena != submessage_arena) {
      device_user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_user, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_user_ = device_user;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.LaCrOsBrowserReport.device_user)
}

// optional .enterprise_management.BrowserReport browser_report = 2;
inline bool LaCrOsBrowserReport::_internal_has_browser_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_report_ != nullptr);
  return value;
}
inline bool LaCrOsBrowserReport::has_browser_report() const {
  return _internal_has_browser_report();
}
inline void LaCrOsBrowserReport::clear_browser_report() {
  if (_impl_.browser_report_ != nullptr) _impl_.browser_report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::BrowserReport& LaCrOsBrowserReport::_internal_browser_report() const {
  const ::enterprise_management::BrowserReport* p = _impl_.browser_report_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserReport&>(
      ::enterprise_management::_BrowserReport_default_instance_);
}
inline const ::enterprise_management::BrowserReport& LaCrOsBrowserReport::browser_report() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LaCrOsBrowserReport.browser_report)
  return _internal_browser_report();
}
inline void LaCrOsBrowserReport::unsafe_arena_set_allocated_browser_report(
    ::enterprise_management::BrowserReport* browser_report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_report_);
  }
  _impl_.browser_report_ = browser_report;
  if (browser_report) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.LaCrOsBrowserReport.browser_report)
}
inline ::enterprise_management::BrowserReport* LaCrOsBrowserReport::release_browser_report() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::BrowserReport* temp = _impl_.browser_report_;
  _impl_.browser_report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserReport* LaCrOsBrowserReport::unsafe_arena_release_browser_report() {
  // @@protoc_insertion_point(field_release:enterprise_management.LaCrOsBrowserReport.browser_report)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::BrowserReport* temp = _impl_.browser_report_;
  _impl_.browser_report_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserReport* LaCrOsBrowserReport::_internal_mutable_browser_report() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.browser_report_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserReport>(GetArenaForAllocation());
    _impl_.browser_report_ = p;
  }
  return _impl_.browser_report_;
}
inline ::enterprise_management::BrowserReport* LaCrOsBrowserReport::mutable_browser_report() {
  ::enterprise_management::BrowserReport* _msg = _internal_mutable_browser_report();
  // @@protoc_insertion_point(field_mutable:enterprise_management.LaCrOsBrowserReport.browser_report)
  return _msg;
}
inline void LaCrOsBrowserReport::set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_report_;
  }
  if (browser_report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_report);
    if (message_arena != submessage_arena) {
      browser_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_report, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.browser_report_ = browser_report;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.LaCrOsBrowserReport.browser_report)
}

// -------------------------------------------------------------------

// DeviceStatusReportRequest

// optional string os_version = 1;
inline bool DeviceStatusReportRequest::_internal_has_os_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_os_version() const {
  return _internal_has_os_version();
}
inline void DeviceStatusReportRequest::clear_os_version() {
  _impl_.os_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceStatusReportRequest::os_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.os_version)
  return _internal_os_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStatusReportRequest::set_os_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.os_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.os_version)
}
inline std::string* DeviceStatusReportRequest::mutable_os_version() {
  std::string* _s = _internal_mutable_os_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.os_version)
  return _s;
}
inline const std::string& DeviceStatusReportRequest::_internal_os_version() const {
  return _impl_.os_version_.Get();
}
inline void DeviceStatusReportRequest::_internal_set_os_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.os_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceStatusReportRequest::_internal_mutable_os_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.os_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceStatusReportRequest::release_os_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.os_version)
  if (!_internal_has_os_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.os_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceStatusReportRequest::set_allocated_os_version(std::string* os_version) {
  if (os_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.os_version_.SetAllocated(os_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.os_version)
}

// optional string firmware_version = 2;
inline bool DeviceStatusReportRequest::_internal_has_firmware_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_firmware_version() const {
  return _internal_has_firmware_version();
}
inline void DeviceStatusReportRequest::clear_firmware_version() {
  _impl_.firmware_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceStatusReportRequest::firmware_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.firmware_version)
  return _internal_firmware_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStatusReportRequest::set_firmware_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.firmware_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.firmware_version)
}
inline std::string* DeviceStatusReportRequest::mutable_firmware_version() {
  std::string* _s = _internal_mutable_firmware_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.firmware_version)
  return _s;
}
inline const std::string& DeviceStatusReportRequest::_internal_firmware_version() const {
  return _impl_.firmware_version_.Get();
}
inline void DeviceStatusReportRequest::_internal_set_firmware_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.firmware_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceStatusReportRequest::_internal_mutable_firmware_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.firmware_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceStatusReportRequest::release_firmware_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.firmware_version)
  if (!_internal_has_firmware_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.firmware_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firmware_version_.IsDefault()) {
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceStatusReportRequest::set_allocated_firmware_version(std::string* firmware_version) {
  if (firmware_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.firmware_version_.SetAllocated(firmware_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firmware_version_.IsDefault()) {
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.firmware_version)
}

// optional string boot_mode = 3;
inline bool DeviceStatusReportRequest::_internal_has_boot_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_boot_mode() const {
  return _internal_has_boot_mode();
}
inline void DeviceStatusReportRequest::clear_boot_mode() {
  _impl_.boot_mode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceStatusReportRequest::boot_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.boot_mode)
  return _internal_boot_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStatusReportRequest::set_boot_mode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.boot_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.boot_mode)
}
inline std::string* DeviceStatusReportRequest::mutable_boot_mode() {
  std::string* _s = _internal_mutable_boot_mode();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.boot_mode)
  return _s;
}
inline const std::string& DeviceStatusReportRequest::_internal_boot_mode() const {
  return _impl_.boot_mode_.Get();
}
inline void DeviceStatusReportRequest::_internal_set_boot_mode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.boot_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceStatusReportRequest::_internal_mutable_boot_mode() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.boot_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceStatusReportRequest::release_boot_mode() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.boot_mode)
  if (!_internal_has_boot_mode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.boot_mode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boot_mode_.IsDefault()) {
    _impl_.boot_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceStatusReportRequest::set_allocated_boot_mode(std::string* boot_mode) {
  if (boot_mode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.boot_mode_.SetAllocated(boot_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boot_mode_.IsDefault()) {
    _impl_.boot_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.boot_mode)
}

// optional string browser_version = 5;
inline bool DeviceStatusReportRequest::_internal_has_browser_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_browser_version() const {
  return _internal_has_browser_version();
}
inline void DeviceStatusReportRequest::clear_browser_version() {
  _impl_.browser_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceStatusReportRequest::browser_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.browser_version)
  return _internal_browser_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStatusReportRequest::set_browser_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.browser_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.browser_version)
}
inline std::string* DeviceStatusReportRequest::mutable_browser_version() {
  std::string* _s = _internal_mutable_browser_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.browser_version)
  return _s;
}
inline const std::string& DeviceStatusReportRequest::_internal_browser_version() const {
  return _impl_.browser_version_.Get();
}
inline void DeviceStatusReportRequest::_internal_set_browser_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.browser_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceStatusReportRequest::_internal_mutable_browser_version() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.browser_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceStatusReportRequest::release_browser_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.browser_version)
  if (!_internal_has_browser_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.browser_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_version_.IsDefault()) {
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceStatusReportRequest::set_allocated_browser_version(std::string* browser_version) {
  if (browser_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.browser_version_.SetAllocated(browser_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_version_.IsDefault()) {
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.browser_version)
}

// repeated .enterprise_management.ActiveTimePeriod active_periods = 6;
inline int DeviceStatusReportRequest::_internal_active_periods_size() const {
  return _impl_.active_periods_.size();
}
inline int DeviceStatusReportRequest::active_periods_size() const {
  return _internal_active_periods_size();
}
inline void DeviceStatusReportRequest::clear_active_periods() {
  _impl_.active_periods_.Clear();
}
inline ::enterprise_management::ActiveTimePeriod* DeviceStatusReportRequest::mutable_active_periods(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.active_periods)
  return _impl_.active_periods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod >*
DeviceStatusReportRequest::mutable_active_periods() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.active_periods)
  return &_impl_.active_periods_;
}
inline const ::enterprise_management::ActiveTimePeriod& DeviceStatusReportRequest::_internal_active_periods(int index) const {
  return _impl_.active_periods_.Get(index);
}
inline const ::enterprise_management::ActiveTimePeriod& DeviceStatusReportRequest::active_periods(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.active_periods)
  return _internal_active_periods(index);
}
inline ::enterprise_management::ActiveTimePeriod* DeviceStatusReportRequest::_internal_add_active_periods() {
  return _impl_.active_periods_.Add();
}
inline ::enterprise_management::ActiveTimePeriod* DeviceStatusReportRequest::add_active_periods() {
  ::enterprise_management::ActiveTimePeriod* _add = _internal_add_active_periods();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.active_periods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ActiveTimePeriod >&
DeviceStatusReportRequest::active_periods() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.active_periods)
  return _impl_.active_periods_;
}

// repeated .enterprise_management.NetworkInterface network_interfaces = 8;
inline int DeviceStatusReportRequest::_internal_network_interfaces_size() const {
  return _impl_.network_interfaces_.size();
}
inline int DeviceStatusReportRequest::network_interfaces_size() const {
  return _internal_network_interfaces_size();
}
inline void DeviceStatusReportRequest::clear_network_interfaces() {
  _impl_.network_interfaces_.Clear();
}
inline ::enterprise_management::NetworkInterface* DeviceStatusReportRequest::mutable_network_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.network_interfaces)
  return _impl_.network_interfaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface >*
DeviceStatusReportRequest::mutable_network_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.network_interfaces)
  return &_impl_.network_interfaces_;
}
inline const ::enterprise_management::NetworkInterface& DeviceStatusReportRequest::_internal_network_interfaces(int index) const {
  return _impl_.network_interfaces_.Get(index);
}
inline const ::enterprise_management::NetworkInterface& DeviceStatusReportRequest::network_interfaces(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.network_interfaces)
  return _internal_network_interfaces(index);
}
inline ::enterprise_management::NetworkInterface* DeviceStatusReportRequest::_internal_add_network_interfaces() {
  return _impl_.network_interfaces_.Add();
}
inline ::enterprise_management::NetworkInterface* DeviceStatusReportRequest::add_network_interfaces() {
  ::enterprise_management::NetworkInterface* _add = _internal_add_network_interfaces();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.network_interfaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkInterface >&
DeviceStatusReportRequest::network_interfaces() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.network_interfaces)
  return _impl_.network_interfaces_;
}

// repeated .enterprise_management.DeviceUser users = 9;
inline int DeviceStatusReportRequest::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int DeviceStatusReportRequest::users_size() const {
  return _internal_users_size();
}
inline void DeviceStatusReportRequest::clear_users() {
  _impl_.users_.Clear();
}
inline ::enterprise_management::DeviceUser* DeviceStatusReportRequest::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser >*
DeviceStatusReportRequest::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.users)
  return &_impl_.users_;
}
inline const ::enterprise_management::DeviceUser& DeviceStatusReportRequest::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::enterprise_management::DeviceUser& DeviceStatusReportRequest::users(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.users)
  return _internal_users(index);
}
inline ::enterprise_management::DeviceUser* DeviceStatusReportRequest::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::enterprise_management::DeviceUser* DeviceStatusReportRequest::add_users() {
  ::enterprise_management::DeviceUser* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::DeviceUser >&
DeviceStatusReportRequest::users() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.users)
  return _impl_.users_;
}

// repeated .enterprise_management.VolumeInfo volume_infos = 10;
inline int DeviceStatusReportRequest::_internal_volume_infos_size() const {
  return _impl_.volume_infos_.size();
}
inline int DeviceStatusReportRequest::volume_infos_size() const {
  return _internal_volume_infos_size();
}
inline void DeviceStatusReportRequest::clear_volume_infos() {
  _impl_.volume_infos_.Clear();
}
inline ::enterprise_management::VolumeInfo* DeviceStatusReportRequest::mutable_volume_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.volume_infos)
  return _impl_.volume_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >*
DeviceStatusReportRequest::mutable_volume_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.volume_infos)
  return &_impl_.volume_infos_;
}
inline const ::enterprise_management::VolumeInfo& DeviceStatusReportRequest::_internal_volume_infos(int index) const {
  return _impl_.volume_infos_.Get(index);
}
inline const ::enterprise_management::VolumeInfo& DeviceStatusReportRequest::volume_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.volume_infos)
  return _internal_volume_infos(index);
}
inline ::enterprise_management::VolumeInfo* DeviceStatusReportRequest::_internal_add_volume_infos() {
  return _impl_.volume_infos_.Add();
}
inline ::enterprise_management::VolumeInfo* DeviceStatusReportRequest::add_volume_infos() {
  ::enterprise_management::VolumeInfo* _add = _internal_add_volume_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.volume_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >&
DeviceStatusReportRequest::volume_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.volume_infos)
  return _impl_.volume_infos_;
}

// repeated .enterprise_management.NetworkState network_states = 11;
inline int DeviceStatusReportRequest::_internal_network_states_size() const {
  return _impl_.network_states_.size();
}
inline int DeviceStatusReportRequest::network_states_size() const {
  return _internal_network_states_size();
}
inline void DeviceStatusReportRequest::clear_network_states() {
  _impl_.network_states_.Clear();
}
inline ::enterprise_management::NetworkState* DeviceStatusReportRequest::mutable_network_states(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.network_states)
  return _impl_.network_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState >*
DeviceStatusReportRequest::mutable_network_states() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.network_states)
  return &_impl_.network_states_;
}
inline const ::enterprise_management::NetworkState& DeviceStatusReportRequest::_internal_network_states(int index) const {
  return _impl_.network_states_.Get(index);
}
inline const ::enterprise_management::NetworkState& DeviceStatusReportRequest::network_states(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.network_states)
  return _internal_network_states(index);
}
inline ::enterprise_management::NetworkState* DeviceStatusReportRequest::_internal_add_network_states() {
  return _impl_.network_states_.Add();
}
inline ::enterprise_management::NetworkState* DeviceStatusReportRequest::add_network_states() {
  ::enterprise_management::NetworkState* _add = _internal_add_network_states();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.network_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkState >&
DeviceStatusReportRequest::network_states() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.network_states)
  return _impl_.network_states_;
}

// repeated int32 cpu_utilization_pct_samples = 12 [deprecated = true];
inline int DeviceStatusReportRequest::_internal_cpu_utilization_pct_samples_size() const {
  return _impl_.cpu_utilization_pct_samples_.size();
}
inline int DeviceStatusReportRequest::cpu_utilization_pct_samples_size() const {
  return _internal_cpu_utilization_pct_samples_size();
}
inline void DeviceStatusReportRequest::clear_cpu_utilization_pct_samples() {
  _impl_.cpu_utilization_pct_samples_.Clear();
}
inline int32_t DeviceStatusReportRequest::_internal_cpu_utilization_pct_samples(int index) const {
  return _impl_.cpu_utilization_pct_samples_.Get(index);
}
inline int32_t DeviceStatusReportRequest::cpu_utilization_pct_samples(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
  return _internal_cpu_utilization_pct_samples(index);
}
inline void DeviceStatusReportRequest::set_cpu_utilization_pct_samples(int index, int32_t value) {
  _impl_.cpu_utilization_pct_samples_.Set(index, value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
}
inline void DeviceStatusReportRequest::_internal_add_cpu_utilization_pct_samples(int32_t value) {
  _impl_.cpu_utilization_pct_samples_.Add(value);
}
inline void DeviceStatusReportRequest::add_cpu_utilization_pct_samples(int32_t value) {
  _internal_add_cpu_utilization_pct_samples(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DeviceStatusReportRequest::_internal_cpu_utilization_pct_samples() const {
  return _impl_.cpu_utilization_pct_samples_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DeviceStatusReportRequest::cpu_utilization_pct_samples() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
  return _internal_cpu_utilization_pct_samples();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DeviceStatusReportRequest::_internal_mutable_cpu_utilization_pct_samples() {
  return &_impl_.cpu_utilization_pct_samples_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DeviceStatusReportRequest::mutable_cpu_utilization_pct_samples() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_pct_samples)
  return _internal_mutable_cpu_utilization_pct_samples();
}

// optional int64 system_ram_total = 14;
inline bool DeviceStatusReportRequest::_internal_has_system_ram_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_system_ram_total() const {
  return _internal_has_system_ram_total();
}
inline void DeviceStatusReportRequest::clear_system_ram_total() {
  _impl_.system_ram_total_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int64_t DeviceStatusReportRequest::_internal_system_ram_total() const {
  return _impl_.system_ram_total_;
}
inline int64_t DeviceStatusReportRequest::system_ram_total() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_ram_total)
  return _internal_system_ram_total();
}
inline void DeviceStatusReportRequest::_internal_set_system_ram_total(int64_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.system_ram_total_ = value;
}
inline void DeviceStatusReportRequest::set_system_ram_total(int64_t value) {
  _internal_set_system_ram_total(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.system_ram_total)
}

// repeated int64 system_ram_free_samples = 15 [deprecated = true];
inline int DeviceStatusReportRequest::_internal_system_ram_free_samples_size() const {
  return _impl_.system_ram_free_samples_.size();
}
inline int DeviceStatusReportRequest::system_ram_free_samples_size() const {
  return _internal_system_ram_free_samples_size();
}
inline void DeviceStatusReportRequest::clear_system_ram_free_samples() {
  _impl_.system_ram_free_samples_.Clear();
}
inline int64_t DeviceStatusReportRequest::_internal_system_ram_free_samples(int index) const {
  return _impl_.system_ram_free_samples_.Get(index);
}
inline int64_t DeviceStatusReportRequest::system_ram_free_samples(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
  return _internal_system_ram_free_samples(index);
}
inline void DeviceStatusReportRequest::set_system_ram_free_samples(int index, int64_t value) {
  _impl_.system_ram_free_samples_.Set(index, value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
}
inline void DeviceStatusReportRequest::_internal_add_system_ram_free_samples(int64_t value) {
  _impl_.system_ram_free_samples_.Add(value);
}
inline void DeviceStatusReportRequest::add_system_ram_free_samples(int64_t value) {
  _internal_add_system_ram_free_samples(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DeviceStatusReportRequest::_internal_system_ram_free_samples() const {
  return _impl_.system_ram_free_samples_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DeviceStatusReportRequest::system_ram_free_samples() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
  return _internal_system_ram_free_samples();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DeviceStatusReportRequest::_internal_mutable_system_ram_free_samples() {
  return &_impl_.system_ram_free_samples_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DeviceStatusReportRequest::mutable_system_ram_free_samples() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.system_ram_free_samples)
  return _internal_mutable_system_ram_free_samples();
}

// repeated .enterprise_management.CPUTempInfo cpu_temp_infos = 16;
inline int DeviceStatusReportRequest::_internal_cpu_temp_infos_size() const {
  return _impl_.cpu_temp_infos_.size();
}
inline int DeviceStatusReportRequest::cpu_temp_infos_size() const {
  return _internal_cpu_temp_infos_size();
}
inline void DeviceStatusReportRequest::clear_cpu_temp_infos() {
  _impl_.cpu_temp_infos_.Clear();
}
inline ::enterprise_management::CPUTempInfo* DeviceStatusReportRequest::mutable_cpu_temp_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
  return _impl_.cpu_temp_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo >*
DeviceStatusReportRequest::mutable_cpu_temp_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
  return &_impl_.cpu_temp_infos_;
}
inline const ::enterprise_management::CPUTempInfo& DeviceStatusReportRequest::_internal_cpu_temp_infos(int index) const {
  return _impl_.cpu_temp_infos_.Get(index);
}
inline const ::enterprise_management::CPUTempInfo& DeviceStatusReportRequest::cpu_temp_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
  return _internal_cpu_temp_infos(index);
}
inline ::enterprise_management::CPUTempInfo* DeviceStatusReportRequest::_internal_add_cpu_temp_infos() {
  return _impl_.cpu_temp_infos_.Add();
}
inline ::enterprise_management::CPUTempInfo* DeviceStatusReportRequest::add_cpu_temp_infos() {
  ::enterprise_management::CPUTempInfo* _add = _internal_add_cpu_temp_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CPUTempInfo >&
DeviceStatusReportRequest::cpu_temp_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_temp_infos)
  return _impl_.cpu_temp_infos_;
}

// optional .enterprise_management.OsUpdateStatus os_update_status = 17;
inline bool DeviceStatusReportRequest::_internal_has_os_update_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.os_update_status_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_os_update_status() const {
  return _internal_has_os_update_status();
}
inline void DeviceStatusReportRequest::clear_os_update_status() {
  if (_impl_.os_update_status_ != nullptr) _impl_.os_update_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::OsUpdateStatus& DeviceStatusReportRequest::_internal_os_update_status() const {
  const ::enterprise_management::OsUpdateStatus* p = _impl_.os_update_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OsUpdateStatus&>(
      ::enterprise_management::_OsUpdateStatus_default_instance_);
}
inline const ::enterprise_management::OsUpdateStatus& DeviceStatusReportRequest::os_update_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.os_update_status)
  return _internal_os_update_status();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_os_update_status(
    ::enterprise_management::OsUpdateStatus* os_update_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.os_update_status_);
  }
  _impl_.os_update_status_ = os_update_status;
  if (os_update_status) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.os_update_status)
}
inline ::enterprise_management::OsUpdateStatus* DeviceStatusReportRequest::release_os_update_status() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::OsUpdateStatus* temp = _impl_.os_update_status_;
  _impl_.os_update_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OsUpdateStatus* DeviceStatusReportRequest::unsafe_arena_release_os_update_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.os_update_status)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::OsUpdateStatus* temp = _impl_.os_update_status_;
  _impl_.os_update_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::OsUpdateStatus* DeviceStatusReportRequest::_internal_mutable_os_update_status() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.os_update_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OsUpdateStatus>(GetArenaForAllocation());
    _impl_.os_update_status_ = p;
  }
  return _impl_.os_update_status_;
}
inline ::enterprise_management::OsUpdateStatus* DeviceStatusReportRequest::mutable_os_update_status() {
  ::enterprise_management::OsUpdateStatus* _msg = _internal_mutable_os_update_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.os_update_status)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_os_update_status(::enterprise_management::OsUpdateStatus* os_update_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.os_update_status_;
  }
  if (os_update_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(os_update_status);
    if (message_arena != submessage_arena) {
      os_update_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, os_update_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.os_update_status_ = os_update_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.os_update_status)
}

// optional .enterprise_management.AppStatus running_kiosk_app = 18;
inline bool DeviceStatusReportRequest::_internal_has_running_kiosk_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.running_kiosk_app_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_running_kiosk_app() const {
  return _internal_has_running_kiosk_app();
}
inline void DeviceStatusReportRequest::clear_running_kiosk_app() {
  if (_impl_.running_kiosk_app_ != nullptr) _impl_.running_kiosk_app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_management::AppStatus& DeviceStatusReportRequest::_internal_running_kiosk_app() const {
  const ::enterprise_management::AppStatus* p = _impl_.running_kiosk_app_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AppStatus&>(
      ::enterprise_management::_AppStatus_default_instance_);
}
inline const ::enterprise_management::AppStatus& DeviceStatusReportRequest::running_kiosk_app() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
  return _internal_running_kiosk_app();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_running_kiosk_app(
    ::enterprise_management::AppStatus* running_kiosk_app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.running_kiosk_app_);
  }
  _impl_.running_kiosk_app_ = running_kiosk_app;
  if (running_kiosk_app) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
}
inline ::enterprise_management::AppStatus* DeviceStatusReportRequest::release_running_kiosk_app() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::AppStatus* temp = _impl_.running_kiosk_app_;
  _impl_.running_kiosk_app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AppStatus* DeviceStatusReportRequest::unsafe_arena_release_running_kiosk_app() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::AppStatus* temp = _impl_.running_kiosk_app_;
  _impl_.running_kiosk_app_ = nullptr;
  return temp;
}
inline ::enterprise_management::AppStatus* DeviceStatusReportRequest::_internal_mutable_running_kiosk_app() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.running_kiosk_app_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AppStatus>(GetArenaForAllocation());
    _impl_.running_kiosk_app_ = p;
  }
  return _impl_.running_kiosk_app_;
}
inline ::enterprise_management::AppStatus* DeviceStatusReportRequest::mutable_running_kiosk_app() {
  ::enterprise_management::AppStatus* _msg = _internal_mutable_running_kiosk_app();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_running_kiosk_app(::enterprise_management::AppStatus* running_kiosk_app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.running_kiosk_app_;
  }
  if (running_kiosk_app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(running_kiosk_app);
    if (message_arena != submessage_arena) {
      running_kiosk_app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, running_kiosk_app, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.running_kiosk_app_ = running_kiosk_app;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.running_kiosk_app)
}

// optional int32 sound_volume = 19;
inline bool DeviceStatusReportRequest::_internal_has_sound_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_sound_volume() const {
  return _internal_has_sound_volume();
}
inline void DeviceStatusReportRequest::clear_sound_volume() {
  _impl_.sound_volume_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t DeviceStatusReportRequest::_internal_sound_volume() const {
  return _impl_.sound_volume_;
}
inline int32_t DeviceStatusReportRequest::sound_volume() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.sound_volume)
  return _internal_sound_volume();
}
inline void DeviceStatusReportRequest::_internal_set_sound_volume(int32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.sound_volume_ = value;
}
inline void DeviceStatusReportRequest::set_sound_volume(int32_t value) {
  _internal_set_sound_volume(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.sound_volume)
}

// optional .enterprise_management.TpmVersionInfo tpm_version_info = 21;
inline bool DeviceStatusReportRequest::_internal_has_tpm_version_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tpm_version_info_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_tpm_version_info() const {
  return _internal_has_tpm_version_info();
}
inline void DeviceStatusReportRequest::clear_tpm_version_info() {
  if (_impl_.tpm_version_info_ != nullptr) _impl_.tpm_version_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::TpmVersionInfo& DeviceStatusReportRequest::_internal_tpm_version_info() const {
  const ::enterprise_management::TpmVersionInfo* p = _impl_.tpm_version_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::TpmVersionInfo&>(
      ::enterprise_management::_TpmVersionInfo_default_instance_);
}
inline const ::enterprise_management::TpmVersionInfo& DeviceStatusReportRequest::tpm_version_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
  return _internal_tpm_version_info();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_tpm_version_info(
    ::enterprise_management::TpmVersionInfo* tpm_version_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tpm_version_info_);
  }
  _impl_.tpm_version_info_ = tpm_version_info;
  if (tpm_version_info) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
}
inline ::enterprise_management::TpmVersionInfo* DeviceStatusReportRequest::release_tpm_version_info() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::TpmVersionInfo* temp = _impl_.tpm_version_info_;
  _impl_.tpm_version_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::TpmVersionInfo* DeviceStatusReportRequest::unsafe_arena_release_tpm_version_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::TpmVersionInfo* temp = _impl_.tpm_version_info_;
  _impl_.tpm_version_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::TpmVersionInfo* DeviceStatusReportRequest::_internal_mutable_tpm_version_info() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.tpm_version_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::TpmVersionInfo>(GetArenaForAllocation());
    _impl_.tpm_version_info_ = p;
  }
  return _impl_.tpm_version_info_;
}
inline ::enterprise_management::TpmVersionInfo* DeviceStatusReportRequest::mutable_tpm_version_info() {
  ::enterprise_management::TpmVersionInfo* _msg = _internal_mutable_tpm_version_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_tpm_version_info(::enterprise_management::TpmVersionInfo* tpm_version_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tpm_version_info_;
  }
  if (tpm_version_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tpm_version_info);
    if (message_arena != submessage_arena) {
      tpm_version_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tpm_version_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.tpm_version_info_ = tpm_version_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.tpm_version_info)
}

// optional .enterprise_management.Channel channel = 22;
inline bool DeviceStatusReportRequest::_internal_has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_channel() const {
  return _internal_has_channel();
}
inline void DeviceStatusReportRequest::clear_channel() {
  _impl_.channel_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::enterprise_management::Channel DeviceStatusReportRequest::_internal_channel() const {
  return static_cast< ::enterprise_management::Channel >(_impl_.channel_);
}
inline ::enterprise_management::Channel DeviceStatusReportRequest::channel() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.channel)
  return _internal_channel();
}
inline void DeviceStatusReportRequest::_internal_set_channel(::enterprise_management::Channel value) {
  assert(::enterprise_management::Channel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.channel_ = value;
}
inline void DeviceStatusReportRequest::set_channel(::enterprise_management::Channel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.channel)
}

// optional .enterprise_management.TpmStatusInfo tpm_status_info = 23;
inline bool DeviceStatusReportRequest::_internal_has_tpm_status_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tpm_status_info_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_tpm_status_info() const {
  return _internal_has_tpm_status_info();
}
inline void DeviceStatusReportRequest::clear_tpm_status_info() {
  if (_impl_.tpm_status_info_ != nullptr) _impl_.tpm_status_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::enterprise_management::TpmStatusInfo& DeviceStatusReportRequest::_internal_tpm_status_info() const {
  const ::enterprise_management::TpmStatusInfo* p = _impl_.tpm_status_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::TpmStatusInfo&>(
      ::enterprise_management::_TpmStatusInfo_default_instance_);
}
inline const ::enterprise_management::TpmStatusInfo& DeviceStatusReportRequest::tpm_status_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
  return _internal_tpm_status_info();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_tpm_status_info(
    ::enterprise_management::TpmStatusInfo* tpm_status_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tpm_status_info_);
  }
  _impl_.tpm_status_info_ = tpm_status_info;
  if (tpm_status_info) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
}
inline ::enterprise_management::TpmStatusInfo* DeviceStatusReportRequest::release_tpm_status_info() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::TpmStatusInfo* temp = _impl_.tpm_status_info_;
  _impl_.tpm_status_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::TpmStatusInfo* DeviceStatusReportRequest::unsafe_arena_release_tpm_status_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::TpmStatusInfo* temp = _impl_.tpm_status_info_;
  _impl_.tpm_status_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::TpmStatusInfo* DeviceStatusReportRequest::_internal_mutable_tpm_status_info() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.tpm_status_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::TpmStatusInfo>(GetArenaForAllocation());
    _impl_.tpm_status_info_ = p;
  }
  return _impl_.tpm_status_info_;
}
inline ::enterprise_management::TpmStatusInfo* DeviceStatusReportRequest::mutable_tpm_status_info() {
  ::enterprise_management::TpmStatusInfo* _msg = _internal_mutable_tpm_status_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_tpm_status_info(::enterprise_management::TpmStatusInfo* tpm_status_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tpm_status_info_;
  }
  if (tpm_status_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tpm_status_info);
    if (message_arena != submessage_arena) {
      tpm_status_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tpm_status_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.tpm_status_info_ = tpm_status_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.tpm_status_info)
}

// optional bool write_protect_switch = 24;
inline bool DeviceStatusReportRequest::_internal_has_write_protect_switch() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_write_protect_switch() const {
  return _internal_has_write_protect_switch();
}
inline void DeviceStatusReportRequest::clear_write_protect_switch() {
  _impl_.write_protect_switch_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool DeviceStatusReportRequest::_internal_write_protect_switch() const {
  return _impl_.write_protect_switch_;
}
inline bool DeviceStatusReportRequest::write_protect_switch() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.write_protect_switch)
  return _internal_write_protect_switch();
}
inline void DeviceStatusReportRequest::_internal_set_write_protect_switch(bool value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.write_protect_switch_ = value;
}
inline void DeviceStatusReportRequest::set_write_protect_switch(bool value) {
  _internal_set_write_protect_switch(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.write_protect_switch)
}

// optional .enterprise_management.PowerStatus power_status = 25;
inline bool DeviceStatusReportRequest::_internal_has_power_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.power_status_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_power_status() const {
  return _internal_has_power_status();
}
inline void DeviceStatusReportRequest::clear_power_status() {
  if (_impl_.power_status_ != nullptr) _impl_.power_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::enterprise_management::PowerStatus& DeviceStatusReportRequest::_internal_power_status() const {
  const ::enterprise_management::PowerStatus* p = _impl_.power_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PowerStatus&>(
      ::enterprise_management::_PowerStatus_default_instance_);
}
inline const ::enterprise_management::PowerStatus& DeviceStatusReportRequest::power_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.power_status)
  return _internal_power_status();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_power_status(
    ::enterprise_management::PowerStatus* power_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.power_status_);
  }
  _impl_.power_status_ = power_status;
  if (power_status) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.power_status)
}
inline ::enterprise_management::PowerStatus* DeviceStatusReportRequest::release_power_status() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::PowerStatus* temp = _impl_.power_status_;
  _impl_.power_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PowerStatus* DeviceStatusReportRequest::unsafe_arena_release_power_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.power_status)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::PowerStatus* temp = _impl_.power_status_;
  _impl_.power_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::PowerStatus* DeviceStatusReportRequest::_internal_mutable_power_status() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.power_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PowerStatus>(GetArenaForAllocation());
    _impl_.power_status_ = p;
  }
  return _impl_.power_status_;
}
inline ::enterprise_management::PowerStatus* DeviceStatusReportRequest::mutable_power_status() {
  ::enterprise_management::PowerStatus* _msg = _internal_mutable_power_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.power_status)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_power_status(::enterprise_management::PowerStatus* power_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.power_status_;
  }
  if (power_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(power_status);
    if (message_arena != submessage_arena) {
      power_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.power_status_ = power_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.power_status)
}

// optional .enterprise_management.StorageStatus storage_status = 26;
inline bool DeviceStatusReportRequest::_internal_has_storage_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_status_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_storage_status() const {
  return _internal_has_storage_status();
}
inline void DeviceStatusReportRequest::clear_storage_status() {
  if (_impl_.storage_status_ != nullptr) _impl_.storage_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::enterprise_management::StorageStatus& DeviceStatusReportRequest::_internal_storage_status() const {
  const ::enterprise_management::StorageStatus* p = _impl_.storage_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::StorageStatus&>(
      ::enterprise_management::_StorageStatus_default_instance_);
}
inline const ::enterprise_management::StorageStatus& DeviceStatusReportRequest::storage_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.storage_status)
  return _internal_storage_status();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_storage_status(
    ::enterprise_management::StorageStatus* storage_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_status_);
  }
  _impl_.storage_status_ = storage_status;
  if (storage_status) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.storage_status)
}
inline ::enterprise_management::StorageStatus* DeviceStatusReportRequest::release_storage_status() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::StorageStatus* temp = _impl_.storage_status_;
  _impl_.storage_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::StorageStatus* DeviceStatusReportRequest::unsafe_arena_release_storage_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.storage_status)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::StorageStatus* temp = _impl_.storage_status_;
  _impl_.storage_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::StorageStatus* DeviceStatusReportRequest::_internal_mutable_storage_status() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.storage_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::StorageStatus>(GetArenaForAllocation());
    _impl_.storage_status_ = p;
  }
  return _impl_.storage_status_;
}
inline ::enterprise_management::StorageStatus* DeviceStatusReportRequest::mutable_storage_status() {
  ::enterprise_management::StorageStatus* _msg = _internal_mutable_storage_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.storage_status)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_storage_status(::enterprise_management::StorageStatus* storage_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.storage_status_;
  }
  if (storage_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(storage_status);
    if (message_arena != submessage_arena) {
      storage_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.storage_status_ = storage_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.storage_status)
}

// optional .enterprise_management.BoardStatus board_status = 27;
inline bool DeviceStatusReportRequest::_internal_has_board_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.board_status_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_board_status() const {
  return _internal_has_board_status();
}
inline void DeviceStatusReportRequest::clear_board_status() {
  if (_impl_.board_status_ != nullptr) _impl_.board_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::BoardStatus& DeviceStatusReportRequest::_internal_board_status() const {
  const ::enterprise_management::BoardStatus* p = _impl_.board_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BoardStatus&>(
      ::enterprise_management::_BoardStatus_default_instance_);
}
inline const ::enterprise_management::BoardStatus& DeviceStatusReportRequest::board_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.board_status)
  return _internal_board_status();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_board_status(
    ::enterprise_management::BoardStatus* board_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.board_status_);
  }
  _impl_.board_status_ = board_status;
  if (board_status) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.board_status)
}
inline ::enterprise_management::BoardStatus* DeviceStatusReportRequest::release_board_status() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::BoardStatus* temp = _impl_.board_status_;
  _impl_.board_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BoardStatus* DeviceStatusReportRequest::unsafe_arena_release_board_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.board_status)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::BoardStatus* temp = _impl_.board_status_;
  _impl_.board_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::BoardStatus* DeviceStatusReportRequest::_internal_mutable_board_status() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.board_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BoardStatus>(GetArenaForAllocation());
    _impl_.board_status_ = p;
  }
  return _impl_.board_status_;
}
inline ::enterprise_management::BoardStatus* DeviceStatusReportRequest::mutable_board_status() {
  ::enterprise_management::BoardStatus* _msg = _internal_mutable_board_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.board_status)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_board_status(::enterprise_management::BoardStatus* board_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.board_status_;
  }
  if (board_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(board_status);
    if (message_arena != submessage_arena) {
      board_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, board_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.board_status_ = board_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.board_status)
}

// optional .enterprise_management.SystemStatus system_status = 28;
inline bool DeviceStatusReportRequest::_internal_has_system_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_status_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_system_status() const {
  return _internal_has_system_status();
}
inline void DeviceStatusReportRequest::clear_system_status() {
  if (_impl_.system_status_ != nullptr) _impl_.system_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::SystemStatus& DeviceStatusReportRequest::_internal_system_status() const {
  const ::enterprise_management::SystemStatus* p = _impl_.system_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SystemStatus&>(
      ::enterprise_management::_SystemStatus_default_instance_);
}
inline const ::enterprise_management::SystemStatus& DeviceStatusReportRequest::system_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_status)
  return _internal_system_status();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_system_status(
    ::enterprise_management::SystemStatus* system_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_status_);
  }
  _impl_.system_status_ = system_status;
  if (system_status) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.system_status)
}
inline ::enterprise_management::SystemStatus* DeviceStatusReportRequest::release_system_status() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::SystemStatus* temp = _impl_.system_status_;
  _impl_.system_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SystemStatus* DeviceStatusReportRequest::unsafe_arena_release_system_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.system_status)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::SystemStatus* temp = _impl_.system_status_;
  _impl_.system_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::SystemStatus* DeviceStatusReportRequest::_internal_mutable_system_status() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.system_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SystemStatus>(GetArenaForAllocation());
    _impl_.system_status_ = p;
  }
  return _impl_.system_status_;
}
inline ::enterprise_management::SystemStatus* DeviceStatusReportRequest::mutable_system_status() {
  ::enterprise_management::SystemStatus* _msg = _internal_mutable_system_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.system_status)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_system_status(::enterprise_management::SystemStatus* system_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_status_;
  }
  if (system_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_status);
    if (message_arena != submessage_arena) {
      system_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.system_status_ = system_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.system_status)
}

// optional .enterprise_management.StatefulPartitionInfo stateful_partition_info = 29;
inline bool DeviceStatusReportRequest::_internal_has_stateful_partition_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stateful_partition_info_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_stateful_partition_info() const {
  return _internal_has_stateful_partition_info();
}
inline void DeviceStatusReportRequest::clear_stateful_partition_info() {
  if (_impl_.stateful_partition_info_ != nullptr) _impl_.stateful_partition_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::enterprise_management::StatefulPartitionInfo& DeviceStatusReportRequest::_internal_stateful_partition_info() const {
  const ::enterprise_management::StatefulPartitionInfo* p = _impl_.stateful_partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::StatefulPartitionInfo&>(
      ::enterprise_management::_StatefulPartitionInfo_default_instance_);
}
inline const ::enterprise_management::StatefulPartitionInfo& DeviceStatusReportRequest::stateful_partition_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
  return _internal_stateful_partition_info();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_stateful_partition_info(
    ::enterprise_management::StatefulPartitionInfo* stateful_partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stateful_partition_info_);
  }
  _impl_.stateful_partition_info_ = stateful_partition_info;
  if (stateful_partition_info) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
}
inline ::enterprise_management::StatefulPartitionInfo* DeviceStatusReportRequest::release_stateful_partition_info() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::StatefulPartitionInfo* temp = _impl_.stateful_partition_info_;
  _impl_.stateful_partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::StatefulPartitionInfo* DeviceStatusReportRequest::unsafe_arena_release_stateful_partition_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::StatefulPartitionInfo* temp = _impl_.stateful_partition_info_;
  _impl_.stateful_partition_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::StatefulPartitionInfo* DeviceStatusReportRequest::_internal_mutable_stateful_partition_info() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.stateful_partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::StatefulPartitionInfo>(GetArenaForAllocation());
    _impl_.stateful_partition_info_ = p;
  }
  return _impl_.stateful_partition_info_;
}
inline ::enterprise_management::StatefulPartitionInfo* DeviceStatusReportRequest::mutable_stateful_partition_info() {
  ::enterprise_management::StatefulPartitionInfo* _msg = _internal_mutable_stateful_partition_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_stateful_partition_info(::enterprise_management::StatefulPartitionInfo* stateful_partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stateful_partition_info_;
  }
  if (stateful_partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stateful_partition_info);
    if (message_arena != submessage_arena) {
      stateful_partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stateful_partition_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.stateful_partition_info_ = stateful_partition_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.stateful_partition_info)
}

// repeated .enterprise_management.CpuUtilizationInfo cpu_utilization_infos = 30;
inline int DeviceStatusReportRequest::_internal_cpu_utilization_infos_size() const {
  return _impl_.cpu_utilization_infos_.size();
}
inline int DeviceStatusReportRequest::cpu_utilization_infos_size() const {
  return _internal_cpu_utilization_infos_size();
}
inline void DeviceStatusReportRequest::clear_cpu_utilization_infos() {
  _impl_.cpu_utilization_infos_.Clear();
}
inline ::enterprise_management::CpuUtilizationInfo* DeviceStatusReportRequest::mutable_cpu_utilization_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
  return _impl_.cpu_utilization_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo >*
DeviceStatusReportRequest::mutable_cpu_utilization_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
  return &_impl_.cpu_utilization_infos_;
}
inline const ::enterprise_management::CpuUtilizationInfo& DeviceStatusReportRequest::_internal_cpu_utilization_infos(int index) const {
  return _impl_.cpu_utilization_infos_.Get(index);
}
inline const ::enterprise_management::CpuUtilizationInfo& DeviceStatusReportRequest::cpu_utilization_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
  return _internal_cpu_utilization_infos(index);
}
inline ::enterprise_management::CpuUtilizationInfo* DeviceStatusReportRequest::_internal_add_cpu_utilization_infos() {
  return _impl_.cpu_utilization_infos_.Add();
}
inline ::enterprise_management::CpuUtilizationInfo* DeviceStatusReportRequest::add_cpu_utilization_infos() {
  ::enterprise_management::CpuUtilizationInfo* _add = _internal_add_cpu_utilization_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuUtilizationInfo >&
DeviceStatusReportRequest::cpu_utilization_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_utilization_infos)
  return _impl_.cpu_utilization_infos_;
}

// repeated .enterprise_management.SystemFreeRamInfo system_ram_free_infos = 31;
inline int DeviceStatusReportRequest::_internal_system_ram_free_infos_size() const {
  return _impl_.system_ram_free_infos_.size();
}
inline int DeviceStatusReportRequest::system_ram_free_infos_size() const {
  return _internal_system_ram_free_infos_size();
}
inline void DeviceStatusReportRequest::clear_system_ram_free_infos() {
  _impl_.system_ram_free_infos_.Clear();
}
inline ::enterprise_management::SystemFreeRamInfo* DeviceStatusReportRequest::mutable_system_ram_free_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
  return _impl_.system_ram_free_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo >*
DeviceStatusReportRequest::mutable_system_ram_free_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
  return &_impl_.system_ram_free_infos_;
}
inline const ::enterprise_management::SystemFreeRamInfo& DeviceStatusReportRequest::_internal_system_ram_free_infos(int index) const {
  return _impl_.system_ram_free_infos_.Get(index);
}
inline const ::enterprise_management::SystemFreeRamInfo& DeviceStatusReportRequest::system_ram_free_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
  return _internal_system_ram_free_infos(index);
}
inline ::enterprise_management::SystemFreeRamInfo* DeviceStatusReportRequest::_internal_add_system_ram_free_infos() {
  return _impl_.system_ram_free_infos_.Add();
}
inline ::enterprise_management::SystemFreeRamInfo* DeviceStatusReportRequest::add_system_ram_free_infos() {
  ::enterprise_management::SystemFreeRamInfo* _add = _internal_add_system_ram_free_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SystemFreeRamInfo >&
DeviceStatusReportRequest::system_ram_free_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.system_ram_free_infos)
  return _impl_.system_ram_free_infos_;
}

// repeated .enterprise_management.CpuInfo cpu_info = 32;
inline int DeviceStatusReportRequest::_internal_cpu_info_size() const {
  return _impl_.cpu_info_.size();
}
inline int DeviceStatusReportRequest::cpu_info_size() const {
  return _internal_cpu_info_size();
}
inline void DeviceStatusReportRequest::clear_cpu_info() {
  _impl_.cpu_info_.Clear();
}
inline ::enterprise_management::CpuInfo* DeviceStatusReportRequest::mutable_cpu_info(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.cpu_info)
  return _impl_.cpu_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo >*
DeviceStatusReportRequest::mutable_cpu_info() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.cpu_info)
  return &_impl_.cpu_info_;
}
inline const ::enterprise_management::CpuInfo& DeviceStatusReportRequest::_internal_cpu_info(int index) const {
  return _impl_.cpu_info_.Get(index);
}
inline const ::enterprise_management::CpuInfo& DeviceStatusReportRequest::cpu_info(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.cpu_info)
  return _internal_cpu_info(index);
}
inline ::enterprise_management::CpuInfo* DeviceStatusReportRequest::_internal_add_cpu_info() {
  return _impl_.cpu_info_.Add();
}
inline ::enterprise_management::CpuInfo* DeviceStatusReportRequest::add_cpu_info() {
  ::enterprise_management::CpuInfo* _add = _internal_add_cpu_info();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.cpu_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CpuInfo >&
DeviceStatusReportRequest::cpu_info() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.cpu_info)
  return _impl_.cpu_info_;
}

// optional .enterprise_management.GraphicsStatus graphics_status = 33;
inline bool DeviceStatusReportRequest::_internal_has_graphics_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.graphics_status_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_graphics_status() const {
  return _internal_has_graphics_status();
}
inline void DeviceStatusReportRequest::clear_graphics_status() {
  if (_impl_.graphics_status_ != nullptr) _impl_.graphics_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::enterprise_management::GraphicsStatus& DeviceStatusReportRequest::_internal_graphics_status() const {
  const ::enterprise_management::GraphicsStatus* p = _impl_.graphics_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::GraphicsStatus&>(
      ::enterprise_management::_GraphicsStatus_default_instance_);
}
inline const ::enterprise_management::GraphicsStatus& DeviceStatusReportRequest::graphics_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.graphics_status)
  return _internal_graphics_status();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_graphics_status(
    ::enterprise_management::GraphicsStatus* graphics_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graphics_status_);
  }
  _impl_.graphics_status_ = graphics_status;
  if (graphics_status) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.graphics_status)
}
inline ::enterprise_management::GraphicsStatus* DeviceStatusReportRequest::release_graphics_status() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::GraphicsStatus* temp = _impl_.graphics_status_;
  _impl_.graphics_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::GraphicsStatus* DeviceStatusReportRequest::unsafe_arena_release_graphics_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.graphics_status)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::GraphicsStatus* temp = _impl_.graphics_status_;
  _impl_.graphics_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::GraphicsStatus* DeviceStatusReportRequest::_internal_mutable_graphics_status() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.graphics_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::GraphicsStatus>(GetArenaForAllocation());
    _impl_.graphics_status_ = p;
  }
  return _impl_.graphics_status_;
}
inline ::enterprise_management::GraphicsStatus* DeviceStatusReportRequest::mutable_graphics_status() {
  ::enterprise_management::GraphicsStatus* _msg = _internal_mutable_graphics_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.graphics_status)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_graphics_status(::enterprise_management::GraphicsStatus* graphics_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.graphics_status_;
  }
  if (graphics_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(graphics_status);
    if (message_arena != submessage_arena) {
      graphics_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graphics_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.graphics_status_ = graphics_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.graphics_status)
}

// repeated .enterprise_management.CrashReportInfo crash_report_infos = 34;
inline int DeviceStatusReportRequest::_internal_crash_report_infos_size() const {
  return _impl_.crash_report_infos_.size();
}
inline int DeviceStatusReportRequest::crash_report_infos_size() const {
  return _internal_crash_report_infos_size();
}
inline void DeviceStatusReportRequest::clear_crash_report_infos() {
  _impl_.crash_report_infos_.Clear();
}
inline ::enterprise_management::CrashReportInfo* DeviceStatusReportRequest::mutable_crash_report_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
  return _impl_.crash_report_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo >*
DeviceStatusReportRequest::mutable_crash_report_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
  return &_impl_.crash_report_infos_;
}
inline const ::enterprise_management::CrashReportInfo& DeviceStatusReportRequest::_internal_crash_report_infos(int index) const {
  return _impl_.crash_report_infos_.Get(index);
}
inline const ::enterprise_management::CrashReportInfo& DeviceStatusReportRequest::crash_report_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
  return _internal_crash_report_infos(index);
}
inline ::enterprise_management::CrashReportInfo* DeviceStatusReportRequest::_internal_add_crash_report_infos() {
  return _impl_.crash_report_infos_.Add();
}
inline ::enterprise_management::CrashReportInfo* DeviceStatusReportRequest::add_crash_report_infos() {
  ::enterprise_management::CrashReportInfo* _add = _internal_add_crash_report_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrashReportInfo >&
DeviceStatusReportRequest::crash_report_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.crash_report_infos)
  return _impl_.crash_report_infos_;
}

// optional .enterprise_management.TimezoneInfo timezone_info = 35;
inline bool DeviceStatusReportRequest::_internal_has_timezone_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timezone_info_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_timezone_info() const {
  return _internal_has_timezone_info();
}
inline void DeviceStatusReportRequest::clear_timezone_info() {
  if (_impl_.timezone_info_ != nullptr) _impl_.timezone_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::enterprise_management::TimezoneInfo& DeviceStatusReportRequest::_internal_timezone_info() const {
  const ::enterprise_management::TimezoneInfo* p = _impl_.timezone_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::TimezoneInfo&>(
      ::enterprise_management::_TimezoneInfo_default_instance_);
}
inline const ::enterprise_management::TimezoneInfo& DeviceStatusReportRequest::timezone_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.timezone_info)
  return _internal_timezone_info();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_timezone_info(
    ::enterprise_management::TimezoneInfo* timezone_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timezone_info_);
  }
  _impl_.timezone_info_ = timezone_info;
  if (timezone_info) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.timezone_info)
}
inline ::enterprise_management::TimezoneInfo* DeviceStatusReportRequest::release_timezone_info() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::TimezoneInfo* temp = _impl_.timezone_info_;
  _impl_.timezone_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::TimezoneInfo* DeviceStatusReportRequest::unsafe_arena_release_timezone_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.timezone_info)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::TimezoneInfo* temp = _impl_.timezone_info_;
  _impl_.timezone_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::TimezoneInfo* DeviceStatusReportRequest::_internal_mutable_timezone_info() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.timezone_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::TimezoneInfo>(GetArenaForAllocation());
    _impl_.timezone_info_ = p;
  }
  return _impl_.timezone_info_;
}
inline ::enterprise_management::TimezoneInfo* DeviceStatusReportRequest::mutable_timezone_info() {
  ::enterprise_management::TimezoneInfo* _msg = _internal_mutable_timezone_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.timezone_info)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_timezone_info(::enterprise_management::TimezoneInfo* timezone_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timezone_info_;
  }
  if (timezone_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timezone_info);
    if (message_arena != submessage_arena) {
      timezone_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timezone_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.timezone_info_ = timezone_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.timezone_info)
}

// optional .enterprise_management.MemoryInfo memory_info = 36;
inline bool DeviceStatusReportRequest::_internal_has_memory_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.memory_info_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_memory_info() const {
  return _internal_has_memory_info();
}
inline void DeviceStatusReportRequest::clear_memory_info() {
  if (_impl_.memory_info_ != nullptr) _impl_.memory_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::enterprise_management::MemoryInfo& DeviceStatusReportRequest::_internal_memory_info() const {
  const ::enterprise_management::MemoryInfo* p = _impl_.memory_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::MemoryInfo&>(
      ::enterprise_management::_MemoryInfo_default_instance_);
}
inline const ::enterprise_management::MemoryInfo& DeviceStatusReportRequest::memory_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.memory_info)
  return _internal_memory_info();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_memory_info(
    ::enterprise_management::MemoryInfo* memory_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.memory_info_);
  }
  _impl_.memory_info_ = memory_info;
  if (memory_info) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.memory_info)
}
inline ::enterprise_management::MemoryInfo* DeviceStatusReportRequest::release_memory_info() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::enterprise_management::MemoryInfo* temp = _impl_.memory_info_;
  _impl_.memory_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::MemoryInfo* DeviceStatusReportRequest::unsafe_arena_release_memory_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.memory_info)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::enterprise_management::MemoryInfo* temp = _impl_.memory_info_;
  _impl_.memory_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::MemoryInfo* DeviceStatusReportRequest::_internal_mutable_memory_info() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.memory_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::MemoryInfo>(GetArenaForAllocation());
    _impl_.memory_info_ = p;
  }
  return _impl_.memory_info_;
}
inline ::enterprise_management::MemoryInfo* DeviceStatusReportRequest::mutable_memory_info() {
  ::enterprise_management::MemoryInfo* _msg = _internal_mutable_memory_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.memory_info)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_memory_info(::enterprise_management::MemoryInfo* memory_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.memory_info_;
  }
  if (memory_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(memory_info);
    if (message_arena != submessage_arena) {
      memory_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, memory_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.memory_info_ = memory_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.memory_info)
}

// repeated .enterprise_management.BacklightInfo backlight_info = 37;
inline int DeviceStatusReportRequest::_internal_backlight_info_size() const {
  return _impl_.backlight_info_.size();
}
inline int DeviceStatusReportRequest::backlight_info_size() const {
  return _internal_backlight_info_size();
}
inline void DeviceStatusReportRequest::clear_backlight_info() {
  _impl_.backlight_info_.Clear();
}
inline ::enterprise_management::BacklightInfo* DeviceStatusReportRequest::mutable_backlight_info(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.backlight_info)
  return _impl_.backlight_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo >*
DeviceStatusReportRequest::mutable_backlight_info() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.backlight_info)
  return &_impl_.backlight_info_;
}
inline const ::enterprise_management::BacklightInfo& DeviceStatusReportRequest::_internal_backlight_info(int index) const {
  return _impl_.backlight_info_.Get(index);
}
inline const ::enterprise_management::BacklightInfo& DeviceStatusReportRequest::backlight_info(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.backlight_info)
  return _internal_backlight_info(index);
}
inline ::enterprise_management::BacklightInfo* DeviceStatusReportRequest::_internal_add_backlight_info() {
  return _impl_.backlight_info_.Add();
}
inline ::enterprise_management::BacklightInfo* DeviceStatusReportRequest::add_backlight_info() {
  ::enterprise_management::BacklightInfo* _add = _internal_add_backlight_info();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.backlight_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BacklightInfo >&
DeviceStatusReportRequest::backlight_info() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.backlight_info)
  return _impl_.backlight_info_;
}

// repeated .enterprise_management.FanInfo fan_info = 38;
inline int DeviceStatusReportRequest::_internal_fan_info_size() const {
  return _impl_.fan_info_.size();
}
inline int DeviceStatusReportRequest::fan_info_size() const {
  return _internal_fan_info_size();
}
inline void DeviceStatusReportRequest::clear_fan_info() {
  _impl_.fan_info_.Clear();
}
inline ::enterprise_management::FanInfo* DeviceStatusReportRequest::mutable_fan_info(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.fan_info)
  return _impl_.fan_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo >*
DeviceStatusReportRequest::mutable_fan_info() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.fan_info)
  return &_impl_.fan_info_;
}
inline const ::enterprise_management::FanInfo& DeviceStatusReportRequest::_internal_fan_info(int index) const {
  return _impl_.fan_info_.Get(index);
}
inline const ::enterprise_management::FanInfo& DeviceStatusReportRequest::fan_info(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.fan_info)
  return _internal_fan_info(index);
}
inline ::enterprise_management::FanInfo* DeviceStatusReportRequest::_internal_add_fan_info() {
  return _impl_.fan_info_.Add();
}
inline ::enterprise_management::FanInfo* DeviceStatusReportRequest::add_fan_info() {
  ::enterprise_management::FanInfo* _add = _internal_add_fan_info();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.fan_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::FanInfo >&
DeviceStatusReportRequest::fan_info() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.fan_info)
  return _impl_.fan_info_;
}

// optional .enterprise_management.GlobalCpuInfo global_cpu_info = 39;
inline bool DeviceStatusReportRequest::_internal_has_global_cpu_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.global_cpu_info_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_global_cpu_info() const {
  return _internal_has_global_cpu_info();
}
inline void DeviceStatusReportRequest::clear_global_cpu_info() {
  if (_impl_.global_cpu_info_ != nullptr) _impl_.global_cpu_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::enterprise_management::GlobalCpuInfo& DeviceStatusReportRequest::_internal_global_cpu_info() const {
  const ::enterprise_management::GlobalCpuInfo* p = _impl_.global_cpu_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::GlobalCpuInfo&>(
      ::enterprise_management::_GlobalCpuInfo_default_instance_);
}
inline const ::enterprise_management::GlobalCpuInfo& DeviceStatusReportRequest::global_cpu_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
  return _internal_global_cpu_info();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_global_cpu_info(
    ::enterprise_management::GlobalCpuInfo* global_cpu_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.global_cpu_info_);
  }
  _impl_.global_cpu_info_ = global_cpu_info;
  if (global_cpu_info) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
}
inline ::enterprise_management::GlobalCpuInfo* DeviceStatusReportRequest::release_global_cpu_info() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::enterprise_management::GlobalCpuInfo* temp = _impl_.global_cpu_info_;
  _impl_.global_cpu_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::GlobalCpuInfo* DeviceStatusReportRequest::unsafe_arena_release_global_cpu_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::enterprise_management::GlobalCpuInfo* temp = _impl_.global_cpu_info_;
  _impl_.global_cpu_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::GlobalCpuInfo* DeviceStatusReportRequest::_internal_mutable_global_cpu_info() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.global_cpu_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::GlobalCpuInfo>(GetArenaForAllocation());
    _impl_.global_cpu_info_ = p;
  }
  return _impl_.global_cpu_info_;
}
inline ::enterprise_management::GlobalCpuInfo* DeviceStatusReportRequest::mutable_global_cpu_info() {
  ::enterprise_management::GlobalCpuInfo* _msg = _internal_mutable_global_cpu_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_global_cpu_info(::enterprise_management::GlobalCpuInfo* global_cpu_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.global_cpu_info_;
  }
  if (global_cpu_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(global_cpu_info);
    if (message_arena != submessage_arena) {
      global_cpu_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, global_cpu_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.global_cpu_info_ = global_cpu_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.global_cpu_info)
}

// repeated .enterprise_management.BluetoothAdapterInfo bluetooth_adapter_info = 40;
inline int DeviceStatusReportRequest::_internal_bluetooth_adapter_info_size() const {
  return _impl_.bluetooth_adapter_info_.size();
}
inline int DeviceStatusReportRequest::bluetooth_adapter_info_size() const {
  return _internal_bluetooth_adapter_info_size();
}
inline void DeviceStatusReportRequest::clear_bluetooth_adapter_info() {
  _impl_.bluetooth_adapter_info_.Clear();
}
inline ::enterprise_management::BluetoothAdapterInfo* DeviceStatusReportRequest::mutable_bluetooth_adapter_info(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
  return _impl_.bluetooth_adapter_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo >*
DeviceStatusReportRequest::mutable_bluetooth_adapter_info() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
  return &_impl_.bluetooth_adapter_info_;
}
inline const ::enterprise_management::BluetoothAdapterInfo& DeviceStatusReportRequest::_internal_bluetooth_adapter_info(int index) const {
  return _impl_.bluetooth_adapter_info_.Get(index);
}
inline const ::enterprise_management::BluetoothAdapterInfo& DeviceStatusReportRequest::bluetooth_adapter_info(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
  return _internal_bluetooth_adapter_info(index);
}
inline ::enterprise_management::BluetoothAdapterInfo* DeviceStatusReportRequest::_internal_add_bluetooth_adapter_info() {
  return _impl_.bluetooth_adapter_info_.Add();
}
inline ::enterprise_management::BluetoothAdapterInfo* DeviceStatusReportRequest::add_bluetooth_adapter_info() {
  ::enterprise_management::BluetoothAdapterInfo* _add = _internal_add_bluetooth_adapter_info();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::BluetoothAdapterInfo >&
DeviceStatusReportRequest::bluetooth_adapter_info() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.bluetooth_adapter_info)
  return _impl_.bluetooth_adapter_info_;
}

// optional .enterprise_management.SmbiosInfo smbios_info = 41;
inline bool DeviceStatusReportRequest::_internal_has_smbios_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.smbios_info_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_smbios_info() const {
  return _internal_has_smbios_info();
}
inline void DeviceStatusReportRequest::clear_smbios_info() {
  if (_impl_.smbios_info_ != nullptr) _impl_.smbios_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::enterprise_management::SmbiosInfo& DeviceStatusReportRequest::_internal_smbios_info() const {
  const ::enterprise_management::SmbiosInfo* p = _impl_.smbios_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SmbiosInfo&>(
      ::enterprise_management::_SmbiosInfo_default_instance_);
}
inline const ::enterprise_management::SmbiosInfo& DeviceStatusReportRequest::smbios_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.smbios_info)
  return _internal_smbios_info();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_smbios_info(
    ::enterprise_management::SmbiosInfo* smbios_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.smbios_info_);
  }
  _impl_.smbios_info_ = smbios_info;
  if (smbios_info) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.smbios_info)
}
inline ::enterprise_management::SmbiosInfo* DeviceStatusReportRequest::release_smbios_info() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::enterprise_management::SmbiosInfo* temp = _impl_.smbios_info_;
  _impl_.smbios_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SmbiosInfo* DeviceStatusReportRequest::unsafe_arena_release_smbios_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.smbios_info)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::enterprise_management::SmbiosInfo* temp = _impl_.smbios_info_;
  _impl_.smbios_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::SmbiosInfo* DeviceStatusReportRequest::_internal_mutable_smbios_info() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.smbios_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SmbiosInfo>(GetArenaForAllocation());
    _impl_.smbios_info_ = p;
  }
  return _impl_.smbios_info_;
}
inline ::enterprise_management::SmbiosInfo* DeviceStatusReportRequest::mutable_smbios_info() {
  ::enterprise_management::SmbiosInfo* _msg = _internal_mutable_smbios_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.smbios_info)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_smbios_info(::enterprise_management::SmbiosInfo* smbios_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.smbios_info_;
  }
  if (smbios_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(smbios_info);
    if (message_arena != submessage_arena) {
      smbios_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smbios_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.smbios_info_ = smbios_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.smbios_info)
}

// optional .enterprise_management.KernelParameters kernel_parameters = 42;
inline bool DeviceStatusReportRequest::_internal_has_kernel_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kernel_parameters_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_kernel_parameters() const {
  return _internal_has_kernel_parameters();
}
inline void DeviceStatusReportRequest::clear_kernel_parameters() {
  if (_impl_.kernel_parameters_ != nullptr) _impl_.kernel_parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::enterprise_management::KernelParameters& DeviceStatusReportRequest::_internal_kernel_parameters() const {
  const ::enterprise_management::KernelParameters* p = _impl_.kernel_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::KernelParameters&>(
      ::enterprise_management::_KernelParameters_default_instance_);
}
inline const ::enterprise_management::KernelParameters& DeviceStatusReportRequest::kernel_parameters() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.kernel_parameters)
  return _internal_kernel_parameters();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_kernel_parameters(
    ::enterprise_management::KernelParameters* kernel_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kernel_parameters_);
  }
  _impl_.kernel_parameters_ = kernel_parameters;
  if (kernel_parameters) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.kernel_parameters)
}
inline ::enterprise_management::KernelParameters* DeviceStatusReportRequest::release_kernel_parameters() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::enterprise_management::KernelParameters* temp = _impl_.kernel_parameters_;
  _impl_.kernel_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::KernelParameters* DeviceStatusReportRequest::unsafe_arena_release_kernel_parameters() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.kernel_parameters)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::enterprise_management::KernelParameters* temp = _impl_.kernel_parameters_;
  _impl_.kernel_parameters_ = nullptr;
  return temp;
}
inline ::enterprise_management::KernelParameters* DeviceStatusReportRequest::_internal_mutable_kernel_parameters() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.kernel_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::KernelParameters>(GetArenaForAllocation());
    _impl_.kernel_parameters_ = p;
  }
  return _impl_.kernel_parameters_;
}
inline ::enterprise_management::KernelParameters* DeviceStatusReportRequest::mutable_kernel_parameters() {
  ::enterprise_management::KernelParameters* _msg = _internal_mutable_kernel_parameters();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.kernel_parameters)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_kernel_parameters(::enterprise_management::KernelParameters* kernel_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.kernel_parameters_;
  }
  if (kernel_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kernel_parameters);
    if (message_arena != submessage_arena) {
      kernel_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kernel_parameters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.kernel_parameters_ = kernel_parameters;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.kernel_parameters)
}

// optional .enterprise_management.EFIVars efi_vars = 43;
inline bool DeviceStatusReportRequest::_internal_has_efi_vars() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.efi_vars_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_efi_vars() const {
  return _internal_has_efi_vars();
}
inline void DeviceStatusReportRequest::clear_efi_vars() {
  if (_impl_.efi_vars_ != nullptr) _impl_.efi_vars_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::enterprise_management::EFIVars& DeviceStatusReportRequest::_internal_efi_vars() const {
  const ::enterprise_management::EFIVars* p = _impl_.efi_vars_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::EFIVars&>(
      ::enterprise_management::_EFIVars_default_instance_);
}
inline const ::enterprise_management::EFIVars& DeviceStatusReportRequest::efi_vars() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.efi_vars)
  return _internal_efi_vars();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_efi_vars(
    ::enterprise_management::EFIVars* efi_vars) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.efi_vars_);
  }
  _impl_.efi_vars_ = efi_vars;
  if (efi_vars) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.efi_vars)
}
inline ::enterprise_management::EFIVars* DeviceStatusReportRequest::release_efi_vars() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::enterprise_management::EFIVars* temp = _impl_.efi_vars_;
  _impl_.efi_vars_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::EFIVars* DeviceStatusReportRequest::unsafe_arena_release_efi_vars() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.efi_vars)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::enterprise_management::EFIVars* temp = _impl_.efi_vars_;
  _impl_.efi_vars_ = nullptr;
  return temp;
}
inline ::enterprise_management::EFIVars* DeviceStatusReportRequest::_internal_mutable_efi_vars() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.efi_vars_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::EFIVars>(GetArenaForAllocation());
    _impl_.efi_vars_ = p;
  }
  return _impl_.efi_vars_;
}
inline ::enterprise_management::EFIVars* DeviceStatusReportRequest::mutable_efi_vars() {
  ::enterprise_management::EFIVars* _msg = _internal_mutable_efi_vars();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.efi_vars)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_efi_vars(::enterprise_management::EFIVars* efi_vars) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.efi_vars_;
  }
  if (efi_vars) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(efi_vars);
    if (message_arena != submessage_arena) {
      efi_vars = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, efi_vars, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.efi_vars_ = efi_vars;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.efi_vars)
}

// optional .enterprise_management.BootInfo boot_info = 44;
inline bool DeviceStatusReportRequest::_internal_has_boot_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.boot_info_ != nullptr);
  return value;
}
inline bool DeviceStatusReportRequest::has_boot_info() const {
  return _internal_has_boot_info();
}
inline void DeviceStatusReportRequest::clear_boot_info() {
  if (_impl_.boot_info_ != nullptr) _impl_.boot_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::enterprise_management::BootInfo& DeviceStatusReportRequest::_internal_boot_info() const {
  const ::enterprise_management::BootInfo* p = _impl_.boot_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BootInfo&>(
      ::enterprise_management::_BootInfo_default_instance_);
}
inline const ::enterprise_management::BootInfo& DeviceStatusReportRequest::boot_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.boot_info)
  return _internal_boot_info();
}
inline void DeviceStatusReportRequest::unsafe_arena_set_allocated_boot_info(
    ::enterprise_management::BootInfo* boot_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.boot_info_);
  }
  _impl_.boot_info_ = boot_info;
  if (boot_info) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStatusReportRequest.boot_info)
}
inline ::enterprise_management::BootInfo* DeviceStatusReportRequest::release_boot_info() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::enterprise_management::BootInfo* temp = _impl_.boot_info_;
  _impl_.boot_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BootInfo* DeviceStatusReportRequest::unsafe_arena_release_boot_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportRequest.boot_info)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::enterprise_management::BootInfo* temp = _impl_.boot_info_;
  _impl_.boot_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::BootInfo* DeviceStatusReportRequest::_internal_mutable_boot_info() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.boot_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BootInfo>(GetArenaForAllocation());
    _impl_.boot_info_ = p;
  }
  return _impl_.boot_info_;
}
inline ::enterprise_management::BootInfo* DeviceStatusReportRequest::mutable_boot_info() {
  ::enterprise_management::BootInfo* _msg = _internal_mutable_boot_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.boot_info)
  return _msg;
}
inline void DeviceStatusReportRequest::set_allocated_boot_info(::enterprise_management::BootInfo* boot_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.boot_info_;
  }
  if (boot_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boot_info);
    if (message_arena != submessage_arena) {
      boot_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boot_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.boot_info_ = boot_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportRequest.boot_info)
}

// repeated .enterprise_management.NetworkAdapterInfo network_adapter_info = 45;
inline int DeviceStatusReportRequest::_internal_network_adapter_info_size() const {
  return _impl_.network_adapter_info_.size();
}
inline int DeviceStatusReportRequest::network_adapter_info_size() const {
  return _internal_network_adapter_info_size();
}
inline void DeviceStatusReportRequest::clear_network_adapter_info() {
  _impl_.network_adapter_info_.Clear();
}
inline ::enterprise_management::NetworkAdapterInfo* DeviceStatusReportRequest::mutable_network_adapter_info(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.network_adapter_info)
  return _impl_.network_adapter_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkAdapterInfo >*
DeviceStatusReportRequest::mutable_network_adapter_info() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.network_adapter_info)
  return &_impl_.network_adapter_info_;
}
inline const ::enterprise_management::NetworkAdapterInfo& DeviceStatusReportRequest::_internal_network_adapter_info(int index) const {
  return _impl_.network_adapter_info_.Get(index);
}
inline const ::enterprise_management::NetworkAdapterInfo& DeviceStatusReportRequest::network_adapter_info(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.network_adapter_info)
  return _internal_network_adapter_info(index);
}
inline ::enterprise_management::NetworkAdapterInfo* DeviceStatusReportRequest::_internal_add_network_adapter_info() {
  return _impl_.network_adapter_info_.Add();
}
inline ::enterprise_management::NetworkAdapterInfo* DeviceStatusReportRequest::add_network_adapter_info() {
  ::enterprise_management::NetworkAdapterInfo* _add = _internal_add_network_adapter_info();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.network_adapter_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::NetworkAdapterInfo >&
DeviceStatusReportRequest::network_adapter_info() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.network_adapter_info)
  return _impl_.network_adapter_info_;
}

// repeated .enterprise_management.LaCrOsBrowserReport lacros_browser_report = 46;
inline int DeviceStatusReportRequest::_internal_lacros_browser_report_size() const {
  return _impl_.lacros_browser_report_.size();
}
inline int DeviceStatusReportRequest::lacros_browser_report_size() const {
  return _internal_lacros_browser_report_size();
}
inline void DeviceStatusReportRequest::clear_lacros_browser_report() {
  _impl_.lacros_browser_report_.Clear();
}
inline ::enterprise_management::LaCrOsBrowserReport* DeviceStatusReportRequest::mutable_lacros_browser_report(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportRequest.lacros_browser_report)
  return _impl_.lacros_browser_report_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LaCrOsBrowserReport >*
DeviceStatusReportRequest::mutable_lacros_browser_report() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStatusReportRequest.lacros_browser_report)
  return &_impl_.lacros_browser_report_;
}
inline const ::enterprise_management::LaCrOsBrowserReport& DeviceStatusReportRequest::_internal_lacros_browser_report(int index) const {
  return _impl_.lacros_browser_report_.Get(index);
}
inline const ::enterprise_management::LaCrOsBrowserReport& DeviceStatusReportRequest::lacros_browser_report(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.lacros_browser_report)
  return _internal_lacros_browser_report(index);
}
inline ::enterprise_management::LaCrOsBrowserReport* DeviceStatusReportRequest::_internal_add_lacros_browser_report() {
  return _impl_.lacros_browser_report_.Add();
}
inline ::enterprise_management::LaCrOsBrowserReport* DeviceStatusReportRequest::add_lacros_browser_report() {
  ::enterprise_management::LaCrOsBrowserReport* _add = _internal_add_lacros_browser_report();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStatusReportRequest.lacros_browser_report)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LaCrOsBrowserReport >&
DeviceStatusReportRequest::lacros_browser_report() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStatusReportRequest.lacros_browser_report)
  return _impl_.lacros_browser_report_;
}

// optional int64 root_device_total_storage_bytes = 47;
inline bool DeviceStatusReportRequest::_internal_has_root_device_total_storage_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool DeviceStatusReportRequest::has_root_device_total_storage_bytes() const {
  return _internal_has_root_device_total_storage_bytes();
}
inline void DeviceStatusReportRequest::clear_root_device_total_storage_bytes() {
  _impl_.root_device_total_storage_bytes_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline int64_t DeviceStatusReportRequest::_internal_root_device_total_storage_bytes() const {
  return _impl_.root_device_total_storage_bytes_;
}
inline int64_t DeviceStatusReportRequest::root_device_total_storage_bytes() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportRequest.root_device_total_storage_bytes)
  return _internal_root_device_total_storage_bytes();
}
inline void DeviceStatusReportRequest::_internal_set_root_device_total_storage_bytes(int64_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.root_device_total_storage_bytes_ = value;
}
inline void DeviceStatusReportRequest::set_root_device_total_storage_bytes(int64_t value) {
  _internal_set_root_device_total_storage_bytes(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportRequest.root_device_total_storage_bytes)
}

// -------------------------------------------------------------------

// OsUpdateStatus

// optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
inline bool OsUpdateStatus::_internal_has_update_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OsUpdateStatus::has_update_status() const {
  return _internal_has_update_status();
}
inline void OsUpdateStatus::clear_update_status() {
  _impl_.update_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::OsUpdateStatus_UpdateStatus OsUpdateStatus::_internal_update_status() const {
  return static_cast< ::enterprise_management::OsUpdateStatus_UpdateStatus >(_impl_.update_status_);
}
inline ::enterprise_management::OsUpdateStatus_UpdateStatus OsUpdateStatus::update_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.update_status)
  return _internal_update_status();
}
inline void OsUpdateStatus::_internal_set_update_status(::enterprise_management::OsUpdateStatus_UpdateStatus value) {
  assert(::enterprise_management::OsUpdateStatus_UpdateStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.update_status_ = value;
}
inline void OsUpdateStatus::set_update_status(::enterprise_management::OsUpdateStatus_UpdateStatus value) {
  _internal_set_update_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.update_status)
}

// optional string new_platform_version = 2;
inline bool OsUpdateStatus::_internal_has_new_platform_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OsUpdateStatus::has_new_platform_version() const {
  return _internal_has_new_platform_version();
}
inline void OsUpdateStatus::clear_new_platform_version() {
  _impl_.new_platform_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OsUpdateStatus::new_platform_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.new_platform_version)
  return _internal_new_platform_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OsUpdateStatus::set_new_platform_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_platform_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.new_platform_version)
}
inline std::string* OsUpdateStatus::mutable_new_platform_version() {
  std::string* _s = _internal_mutable_new_platform_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OsUpdateStatus.new_platform_version)
  return _s;
}
inline const std::string& OsUpdateStatus::_internal_new_platform_version() const {
  return _impl_.new_platform_version_.Get();
}
inline void OsUpdateStatus::_internal_set_new_platform_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_platform_version_.Set(value, GetArenaForAllocation());
}
inline std::string* OsUpdateStatus::_internal_mutable_new_platform_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_platform_version_.Mutable(GetArenaForAllocation());
}
inline std::string* OsUpdateStatus::release_new_platform_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.OsUpdateStatus.new_platform_version)
  if (!_internal_has_new_platform_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_platform_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_platform_version_.IsDefault()) {
    _impl_.new_platform_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OsUpdateStatus::set_allocated_new_platform_version(std::string* new_platform_version) {
  if (new_platform_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_platform_version_.SetAllocated(new_platform_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_platform_version_.IsDefault()) {
    _impl_.new_platform_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OsUpdateStatus.new_platform_version)
}

// optional string new_required_platform_version = 3;
inline bool OsUpdateStatus::_internal_has_new_required_platform_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OsUpdateStatus::has_new_required_platform_version() const {
  return _internal_has_new_required_platform_version();
}
inline void OsUpdateStatus::clear_new_required_platform_version() {
  _impl_.new_required_platform_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OsUpdateStatus::new_required_platform_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.new_required_platform_version)
  return _internal_new_required_platform_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OsUpdateStatus::set_new_required_platform_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.new_required_platform_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.new_required_platform_version)
}
inline std::string* OsUpdateStatus::mutable_new_required_platform_version() {
  std::string* _s = _internal_mutable_new_required_platform_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OsUpdateStatus.new_required_platform_version)
  return _s;
}
inline const std::string& OsUpdateStatus::_internal_new_required_platform_version() const {
  return _impl_.new_required_platform_version_.Get();
}
inline void OsUpdateStatus::_internal_set_new_required_platform_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.new_required_platform_version_.Set(value, GetArenaForAllocation());
}
inline std::string* OsUpdateStatus::_internal_mutable_new_required_platform_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.new_required_platform_version_.Mutable(GetArenaForAllocation());
}
inline std::string* OsUpdateStatus::release_new_required_platform_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.OsUpdateStatus.new_required_platform_version)
  if (!_internal_has_new_required_platform_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.new_required_platform_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_required_platform_version_.IsDefault()) {
    _impl_.new_required_platform_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OsUpdateStatus::set_allocated_new_required_platform_version(std::string* new_required_platform_version) {
  if (new_required_platform_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.new_required_platform_version_.SetAllocated(new_required_platform_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_required_platform_version_.IsDefault()) {
    _impl_.new_required_platform_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OsUpdateStatus.new_required_platform_version)
}

// optional int64 last_checked_timestamp = 4;
inline bool OsUpdateStatus::_internal_has_last_checked_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OsUpdateStatus::has_last_checked_timestamp() const {
  return _internal_has_last_checked_timestamp();
}
inline void OsUpdateStatus::clear_last_checked_timestamp() {
  _impl_.last_checked_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t OsUpdateStatus::_internal_last_checked_timestamp() const {
  return _impl_.last_checked_timestamp_;
}
inline int64_t OsUpdateStatus::last_checked_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.last_checked_timestamp)
  return _internal_last_checked_timestamp();
}
inline void OsUpdateStatus::_internal_set_last_checked_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.last_checked_timestamp_ = value;
}
inline void OsUpdateStatus::set_last_checked_timestamp(int64_t value) {
  _internal_set_last_checked_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.last_checked_timestamp)
}

// optional int64 last_reboot_timestamp = 5;
inline bool OsUpdateStatus::_internal_has_last_reboot_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OsUpdateStatus::has_last_reboot_timestamp() const {
  return _internal_has_last_reboot_timestamp();
}
inline void OsUpdateStatus::clear_last_reboot_timestamp() {
  _impl_.last_reboot_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t OsUpdateStatus::_internal_last_reboot_timestamp() const {
  return _impl_.last_reboot_timestamp_;
}
inline int64_t OsUpdateStatus::last_reboot_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OsUpdateStatus.last_reboot_timestamp)
  return _internal_last_reboot_timestamp();
}
inline void OsUpdateStatus::_internal_set_last_reboot_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_reboot_timestamp_ = value;
}
inline void OsUpdateStatus::set_last_reboot_timestamp(int64_t value) {
  _internal_set_last_reboot_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OsUpdateStatus.last_reboot_timestamp)
}

// -------------------------------------------------------------------

// AppStatus

// optional string app_id = 1;
inline bool AppStatus::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppStatus::has_app_id() const {
  return _internal_has_app_id();
}
inline void AppStatus::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppStatus::app_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppStatus::set_app_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.app_id)
}
inline std::string* AppStatus::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.app_id)
  return _s;
}
inline const std::string& AppStatus::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void AppStatus::_internal_set_app_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppStatus::_internal_mutable_app_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppStatus::release_app_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppStatus.app_id)
  if (!_internal_has_app_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppStatus::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.app_id)
}

// optional string extension_version = 2;
inline bool AppStatus::_internal_has_extension_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppStatus::has_extension_version() const {
  return _internal_has_extension_version();
}
inline void AppStatus::clear_extension_version() {
  _impl_.extension_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppStatus::extension_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.extension_version)
  return _internal_extension_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppStatus::set_extension_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.extension_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.extension_version)
}
inline std::string* AppStatus::mutable_extension_version() {
  std::string* _s = _internal_mutable_extension_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.extension_version)
  return _s;
}
inline const std::string& AppStatus::_internal_extension_version() const {
  return _impl_.extension_version_.Get();
}
inline void AppStatus::_internal_set_extension_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.extension_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AppStatus::_internal_mutable_extension_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.extension_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AppStatus::release_extension_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppStatus.extension_version)
  if (!_internal_has_extension_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.extension_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_version_.IsDefault()) {
    _impl_.extension_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppStatus::set_allocated_extension_version(std::string* extension_version) {
  if (extension_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.extension_version_.SetAllocated(extension_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_version_.IsDefault()) {
    _impl_.extension_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.extension_version)
}

// optional string status = 3;
inline bool AppStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AppStatus::has_status() const {
  return _internal_has_status();
}
inline void AppStatus::clear_status() {
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AppStatus::status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppStatus::set_status(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.status)
}
inline std::string* AppStatus::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.status)
  return _s;
}
inline const std::string& AppStatus::_internal_status() const {
  return _impl_.status_.Get();
}
inline void AppStatus::_internal_set_status(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* AppStatus::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* AppStatus::release_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppStatus.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.status_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppStatus::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.status)
}

// optional bool error = 4;
inline bool AppStatus::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AppStatus::has_error() const {
  return _internal_has_error();
}
inline void AppStatus::clear_error() {
  _impl_.error_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool AppStatus::_internal_error() const {
  return _impl_.error_;
}
inline bool AppStatus::error() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.error)
  return _internal_error();
}
inline void AppStatus::_internal_set_error(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}
inline void AppStatus::set_error(bool value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.error)
}

// optional string required_platform_version = 5;
inline bool AppStatus::_internal_has_required_platform_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AppStatus::has_required_platform_version() const {
  return _internal_has_required_platform_version();
}
inline void AppStatus::clear_required_platform_version() {
  _impl_.required_platform_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AppStatus::required_platform_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppStatus.required_platform_version)
  return _internal_required_platform_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppStatus::set_required_platform_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.required_platform_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppStatus.required_platform_version)
}
inline std::string* AppStatus::mutable_required_platform_version() {
  std::string* _s = _internal_mutable_required_platform_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppStatus.required_platform_version)
  return _s;
}
inline const std::string& AppStatus::_internal_required_platform_version() const {
  return _impl_.required_platform_version_.Get();
}
inline void AppStatus::_internal_set_required_platform_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.required_platform_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AppStatus::_internal_mutable_required_platform_version() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.required_platform_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AppStatus::release_required_platform_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppStatus.required_platform_version)
  if (!_internal_has_required_platform_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.required_platform_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.required_platform_version_.IsDefault()) {
    _impl_.required_platform_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppStatus::set_allocated_required_platform_version(std::string* required_platform_version) {
  if (required_platform_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.required_platform_version_.SetAllocated(required_platform_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.required_platform_version_.IsDefault()) {
    _impl_.required_platform_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppStatus.required_platform_version)
}

// -------------------------------------------------------------------

// AppInfo

// optional string app_id = 1;
inline bool AppInfo::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppInfo::has_app_id() const {
  return _internal_has_app_id();
}
inline void AppInfo::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInfo::app_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInfo.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_app_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppInfo.app_id)
}
inline std::string* AppInfo::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppInfo.app_id)
  return _s;
}
inline const std::string& AppInfo::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void AppInfo::_internal_set_app_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_app_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppInfo::release_app_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppInfo.app_id)
  if (!_internal_has_app_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppInfo::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInfo.app_id)
}

// optional .enterprise_management.AppInfo.AppType app_type = 2;
inline bool AppInfo::_internal_has_app_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AppInfo::has_app_type() const {
  return _internal_has_app_type();
}
inline void AppInfo::clear_app_type() {
  _impl_.app_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::AppInfo_AppType AppInfo::_internal_app_type() const {
  return static_cast< ::enterprise_management::AppInfo_AppType >(_impl_.app_type_);
}
inline ::enterprise_management::AppInfo_AppType AppInfo::app_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInfo.app_type)
  return _internal_app_type();
}
inline void AppInfo::_internal_set_app_type(::enterprise_management::AppInfo_AppType value) {
  assert(::enterprise_management::AppInfo_AppType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.app_type_ = value;
}
inline void AppInfo::set_app_type(::enterprise_management::AppInfo_AppType value) {
  _internal_set_app_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInfo.app_type)
}

// optional string app_name = 3;
inline bool AppInfo::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppInfo::has_app_name() const {
  return _internal_has_app_name();
}
inline void AppInfo::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppInfo::app_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInfo.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppInfo.app_name)
}
inline std::string* AppInfo::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppInfo.app_name)
  return _s;
}
inline const std::string& AppInfo::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void AppInfo::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AppInfo::release_app_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppInfo.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppInfo::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInfo.app_name)
}

// optional .enterprise_management.AppInfo.Status status = 4;
inline bool AppInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AppInfo::has_status() const {
  return _internal_has_status();
}
inline void AppInfo::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::AppInfo_Status AppInfo::_internal_status() const {
  return static_cast< ::enterprise_management::AppInfo_Status >(_impl_.status_);
}
inline ::enterprise_management::AppInfo_Status AppInfo::status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInfo.status)
  return _internal_status();
}
inline void AppInfo::_internal_set_status(::enterprise_management::AppInfo_Status value) {
  assert(::enterprise_management::AppInfo_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_ = value;
}
inline void AppInfo::set_status(::enterprise_management::AppInfo_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInfo.status)
}

// optional int64 install_time = 5;
inline bool AppInfo::_internal_has_install_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AppInfo::has_install_time() const {
  return _internal_has_install_time();
}
inline void AppInfo::clear_install_time() {
  _impl_.install_time_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t AppInfo::_internal_install_time() const {
  return _impl_.install_time_;
}
inline int64_t AppInfo::install_time() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInfo.install_time)
  return _internal_install_time();
}
inline void AppInfo::_internal_set_install_time(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.install_time_ = value;
}
inline void AppInfo::set_install_time(int64_t value) {
  _internal_set_install_time(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInfo.install_time)
}

// optional string version = 7;
inline bool AppInfo::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AppInfo::has_version() const {
  return _internal_has_version();
}
inline void AppInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AppInfo::version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppInfo.version)
}
inline std::string* AppInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppInfo.version)
  return _s;
}
inline const std::string& AppInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void AppInfo::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* AppInfo::release_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppInfo.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInfo.version)
}

// repeated .enterprise_management.TimePeriod active_time_periods = 8;
inline int AppInfo::_internal_active_time_periods_size() const {
  return _impl_.active_time_periods_.size();
}
inline int AppInfo::active_time_periods_size() const {
  return _internal_active_time_periods_size();
}
inline void AppInfo::clear_active_time_periods() {
  _impl_.active_time_periods_.Clear();
}
inline ::enterprise_management::TimePeriod* AppInfo::mutable_active_time_periods(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppInfo.active_time_periods)
  return _impl_.active_time_periods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >*
AppInfo::mutable_active_time_periods() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.AppInfo.active_time_periods)
  return &_impl_.active_time_periods_;
}
inline const ::enterprise_management::TimePeriod& AppInfo::_internal_active_time_periods(int index) const {
  return _impl_.active_time_periods_.Get(index);
}
inline const ::enterprise_management::TimePeriod& AppInfo::active_time_periods(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInfo.active_time_periods)
  return _internal_active_time_periods(index);
}
inline ::enterprise_management::TimePeriod* AppInfo::_internal_add_active_time_periods() {
  return _impl_.active_time_periods_.Add();
}
inline ::enterprise_management::TimePeriod* AppInfo::add_active_time_periods() {
  ::enterprise_management::TimePeriod* _add = _internal_add_active_time_periods();
  // @@protoc_insertion_point(field_add:enterprise_management.AppInfo.active_time_periods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >&
AppInfo::active_time_periods() const {
  // @@protoc_insertion_point(field_list:enterprise_management.AppInfo.active_time_periods)
  return _impl_.active_time_periods_;
}

// -------------------------------------------------------------------

// AndroidAppPermission

// optional string name = 1;
inline bool AndroidAppPermission::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AndroidAppPermission::has_name() const {
  return _internal_has_name();
}
inline void AndroidAppPermission::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AndroidAppPermission::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppPermission.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidAppPermission::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppPermission.name)
}
inline std::string* AndroidAppPermission::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppPermission.name)
  return _s;
}
inline const std::string& AndroidAppPermission::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AndroidAppPermission::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidAppPermission::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidAppPermission::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidAppPermission.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidAppPermission::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidAppPermission.name)
}

// optional bool granted = 2;
inline bool AndroidAppPermission::_internal_has_granted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AndroidAppPermission::has_granted() const {
  return _internal_has_granted();
}
inline void AndroidAppPermission::clear_granted() {
  _impl_.granted_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AndroidAppPermission::_internal_granted() const {
  return _impl_.granted_;
}
inline bool AndroidAppPermission::granted() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppPermission.granted)
  return _internal_granted();
}
inline void AndroidAppPermission::_internal_set_granted(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.granted_ = value;
}
inline void AndroidAppPermission::set_granted(bool value) {
  _internal_set_granted(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppPermission.granted)
}

// optional bool managed = 3;
inline bool AndroidAppPermission::_internal_has_managed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AndroidAppPermission::has_managed() const {
  return _internal_has_managed();
}
inline void AndroidAppPermission::clear_managed() {
  _impl_.managed_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool AndroidAppPermission::_internal_managed() const {
  return _impl_.managed_;
}
inline bool AndroidAppPermission::managed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppPermission.managed)
  return _internal_managed();
}
inline void AndroidAppPermission::_internal_set_managed(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.managed_ = value;
}
inline void AndroidAppPermission::set_managed(bool value) {
  _internal_set_managed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppPermission.managed)
}

// -------------------------------------------------------------------

// AndroidAppInfo

// optional string app_id = 1;
inline bool AndroidAppInfo::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AndroidAppInfo::has_app_id() const {
  return _internal_has_app_id();
}
inline void AndroidAppInfo::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AndroidAppInfo::app_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidAppInfo::set_app_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.app_id)
}
inline std::string* AndroidAppInfo::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppInfo.app_id)
  return _s;
}
inline const std::string& AndroidAppInfo::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void AndroidAppInfo::_internal_set_app_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidAppInfo::_internal_mutable_app_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidAppInfo::release_app_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidAppInfo.app_id)
  if (!_internal_has_app_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidAppInfo::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidAppInfo.app_id)
}

// optional string app_name = 2;
inline bool AndroidAppInfo::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AndroidAppInfo::has_app_name() const {
  return _internal_has_app_name();
}
inline void AndroidAppInfo::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AndroidAppInfo::app_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidAppInfo::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.app_name)
}
inline std::string* AndroidAppInfo::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppInfo.app_name)
  return _s;
}
inline const std::string& AndroidAppInfo::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void AndroidAppInfo::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidAppInfo::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidAppInfo::release_app_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidAppInfo.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidAppInfo::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidAppInfo.app_name)
}

// optional string package_name = 3;
inline bool AndroidAppInfo::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AndroidAppInfo::has_package_name() const {
  return _internal_has_package_name();
}
inline void AndroidAppInfo::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AndroidAppInfo::package_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidAppInfo::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.package_name)
}
inline std::string* AndroidAppInfo::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppInfo.package_name)
  return _s;
}
inline const std::string& AndroidAppInfo::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void AndroidAppInfo::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidAppInfo::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidAppInfo::release_package_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidAppInfo.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidAppInfo::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidAppInfo.package_name)
}

// optional .enterprise_management.AndroidAppInfo.AndroidAppStatus status = 4;
inline bool AndroidAppInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AndroidAppInfo::has_status() const {
  return _internal_has_status();
}
inline void AndroidAppInfo::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::AndroidAppInfo_AndroidAppStatus AndroidAppInfo::_internal_status() const {
  return static_cast< ::enterprise_management::AndroidAppInfo_AndroidAppStatus >(_impl_.status_);
}
inline ::enterprise_management::AndroidAppInfo_AndroidAppStatus AndroidAppInfo::status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.status)
  return _internal_status();
}
inline void AndroidAppInfo::_internal_set_status(::enterprise_management::AndroidAppInfo_AndroidAppStatus value) {
  assert(::enterprise_management::AndroidAppInfo_AndroidAppStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.status_ = value;
}
inline void AndroidAppInfo::set_status(::enterprise_management::AndroidAppInfo_AndroidAppStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.status)
}

// optional .enterprise_management.AndroidAppInfo.InstalledSource installed_source = 5;
inline bool AndroidAppInfo::_internal_has_installed_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AndroidAppInfo::has_installed_source() const {
  return _internal_has_installed_source();
}
inline void AndroidAppInfo::clear_installed_source() {
  _impl_.installed_source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::AndroidAppInfo_InstalledSource AndroidAppInfo::_internal_installed_source() const {
  return static_cast< ::enterprise_management::AndroidAppInfo_InstalledSource >(_impl_.installed_source_);
}
inline ::enterprise_management::AndroidAppInfo_InstalledSource AndroidAppInfo::installed_source() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.installed_source)
  return _internal_installed_source();
}
inline void AndroidAppInfo::_internal_set_installed_source(::enterprise_management::AndroidAppInfo_InstalledSource value) {
  assert(::enterprise_management::AndroidAppInfo_InstalledSource_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.installed_source_ = value;
}
inline void AndroidAppInfo::set_installed_source(::enterprise_management::AndroidAppInfo_InstalledSource value) {
  _internal_set_installed_source(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.installed_source)
}

// optional int32 version = 6;
inline bool AndroidAppInfo::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AndroidAppInfo::has_version() const {
  return _internal_has_version();
}
inline void AndroidAppInfo::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t AndroidAppInfo::_internal_version() const {
  return _impl_.version_;
}
inline int32_t AndroidAppInfo::version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.version)
  return _internal_version();
}
inline void AndroidAppInfo::_internal_set_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.version_ = value;
}
inline void AndroidAppInfo::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidAppInfo.version)
}

// repeated .enterprise_management.AndroidAppPermission permissions = 7;
inline int AndroidAppInfo::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int AndroidAppInfo::permissions_size() const {
  return _internal_permissions_size();
}
inline void AndroidAppInfo::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::enterprise_management::AndroidAppPermission* AndroidAppInfo::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidAppInfo.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission >*
AndroidAppInfo::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.AndroidAppInfo.permissions)
  return &_impl_.permissions_;
}
inline const ::enterprise_management::AndroidAppPermission& AndroidAppInfo::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::enterprise_management::AndroidAppPermission& AndroidAppInfo::permissions(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidAppInfo.permissions)
  return _internal_permissions(index);
}
inline ::enterprise_management::AndroidAppPermission* AndroidAppInfo::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::enterprise_management::AndroidAppPermission* AndroidAppInfo::add_permissions() {
  ::enterprise_management::AndroidAppPermission* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:enterprise_management.AndroidAppInfo.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppPermission >&
AndroidAppInfo::permissions() const {
  // @@protoc_insertion_point(field_list:enterprise_management.AndroidAppInfo.permissions)
  return _impl_.permissions_;
}

// -------------------------------------------------------------------

// ChromeUserProfileReport

// optional string id = 1;
inline bool ChromeUserProfileReport::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_id() const {
  return _internal_has_id();
}
inline void ChromeUserProfileReport::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeUserProfileReport::id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeUserProfileReport::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.id)
}
inline std::string* ChromeUserProfileReport::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.id)
  return _s;
}
inline const std::string& ChromeUserProfileReport::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ChromeUserProfileReport::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::release_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeUserProfileReport::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.id)
}

// optional string chrome_signed_in_user = 2;
inline bool ChromeUserProfileReport::_internal_has_chrome_signed_in_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_chrome_signed_in_user() const {
  return _internal_has_chrome_signed_in_user();
}
inline void ChromeUserProfileReport::clear_chrome_signed_in_user() {
  _impl_.chrome_signed_in_user_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeUserProfileReport::chrome_signed_in_user() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
  return _internal_chrome_signed_in_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeUserProfileReport::set_chrome_signed_in_user(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.chrome_signed_in_user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
}
inline std::string* ChromeUserProfileReport::mutable_chrome_signed_in_user() {
  std::string* _s = _internal_mutable_chrome_signed_in_user();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
  return _s;
}
inline const std::string& ChromeUserProfileReport::_internal_chrome_signed_in_user() const {
  return _impl_.chrome_signed_in_user_.Get();
}
inline void ChromeUserProfileReport::_internal_set_chrome_signed_in_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chrome_signed_in_user_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::_internal_mutable_chrome_signed_in_user() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.chrome_signed_in_user_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::release_chrome_signed_in_user() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
  if (!_internal_has_chrome_signed_in_user()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.chrome_signed_in_user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chrome_signed_in_user_.IsDefault()) {
    _impl_.chrome_signed_in_user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeUserProfileReport::set_allocated_chrome_signed_in_user(std::string* chrome_signed_in_user) {
  if (chrome_signed_in_user != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.chrome_signed_in_user_.SetAllocated(chrome_signed_in_user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chrome_signed_in_user_.IsDefault()) {
    _impl_.chrome_signed_in_user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.chrome_signed_in_user)
}

// optional string extension_data = 3;
inline bool ChromeUserProfileReport::_internal_has_extension_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_extension_data() const {
  return _internal_has_extension_data();
}
inline void ChromeUserProfileReport::clear_extension_data() {
  _impl_.extension_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ChromeUserProfileReport::extension_data() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.extension_data)
  return _internal_extension_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeUserProfileReport::set_extension_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.extension_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.extension_data)
}
inline std::string* ChromeUserProfileReport::mutable_extension_data() {
  std::string* _s = _internal_mutable_extension_data();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.extension_data)
  return _s;
}
inline const std::string& ChromeUserProfileReport::_internal_extension_data() const {
  return _impl_.extension_data_.Get();
}
inline void ChromeUserProfileReport::_internal_set_extension_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.extension_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::_internal_mutable_extension_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.extension_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::release_extension_data() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.extension_data)
  if (!_internal_has_extension_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.extension_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_data_.IsDefault()) {
    _impl_.extension_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeUserProfileReport::set_allocated_extension_data(std::string* extension_data) {
  if (extension_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.extension_data_.SetAllocated(extension_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_data_.IsDefault()) {
    _impl_.extension_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.extension_data)
}

// optional string plugins = 4;
inline bool ChromeUserProfileReport::_internal_has_plugins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_plugins() const {
  return _internal_has_plugins();
}
inline void ChromeUserProfileReport::clear_plugins() {
  _impl_.plugins_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ChromeUserProfileReport::plugins() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.plugins)
  return _internal_plugins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeUserProfileReport::set_plugins(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.plugins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.plugins)
}
inline std::string* ChromeUserProfileReport::mutable_plugins() {
  std::string* _s = _internal_mutable_plugins();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.plugins)
  return _s;
}
inline const std::string& ChromeUserProfileReport::_internal_plugins() const {
  return _impl_.plugins_.Get();
}
inline void ChromeUserProfileReport::_internal_set_plugins(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.plugins_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::_internal_mutable_plugins() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.plugins_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::release_plugins() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.plugins)
  if (!_internal_has_plugins()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.plugins_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plugins_.IsDefault()) {
    _impl_.plugins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeUserProfileReport::set_allocated_plugins(std::string* plugins) {
  if (plugins != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.plugins_.SetAllocated(plugins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plugins_.IsDefault()) {
    _impl_.plugins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.plugins)
}

// optional string policy_data = 5;
inline bool ChromeUserProfileReport::_internal_has_policy_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_policy_data() const {
  return _internal_has_policy_data();
}
inline void ChromeUserProfileReport::clear_policy_data() {
  _impl_.policy_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ChromeUserProfileReport::policy_data() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.policy_data)
  return _internal_policy_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeUserProfileReport::set_policy_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.policy_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.policy_data)
}
inline std::string* ChromeUserProfileReport::mutable_policy_data() {
  std::string* _s = _internal_mutable_policy_data();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.policy_data)
  return _s;
}
inline const std::string& ChromeUserProfileReport::_internal_policy_data() const {
  return _impl_.policy_data_.Get();
}
inline void ChromeUserProfileReport::_internal_set_policy_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.policy_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::_internal_mutable_policy_data() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.policy_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::release_policy_data() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.policy_data)
  if (!_internal_has_policy_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.policy_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_data_.IsDefault()) {
    _impl_.policy_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeUserProfileReport::set_allocated_policy_data(std::string* policy_data) {
  if (policy_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.policy_data_.SetAllocated(policy_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_data_.IsDefault()) {
    _impl_.policy_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.policy_data)
}

// optional int64 policy_fetched_timestamp = 6;
inline bool ChromeUserProfileReport::_internal_has_policy_fetched_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_policy_fetched_timestamp() const {
  return _internal_has_policy_fetched_timestamp();
}
inline void ChromeUserProfileReport::clear_policy_fetched_timestamp() {
  _impl_.policy_fetched_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t ChromeUserProfileReport::_internal_policy_fetched_timestamp() const {
  return _impl_.policy_fetched_timestamp_;
}
inline int64_t ChromeUserProfileReport::policy_fetched_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.policy_fetched_timestamp)
  return _internal_policy_fetched_timestamp();
}
inline void ChromeUserProfileReport::_internal_set_policy_fetched_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.policy_fetched_timestamp_ = value;
}
inline void ChromeUserProfileReport::set_policy_fetched_timestamp(int64_t value) {
  _internal_set_policy_fetched_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.policy_fetched_timestamp)
}

// optional uint64 safe_browsing_warnings = 7;
inline bool ChromeUserProfileReport::_internal_has_safe_browsing_warnings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_safe_browsing_warnings() const {
  return _internal_has_safe_browsing_warnings();
}
inline void ChromeUserProfileReport::clear_safe_browsing_warnings() {
  _impl_.safe_browsing_warnings_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t ChromeUserProfileReport::_internal_safe_browsing_warnings() const {
  return _impl_.safe_browsing_warnings_;
}
inline uint64_t ChromeUserProfileReport::safe_browsing_warnings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.safe_browsing_warnings)
  return _internal_safe_browsing_warnings();
}
inline void ChromeUserProfileReport::_internal_set_safe_browsing_warnings(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.safe_browsing_warnings_ = value;
}
inline void ChromeUserProfileReport::set_safe_browsing_warnings(uint64_t value) {
  _internal_set_safe_browsing_warnings(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.safe_browsing_warnings)
}

// optional uint64 safe_browsing_warnings_click_through = 8;
inline bool ChromeUserProfileReport::_internal_has_safe_browsing_warnings_click_through() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_safe_browsing_warnings_click_through() const {
  return _internal_has_safe_browsing_warnings_click_through();
}
inline void ChromeUserProfileReport::clear_safe_browsing_warnings_click_through() {
  _impl_.safe_browsing_warnings_click_through_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint64_t ChromeUserProfileReport::_internal_safe_browsing_warnings_click_through() const {
  return _impl_.safe_browsing_warnings_click_through_;
}
inline uint64_t ChromeUserProfileReport::safe_browsing_warnings_click_through() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.safe_browsing_warnings_click_through)
  return _internal_safe_browsing_warnings_click_through();
}
inline void ChromeUserProfileReport::_internal_set_safe_browsing_warnings_click_through(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.safe_browsing_warnings_click_through_ = value;
}
inline void ChromeUserProfileReport::set_safe_browsing_warnings_click_through(uint64_t value) {
  _internal_set_safe_browsing_warnings_click_through(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.safe_browsing_warnings_click_through)
}

// optional string name = 9;
inline bool ChromeUserProfileReport::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChromeUserProfileReport::has_name() const {
  return _internal_has_name();
}
inline void ChromeUserProfileReport::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ChromeUserProfileReport::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeUserProfileReport::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileReport.name)
}
inline std::string* ChromeUserProfileReport::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.name)
  return _s;
}
inline const std::string& ChromeUserProfileReport::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ChromeUserProfileReport::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeUserProfileReport::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileReport.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeUserProfileReport::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileReport.name)
}

// repeated .enterprise_management.ExtensionRequest extension_requests = 10;
inline int ChromeUserProfileReport::_internal_extension_requests_size() const {
  return _impl_.extension_requests_.size();
}
inline int ChromeUserProfileReport::extension_requests_size() const {
  return _internal_extension_requests_size();
}
inline void ChromeUserProfileReport::clear_extension_requests() {
  _impl_.extension_requests_.Clear();
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileReport::mutable_extension_requests(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileReport.extension_requests)
  return _impl_.extension_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >*
ChromeUserProfileReport::mutable_extension_requests() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileReport.extension_requests)
  return &_impl_.extension_requests_;
}
inline const ::enterprise_management::ExtensionRequest& ChromeUserProfileReport::_internal_extension_requests(int index) const {
  return _impl_.extension_requests_.Get(index);
}
inline const ::enterprise_management::ExtensionRequest& ChromeUserProfileReport::extension_requests(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileReport.extension_requests)
  return _internal_extension_requests(index);
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileReport::_internal_add_extension_requests() {
  return _impl_.extension_requests_.Add();
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileReport::add_extension_requests() {
  ::enterprise_management::ExtensionRequest* _add = _internal_add_extension_requests();
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileReport.extension_requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >&
ChromeUserProfileReport::extension_requests() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileReport.extension_requests)
  return _impl_.extension_requests_;
}

// -------------------------------------------------------------------

// ChromeSignedInUser

// optional string email = 1;
inline bool ChromeSignedInUser::_internal_has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChromeSignedInUser::has_email() const {
  return _internal_has_email();
}
inline void ChromeSignedInUser::clear_email() {
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeSignedInUser::email() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeSignedInUser.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeSignedInUser::set_email(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeSignedInUser.email)
}
inline std::string* ChromeSignedInUser::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeSignedInUser.email)
  return _s;
}
inline const std::string& ChromeSignedInUser::_internal_email() const {
  return _impl_.email_.Get();
}
inline void ChromeSignedInUser::_internal_set_email(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeSignedInUser::_internal_mutable_email() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeSignedInUser::release_email() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeSignedInUser.email)
  if (!_internal_has_email()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeSignedInUser::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeSignedInUser.email)
}

// optional string obfuscated_gaia_id = 2;
inline bool ChromeSignedInUser::_internal_has_obfuscated_gaia_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChromeSignedInUser::has_obfuscated_gaia_id() const {
  return _internal_has_obfuscated_gaia_id();
}
inline void ChromeSignedInUser::clear_obfuscated_gaia_id() {
  _impl_.obfuscated_gaia_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeSignedInUser::obfuscated_gaia_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeSignedInUser.obfuscated_gaia_id)
  return _internal_obfuscated_gaia_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeSignedInUser::set_obfuscated_gaia_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.obfuscated_gaia_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeSignedInUser.obfuscated_gaia_id)
}
inline std::string* ChromeSignedInUser::mutable_obfuscated_gaia_id() {
  std::string* _s = _internal_mutable_obfuscated_gaia_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeSignedInUser.obfuscated_gaia_id)
  return _s;
}
inline const std::string& ChromeSignedInUser::_internal_obfuscated_gaia_id() const {
  return _impl_.obfuscated_gaia_id_.Get();
}
inline void ChromeSignedInUser::_internal_set_obfuscated_gaia_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.obfuscated_gaia_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeSignedInUser::_internal_mutable_obfuscated_gaia_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.obfuscated_gaia_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeSignedInUser::release_obfuscated_gaia_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeSignedInUser.obfuscated_gaia_id)
  if (!_internal_has_obfuscated_gaia_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.obfuscated_gaia_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obfuscated_gaia_id_.IsDefault()) {
    _impl_.obfuscated_gaia_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeSignedInUser::set_allocated_obfuscated_gaia_id(std::string* obfuscated_gaia_id) {
  if (obfuscated_gaia_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.obfuscated_gaia_id_.SetAllocated(obfuscated_gaia_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obfuscated_gaia_id_.IsDefault()) {
    _impl_.obfuscated_gaia_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeSignedInUser.obfuscated_gaia_id)
}

// -------------------------------------------------------------------

// ExtensionRequest

// optional string id = 1;
inline bool ExtensionRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtensionRequest::has_id() const {
  return _internal_has_id();
}
inline void ExtensionRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionRequest::id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtensionRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionRequest.id)
}
inline std::string* ExtensionRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionRequest.id)
  return _s;
}
inline const std::string& ExtensionRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ExtensionRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionRequest::release_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ExtensionRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtensionRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ExtensionRequest.id)
}

// optional int64 request_timestamp = 2;
inline bool ExtensionRequest::_internal_has_request_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExtensionRequest::has_request_timestamp() const {
  return _internal_has_request_timestamp();
}
inline void ExtensionRequest::clear_request_timestamp() {
  _impl_.request_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ExtensionRequest::_internal_request_timestamp() const {
  return _impl_.request_timestamp_;
}
inline int64_t ExtensionRequest::request_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionRequest.request_timestamp)
  return _internal_request_timestamp();
}
inline void ExtensionRequest::_internal_set_request_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_timestamp_ = value;
}
inline void ExtensionRequest::set_request_timestamp(int64_t value) {
  _internal_set_request_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionRequest.request_timestamp)
}

// optional string justification = 3;
inline bool ExtensionRequest::_internal_has_justification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtensionRequest::has_justification() const {
  return _internal_has_justification();
}
inline void ExtensionRequest::clear_justification() {
  _impl_.justification_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExtensionRequest::justification() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionRequest.justification)
  return _internal_justification();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtensionRequest::set_justification(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.justification_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionRequest.justification)
}
inline std::string* ExtensionRequest::mutable_justification() {
  std::string* _s = _internal_mutable_justification();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionRequest.justification)
  return _s;
}
inline const std::string& ExtensionRequest::_internal_justification() const {
  return _impl_.justification_.Get();
}
inline void ExtensionRequest::_internal_set_justification(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.justification_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionRequest::_internal_mutable_justification() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.justification_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionRequest::release_justification() {
  // @@protoc_insertion_point(field_release:enterprise_management.ExtensionRequest.justification)
  if (!_internal_has_justification()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.justification_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.justification_.IsDefault()) {
    _impl_.justification_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtensionRequest::set_allocated_justification(std::string* justification) {
  if (justification != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.justification_.SetAllocated(justification, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.justification_.IsDefault()) {
    _impl_.justification_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ExtensionRequest.justification)
}

// -------------------------------------------------------------------

// Extension

// optional string id = 1;
inline bool Extension::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Extension::has_id() const {
  return _internal_has_id();
}
inline void Extension::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Extension::id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Extension::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.id)
}
inline std::string* Extension::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Extension.id)
  return _s;
}
inline const std::string& Extension::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Extension::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Extension::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Extension::release_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.Extension.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Extension::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.id)
}

// optional string version = 2;
inline bool Extension::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Extension::has_version() const {
  return _internal_has_version();
}
inline void Extension::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Extension::version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Extension::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.version)
}
inline std::string* Extension::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Extension.version)
  return _s;
}
inline const std::string& Extension::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Extension::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Extension::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Extension::release_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.Extension.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Extension::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.version)
}

// optional string name = 3;
inline bool Extension::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Extension::has_name() const {
  return _internal_has_name();
}
inline void Extension::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Extension::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Extension::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.name)
}
inline std::string* Extension::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Extension.name)
  return _s;
}
inline const std::string& Extension::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Extension::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Extension::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Extension::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.Extension.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Extension::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.name)
}

// optional string description = 4;
inline bool Extension::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Extension::has_description() const {
  return _internal_has_description();
}
inline void Extension::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Extension::description() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Extension::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.description)
}
inline std::string* Extension::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Extension.description)
  return _s;
}
inline const std::string& Extension::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Extension::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Extension::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Extension::release_description() {
  // @@protoc_insertion_point(field_release:enterprise_management.Extension.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Extension::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.description)
}

// optional .enterprise_management.Extension.ExtensionType app_type = 5;
inline bool Extension::_internal_has_app_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Extension::has_app_type() const {
  return _internal_has_app_type();
}
inline void Extension::clear_app_type() {
  _impl_.app_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::Extension_ExtensionType Extension::_internal_app_type() const {
  return static_cast< ::enterprise_management::Extension_ExtensionType >(_impl_.app_type_);
}
inline ::enterprise_management::Extension_ExtensionType Extension::app_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.app_type)
  return _internal_app_type();
}
inline void Extension::_internal_set_app_type(::enterprise_management::Extension_ExtensionType value) {
  assert(::enterprise_management::Extension_ExtensionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.app_type_ = value;
}
inline void Extension::set_app_type(::enterprise_management::Extension_ExtensionType value) {
  _internal_set_app_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.app_type)
}

// optional string homepage_url = 6;
inline bool Extension::_internal_has_homepage_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Extension::has_homepage_url() const {
  return _internal_has_homepage_url();
}
inline void Extension::clear_homepage_url() {
  _impl_.homepage_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Extension::homepage_url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.homepage_url)
  return _internal_homepage_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Extension::set_homepage_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.homepage_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.homepage_url)
}
inline std::string* Extension::mutable_homepage_url() {
  std::string* _s = _internal_mutable_homepage_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Extension.homepage_url)
  return _s;
}
inline const std::string& Extension::_internal_homepage_url() const {
  return _impl_.homepage_url_.Get();
}
inline void Extension::_internal_set_homepage_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.homepage_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Extension::_internal_mutable_homepage_url() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.homepage_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Extension::release_homepage_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.Extension.homepage_url)
  if (!_internal_has_homepage_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.homepage_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.homepage_url_.IsDefault()) {
    _impl_.homepage_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Extension::set_allocated_homepage_url(std::string* homepage_url) {
  if (homepage_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.homepage_url_.SetAllocated(homepage_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.homepage_url_.IsDefault()) {
    _impl_.homepage_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Extension.homepage_url)
}

// optional .enterprise_management.Extension.InstallType install_type = 8;
inline bool Extension::_internal_has_install_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Extension::has_install_type() const {
  return _internal_has_install_type();
}
inline void Extension::clear_install_type() {
  _impl_.install_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::enterprise_management::Extension_InstallType Extension::_internal_install_type() const {
  return static_cast< ::enterprise_management::Extension_InstallType >(_impl_.install_type_);
}
inline ::enterprise_management::Extension_InstallType Extension::install_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.install_type)
  return _internal_install_type();
}
inline void Extension::_internal_set_install_type(::enterprise_management::Extension_InstallType value) {
  assert(::enterprise_management::Extension_InstallType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.install_type_ = value;
}
inline void Extension::set_install_type(::enterprise_management::Extension_InstallType value) {
  _internal_set_install_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.install_type)
}

// optional bool enabled = 9;
inline bool Extension::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Extension::has_enabled() const {
  return _internal_has_enabled();
}
inline void Extension::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Extension::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool Extension::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.enabled)
  return _internal_enabled();
}
inline void Extension::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.enabled_ = value;
}
inline void Extension::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.enabled)
}

// repeated string permissions = 10;
inline int Extension::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int Extension::permissions_size() const {
  return _internal_permissions_size();
}
inline void Extension::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline std::string* Extension::add_permissions() {
  std::string* _s = _internal_add_permissions();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.Extension.permissions)
  return _s;
}
inline const std::string& Extension::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const std::string& Extension::permissions(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.permissions)
  return _internal_permissions(index);
}
inline std::string* Extension::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.Extension.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline void Extension::set_permissions(int index, const std::string& value) {
  _impl_.permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.permissions)
}
inline void Extension::set_permissions(int index, std::string&& value) {
  _impl_.permissions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.permissions)
}
inline void Extension::set_permissions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.Extension.permissions)
}
inline void Extension::set_permissions(int index, const char* value, size_t size) {
  _impl_.permissions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.permissions)
}
inline std::string* Extension::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline void Extension::add_permissions(const std::string& value) {
  _impl_.permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.Extension.permissions)
}
inline void Extension::add_permissions(std::string&& value) {
  _impl_.permissions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.Extension.permissions)
}
inline void Extension::add_permissions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.Extension.permissions)
}
inline void Extension::add_permissions(const char* value, size_t size) {
  _impl_.permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.Extension.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Extension::permissions() const {
  // @@protoc_insertion_point(field_list:enterprise_management.Extension.permissions)
  return _impl_.permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Extension::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.Extension.permissions)
  return &_impl_.permissions_;
}

// repeated string host_permissions = 11;
inline int Extension::_internal_host_permissions_size() const {
  return _impl_.host_permissions_.size();
}
inline int Extension::host_permissions_size() const {
  return _internal_host_permissions_size();
}
inline void Extension::clear_host_permissions() {
  _impl_.host_permissions_.Clear();
}
inline std::string* Extension::add_host_permissions() {
  std::string* _s = _internal_add_host_permissions();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.Extension.host_permissions)
  return _s;
}
inline const std::string& Extension::_internal_host_permissions(int index) const {
  return _impl_.host_permissions_.Get(index);
}
inline const std::string& Extension::host_permissions(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.host_permissions)
  return _internal_host_permissions(index);
}
inline std::string* Extension::mutable_host_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.Extension.host_permissions)
  return _impl_.host_permissions_.Mutable(index);
}
inline void Extension::set_host_permissions(int index, const std::string& value) {
  _impl_.host_permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.host_permissions)
}
inline void Extension::set_host_permissions(int index, std::string&& value) {
  _impl_.host_permissions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.host_permissions)
}
inline void Extension::set_host_permissions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.host_permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.Extension.host_permissions)
}
inline void Extension::set_host_permissions(int index, const char* value, size_t size) {
  _impl_.host_permissions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.Extension.host_permissions)
}
inline std::string* Extension::_internal_add_host_permissions() {
  return _impl_.host_permissions_.Add();
}
inline void Extension::add_host_permissions(const std::string& value) {
  _impl_.host_permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.Extension.host_permissions)
}
inline void Extension::add_host_permissions(std::string&& value) {
  _impl_.host_permissions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.Extension.host_permissions)
}
inline void Extension::add_host_permissions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.host_permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.Extension.host_permissions)
}
inline void Extension::add_host_permissions(const char* value, size_t size) {
  _impl_.host_permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.Extension.host_permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Extension::host_permissions() const {
  // @@protoc_insertion_point(field_list:enterprise_management.Extension.host_permissions)
  return _impl_.host_permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Extension::mutable_host_permissions() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.Extension.host_permissions)
  return &_impl_.host_permissions_;
}

// optional bool from_webstore = 13;
inline bool Extension::_internal_has_from_webstore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Extension::has_from_webstore() const {
  return _internal_has_from_webstore();
}
inline void Extension::clear_from_webstore() {
  _impl_.from_webstore_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool Extension::_internal_from_webstore() const {
  return _impl_.from_webstore_;
}
inline bool Extension::from_webstore() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.from_webstore)
  return _internal_from_webstore();
}
inline void Extension::_internal_set_from_webstore(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.from_webstore_ = value;
}
inline void Extension::set_from_webstore(bool value) {
  _internal_set_from_webstore(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.from_webstore)
}

// optional int32 manifest_version = 14;
inline bool Extension::_internal_has_manifest_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Extension::has_manifest_version() const {
  return _internal_has_manifest_version();
}
inline void Extension::clear_manifest_version() {
  _impl_.manifest_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t Extension::_internal_manifest_version() const {
  return _impl_.manifest_version_;
}
inline int32_t Extension::manifest_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Extension.manifest_version)
  return _internal_manifest_version();
}
inline void Extension::_internal_set_manifest_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.manifest_version_ = value;
}
inline void Extension::set_manifest_version(int32_t value) {
  _internal_set_manifest_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Extension.manifest_version)
}

// -------------------------------------------------------------------

// Plugin

// optional string name = 1;
inline bool Plugin::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Plugin::has_name() const {
  return _internal_has_name();
}
inline void Plugin::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Plugin::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Plugin.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plugin::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Plugin.name)
}
inline std::string* Plugin::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Plugin.name)
  return _s;
}
inline const std::string& Plugin::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Plugin::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Plugin::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Plugin::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.Plugin.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Plugin::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Plugin.name)
}

// optional string version = 2;
inline bool Plugin::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Plugin::has_version() const {
  return _internal_has_version();
}
inline void Plugin::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Plugin::version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Plugin.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plugin::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Plugin.version)
}
inline std::string* Plugin::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Plugin.version)
  return _s;
}
inline const std::string& Plugin::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Plugin::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Plugin::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Plugin::release_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.Plugin.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Plugin::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Plugin.version)
}

// optional string filename = 3;
inline bool Plugin::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Plugin::has_filename() const {
  return _internal_has_filename();
}
inline void Plugin::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Plugin::filename() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Plugin.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plugin::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Plugin.filename)
}
inline std::string* Plugin::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Plugin.filename)
  return _s;
}
inline const std::string& Plugin::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void Plugin::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* Plugin::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* Plugin::release_filename() {
  // @@protoc_insertion_point(field_release:enterprise_management.Plugin.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Plugin::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Plugin.filename)
}

// optional string description = 4;
inline bool Plugin::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Plugin::has_description() const {
  return _internal_has_description();
}
inline void Plugin::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Plugin::description() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Plugin.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plugin::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Plugin.description)
}
inline std::string* Plugin::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Plugin.description)
  return _s;
}
inline const std::string& Plugin::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Plugin::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Plugin::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Plugin::release_description() {
  // @@protoc_insertion_point(field_release:enterprise_management.Plugin.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Plugin::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Plugin.description)
}

// -------------------------------------------------------------------

// Policy

// optional string name = 1;
inline bool Policy::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Policy::has_name() const {
  return _internal_has_name();
}
inline void Policy::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Policy::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Policy.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Policy::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Policy.name)
}
inline std::string* Policy::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Policy.name)
  return _s;
}
inline const std::string& Policy::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Policy::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Policy::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Policy::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.Policy.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Policy::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Policy.name)
}

// optional .enterprise_management.Policy.PolicyLevel level = 2;
inline bool Policy::_internal_has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Policy::has_level() const {
  return _internal_has_level();
}
inline void Policy::clear_level() {
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::Policy_PolicyLevel Policy::_internal_level() const {
  return static_cast< ::enterprise_management::Policy_PolicyLevel >(_impl_.level_);
}
inline ::enterprise_management::Policy_PolicyLevel Policy::level() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Policy.level)
  return _internal_level();
}
inline void Policy::_internal_set_level(::enterprise_management::Policy_PolicyLevel value) {
  assert(::enterprise_management::Policy_PolicyLevel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.level_ = value;
}
inline void Policy::set_level(::enterprise_management::Policy_PolicyLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Policy.level)
}

// optional .enterprise_management.Policy.PolicyScope scope = 3;
inline bool Policy::_internal_has_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Policy::has_scope() const {
  return _internal_has_scope();
}
inline void Policy::clear_scope() {
  _impl_.scope_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::Policy_PolicyScope Policy::_internal_scope() const {
  return static_cast< ::enterprise_management::Policy_PolicyScope >(_impl_.scope_);
}
inline ::enterprise_management::Policy_PolicyScope Policy::scope() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Policy.scope)
  return _internal_scope();
}
inline void Policy::_internal_set_scope(::enterprise_management::Policy_PolicyScope value) {
  assert(::enterprise_management::Policy_PolicyScope_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.scope_ = value;
}
inline void Policy::set_scope(::enterprise_management::Policy_PolicyScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Policy.scope)
}

// optional .enterprise_management.Policy.PolicySource source = 4;
inline bool Policy::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Policy::has_source() const {
  return _internal_has_source();
}
inline void Policy::clear_source() {
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::Policy_PolicySource Policy::_internal_source() const {
  return static_cast< ::enterprise_management::Policy_PolicySource >(_impl_.source_);
}
inline ::enterprise_management::Policy_PolicySource Policy::source() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Policy.source)
  return _internal_source();
}
inline void Policy::_internal_set_source(::enterprise_management::Policy_PolicySource value) {
  assert(::enterprise_management::Policy_PolicySource_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.source_ = value;
}
inline void Policy::set_source(::enterprise_management::Policy_PolicySource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:enterprise_management.Policy.source)
}

// optional string value = 5;
inline bool Policy::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Policy::has_value() const {
  return _internal_has_value();
}
inline void Policy::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Policy::value() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Policy.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Policy::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Policy.value)
}
inline std::string* Policy::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Policy.value)
  return _s;
}
inline const std::string& Policy::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Policy::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Policy::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Policy::release_value() {
  // @@protoc_insertion_point(field_release:enterprise_management.Policy.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Policy::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Policy.value)
}

// optional string error = 6;
inline bool Policy::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Policy::has_error() const {
  return _internal_has_error();
}
inline void Policy::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Policy::error() const {
  // @@protoc_insertion_point(field_get:enterprise_management.Policy.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Policy::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.Policy.error)
}
inline std::string* Policy::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:enterprise_management.Policy.error)
  return _s;
}
inline const std::string& Policy::_internal_error() const {
  return _impl_.error_.Get();
}
inline void Policy::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* Policy::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* Policy::release_error() {
  // @@protoc_insertion_point(field_release:enterprise_management.Policy.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Policy::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.Policy.error)
}

// -------------------------------------------------------------------

// ExtensionPolicy

// optional string extension_id = 1;
inline bool ExtensionPolicy::_internal_has_extension_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtensionPolicy::has_extension_id() const {
  return _internal_has_extension_id();
}
inline void ExtensionPolicy::clear_extension_id() {
  _impl_.extension_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionPolicy::extension_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionPolicy.extension_id)
  return _internal_extension_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtensionPolicy::set_extension_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.extension_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionPolicy.extension_id)
}
inline std::string* ExtensionPolicy::mutable_extension_id() {
  std::string* _s = _internal_mutable_extension_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionPolicy.extension_id)
  return _s;
}
inline const std::string& ExtensionPolicy::_internal_extension_id() const {
  return _impl_.extension_id_.Get();
}
inline void ExtensionPolicy::_internal_set_extension_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.extension_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionPolicy::_internal_mutable_extension_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.extension_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionPolicy::release_extension_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ExtensionPolicy.extension_id)
  if (!_internal_has_extension_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.extension_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_id_.IsDefault()) {
    _impl_.extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtensionPolicy::set_allocated_extension_id(std::string* extension_id) {
  if (extension_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.extension_id_.SetAllocated(extension_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_id_.IsDefault()) {
    _impl_.extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ExtensionPolicy.extension_id)
}

// repeated .enterprise_management.Policy policies = 2;
inline int ExtensionPolicy::_internal_policies_size() const {
  return _impl_.policies_.size();
}
inline int ExtensionPolicy::policies_size() const {
  return _internal_policies_size();
}
inline void ExtensionPolicy::clear_policies() {
  _impl_.policies_.Clear();
}
inline ::enterprise_management::Policy* ExtensionPolicy::mutable_policies(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionPolicy.policies)
  return _impl_.policies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >*
ExtensionPolicy::mutable_policies() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ExtensionPolicy.policies)
  return &_impl_.policies_;
}
inline const ::enterprise_management::Policy& ExtensionPolicy::_internal_policies(int index) const {
  return _impl_.policies_.Get(index);
}
inline const ::enterprise_management::Policy& ExtensionPolicy::policies(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionPolicy.policies)
  return _internal_policies(index);
}
inline ::enterprise_management::Policy* ExtensionPolicy::_internal_add_policies() {
  return _impl_.policies_.Add();
}
inline ::enterprise_management::Policy* ExtensionPolicy::add_policies() {
  ::enterprise_management::Policy* _add = _internal_add_policies();
  // @@protoc_insertion_point(field_add:enterprise_management.ExtensionPolicy.policies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >&
ExtensionPolicy::policies() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ExtensionPolicy.policies)
  return _impl_.policies_;
}

// -------------------------------------------------------------------

// PolicyFetchTimestamp

// optional string type = 1;
inline bool PolicyFetchTimestamp::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolicyFetchTimestamp::has_type() const {
  return _internal_has_type();
}
inline void PolicyFetchTimestamp::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyFetchTimestamp::type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchTimestamp.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyFetchTimestamp::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchTimestamp.type)
}
inline std::string* PolicyFetchTimestamp::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyFetchTimestamp.type)
  return _s;
}
inline const std::string& PolicyFetchTimestamp::_internal_type() const {
  return _impl_.type_.Get();
}
inline void PolicyFetchTimestamp::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyFetchTimestamp::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyFetchTimestamp::release_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyFetchTimestamp.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyFetchTimestamp::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyFetchTimestamp.type)
}

// optional int64 timestamp = 2;
inline bool PolicyFetchTimestamp::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PolicyFetchTimestamp::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void PolicyFetchTimestamp::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t PolicyFetchTimestamp::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t PolicyFetchTimestamp::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyFetchTimestamp.timestamp)
  return _internal_timestamp();
}
inline void PolicyFetchTimestamp::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void PolicyFetchTimestamp::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyFetchTimestamp.timestamp)
}

// -------------------------------------------------------------------

// ChromeUserProfileInfo

// optional string id = 1;
inline bool ChromeUserProfileInfo::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChromeUserProfileInfo::has_id() const {
  return _internal_has_id();
}
inline void ChromeUserProfileInfo::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeUserProfileInfo::id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeUserProfileInfo::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileInfo.id)
}
inline std::string* ChromeUserProfileInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.id)
  return _s;
}
inline const std::string& ChromeUserProfileInfo::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ChromeUserProfileInfo::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeUserProfileInfo::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeUserProfileInfo::release_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileInfo.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeUserProfileInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileInfo.id)
}

// optional string name = 2;
inline bool ChromeUserProfileInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChromeUserProfileInfo::has_name() const {
  return _internal_has_name();
}
inline void ChromeUserProfileInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeUserProfileInfo::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeUserProfileInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileInfo.name)
}
inline std::string* ChromeUserProfileInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.name)
  return _s;
}
inline const std::string& ChromeUserProfileInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ChromeUserProfileInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeUserProfileInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeUserProfileInfo::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeUserProfileInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileInfo.name)
}

// optional bool is_detail_available = 3;
inline bool ChromeUserProfileInfo::_internal_has_is_detail_available() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChromeUserProfileInfo::has_is_detail_available() const {
  return _internal_has_is_detail_available();
}
inline void ChromeUserProfileInfo::clear_is_detail_available() {
  _impl_.is_detail_available_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ChromeUserProfileInfo::_internal_is_detail_available() const {
  return _impl_.is_detail_available_;
}
inline bool ChromeUserProfileInfo::is_detail_available() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.is_detail_available)
  return _internal_is_detail_available();
}
inline void ChromeUserProfileInfo::_internal_set_is_detail_available(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_detail_available_ = value;
}
inline void ChromeUserProfileInfo::set_is_detail_available(bool value) {
  _internal_set_is_detail_available(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeUserProfileInfo.is_detail_available)
}

// optional .enterprise_management.ChromeSignedInUser chrome_signed_in_user = 4;
inline bool ChromeUserProfileInfo::_internal_has_chrome_signed_in_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chrome_signed_in_user_ != nullptr);
  return value;
}
inline bool ChromeUserProfileInfo::has_chrome_signed_in_user() const {
  return _internal_has_chrome_signed_in_user();
}
inline void ChromeUserProfileInfo::clear_chrome_signed_in_user() {
  if (_impl_.chrome_signed_in_user_ != nullptr) _impl_.chrome_signed_in_user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::ChromeSignedInUser& ChromeUserProfileInfo::_internal_chrome_signed_in_user() const {
  const ::enterprise_management::ChromeSignedInUser* p = _impl_.chrome_signed_in_user_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChromeSignedInUser&>(
      ::enterprise_management::_ChromeSignedInUser_default_instance_);
}
inline const ::enterprise_management::ChromeSignedInUser& ChromeUserProfileInfo::chrome_signed_in_user() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
  return _internal_chrome_signed_in_user();
}
inline void ChromeUserProfileInfo::unsafe_arena_set_allocated_chrome_signed_in_user(
    ::enterprise_management::ChromeSignedInUser* chrome_signed_in_user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_signed_in_user_);
  }
  _impl_.chrome_signed_in_user_ = chrome_signed_in_user;
  if (chrome_signed_in_user) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
}
inline ::enterprise_management::ChromeSignedInUser* ChromeUserProfileInfo::release_chrome_signed_in_user() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::ChromeSignedInUser* temp = _impl_.chrome_signed_in_user_;
  _impl_.chrome_signed_in_user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChromeSignedInUser* ChromeUserProfileInfo::unsafe_arena_release_chrome_signed_in_user() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::ChromeSignedInUser* temp = _impl_.chrome_signed_in_user_;
  _impl_.chrome_signed_in_user_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChromeSignedInUser* ChromeUserProfileInfo::_internal_mutable_chrome_signed_in_user() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.chrome_signed_in_user_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChromeSignedInUser>(GetArenaForAllocation());
    _impl_.chrome_signed_in_user_ = p;
  }
  return _impl_.chrome_signed_in_user_;
}
inline ::enterprise_management::ChromeSignedInUser* ChromeUserProfileInfo::mutable_chrome_signed_in_user() {
  ::enterprise_management::ChromeSignedInUser* _msg = _internal_mutable_chrome_signed_in_user();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
  return _msg;
}
inline void ChromeUserProfileInfo::set_allocated_chrome_signed_in_user(::enterprise_management::ChromeSignedInUser* chrome_signed_in_user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chrome_signed_in_user_;
  }
  if (chrome_signed_in_user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_signed_in_user);
    if (message_arena != submessage_arena) {
      chrome_signed_in_user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_signed_in_user, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.chrome_signed_in_user_ = chrome_signed_in_user;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeUserProfileInfo.chrome_signed_in_user)
}

// repeated .enterprise_management.Extension extensions = 5;
inline int ChromeUserProfileInfo::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int ChromeUserProfileInfo::extensions_size() const {
  return _internal_extensions_size();
}
inline void ChromeUserProfileInfo::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline ::enterprise_management::Extension* ChromeUserProfileInfo::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.extensions)
  return _impl_.extensions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension >*
ChromeUserProfileInfo::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.extensions)
  return &_impl_.extensions_;
}
inline const ::enterprise_management::Extension& ChromeUserProfileInfo::_internal_extensions(int index) const {
  return _impl_.extensions_.Get(index);
}
inline const ::enterprise_management::Extension& ChromeUserProfileInfo::extensions(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.extensions)
  return _internal_extensions(index);
}
inline ::enterprise_management::Extension* ChromeUserProfileInfo::_internal_add_extensions() {
  return _impl_.extensions_.Add();
}
inline ::enterprise_management::Extension* ChromeUserProfileInfo::add_extensions() {
  ::enterprise_management::Extension* _add = _internal_add_extensions();
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.extensions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Extension >&
ChromeUserProfileInfo::extensions() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.extensions)
  return _impl_.extensions_;
}

// repeated .enterprise_management.ExtensionRequest extension_requests = 10;
inline int ChromeUserProfileInfo::_internal_extension_requests_size() const {
  return _impl_.extension_requests_.size();
}
inline int ChromeUserProfileInfo::extension_requests_size() const {
  return _internal_extension_requests_size();
}
inline void ChromeUserProfileInfo::clear_extension_requests() {
  _impl_.extension_requests_.Clear();
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileInfo::mutable_extension_requests(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.extension_requests)
  return _impl_.extension_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >*
ChromeUserProfileInfo::mutable_extension_requests() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.extension_requests)
  return &_impl_.extension_requests_;
}
inline const ::enterprise_management::ExtensionRequest& ChromeUserProfileInfo::_internal_extension_requests(int index) const {
  return _impl_.extension_requests_.Get(index);
}
inline const ::enterprise_management::ExtensionRequest& ChromeUserProfileInfo::extension_requests(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.extension_requests)
  return _internal_extension_requests(index);
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileInfo::_internal_add_extension_requests() {
  return _impl_.extension_requests_.Add();
}
inline ::enterprise_management::ExtensionRequest* ChromeUserProfileInfo::add_extension_requests() {
  ::enterprise_management::ExtensionRequest* _add = _internal_add_extension_requests();
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.extension_requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionRequest >&
ChromeUserProfileInfo::extension_requests() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.extension_requests)
  return _impl_.extension_requests_;
}

// repeated .enterprise_management.Policy chrome_policies = 7;
inline int ChromeUserProfileInfo::_internal_chrome_policies_size() const {
  return _impl_.chrome_policies_.size();
}
inline int ChromeUserProfileInfo::chrome_policies_size() const {
  return _internal_chrome_policies_size();
}
inline void ChromeUserProfileInfo::clear_chrome_policies() {
  _impl_.chrome_policies_.Clear();
}
inline ::enterprise_management::Policy* ChromeUserProfileInfo::mutable_chrome_policies(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.chrome_policies)
  return _impl_.chrome_policies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >*
ChromeUserProfileInfo::mutable_chrome_policies() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.chrome_policies)
  return &_impl_.chrome_policies_;
}
inline const ::enterprise_management::Policy& ChromeUserProfileInfo::_internal_chrome_policies(int index) const {
  return _impl_.chrome_policies_.Get(index);
}
inline const ::enterprise_management::Policy& ChromeUserProfileInfo::chrome_policies(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.chrome_policies)
  return _internal_chrome_policies(index);
}
inline ::enterprise_management::Policy* ChromeUserProfileInfo::_internal_add_chrome_policies() {
  return _impl_.chrome_policies_.Add();
}
inline ::enterprise_management::Policy* ChromeUserProfileInfo::add_chrome_policies() {
  ::enterprise_management::Policy* _add = _internal_add_chrome_policies();
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.chrome_policies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Policy >&
ChromeUserProfileInfo::chrome_policies() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.chrome_policies)
  return _impl_.chrome_policies_;
}

// repeated .enterprise_management.ExtensionPolicy extension_policies = 8;
inline int ChromeUserProfileInfo::_internal_extension_policies_size() const {
  return _impl_.extension_policies_.size();
}
inline int ChromeUserProfileInfo::extension_policies_size() const {
  return _internal_extension_policies_size();
}
inline void ChromeUserProfileInfo::clear_extension_policies() {
  _impl_.extension_policies_.Clear();
}
inline ::enterprise_management::ExtensionPolicy* ChromeUserProfileInfo::mutable_extension_policies(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.extension_policies)
  return _impl_.extension_policies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy >*
ChromeUserProfileInfo::mutable_extension_policies() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.extension_policies)
  return &_impl_.extension_policies_;
}
inline const ::enterprise_management::ExtensionPolicy& ChromeUserProfileInfo::_internal_extension_policies(int index) const {
  return _impl_.extension_policies_.Get(index);
}
inline const ::enterprise_management::ExtensionPolicy& ChromeUserProfileInfo::extension_policies(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.extension_policies)
  return _internal_extension_policies(index);
}
inline ::enterprise_management::ExtensionPolicy* ChromeUserProfileInfo::_internal_add_extension_policies() {
  return _impl_.extension_policies_.Add();
}
inline ::enterprise_management::ExtensionPolicy* ChromeUserProfileInfo::add_extension_policies() {
  ::enterprise_management::ExtensionPolicy* _add = _internal_add_extension_policies();
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.extension_policies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionPolicy >&
ChromeUserProfileInfo::extension_policies() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.extension_policies)
  return _impl_.extension_policies_;
}

// repeated .enterprise_management.PolicyFetchTimestamp policy_fetched_timestamps = 9;
inline int ChromeUserProfileInfo::_internal_policy_fetched_timestamps_size() const {
  return _impl_.policy_fetched_timestamps_.size();
}
inline int ChromeUserProfileInfo::policy_fetched_timestamps_size() const {
  return _internal_policy_fetched_timestamps_size();
}
inline void ChromeUserProfileInfo::clear_policy_fetched_timestamps() {
  _impl_.policy_fetched_timestamps_.Clear();
}
inline ::enterprise_management::PolicyFetchTimestamp* ChromeUserProfileInfo::mutable_policy_fetched_timestamps(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
  return _impl_.policy_fetched_timestamps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp >*
ChromeUserProfileInfo::mutable_policy_fetched_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
  return &_impl_.policy_fetched_timestamps_;
}
inline const ::enterprise_management::PolicyFetchTimestamp& ChromeUserProfileInfo::_internal_policy_fetched_timestamps(int index) const {
  return _impl_.policy_fetched_timestamps_.Get(index);
}
inline const ::enterprise_management::PolicyFetchTimestamp& ChromeUserProfileInfo::policy_fetched_timestamps(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
  return _internal_policy_fetched_timestamps(index);
}
inline ::enterprise_management::PolicyFetchTimestamp* ChromeUserProfileInfo::_internal_add_policy_fetched_timestamps() {
  return _impl_.policy_fetched_timestamps_.Add();
}
inline ::enterprise_management::PolicyFetchTimestamp* ChromeUserProfileInfo::add_policy_fetched_timestamps() {
  ::enterprise_management::PolicyFetchTimestamp* _add = _internal_add_policy_fetched_timestamps();
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyFetchTimestamp >&
ChromeUserProfileInfo::policy_fetched_timestamps() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeUserProfileInfo.policy_fetched_timestamps)
  return _impl_.policy_fetched_timestamps_;
}

// -------------------------------------------------------------------

// BrowserReport

// optional string browser_version = 1;
inline bool BrowserReport::_internal_has_browser_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BrowserReport::has_browser_version() const {
  return _internal_has_browser_version();
}
inline void BrowserReport::clear_browser_version() {
  _impl_.browser_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BrowserReport::browser_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.browser_version)
  return _internal_browser_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BrowserReport::set_browser_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.browser_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.browser_version)
}
inline std::string* BrowserReport::mutable_browser_version() {
  std::string* _s = _internal_mutable_browser_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.browser_version)
  return _s;
}
inline const std::string& BrowserReport::_internal_browser_version() const {
  return _impl_.browser_version_.Get();
}
inline void BrowserReport::_internal_set_browser_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.browser_version_.Set(value, GetArenaForAllocation());
}
inline std::string* BrowserReport::_internal_mutable_browser_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.browser_version_.Mutable(GetArenaForAllocation());
}
inline std::string* BrowserReport::release_browser_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.BrowserReport.browser_version)
  if (!_internal_has_browser_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.browser_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_version_.IsDefault()) {
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BrowserReport::set_allocated_browser_version(std::string* browser_version) {
  if (browser_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.browser_version_.SetAllocated(browser_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_version_.IsDefault()) {
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserReport.browser_version)
}

// optional .enterprise_management.Channel channel = 2;
inline bool BrowserReport::_internal_has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BrowserReport::has_channel() const {
  return _internal_has_channel();
}
inline void BrowserReport::clear_channel() {
  _impl_.channel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::Channel BrowserReport::_internal_channel() const {
  return static_cast< ::enterprise_management::Channel >(_impl_.channel_);
}
inline ::enterprise_management::Channel BrowserReport::channel() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.channel)
  return _internal_channel();
}
inline void BrowserReport::_internal_set_channel(::enterprise_management::Channel value) {
  assert(::enterprise_management::Channel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.channel_ = value;
}
inline void BrowserReport::set_channel(::enterprise_management::Channel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.channel)
}

// optional string executable_path = 3;
inline bool BrowserReport::_internal_has_executable_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BrowserReport::has_executable_path() const {
  return _internal_has_executable_path();
}
inline void BrowserReport::clear_executable_path() {
  _impl_.executable_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BrowserReport::executable_path() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.executable_path)
  return _internal_executable_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BrowserReport::set_executable_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.executable_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.executable_path)
}
inline std::string* BrowserReport::mutable_executable_path() {
  std::string* _s = _internal_mutable_executable_path();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.executable_path)
  return _s;
}
inline const std::string& BrowserReport::_internal_executable_path() const {
  return _impl_.executable_path_.Get();
}
inline void BrowserReport::_internal_set_executable_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.executable_path_.Set(value, GetArenaForAllocation());
}
inline std::string* BrowserReport::_internal_mutable_executable_path() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.executable_path_.Mutable(GetArenaForAllocation());
}
inline std::string* BrowserReport::release_executable_path() {
  // @@protoc_insertion_point(field_release:enterprise_management.BrowserReport.executable_path)
  if (!_internal_has_executable_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.executable_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.executable_path_.IsDefault()) {
    _impl_.executable_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BrowserReport::set_allocated_executable_path(std::string* executable_path) {
  if (executable_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.executable_path_.SetAllocated(executable_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.executable_path_.IsDefault()) {
    _impl_.executable_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserReport.executable_path)
}

// repeated .enterprise_management.ChromeUserProfileReport chrome_user_profile_reports = 4;
inline int BrowserReport::_internal_chrome_user_profile_reports_size() const {
  return _impl_.chrome_user_profile_reports_.size();
}
inline int BrowserReport::chrome_user_profile_reports_size() const {
  return _internal_chrome_user_profile_reports_size();
}
inline void BrowserReport::clear_chrome_user_profile_reports() {
  _impl_.chrome_user_profile_reports_.Clear();
}
inline ::enterprise_management::ChromeUserProfileReport* BrowserReport::mutable_chrome_user_profile_reports(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.chrome_user_profile_reports)
  return _impl_.chrome_user_profile_reports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport >*
BrowserReport::mutable_chrome_user_profile_reports() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.BrowserReport.chrome_user_profile_reports)
  return &_impl_.chrome_user_profile_reports_;
}
inline const ::enterprise_management::ChromeUserProfileReport& BrowserReport::_internal_chrome_user_profile_reports(int index) const {
  return _impl_.chrome_user_profile_reports_.Get(index);
}
inline const ::enterprise_management::ChromeUserProfileReport& BrowserReport::chrome_user_profile_reports(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.chrome_user_profile_reports)
  return _internal_chrome_user_profile_reports(index);
}
inline ::enterprise_management::ChromeUserProfileReport* BrowserReport::_internal_add_chrome_user_profile_reports() {
  return _impl_.chrome_user_profile_reports_.Add();
}
inline ::enterprise_management::ChromeUserProfileReport* BrowserReport::add_chrome_user_profile_reports() {
  ::enterprise_management::ChromeUserProfileReport* _add = _internal_add_chrome_user_profile_reports();
  // @@protoc_insertion_point(field_add:enterprise_management.BrowserReport.chrome_user_profile_reports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileReport >&
BrowserReport::chrome_user_profile_reports() const {
  // @@protoc_insertion_point(field_list:enterprise_management.BrowserReport.chrome_user_profile_reports)
  return _impl_.chrome_user_profile_reports_;
}

// repeated .enterprise_management.ChromeUserProfileInfo chrome_user_profile_infos = 6;
inline int BrowserReport::_internal_chrome_user_profile_infos_size() const {
  return _impl_.chrome_user_profile_infos_.size();
}
inline int BrowserReport::chrome_user_profile_infos_size() const {
  return _internal_chrome_user_profile_infos_size();
}
inline void BrowserReport::clear_chrome_user_profile_infos() {
  _impl_.chrome_user_profile_infos_.Clear();
}
inline ::enterprise_management::ChromeUserProfileInfo* BrowserReport::mutable_chrome_user_profile_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.chrome_user_profile_infos)
  return _impl_.chrome_user_profile_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo >*
BrowserReport::mutable_chrome_user_profile_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.BrowserReport.chrome_user_profile_infos)
  return &_impl_.chrome_user_profile_infos_;
}
inline const ::enterprise_management::ChromeUserProfileInfo& BrowserReport::_internal_chrome_user_profile_infos(int index) const {
  return _impl_.chrome_user_profile_infos_.Get(index);
}
inline const ::enterprise_management::ChromeUserProfileInfo& BrowserReport::chrome_user_profile_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.chrome_user_profile_infos)
  return _internal_chrome_user_profile_infos(index);
}
inline ::enterprise_management::ChromeUserProfileInfo* BrowserReport::_internal_add_chrome_user_profile_infos() {
  return _impl_.chrome_user_profile_infos_.Add();
}
inline ::enterprise_management::ChromeUserProfileInfo* BrowserReport::add_chrome_user_profile_infos() {
  ::enterprise_management::ChromeUserProfileInfo* _add = _internal_add_chrome_user_profile_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.BrowserReport.chrome_user_profile_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ChromeUserProfileInfo >&
BrowserReport::chrome_user_profile_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.BrowserReport.chrome_user_profile_infos)
  return _impl_.chrome_user_profile_infos_;
}

// repeated .enterprise_management.Plugin plugins = 7;
inline int BrowserReport::_internal_plugins_size() const {
  return _impl_.plugins_.size();
}
inline int BrowserReport::plugins_size() const {
  return _internal_plugins_size();
}
inline void BrowserReport::clear_plugins() {
  _impl_.plugins_.Clear();
}
inline ::enterprise_management::Plugin* BrowserReport::mutable_plugins(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.plugins)
  return _impl_.plugins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin >*
BrowserReport::mutable_plugins() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.BrowserReport.plugins)
  return &_impl_.plugins_;
}
inline const ::enterprise_management::Plugin& BrowserReport::_internal_plugins(int index) const {
  return _impl_.plugins_.Get(index);
}
inline const ::enterprise_management::Plugin& BrowserReport::plugins(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.plugins)
  return _internal_plugins(index);
}
inline ::enterprise_management::Plugin* BrowserReport::_internal_add_plugins() {
  return _impl_.plugins_.Add();
}
inline ::enterprise_management::Plugin* BrowserReport::add_plugins() {
  ::enterprise_management::Plugin* _add = _internal_add_plugins();
  // @@protoc_insertion_point(field_add:enterprise_management.BrowserReport.plugins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::Plugin >&
BrowserReport::plugins() const {
  // @@protoc_insertion_point(field_list:enterprise_management.BrowserReport.plugins)
  return _impl_.plugins_;
}

// optional string installed_browser_version = 8;
inline bool BrowserReport::_internal_has_installed_browser_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BrowserReport::has_installed_browser_version() const {
  return _internal_has_installed_browser_version();
}
inline void BrowserReport::clear_installed_browser_version() {
  _impl_.installed_browser_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BrowserReport::installed_browser_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.installed_browser_version)
  return _internal_installed_browser_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BrowserReport::set_installed_browser_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.installed_browser_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.installed_browser_version)
}
inline std::string* BrowserReport::mutable_installed_browser_version() {
  std::string* _s = _internal_mutable_installed_browser_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserReport.installed_browser_version)
  return _s;
}
inline const std::string& BrowserReport::_internal_installed_browser_version() const {
  return _impl_.installed_browser_version_.Get();
}
inline void BrowserReport::_internal_set_installed_browser_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.installed_browser_version_.Set(value, GetArenaForAllocation());
}
inline std::string* BrowserReport::_internal_mutable_installed_browser_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.installed_browser_version_.Mutable(GetArenaForAllocation());
}
inline std::string* BrowserReport::release_installed_browser_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.BrowserReport.installed_browser_version)
  if (!_internal_has_installed_browser_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.installed_browser_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.installed_browser_version_.IsDefault()) {
    _impl_.installed_browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BrowserReport::set_allocated_installed_browser_version(std::string* installed_browser_version) {
  if (installed_browser_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.installed_browser_version_.SetAllocated(installed_browser_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.installed_browser_version_.IsDefault()) {
    _impl_.installed_browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserReport.installed_browser_version)
}

// optional bool is_extended_stable_channel = 9 [default = false];
inline bool BrowserReport::_internal_has_is_extended_stable_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BrowserReport::has_is_extended_stable_channel() const {
  return _internal_has_is_extended_stable_channel();
}
inline void BrowserReport::clear_is_extended_stable_channel() {
  _impl_.is_extended_stable_channel_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool BrowserReport::_internal_is_extended_stable_channel() const {
  return _impl_.is_extended_stable_channel_;
}
inline bool BrowserReport::is_extended_stable_channel() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserReport.is_extended_stable_channel)
  return _internal_is_extended_stable_channel();
}
inline void BrowserReport::_internal_set_is_extended_stable_channel(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_extended_stable_channel_ = value;
}
inline void BrowserReport::set_is_extended_stable_channel(bool value) {
  _internal_set_is_extended_stable_channel(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserReport.is_extended_stable_channel)
}

// -------------------------------------------------------------------

// OSReport

// optional string name = 1;
inline bool OSReport::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OSReport::has_name() const {
  return _internal_has_name();
}
inline void OSReport::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OSReport::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OSReport.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSReport::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OSReport.name)
}
inline std::string* OSReport::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OSReport.name)
  return _s;
}
inline const std::string& OSReport::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OSReport::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OSReport::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OSReport::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.OSReport.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OSReport::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OSReport.name)
}

// optional string arch = 2;
inline bool OSReport::_internal_has_arch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OSReport::has_arch() const {
  return _internal_has_arch();
}
inline void OSReport::clear_arch() {
  _impl_.arch_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OSReport::arch() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OSReport.arch)
  return _internal_arch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSReport::set_arch(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.arch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OSReport.arch)
}
inline std::string* OSReport::mutable_arch() {
  std::string* _s = _internal_mutable_arch();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OSReport.arch)
  return _s;
}
inline const std::string& OSReport::_internal_arch() const {
  return _impl_.arch_.Get();
}
inline void OSReport::_internal_set_arch(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.arch_.Set(value, GetArenaForAllocation());
}
inline std::string* OSReport::_internal_mutable_arch() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.arch_.Mutable(GetArenaForAllocation());
}
inline std::string* OSReport::release_arch() {
  // @@protoc_insertion_point(field_release:enterprise_management.OSReport.arch)
  if (!_internal_has_arch()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.arch_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arch_.IsDefault()) {
    _impl_.arch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OSReport::set_allocated_arch(std::string* arch) {
  if (arch != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.arch_.SetAllocated(arch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arch_.IsDefault()) {
    _impl_.arch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OSReport.arch)
}

// optional string version = 3;
inline bool OSReport::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OSReport::has_version() const {
  return _internal_has_version();
}
inline void OSReport::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OSReport::version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OSReport.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSReport::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.OSReport.version)
}
inline std::string* OSReport::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.OSReport.version)
  return _s;
}
inline const std::string& OSReport::_internal_version() const {
  return _impl_.version_.Get();
}
inline void OSReport::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* OSReport::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* OSReport::release_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.OSReport.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OSReport::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.OSReport.version)
}

// optional .enterprise_management.OSReport.VersionType version_type = 4;
inline bool OSReport::_internal_has_version_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OSReport::has_version_type() const {
  return _internal_has_version_type();
}
inline void OSReport::clear_version_type() {
  _impl_.version_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::OSReport_VersionType OSReport::_internal_version_type() const {
  return static_cast< ::enterprise_management::OSReport_VersionType >(_impl_.version_type_);
}
inline ::enterprise_management::OSReport_VersionType OSReport::version_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.OSReport.version_type)
  return _internal_version_type();
}
inline void OSReport::_internal_set_version_type(::enterprise_management::OSReport_VersionType value) {
  assert(::enterprise_management::OSReport_VersionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.version_type_ = value;
}
inline void OSReport::set_version_type(::enterprise_management::OSReport_VersionType value) {
  _internal_set_version_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.OSReport.version_type)
}

// -------------------------------------------------------------------

// ChromeDesktopReportRequest

// optional string machine_name = 1 [deprecated = true];
inline bool ChromeDesktopReportRequest::_internal_has_machine_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_machine_name() const {
  return _internal_has_machine_name();
}
inline void ChromeDesktopReportRequest::clear_machine_name() {
  _impl_.machine_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeDesktopReportRequest::machine_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.machine_name)
  return _internal_machine_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_machine_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.machine_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.machine_name)
}
inline std::string* ChromeDesktopReportRequest::mutable_machine_name() {
  std::string* _s = _internal_mutable_machine_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.machine_name)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_machine_name() const {
  return _impl_.machine_name_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_machine_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.machine_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_machine_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.machine_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_machine_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.machine_name)
  if (!_internal_has_machine_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.machine_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_machine_name(std::string* machine_name) {
  if (machine_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.machine_name_.SetAllocated(machine_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.machine_name)
}

// optional string os_info = 2;
inline bool ChromeDesktopReportRequest::_internal_has_os_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_os_info() const {
  return _internal_has_os_info();
}
inline void ChromeDesktopReportRequest::clear_os_info() {
  _impl_.os_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeDesktopReportRequest::os_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.os_info)
  return _internal_os_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_os_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.os_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.os_info)
}
inline std::string* ChromeDesktopReportRequest::mutable_os_info() {
  std::string* _s = _internal_mutable_os_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.os_info)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_os_info() const {
  return _impl_.os_info_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_os_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.os_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_os_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.os_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_os_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.os_info)
  if (!_internal_has_os_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.os_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_info_.IsDefault()) {
    _impl_.os_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_os_info(std::string* os_info) {
  if (os_info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.os_info_.SetAllocated(os_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_info_.IsDefault()) {
    _impl_.os_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_info)
}

// optional string os_user = 3;
inline bool ChromeDesktopReportRequest::_internal_has_os_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_os_user() const {
  return _internal_has_os_user();
}
inline void ChromeDesktopReportRequest::clear_os_user() {
  _impl_.os_user_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ChromeDesktopReportRequest::os_user() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.os_user)
  return _internal_os_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_os_user(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.os_user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.os_user)
}
inline std::string* ChromeDesktopReportRequest::mutable_os_user() {
  std::string* _s = _internal_mutable_os_user();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.os_user)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_os_user() const {
  return _impl_.os_user_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_os_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.os_user_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_os_user() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.os_user_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_os_user() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.os_user)
  if (!_internal_has_os_user()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.os_user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_user_.IsDefault()) {
    _impl_.os_user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_os_user(std::string* os_user) {
  if (os_user != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.os_user_.SetAllocated(os_user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_user_.IsDefault()) {
    _impl_.os_user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_user)
}

// optional .enterprise_management.BrowserReport browser_report = 4;
inline bool ChromeDesktopReportRequest::_internal_has_browser_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_report_ != nullptr);
  return value;
}
inline bool ChromeDesktopReportRequest::has_browser_report() const {
  return _internal_has_browser_report();
}
inline void ChromeDesktopReportRequest::clear_browser_report() {
  if (_impl_.browser_report_ != nullptr) _impl_.browser_report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::enterprise_management::BrowserReport& ChromeDesktopReportRequest::_internal_browser_report() const {
  const ::enterprise_management::BrowserReport* p = _impl_.browser_report_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserReport&>(
      ::enterprise_management::_BrowserReport_default_instance_);
}
inline const ::enterprise_management::BrowserReport& ChromeDesktopReportRequest::browser_report() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.browser_report)
  return _internal_browser_report();
}
inline void ChromeDesktopReportRequest::unsafe_arena_set_allocated_browser_report(
    ::enterprise_management::BrowserReport* browser_report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_report_);
  }
  _impl_.browser_report_ = browser_report;
  if (browser_report) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDesktopReportRequest.browser_report)
}
inline ::enterprise_management::BrowserReport* ChromeDesktopReportRequest::release_browser_report() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::BrowserReport* temp = _impl_.browser_report_;
  _impl_.browser_report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserReport* ChromeDesktopReportRequest::unsafe_arena_release_browser_report() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.browser_report)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::BrowserReport* temp = _impl_.browser_report_;
  _impl_.browser_report_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserReport* ChromeDesktopReportRequest::_internal_mutable_browser_report() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.browser_report_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserReport>(GetArenaForAllocation());
    _impl_.browser_report_ = p;
  }
  return _impl_.browser_report_;
}
inline ::enterprise_management::BrowserReport* ChromeDesktopReportRequest::mutable_browser_report() {
  ::enterprise_management::BrowserReport* _msg = _internal_mutable_browser_report();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.browser_report)
  return _msg;
}
inline void ChromeDesktopReportRequest::set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_report_;
  }
  if (browser_report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_report);
    if (message_arena != submessage_arena) {
      browser_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_report, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.browser_report_ = browser_report;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.browser_report)
}

// optional string serial_number = 5 [deprecated = true];
inline bool ChromeDesktopReportRequest::_internal_has_serial_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_serial_number() const {
  return _internal_has_serial_number();
}
inline void ChromeDesktopReportRequest::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ChromeDesktopReportRequest::serial_number() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_serial_number(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.serial_number)
}
inline std::string* ChromeDesktopReportRequest::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.serial_number)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_serial_number(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_serial_number() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_serial_number() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.serial_number)
  if (!_internal_has_serial_number()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.serial_number_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.serial_number)
}

// optional string computer_name = 6 [deprecated = true];
inline bool ChromeDesktopReportRequest::_internal_has_computer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_computer_name() const {
  return _internal_has_computer_name();
}
inline void ChromeDesktopReportRequest::clear_computer_name() {
  _impl_.computer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ChromeDesktopReportRequest::computer_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.computer_name)
  return _internal_computer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_computer_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.computer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.computer_name)
}
inline std::string* ChromeDesktopReportRequest::mutable_computer_name() {
  std::string* _s = _internal_mutable_computer_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.computer_name)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_computer_name() const {
  return _impl_.computer_name_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_computer_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.computer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_computer_name() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.computer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_computer_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.computer_name)
  if (!_internal_has_computer_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.computer_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.computer_name_.IsDefault()) {
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_computer_name(std::string* computer_name) {
  if (computer_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.computer_name_.SetAllocated(computer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.computer_name_.IsDefault()) {
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.computer_name)
}

// optional .enterprise_management.OSReport os_report = 7;
inline bool ChromeDesktopReportRequest::_internal_has_os_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.os_report_ != nullptr);
  return value;
}
inline bool ChromeDesktopReportRequest::has_os_report() const {
  return _internal_has_os_report();
}
inline void ChromeDesktopReportRequest::clear_os_report() {
  if (_impl_.os_report_ != nullptr) _impl_.os_report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::OSReport& ChromeDesktopReportRequest::_internal_os_report() const {
  const ::enterprise_management::OSReport* p = _impl_.os_report_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OSReport&>(
      ::enterprise_management::_OSReport_default_instance_);
}
inline const ::enterprise_management::OSReport& ChromeDesktopReportRequest::os_report() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.os_report)
  return _internal_os_report();
}
inline void ChromeDesktopReportRequest::unsafe_arena_set_allocated_os_report(
    ::enterprise_management::OSReport* os_report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.os_report_);
  }
  _impl_.os_report_ = os_report;
  if (os_report) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_report)
}
inline ::enterprise_management::OSReport* ChromeDesktopReportRequest::release_os_report() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::OSReport* temp = _impl_.os_report_;
  _impl_.os_report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OSReport* ChromeDesktopReportRequest::unsafe_arena_release_os_report() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.os_report)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::OSReport* temp = _impl_.os_report_;
  _impl_.os_report_ = nullptr;
  return temp;
}
inline ::enterprise_management::OSReport* ChromeDesktopReportRequest::_internal_mutable_os_report() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.os_report_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OSReport>(GetArenaForAllocation());
    _impl_.os_report_ = p;
  }
  return _impl_.os_report_;
}
inline ::enterprise_management::OSReport* ChromeDesktopReportRequest::mutable_os_report() {
  ::enterprise_management::OSReport* _msg = _internal_mutable_os_report();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.os_report)
  return _msg;
}
inline void ChromeDesktopReportRequest::set_allocated_os_report(::enterprise_management::OSReport* os_report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.os_report_;
  }
  if (os_report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(os_report);
    if (message_arena != submessage_arena) {
      os_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, os_report, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.os_report_ = os_report;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_report)
}

// optional string os_user_name = 8;
inline bool ChromeDesktopReportRequest::_internal_has_os_user_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_os_user_name() const {
  return _internal_has_os_user_name();
}
inline void ChromeDesktopReportRequest::clear_os_user_name() {
  _impl_.os_user_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ChromeDesktopReportRequest::os_user_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.os_user_name)
  return _internal_os_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_os_user_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.os_user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.os_user_name)
}
inline std::string* ChromeDesktopReportRequest::mutable_os_user_name() {
  std::string* _s = _internal_mutable_os_user_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.os_user_name)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_os_user_name() const {
  return _impl_.os_user_name_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_os_user_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.os_user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_os_user_name() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.os_user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_os_user_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.os_user_name)
  if (!_internal_has_os_user_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.os_user_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_user_name_.IsDefault()) {
    _impl_.os_user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_os_user_name(std::string* os_user_name) {
  if (os_user_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.os_user_name_.SetAllocated(os_user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_user_name_.IsDefault()) {
    _impl_.os_user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.os_user_name)
}

// optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 9;
inline bool ChromeDesktopReportRequest::_internal_has_browser_device_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_device_identifier_ != nullptr);
  return value;
}
inline bool ChromeDesktopReportRequest::has_browser_device_identifier() const {
  return _internal_has_browser_device_identifier();
}
inline void ChromeDesktopReportRequest::clear_browser_device_identifier() {
  if (_impl_.browser_device_identifier_ != nullptr) _impl_.browser_device_identifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::BrowserDeviceIdentifier& ChromeDesktopReportRequest::_internal_browser_device_identifier() const {
  const ::enterprise_management::BrowserDeviceIdentifier* p = _impl_.browser_device_identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserDeviceIdentifier&>(
      ::enterprise_management::_BrowserDeviceIdentifier_default_instance_);
}
inline const ::enterprise_management::BrowserDeviceIdentifier& ChromeDesktopReportRequest::browser_device_identifier() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.browser_device_identifier)
  return _internal_browser_device_identifier();
}
inline void ChromeDesktopReportRequest::unsafe_arena_set_allocated_browser_device_identifier(
    ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_device_identifier_);
  }
  _impl_.browser_device_identifier_ = browser_device_identifier;
  if (browser_device_identifier) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeDesktopReportRequest.browser_device_identifier)
}
inline ::enterprise_management::BrowserDeviceIdentifier* ChromeDesktopReportRequest::release_browser_device_identifier() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::BrowserDeviceIdentifier* temp = _impl_.browser_device_identifier_;
  _impl_.browser_device_identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserDeviceIdentifier* ChromeDesktopReportRequest::unsafe_arena_release_browser_device_identifier() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.browser_device_identifier)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::BrowserDeviceIdentifier* temp = _impl_.browser_device_identifier_;
  _impl_.browser_device_identifier_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserDeviceIdentifier* ChromeDesktopReportRequest::_internal_mutable_browser_device_identifier() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.browser_device_identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserDeviceIdentifier>(GetArenaForAllocation());
    _impl_.browser_device_identifier_ = p;
  }
  return _impl_.browser_device_identifier_;
}
inline ::enterprise_management::BrowserDeviceIdentifier* ChromeDesktopReportRequest::mutable_browser_device_identifier() {
  ::enterprise_management::BrowserDeviceIdentifier* _msg = _internal_mutable_browser_device_identifier();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.browser_device_identifier)
  return _msg;
}
inline void ChromeDesktopReportRequest::set_allocated_browser_device_identifier(::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_device_identifier_;
  }
  if (browser_device_identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_device_identifier);
    if (message_arena != submessage_arena) {
      browser_device_identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_device_identifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.browser_device_identifier_ = browser_device_identifier;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.browser_device_identifier)
}

// repeated .enterprise_management.PartialReportType partial_report_types = 10;
inline int ChromeDesktopReportRequest::_internal_partial_report_types_size() const {
  return _impl_.partial_report_types_.size();
}
inline int ChromeDesktopReportRequest::partial_report_types_size() const {
  return _internal_partial_report_types_size();
}
inline void ChromeDesktopReportRequest::clear_partial_report_types() {
  _impl_.partial_report_types_.Clear();
}
inline ::enterprise_management::PartialReportType ChromeDesktopReportRequest::_internal_partial_report_types(int index) const {
  return static_cast< ::enterprise_management::PartialReportType >(_impl_.partial_report_types_.Get(index));
}
inline ::enterprise_management::PartialReportType ChromeDesktopReportRequest::partial_report_types(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.partial_report_types)
  return _internal_partial_report_types(index);
}
inline void ChromeDesktopReportRequest::set_partial_report_types(int index, ::enterprise_management::PartialReportType value) {
  assert(::enterprise_management::PartialReportType_IsValid(value));
  _impl_.partial_report_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.partial_report_types)
}
inline void ChromeDesktopReportRequest::_internal_add_partial_report_types(::enterprise_management::PartialReportType value) {
  assert(::enterprise_management::PartialReportType_IsValid(value));
  _impl_.partial_report_types_.Add(value);
}
inline void ChromeDesktopReportRequest::add_partial_report_types(::enterprise_management::PartialReportType value) {
  _internal_add_partial_report_types(value);
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeDesktopReportRequest.partial_report_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ChromeDesktopReportRequest::partial_report_types() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeDesktopReportRequest.partial_report_types)
  return _impl_.partial_report_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ChromeDesktopReportRequest::_internal_mutable_partial_report_types() {
  return &_impl_.partial_report_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ChromeDesktopReportRequest::mutable_partial_report_types() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeDesktopReportRequest.partial_report_types)
  return _internal_mutable_partial_report_types();
}

// optional string machine_attestation_key = 11;
inline bool ChromeDesktopReportRequest::_internal_has_machine_attestation_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_machine_attestation_key() const {
  return _internal_has_machine_attestation_key();
}
inline void ChromeDesktopReportRequest::clear_machine_attestation_key() {
  _impl_.machine_attestation_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ChromeDesktopReportRequest::machine_attestation_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.machine_attestation_key)
  return _internal_machine_attestation_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_machine_attestation_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.machine_attestation_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.machine_attestation_key)
}
inline std::string* ChromeDesktopReportRequest::mutable_machine_attestation_key() {
  std::string* _s = _internal_mutable_machine_attestation_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.machine_attestation_key)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_machine_attestation_key() const {
  return _impl_.machine_attestation_key_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_machine_attestation_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.machine_attestation_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_machine_attestation_key() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.machine_attestation_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_machine_attestation_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.machine_attestation_key)
  if (!_internal_has_machine_attestation_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.machine_attestation_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_attestation_key_.IsDefault()) {
    _impl_.machine_attestation_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_machine_attestation_key(std::string* machine_attestation_key) {
  if (machine_attestation_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.machine_attestation_key_.SetAllocated(machine_attestation_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_attestation_key_.IsDefault()) {
    _impl_.machine_attestation_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.machine_attestation_key)
}

// optional string device_model = 12;
inline bool ChromeDesktopReportRequest::_internal_has_device_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_device_model() const {
  return _internal_has_device_model();
}
inline void ChromeDesktopReportRequest::clear_device_model() {
  _impl_.device_model_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ChromeDesktopReportRequest::device_model() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.device_model)
  return _internal_device_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_device_model(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.device_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.device_model)
}
inline std::string* ChromeDesktopReportRequest::mutable_device_model() {
  std::string* _s = _internal_mutable_device_model();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.device_model)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_device_model() const {
  return _impl_.device_model_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_device_model(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.device_model_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_device_model() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.device_model_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_device_model() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.device_model)
  if (!_internal_has_device_model()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.device_model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_model_.IsDefault()) {
    _impl_.device_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_device_model(std::string* device_model) {
  if (device_model != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.device_model_.SetAllocated(device_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_model_.IsDefault()) {
    _impl_.device_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.device_model)
}

// optional string brand_name = 13;
inline bool ChromeDesktopReportRequest::_internal_has_brand_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ChromeDesktopReportRequest::has_brand_name() const {
  return _internal_has_brand_name();
}
inline void ChromeDesktopReportRequest::clear_brand_name() {
  _impl_.brand_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ChromeDesktopReportRequest::brand_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeDesktopReportRequest.brand_name)
  return _internal_brand_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeDesktopReportRequest::set_brand_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.brand_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeDesktopReportRequest.brand_name)
}
inline std::string* ChromeDesktopReportRequest::mutable_brand_name() {
  std::string* _s = _internal_mutable_brand_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeDesktopReportRequest.brand_name)
  return _s;
}
inline const std::string& ChromeDesktopReportRequest::_internal_brand_name() const {
  return _impl_.brand_name_.Get();
}
inline void ChromeDesktopReportRequest::_internal_set_brand_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.brand_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::_internal_mutable_brand_name() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.brand_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeDesktopReportRequest::release_brand_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeDesktopReportRequest.brand_name)
  if (!_internal_has_brand_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.brand_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brand_name_.IsDefault()) {
    _impl_.brand_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeDesktopReportRequest::set_allocated_brand_name(std::string* brand_name) {
  if (brand_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.brand_name_.SetAllocated(brand_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brand_name_.IsDefault()) {
    _impl_.brand_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeDesktopReportRequest.brand_name)
}

// -------------------------------------------------------------------

// ChromeOsUserReportRequest

// optional .enterprise_management.BrowserReport browser_report = 1;
inline bool ChromeOsUserReportRequest::_internal_has_browser_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_report_ != nullptr);
  return value;
}
inline bool ChromeOsUserReportRequest::has_browser_report() const {
  return _internal_has_browser_report();
}
inline void ChromeOsUserReportRequest::clear_browser_report() {
  if (_impl_.browser_report_ != nullptr) _impl_.browser_report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::BrowserReport& ChromeOsUserReportRequest::_internal_browser_report() const {
  const ::enterprise_management::BrowserReport* p = _impl_.browser_report_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserReport&>(
      ::enterprise_management::_BrowserReport_default_instance_);
}
inline const ::enterprise_management::BrowserReport& ChromeOsUserReportRequest::browser_report() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeOsUserReportRequest.browser_report)
  return _internal_browser_report();
}
inline void ChromeOsUserReportRequest::unsafe_arena_set_allocated_browser_report(
    ::enterprise_management::BrowserReport* browser_report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_report_);
  }
  _impl_.browser_report_ = browser_report;
  if (browser_report) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeOsUserReportRequest.browser_report)
}
inline ::enterprise_management::BrowserReport* ChromeOsUserReportRequest::release_browser_report() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::BrowserReport* temp = _impl_.browser_report_;
  _impl_.browser_report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserReport* ChromeOsUserReportRequest::unsafe_arena_release_browser_report() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeOsUserReportRequest.browser_report)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::BrowserReport* temp = _impl_.browser_report_;
  _impl_.browser_report_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserReport* ChromeOsUserReportRequest::_internal_mutable_browser_report() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.browser_report_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserReport>(GetArenaForAllocation());
    _impl_.browser_report_ = p;
  }
  return _impl_.browser_report_;
}
inline ::enterprise_management::BrowserReport* ChromeOsUserReportRequest::mutable_browser_report() {
  ::enterprise_management::BrowserReport* _msg = _internal_mutable_browser_report();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeOsUserReportRequest.browser_report)
  return _msg;
}
inline void ChromeOsUserReportRequest::set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_report_;
  }
  if (browser_report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_report);
    if (message_arena != submessage_arena) {
      browser_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_report, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.browser_report_ = browser_report;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeOsUserReportRequest.browser_report)
}

// repeated .enterprise_management.AndroidAppInfo android_app_infos = 2;
inline int ChromeOsUserReportRequest::_internal_android_app_infos_size() const {
  return _impl_.android_app_infos_.size();
}
inline int ChromeOsUserReportRequest::android_app_infos_size() const {
  return _internal_android_app_infos_size();
}
inline void ChromeOsUserReportRequest::clear_android_app_infos() {
  _impl_.android_app_infos_.Clear();
}
inline ::enterprise_management::AndroidAppInfo* ChromeOsUserReportRequest::mutable_android_app_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
  return _impl_.android_app_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo >*
ChromeOsUserReportRequest::mutable_android_app_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
  return &_impl_.android_app_infos_;
}
inline const ::enterprise_management::AndroidAppInfo& ChromeOsUserReportRequest::_internal_android_app_infos(int index) const {
  return _impl_.android_app_infos_.Get(index);
}
inline const ::enterprise_management::AndroidAppInfo& ChromeOsUserReportRequest::android_app_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
  return _internal_android_app_infos(index);
}
inline ::enterprise_management::AndroidAppInfo* ChromeOsUserReportRequest::_internal_add_android_app_infos() {
  return _impl_.android_app_infos_.Add();
}
inline ::enterprise_management::AndroidAppInfo* ChromeOsUserReportRequest::add_android_app_infos() {
  ::enterprise_management::AndroidAppInfo* _add = _internal_add_android_app_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AndroidAppInfo >&
ChromeOsUserReportRequest::android_app_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeOsUserReportRequest.android_app_infos)
  return _impl_.android_app_infos_;
}

// repeated .enterprise_management.PartialReportType partial_report_types = 3;
inline int ChromeOsUserReportRequest::_internal_partial_report_types_size() const {
  return _impl_.partial_report_types_.size();
}
inline int ChromeOsUserReportRequest::partial_report_types_size() const {
  return _internal_partial_report_types_size();
}
inline void ChromeOsUserReportRequest::clear_partial_report_types() {
  _impl_.partial_report_types_.Clear();
}
inline ::enterprise_management::PartialReportType ChromeOsUserReportRequest::_internal_partial_report_types(int index) const {
  return static_cast< ::enterprise_management::PartialReportType >(_impl_.partial_report_types_.Get(index));
}
inline ::enterprise_management::PartialReportType ChromeOsUserReportRequest::partial_report_types(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeOsUserReportRequest.partial_report_types)
  return _internal_partial_report_types(index);
}
inline void ChromeOsUserReportRequest::set_partial_report_types(int index, ::enterprise_management::PartialReportType value) {
  assert(::enterprise_management::PartialReportType_IsValid(value));
  _impl_.partial_report_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:enterprise_management.ChromeOsUserReportRequest.partial_report_types)
}
inline void ChromeOsUserReportRequest::_internal_add_partial_report_types(::enterprise_management::PartialReportType value) {
  assert(::enterprise_management::PartialReportType_IsValid(value));
  _impl_.partial_report_types_.Add(value);
}
inline void ChromeOsUserReportRequest::add_partial_report_types(::enterprise_management::PartialReportType value) {
  _internal_add_partial_report_types(value);
  // @@protoc_insertion_point(field_add:enterprise_management.ChromeOsUserReportRequest.partial_report_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ChromeOsUserReportRequest::partial_report_types() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChromeOsUserReportRequest.partial_report_types)
  return _impl_.partial_report_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ChromeOsUserReportRequest::_internal_mutable_partial_report_types() {
  return &_impl_.partial_report_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ChromeOsUserReportRequest::mutable_partial_report_types() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChromeOsUserReportRequest.partial_report_types)
  return _internal_mutable_partial_report_types();
}

// -------------------------------------------------------------------

// ChromeProfileReportRequest

// optional .enterprise_management.BrowserReport browser_report = 1;
inline bool ChromeProfileReportRequest::_internal_has_browser_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_report_ != nullptr);
  return value;
}
inline bool ChromeProfileReportRequest::has_browser_report() const {
  return _internal_has_browser_report();
}
inline void ChromeProfileReportRequest::clear_browser_report() {
  if (_impl_.browser_report_ != nullptr) _impl_.browser_report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::BrowserReport& ChromeProfileReportRequest::_internal_browser_report() const {
  const ::enterprise_management::BrowserReport* p = _impl_.browser_report_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserReport&>(
      ::enterprise_management::_BrowserReport_default_instance_);
}
inline const ::enterprise_management::BrowserReport& ChromeProfileReportRequest::browser_report() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeProfileReportRequest.browser_report)
  return _internal_browser_report();
}
inline void ChromeProfileReportRequest::unsafe_arena_set_allocated_browser_report(
    ::enterprise_management::BrowserReport* browser_report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_report_);
  }
  _impl_.browser_report_ = browser_report;
  if (browser_report) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeProfileReportRequest.browser_report)
}
inline ::enterprise_management::BrowserReport* ChromeProfileReportRequest::release_browser_report() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::BrowserReport* temp = _impl_.browser_report_;
  _impl_.browser_report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserReport* ChromeProfileReportRequest::unsafe_arena_release_browser_report() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeProfileReportRequest.browser_report)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::BrowserReport* temp = _impl_.browser_report_;
  _impl_.browser_report_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserReport* ChromeProfileReportRequest::_internal_mutable_browser_report() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.browser_report_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserReport>(GetArenaForAllocation());
    _impl_.browser_report_ = p;
  }
  return _impl_.browser_report_;
}
inline ::enterprise_management::BrowserReport* ChromeProfileReportRequest::mutable_browser_report() {
  ::enterprise_management::BrowserReport* _msg = _internal_mutable_browser_report();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeProfileReportRequest.browser_report)
  return _msg;
}
inline void ChromeProfileReportRequest::set_allocated_browser_report(::enterprise_management::BrowserReport* browser_report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_report_;
  }
  if (browser_report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_report);
    if (message_arena != submessage_arena) {
      browser_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_report, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.browser_report_ = browser_report;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeProfileReportRequest.browser_report)
}

// optional .enterprise_management.OSReport os_report = 2;
inline bool ChromeProfileReportRequest::_internal_has_os_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.os_report_ != nullptr);
  return value;
}
inline bool ChromeProfileReportRequest::has_os_report() const {
  return _internal_has_os_report();
}
inline void ChromeProfileReportRequest::clear_os_report() {
  if (_impl_.os_report_ != nullptr) _impl_.os_report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::OSReport& ChromeProfileReportRequest::_internal_os_report() const {
  const ::enterprise_management::OSReport* p = _impl_.os_report_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::OSReport&>(
      ::enterprise_management::_OSReport_default_instance_);
}
inline const ::enterprise_management::OSReport& ChromeProfileReportRequest::os_report() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChromeProfileReportRequest.os_report)
  return _internal_os_report();
}
inline void ChromeProfileReportRequest::unsafe_arena_set_allocated_os_report(
    ::enterprise_management::OSReport* os_report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.os_report_);
  }
  _impl_.os_report_ = os_report;
  if (os_report) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChromeProfileReportRequest.os_report)
}
inline ::enterprise_management::OSReport* ChromeProfileReportRequest::release_os_report() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::OSReport* temp = _impl_.os_report_;
  _impl_.os_report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::OSReport* ChromeProfileReportRequest::unsafe_arena_release_os_report() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChromeProfileReportRequest.os_report)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::OSReport* temp = _impl_.os_report_;
  _impl_.os_report_ = nullptr;
  return temp;
}
inline ::enterprise_management::OSReport* ChromeProfileReportRequest::_internal_mutable_os_report() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.os_report_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::OSReport>(GetArenaForAllocation());
    _impl_.os_report_ = p;
  }
  return _impl_.os_report_;
}
inline ::enterprise_management::OSReport* ChromeProfileReportRequest::mutable_os_report() {
  ::enterprise_management::OSReport* _msg = _internal_mutable_os_report();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChromeProfileReportRequest.os_report)
  return _msg;
}
inline void ChromeProfileReportRequest::set_allocated_os_report(::enterprise_management::OSReport* os_report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.os_report_;
  }
  if (os_report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(os_report);
    if (message_arena != submessage_arena) {
      os_report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, os_report, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.os_report_ = os_report;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChromeProfileReportRequest.os_report)
}

// -------------------------------------------------------------------

// PolicyValueValidationIssue

// optional string policy_name = 1;
inline bool PolicyValueValidationIssue::_internal_has_policy_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolicyValueValidationIssue::has_policy_name() const {
  return _internal_has_policy_name();
}
inline void PolicyValueValidationIssue::clear_policy_name() {
  _impl_.policy_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyValueValidationIssue::policy_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyValueValidationIssue.policy_name)
  return _internal_policy_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyValueValidationIssue::set_policy_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyValueValidationIssue.policy_name)
}
inline std::string* PolicyValueValidationIssue::mutable_policy_name() {
  std::string* _s = _internal_mutable_policy_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValueValidationIssue.policy_name)
  return _s;
}
inline const std::string& PolicyValueValidationIssue::_internal_policy_name() const {
  return _impl_.policy_name_.Get();
}
inline void PolicyValueValidationIssue::_internal_set_policy_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyValueValidationIssue::_internal_mutable_policy_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyValueValidationIssue::release_policy_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyValueValidationIssue.policy_name)
  if (!_internal_has_policy_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_name_.IsDefault()) {
    _impl_.policy_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyValueValidationIssue::set_allocated_policy_name(std::string* policy_name) {
  if (policy_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_name_.SetAllocated(policy_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_name_.IsDefault()) {
    _impl_.policy_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyValueValidationIssue.policy_name)
}

// optional .enterprise_management.PolicyValueValidationIssue.ValueValidationIssueSeverity severity = 2;
inline bool PolicyValueValidationIssue::_internal_has_severity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PolicyValueValidationIssue::has_severity() const {
  return _internal_has_severity();
}
inline void PolicyValueValidationIssue::clear_severity() {
  _impl_.severity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue::_internal_severity() const {
  return static_cast< ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity >(_impl_.severity_);
}
inline ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue::severity() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyValueValidationIssue.severity)
  return _internal_severity();
}
inline void PolicyValueValidationIssue::_internal_set_severity(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity value) {
  assert(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.severity_ = value;
}
inline void PolicyValueValidationIssue::set_severity(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyValueValidationIssue.severity)
}

// optional string debug_message = 3;
inline bool PolicyValueValidationIssue::_internal_has_debug_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PolicyValueValidationIssue::has_debug_message() const {
  return _internal_has_debug_message();
}
inline void PolicyValueValidationIssue::clear_debug_message() {
  _impl_.debug_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyValueValidationIssue::debug_message() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyValueValidationIssue.debug_message)
  return _internal_debug_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyValueValidationIssue::set_debug_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.debug_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyValueValidationIssue.debug_message)
}
inline std::string* PolicyValueValidationIssue::mutable_debug_message() {
  std::string* _s = _internal_mutable_debug_message();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValueValidationIssue.debug_message)
  return _s;
}
inline const std::string& PolicyValueValidationIssue::_internal_debug_message() const {
  return _impl_.debug_message_.Get();
}
inline void PolicyValueValidationIssue::_internal_set_debug_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.debug_message_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyValueValidationIssue::_internal_mutable_debug_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.debug_message_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyValueValidationIssue::release_debug_message() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyValueValidationIssue.debug_message)
  if (!_internal_has_debug_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.debug_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.debug_message_.IsDefault()) {
    _impl_.debug_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyValueValidationIssue::set_allocated_debug_message(std::string* debug_message) {
  if (debug_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.debug_message_.SetAllocated(debug_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.debug_message_.IsDefault()) {
    _impl_.debug_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyValueValidationIssue.debug_message)
}

// -------------------------------------------------------------------

// PolicyValidationReportRequest

// optional string policy_type = 1;
inline bool PolicyValidationReportRequest::_internal_has_policy_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolicyValidationReportRequest::has_policy_type() const {
  return _internal_has_policy_type();
}
inline void PolicyValidationReportRequest::clear_policy_type() {
  _impl_.policy_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyValidationReportRequest::policy_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyValidationReportRequest.policy_type)
  return _internal_policy_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyValidationReportRequest::set_policy_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyValidationReportRequest.policy_type)
}
inline std::string* PolicyValidationReportRequest::mutable_policy_type() {
  std::string* _s = _internal_mutable_policy_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValidationReportRequest.policy_type)
  return _s;
}
inline const std::string& PolicyValidationReportRequest::_internal_policy_type() const {
  return _impl_.policy_type_.Get();
}
inline void PolicyValidationReportRequest::_internal_set_policy_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyValidationReportRequest::_internal_mutable_policy_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_type_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyValidationReportRequest::release_policy_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyValidationReportRequest.policy_type)
  if (!_internal_has_policy_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_type_.IsDefault()) {
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyValidationReportRequest::set_allocated_policy_type(std::string* policy_type) {
  if (policy_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_type_.SetAllocated(policy_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_type_.IsDefault()) {
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyValidationReportRequest.policy_type)
}

// optional string policy_token = 2;
inline bool PolicyValidationReportRequest::_internal_has_policy_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PolicyValidationReportRequest::has_policy_token() const {
  return _internal_has_policy_token();
}
inline void PolicyValidationReportRequest::clear_policy_token() {
  _impl_.policy_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PolicyValidationReportRequest::policy_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyValidationReportRequest.policy_token)
  return _internal_policy_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyValidationReportRequest::set_policy_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.policy_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyValidationReportRequest.policy_token)
}
inline std::string* PolicyValidationReportRequest::mutable_policy_token() {
  std::string* _s = _internal_mutable_policy_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValidationReportRequest.policy_token)
  return _s;
}
inline const std::string& PolicyValidationReportRequest::_internal_policy_token() const {
  return _impl_.policy_token_.Get();
}
inline void PolicyValidationReportRequest::_internal_set_policy_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.policy_token_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyValidationReportRequest::_internal_mutable_policy_token() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.policy_token_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyValidationReportRequest::release_policy_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.PolicyValidationReportRequest.policy_token)
  if (!_internal_has_policy_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.policy_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_token_.IsDefault()) {
    _impl_.policy_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PolicyValidationReportRequest::set_allocated_policy_token(std::string* policy_token) {
  if (policy_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.policy_token_.SetAllocated(policy_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_token_.IsDefault()) {
    _impl_.policy_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PolicyValidationReportRequest.policy_token)
}

// optional .enterprise_management.PolicyValidationReportRequest.ValidationResultType validation_result_type = 3;
inline bool PolicyValidationReportRequest::_internal_has_validation_result_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PolicyValidationReportRequest::has_validation_result_type() const {
  return _internal_has_validation_result_type();
}
inline void PolicyValidationReportRequest::clear_validation_result_type() {
  _impl_.validation_result_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::_internal_validation_result_type() const {
  return static_cast< ::enterprise_management::PolicyValidationReportRequest_ValidationResultType >(_impl_.validation_result_type_);
}
inline ::enterprise_management::PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::validation_result_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyValidationReportRequest.validation_result_type)
  return _internal_validation_result_type();
}
inline void PolicyValidationReportRequest::_internal_set_validation_result_type(::enterprise_management::PolicyValidationReportRequest_ValidationResultType value) {
  assert(::enterprise_management::PolicyValidationReportRequest_ValidationResultType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.validation_result_type_ = value;
}
inline void PolicyValidationReportRequest::set_validation_result_type(::enterprise_management::PolicyValidationReportRequest_ValidationResultType value) {
  _internal_set_validation_result_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PolicyValidationReportRequest.validation_result_type)
}

// repeated .enterprise_management.PolicyValueValidationIssue policy_value_validation_issues = 4;
inline int PolicyValidationReportRequest::_internal_policy_value_validation_issues_size() const {
  return _impl_.policy_value_validation_issues_.size();
}
inline int PolicyValidationReportRequest::policy_value_validation_issues_size() const {
  return _internal_policy_value_validation_issues_size();
}
inline void PolicyValidationReportRequest::clear_policy_value_validation_issues() {
  _impl_.policy_value_validation_issues_.Clear();
}
inline ::enterprise_management::PolicyValueValidationIssue* PolicyValidationReportRequest::mutable_policy_value_validation_issues(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
  return _impl_.policy_value_validation_issues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue >*
PolicyValidationReportRequest::mutable_policy_value_validation_issues() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
  return &_impl_.policy_value_validation_issues_;
}
inline const ::enterprise_management::PolicyValueValidationIssue& PolicyValidationReportRequest::_internal_policy_value_validation_issues(int index) const {
  return _impl_.policy_value_validation_issues_.Get(index);
}
inline const ::enterprise_management::PolicyValueValidationIssue& PolicyValidationReportRequest::policy_value_validation_issues(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
  return _internal_policy_value_validation_issues(index);
}
inline ::enterprise_management::PolicyValueValidationIssue* PolicyValidationReportRequest::_internal_add_policy_value_validation_issues() {
  return _impl_.policy_value_validation_issues_.Add();
}
inline ::enterprise_management::PolicyValueValidationIssue* PolicyValidationReportRequest::add_policy_value_validation_issues() {
  ::enterprise_management::PolicyValueValidationIssue* _add = _internal_add_policy_value_validation_issues();
  // @@protoc_insertion_point(field_add:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::PolicyValueValidationIssue >&
PolicyValidationReportRequest::policy_value_validation_issues() const {
  // @@protoc_insertion_point(field_list:enterprise_management.PolicyValidationReportRequest.policy_value_validation_issues)
  return _impl_.policy_value_validation_issues_;
}

// -------------------------------------------------------------------

// PolicyValidationReportResponse

// -------------------------------------------------------------------

// AndroidStatus

// optional string status_payload = 1;
inline bool AndroidStatus::_internal_has_status_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AndroidStatus::has_status_payload() const {
  return _internal_has_status_payload();
}
inline void AndroidStatus::clear_status_payload() {
  _impl_.status_payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AndroidStatus::status_payload() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidStatus.status_payload)
  return _internal_status_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidStatus::set_status_payload(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.status_payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidStatus.status_payload)
}
inline std::string* AndroidStatus::mutable_status_payload() {
  std::string* _s = _internal_mutable_status_payload();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidStatus.status_payload)
  return _s;
}
inline const std::string& AndroidStatus::_internal_status_payload() const {
  return _impl_.status_payload_.Get();
}
inline void AndroidStatus::_internal_set_status_payload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidStatus::_internal_mutable_status_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.status_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidStatus::release_status_payload() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidStatus.status_payload)
  if (!_internal_has_status_payload()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.status_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_payload_.IsDefault()) {
    _impl_.status_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidStatus::set_allocated_status_payload(std::string* status_payload) {
  if (status_payload != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.status_payload_.SetAllocated(status_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_payload_.IsDefault()) {
    _impl_.status_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidStatus.status_payload)
}

// optional string droid_guard_info = 2;
inline bool AndroidStatus::_internal_has_droid_guard_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AndroidStatus::has_droid_guard_info() const {
  return _internal_has_droid_guard_info();
}
inline void AndroidStatus::clear_droid_guard_info() {
  _impl_.droid_guard_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AndroidStatus::droid_guard_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AndroidStatus.droid_guard_info)
  return _internal_droid_guard_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidStatus::set_droid_guard_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.droid_guard_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AndroidStatus.droid_guard_info)
}
inline std::string* AndroidStatus::mutable_droid_guard_info() {
  std::string* _s = _internal_mutable_droid_guard_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AndroidStatus.droid_guard_info)
  return _s;
}
inline const std::string& AndroidStatus::_internal_droid_guard_info() const {
  return _impl_.droid_guard_info_.Get();
}
inline void AndroidStatus::_internal_set_droid_guard_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.droid_guard_info_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidStatus::_internal_mutable_droid_guard_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.droid_guard_info_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidStatus::release_droid_guard_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.AndroidStatus.droid_guard_info)
  if (!_internal_has_droid_guard_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.droid_guard_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.droid_guard_info_.IsDefault()) {
    _impl_.droid_guard_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidStatus::set_allocated_droid_guard_info(std::string* droid_guard_info) {
  if (droid_guard_info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.droid_guard_info_.SetAllocated(droid_guard_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.droid_guard_info_.IsDefault()) {
    _impl_.droid_guard_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AndroidStatus.droid_guard_info)
}

// -------------------------------------------------------------------

// CrostiniApp

// optional string app_name = 1;
inline bool CrostiniApp::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrostiniApp::has_app_name() const {
  return _internal_has_app_name();
}
inline void CrostiniApp::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrostiniApp::app_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrostiniApp::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.app_name)
}
inline std::string* CrostiniApp::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniApp.app_name)
  return _s;
}
inline const std::string& CrostiniApp::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void CrostiniApp::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CrostiniApp::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CrostiniApp::release_app_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.CrostiniApp.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrostiniApp::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniApp.app_name)
}

// optional .enterprise_management.CrostiniAppType app_type = 2;
inline bool CrostiniApp::_internal_has_app_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CrostiniApp::has_app_type() const {
  return _internal_has_app_type();
}
inline void CrostiniApp::clear_app_type() {
  _impl_.app_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::CrostiniAppType CrostiniApp::_internal_app_type() const {
  return static_cast< ::enterprise_management::CrostiniAppType >(_impl_.app_type_);
}
inline ::enterprise_management::CrostiniAppType CrostiniApp::app_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.app_type)
  return _internal_app_type();
}
inline void CrostiniApp::_internal_set_app_type(::enterprise_management::CrostiniAppType value) {
  assert(::enterprise_management::CrostiniAppType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.app_type_ = value;
}
inline void CrostiniApp::set_app_type(::enterprise_management::CrostiniAppType value) {
  _internal_set_app_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.app_type)
}

// optional int64 last_launch_time_window_start_timestamp = 3;
inline bool CrostiniApp::_internal_has_last_launch_time_window_start_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CrostiniApp::has_last_launch_time_window_start_timestamp() const {
  return _internal_has_last_launch_time_window_start_timestamp();
}
inline void CrostiniApp::clear_last_launch_time_window_start_timestamp() {
  _impl_.last_launch_time_window_start_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t CrostiniApp::_internal_last_launch_time_window_start_timestamp() const {
  return _impl_.last_launch_time_window_start_timestamp_;
}
inline int64_t CrostiniApp::last_launch_time_window_start_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.last_launch_time_window_start_timestamp)
  return _internal_last_launch_time_window_start_timestamp();
}
inline void CrostiniApp::_internal_set_last_launch_time_window_start_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.last_launch_time_window_start_timestamp_ = value;
}
inline void CrostiniApp::set_last_launch_time_window_start_timestamp(int64_t value) {
  _internal_set_last_launch_time_window_start_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.last_launch_time_window_start_timestamp)
}

// optional string package_name = 4;
inline bool CrostiniApp::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrostiniApp::has_package_name() const {
  return _internal_has_package_name();
}
inline void CrostiniApp::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CrostiniApp::package_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrostiniApp::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.package_name)
}
inline std::string* CrostiniApp::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniApp.package_name)
  return _s;
}
inline const std::string& CrostiniApp::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void CrostiniApp::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CrostiniApp::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CrostiniApp::release_package_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.CrostiniApp.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrostiniApp::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniApp.package_name)
}

// optional string package_version = 5;
inline bool CrostiniApp::_internal_has_package_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrostiniApp::has_package_version() const {
  return _internal_has_package_version();
}
inline void CrostiniApp::clear_package_version() {
  _impl_.package_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CrostiniApp::package_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.package_version)
  return _internal_package_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrostiniApp::set_package_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.package_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.package_version)
}
inline std::string* CrostiniApp::mutable_package_version() {
  std::string* _s = _internal_mutable_package_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniApp.package_version)
  return _s;
}
inline const std::string& CrostiniApp::_internal_package_version() const {
  return _impl_.package_version_.Get();
}
inline void CrostiniApp::_internal_set_package_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.package_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CrostiniApp::_internal_mutable_package_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.package_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CrostiniApp::release_package_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.CrostiniApp.package_version)
  if (!_internal_has_package_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.package_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_version_.IsDefault()) {
    _impl_.package_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrostiniApp::set_allocated_package_version(std::string* package_version) {
  if (package_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.package_version_.SetAllocated(package_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_version_.IsDefault()) {
    _impl_.package_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniApp.package_version)
}

// optional string package_hash = 6;
inline bool CrostiniApp::_internal_has_package_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrostiniApp::has_package_hash() const {
  return _internal_has_package_hash();
}
inline void CrostiniApp::clear_package_hash() {
  _impl_.package_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CrostiniApp::package_hash() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniApp.package_hash)
  return _internal_package_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrostiniApp::set_package_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.package_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniApp.package_hash)
}
inline std::string* CrostiniApp::mutable_package_hash() {
  std::string* _s = _internal_mutable_package_hash();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniApp.package_hash)
  return _s;
}
inline const std::string& CrostiniApp::_internal_package_hash() const {
  return _impl_.package_hash_.Get();
}
inline void CrostiniApp::_internal_set_package_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.package_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* CrostiniApp::_internal_mutable_package_hash() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.package_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* CrostiniApp::release_package_hash() {
  // @@protoc_insertion_point(field_release:enterprise_management.CrostiniApp.package_hash)
  if (!_internal_has_package_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.package_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_hash_.IsDefault()) {
    _impl_.package_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrostiniApp::set_allocated_package_hash(std::string* package_hash) {
  if (package_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.package_hash_.SetAllocated(package_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_hash_.IsDefault()) {
    _impl_.package_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniApp.package_hash)
}

// -------------------------------------------------------------------

// CrostiniStatus

// optional int64 last_launch_time_window_start_timestamp = 1;
inline bool CrostiniStatus::_internal_has_last_launch_time_window_start_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrostiniStatus::has_last_launch_time_window_start_timestamp() const {
  return _internal_has_last_launch_time_window_start_timestamp();
}
inline void CrostiniStatus::clear_last_launch_time_window_start_timestamp() {
  _impl_.last_launch_time_window_start_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t CrostiniStatus::_internal_last_launch_time_window_start_timestamp() const {
  return _impl_.last_launch_time_window_start_timestamp_;
}
inline int64_t CrostiniStatus::last_launch_time_window_start_timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniStatus.last_launch_time_window_start_timestamp)
  return _internal_last_launch_time_window_start_timestamp();
}
inline void CrostiniStatus::_internal_set_last_launch_time_window_start_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.last_launch_time_window_start_timestamp_ = value;
}
inline void CrostiniStatus::set_last_launch_time_window_start_timestamp(int64_t value) {
  _internal_set_last_launch_time_window_start_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniStatus.last_launch_time_window_start_timestamp)
}

// optional string last_launch_vm_image_version = 2;
inline bool CrostiniStatus::_internal_has_last_launch_vm_image_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrostiniStatus::has_last_launch_vm_image_version() const {
  return _internal_has_last_launch_vm_image_version();
}
inline void CrostiniStatus::clear_last_launch_vm_image_version() {
  _impl_.last_launch_vm_image_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrostiniStatus::last_launch_vm_image_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
  return _internal_last_launch_vm_image_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrostiniStatus::set_last_launch_vm_image_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.last_launch_vm_image_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
}
inline std::string* CrostiniStatus::mutable_last_launch_vm_image_version() {
  std::string* _s = _internal_mutable_last_launch_vm_image_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
  return _s;
}
inline const std::string& CrostiniStatus::_internal_last_launch_vm_image_version() const {
  return _impl_.last_launch_vm_image_version_.Get();
}
inline void CrostiniStatus::_internal_set_last_launch_vm_image_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.last_launch_vm_image_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CrostiniStatus::_internal_mutable_last_launch_vm_image_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.last_launch_vm_image_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CrostiniStatus::release_last_launch_vm_image_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
  if (!_internal_has_last_launch_vm_image_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.last_launch_vm_image_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_launch_vm_image_version_.IsDefault()) {
    _impl_.last_launch_vm_image_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrostiniStatus::set_allocated_last_launch_vm_image_version(std::string* last_launch_vm_image_version) {
  if (last_launch_vm_image_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.last_launch_vm_image_version_.SetAllocated(last_launch_vm_image_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_launch_vm_image_version_.IsDefault()) {
    _impl_.last_launch_vm_image_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniStatus.last_launch_vm_image_version)
}

// optional string last_launch_vm_kernel_version = 3;
inline bool CrostiniStatus::_internal_has_last_launch_vm_kernel_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrostiniStatus::has_last_launch_vm_kernel_version() const {
  return _internal_has_last_launch_vm_kernel_version();
}
inline void CrostiniStatus::clear_last_launch_vm_kernel_version() {
  _impl_.last_launch_vm_kernel_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CrostiniStatus::last_launch_vm_kernel_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
  return _internal_last_launch_vm_kernel_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrostiniStatus::set_last_launch_vm_kernel_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.last_launch_vm_kernel_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
}
inline std::string* CrostiniStatus::mutable_last_launch_vm_kernel_version() {
  std::string* _s = _internal_mutable_last_launch_vm_kernel_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
  return _s;
}
inline const std::string& CrostiniStatus::_internal_last_launch_vm_kernel_version() const {
  return _impl_.last_launch_vm_kernel_version_.Get();
}
inline void CrostiniStatus::_internal_set_last_launch_vm_kernel_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.last_launch_vm_kernel_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CrostiniStatus::_internal_mutable_last_launch_vm_kernel_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.last_launch_vm_kernel_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CrostiniStatus::release_last_launch_vm_kernel_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
  if (!_internal_has_last_launch_vm_kernel_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.last_launch_vm_kernel_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_launch_vm_kernel_version_.IsDefault()) {
    _impl_.last_launch_vm_kernel_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrostiniStatus::set_allocated_last_launch_vm_kernel_version(std::string* last_launch_vm_kernel_version) {
  if (last_launch_vm_kernel_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.last_launch_vm_kernel_version_.SetAllocated(last_launch_vm_kernel_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_launch_vm_kernel_version_.IsDefault()) {
    _impl_.last_launch_vm_kernel_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CrostiniStatus.last_launch_vm_kernel_version)
}

// repeated .enterprise_management.CrostiniApp installed_apps = 4;
inline int CrostiniStatus::_internal_installed_apps_size() const {
  return _impl_.installed_apps_.size();
}
inline int CrostiniStatus::installed_apps_size() const {
  return _internal_installed_apps_size();
}
inline void CrostiniStatus::clear_installed_apps() {
  _impl_.installed_apps_.Clear();
}
inline ::enterprise_management::CrostiniApp* CrostiniStatus::mutable_installed_apps(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.CrostiniStatus.installed_apps)
  return _impl_.installed_apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp >*
CrostiniStatus::mutable_installed_apps() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.CrostiniStatus.installed_apps)
  return &_impl_.installed_apps_;
}
inline const ::enterprise_management::CrostiniApp& CrostiniStatus::_internal_installed_apps(int index) const {
  return _impl_.installed_apps_.Get(index);
}
inline const ::enterprise_management::CrostiniApp& CrostiniStatus::installed_apps(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.CrostiniStatus.installed_apps)
  return _internal_installed_apps(index);
}
inline ::enterprise_management::CrostiniApp* CrostiniStatus::_internal_add_installed_apps() {
  return _impl_.installed_apps_.Add();
}
inline ::enterprise_management::CrostiniApp* CrostiniStatus::add_installed_apps() {
  ::enterprise_management::CrostiniApp* _add = _internal_add_installed_apps();
  // @@protoc_insertion_point(field_add:enterprise_management.CrostiniStatus.installed_apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::CrostiniApp >&
CrostiniStatus::installed_apps() const {
  // @@protoc_insertion_point(field_list:enterprise_management.CrostiniStatus.installed_apps)
  return _impl_.installed_apps_;
}

// -------------------------------------------------------------------

// SessionStatusReportRequest

// optional string device_local_account_id = 4;
inline bool SessionStatusReportRequest::_internal_has_device_local_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionStatusReportRequest::has_device_local_account_id() const {
  return _internal_has_device_local_account_id();
}
inline void SessionStatusReportRequest::clear_device_local_account_id() {
  _impl_.device_local_account_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionStatusReportRequest::device_local_account_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.device_local_account_id)
  return _internal_device_local_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionStatusReportRequest::set_device_local_account_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_local_account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}
inline std::string* SessionStatusReportRequest::mutable_device_local_account_id() {
  std::string* _s = _internal_mutable_device_local_account_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.device_local_account_id)
  return _s;
}
inline const std::string& SessionStatusReportRequest::_internal_device_local_account_id() const {
  return _impl_.device_local_account_id_.Get();
}
inline void SessionStatusReportRequest::_internal_set_device_local_account_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_local_account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionStatusReportRequest::_internal_mutable_device_local_account_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_local_account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionStatusReportRequest::release_device_local_account_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.device_local_account_id)
  if (!_internal_has_device_local_account_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_local_account_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_local_account_id_.IsDefault()) {
    _impl_.device_local_account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionStatusReportRequest::set_allocated_device_local_account_id(std::string* device_local_account_id) {
  if (device_local_account_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_local_account_id_.SetAllocated(device_local_account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_local_account_id_.IsDefault()) {
    _impl_.device_local_account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.device_local_account_id)
}

// repeated .enterprise_management.AppStatus installed_apps = 5;
inline int SessionStatusReportRequest::_internal_installed_apps_size() const {
  return _impl_.installed_apps_.size();
}
inline int SessionStatusReportRequest::installed_apps_size() const {
  return _internal_installed_apps_size();
}
inline void SessionStatusReportRequest::clear_installed_apps() {
  _impl_.installed_apps_.Clear();
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::mutable_installed_apps(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.installed_apps)
  return _impl_.installed_apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus >*
SessionStatusReportRequest::mutable_installed_apps() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.installed_apps)
  return &_impl_.installed_apps_;
}
inline const ::enterprise_management::AppStatus& SessionStatusReportRequest::_internal_installed_apps(int index) const {
  return _impl_.installed_apps_.Get(index);
}
inline const ::enterprise_management::AppStatus& SessionStatusReportRequest::installed_apps(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.installed_apps)
  return _internal_installed_apps(index);
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::_internal_add_installed_apps() {
  return _impl_.installed_apps_.Add();
}
inline ::enterprise_management::AppStatus* SessionStatusReportRequest::add_installed_apps() {
  ::enterprise_management::AppStatus* _add = _internal_add_installed_apps();
  // @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.installed_apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppStatus >&
SessionStatusReportRequest::installed_apps() const {
  // @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.installed_apps)
  return _impl_.installed_apps_;
}

// optional .enterprise_management.AndroidStatus android_status = 7;
inline bool SessionStatusReportRequest::_internal_has_android_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.android_status_ != nullptr);
  return value;
}
inline bool SessionStatusReportRequest::has_android_status() const {
  return _internal_has_android_status();
}
inline void SessionStatusReportRequest::clear_android_status() {
  if (_impl_.android_status_ != nullptr) _impl_.android_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::AndroidStatus& SessionStatusReportRequest::_internal_android_status() const {
  const ::enterprise_management::AndroidStatus* p = _impl_.android_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AndroidStatus&>(
      ::enterprise_management::_AndroidStatus_default_instance_);
}
inline const ::enterprise_management::AndroidStatus& SessionStatusReportRequest::android_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.android_status)
  return _internal_android_status();
}
inline void SessionStatusReportRequest::unsafe_arena_set_allocated_android_status(
    ::enterprise_management::AndroidStatus* android_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.android_status_);
  }
  _impl_.android_status_ = android_status;
  if (android_status) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.SessionStatusReportRequest.android_status)
}
inline ::enterprise_management::AndroidStatus* SessionStatusReportRequest::release_android_status() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::AndroidStatus* temp = _impl_.android_status_;
  _impl_.android_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AndroidStatus* SessionStatusReportRequest::unsafe_arena_release_android_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.android_status)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::AndroidStatus* temp = _impl_.android_status_;
  _impl_.android_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::AndroidStatus* SessionStatusReportRequest::_internal_mutable_android_status() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.android_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AndroidStatus>(GetArenaForAllocation());
    _impl_.android_status_ = p;
  }
  return _impl_.android_status_;
}
inline ::enterprise_management::AndroidStatus* SessionStatusReportRequest::mutable_android_status() {
  ::enterprise_management::AndroidStatus* _msg = _internal_mutable_android_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.android_status)
  return _msg;
}
inline void SessionStatusReportRequest::set_allocated_android_status(::enterprise_management::AndroidStatus* android_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.android_status_;
  }
  if (android_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(android_status);
    if (message_arena != submessage_arena) {
      android_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, android_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.android_status_ = android_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.android_status)
}

// optional string user_dm_token = 8;
inline bool SessionStatusReportRequest::_internal_has_user_dm_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SessionStatusReportRequest::has_user_dm_token() const {
  return _internal_has_user_dm_token();
}
inline void SessionStatusReportRequest::clear_user_dm_token() {
  _impl_.user_dm_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SessionStatusReportRequest::user_dm_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.user_dm_token)
  return _internal_user_dm_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionStatusReportRequest::set_user_dm_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.user_dm_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.user_dm_token)
}
inline std::string* SessionStatusReportRequest::mutable_user_dm_token() {
  std::string* _s = _internal_mutable_user_dm_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.user_dm_token)
  return _s;
}
inline const std::string& SessionStatusReportRequest::_internal_user_dm_token() const {
  return _impl_.user_dm_token_.Get();
}
inline void SessionStatusReportRequest::_internal_set_user_dm_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionStatusReportRequest::_internal_mutable_user_dm_token() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.user_dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionStatusReportRequest::release_user_dm_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.user_dm_token)
  if (!_internal_has_user_dm_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.user_dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_dm_token_.IsDefault()) {
    _impl_.user_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionStatusReportRequest::set_allocated_user_dm_token(std::string* user_dm_token) {
  if (user_dm_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.user_dm_token_.SetAllocated(user_dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_dm_token_.IsDefault()) {
    _impl_.user_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.user_dm_token)
}

// optional string time_zone = 9;
inline bool SessionStatusReportRequest::_internal_has_time_zone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SessionStatusReportRequest::has_time_zone() const {
  return _internal_has_time_zone();
}
inline void SessionStatusReportRequest::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SessionStatusReportRequest::time_zone() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionStatusReportRequest::set_time_zone(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportRequest.time_zone)
}
inline std::string* SessionStatusReportRequest::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.time_zone)
  return _s;
}
inline const std::string& SessionStatusReportRequest::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void SessionStatusReportRequest::_internal_set_time_zone(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionStatusReportRequest::_internal_mutable_time_zone() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionStatusReportRequest::release_time_zone() {
  // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.time_zone)
  if (!_internal_has_time_zone()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.time_zone_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionStatusReportRequest::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.time_zone)
}

// optional .enterprise_management.CrostiniStatus crostini_status = 10;
inline bool SessionStatusReportRequest::_internal_has_crostini_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.crostini_status_ != nullptr);
  return value;
}
inline bool SessionStatusReportRequest::has_crostini_status() const {
  return _internal_has_crostini_status();
}
inline void SessionStatusReportRequest::clear_crostini_status() {
  if (_impl_.crostini_status_ != nullptr) _impl_.crostini_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::CrostiniStatus& SessionStatusReportRequest::_internal_crostini_status() const {
  const ::enterprise_management::CrostiniStatus* p = _impl_.crostini_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CrostiniStatus&>(
      ::enterprise_management::_CrostiniStatus_default_instance_);
}
inline const ::enterprise_management::CrostiniStatus& SessionStatusReportRequest::crostini_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.crostini_status)
  return _internal_crostini_status();
}
inline void SessionStatusReportRequest::unsafe_arena_set_allocated_crostini_status(
    ::enterprise_management::CrostiniStatus* crostini_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.crostini_status_);
  }
  _impl_.crostini_status_ = crostini_status;
  if (crostini_status) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.SessionStatusReportRequest.crostini_status)
}
inline ::enterprise_management::CrostiniStatus* SessionStatusReportRequest::release_crostini_status() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::CrostiniStatus* temp = _impl_.crostini_status_;
  _impl_.crostini_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CrostiniStatus* SessionStatusReportRequest::unsafe_arena_release_crostini_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportRequest.crostini_status)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::CrostiniStatus* temp = _impl_.crostini_status_;
  _impl_.crostini_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::CrostiniStatus* SessionStatusReportRequest::_internal_mutable_crostini_status() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.crostini_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CrostiniStatus>(GetArenaForAllocation());
    _impl_.crostini_status_ = p;
  }
  return _impl_.crostini_status_;
}
inline ::enterprise_management::CrostiniStatus* SessionStatusReportRequest::mutable_crostini_status() {
  ::enterprise_management::CrostiniStatus* _msg = _internal_mutable_crostini_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.crostini_status)
  return _msg;
}
inline void SessionStatusReportRequest::set_allocated_crostini_status(::enterprise_management::CrostiniStatus* crostini_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.crostini_status_;
  }
  if (crostini_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(crostini_status);
    if (message_arena != submessage_arena) {
      crostini_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crostini_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.crostini_status_ = crostini_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportRequest.crostini_status)
}

// repeated .enterprise_management.AppInfo app_infos = 11;
inline int SessionStatusReportRequest::_internal_app_infos_size() const {
  return _impl_.app_infos_.size();
}
inline int SessionStatusReportRequest::app_infos_size() const {
  return _internal_app_infos_size();
}
inline void SessionStatusReportRequest::clear_app_infos() {
  _impl_.app_infos_.Clear();
}
inline ::enterprise_management::AppInfo* SessionStatusReportRequest::mutable_app_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportRequest.app_infos)
  return _impl_.app_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo >*
SessionStatusReportRequest::mutable_app_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.SessionStatusReportRequest.app_infos)
  return &_impl_.app_infos_;
}
inline const ::enterprise_management::AppInfo& SessionStatusReportRequest::_internal_app_infos(int index) const {
  return _impl_.app_infos_.Get(index);
}
inline const ::enterprise_management::AppInfo& SessionStatusReportRequest::app_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportRequest.app_infos)
  return _internal_app_infos(index);
}
inline ::enterprise_management::AppInfo* SessionStatusReportRequest::_internal_add_app_infos() {
  return _impl_.app_infos_.Add();
}
inline ::enterprise_management::AppInfo* SessionStatusReportRequest::add_app_infos() {
  ::enterprise_management::AppInfo* _add = _internal_add_app_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.SessionStatusReportRequest.app_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInfo >&
SessionStatusReportRequest::app_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.SessionStatusReportRequest.app_infos)
  return _impl_.app_infos_;
}

// -------------------------------------------------------------------

// DeviceStatusReportResponse

// optional int32 error_code = 1;
inline bool DeviceStatusReportResponse::_internal_has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceStatusReportResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void DeviceStatusReportResponse::clear_error_code() {
  _impl_.error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t DeviceStatusReportResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t DeviceStatusReportResponse::error_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportResponse.error_code)
  return _internal_error_code();
}
inline void DeviceStatusReportResponse::_internal_set_error_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_code_ = value;
}
inline void DeviceStatusReportResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportResponse.error_code)
}

// optional string error_message = 2;
inline bool DeviceStatusReportResponse::_internal_has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceStatusReportResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void DeviceStatusReportResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceStatusReportResponse::error_message() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStatusReportResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStatusReportResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStatusReportResponse.error_message)
}
inline std::string* DeviceStatusReportResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStatusReportResponse.error_message)
  return _s;
}
inline const std::string& DeviceStatusReportResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void DeviceStatusReportResponse::_internal_set_error_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceStatusReportResponse::_internal_mutable_error_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceStatusReportResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStatusReportResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceStatusReportResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStatusReportResponse.error_message)
}

// -------------------------------------------------------------------

// ChromeDesktopReportResponse

// -------------------------------------------------------------------

// ChromeOsUserReportResponse

// -------------------------------------------------------------------

// ChromeProfileReportResponse

// -------------------------------------------------------------------

// SessionStatusReportResponse

// optional int32 error_code = 1;
inline bool SessionStatusReportResponse::_internal_has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SessionStatusReportResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void SessionStatusReportResponse::clear_error_code() {
  _impl_.error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SessionStatusReportResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t SessionStatusReportResponse::error_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportResponse.error_code)
  return _internal_error_code();
}
inline void SessionStatusReportResponse::_internal_set_error_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_code_ = value;
}
inline void SessionStatusReportResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportResponse.error_code)
}

// optional string error_message = 2;
inline bool SessionStatusReportResponse::_internal_has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionStatusReportResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void SessionStatusReportResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionStatusReportResponse::error_message() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SessionStatusReportResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionStatusReportResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SessionStatusReportResponse.error_message)
}
inline std::string* SessionStatusReportResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SessionStatusReportResponse.error_message)
  return _s;
}
inline const std::string& SessionStatusReportResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void SessionStatusReportResponse::_internal_set_error_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionStatusReportResponse::_internal_mutable_error_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionStatusReportResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:enterprise_management.SessionStatusReportResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionStatusReportResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SessionStatusReportResponse.error_message)
}

// -------------------------------------------------------------------

// PrivateSetMembershipRequest

// optional .enterprise_management.PrivateSetMembershipRlweRequest rlwe_request = 1;
inline bool PrivateSetMembershipRequest::_internal_has_rlwe_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rlwe_request_ != nullptr);
  return value;
}
inline bool PrivateSetMembershipRequest::has_rlwe_request() const {
  return _internal_has_rlwe_request();
}
inline void PrivateSetMembershipRequest::clear_rlwe_request() {
  if (_impl_.rlwe_request_ != nullptr) _impl_.rlwe_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::PrivateSetMembershipRlweRequest& PrivateSetMembershipRequest::_internal_rlwe_request() const {
  const ::enterprise_management::PrivateSetMembershipRlweRequest* p = _impl_.rlwe_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PrivateSetMembershipRlweRequest&>(
      ::enterprise_management::_PrivateSetMembershipRlweRequest_default_instance_);
}
inline const ::enterprise_management::PrivateSetMembershipRlweRequest& PrivateSetMembershipRequest::rlwe_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrivateSetMembershipRequest.rlwe_request)
  return _internal_rlwe_request();
}
inline void PrivateSetMembershipRequest::unsafe_arena_set_allocated_rlwe_request(
    ::enterprise_management::PrivateSetMembershipRlweRequest* rlwe_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rlwe_request_);
  }
  _impl_.rlwe_request_ = rlwe_request;
  if (rlwe_request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrivateSetMembershipRequest.rlwe_request)
}
inline ::enterprise_management::PrivateSetMembershipRlweRequest* PrivateSetMembershipRequest::release_rlwe_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PrivateSetMembershipRlweRequest* temp = _impl_.rlwe_request_;
  _impl_.rlwe_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PrivateSetMembershipRlweRequest* PrivateSetMembershipRequest::unsafe_arena_release_rlwe_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrivateSetMembershipRequest.rlwe_request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PrivateSetMembershipRlweRequest* temp = _impl_.rlwe_request_;
  _impl_.rlwe_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::PrivateSetMembershipRlweRequest* PrivateSetMembershipRequest::_internal_mutable_rlwe_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rlwe_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PrivateSetMembershipRlweRequest>(GetArenaForAllocation());
    _impl_.rlwe_request_ = p;
  }
  return _impl_.rlwe_request_;
}
inline ::enterprise_management::PrivateSetMembershipRlweRequest* PrivateSetMembershipRequest::mutable_rlwe_request() {
  ::enterprise_management::PrivateSetMembershipRlweRequest* _msg = _internal_mutable_rlwe_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrivateSetMembershipRequest.rlwe_request)
  return _msg;
}
inline void PrivateSetMembershipRequest::set_allocated_rlwe_request(::enterprise_management::PrivateSetMembershipRlweRequest* rlwe_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rlwe_request_;
  }
  if (rlwe_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rlwe_request);
    if (message_arena != submessage_arena) {
      rlwe_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rlwe_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rlwe_request_ = rlwe_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrivateSetMembershipRequest.rlwe_request)
}

// -------------------------------------------------------------------

// PrivateSetMembershipResponse

// optional .enterprise_management.PrivateSetMembershipRlweResponse rlwe_response = 1;
inline bool PrivateSetMembershipResponse::_internal_has_rlwe_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rlwe_response_ != nullptr);
  return value;
}
inline bool PrivateSetMembershipResponse::has_rlwe_response() const {
  return _internal_has_rlwe_response();
}
inline void PrivateSetMembershipResponse::clear_rlwe_response() {
  if (_impl_.rlwe_response_ != nullptr) _impl_.rlwe_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::PrivateSetMembershipRlweResponse& PrivateSetMembershipResponse::_internal_rlwe_response() const {
  const ::enterprise_management::PrivateSetMembershipRlweResponse* p = _impl_.rlwe_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PrivateSetMembershipRlweResponse&>(
      ::enterprise_management::_PrivateSetMembershipRlweResponse_default_instance_);
}
inline const ::enterprise_management::PrivateSetMembershipRlweResponse& PrivateSetMembershipResponse::rlwe_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrivateSetMembershipResponse.rlwe_response)
  return _internal_rlwe_response();
}
inline void PrivateSetMembershipResponse::unsafe_arena_set_allocated_rlwe_response(
    ::enterprise_management::PrivateSetMembershipRlweResponse* rlwe_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rlwe_response_);
  }
  _impl_.rlwe_response_ = rlwe_response;
  if (rlwe_response) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrivateSetMembershipResponse.rlwe_response)
}
inline ::enterprise_management::PrivateSetMembershipRlweResponse* PrivateSetMembershipResponse::release_rlwe_response() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PrivateSetMembershipRlweResponse* temp = _impl_.rlwe_response_;
  _impl_.rlwe_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PrivateSetMembershipRlweResponse* PrivateSetMembershipResponse::unsafe_arena_release_rlwe_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrivateSetMembershipResponse.rlwe_response)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PrivateSetMembershipRlweResponse* temp = _impl_.rlwe_response_;
  _impl_.rlwe_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::PrivateSetMembershipRlweResponse* PrivateSetMembershipResponse::_internal_mutable_rlwe_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rlwe_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PrivateSetMembershipRlweResponse>(GetArenaForAllocation());
    _impl_.rlwe_response_ = p;
  }
  return _impl_.rlwe_response_;
}
inline ::enterprise_management::PrivateSetMembershipRlweResponse* PrivateSetMembershipResponse::mutable_rlwe_response() {
  ::enterprise_management::PrivateSetMembershipRlweResponse* _msg = _internal_mutable_rlwe_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrivateSetMembershipResponse.rlwe_response)
  return _msg;
}
inline void PrivateSetMembershipResponse::set_allocated_rlwe_response(::enterprise_management::PrivateSetMembershipRlweResponse* rlwe_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rlwe_response_;
  }
  if (rlwe_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rlwe_response);
    if (message_arena != submessage_arena) {
      rlwe_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rlwe_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rlwe_response_ = rlwe_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrivateSetMembershipResponse.rlwe_response)
}

// -------------------------------------------------------------------

// PrivateSetMembershipRlweRequest

// optional .private_membership.rlwe.PrivateMembershipRlweOprfRequest oprf_request = 1;
inline bool PrivateSetMembershipRlweRequest::_internal_has_oprf_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.oprf_request_ != nullptr);
  return value;
}
inline bool PrivateSetMembershipRlweRequest::has_oprf_request() const {
  return _internal_has_oprf_request();
}
inline const ::private_membership::rlwe::PrivateMembershipRlweOprfRequest& PrivateSetMembershipRlweRequest::_internal_oprf_request() const {
  const ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* p = _impl_.oprf_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::private_membership::rlwe::PrivateMembershipRlweOprfRequest&>(
      ::private_membership::rlwe::_PrivateMembershipRlweOprfRequest_default_instance_);
}
inline const ::private_membership::rlwe::PrivateMembershipRlweOprfRequest& PrivateSetMembershipRlweRequest::oprf_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrivateSetMembershipRlweRequest.oprf_request)
  return _internal_oprf_request();
}
inline void PrivateSetMembershipRlweRequest::unsafe_arena_set_allocated_oprf_request(
    ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* oprf_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oprf_request_);
  }
  _impl_.oprf_request_ = oprf_request;
  if (oprf_request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrivateSetMembershipRlweRequest.oprf_request)
}
inline ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* PrivateSetMembershipRlweRequest::release_oprf_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* temp = _impl_.oprf_request_;
  _impl_.oprf_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* PrivateSetMembershipRlweRequest::unsafe_arena_release_oprf_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrivateSetMembershipRlweRequest.oprf_request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* temp = _impl_.oprf_request_;
  _impl_.oprf_request_ = nullptr;
  return temp;
}
inline ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* PrivateSetMembershipRlweRequest::_internal_mutable_oprf_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.oprf_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::private_membership::rlwe::PrivateMembershipRlweOprfRequest>(GetArenaForAllocation());
    _impl_.oprf_request_ = p;
  }
  return _impl_.oprf_request_;
}
inline ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* PrivateSetMembershipRlweRequest::mutable_oprf_request() {
  ::private_membership::rlwe::PrivateMembershipRlweOprfRequest* _msg = _internal_mutable_oprf_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrivateSetMembershipRlweRequest.oprf_request)
  return _msg;
}
inline void PrivateSetMembershipRlweRequest::set_allocated_oprf_request(::private_membership::rlwe::PrivateMembershipRlweOprfRequest* oprf_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oprf_request_);
  }
  if (oprf_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oprf_request));
    if (message_arena != submessage_arena) {
      oprf_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oprf_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.oprf_request_ = oprf_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrivateSetMembershipRlweRequest.oprf_request)
}

// optional .private_membership.rlwe.PrivateMembershipRlweQueryRequest query_request = 2;
inline bool PrivateSetMembershipRlweRequest::_internal_has_query_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_request_ != nullptr);
  return value;
}
inline bool PrivateSetMembershipRlweRequest::has_query_request() const {
  return _internal_has_query_request();
}
inline const ::private_membership::rlwe::PrivateMembershipRlweQueryRequest& PrivateSetMembershipRlweRequest::_internal_query_request() const {
  const ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* p = _impl_.query_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::private_membership::rlwe::PrivateMembershipRlweQueryRequest&>(
      ::private_membership::rlwe::_PrivateMembershipRlweQueryRequest_default_instance_);
}
inline const ::private_membership::rlwe::PrivateMembershipRlweQueryRequest& PrivateSetMembershipRlweRequest::query_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrivateSetMembershipRlweRequest.query_request)
  return _internal_query_request();
}
inline void PrivateSetMembershipRlweRequest::unsafe_arena_set_allocated_query_request(
    ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* query_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_request_);
  }
  _impl_.query_request_ = query_request;
  if (query_request) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrivateSetMembershipRlweRequest.query_request)
}
inline ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* PrivateSetMembershipRlweRequest::release_query_request() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* temp = _impl_.query_request_;
  _impl_.query_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* PrivateSetMembershipRlweRequest::unsafe_arena_release_query_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrivateSetMembershipRlweRequest.query_request)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* temp = _impl_.query_request_;
  _impl_.query_request_ = nullptr;
  return temp;
}
inline ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* PrivateSetMembershipRlweRequest::_internal_mutable_query_request() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.query_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::private_membership::rlwe::PrivateMembershipRlweQueryRequest>(GetArenaForAllocation());
    _impl_.query_request_ = p;
  }
  return _impl_.query_request_;
}
inline ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* PrivateSetMembershipRlweRequest::mutable_query_request() {
  ::private_membership::rlwe::PrivateMembershipRlweQueryRequest* _msg = _internal_mutable_query_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrivateSetMembershipRlweRequest.query_request)
  return _msg;
}
inline void PrivateSetMembershipRlweRequest::set_allocated_query_request(::private_membership::rlwe::PrivateMembershipRlweQueryRequest* query_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_request_);
  }
  if (query_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_request));
    if (message_arena != submessage_arena) {
      query_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.query_request_ = query_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrivateSetMembershipRlweRequest.query_request)
}

// -------------------------------------------------------------------

// PrivateSetMembershipRlweResponse

// optional .private_membership.rlwe.PrivateMembershipRlweOprfResponse oprf_response = 1;
inline bool PrivateSetMembershipRlweResponse::_internal_has_oprf_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.oprf_response_ != nullptr);
  return value;
}
inline bool PrivateSetMembershipRlweResponse::has_oprf_response() const {
  return _internal_has_oprf_response();
}
inline const ::private_membership::rlwe::PrivateMembershipRlweOprfResponse& PrivateSetMembershipRlweResponse::_internal_oprf_response() const {
  const ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* p = _impl_.oprf_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::private_membership::rlwe::PrivateMembershipRlweOprfResponse&>(
      ::private_membership::rlwe::_PrivateMembershipRlweOprfResponse_default_instance_);
}
inline const ::private_membership::rlwe::PrivateMembershipRlweOprfResponse& PrivateSetMembershipRlweResponse::oprf_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrivateSetMembershipRlweResponse.oprf_response)
  return _internal_oprf_response();
}
inline void PrivateSetMembershipRlweResponse::unsafe_arena_set_allocated_oprf_response(
    ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* oprf_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oprf_response_);
  }
  _impl_.oprf_response_ = oprf_response;
  if (oprf_response) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrivateSetMembershipRlweResponse.oprf_response)
}
inline ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* PrivateSetMembershipRlweResponse::release_oprf_response() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* temp = _impl_.oprf_response_;
  _impl_.oprf_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* PrivateSetMembershipRlweResponse::unsafe_arena_release_oprf_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrivateSetMembershipRlweResponse.oprf_response)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* temp = _impl_.oprf_response_;
  _impl_.oprf_response_ = nullptr;
  return temp;
}
inline ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* PrivateSetMembershipRlweResponse::_internal_mutable_oprf_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.oprf_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::private_membership::rlwe::PrivateMembershipRlweOprfResponse>(GetArenaForAllocation());
    _impl_.oprf_response_ = p;
  }
  return _impl_.oprf_response_;
}
inline ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* PrivateSetMembershipRlweResponse::mutable_oprf_response() {
  ::private_membership::rlwe::PrivateMembershipRlweOprfResponse* _msg = _internal_mutable_oprf_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrivateSetMembershipRlweResponse.oprf_response)
  return _msg;
}
inline void PrivateSetMembershipRlweResponse::set_allocated_oprf_response(::private_membership::rlwe::PrivateMembershipRlweOprfResponse* oprf_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oprf_response_);
  }
  if (oprf_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oprf_response));
    if (message_arena != submessage_arena) {
      oprf_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oprf_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.oprf_response_ = oprf_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrivateSetMembershipRlweResponse.oprf_response)
}

// optional .private_membership.rlwe.PrivateMembershipRlweQueryResponse query_response = 2;
inline bool PrivateSetMembershipRlweResponse::_internal_has_query_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_response_ != nullptr);
  return value;
}
inline bool PrivateSetMembershipRlweResponse::has_query_response() const {
  return _internal_has_query_response();
}
inline const ::private_membership::rlwe::PrivateMembershipRlweQueryResponse& PrivateSetMembershipRlweResponse::_internal_query_response() const {
  const ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* p = _impl_.query_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::private_membership::rlwe::PrivateMembershipRlweQueryResponse&>(
      ::private_membership::rlwe::_PrivateMembershipRlweQueryResponse_default_instance_);
}
inline const ::private_membership::rlwe::PrivateMembershipRlweQueryResponse& PrivateSetMembershipRlweResponse::query_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrivateSetMembershipRlweResponse.query_response)
  return _internal_query_response();
}
inline void PrivateSetMembershipRlweResponse::unsafe_arena_set_allocated_query_response(
    ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* query_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_response_);
  }
  _impl_.query_response_ = query_response;
  if (query_response) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrivateSetMembershipRlweResponse.query_response)
}
inline ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* PrivateSetMembershipRlweResponse::release_query_response() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* temp = _impl_.query_response_;
  _impl_.query_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* PrivateSetMembershipRlweResponse::unsafe_arena_release_query_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrivateSetMembershipRlweResponse.query_response)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* temp = _impl_.query_response_;
  _impl_.query_response_ = nullptr;
  return temp;
}
inline ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* PrivateSetMembershipRlweResponse::_internal_mutable_query_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.query_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::private_membership::rlwe::PrivateMembershipRlweQueryResponse>(GetArenaForAllocation());
    _impl_.query_response_ = p;
  }
  return _impl_.query_response_;
}
inline ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* PrivateSetMembershipRlweResponse::mutable_query_response() {
  ::private_membership::rlwe::PrivateMembershipRlweQueryResponse* _msg = _internal_mutable_query_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrivateSetMembershipRlweResponse.query_response)
  return _msg;
}
inline void PrivateSetMembershipRlweResponse::set_allocated_query_response(::private_membership::rlwe::PrivateMembershipRlweQueryResponse* query_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_response_);
  }
  if (query_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_response));
    if (message_arena != submessage_arena) {
      query_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.query_response_ = query_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrivateSetMembershipRlweResponse.query_response)
}

// -------------------------------------------------------------------

// DeviceAutoEnrollmentRequest

// optional int64 remainder = 1;
inline bool DeviceAutoEnrollmentRequest::_internal_has_remainder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceAutoEnrollmentRequest::has_remainder() const {
  return _internal_has_remainder();
}
inline void DeviceAutoEnrollmentRequest::clear_remainder() {
  _impl_.remainder_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t DeviceAutoEnrollmentRequest::_internal_remainder() const {
  return _impl_.remainder_;
}
inline int64_t DeviceAutoEnrollmentRequest::remainder() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentRequest.remainder)
  return _internal_remainder();
}
inline void DeviceAutoEnrollmentRequest::_internal_set_remainder(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.remainder_ = value;
}
inline void DeviceAutoEnrollmentRequest::set_remainder(int64_t value) {
  _internal_set_remainder(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentRequest.remainder)
}

// optional int64 modulus = 2;
inline bool DeviceAutoEnrollmentRequest::_internal_has_modulus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceAutoEnrollmentRequest::has_modulus() const {
  return _internal_has_modulus();
}
inline void DeviceAutoEnrollmentRequest::clear_modulus() {
  _impl_.modulus_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t DeviceAutoEnrollmentRequest::_internal_modulus() const {
  return _impl_.modulus_;
}
inline int64_t DeviceAutoEnrollmentRequest::modulus() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentRequest.modulus)
  return _internal_modulus();
}
inline void DeviceAutoEnrollmentRequest::_internal_set_modulus(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.modulus_ = value;
}
inline void DeviceAutoEnrollmentRequest::set_modulus(int64_t value) {
  _internal_set_modulus(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentRequest.modulus)
}

// optional .enterprise_management.DeviceAutoEnrollmentRequest.EnrollmentCheckType enrollment_check_type = 3 [default = ENROLLMENT_CHECK_TYPE_FRE];
inline bool DeviceAutoEnrollmentRequest::_internal_has_enrollment_check_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceAutoEnrollmentRequest::has_enrollment_check_type() const {
  return _internal_has_enrollment_check_type();
}
inline void DeviceAutoEnrollmentRequest::clear_enrollment_check_type() {
  _impl_.enrollment_check_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest::_internal_enrollment_check_type() const {
  return static_cast< ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType >(_impl_.enrollment_check_type_);
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest::enrollment_check_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentRequest.enrollment_check_type)
  return _internal_enrollment_check_type();
}
inline void DeviceAutoEnrollmentRequest::_internal_set_enrollment_check_type(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType value) {
  assert(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.enrollment_check_type_ = value;
}
inline void DeviceAutoEnrollmentRequest::set_enrollment_check_type(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType value) {
  _internal_set_enrollment_check_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentRequest.enrollment_check_type)
}

// -------------------------------------------------------------------

// DeviceAutoEnrollmentResponse

// optional int64 expected_modulus = 1;
inline bool DeviceAutoEnrollmentResponse::_internal_has_expected_modulus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceAutoEnrollmentResponse::has_expected_modulus() const {
  return _internal_has_expected_modulus();
}
inline void DeviceAutoEnrollmentResponse::clear_expected_modulus() {
  _impl_.expected_modulus_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t DeviceAutoEnrollmentResponse::_internal_expected_modulus() const {
  return _impl_.expected_modulus_;
}
inline int64_t DeviceAutoEnrollmentResponse::expected_modulus() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentResponse.expected_modulus)
  return _internal_expected_modulus();
}
inline void DeviceAutoEnrollmentResponse::_internal_set_expected_modulus(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.expected_modulus_ = value;
}
inline void DeviceAutoEnrollmentResponse::set_expected_modulus(int64_t value) {
  _internal_set_expected_modulus(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentResponse.expected_modulus)
}

// repeated bytes hashes = 2;
inline int DeviceAutoEnrollmentResponse::_internal_hashes_size() const {
  return _impl_.hashes_.size();
}
inline int DeviceAutoEnrollmentResponse::hashes_size() const {
  return _internal_hashes_size();
}
inline void DeviceAutoEnrollmentResponse::clear_hashes() {
  _impl_.hashes_.Clear();
}
inline std::string* DeviceAutoEnrollmentResponse::add_hashes() {
  std::string* _s = _internal_add_hashes();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
  return _s;
}
inline const std::string& DeviceAutoEnrollmentResponse::_internal_hashes(int index) const {
  return _impl_.hashes_.Get(index);
}
inline const std::string& DeviceAutoEnrollmentResponse::hashes(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
  return _internal_hashes(index);
}
inline std::string* DeviceAutoEnrollmentResponse::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
  return _impl_.hashes_.Mutable(index);
}
inline void DeviceAutoEnrollmentResponse::set_hashes(int index, const std::string& value) {
  _impl_.hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::set_hashes(int index, std::string&& value) {
  _impl_.hashes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::set_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::set_hashes(int index, const void* value, size_t size) {
  _impl_.hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline std::string* DeviceAutoEnrollmentResponse::_internal_add_hashes() {
  return _impl_.hashes_.Add();
}
inline void DeviceAutoEnrollmentResponse::add_hashes(const std::string& value) {
  _impl_.hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::add_hashes(std::string&& value) {
  _impl_.hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::add_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline void DeviceAutoEnrollmentResponse::add_hashes(const void* value, size_t size) {
  _impl_.hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceAutoEnrollmentResponse::hashes() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
  return _impl_.hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceAutoEnrollmentResponse::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceAutoEnrollmentResponse.hashes)
  return &_impl_.hashes_;
}

// -------------------------------------------------------------------

// DeviceStateRetrievalRequest

// optional bytes server_backed_state_key = 1;
inline bool DeviceStateRetrievalRequest::_internal_has_server_backed_state_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceStateRetrievalRequest::has_server_backed_state_key() const {
  return _internal_has_server_backed_state_key();
}
inline void DeviceStateRetrievalRequest::clear_server_backed_state_key() {
  _impl_.server_backed_state_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceStateRetrievalRequest::server_backed_state_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
  return _internal_server_backed_state_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStateRetrievalRequest::set_server_backed_state_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.server_backed_state_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}
inline std::string* DeviceStateRetrievalRequest::mutable_server_backed_state_key() {
  std::string* _s = _internal_mutable_server_backed_state_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
  return _s;
}
inline const std::string& DeviceStateRetrievalRequest::_internal_server_backed_state_key() const {
  return _impl_.server_backed_state_key_.Get();
}
inline void DeviceStateRetrievalRequest::_internal_set_server_backed_state_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_backed_state_key_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceStateRetrievalRequest::_internal_mutable_server_backed_state_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_backed_state_key_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceStateRetrievalRequest::release_server_backed_state_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
  if (!_internal_has_server_backed_state_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.server_backed_state_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_backed_state_key_.IsDefault()) {
    _impl_.server_backed_state_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceStateRetrievalRequest::set_allocated_server_backed_state_key(std::string* server_backed_state_key) {
  if (server_backed_state_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_backed_state_key_.SetAllocated(server_backed_state_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_backed_state_key_.IsDefault()) {
    _impl_.server_backed_state_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalRequest.server_backed_state_key)
}

// -------------------------------------------------------------------

// DeviceStateKeyUpdateRequest

// repeated bytes server_backed_state_keys = 1;
inline int DeviceStateKeyUpdateRequest::_internal_server_backed_state_keys_size() const {
  return _impl_.server_backed_state_keys_.size();
}
inline int DeviceStateKeyUpdateRequest::server_backed_state_keys_size() const {
  return _internal_server_backed_state_keys_size();
}
inline void DeviceStateKeyUpdateRequest::clear_server_backed_state_keys() {
  _impl_.server_backed_state_keys_.Clear();
}
inline std::string* DeviceStateKeyUpdateRequest::add_server_backed_state_keys() {
  std::string* _s = _internal_add_server_backed_state_keys();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
  return _s;
}
inline const std::string& DeviceStateKeyUpdateRequest::_internal_server_backed_state_keys(int index) const {
  return _impl_.server_backed_state_keys_.Get(index);
}
inline const std::string& DeviceStateKeyUpdateRequest::server_backed_state_keys(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
  return _internal_server_backed_state_keys(index);
}
inline std::string* DeviceStateKeyUpdateRequest::mutable_server_backed_state_keys(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
  return _impl_.server_backed_state_keys_.Mutable(index);
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_keys(int index, const std::string& value) {
  _impl_.server_backed_state_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_keys(int index, std::string&& value) {
  _impl_.server_backed_state_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.server_backed_state_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::set_server_backed_state_keys(int index, const void* value, size_t size) {
  _impl_.server_backed_state_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline std::string* DeviceStateKeyUpdateRequest::_internal_add_server_backed_state_keys() {
  return _impl_.server_backed_state_keys_.Add();
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_keys(const std::string& value) {
  _impl_.server_backed_state_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_keys(std::string&& value) {
  _impl_.server_backed_state_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.server_backed_state_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline void DeviceStateKeyUpdateRequest::add_server_backed_state_keys(const void* value, size_t size) {
  _impl_.server_backed_state_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceStateKeyUpdateRequest::server_backed_state_keys() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
  return _impl_.server_backed_state_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceStateKeyUpdateRequest::mutable_server_backed_state_keys() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceStateKeyUpdateRequest.server_backed_state_keys)
  return &_impl_.server_backed_state_keys_;
}

// -------------------------------------------------------------------

// DeviceStateRetrievalResponse

// optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
inline bool DeviceStateRetrievalResponse::_internal_has_restore_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceStateRetrievalResponse::has_restore_mode() const {
  return _internal_has_restore_mode();
}
inline void DeviceStateRetrievalResponse::clear_restore_mode() {
  _impl_.restore_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::_internal_restore_mode() const {
  return static_cast< ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode >(_impl_.restore_mode_);
}
inline ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::restore_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.restore_mode)
  return _internal_restore_mode();
}
inline void DeviceStateRetrievalResponse::_internal_set_restore_mode(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode value) {
  assert(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.restore_mode_ = value;
}
inline void DeviceStateRetrievalResponse::set_restore_mode(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode value) {
  _internal_set_restore_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalResponse.restore_mode)
}

// optional string management_domain = 2;
inline bool DeviceStateRetrievalResponse::_internal_has_management_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceStateRetrievalResponse::has_management_domain() const {
  return _internal_has_management_domain();
}
inline void DeviceStateRetrievalResponse::clear_management_domain() {
  _impl_.management_domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceStateRetrievalResponse::management_domain() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.management_domain)
  return _internal_management_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceStateRetrievalResponse::set_management_domain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.management_domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}
inline std::string* DeviceStateRetrievalResponse::mutable_management_domain() {
  std::string* _s = _internal_mutable_management_domain();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalResponse.management_domain)
  return _s;
}
inline const std::string& DeviceStateRetrievalResponse::_internal_management_domain() const {
  return _impl_.management_domain_.Get();
}
inline void DeviceStateRetrievalResponse::_internal_set_management_domain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.management_domain_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceStateRetrievalResponse::_internal_mutable_management_domain() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.management_domain_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceStateRetrievalResponse::release_management_domain() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalResponse.management_domain)
  if (!_internal_has_management_domain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.management_domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.management_domain_.IsDefault()) {
    _impl_.management_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceStateRetrievalResponse::set_allocated_management_domain(std::string* management_domain) {
  if (management_domain != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.management_domain_.SetAllocated(management_domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.management_domain_.IsDefault()) {
    _impl_.management_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalResponse.management_domain)
}

// optional .enterprise_management.DisabledState disabled_state = 3;
inline bool DeviceStateRetrievalResponse::_internal_has_disabled_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.disabled_state_ != nullptr);
  return value;
}
inline bool DeviceStateRetrievalResponse::has_disabled_state() const {
  return _internal_has_disabled_state();
}
inline void DeviceStateRetrievalResponse::clear_disabled_state() {
  if (_impl_.disabled_state_ != nullptr) _impl_.disabled_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DisabledState& DeviceStateRetrievalResponse::_internal_disabled_state() const {
  const ::enterprise_management::DisabledState* p = _impl_.disabled_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DisabledState&>(
      ::enterprise_management::_DisabledState_default_instance_);
}
inline const ::enterprise_management::DisabledState& DeviceStateRetrievalResponse::disabled_state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
  return _internal_disabled_state();
}
inline void DeviceStateRetrievalResponse::unsafe_arena_set_allocated_disabled_state(
    ::enterprise_management::DisabledState* disabled_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.disabled_state_);
  }
  _impl_.disabled_state_ = disabled_state;
  if (disabled_state) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
}
inline ::enterprise_management::DisabledState* DeviceStateRetrievalResponse::release_disabled_state() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DisabledState* temp = _impl_.disabled_state_;
  _impl_.disabled_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DisabledState* DeviceStateRetrievalResponse::unsafe_arena_release_disabled_state() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DisabledState* temp = _impl_.disabled_state_;
  _impl_.disabled_state_ = nullptr;
  return temp;
}
inline ::enterprise_management::DisabledState* DeviceStateRetrievalResponse::_internal_mutable_disabled_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.disabled_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DisabledState>(GetArenaForAllocation());
    _impl_.disabled_state_ = p;
  }
  return _impl_.disabled_state_;
}
inline ::enterprise_management::DisabledState* DeviceStateRetrievalResponse::mutable_disabled_state() {
  ::enterprise_management::DisabledState* _msg = _internal_mutable_disabled_state();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
  return _msg;
}
inline void DeviceStateRetrievalResponse::set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.disabled_state_;
  }
  if (disabled_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disabled_state);
    if (message_arena != submessage_arena) {
      disabled_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disabled_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.disabled_state_ = disabled_state;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalResponse.disabled_state)
}

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse initial_state_response = 4;
inline bool DeviceStateRetrievalResponse::_internal_has_initial_state_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.initial_state_response_ != nullptr);
  return value;
}
inline bool DeviceStateRetrievalResponse::has_initial_state_response() const {
  return _internal_has_initial_state_response();
}
inline void DeviceStateRetrievalResponse::clear_initial_state_response() {
  if (_impl_.initial_state_response_ != nullptr) _impl_.initial_state_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::DeviceInitialEnrollmentStateResponse& DeviceStateRetrievalResponse::_internal_initial_state_response() const {
  const ::enterprise_management::DeviceInitialEnrollmentStateResponse* p = _impl_.initial_state_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceInitialEnrollmentStateResponse&>(
      ::enterprise_management::_DeviceInitialEnrollmentStateResponse_default_instance_);
}
inline const ::enterprise_management::DeviceInitialEnrollmentStateResponse& DeviceStateRetrievalResponse::initial_state_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.initial_state_response)
  return _internal_initial_state_response();
}
inline void DeviceStateRetrievalResponse::unsafe_arena_set_allocated_initial_state_response(
    ::enterprise_management::DeviceInitialEnrollmentStateResponse* initial_state_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_state_response_);
  }
  _impl_.initial_state_response_ = initial_state_response;
  if (initial_state_response) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStateRetrievalResponse.initial_state_response)
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceStateRetrievalResponse::release_initial_state_response() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* temp = _impl_.initial_state_response_;
  _impl_.initial_state_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceStateRetrievalResponse::unsafe_arena_release_initial_state_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalResponse.initial_state_response)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* temp = _impl_.initial_state_response_;
  _impl_.initial_state_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceStateRetrievalResponse::_internal_mutable_initial_state_response() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.initial_state_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateResponse>(GetArenaForAllocation());
    _impl_.initial_state_response_ = p;
  }
  return _impl_.initial_state_response_;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceStateRetrievalResponse::mutable_initial_state_response() {
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* _msg = _internal_mutable_initial_state_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalResponse.initial_state_response)
  return _msg;
}
inline void DeviceStateRetrievalResponse::set_allocated_initial_state_response(::enterprise_management::DeviceInitialEnrollmentStateResponse* initial_state_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.initial_state_response_;
  }
  if (initial_state_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initial_state_response);
    if (message_arena != submessage_arena) {
      initial_state_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_state_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.initial_state_response_ = initial_state_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalResponse.initial_state_response)
}

// optional .enterprise_management.LicenseType license_type = 5;
inline bool DeviceStateRetrievalResponse::_internal_has_license_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.license_type_ != nullptr);
  return value;
}
inline bool DeviceStateRetrievalResponse::has_license_type() const {
  return _internal_has_license_type();
}
inline void DeviceStateRetrievalResponse::clear_license_type() {
  if (_impl_.license_type_ != nullptr) _impl_.license_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::LicenseType& DeviceStateRetrievalResponse::_internal_license_type() const {
  const ::enterprise_management::LicenseType* p = _impl_.license_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LicenseType&>(
      ::enterprise_management::_LicenseType_default_instance_);
}
inline const ::enterprise_management::LicenseType& DeviceStateRetrievalResponse::license_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalResponse.license_type)
  return _internal_license_type();
}
inline void DeviceStateRetrievalResponse::unsafe_arena_set_allocated_license_type(
    ::enterprise_management::LicenseType* license_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.license_type_);
  }
  _impl_.license_type_ = license_type;
  if (license_type) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceStateRetrievalResponse.license_type)
}
inline ::enterprise_management::LicenseType* DeviceStateRetrievalResponse::release_license_type() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::LicenseType* temp = _impl_.license_type_;
  _impl_.license_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LicenseType* DeviceStateRetrievalResponse::unsafe_arena_release_license_type() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceStateRetrievalResponse.license_type)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::LicenseType* temp = _impl_.license_type_;
  _impl_.license_type_ = nullptr;
  return temp;
}
inline ::enterprise_management::LicenseType* DeviceStateRetrievalResponse::_internal_mutable_license_type() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.license_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LicenseType>(GetArenaForAllocation());
    _impl_.license_type_ = p;
  }
  return _impl_.license_type_;
}
inline ::enterprise_management::LicenseType* DeviceStateRetrievalResponse::mutable_license_type() {
  ::enterprise_management::LicenseType* _msg = _internal_mutable_license_type();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceStateRetrievalResponse.license_type)
  return _msg;
}
inline void DeviceStateRetrievalResponse::set_allocated_license_type(::enterprise_management::LicenseType* license_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.license_type_;
  }
  if (license_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(license_type);
    if (message_arena != submessage_arena) {
      license_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, license_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.license_type_ = license_type;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceStateRetrievalResponse.license_type)
}

// -------------------------------------------------------------------

// DeviceInitialEnrollmentStateRequest

// optional string serial_number = 1;
inline bool DeviceInitialEnrollmentStateRequest::_internal_has_serial_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceInitialEnrollmentStateRequest::has_serial_number() const {
  return _internal_has_serial_number();
}
inline void DeviceInitialEnrollmentStateRequest::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInitialEnrollmentStateRequest::serial_number() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInitialEnrollmentStateRequest::set_serial_number(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
}
inline std::string* DeviceInitialEnrollmentStateRequest::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
  return _s;
}
inline const std::string& DeviceInitialEnrollmentStateRequest::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void DeviceInitialEnrollmentStateRequest::_internal_set_serial_number(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInitialEnrollmentStateRequest::_internal_mutable_serial_number() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInitialEnrollmentStateRequest::release_serial_number() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
  if (!_internal_has_serial_number()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.serial_number_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInitialEnrollmentStateRequest::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceInitialEnrollmentStateRequest.serial_number)
}

// optional string brand_code = 2;
inline bool DeviceInitialEnrollmentStateRequest::_internal_has_brand_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceInitialEnrollmentStateRequest::has_brand_code() const {
  return _internal_has_brand_code();
}
inline void DeviceInitialEnrollmentStateRequest::clear_brand_code() {
  _impl_.brand_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceInitialEnrollmentStateRequest::brand_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
  return _internal_brand_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInitialEnrollmentStateRequest::set_brand_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.brand_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
}
inline std::string* DeviceInitialEnrollmentStateRequest::mutable_brand_code() {
  std::string* _s = _internal_mutable_brand_code();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
  return _s;
}
inline const std::string& DeviceInitialEnrollmentStateRequest::_internal_brand_code() const {
  return _impl_.brand_code_.Get();
}
inline void DeviceInitialEnrollmentStateRequest::_internal_set_brand_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.brand_code_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInitialEnrollmentStateRequest::_internal_mutable_brand_code() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.brand_code_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInitialEnrollmentStateRequest::release_brand_code() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
  if (!_internal_has_brand_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.brand_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brand_code_.IsDefault()) {
    _impl_.brand_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInitialEnrollmentStateRequest::set_allocated_brand_code(std::string* brand_code) {
  if (brand_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.brand_code_.SetAllocated(brand_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brand_code_.IsDefault()) {
    _impl_.brand_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceInitialEnrollmentStateRequest.brand_code)
}

// -------------------------------------------------------------------

// DeviceInitialEnrollmentStateResponse

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse.InitialEnrollmentMode initial_enrollment_mode = 1 [default = INITIAL_ENROLLMENT_MODE_NONE];
inline bool DeviceInitialEnrollmentStateResponse::_internal_has_initial_enrollment_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceInitialEnrollmentStateResponse::has_initial_enrollment_mode() const {
  return _internal_has_initial_enrollment_mode();
}
inline void DeviceInitialEnrollmentStateResponse::clear_initial_enrollment_mode() {
  _impl_.initial_enrollment_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::_internal_initial_enrollment_mode() const {
  return static_cast< ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode >(_impl_.initial_enrollment_mode_);
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::initial_enrollment_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.initial_enrollment_mode)
  return _internal_initial_enrollment_mode();
}
inline void DeviceInitialEnrollmentStateResponse::_internal_set_initial_enrollment_mode(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value) {
  assert(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.initial_enrollment_mode_ = value;
}
inline void DeviceInitialEnrollmentStateResponse::set_initial_enrollment_mode(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value) {
  _internal_set_initial_enrollment_mode(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateResponse.initial_enrollment_mode)
}

// optional string management_domain = 2;
inline bool DeviceInitialEnrollmentStateResponse::_internal_has_management_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceInitialEnrollmentStateResponse::has_management_domain() const {
  return _internal_has_management_domain();
}
inline void DeviceInitialEnrollmentStateResponse::clear_management_domain() {
  _impl_.management_domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInitialEnrollmentStateResponse::management_domain() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
  return _internal_management_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInitialEnrollmentStateResponse::set_management_domain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.management_domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
}
inline std::string* DeviceInitialEnrollmentStateResponse::mutable_management_domain() {
  std::string* _s = _internal_mutable_management_domain();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
  return _s;
}
inline const std::string& DeviceInitialEnrollmentStateResponse::_internal_management_domain() const {
  return _impl_.management_domain_.Get();
}
inline void DeviceInitialEnrollmentStateResponse::_internal_set_management_domain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.management_domain_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInitialEnrollmentStateResponse::_internal_mutable_management_domain() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.management_domain_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInitialEnrollmentStateResponse::release_management_domain() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
  if (!_internal_has_management_domain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.management_domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.management_domain_.IsDefault()) {
    _impl_.management_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInitialEnrollmentStateResponse::set_allocated_management_domain(std::string* management_domain) {
  if (management_domain != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.management_domain_.SetAllocated(management_domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.management_domain_.IsDefault()) {
    _impl_.management_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceInitialEnrollmentStateResponse.management_domain)
}

// optional bool is_license_packaged_with_device = 3;
inline bool DeviceInitialEnrollmentStateResponse::_internal_has_is_license_packaged_with_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceInitialEnrollmentStateResponse::has_is_license_packaged_with_device() const {
  return _internal_has_is_license_packaged_with_device();
}
inline void DeviceInitialEnrollmentStateResponse::clear_is_license_packaged_with_device() {
  _impl_.is_license_packaged_with_device_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DeviceInitialEnrollmentStateResponse::_internal_is_license_packaged_with_device() const {
  return _impl_.is_license_packaged_with_device_;
}
inline bool DeviceInitialEnrollmentStateResponse::is_license_packaged_with_device() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.is_license_packaged_with_device)
  return _internal_is_license_packaged_with_device();
}
inline void DeviceInitialEnrollmentStateResponse::_internal_set_is_license_packaged_with_device(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_license_packaged_with_device_ = value;
}
inline void DeviceInitialEnrollmentStateResponse::set_is_license_packaged_with_device(bool value) {
  _internal_set_is_license_packaged_with_device(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateResponse.is_license_packaged_with_device)
}

// optional .enterprise_management.DisabledState disabled_state = 4;
inline bool DeviceInitialEnrollmentStateResponse::_internal_has_disabled_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.disabled_state_ != nullptr);
  return value;
}
inline bool DeviceInitialEnrollmentStateResponse::has_disabled_state() const {
  return _internal_has_disabled_state();
}
inline void DeviceInitialEnrollmentStateResponse::clear_disabled_state() {
  if (_impl_.disabled_state_ != nullptr) _impl_.disabled_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DisabledState& DeviceInitialEnrollmentStateResponse::_internal_disabled_state() const {
  const ::enterprise_management::DisabledState* p = _impl_.disabled_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DisabledState&>(
      ::enterprise_management::_DisabledState_default_instance_);
}
inline const ::enterprise_management::DisabledState& DeviceInitialEnrollmentStateResponse::disabled_state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.disabled_state)
  return _internal_disabled_state();
}
inline void DeviceInitialEnrollmentStateResponse::unsafe_arena_set_allocated_disabled_state(
    ::enterprise_management::DisabledState* disabled_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.disabled_state_);
  }
  _impl_.disabled_state_ = disabled_state;
  if (disabled_state) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceInitialEnrollmentStateResponse.disabled_state)
}
inline ::enterprise_management::DisabledState* DeviceInitialEnrollmentStateResponse::release_disabled_state() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DisabledState* temp = _impl_.disabled_state_;
  _impl_.disabled_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DisabledState* DeviceInitialEnrollmentStateResponse::unsafe_arena_release_disabled_state() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceInitialEnrollmentStateResponse.disabled_state)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DisabledState* temp = _impl_.disabled_state_;
  _impl_.disabled_state_ = nullptr;
  return temp;
}
inline ::enterprise_management::DisabledState* DeviceInitialEnrollmentStateResponse::_internal_mutable_disabled_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.disabled_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DisabledState>(GetArenaForAllocation());
    _impl_.disabled_state_ = p;
  }
  return _impl_.disabled_state_;
}
inline ::enterprise_management::DisabledState* DeviceInitialEnrollmentStateResponse::mutable_disabled_state() {
  ::enterprise_management::DisabledState* _msg = _internal_mutable_disabled_state();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceInitialEnrollmentStateResponse.disabled_state)
  return _msg;
}
inline void DeviceInitialEnrollmentStateResponse::set_allocated_disabled_state(::enterprise_management::DisabledState* disabled_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.disabled_state_;
  }
  if (disabled_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disabled_state);
    if (message_arena != submessage_arena) {
      disabled_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disabled_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.disabled_state_ = disabled_state;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceInitialEnrollmentStateResponse.disabled_state)
}

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse.LicensePackagingSKU license_packaging_sku = 5;
inline bool DeviceInitialEnrollmentStateResponse::_internal_has_license_packaging_sku() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceInitialEnrollmentStateResponse::has_license_packaging_sku() const {
  return _internal_has_license_packaging_sku();
}
inline void DeviceInitialEnrollmentStateResponse::clear_license_packaging_sku() {
  _impl_.license_packaging_sku_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse::_internal_license_packaging_sku() const {
  return static_cast< ::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU >(_impl_.license_packaging_sku_);
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse::license_packaging_sku() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.license_packaging_sku)
  return _internal_license_packaging_sku();
}
inline void DeviceInitialEnrollmentStateResponse::_internal_set_license_packaging_sku(::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU value) {
  assert(::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.license_packaging_sku_ = value;
}
inline void DeviceInitialEnrollmentStateResponse::set_license_packaging_sku(::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU value) {
  _internal_set_license_packaging_sku(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateResponse.license_packaging_sku)
}

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse.AssignedUpgradeType assigned_upgrade_type = 6;
inline bool DeviceInitialEnrollmentStateResponse::_internal_has_assigned_upgrade_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceInitialEnrollmentStateResponse::has_assigned_upgrade_type() const {
  return _internal_has_assigned_upgrade_type();
}
inline void DeviceInitialEnrollmentStateResponse::clear_assigned_upgrade_type() {
  _impl_.assigned_upgrade_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse::_internal_assigned_upgrade_type() const {
  return static_cast< ::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType >(_impl_.assigned_upgrade_type_);
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse::assigned_upgrade_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceInitialEnrollmentStateResponse.assigned_upgrade_type)
  return _internal_assigned_upgrade_type();
}
inline void DeviceInitialEnrollmentStateResponse::_internal_set_assigned_upgrade_type(::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType value) {
  assert(::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.assigned_upgrade_type_ = value;
}
inline void DeviceInitialEnrollmentStateResponse::set_assigned_upgrade_type(::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType value) {
  _internal_set_assigned_upgrade_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceInitialEnrollmentStateResponse.assigned_upgrade_type)
}

// -------------------------------------------------------------------

// DevicePairingRequest

// optional string host_device_id = 1;
inline bool DevicePairingRequest::_internal_has_host_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePairingRequest::has_host_device_id() const {
  return _internal_has_host_device_id();
}
inline void DevicePairingRequest::clear_host_device_id() {
  _impl_.host_device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DevicePairingRequest::host_device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePairingRequest.host_device_id)
  return _internal_host_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicePairingRequest::set_host_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.host_device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePairingRequest.host_device_id)
}
inline std::string* DevicePairingRequest::mutable_host_device_id() {
  std::string* _s = _internal_mutable_host_device_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePairingRequest.host_device_id)
  return _s;
}
inline const std::string& DevicePairingRequest::_internal_host_device_id() const {
  return _impl_.host_device_id_.Get();
}
inline void DevicePairingRequest::_internal_set_host_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicePairingRequest::_internal_mutable_host_device_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.host_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicePairingRequest::release_host_device_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DevicePairingRequest.host_device_id)
  if (!_internal_has_host_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.host_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_device_id_.IsDefault()) {
    _impl_.host_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicePairingRequest::set_allocated_host_device_id(std::string* host_device_id) {
  if (host_device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_device_id_.SetAllocated(host_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_device_id_.IsDefault()) {
    _impl_.host_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DevicePairingRequest.host_device_id)
}

// optional string controller_device_id = 2;
inline bool DevicePairingRequest::_internal_has_controller_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DevicePairingRequest::has_controller_device_id() const {
  return _internal_has_controller_device_id();
}
inline void DevicePairingRequest::clear_controller_device_id() {
  _impl_.controller_device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DevicePairingRequest::controller_device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePairingRequest.controller_device_id)
  return _internal_controller_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicePairingRequest::set_controller_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.controller_device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePairingRequest.controller_device_id)
}
inline std::string* DevicePairingRequest::mutable_controller_device_id() {
  std::string* _s = _internal_mutable_controller_device_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DevicePairingRequest.controller_device_id)
  return _s;
}
inline const std::string& DevicePairingRequest::_internal_controller_device_id() const {
  return _impl_.controller_device_id_.Get();
}
inline void DevicePairingRequest::_internal_set_controller_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.controller_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicePairingRequest::_internal_mutable_controller_device_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.controller_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicePairingRequest::release_controller_device_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DevicePairingRequest.controller_device_id)
  if (!_internal_has_controller_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.controller_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.controller_device_id_.IsDefault()) {
    _impl_.controller_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicePairingRequest::set_allocated_controller_device_id(std::string* controller_device_id) {
  if (controller_device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.controller_device_id_.SetAllocated(controller_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.controller_device_id_.IsDefault()) {
    _impl_.controller_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DevicePairingRequest.controller_device_id)
}

// -------------------------------------------------------------------

// DevicePairingResponse

// optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
inline bool DevicePairingResponse::_internal_has_status_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicePairingResponse::has_status_code() const {
  return _internal_has_status_code();
}
inline void DevicePairingResponse::clear_status_code() {
  _impl_.status_code_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DevicePairingResponse_StatusCode DevicePairingResponse::_internal_status_code() const {
  return static_cast< ::enterprise_management::DevicePairingResponse_StatusCode >(_impl_.status_code_);
}
inline ::enterprise_management::DevicePairingResponse_StatusCode DevicePairingResponse::status_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DevicePairingResponse.status_code)
  return _internal_status_code();
}
inline void DevicePairingResponse::_internal_set_status_code(::enterprise_management::DevicePairingResponse_StatusCode value) {
  assert(::enterprise_management::DevicePairingResponse_StatusCode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_code_ = value;
}
inline void DevicePairingResponse::set_status_code(::enterprise_management::DevicePairingResponse_StatusCode value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DevicePairingResponse.status_code)
}

// -------------------------------------------------------------------

// CheckDevicePairingRequest

// optional string host_device_id = 1;
inline bool CheckDevicePairingRequest::_internal_has_host_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckDevicePairingRequest::has_host_device_id() const {
  return _internal_has_host_device_id();
}
inline void CheckDevicePairingRequest::clear_host_device_id() {
  _impl_.host_device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckDevicePairingRequest::host_device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingRequest.host_device_id)
  return _internal_host_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckDevicePairingRequest::set_host_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.host_device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingRequest.host_device_id)
}
inline std::string* CheckDevicePairingRequest::mutable_host_device_id() {
  std::string* _s = _internal_mutable_host_device_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CheckDevicePairingRequest.host_device_id)
  return _s;
}
inline const std::string& CheckDevicePairingRequest::_internal_host_device_id() const {
  return _impl_.host_device_id_.Get();
}
inline void CheckDevicePairingRequest::_internal_set_host_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckDevicePairingRequest::_internal_mutable_host_device_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.host_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckDevicePairingRequest::release_host_device_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.CheckDevicePairingRequest.host_device_id)
  if (!_internal_has_host_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.host_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_device_id_.IsDefault()) {
    _impl_.host_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CheckDevicePairingRequest::set_allocated_host_device_id(std::string* host_device_id) {
  if (host_device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_device_id_.SetAllocated(host_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_device_id_.IsDefault()) {
    _impl_.host_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CheckDevicePairingRequest.host_device_id)
}

// optional string controller_device_id = 2;
inline bool CheckDevicePairingRequest::_internal_has_controller_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CheckDevicePairingRequest::has_controller_device_id() const {
  return _internal_has_controller_device_id();
}
inline void CheckDevicePairingRequest::clear_controller_device_id() {
  _impl_.controller_device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CheckDevicePairingRequest::controller_device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingRequest.controller_device_id)
  return _internal_controller_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckDevicePairingRequest::set_controller_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.controller_device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}
inline std::string* CheckDevicePairingRequest::mutable_controller_device_id() {
  std::string* _s = _internal_mutable_controller_device_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CheckDevicePairingRequest.controller_device_id)
  return _s;
}
inline const std::string& CheckDevicePairingRequest::_internal_controller_device_id() const {
  return _impl_.controller_device_id_.Get();
}
inline void CheckDevicePairingRequest::_internal_set_controller_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.controller_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckDevicePairingRequest::_internal_mutable_controller_device_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.controller_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckDevicePairingRequest::release_controller_device_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.CheckDevicePairingRequest.controller_device_id)
  if (!_internal_has_controller_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.controller_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.controller_device_id_.IsDefault()) {
    _impl_.controller_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CheckDevicePairingRequest::set_allocated_controller_device_id(std::string* controller_device_id) {
  if (controller_device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.controller_device_id_.SetAllocated(controller_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.controller_device_id_.IsDefault()) {
    _impl_.controller_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CheckDevicePairingRequest.controller_device_id)
}

// -------------------------------------------------------------------

// CheckDevicePairingResponse

// optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
inline bool CheckDevicePairingResponse::_internal_has_status_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckDevicePairingResponse::has_status_code() const {
  return _internal_has_status_code();
}
inline void CheckDevicePairingResponse::clear_status_code() {
  _impl_.status_code_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::_internal_status_code() const {
  return static_cast< ::enterprise_management::CheckDevicePairingResponse_StatusCode >(_impl_.status_code_);
}
inline ::enterprise_management::CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::status_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CheckDevicePairingResponse.status_code)
  return _internal_status_code();
}
inline void CheckDevicePairingResponse::_internal_set_status_code(::enterprise_management::CheckDevicePairingResponse_StatusCode value) {
  assert(::enterprise_management::CheckDevicePairingResponse_StatusCode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_code_ = value;
}
inline void CheckDevicePairingResponse::set_status_code(::enterprise_management::CheckDevicePairingResponse_StatusCode value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CheckDevicePairingResponse.status_code)
}

// -------------------------------------------------------------------

// RemoteCommand

// optional .enterprise_management.RemoteCommand.Type type = 1;
inline bool RemoteCommand::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RemoteCommand::has_type() const {
  return _internal_has_type();
}
inline void RemoteCommand::clear_type() {
  _impl_.type_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::RemoteCommand_Type RemoteCommand::_internal_type() const {
  return static_cast< ::enterprise_management::RemoteCommand_Type >(_impl_.type_);
}
inline ::enterprise_management::RemoteCommand_Type RemoteCommand::type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.type)
  return _internal_type();
}
inline void RemoteCommand::_internal_set_type(::enterprise_management::RemoteCommand_Type value) {
  assert(::enterprise_management::RemoteCommand_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void RemoteCommand::set_type(::enterprise_management::RemoteCommand_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.type)
}

// optional int64 command_id = 2;
inline bool RemoteCommand::_internal_has_command_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoteCommand::has_command_id() const {
  return _internal_has_command_id();
}
inline void RemoteCommand::clear_command_id() {
  _impl_.command_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t RemoteCommand::_internal_command_id() const {
  return _impl_.command_id_;
}
inline int64_t RemoteCommand::command_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.command_id)
  return _internal_command_id();
}
inline void RemoteCommand::_internal_set_command_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.command_id_ = value;
}
inline void RemoteCommand::set_command_id(int64_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.command_id)
}

// optional int64 age_of_command = 3;
inline bool RemoteCommand::_internal_has_age_of_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemoteCommand::has_age_of_command() const {
  return _internal_has_age_of_command();
}
inline void RemoteCommand::clear_age_of_command() {
  _impl_.age_of_command_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t RemoteCommand::_internal_age_of_command() const {
  return _impl_.age_of_command_;
}
inline int64_t RemoteCommand::age_of_command() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.age_of_command)
  return _internal_age_of_command();
}
inline void RemoteCommand::_internal_set_age_of_command(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.age_of_command_ = value;
}
inline void RemoteCommand::set_age_of_command(int64_t value) {
  _internal_set_age_of_command(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.age_of_command)
}

// optional string payload = 4;
inline bool RemoteCommand::_internal_has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemoteCommand::has_payload() const {
  return _internal_has_payload();
}
inline void RemoteCommand::clear_payload() {
  _impl_.payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoteCommand::payload() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteCommand::set_payload(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.payload)
}
inline std::string* RemoteCommand::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RemoteCommand.payload)
  return _s;
}
inline const std::string& RemoteCommand::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void RemoteCommand::_internal_set_payload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteCommand::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteCommand::release_payload() {
  // @@protoc_insertion_point(field_release:enterprise_management.RemoteCommand.payload)
  if (!_internal_has_payload()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RemoteCommand::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RemoteCommand.payload)
}

// optional string target_device_id = 5;
inline bool RemoteCommand::_internal_has_target_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoteCommand::has_target_device_id() const {
  return _internal_has_target_device_id();
}
inline void RemoteCommand::clear_target_device_id() {
  _impl_.target_device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RemoteCommand::target_device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommand.target_device_id)
  return _internal_target_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteCommand::set_target_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.target_device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommand.target_device_id)
}
inline std::string* RemoteCommand::mutable_target_device_id() {
  std::string* _s = _internal_mutable_target_device_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RemoteCommand.target_device_id)
  return _s;
}
inline const std::string& RemoteCommand::_internal_target_device_id() const {
  return _impl_.target_device_id_.Get();
}
inline void RemoteCommand::_internal_set_target_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.target_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteCommand::_internal_mutable_target_device_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.target_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteCommand::release_target_device_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.RemoteCommand.target_device_id)
  if (!_internal_has_target_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.target_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_device_id_.IsDefault()) {
    _impl_.target_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RemoteCommand::set_allocated_target_device_id(std::string* target_device_id) {
  if (target_device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.target_device_id_.SetAllocated(target_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_device_id_.IsDefault()) {
    _impl_.target_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RemoteCommand.target_device_id)
}

// -------------------------------------------------------------------

// RemoteCommandResult

// optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
inline bool RemoteCommandResult::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemoteCommandResult::has_result() const {
  return _internal_has_result();
}
inline void RemoteCommandResult::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::RemoteCommandResult_ResultType RemoteCommandResult::_internal_result() const {
  return static_cast< ::enterprise_management::RemoteCommandResult_ResultType >(_impl_.result_);
}
inline ::enterprise_management::RemoteCommandResult_ResultType RemoteCommandResult::result() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.result)
  return _internal_result();
}
inline void RemoteCommandResult::_internal_set_result(::enterprise_management::RemoteCommandResult_ResultType value) {
  assert(::enterprise_management::RemoteCommandResult_ResultType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.result_ = value;
}
inline void RemoteCommandResult::set_result(::enterprise_management::RemoteCommandResult_ResultType value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.result)
}

// optional int64 command_id = 2;
inline bool RemoteCommandResult::_internal_has_command_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoteCommandResult::has_command_id() const {
  return _internal_has_command_id();
}
inline void RemoteCommandResult::clear_command_id() {
  _impl_.command_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t RemoteCommandResult::_internal_command_id() const {
  return _impl_.command_id_;
}
inline int64_t RemoteCommandResult::command_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.command_id)
  return _internal_command_id();
}
inline void RemoteCommandResult::_internal_set_command_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.command_id_ = value;
}
inline void RemoteCommandResult::set_command_id(int64_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.command_id)
}

// optional int64 timestamp = 3;
inline bool RemoteCommandResult::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoteCommandResult::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void RemoteCommandResult::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t RemoteCommandResult::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t RemoteCommandResult::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.timestamp)
  return _internal_timestamp();
}
inline void RemoteCommandResult::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ = value;
}
inline void RemoteCommandResult::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.timestamp)
}

// optional string payload = 4;
inline bool RemoteCommandResult::_internal_has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemoteCommandResult::has_payload() const {
  return _internal_has_payload();
}
inline void RemoteCommandResult::clear_payload() {
  _impl_.payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoteCommandResult::payload() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RemoteCommandResult.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteCommandResult::set_payload(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RemoteCommandResult.payload)
}
inline std::string* RemoteCommandResult::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RemoteCommandResult.payload)
  return _s;
}
inline const std::string& RemoteCommandResult::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void RemoteCommandResult::_internal_set_payload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteCommandResult::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteCommandResult::release_payload() {
  // @@protoc_insertion_point(field_release:enterprise_management.RemoteCommandResult.payload)
  if (!_internal_has_payload()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RemoteCommandResult::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RemoteCommandResult.payload)
}

// -------------------------------------------------------------------

// DeviceRemoteCommandRequest

// optional int64 last_command_unique_id = 1;
inline bool DeviceRemoteCommandRequest::_internal_has_last_command_unique_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceRemoteCommandRequest::has_last_command_unique_id() const {
  return _internal_has_last_command_unique_id();
}
inline void DeviceRemoteCommandRequest::clear_last_command_unique_id() {
  _impl_.last_command_unique_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t DeviceRemoteCommandRequest::_internal_last_command_unique_id() const {
  return _impl_.last_command_unique_id_;
}
inline int64_t DeviceRemoteCommandRequest::last_command_unique_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.last_command_unique_id)
  return _internal_last_command_unique_id();
}
inline void DeviceRemoteCommandRequest::_internal_set_last_command_unique_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.last_command_unique_id_ = value;
}
inline void DeviceRemoteCommandRequest::set_last_command_unique_id(int64_t value) {
  _internal_set_last_command_unique_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRemoteCommandRequest.last_command_unique_id)
}

// repeated .enterprise_management.RemoteCommandResult command_results = 2;
inline int DeviceRemoteCommandRequest::_internal_command_results_size() const {
  return _impl_.command_results_.size();
}
inline int DeviceRemoteCommandRequest::command_results_size() const {
  return _internal_command_results_size();
}
inline void DeviceRemoteCommandRequest::clear_command_results() {
  _impl_.command_results_.Clear();
}
inline ::enterprise_management::RemoteCommandResult* DeviceRemoteCommandRequest::mutable_command_results(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRemoteCommandRequest.command_results)
  return _impl_.command_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult >*
DeviceRemoteCommandRequest::mutable_command_results() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRemoteCommandRequest.command_results)
  return &_impl_.command_results_;
}
inline const ::enterprise_management::RemoteCommandResult& DeviceRemoteCommandRequest::_internal_command_results(int index) const {
  return _impl_.command_results_.Get(index);
}
inline const ::enterprise_management::RemoteCommandResult& DeviceRemoteCommandRequest::command_results(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.command_results)
  return _internal_command_results(index);
}
inline ::enterprise_management::RemoteCommandResult* DeviceRemoteCommandRequest::_internal_add_command_results() {
  return _impl_.command_results_.Add();
}
inline ::enterprise_management::RemoteCommandResult* DeviceRemoteCommandRequest::add_command_results() {
  ::enterprise_management::RemoteCommandResult* _add = _internal_add_command_results();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceRemoteCommandRequest.command_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommandResult >&
DeviceRemoteCommandRequest::command_results() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceRemoteCommandRequest.command_results)
  return _impl_.command_results_;
}

// optional bool send_secure_commands = 3;
inline bool DeviceRemoteCommandRequest::_internal_has_send_secure_commands() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceRemoteCommandRequest::has_send_secure_commands() const {
  return _internal_has_send_secure_commands();
}
inline void DeviceRemoteCommandRequest::clear_send_secure_commands() {
  _impl_.send_secure_commands_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DeviceRemoteCommandRequest::_internal_send_secure_commands() const {
  return _impl_.send_secure_commands_;
}
inline bool DeviceRemoteCommandRequest::send_secure_commands() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.send_secure_commands)
  return _internal_send_secure_commands();
}
inline void DeviceRemoteCommandRequest::_internal_set_send_secure_commands(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.send_secure_commands_ = value;
}
inline void DeviceRemoteCommandRequest::set_send_secure_commands(bool value) {
  _internal_set_send_secure_commands(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRemoteCommandRequest.send_secure_commands)
}

// optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 4;
inline bool DeviceRemoteCommandRequest::_internal_has_signature_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceRemoteCommandRequest::has_signature_type() const {
  return _internal_has_signature_type();
}
inline void DeviceRemoteCommandRequest::clear_signature_type() {
  _impl_.signature_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType DeviceRemoteCommandRequest::_internal_signature_type() const {
  return static_cast< ::enterprise_management::PolicyFetchRequest_SignatureType >(_impl_.signature_type_);
}
inline ::enterprise_management::PolicyFetchRequest_SignatureType DeviceRemoteCommandRequest::signature_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandRequest.signature_type)
  return _internal_signature_type();
}
inline void DeviceRemoteCommandRequest::_internal_set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
  assert(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.signature_type_ = value;
}
inline void DeviceRemoteCommandRequest::set_signature_type(::enterprise_management::PolicyFetchRequest_SignatureType value) {
  _internal_set_signature_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRemoteCommandRequest.signature_type)
}

// -------------------------------------------------------------------

// DeviceRemoteCommandResponse

// repeated .enterprise_management.RemoteCommand commands = 1;
inline int DeviceRemoteCommandResponse::_internal_commands_size() const {
  return _impl_.commands_.size();
}
inline int DeviceRemoteCommandResponse::commands_size() const {
  return _internal_commands_size();
}
inline void DeviceRemoteCommandResponse::clear_commands() {
  _impl_.commands_.Clear();
}
inline ::enterprise_management::RemoteCommand* DeviceRemoteCommandResponse::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRemoteCommandResponse.commands)
  return _impl_.commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand >*
DeviceRemoteCommandResponse::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRemoteCommandResponse.commands)
  return &_impl_.commands_;
}
inline const ::enterprise_management::RemoteCommand& DeviceRemoteCommandResponse::_internal_commands(int index) const {
  return _impl_.commands_.Get(index);
}
inline const ::enterprise_management::RemoteCommand& DeviceRemoteCommandResponse::commands(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandResponse.commands)
  return _internal_commands(index);
}
inline ::enterprise_management::RemoteCommand* DeviceRemoteCommandResponse::_internal_add_commands() {
  return _impl_.commands_.Add();
}
inline ::enterprise_management::RemoteCommand* DeviceRemoteCommandResponse::add_commands() {
  ::enterprise_management::RemoteCommand* _add = _internal_add_commands();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceRemoteCommandResponse.commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::RemoteCommand >&
DeviceRemoteCommandResponse::commands() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceRemoteCommandResponse.commands)
  return _impl_.commands_;
}

// repeated .enterprise_management.SignedData secure_commands = 2;
inline int DeviceRemoteCommandResponse::_internal_secure_commands_size() const {
  return _impl_.secure_commands_.size();
}
inline int DeviceRemoteCommandResponse::secure_commands_size() const {
  return _internal_secure_commands_size();
}
inline void DeviceRemoteCommandResponse::clear_secure_commands() {
  _impl_.secure_commands_.Clear();
}
inline ::enterprise_management::SignedData* DeviceRemoteCommandResponse::mutable_secure_commands(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
  return _impl_.secure_commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData >*
DeviceRemoteCommandResponse::mutable_secure_commands() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
  return &_impl_.secure_commands_;
}
inline const ::enterprise_management::SignedData& DeviceRemoteCommandResponse::_internal_secure_commands(int index) const {
  return _impl_.secure_commands_.Get(index);
}
inline const ::enterprise_management::SignedData& DeviceRemoteCommandResponse::secure_commands(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
  return _internal_secure_commands(index);
}
inline ::enterprise_management::SignedData* DeviceRemoteCommandResponse::_internal_add_secure_commands() {
  return _impl_.secure_commands_.Add();
}
inline ::enterprise_management::SignedData* DeviceRemoteCommandResponse::add_secure_commands() {
  ::enterprise_management::SignedData* _add = _internal_add_secure_commands();
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::SignedData >&
DeviceRemoteCommandResponse::secure_commands() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceRemoteCommandResponse.secure_commands)
  return _impl_.secure_commands_;
}

// -------------------------------------------------------------------

// DeviceAttributeUpdatePermissionRequest

// -------------------------------------------------------------------

// DeviceAttributeUpdatePermissionResponse

// optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
inline bool DeviceAttributeUpdatePermissionResponse::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceAttributeUpdatePermissionResponse::has_result() const {
  return _internal_has_result();
}
inline void DeviceAttributeUpdatePermissionResponse::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse::_internal_result() const {
  return static_cast< ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType >(_impl_.result_);
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse::result() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdatePermissionResponse.result)
  return _internal_result();
}
inline void DeviceAttributeUpdatePermissionResponse::_internal_set_result(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType value) {
  assert(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void DeviceAttributeUpdatePermissionResponse::set_result(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdatePermissionResponse.result)
}

// -------------------------------------------------------------------

// DeviceAttributeUpdateRequest

// optional string asset_id = 1;
inline bool DeviceAttributeUpdateRequest::_internal_has_asset_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceAttributeUpdateRequest::has_asset_id() const {
  return _internal_has_asset_id();
}
inline void DeviceAttributeUpdateRequest::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceAttributeUpdateRequest::asset_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceAttributeUpdateRequest::set_asset_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.asset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}
inline std::string* DeviceAttributeUpdateRequest::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
  return _s;
}
inline const std::string& DeviceAttributeUpdateRequest::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void DeviceAttributeUpdateRequest::_internal_set_asset_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceAttributeUpdateRequest::_internal_mutable_asset_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceAttributeUpdateRequest::release_asset_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
  if (!_internal_has_asset_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.asset_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceAttributeUpdateRequest::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceAttributeUpdateRequest.asset_id)
}

// optional string location = 2;
inline bool DeviceAttributeUpdateRequest::_internal_has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceAttributeUpdateRequest::has_location() const {
  return _internal_has_location();
}
inline void DeviceAttributeUpdateRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceAttributeUpdateRequest::location() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceAttributeUpdateRequest::set_location(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateRequest.location)
}
inline std::string* DeviceAttributeUpdateRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceAttributeUpdateRequest.location)
  return _s;
}
inline const std::string& DeviceAttributeUpdateRequest::_internal_location() const {
  return _impl_.location_.Get();
}
inline void DeviceAttributeUpdateRequest::_internal_set_location(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceAttributeUpdateRequest::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceAttributeUpdateRequest::release_location() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceAttributeUpdateRequest.location)
  if (!_internal_has_location()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.location_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceAttributeUpdateRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceAttributeUpdateRequest.location)
}

// -------------------------------------------------------------------

// DeviceAttributeUpdateResponse

// optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
inline bool DeviceAttributeUpdateResponse::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceAttributeUpdateResponse::has_result() const {
  return _internal_has_result();
}
inline void DeviceAttributeUpdateResponse::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse::_internal_result() const {
  return static_cast< ::enterprise_management::DeviceAttributeUpdateResponse_ResultType >(_impl_.result_);
}
inline ::enterprise_management::DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse::result() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceAttributeUpdateResponse.result)
  return _internal_result();
}
inline void DeviceAttributeUpdateResponse::_internal_set_result(::enterprise_management::DeviceAttributeUpdateResponse_ResultType value) {
  assert(::enterprise_management::DeviceAttributeUpdateResponse_ResultType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void DeviceAttributeUpdateResponse::set_result(::enterprise_management::DeviceAttributeUpdateResponse_ResultType value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceAttributeUpdateResponse.result)
}

// -------------------------------------------------------------------

// GcmIdUpdateRequest

// optional string gcm_id = 1;
inline bool GcmIdUpdateRequest::_internal_has_gcm_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GcmIdUpdateRequest::has_gcm_id() const {
  return _internal_has_gcm_id();
}
inline void GcmIdUpdateRequest::clear_gcm_id() {
  _impl_.gcm_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GcmIdUpdateRequest::gcm_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.GcmIdUpdateRequest.gcm_id)
  return _internal_gcm_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GcmIdUpdateRequest::set_gcm_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.gcm_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.GcmIdUpdateRequest.gcm_id)
}
inline std::string* GcmIdUpdateRequest::mutable_gcm_id() {
  std::string* _s = _internal_mutable_gcm_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.GcmIdUpdateRequest.gcm_id)
  return _s;
}
inline const std::string& GcmIdUpdateRequest::_internal_gcm_id() const {
  return _impl_.gcm_id_.Get();
}
inline void GcmIdUpdateRequest::_internal_set_gcm_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gcm_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GcmIdUpdateRequest::_internal_mutable_gcm_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gcm_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GcmIdUpdateRequest::release_gcm_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.GcmIdUpdateRequest.gcm_id)
  if (!_internal_has_gcm_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.gcm_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gcm_id_.IsDefault()) {
    _impl_.gcm_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GcmIdUpdateRequest::set_allocated_gcm_id(std::string* gcm_id) {
  if (gcm_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gcm_id_.SetAllocated(gcm_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gcm_id_.IsDefault()) {
    _impl_.gcm_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.GcmIdUpdateRequest.gcm_id)
}

// -------------------------------------------------------------------

// GcmIdUpdateResponse

// -------------------------------------------------------------------

// CheckAndroidManagementRequest

// -------------------------------------------------------------------

// CheckAndroidManagementResponse

// -------------------------------------------------------------------

// CertificateBasedDeviceRegisterRequest

// optional .enterprise_management.SignedData signed_request = 1;
inline bool CertificateBasedDeviceRegisterRequest::_internal_has_signed_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.signed_request_ != nullptr);
  return value;
}
inline bool CertificateBasedDeviceRegisterRequest::has_signed_request() const {
  return _internal_has_signed_request();
}
inline void CertificateBasedDeviceRegisterRequest::clear_signed_request() {
  if (_impl_.signed_request_ != nullptr) _impl_.signed_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::SignedData& CertificateBasedDeviceRegisterRequest::_internal_signed_request() const {
  const ::enterprise_management::SignedData* p = _impl_.signed_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SignedData&>(
      ::enterprise_management::_SignedData_default_instance_);
}
inline const ::enterprise_management::SignedData& CertificateBasedDeviceRegisterRequest::signed_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
  return _internal_signed_request();
}
inline void CertificateBasedDeviceRegisterRequest::unsafe_arena_set_allocated_signed_request(
    ::enterprise_management::SignedData* signed_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signed_request_);
  }
  _impl_.signed_request_ = signed_request;
  if (signed_request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
}
inline ::enterprise_management::SignedData* CertificateBasedDeviceRegisterRequest::release_signed_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::SignedData* temp = _impl_.signed_request_;
  _impl_.signed_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SignedData* CertificateBasedDeviceRegisterRequest::unsafe_arena_release_signed_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::SignedData* temp = _impl_.signed_request_;
  _impl_.signed_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::SignedData* CertificateBasedDeviceRegisterRequest::_internal_mutable_signed_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.signed_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SignedData>(GetArenaForAllocation());
    _impl_.signed_request_ = p;
  }
  return _impl_.signed_request_;
}
inline ::enterprise_management::SignedData* CertificateBasedDeviceRegisterRequest::mutable_signed_request() {
  ::enterprise_management::SignedData* _msg = _internal_mutable_signed_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
  return _msg;
}
inline void CertificateBasedDeviceRegisterRequest::set_allocated_signed_request(::enterprise_management::SignedData* signed_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.signed_request_;
  }
  if (signed_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signed_request);
    if (message_arena != submessage_arena) {
      signed_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signed_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signed_request_ = signed_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegisterRequest.signed_request)
}

// -------------------------------------------------------------------

// DeviceRegisterConfiguration

// optional string device_owner = 1;
inline bool DeviceRegisterConfiguration::_internal_has_device_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceRegisterConfiguration::has_device_owner() const {
  return _internal_has_device_owner();
}
inline void DeviceRegisterConfiguration::clear_device_owner() {
  _impl_.device_owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceRegisterConfiguration::device_owner() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceRegisterConfiguration.device_owner)
  return _internal_device_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceRegisterConfiguration::set_device_owner(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceRegisterConfiguration.device_owner)
}
inline std::string* DeviceRegisterConfiguration::mutable_device_owner() {
  std::string* _s = _internal_mutable_device_owner();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceRegisterConfiguration.device_owner)
  return _s;
}
inline const std::string& DeviceRegisterConfiguration::_internal_device_owner() const {
  return _impl_.device_owner_.Get();
}
inline void DeviceRegisterConfiguration::_internal_set_device_owner(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_owner_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceRegisterConfiguration::_internal_mutable_device_owner() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_owner_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceRegisterConfiguration::release_device_owner() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceRegisterConfiguration.device_owner)
  if (!_internal_has_device_owner()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_owner_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_owner_.IsDefault()) {
    _impl_.device_owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceRegisterConfiguration::set_allocated_device_owner(std::string* device_owner) {
  if (device_owner != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_owner_.SetAllocated(device_owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_owner_.IsDefault()) {
    _impl_.device_owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceRegisterConfiguration.device_owner)
}

// -------------------------------------------------------------------

// CertificateBasedDeviceRegistrationData

// optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
inline bool CertificateBasedDeviceRegistrationData::_internal_has_certificate_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CertificateBasedDeviceRegistrationData::has_certificate_type() const {
  return _internal_has_certificate_type();
}
inline void CertificateBasedDeviceRegistrationData::clear_certificate_type() {
  _impl_.certificate_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData::_internal_certificate_type() const {
  return static_cast< ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType >(_impl_.certificate_type_);
}
inline ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData::certificate_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.certificate_type)
  return _internal_certificate_type();
}
inline void CertificateBasedDeviceRegistrationData::_internal_set_certificate_type(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType value) {
  assert(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.certificate_type_ = value;
}
inline void CertificateBasedDeviceRegistrationData::set_certificate_type(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType value) {
  _internal_set_certificate_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CertificateBasedDeviceRegistrationData.certificate_type)
}

// optional bytes device_certificate = 2;
inline bool CertificateBasedDeviceRegistrationData::_internal_has_device_certificate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertificateBasedDeviceRegistrationData::has_device_certificate() const {
  return _internal_has_device_certificate();
}
inline void CertificateBasedDeviceRegistrationData::clear_device_certificate() {
  _impl_.device_certificate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertificateBasedDeviceRegistrationData::device_certificate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
  return _internal_device_certificate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertificateBasedDeviceRegistrationData::set_device_certificate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_certificate_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}
inline std::string* CertificateBasedDeviceRegistrationData::mutable_device_certificate() {
  std::string* _s = _internal_mutable_device_certificate();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
  return _s;
}
inline const std::string& CertificateBasedDeviceRegistrationData::_internal_device_certificate() const {
  return _impl_.device_certificate_.Get();
}
inline void CertificateBasedDeviceRegistrationData::_internal_set_device_certificate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_certificate_.Set(value, GetArenaForAllocation());
}
inline std::string* CertificateBasedDeviceRegistrationData::_internal_mutable_device_certificate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_certificate_.Mutable(GetArenaForAllocation());
}
inline std::string* CertificateBasedDeviceRegistrationData::release_device_certificate() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
  if (!_internal_has_device_certificate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_certificate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_certificate_.IsDefault()) {
    _impl_.device_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CertificateBasedDeviceRegistrationData::set_allocated_device_certificate(std::string* device_certificate) {
  if (device_certificate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_certificate_.SetAllocated(device_certificate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_certificate_.IsDefault()) {
    _impl_.device_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_certificate)
}

// optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
inline bool CertificateBasedDeviceRegistrationData::_internal_has_device_register_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_register_request_ != nullptr);
  return value;
}
inline bool CertificateBasedDeviceRegistrationData::has_device_register_request() const {
  return _internal_has_device_register_request();
}
inline void CertificateBasedDeviceRegistrationData::clear_device_register_request() {
  if (_impl_.device_register_request_ != nullptr) _impl_.device_register_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DeviceRegisterRequest& CertificateBasedDeviceRegistrationData::_internal_device_register_request() const {
  const ::enterprise_management::DeviceRegisterRequest* p = _impl_.device_register_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRegisterRequest&>(
      ::enterprise_management::_DeviceRegisterRequest_default_instance_);
}
inline const ::enterprise_management::DeviceRegisterRequest& CertificateBasedDeviceRegistrationData::device_register_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
  return _internal_device_register_request();
}
inline void CertificateBasedDeviceRegistrationData::unsafe_arena_set_allocated_device_register_request(
    ::enterprise_management::DeviceRegisterRequest* device_register_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_register_request_);
  }
  _impl_.device_register_request_ = device_register_request;
  if (device_register_request) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
}
inline ::enterprise_management::DeviceRegisterRequest* CertificateBasedDeviceRegistrationData::release_device_register_request() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DeviceRegisterRequest* temp = _impl_.device_register_request_;
  _impl_.device_register_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRegisterRequest* CertificateBasedDeviceRegistrationData::unsafe_arena_release_device_register_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DeviceRegisterRequest* temp = _impl_.device_register_request_;
  _impl_.device_register_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRegisterRequest* CertificateBasedDeviceRegistrationData::_internal_mutable_device_register_request() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.device_register_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterRequest>(GetArenaForAllocation());
    _impl_.device_register_request_ = p;
  }
  return _impl_.device_register_request_;
}
inline ::enterprise_management::DeviceRegisterRequest* CertificateBasedDeviceRegistrationData::mutable_device_register_request() {
  ::enterprise_management::DeviceRegisterRequest* _msg = _internal_mutable_device_register_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
  return _msg;
}
inline void CertificateBasedDeviceRegistrationData::set_allocated_device_register_request(::enterprise_management::DeviceRegisterRequest* device_register_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_register_request_;
  }
  if (device_register_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_register_request);
    if (message_arena != submessage_arena) {
      device_register_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_register_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.device_register_request_ = device_register_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_request)
}

// optional .enterprise_management.DeviceRegisterConfiguration device_register_configuration = 4;
inline bool CertificateBasedDeviceRegistrationData::_internal_has_device_register_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_register_configuration_ != nullptr);
  return value;
}
inline bool CertificateBasedDeviceRegistrationData::has_device_register_configuration() const {
  return _internal_has_device_register_configuration();
}
inline void CertificateBasedDeviceRegistrationData::clear_device_register_configuration() {
  if (_impl_.device_register_configuration_ != nullptr) _impl_.device_register_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::DeviceRegisterConfiguration& CertificateBasedDeviceRegistrationData::_internal_device_register_configuration() const {
  const ::enterprise_management::DeviceRegisterConfiguration* p = _impl_.device_register_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRegisterConfiguration&>(
      ::enterprise_management::_DeviceRegisterConfiguration_default_instance_);
}
inline const ::enterprise_management::DeviceRegisterConfiguration& CertificateBasedDeviceRegistrationData::device_register_configuration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
  return _internal_device_register_configuration();
}
inline void CertificateBasedDeviceRegistrationData::unsafe_arena_set_allocated_device_register_configuration(
    ::enterprise_management::DeviceRegisterConfiguration* device_register_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_register_configuration_);
  }
  _impl_.device_register_configuration_ = device_register_configuration;
  if (device_register_configuration) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
}
inline ::enterprise_management::DeviceRegisterConfiguration* CertificateBasedDeviceRegistrationData::release_device_register_configuration() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::DeviceRegisterConfiguration* temp = _impl_.device_register_configuration_;
  _impl_.device_register_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRegisterConfiguration* CertificateBasedDeviceRegistrationData::unsafe_arena_release_device_register_configuration() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::DeviceRegisterConfiguration* temp = _impl_.device_register_configuration_;
  _impl_.device_register_configuration_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRegisterConfiguration* CertificateBasedDeviceRegistrationData::_internal_mutable_device_register_configuration() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.device_register_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterConfiguration>(GetArenaForAllocation());
    _impl_.device_register_configuration_ = p;
  }
  return _impl_.device_register_configuration_;
}
inline ::enterprise_management::DeviceRegisterConfiguration* CertificateBasedDeviceRegistrationData::mutable_device_register_configuration() {
  ::enterprise_management::DeviceRegisterConfiguration* _msg = _internal_mutable_device_register_configuration();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
  return _msg;
}
inline void CertificateBasedDeviceRegistrationData::set_allocated_device_register_configuration(::enterprise_management::DeviceRegisterConfiguration* device_register_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_register_configuration_;
  }
  if (device_register_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_register_configuration);
    if (message_arena != submessage_arena) {
      device_register_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_register_configuration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.device_register_configuration_ = device_register_configuration;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertificateBasedDeviceRegistrationData.device_register_configuration)
}

// -------------------------------------------------------------------

// RegisterBrowserRequest

// optional string machine_name = 1;
inline bool RegisterBrowserRequest::_internal_has_machine_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegisterBrowserRequest::has_machine_name() const {
  return _internal_has_machine_name();
}
inline void RegisterBrowserRequest::clear_machine_name() {
  _impl_.machine_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterBrowserRequest::machine_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.machine_name)
  return _internal_machine_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterBrowserRequest::set_machine_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.machine_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RegisterBrowserRequest.machine_name)
}
inline std::string* RegisterBrowserRequest::mutable_machine_name() {
  std::string* _s = _internal_mutable_machine_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.machine_name)
  return _s;
}
inline const std::string& RegisterBrowserRequest::_internal_machine_name() const {
  return _impl_.machine_name_.Get();
}
inline void RegisterBrowserRequest::_internal_set_machine_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.machine_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::_internal_mutable_machine_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.machine_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::release_machine_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.machine_name)
  if (!_internal_has_machine_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.machine_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterBrowserRequest::set_allocated_machine_name(std::string* machine_name) {
  if (machine_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.machine_name_.SetAllocated(machine_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.machine_name)
}

// optional string os_platform = 2;
inline bool RegisterBrowserRequest::_internal_has_os_platform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegisterBrowserRequest::has_os_platform() const {
  return _internal_has_os_platform();
}
inline void RegisterBrowserRequest::clear_os_platform() {
  _impl_.os_platform_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegisterBrowserRequest::os_platform() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.os_platform)
  return _internal_os_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterBrowserRequest::set_os_platform(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.os_platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RegisterBrowserRequest.os_platform)
}
inline std::string* RegisterBrowserRequest::mutable_os_platform() {
  std::string* _s = _internal_mutable_os_platform();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.os_platform)
  return _s;
}
inline const std::string& RegisterBrowserRequest::_internal_os_platform() const {
  return _impl_.os_platform_.Get();
}
inline void RegisterBrowserRequest::_internal_set_os_platform(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.os_platform_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::_internal_mutable_os_platform() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.os_platform_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::release_os_platform() {
  // @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.os_platform)
  if (!_internal_has_os_platform()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.os_platform_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_platform_.IsDefault()) {
    _impl_.os_platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterBrowserRequest::set_allocated_os_platform(std::string* os_platform) {
  if (os_platform != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.os_platform_.SetAllocated(os_platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_platform_.IsDefault()) {
    _impl_.os_platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.os_platform)
}

// optional string os_version = 3;
inline bool RegisterBrowserRequest::_internal_has_os_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegisterBrowserRequest::has_os_version() const {
  return _internal_has_os_version();
}
inline void RegisterBrowserRequest::clear_os_version() {
  _impl_.os_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegisterBrowserRequest::os_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.os_version)
  return _internal_os_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterBrowserRequest::set_os_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.os_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RegisterBrowserRequest.os_version)
}
inline std::string* RegisterBrowserRequest::mutable_os_version() {
  std::string* _s = _internal_mutable_os_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.os_version)
  return _s;
}
inline const std::string& RegisterBrowserRequest::_internal_os_version() const {
  return _impl_.os_version_.Get();
}
inline void RegisterBrowserRequest::_internal_set_os_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.os_version_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::_internal_mutable_os_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.os_version_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::release_os_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.os_version)
  if (!_internal_has_os_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.os_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterBrowserRequest::set_allocated_os_version(std::string* os_version) {
  if (os_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.os_version_.SetAllocated(os_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.os_version)
}

// optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 4;
inline bool RegisterBrowserRequest::_internal_has_browser_device_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_device_identifier_ != nullptr);
  return value;
}
inline bool RegisterBrowserRequest::has_browser_device_identifier() const {
  return _internal_has_browser_device_identifier();
}
inline void RegisterBrowserRequest::clear_browser_device_identifier() {
  if (_impl_.browser_device_identifier_ != nullptr) _impl_.browser_device_identifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_management::BrowserDeviceIdentifier& RegisterBrowserRequest::_internal_browser_device_identifier() const {
  const ::enterprise_management::BrowserDeviceIdentifier* p = _impl_.browser_device_identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserDeviceIdentifier&>(
      ::enterprise_management::_BrowserDeviceIdentifier_default_instance_);
}
inline const ::enterprise_management::BrowserDeviceIdentifier& RegisterBrowserRequest::browser_device_identifier() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.browser_device_identifier)
  return _internal_browser_device_identifier();
}
inline void RegisterBrowserRequest::unsafe_arena_set_allocated_browser_device_identifier(
    ::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_device_identifier_);
  }
  _impl_.browser_device_identifier_ = browser_device_identifier;
  if (browser_device_identifier) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.RegisterBrowserRequest.browser_device_identifier)
}
inline ::enterprise_management::BrowserDeviceIdentifier* RegisterBrowserRequest::release_browser_device_identifier() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::BrowserDeviceIdentifier* temp = _impl_.browser_device_identifier_;
  _impl_.browser_device_identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserDeviceIdentifier* RegisterBrowserRequest::unsafe_arena_release_browser_device_identifier() {
  // @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.browser_device_identifier)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::BrowserDeviceIdentifier* temp = _impl_.browser_device_identifier_;
  _impl_.browser_device_identifier_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserDeviceIdentifier* RegisterBrowserRequest::_internal_mutable_browser_device_identifier() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.browser_device_identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserDeviceIdentifier>(GetArenaForAllocation());
    _impl_.browser_device_identifier_ = p;
  }
  return _impl_.browser_device_identifier_;
}
inline ::enterprise_management::BrowserDeviceIdentifier* RegisterBrowserRequest::mutable_browser_device_identifier() {
  ::enterprise_management::BrowserDeviceIdentifier* _msg = _internal_mutable_browser_device_identifier();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.browser_device_identifier)
  return _msg;
}
inline void RegisterBrowserRequest::set_allocated_browser_device_identifier(::enterprise_management::BrowserDeviceIdentifier* browser_device_identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_device_identifier_;
  }
  if (browser_device_identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_device_identifier);
    if (message_arena != submessage_arena) {
      browser_device_identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_device_identifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.browser_device_identifier_ = browser_device_identifier;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.browser_device_identifier)
}

// optional string device_model = 5;
inline bool RegisterBrowserRequest::_internal_has_device_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegisterBrowserRequest::has_device_model() const {
  return _internal_has_device_model();
}
inline void RegisterBrowserRequest::clear_device_model() {
  _impl_.device_model_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RegisterBrowserRequest::device_model() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.device_model)
  return _internal_device_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterBrowserRequest::set_device_model(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.device_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RegisterBrowserRequest.device_model)
}
inline std::string* RegisterBrowserRequest::mutable_device_model() {
  std::string* _s = _internal_mutable_device_model();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.device_model)
  return _s;
}
inline const std::string& RegisterBrowserRequest::_internal_device_model() const {
  return _impl_.device_model_.Get();
}
inline void RegisterBrowserRequest::_internal_set_device_model(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.device_model_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::_internal_mutable_device_model() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.device_model_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::release_device_model() {
  // @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.device_model)
  if (!_internal_has_device_model()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.device_model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_model_.IsDefault()) {
    _impl_.device_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterBrowserRequest::set_allocated_device_model(std::string* device_model) {
  if (device_model != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.device_model_.SetAllocated(device_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_model_.IsDefault()) {
    _impl_.device_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.device_model)
}

// optional string brand_name = 6;
inline bool RegisterBrowserRequest::_internal_has_brand_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegisterBrowserRequest::has_brand_name() const {
  return _internal_has_brand_name();
}
inline void RegisterBrowserRequest::clear_brand_name() {
  _impl_.brand_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RegisterBrowserRequest::brand_name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RegisterBrowserRequest.brand_name)
  return _internal_brand_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterBrowserRequest::set_brand_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.brand_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RegisterBrowserRequest.brand_name)
}
inline std::string* RegisterBrowserRequest::mutable_brand_name() {
  std::string* _s = _internal_mutable_brand_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RegisterBrowserRequest.brand_name)
  return _s;
}
inline const std::string& RegisterBrowserRequest::_internal_brand_name() const {
  return _impl_.brand_name_.Get();
}
inline void RegisterBrowserRequest::_internal_set_brand_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.brand_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::_internal_mutable_brand_name() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.brand_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterBrowserRequest::release_brand_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.RegisterBrowserRequest.brand_name)
  if (!_internal_has_brand_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.brand_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brand_name_.IsDefault()) {
    _impl_.brand_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterBrowserRequest::set_allocated_brand_name(std::string* brand_name) {
  if (brand_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.brand_name_.SetAllocated(brand_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brand_name_.IsDefault()) {
    _impl_.brand_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RegisterBrowserRequest.brand_name)
}

// -------------------------------------------------------------------

// ActiveDirectoryEnrollPlayUserRequest

// optional string auth_session_id = 1;
inline bool ActiveDirectoryEnrollPlayUserRequest::_internal_has_auth_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActiveDirectoryEnrollPlayUserRequest::has_auth_session_id() const {
  return _internal_has_auth_session_id();
}
inline void ActiveDirectoryEnrollPlayUserRequest::clear_auth_session_id() {
  _impl_.auth_session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveDirectoryEnrollPlayUserRequest::auth_session_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
  return _internal_auth_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveDirectoryEnrollPlayUserRequest::set_auth_session_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.auth_session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
}
inline std::string* ActiveDirectoryEnrollPlayUserRequest::mutable_auth_session_id() {
  std::string* _s = _internal_mutable_auth_session_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
  return _s;
}
inline const std::string& ActiveDirectoryEnrollPlayUserRequest::_internal_auth_session_id() const {
  return _impl_.auth_session_id_.Get();
}
inline void ActiveDirectoryEnrollPlayUserRequest::_internal_set_auth_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveDirectoryEnrollPlayUserRequest::_internal_mutable_auth_session_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auth_session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveDirectoryEnrollPlayUserRequest::release_auth_session_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
  if (!_internal_has_auth_session_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.auth_session_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_session_id_.IsDefault()) {
    _impl_.auth_session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActiveDirectoryEnrollPlayUserRequest::set_allocated_auth_session_id(std::string* auth_session_id) {
  if (auth_session_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auth_session_id_.SetAllocated(auth_session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_session_id_.IsDefault()) {
    _impl_.auth_session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserRequest.auth_session_id)
}

// -------------------------------------------------------------------

// ActiveDirectoryEnrollPlayUserResponse

// optional string enrollment_token = 1;
inline bool ActiveDirectoryEnrollPlayUserResponse::_internal_has_enrollment_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActiveDirectoryEnrollPlayUserResponse::has_enrollment_token() const {
  return _internal_has_enrollment_token();
}
inline void ActiveDirectoryEnrollPlayUserResponse::clear_enrollment_token() {
  _impl_.enrollment_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveDirectoryEnrollPlayUserResponse::enrollment_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
  return _internal_enrollment_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveDirectoryEnrollPlayUserResponse::set_enrollment_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.enrollment_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::mutable_enrollment_token() {
  std::string* _s = _internal_mutable_enrollment_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
  return _s;
}
inline const std::string& ActiveDirectoryEnrollPlayUserResponse::_internal_enrollment_token() const {
  return _impl_.enrollment_token_.Get();
}
inline void ActiveDirectoryEnrollPlayUserResponse::_internal_set_enrollment_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enrollment_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::_internal_mutable_enrollment_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.enrollment_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::release_enrollment_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
  if (!_internal_has_enrollment_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.enrollment_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enrollment_token_.IsDefault()) {
    _impl_.enrollment_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_allocated_enrollment_token(std::string* enrollment_token) {
  if (enrollment_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.enrollment_token_.SetAllocated(enrollment_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enrollment_token_.IsDefault()) {
    _impl_.enrollment_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.enrollment_token)
}

// optional string user_id = 2;
inline bool ActiveDirectoryEnrollPlayUserResponse::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActiveDirectoryEnrollPlayUserResponse::has_user_id() const {
  return _internal_has_user_id();
}
inline void ActiveDirectoryEnrollPlayUserResponse::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActiveDirectoryEnrollPlayUserResponse::user_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveDirectoryEnrollPlayUserResponse::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
  return _s;
}
inline const std::string& ActiveDirectoryEnrollPlayUserResponse::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ActiveDirectoryEnrollPlayUserResponse::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveDirectoryEnrollPlayUserResponse::release_user_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.user_id)
}

// optional .enterprise_management.SamlParametersProto saml_parameters = 3;
inline bool ActiveDirectoryEnrollPlayUserResponse::_internal_has_saml_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.saml_parameters_ != nullptr);
  return value;
}
inline bool ActiveDirectoryEnrollPlayUserResponse::has_saml_parameters() const {
  return _internal_has_saml_parameters();
}
inline void ActiveDirectoryEnrollPlayUserResponse::clear_saml_parameters() {
  if (_impl_.saml_parameters_ != nullptr) _impl_.saml_parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::SamlParametersProto& ActiveDirectoryEnrollPlayUserResponse::_internal_saml_parameters() const {
  const ::enterprise_management::SamlParametersProto* p = _impl_.saml_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SamlParametersProto&>(
      ::enterprise_management::_SamlParametersProto_default_instance_);
}
inline const ::enterprise_management::SamlParametersProto& ActiveDirectoryEnrollPlayUserResponse::saml_parameters() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
  return _internal_saml_parameters();
}
inline void ActiveDirectoryEnrollPlayUserResponse::unsafe_arena_set_allocated_saml_parameters(
    ::enterprise_management::SamlParametersProto* saml_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.saml_parameters_);
  }
  _impl_.saml_parameters_ = saml_parameters;
  if (saml_parameters) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
}
inline ::enterprise_management::SamlParametersProto* ActiveDirectoryEnrollPlayUserResponse::release_saml_parameters() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::SamlParametersProto* temp = _impl_.saml_parameters_;
  _impl_.saml_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SamlParametersProto* ActiveDirectoryEnrollPlayUserResponse::unsafe_arena_release_saml_parameters() {
  // @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::SamlParametersProto* temp = _impl_.saml_parameters_;
  _impl_.saml_parameters_ = nullptr;
  return temp;
}
inline ::enterprise_management::SamlParametersProto* ActiveDirectoryEnrollPlayUserResponse::_internal_mutable_saml_parameters() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.saml_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SamlParametersProto>(GetArenaForAllocation());
    _impl_.saml_parameters_ = p;
  }
  return _impl_.saml_parameters_;
}
inline ::enterprise_management::SamlParametersProto* ActiveDirectoryEnrollPlayUserResponse::mutable_saml_parameters() {
  ::enterprise_management::SamlParametersProto* _msg = _internal_mutable_saml_parameters();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
  return _msg;
}
inline void ActiveDirectoryEnrollPlayUserResponse::set_allocated_saml_parameters(::enterprise_management::SamlParametersProto* saml_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.saml_parameters_;
  }
  if (saml_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saml_parameters);
    if (message_arena != submessage_arena) {
      saml_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saml_parameters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.saml_parameters_ = saml_parameters;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryEnrollPlayUserResponse.saml_parameters)
}

// -------------------------------------------------------------------

// SamlParametersProto

// optional string auth_redirect_url = 1;
inline bool SamlParametersProto::_internal_has_auth_redirect_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SamlParametersProto::has_auth_redirect_url() const {
  return _internal_has_auth_redirect_url();
}
inline void SamlParametersProto::clear_auth_redirect_url() {
  _impl_.auth_redirect_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SamlParametersProto::auth_redirect_url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SamlParametersProto.auth_redirect_url)
  return _internal_auth_redirect_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SamlParametersProto::set_auth_redirect_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.auth_redirect_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SamlParametersProto.auth_redirect_url)
}
inline std::string* SamlParametersProto::mutable_auth_redirect_url() {
  std::string* _s = _internal_mutable_auth_redirect_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SamlParametersProto.auth_redirect_url)
  return _s;
}
inline const std::string& SamlParametersProto::_internal_auth_redirect_url() const {
  return _impl_.auth_redirect_url_.Get();
}
inline void SamlParametersProto::_internal_set_auth_redirect_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_redirect_url_.Set(value, GetArenaForAllocation());
}
inline std::string* SamlParametersProto::_internal_mutable_auth_redirect_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auth_redirect_url_.Mutable(GetArenaForAllocation());
}
inline std::string* SamlParametersProto::release_auth_redirect_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.SamlParametersProto.auth_redirect_url)
  if (!_internal_has_auth_redirect_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.auth_redirect_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_redirect_url_.IsDefault()) {
    _impl_.auth_redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SamlParametersProto::set_allocated_auth_redirect_url(std::string* auth_redirect_url) {
  if (auth_redirect_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auth_redirect_url_.SetAllocated(auth_redirect_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_redirect_url_.IsDefault()) {
    _impl_.auth_redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SamlParametersProto.auth_redirect_url)
}

// optional string auth_session_id = 2;
inline bool SamlParametersProto::_internal_has_auth_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SamlParametersProto::has_auth_session_id() const {
  return _internal_has_auth_session_id();
}
inline void SamlParametersProto::clear_auth_session_id() {
  _impl_.auth_session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SamlParametersProto::auth_session_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.SamlParametersProto.auth_session_id)
  return _internal_auth_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SamlParametersProto::set_auth_session_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.auth_session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.SamlParametersProto.auth_session_id)
}
inline std::string* SamlParametersProto::mutable_auth_session_id() {
  std::string* _s = _internal_mutable_auth_session_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.SamlParametersProto.auth_session_id)
  return _s;
}
inline const std::string& SamlParametersProto::_internal_auth_session_id() const {
  return _impl_.auth_session_id_.Get();
}
inline void SamlParametersProto::_internal_set_auth_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.auth_session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SamlParametersProto::_internal_mutable_auth_session_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.auth_session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SamlParametersProto::release_auth_session_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.SamlParametersProto.auth_session_id)
  if (!_internal_has_auth_session_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.auth_session_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_session_id_.IsDefault()) {
    _impl_.auth_session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SamlParametersProto::set_allocated_auth_session_id(std::string* auth_session_id) {
  if (auth_session_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.auth_session_id_.SetAllocated(auth_session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_session_id_.IsDefault()) {
    _impl_.auth_session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.SamlParametersProto.auth_session_id)
}

// -------------------------------------------------------------------

// PublicSamlUserRequest

// optional string account_id = 1;
inline bool PublicSamlUserRequest::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublicSamlUserRequest::has_account_id() const {
  return _internal_has_account_id();
}
inline void PublicSamlUserRequest::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublicSamlUserRequest::account_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PublicSamlUserRequest.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicSamlUserRequest::set_account_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PublicSamlUserRequest.account_id)
}
inline std::string* PublicSamlUserRequest::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PublicSamlUserRequest.account_id)
  return _s;
}
inline const std::string& PublicSamlUserRequest::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void PublicSamlUserRequest::_internal_set_account_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicSamlUserRequest::_internal_mutable_account_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicSamlUserRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PublicSamlUserRequest.account_id)
  if (!_internal_has_account_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.account_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublicSamlUserRequest::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicSamlUserRequest.account_id)
}

// -------------------------------------------------------------------

// PublicSamlUserResponse

// optional .enterprise_management.SamlParametersProto saml_parameters = 1;
inline bool PublicSamlUserResponse::_internal_has_saml_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.saml_parameters_ != nullptr);
  return value;
}
inline bool PublicSamlUserResponse::has_saml_parameters() const {
  return _internal_has_saml_parameters();
}
inline void PublicSamlUserResponse::clear_saml_parameters() {
  if (_impl_.saml_parameters_ != nullptr) _impl_.saml_parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::SamlParametersProto& PublicSamlUserResponse::_internal_saml_parameters() const {
  const ::enterprise_management::SamlParametersProto* p = _impl_.saml_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SamlParametersProto&>(
      ::enterprise_management::_SamlParametersProto_default_instance_);
}
inline const ::enterprise_management::SamlParametersProto& PublicSamlUserResponse::saml_parameters() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PublicSamlUserResponse.saml_parameters)
  return _internal_saml_parameters();
}
inline void PublicSamlUserResponse::unsafe_arena_set_allocated_saml_parameters(
    ::enterprise_management::SamlParametersProto* saml_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.saml_parameters_);
  }
  _impl_.saml_parameters_ = saml_parameters;
  if (saml_parameters) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PublicSamlUserResponse.saml_parameters)
}
inline ::enterprise_management::SamlParametersProto* PublicSamlUserResponse::release_saml_parameters() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::SamlParametersProto* temp = _impl_.saml_parameters_;
  _impl_.saml_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SamlParametersProto* PublicSamlUserResponse::unsafe_arena_release_saml_parameters() {
  // @@protoc_insertion_point(field_release:enterprise_management.PublicSamlUserResponse.saml_parameters)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::SamlParametersProto* temp = _impl_.saml_parameters_;
  _impl_.saml_parameters_ = nullptr;
  return temp;
}
inline ::enterprise_management::SamlParametersProto* PublicSamlUserResponse::_internal_mutable_saml_parameters() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.saml_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SamlParametersProto>(GetArenaForAllocation());
    _impl_.saml_parameters_ = p;
  }
  return _impl_.saml_parameters_;
}
inline ::enterprise_management::SamlParametersProto* PublicSamlUserResponse::mutable_saml_parameters() {
  ::enterprise_management::SamlParametersProto* _msg = _internal_mutable_saml_parameters();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PublicSamlUserResponse.saml_parameters)
  return _msg;
}
inline void PublicSamlUserResponse::set_allocated_saml_parameters(::enterprise_management::SamlParametersProto* saml_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.saml_parameters_;
  }
  if (saml_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saml_parameters);
    if (message_arena != submessage_arena) {
      saml_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saml_parameters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.saml_parameters_ = saml_parameters;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PublicSamlUserResponse.saml_parameters)
}

// -------------------------------------------------------------------

// ActiveDirectoryPlayActivityRequest

// optional string user_id = 1;
inline bool ActiveDirectoryPlayActivityRequest::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActiveDirectoryPlayActivityRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void ActiveDirectoryPlayActivityRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveDirectoryPlayActivityRequest::user_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveDirectoryPlayActivityRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
}
inline std::string* ActiveDirectoryPlayActivityRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
  return _s;
}
inline const std::string& ActiveDirectoryPlayActivityRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ActiveDirectoryPlayActivityRequest::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveDirectoryPlayActivityRequest::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveDirectoryPlayActivityRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActiveDirectoryPlayActivityRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryPlayActivityRequest.user_id)
}

// -------------------------------------------------------------------

// ActiveDirectoryPlayActivityResponse

// -------------------------------------------------------------------

// CheckDeviceLicenseRequest

// -------------------------------------------------------------------

// LicenseAvailability

// optional .enterprise_management.LicenseType license_type_deprecated = 1 [deprecated = true];
inline bool LicenseAvailability::_internal_has_license_type_deprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.license_type_deprecated_ != nullptr);
  return value;
}
inline bool LicenseAvailability::has_license_type_deprecated() const {
  return _internal_has_license_type_deprecated();
}
inline void LicenseAvailability::clear_license_type_deprecated() {
  if (_impl_.license_type_deprecated_ != nullptr) _impl_.license_type_deprecated_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::LicenseType& LicenseAvailability::_internal_license_type_deprecated() const {
  const ::enterprise_management::LicenseType* p = _impl_.license_type_deprecated_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::LicenseType&>(
      ::enterprise_management::_LicenseType_default_instance_);
}
inline const ::enterprise_management::LicenseType& LicenseAvailability::license_type_deprecated() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LicenseAvailability.license_type_deprecated)
  return _internal_license_type_deprecated();
}
inline void LicenseAvailability::unsafe_arena_set_allocated_license_type_deprecated(
    ::enterprise_management::LicenseType* license_type_deprecated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.license_type_deprecated_);
  }
  _impl_.license_type_deprecated_ = license_type_deprecated;
  if (license_type_deprecated) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.LicenseAvailability.license_type_deprecated)
}
inline ::enterprise_management::LicenseType* LicenseAvailability::release_license_type_deprecated() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::LicenseType* temp = _impl_.license_type_deprecated_;
  _impl_.license_type_deprecated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::LicenseType* LicenseAvailability::unsafe_arena_release_license_type_deprecated() {
  // @@protoc_insertion_point(field_release:enterprise_management.LicenseAvailability.license_type_deprecated)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::LicenseType* temp = _impl_.license_type_deprecated_;
  _impl_.license_type_deprecated_ = nullptr;
  return temp;
}
inline ::enterprise_management::LicenseType* LicenseAvailability::_internal_mutable_license_type_deprecated() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.license_type_deprecated_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::LicenseType>(GetArenaForAllocation());
    _impl_.license_type_deprecated_ = p;
  }
  return _impl_.license_type_deprecated_;
}
inline ::enterprise_management::LicenseType* LicenseAvailability::mutable_license_type_deprecated() {
  ::enterprise_management::LicenseType* _msg = _internal_mutable_license_type_deprecated();
  // @@protoc_insertion_point(field_mutable:enterprise_management.LicenseAvailability.license_type_deprecated)
  return _msg;
}
inline void LicenseAvailability::set_allocated_license_type_deprecated(::enterprise_management::LicenseType* license_type_deprecated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.license_type_deprecated_;
  }
  if (license_type_deprecated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(license_type_deprecated);
    if (message_arena != submessage_arena) {
      license_type_deprecated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, license_type_deprecated, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.license_type_deprecated_ = license_type_deprecated;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.LicenseAvailability.license_type_deprecated)
}

// optional int32 available_licenses_deprecated = 2 [deprecated = true];
inline bool LicenseAvailability::_internal_has_available_licenses_deprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LicenseAvailability::has_available_licenses_deprecated() const {
  return _internal_has_available_licenses_deprecated();
}
inline void LicenseAvailability::clear_available_licenses_deprecated() {
  _impl_.available_licenses_deprecated_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t LicenseAvailability::_internal_available_licenses_deprecated() const {
  return _impl_.available_licenses_deprecated_;
}
inline int32_t LicenseAvailability::available_licenses_deprecated() const {
  // @@protoc_insertion_point(field_get:enterprise_management.LicenseAvailability.available_licenses_deprecated)
  return _internal_available_licenses_deprecated();
}
inline void LicenseAvailability::_internal_set_available_licenses_deprecated(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.available_licenses_deprecated_ = value;
}
inline void LicenseAvailability::set_available_licenses_deprecated(int32_t value) {
  _internal_set_available_licenses_deprecated(value);
  // @@protoc_insertion_point(field_set:enterprise_management.LicenseAvailability.available_licenses_deprecated)
}

// -------------------------------------------------------------------

// CheckDeviceLicenseResponse

// optional .enterprise_management.CheckDeviceLicenseResponse.LicenseSelectionMode license_selection_mode_deprecated = 1 [deprecated = true];
inline bool CheckDeviceLicenseResponse::_internal_has_license_selection_mode_deprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckDeviceLicenseResponse::has_license_selection_mode_deprecated() const {
  return _internal_has_license_selection_mode_deprecated();
}
inline void CheckDeviceLicenseResponse::clear_license_selection_mode_deprecated() {
  _impl_.license_selection_mode_deprecated_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse::_internal_license_selection_mode_deprecated() const {
  return static_cast< ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode >(_impl_.license_selection_mode_deprecated_);
}
inline ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse::license_selection_mode_deprecated() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CheckDeviceLicenseResponse.license_selection_mode_deprecated)
  return _internal_license_selection_mode_deprecated();
}
inline void CheckDeviceLicenseResponse::_internal_set_license_selection_mode_deprecated(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode value) {
  assert(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.license_selection_mode_deprecated_ = value;
}
inline void CheckDeviceLicenseResponse::set_license_selection_mode_deprecated(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode value) {
  _internal_set_license_selection_mode_deprecated(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CheckDeviceLicenseResponse.license_selection_mode_deprecated)
}

// repeated .enterprise_management.LicenseAvailability license_availabilities_deprecated = 2 [deprecated = true];
inline int CheckDeviceLicenseResponse::_internal_license_availabilities_deprecated_size() const {
  return _impl_.license_availabilities_deprecated_.size();
}
inline int CheckDeviceLicenseResponse::license_availabilities_deprecated_size() const {
  return _internal_license_availabilities_deprecated_size();
}
inline void CheckDeviceLicenseResponse::clear_license_availabilities_deprecated() {
  _impl_.license_availabilities_deprecated_.Clear();
}
inline ::enterprise_management::LicenseAvailability* CheckDeviceLicenseResponse::mutable_license_availabilities_deprecated(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
  return _impl_.license_availabilities_deprecated_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability >*
CheckDeviceLicenseResponse::mutable_license_availabilities_deprecated() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
  return &_impl_.license_availabilities_deprecated_;
}
inline const ::enterprise_management::LicenseAvailability& CheckDeviceLicenseResponse::_internal_license_availabilities_deprecated(int index) const {
  return _impl_.license_availabilities_deprecated_.Get(index);
}
inline const ::enterprise_management::LicenseAvailability& CheckDeviceLicenseResponse::license_availabilities_deprecated(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
  return _internal_license_availabilities_deprecated(index);
}
inline ::enterprise_management::LicenseAvailability* CheckDeviceLicenseResponse::_internal_add_license_availabilities_deprecated() {
  return _impl_.license_availabilities_deprecated_.Add();
}
inline ::enterprise_management::LicenseAvailability* CheckDeviceLicenseResponse::add_license_availabilities_deprecated() {
  ::enterprise_management::LicenseAvailability* _add = _internal_add_license_availabilities_deprecated();
  // @@protoc_insertion_point(field_add:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::LicenseAvailability >&
CheckDeviceLicenseResponse::license_availabilities_deprecated() const {
  // @@protoc_insertion_point(field_list:enterprise_management.CheckDeviceLicenseResponse.license_availabilities_deprecated)
  return _impl_.license_availabilities_deprecated_;
}

// -------------------------------------------------------------------

// ActiveDirectoryUserSigninRequest

// -------------------------------------------------------------------

// ActiveDirectoryUserSigninResponse

// optional string auth_redirect_url = 1;
inline bool ActiveDirectoryUserSigninResponse::_internal_has_auth_redirect_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActiveDirectoryUserSigninResponse::has_auth_redirect_url() const {
  return _internal_has_auth_redirect_url();
}
inline void ActiveDirectoryUserSigninResponse::clear_auth_redirect_url() {
  _impl_.auth_redirect_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActiveDirectoryUserSigninResponse::auth_redirect_url() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
  return _internal_auth_redirect_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveDirectoryUserSigninResponse::set_auth_redirect_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.auth_redirect_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
}
inline std::string* ActiveDirectoryUserSigninResponse::mutable_auth_redirect_url() {
  std::string* _s = _internal_mutable_auth_redirect_url();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
  return _s;
}
inline const std::string& ActiveDirectoryUserSigninResponse::_internal_auth_redirect_url() const {
  return _impl_.auth_redirect_url_.Get();
}
inline void ActiveDirectoryUserSigninResponse::_internal_set_auth_redirect_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_redirect_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveDirectoryUserSigninResponse::_internal_mutable_auth_redirect_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auth_redirect_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveDirectoryUserSigninResponse::release_auth_redirect_url() {
  // @@protoc_insertion_point(field_release:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
  if (!_internal_has_auth_redirect_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.auth_redirect_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_redirect_url_.IsDefault()) {
    _impl_.auth_redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActiveDirectoryUserSigninResponse::set_allocated_auth_redirect_url(std::string* auth_redirect_url) {
  if (auth_redirect_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auth_redirect_url_.SetAllocated(auth_redirect_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_redirect_url_.IsDefault()) {
    _impl_.auth_redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ActiveDirectoryUserSigninResponse.auth_redirect_url)
}

// -------------------------------------------------------------------

// TpmVersionInfo

// optional uint32 family = 1;
inline bool TpmVersionInfo::_internal_has_family() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TpmVersionInfo::has_family() const {
  return _internal_has_family();
}
inline void TpmVersionInfo::clear_family() {
  _impl_.family_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TpmVersionInfo::_internal_family() const {
  return _impl_.family_;
}
inline uint32_t TpmVersionInfo::family() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.family)
  return _internal_family();
}
inline void TpmVersionInfo::_internal_set_family(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.family_ = value;
}
inline void TpmVersionInfo::set_family(uint32_t value) {
  _internal_set_family(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.family)
}

// optional uint64 spec_level = 2;
inline bool TpmVersionInfo::_internal_has_spec_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TpmVersionInfo::has_spec_level() const {
  return _internal_has_spec_level();
}
inline void TpmVersionInfo::clear_spec_level() {
  _impl_.spec_level_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t TpmVersionInfo::_internal_spec_level() const {
  return _impl_.spec_level_;
}
inline uint64_t TpmVersionInfo::spec_level() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.spec_level)
  return _internal_spec_level();
}
inline void TpmVersionInfo::_internal_set_spec_level(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.spec_level_ = value;
}
inline void TpmVersionInfo::set_spec_level(uint64_t value) {
  _internal_set_spec_level(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.spec_level)
}

// optional uint32 manufacturer = 3;
inline bool TpmVersionInfo::_internal_has_manufacturer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TpmVersionInfo::has_manufacturer() const {
  return _internal_has_manufacturer();
}
inline void TpmVersionInfo::clear_manufacturer() {
  _impl_.manufacturer_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TpmVersionInfo::_internal_manufacturer() const {
  return _impl_.manufacturer_;
}
inline uint32_t TpmVersionInfo::manufacturer() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.manufacturer)
  return _internal_manufacturer();
}
inline void TpmVersionInfo::_internal_set_manufacturer(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.manufacturer_ = value;
}
inline void TpmVersionInfo::set_manufacturer(uint32_t value) {
  _internal_set_manufacturer(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.manufacturer)
}

// optional uint32 tpm_model = 4;
inline bool TpmVersionInfo::_internal_has_tpm_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TpmVersionInfo::has_tpm_model() const {
  return _internal_has_tpm_model();
}
inline void TpmVersionInfo::clear_tpm_model() {
  _impl_.tpm_model_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TpmVersionInfo::_internal_tpm_model() const {
  return _impl_.tpm_model_;
}
inline uint32_t TpmVersionInfo::tpm_model() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.tpm_model)
  return _internal_tpm_model();
}
inline void TpmVersionInfo::_internal_set_tpm_model(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tpm_model_ = value;
}
inline void TpmVersionInfo::set_tpm_model(uint32_t value) {
  _internal_set_tpm_model(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.tpm_model)
}

// optional uint64 firmware_version = 5;
inline bool TpmVersionInfo::_internal_has_firmware_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TpmVersionInfo::has_firmware_version() const {
  return _internal_has_firmware_version();
}
inline void TpmVersionInfo::clear_firmware_version() {
  _impl_.firmware_version_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t TpmVersionInfo::_internal_firmware_version() const {
  return _impl_.firmware_version_;
}
inline uint64_t TpmVersionInfo::firmware_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.firmware_version)
  return _internal_firmware_version();
}
inline void TpmVersionInfo::_internal_set_firmware_version(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.firmware_version_ = value;
}
inline void TpmVersionInfo::set_firmware_version(uint64_t value) {
  _internal_set_firmware_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.firmware_version)
}

// optional string vendor_specific = 6;
inline bool TpmVersionInfo::_internal_has_vendor_specific() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TpmVersionInfo::has_vendor_specific() const {
  return _internal_has_vendor_specific();
}
inline void TpmVersionInfo::clear_vendor_specific() {
  _impl_.vendor_specific_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TpmVersionInfo::vendor_specific() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.vendor_specific)
  return _internal_vendor_specific();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TpmVersionInfo::set_vendor_specific(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vendor_specific_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.vendor_specific)
}
inline std::string* TpmVersionInfo::mutable_vendor_specific() {
  std::string* _s = _internal_mutable_vendor_specific();
  // @@protoc_insertion_point(field_mutable:enterprise_management.TpmVersionInfo.vendor_specific)
  return _s;
}
inline const std::string& TpmVersionInfo::_internal_vendor_specific() const {
  return _impl_.vendor_specific_.Get();
}
inline void TpmVersionInfo::_internal_set_vendor_specific(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vendor_specific_.Set(value, GetArenaForAllocation());
}
inline std::string* TpmVersionInfo::_internal_mutable_vendor_specific() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vendor_specific_.Mutable(GetArenaForAllocation());
}
inline std::string* TpmVersionInfo::release_vendor_specific() {
  // @@protoc_insertion_point(field_release:enterprise_management.TpmVersionInfo.vendor_specific)
  if (!_internal_has_vendor_specific()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vendor_specific_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_specific_.IsDefault()) {
    _impl_.vendor_specific_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TpmVersionInfo::set_allocated_vendor_specific(std::string* vendor_specific) {
  if (vendor_specific != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vendor_specific_.SetAllocated(vendor_specific, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_specific_.IsDefault()) {
    _impl_.vendor_specific_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.TpmVersionInfo.vendor_specific)
}

// optional .enterprise_management.TpmVersionInfo.GscVersion gsc_version = 7;
inline bool TpmVersionInfo::_internal_has_gsc_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TpmVersionInfo::has_gsc_version() const {
  return _internal_has_gsc_version();
}
inline void TpmVersionInfo::clear_gsc_version() {
  _impl_.gsc_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::enterprise_management::TpmVersionInfo_GscVersion TpmVersionInfo::_internal_gsc_version() const {
  return static_cast< ::enterprise_management::TpmVersionInfo_GscVersion >(_impl_.gsc_version_);
}
inline ::enterprise_management::TpmVersionInfo_GscVersion TpmVersionInfo::gsc_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.gsc_version)
  return _internal_gsc_version();
}
inline void TpmVersionInfo::_internal_set_gsc_version(::enterprise_management::TpmVersionInfo_GscVersion value) {
  assert(::enterprise_management::TpmVersionInfo_GscVersion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.gsc_version_ = value;
}
inline void TpmVersionInfo::set_gsc_version(::enterprise_management::TpmVersionInfo_GscVersion value) {
  _internal_set_gsc_version(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.gsc_version)
}

// optional string did_vid = 8;
inline bool TpmVersionInfo::_internal_has_did_vid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TpmVersionInfo::has_did_vid() const {
  return _internal_has_did_vid();
}
inline void TpmVersionInfo::clear_did_vid() {
  _impl_.did_vid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TpmVersionInfo::did_vid() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmVersionInfo.did_vid)
  return _internal_did_vid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TpmVersionInfo::set_did_vid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.did_vid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.TpmVersionInfo.did_vid)
}
inline std::string* TpmVersionInfo::mutable_did_vid() {
  std::string* _s = _internal_mutable_did_vid();
  // @@protoc_insertion_point(field_mutable:enterprise_management.TpmVersionInfo.did_vid)
  return _s;
}
inline const std::string& TpmVersionInfo::_internal_did_vid() const {
  return _impl_.did_vid_.Get();
}
inline void TpmVersionInfo::_internal_set_did_vid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.did_vid_.Set(value, GetArenaForAllocation());
}
inline std::string* TpmVersionInfo::_internal_mutable_did_vid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.did_vid_.Mutable(GetArenaForAllocation());
}
inline std::string* TpmVersionInfo::release_did_vid() {
  // @@protoc_insertion_point(field_release:enterprise_management.TpmVersionInfo.did_vid)
  if (!_internal_has_did_vid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.did_vid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.did_vid_.IsDefault()) {
    _impl_.did_vid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TpmVersionInfo::set_allocated_did_vid(std::string* did_vid) {
  if (did_vid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.did_vid_.SetAllocated(did_vid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.did_vid_.IsDefault()) {
    _impl_.did_vid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.TpmVersionInfo.did_vid)
}

// -------------------------------------------------------------------

// TpmStatusInfo

// optional bool enabled = 1;
inline bool TpmStatusInfo::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_enabled() const {
  return _internal_has_enabled();
}
inline void TpmStatusInfo::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TpmStatusInfo::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool TpmStatusInfo::enabled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.enabled)
  return _internal_enabled();
}
inline void TpmStatusInfo::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enabled_ = value;
}
inline void TpmStatusInfo::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.enabled)
}

// optional bool owned = 2;
inline bool TpmStatusInfo::_internal_has_owned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_owned() const {
  return _internal_has_owned();
}
inline void TpmStatusInfo::clear_owned() {
  _impl_.owned_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TpmStatusInfo::_internal_owned() const {
  return _impl_.owned_;
}
inline bool TpmStatusInfo::owned() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.owned)
  return _internal_owned();
}
inline void TpmStatusInfo::_internal_set_owned(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owned_ = value;
}
inline void TpmStatusInfo::set_owned(bool value) {
  _internal_set_owned(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.owned)
}

// optional bool tpm_initialized = 3;
inline bool TpmStatusInfo::_internal_has_tpm_initialized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_tpm_initialized() const {
  return _internal_has_tpm_initialized();
}
inline void TpmStatusInfo::clear_tpm_initialized() {
  _impl_.tpm_initialized_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool TpmStatusInfo::_internal_tpm_initialized() const {
  return _impl_.tpm_initialized_;
}
inline bool TpmStatusInfo::tpm_initialized() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.tpm_initialized)
  return _internal_tpm_initialized();
}
inline void TpmStatusInfo::_internal_set_tpm_initialized(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tpm_initialized_ = value;
}
inline void TpmStatusInfo::set_tpm_initialized(bool value) {
  _internal_set_tpm_initialized(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.tpm_initialized)
}

// optional bool attestation_prepared = 4;
inline bool TpmStatusInfo::_internal_has_attestation_prepared() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_attestation_prepared() const {
  return _internal_has_attestation_prepared();
}
inline void TpmStatusInfo::clear_attestation_prepared() {
  _impl_.attestation_prepared_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool TpmStatusInfo::_internal_attestation_prepared() const {
  return _impl_.attestation_prepared_;
}
inline bool TpmStatusInfo::attestation_prepared() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.attestation_prepared)
  return _internal_attestation_prepared();
}
inline void TpmStatusInfo::_internal_set_attestation_prepared(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.attestation_prepared_ = value;
}
inline void TpmStatusInfo::set_attestation_prepared(bool value) {
  _internal_set_attestation_prepared(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.attestation_prepared)
}

// optional bool attestation_enrolled = 5;
inline bool TpmStatusInfo::_internal_has_attestation_enrolled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_attestation_enrolled() const {
  return _internal_has_attestation_enrolled();
}
inline void TpmStatusInfo::clear_attestation_enrolled() {
  _impl_.attestation_enrolled_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool TpmStatusInfo::_internal_attestation_enrolled() const {
  return _impl_.attestation_enrolled_;
}
inline bool TpmStatusInfo::attestation_enrolled() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.attestation_enrolled)
  return _internal_attestation_enrolled();
}
inline void TpmStatusInfo::_internal_set_attestation_enrolled(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.attestation_enrolled_ = value;
}
inline void TpmStatusInfo::set_attestation_enrolled(bool value) {
  _internal_set_attestation_enrolled(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.attestation_enrolled)
}

// optional int32 dictionary_attack_counter = 6;
inline bool TpmStatusInfo::_internal_has_dictionary_attack_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_dictionary_attack_counter() const {
  return _internal_has_dictionary_attack_counter();
}
inline void TpmStatusInfo::clear_dictionary_attack_counter() {
  _impl_.dictionary_attack_counter_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t TpmStatusInfo::_internal_dictionary_attack_counter() const {
  return _impl_.dictionary_attack_counter_;
}
inline int32_t TpmStatusInfo::dictionary_attack_counter() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.dictionary_attack_counter)
  return _internal_dictionary_attack_counter();
}
inline void TpmStatusInfo::_internal_set_dictionary_attack_counter(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.dictionary_attack_counter_ = value;
}
inline void TpmStatusInfo::set_dictionary_attack_counter(int32_t value) {
  _internal_set_dictionary_attack_counter(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.dictionary_attack_counter)
}

// optional int32 dictionary_attack_threshold = 7;
inline bool TpmStatusInfo::_internal_has_dictionary_attack_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_dictionary_attack_threshold() const {
  return _internal_has_dictionary_attack_threshold();
}
inline void TpmStatusInfo::clear_dictionary_attack_threshold() {
  _impl_.dictionary_attack_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t TpmStatusInfo::_internal_dictionary_attack_threshold() const {
  return _impl_.dictionary_attack_threshold_;
}
inline int32_t TpmStatusInfo::dictionary_attack_threshold() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.dictionary_attack_threshold)
  return _internal_dictionary_attack_threshold();
}
inline void TpmStatusInfo::_internal_set_dictionary_attack_threshold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.dictionary_attack_threshold_ = value;
}
inline void TpmStatusInfo::set_dictionary_attack_threshold(int32_t value) {
  _internal_set_dictionary_attack_threshold(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.dictionary_attack_threshold)
}

// optional bool dictionary_attack_lockout_in_effect = 8;
inline bool TpmStatusInfo::_internal_has_dictionary_attack_lockout_in_effect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_dictionary_attack_lockout_in_effect() const {
  return _internal_has_dictionary_attack_lockout_in_effect();
}
inline void TpmStatusInfo::clear_dictionary_attack_lockout_in_effect() {
  _impl_.dictionary_attack_lockout_in_effect_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool TpmStatusInfo::_internal_dictionary_attack_lockout_in_effect() const {
  return _impl_.dictionary_attack_lockout_in_effect_;
}
inline bool TpmStatusInfo::dictionary_attack_lockout_in_effect() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.dictionary_attack_lockout_in_effect)
  return _internal_dictionary_attack_lockout_in_effect();
}
inline void TpmStatusInfo::_internal_set_dictionary_attack_lockout_in_effect(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.dictionary_attack_lockout_in_effect_ = value;
}
inline void TpmStatusInfo::set_dictionary_attack_lockout_in_effect(bool value) {
  _internal_set_dictionary_attack_lockout_in_effect(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.dictionary_attack_lockout_in_effect)
}

// optional int32 dictionary_attack_lockout_seconds_remaining = 9;
inline bool TpmStatusInfo::_internal_has_dictionary_attack_lockout_seconds_remaining() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_dictionary_attack_lockout_seconds_remaining() const {
  return _internal_has_dictionary_attack_lockout_seconds_remaining();
}
inline void TpmStatusInfo::clear_dictionary_attack_lockout_seconds_remaining() {
  _impl_.dictionary_attack_lockout_seconds_remaining_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t TpmStatusInfo::_internal_dictionary_attack_lockout_seconds_remaining() const {
  return _impl_.dictionary_attack_lockout_seconds_remaining_;
}
inline int32_t TpmStatusInfo::dictionary_attack_lockout_seconds_remaining() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.dictionary_attack_lockout_seconds_remaining)
  return _internal_dictionary_attack_lockout_seconds_remaining();
}
inline void TpmStatusInfo::_internal_set_dictionary_attack_lockout_seconds_remaining(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.dictionary_attack_lockout_seconds_remaining_ = value;
}
inline void TpmStatusInfo::set_dictionary_attack_lockout_seconds_remaining(int32_t value) {
  _internal_set_dictionary_attack_lockout_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.dictionary_attack_lockout_seconds_remaining)
}

// optional bool boot_lockbox_finalized = 10 [deprecated = true];
inline bool TpmStatusInfo::_internal_has_boot_lockbox_finalized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_boot_lockbox_finalized() const {
  return _internal_has_boot_lockbox_finalized();
}
inline void TpmStatusInfo::clear_boot_lockbox_finalized() {
  _impl_.boot_lockbox_finalized_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool TpmStatusInfo::_internal_boot_lockbox_finalized() const {
  return _impl_.boot_lockbox_finalized_;
}
inline bool TpmStatusInfo::boot_lockbox_finalized() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.boot_lockbox_finalized)
  return _internal_boot_lockbox_finalized();
}
inline void TpmStatusInfo::_internal_set_boot_lockbox_finalized(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.boot_lockbox_finalized_ = value;
}
inline void TpmStatusInfo::set_boot_lockbox_finalized(bool value) {
  _internal_set_boot_lockbox_finalized(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.boot_lockbox_finalized)
}

// optional bool owner_password_is_present = 11;
inline bool TpmStatusInfo::_internal_has_owner_password_is_present() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TpmStatusInfo::has_owner_password_is_present() const {
  return _internal_has_owner_password_is_present();
}
inline void TpmStatusInfo::clear_owner_password_is_present() {
  _impl_.owner_password_is_present_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool TpmStatusInfo::_internal_owner_password_is_present() const {
  return _impl_.owner_password_is_present_;
}
inline bool TpmStatusInfo::owner_password_is_present() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.owner_password_is_present)
  return _internal_owner_password_is_present();
}
inline void TpmStatusInfo::_internal_set_owner_password_is_present(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.owner_password_is_present_ = value;
}
inline void TpmStatusInfo::set_owner_password_is_present(bool value) {
  _internal_set_owner_password_is_present(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmStatusInfo.owner_password_is_present)
}

// optional .enterprise_management.TpmSupportedFeatures tpm_supported_features = 12;
inline bool TpmStatusInfo::_internal_has_tpm_supported_features() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tpm_supported_features_ != nullptr);
  return value;
}
inline bool TpmStatusInfo::has_tpm_supported_features() const {
  return _internal_has_tpm_supported_features();
}
inline void TpmStatusInfo::clear_tpm_supported_features() {
  if (_impl_.tpm_supported_features_ != nullptr) _impl_.tpm_supported_features_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::TpmSupportedFeatures& TpmStatusInfo::_internal_tpm_supported_features() const {
  const ::enterprise_management::TpmSupportedFeatures* p = _impl_.tpm_supported_features_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::TpmSupportedFeatures&>(
      ::enterprise_management::_TpmSupportedFeatures_default_instance_);
}
inline const ::enterprise_management::TpmSupportedFeatures& TpmStatusInfo::tpm_supported_features() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmStatusInfo.tpm_supported_features)
  return _internal_tpm_supported_features();
}
inline void TpmStatusInfo::unsafe_arena_set_allocated_tpm_supported_features(
    ::enterprise_management::TpmSupportedFeatures* tpm_supported_features) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tpm_supported_features_);
  }
  _impl_.tpm_supported_features_ = tpm_supported_features;
  if (tpm_supported_features) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.TpmStatusInfo.tpm_supported_features)
}
inline ::enterprise_management::TpmSupportedFeatures* TpmStatusInfo::release_tpm_supported_features() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::TpmSupportedFeatures* temp = _impl_.tpm_supported_features_;
  _impl_.tpm_supported_features_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::TpmSupportedFeatures* TpmStatusInfo::unsafe_arena_release_tpm_supported_features() {
  // @@protoc_insertion_point(field_release:enterprise_management.TpmStatusInfo.tpm_supported_features)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::TpmSupportedFeatures* temp = _impl_.tpm_supported_features_;
  _impl_.tpm_supported_features_ = nullptr;
  return temp;
}
inline ::enterprise_management::TpmSupportedFeatures* TpmStatusInfo::_internal_mutable_tpm_supported_features() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tpm_supported_features_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::TpmSupportedFeatures>(GetArenaForAllocation());
    _impl_.tpm_supported_features_ = p;
  }
  return _impl_.tpm_supported_features_;
}
inline ::enterprise_management::TpmSupportedFeatures* TpmStatusInfo::mutable_tpm_supported_features() {
  ::enterprise_management::TpmSupportedFeatures* _msg = _internal_mutable_tpm_supported_features();
  // @@protoc_insertion_point(field_mutable:enterprise_management.TpmStatusInfo.tpm_supported_features)
  return _msg;
}
inline void TpmStatusInfo::set_allocated_tpm_supported_features(::enterprise_management::TpmSupportedFeatures* tpm_supported_features) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tpm_supported_features_;
  }
  if (tpm_supported_features) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tpm_supported_features);
    if (message_arena != submessage_arena) {
      tpm_supported_features = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tpm_supported_features, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tpm_supported_features_ = tpm_supported_features;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.TpmStatusInfo.tpm_supported_features)
}

// -------------------------------------------------------------------

// TpmSupportedFeatures

// optional bool is_allowed = 1;
inline bool TpmSupportedFeatures::_internal_has_is_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TpmSupportedFeatures::has_is_allowed() const {
  return _internal_has_is_allowed();
}
inline void TpmSupportedFeatures::clear_is_allowed() {
  _impl_.is_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool TpmSupportedFeatures::_internal_is_allowed() const {
  return _impl_.is_allowed_;
}
inline bool TpmSupportedFeatures::is_allowed() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmSupportedFeatures.is_allowed)
  return _internal_is_allowed();
}
inline void TpmSupportedFeatures::_internal_set_is_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.is_allowed_ = value;
}
inline void TpmSupportedFeatures::set_is_allowed(bool value) {
  _internal_set_is_allowed(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmSupportedFeatures.is_allowed)
}

// optional bool support_pinweaver = 2;
inline bool TpmSupportedFeatures::_internal_has_support_pinweaver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TpmSupportedFeatures::has_support_pinweaver() const {
  return _internal_has_support_pinweaver();
}
inline void TpmSupportedFeatures::clear_support_pinweaver() {
  _impl_.support_pinweaver_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TpmSupportedFeatures::_internal_support_pinweaver() const {
  return _impl_.support_pinweaver_;
}
inline bool TpmSupportedFeatures::support_pinweaver() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmSupportedFeatures.support_pinweaver)
  return _internal_support_pinweaver();
}
inline void TpmSupportedFeatures::_internal_set_support_pinweaver(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.support_pinweaver_ = value;
}
inline void TpmSupportedFeatures::set_support_pinweaver(bool value) {
  _internal_set_support_pinweaver(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmSupportedFeatures.support_pinweaver)
}

// optional bool support_runtime_selection = 3;
inline bool TpmSupportedFeatures::_internal_has_support_runtime_selection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TpmSupportedFeatures::has_support_runtime_selection() const {
  return _internal_has_support_runtime_selection();
}
inline void TpmSupportedFeatures::clear_support_runtime_selection() {
  _impl_.support_runtime_selection_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TpmSupportedFeatures::_internal_support_runtime_selection() const {
  return _impl_.support_runtime_selection_;
}
inline bool TpmSupportedFeatures::support_runtime_selection() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmSupportedFeatures.support_runtime_selection)
  return _internal_support_runtime_selection();
}
inline void TpmSupportedFeatures::_internal_set_support_runtime_selection(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.support_runtime_selection_ = value;
}
inline void TpmSupportedFeatures::set_support_runtime_selection(bool value) {
  _internal_set_support_runtime_selection(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmSupportedFeatures.support_runtime_selection)
}

// optional bool support_u2f = 4;
inline bool TpmSupportedFeatures::_internal_has_support_u2f() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TpmSupportedFeatures::has_support_u2f() const {
  return _internal_has_support_u2f();
}
inline void TpmSupportedFeatures::clear_support_u2f() {
  _impl_.support_u2f_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool TpmSupportedFeatures::_internal_support_u2f() const {
  return _impl_.support_u2f_;
}
inline bool TpmSupportedFeatures::support_u2f() const {
  // @@protoc_insertion_point(field_get:enterprise_management.TpmSupportedFeatures.support_u2f)
  return _internal_support_u2f();
}
inline void TpmSupportedFeatures::_internal_set_support_u2f(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.support_u2f_ = value;
}
inline void TpmSupportedFeatures::set_support_u2f(bool value) {
  _internal_set_support_u2f(value);
  // @@protoc_insertion_point(field_set:enterprise_management.TpmSupportedFeatures.support_u2f)
}

// -------------------------------------------------------------------

// SystemState

// repeated .enterprise_management.VolumeInfo volume_infos = 1;
inline int SystemState::_internal_volume_infos_size() const {
  return _impl_.volume_infos_.size();
}
inline int SystemState::volume_infos_size() const {
  return _internal_volume_infos_size();
}
inline void SystemState::clear_volume_infos() {
  _impl_.volume_infos_.Clear();
}
inline ::enterprise_management::VolumeInfo* SystemState::mutable_volume_infos(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.SystemState.volume_infos)
  return _impl_.volume_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >*
SystemState::mutable_volume_infos() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.SystemState.volume_infos)
  return &_impl_.volume_infos_;
}
inline const ::enterprise_management::VolumeInfo& SystemState::_internal_volume_infos(int index) const {
  return _impl_.volume_infos_.Get(index);
}
inline const ::enterprise_management::VolumeInfo& SystemState::volume_infos(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.SystemState.volume_infos)
  return _internal_volume_infos(index);
}
inline ::enterprise_management::VolumeInfo* SystemState::_internal_add_volume_infos() {
  return _impl_.volume_infos_.Add();
}
inline ::enterprise_management::VolumeInfo* SystemState::add_volume_infos() {
  ::enterprise_management::VolumeInfo* _add = _internal_add_volume_infos();
  // @@protoc_insertion_point(field_add:enterprise_management.SystemState.volume_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::VolumeInfo >&
SystemState::volume_infos() const {
  // @@protoc_insertion_point(field_list:enterprise_management.SystemState.volume_infos)
  return _impl_.volume_infos_;
}

// -------------------------------------------------------------------

// ExtensionInstallReportLogEvent

// optional int64 timestamp = 1;
inline bool ExtensionInstallReportLogEvent::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ExtensionInstallReportLogEvent::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ExtensionInstallReportLogEvent::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t ExtensionInstallReportLogEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.timestamp)
  return _internal_timestamp();
}
inline void ExtensionInstallReportLogEvent::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void ExtensionInstallReportLogEvent::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.timestamp)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.EventType event_type = 2;
inline bool ExtensionInstallReportLogEvent::_internal_has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_event_type() const {
  return _internal_has_event_type();
}
inline void ExtensionInstallReportLogEvent::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::_internal_event_type() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_EventType >(_impl_.event_type_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::event_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.event_type)
  return _internal_event_type();
}
inline void ExtensionInstallReportLogEvent::_internal_set_event_type(::enterprise_management::ExtensionInstallReportLogEvent_EventType value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_EventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.event_type_ = value;
}
inline void ExtensionInstallReportLogEvent::set_event_type(::enterprise_management::ExtensionInstallReportLogEvent_EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.event_type)
}

// optional int64 stateful_total = 3;
inline bool ExtensionInstallReportLogEvent::_internal_has_stateful_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_stateful_total() const {
  return _internal_has_stateful_total();
}
inline void ExtensionInstallReportLogEvent::clear_stateful_total() {
  _impl_.stateful_total_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t ExtensionInstallReportLogEvent::_internal_stateful_total() const {
  return _impl_.stateful_total_;
}
inline int64_t ExtensionInstallReportLogEvent::stateful_total() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.stateful_total)
  return _internal_stateful_total();
}
inline void ExtensionInstallReportLogEvent::_internal_set_stateful_total(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stateful_total_ = value;
}
inline void ExtensionInstallReportLogEvent::set_stateful_total(int64_t value) {
  _internal_set_stateful_total(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.stateful_total)
}

// optional int64 stateful_free = 4;
inline bool ExtensionInstallReportLogEvent::_internal_has_stateful_free() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_stateful_free() const {
  return _internal_has_stateful_free();
}
inline void ExtensionInstallReportLogEvent::clear_stateful_free() {
  _impl_.stateful_free_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ExtensionInstallReportLogEvent::_internal_stateful_free() const {
  return _impl_.stateful_free_;
}
inline int64_t ExtensionInstallReportLogEvent::stateful_free() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.stateful_free)
  return _internal_stateful_free();
}
inline void ExtensionInstallReportLogEvent::_internal_set_stateful_free(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stateful_free_ = value;
}
inline void ExtensionInstallReportLogEvent::set_stateful_free(int64_t value) {
  _internal_set_stateful_free(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.stateful_free)
}

// optional bool online = 5;
inline bool ExtensionInstallReportLogEvent::_internal_has_online() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_online() const {
  return _internal_has_online();
}
inline void ExtensionInstallReportLogEvent::clear_online() {
  _impl_.online_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool ExtensionInstallReportLogEvent::_internal_online() const {
  return _impl_.online_;
}
inline bool ExtensionInstallReportLogEvent::online() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.online)
  return _internal_online();
}
inline void ExtensionInstallReportLogEvent::_internal_set_online(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.online_ = value;
}
inline void ExtensionInstallReportLogEvent::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.online)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.SessionStateChangeType session_state_change_type = 6;
inline bool ExtensionInstallReportLogEvent::_internal_has_session_state_change_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_session_state_change_type() const {
  return _internal_has_session_state_change_type();
}
inline void ExtensionInstallReportLogEvent::clear_session_state_change_type() {
  _impl_.session_state_change_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::_internal_session_state_change_type() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType >(_impl_.session_state_change_type_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::session_state_change_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.session_state_change_type)
  return _internal_session_state_change_type();
}
inline void ExtensionInstallReportLogEvent::_internal_set_session_state_change_type(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.session_state_change_type_ = value;
}
inline void ExtensionInstallReportLogEvent::set_session_state_change_type(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType value) {
  _internal_set_session_state_change_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.session_state_change_type)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.FailureReason failure_reason = 7;
inline bool ExtensionInstallReportLogEvent::_internal_has_failure_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_failure_reason() const {
  return _internal_has_failure_reason();
}
inline void ExtensionInstallReportLogEvent::clear_failure_reason() {
  _impl_.failure_reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::_internal_failure_reason() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_FailureReason >(_impl_.failure_reason_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::failure_reason() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.failure_reason)
  return _internal_failure_reason();
}
inline void ExtensionInstallReportLogEvent::_internal_set_failure_reason(::enterprise_management::ExtensionInstallReportLogEvent_FailureReason value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_FailureReason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.failure_reason_ = value;
}
inline void ExtensionInstallReportLogEvent::set_failure_reason(::enterprise_management::ExtensionInstallReportLogEvent_FailureReason value) {
  _internal_set_failure_reason(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.failure_reason)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.InstallationStage installation_stage = 8;
inline bool ExtensionInstallReportLogEvent::_internal_has_installation_stage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_installation_stage() const {
  return _internal_has_installation_stage();
}
inline void ExtensionInstallReportLogEvent::clear_installation_stage() {
  _impl_.installation_stage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::_internal_installation_stage() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage >(_impl_.installation_stage_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::installation_stage() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.installation_stage)
  return _internal_installation_stage();
}
inline void ExtensionInstallReportLogEvent::_internal_set_installation_stage(::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.installation_stage_ = value;
}
inline void ExtensionInstallReportLogEvent::set_installation_stage(::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage value) {
  _internal_set_installation_stage(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.installation_stage)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadingStage downloading_stage = 9;
inline bool ExtensionInstallReportLogEvent::_internal_has_downloading_stage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_downloading_stage() const {
  return _internal_has_downloading_stage();
}
inline void ExtensionInstallReportLogEvent::clear_downloading_stage() {
  _impl_.downloading_stage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::_internal_downloading_stage() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage >(_impl_.downloading_stage_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::downloading_stage() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.downloading_stage)
  return _internal_downloading_stage();
}
inline void ExtensionInstallReportLogEvent::_internal_set_downloading_stage(::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.downloading_stage_ = value;
}
inline void ExtensionInstallReportLogEvent::set_downloading_stage(::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage value) {
  _internal_set_downloading_stage(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.downloading_stage)
}

// optional .enterprise_management.Extension.ExtensionType extension_type = 10;
inline bool ExtensionInstallReportLogEvent::_internal_has_extension_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_extension_type() const {
  return _internal_has_extension_type();
}
inline void ExtensionInstallReportLogEvent::clear_extension_type() {
  _impl_.extension_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::enterprise_management::Extension_ExtensionType ExtensionInstallReportLogEvent::_internal_extension_type() const {
  return static_cast< ::enterprise_management::Extension_ExtensionType >(_impl_.extension_type_);
}
inline ::enterprise_management::Extension_ExtensionType ExtensionInstallReportLogEvent::extension_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.extension_type)
  return _internal_extension_type();
}
inline void ExtensionInstallReportLogEvent::_internal_set_extension_type(::enterprise_management::Extension_ExtensionType value) {
  assert(::enterprise_management::Extension_ExtensionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.extension_type_ = value;
}
inline void ExtensionInstallReportLogEvent::set_extension_type(::enterprise_management::Extension_ExtensionType value) {
  _internal_set_extension_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.extension_type)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.UserType user_type = 11;
inline bool ExtensionInstallReportLogEvent::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_user_type() const {
  return _internal_has_user_type();
}
inline void ExtensionInstallReportLogEvent::clear_user_type() {
  _impl_.user_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::_internal_user_type() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_UserType >(_impl_.user_type_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::user_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.user_type)
  return _internal_user_type();
}
inline void ExtensionInstallReportLogEvent::_internal_set_user_type(::enterprise_management::ExtensionInstallReportLogEvent_UserType value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_UserType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.user_type_ = value;
}
inline void ExtensionInstallReportLogEvent::set_user_type(::enterprise_management::ExtensionInstallReportLogEvent_UserType value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.user_type)
}

// optional bool is_new_user = 12;
inline bool ExtensionInstallReportLogEvent::_internal_has_is_new_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_is_new_user() const {
  return _internal_has_is_new_user();
}
inline void ExtensionInstallReportLogEvent::clear_is_new_user() {
  _impl_.is_new_user_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool ExtensionInstallReportLogEvent::_internal_is_new_user() const {
  return _impl_.is_new_user_;
}
inline bool ExtensionInstallReportLogEvent::is_new_user() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.is_new_user)
  return _internal_is_new_user();
}
inline void ExtensionInstallReportLogEvent::_internal_set_is_new_user(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.is_new_user_ = value;
}
inline void ExtensionInstallReportLogEvent::set_is_new_user(bool value) {
  _internal_set_is_new_user(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.is_new_user)
}

// optional bool is_misconfiguration_failure = 13;
inline bool ExtensionInstallReportLogEvent::_internal_has_is_misconfiguration_failure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_is_misconfiguration_failure() const {
  return _internal_has_is_misconfiguration_failure();
}
inline void ExtensionInstallReportLogEvent::clear_is_misconfiguration_failure() {
  _impl_.is_misconfiguration_failure_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool ExtensionInstallReportLogEvent::_internal_is_misconfiguration_failure() const {
  return _impl_.is_misconfiguration_failure_;
}
inline bool ExtensionInstallReportLogEvent::is_misconfiguration_failure() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.is_misconfiguration_failure)
  return _internal_is_misconfiguration_failure();
}
inline void ExtensionInstallReportLogEvent::_internal_set_is_misconfiguration_failure(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.is_misconfiguration_failure_ = value;
}
inline void ExtensionInstallReportLogEvent::set_is_misconfiguration_failure(bool value) {
  _internal_set_is_misconfiguration_failure(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.is_misconfiguration_failure)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.InstallCreationStage install_creation_stage = 14;
inline bool ExtensionInstallReportLogEvent::_internal_has_install_creation_stage() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_install_creation_stage() const {
  return _internal_has_install_creation_stage();
}
inline void ExtensionInstallReportLogEvent::clear_install_creation_stage() {
  _impl_.install_creation_stage_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::_internal_install_creation_stage() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage >(_impl_.install_creation_stage_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::install_creation_stage() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.install_creation_stage)
  return _internal_install_creation_stage();
}
inline void ExtensionInstallReportLogEvent::_internal_set_install_creation_stage(::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.install_creation_stage_ = value;
}
inline void ExtensionInstallReportLogEvent::set_install_creation_stage(::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage value) {
  _internal_set_install_creation_stage(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.install_creation_stage)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadCacheStatus download_cache_status = 15;
inline bool ExtensionInstallReportLogEvent::_internal_has_download_cache_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_download_cache_status() const {
  return _internal_has_download_cache_status();
}
inline void ExtensionInstallReportLogEvent::clear_download_cache_status() {
  _impl_.download_cache_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::_internal_download_cache_status() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus >(_impl_.download_cache_status_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::download_cache_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.download_cache_status)
  return _internal_download_cache_status();
}
inline void ExtensionInstallReportLogEvent::_internal_set_download_cache_status(::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.download_cache_status_ = value;
}
inline void ExtensionInstallReportLogEvent::set_download_cache_status(::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus value) {
  _internal_set_download_cache_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.download_cache_status)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.SandboxedUnpackerFailureReason unpacker_failure_reason = 16;
inline bool ExtensionInstallReportLogEvent::_internal_has_unpacker_failure_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_unpacker_failure_reason() const {
  return _internal_has_unpacker_failure_reason();
}
inline void ExtensionInstallReportLogEvent::clear_unpacker_failure_reason() {
  _impl_.unpacker_failure_reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::_internal_unpacker_failure_reason() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason >(_impl_.unpacker_failure_reason_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::unpacker_failure_reason() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.unpacker_failure_reason)
  return _internal_unpacker_failure_reason();
}
inline void ExtensionInstallReportLogEvent::_internal_set_unpacker_failure_reason(::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.unpacker_failure_reason_ = value;
}
inline void ExtensionInstallReportLogEvent::set_unpacker_failure_reason(::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason value) {
  _internal_set_unpacker_failure_reason(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.unpacker_failure_reason)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.ManifestInvalidError manifest_invalid_error = 17;
inline bool ExtensionInstallReportLogEvent::_internal_has_manifest_invalid_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_manifest_invalid_error() const {
  return _internal_has_manifest_invalid_error();
}
inline void ExtensionInstallReportLogEvent::clear_manifest_invalid_error() {
  _impl_.manifest_invalid_error_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::_internal_manifest_invalid_error() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError >(_impl_.manifest_invalid_error_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::manifest_invalid_error() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.manifest_invalid_error)
  return _internal_manifest_invalid_error();
}
inline void ExtensionInstallReportLogEvent::_internal_set_manifest_invalid_error(::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.manifest_invalid_error_ = value;
}
inline void ExtensionInstallReportLogEvent::set_manifest_invalid_error(::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError value) {
  _internal_set_manifest_invalid_error(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.manifest_invalid_error)
}

// optional .enterprise_management.ExtensionInstallReportLogEvent.CrxInstallErrorDetail crx_install_error_detail = 18;
inline bool ExtensionInstallReportLogEvent::_internal_has_crx_install_error_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_crx_install_error_detail() const {
  return _internal_has_crx_install_error_detail();
}
inline void ExtensionInstallReportLogEvent::clear_crx_install_error_detail() {
  _impl_.crx_install_error_detail_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::_internal_crx_install_error_detail() const {
  return static_cast< ::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail >(_impl_.crx_install_error_detail_);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::crx_install_error_detail() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.crx_install_error_detail)
  return _internal_crx_install_error_detail();
}
inline void ExtensionInstallReportLogEvent::_internal_set_crx_install_error_detail(::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail value) {
  assert(::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail_IsValid(value));
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.crx_install_error_detail_ = value;
}
inline void ExtensionInstallReportLogEvent::set_crx_install_error_detail(::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail value) {
  _internal_set_crx_install_error_detail(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.crx_install_error_detail)
}

// optional int32 fetch_error_code = 19;
inline bool ExtensionInstallReportLogEvent::_internal_has_fetch_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_fetch_error_code() const {
  return _internal_has_fetch_error_code();
}
inline void ExtensionInstallReportLogEvent::clear_fetch_error_code() {
  _impl_.fetch_error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline int32_t ExtensionInstallReportLogEvent::_internal_fetch_error_code() const {
  return _impl_.fetch_error_code_;
}
inline int32_t ExtensionInstallReportLogEvent::fetch_error_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.fetch_error_code)
  return _internal_fetch_error_code();
}
inline void ExtensionInstallReportLogEvent::_internal_set_fetch_error_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.fetch_error_code_ = value;
}
inline void ExtensionInstallReportLogEvent::set_fetch_error_code(int32_t value) {
  _internal_set_fetch_error_code(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.fetch_error_code)
}

// optional int32 fetch_tries = 20;
inline bool ExtensionInstallReportLogEvent::_internal_has_fetch_tries() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ExtensionInstallReportLogEvent::has_fetch_tries() const {
  return _internal_has_fetch_tries();
}
inline void ExtensionInstallReportLogEvent::clear_fetch_tries() {
  _impl_.fetch_tries_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int32_t ExtensionInstallReportLogEvent::_internal_fetch_tries() const {
  return _impl_.fetch_tries_;
}
inline int32_t ExtensionInstallReportLogEvent::fetch_tries() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportLogEvent.fetch_tries)
  return _internal_fetch_tries();
}
inline void ExtensionInstallReportLogEvent::_internal_set_fetch_tries(int32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.fetch_tries_ = value;
}
inline void ExtensionInstallReportLogEvent::set_fetch_tries(int32_t value) {
  _internal_set_fetch_tries(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReportLogEvent.fetch_tries)
}

// -------------------------------------------------------------------

// AppInstallReportLogEvent

// optional int64 timestamp = 1;
inline bool AppInstallReportLogEvent::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void AppInstallReportLogEvent::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t AppInstallReportLogEvent::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t AppInstallReportLogEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.timestamp)
  return _internal_timestamp();
}
inline void AppInstallReportLogEvent::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void AppInstallReportLogEvent::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.timestamp)
}

// optional .enterprise_management.AppInstallReportLogEvent.EventType event_type = 2;
inline bool AppInstallReportLogEvent::_internal_has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_event_type() const {
  return _internal_has_event_type();
}
inline void AppInstallReportLogEvent::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::AppInstallReportLogEvent_EventType AppInstallReportLogEvent::_internal_event_type() const {
  return static_cast< ::enterprise_management::AppInstallReportLogEvent_EventType >(_impl_.event_type_);
}
inline ::enterprise_management::AppInstallReportLogEvent_EventType AppInstallReportLogEvent::event_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.event_type)
  return _internal_event_type();
}
inline void AppInstallReportLogEvent::_internal_set_event_type(::enterprise_management::AppInstallReportLogEvent_EventType value) {
  assert(::enterprise_management::AppInstallReportLogEvent_EventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.event_type_ = value;
}
inline void AppInstallReportLogEvent::set_event_type(::enterprise_management::AppInstallReportLogEvent_EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.event_type)
}

// optional int64 stateful_total = 3;
inline bool AppInstallReportLogEvent::_internal_has_stateful_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_stateful_total() const {
  return _internal_has_stateful_total();
}
inline void AppInstallReportLogEvent::clear_stateful_total() {
  _impl_.stateful_total_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t AppInstallReportLogEvent::_internal_stateful_total() const {
  return _impl_.stateful_total_;
}
inline int64_t AppInstallReportLogEvent::stateful_total() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.stateful_total)
  return _internal_stateful_total();
}
inline void AppInstallReportLogEvent::_internal_set_stateful_total(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stateful_total_ = value;
}
inline void AppInstallReportLogEvent::set_stateful_total(int64_t value) {
  _internal_set_stateful_total(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.stateful_total)
}

// optional int64 stateful_free = 4;
inline bool AppInstallReportLogEvent::_internal_has_stateful_free() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_stateful_free() const {
  return _internal_has_stateful_free();
}
inline void AppInstallReportLogEvent::clear_stateful_free() {
  _impl_.stateful_free_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t AppInstallReportLogEvent::_internal_stateful_free() const {
  return _impl_.stateful_free_;
}
inline int64_t AppInstallReportLogEvent::stateful_free() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.stateful_free)
  return _internal_stateful_free();
}
inline void AppInstallReportLogEvent::_internal_set_stateful_free(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.stateful_free_ = value;
}
inline void AppInstallReportLogEvent::set_stateful_free(int64_t value) {
  _internal_set_stateful_free(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.stateful_free)
}

// optional int32 clouddps_response = 5;
inline bool AppInstallReportLogEvent::_internal_has_clouddps_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_clouddps_response() const {
  return _internal_has_clouddps_response();
}
inline void AppInstallReportLogEvent::clear_clouddps_response() {
  _impl_.clouddps_response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t AppInstallReportLogEvent::_internal_clouddps_response() const {
  return _impl_.clouddps_response_;
}
inline int32_t AppInstallReportLogEvent::clouddps_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.clouddps_response)
  return _internal_clouddps_response();
}
inline void AppInstallReportLogEvent::_internal_set_clouddps_response(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.clouddps_response_ = value;
}
inline void AppInstallReportLogEvent::set_clouddps_response(int32_t value) {
  _internal_set_clouddps_response(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.clouddps_response)
}

// optional string phonesky_log = 6;
inline bool AppInstallReportLogEvent::_internal_has_phonesky_log() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_phonesky_log() const {
  return _internal_has_phonesky_log();
}
inline void AppInstallReportLogEvent::clear_phonesky_log() {
  _impl_.phonesky_log_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInstallReportLogEvent::phonesky_log() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.phonesky_log)
  return _internal_phonesky_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInstallReportLogEvent::set_phonesky_log(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.phonesky_log_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.phonesky_log)
}
inline std::string* AppInstallReportLogEvent::mutable_phonesky_log() {
  std::string* _s = _internal_mutable_phonesky_log();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppInstallReportLogEvent.phonesky_log)
  return _s;
}
inline const std::string& AppInstallReportLogEvent::_internal_phonesky_log() const {
  return _impl_.phonesky_log_.Get();
}
inline void AppInstallReportLogEvent::_internal_set_phonesky_log(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phonesky_log_.Set(value, GetArenaForAllocation());
}
inline std::string* AppInstallReportLogEvent::_internal_mutable_phonesky_log() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phonesky_log_.Mutable(GetArenaForAllocation());
}
inline std::string* AppInstallReportLogEvent::release_phonesky_log() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppInstallReportLogEvent.phonesky_log)
  if (!_internal_has_phonesky_log()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.phonesky_log_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phonesky_log_.IsDefault()) {
    _impl_.phonesky_log_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppInstallReportLogEvent::set_allocated_phonesky_log(std::string* phonesky_log) {
  if (phonesky_log != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phonesky_log_.SetAllocated(phonesky_log, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phonesky_log_.IsDefault()) {
    _impl_.phonesky_log_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInstallReportLogEvent.phonesky_log)
}

// optional bool online = 7;
inline bool AppInstallReportLogEvent::_internal_has_online() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_online() const {
  return _internal_has_online();
}
inline void AppInstallReportLogEvent::clear_online() {
  _impl_.online_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool AppInstallReportLogEvent::_internal_online() const {
  return _impl_.online_;
}
inline bool AppInstallReportLogEvent::online() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.online)
  return _internal_online();
}
inline void AppInstallReportLogEvent::_internal_set_online(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.online_ = value;
}
inline void AppInstallReportLogEvent::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.online)
}

// optional .enterprise_management.AppInstallReportLogEvent.SessionStateChangeType session_state_change_type = 8;
inline bool AppInstallReportLogEvent::_internal_has_session_state_change_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_session_state_change_type() const {
  return _internal_has_session_state_change_type();
}
inline void AppInstallReportLogEvent::clear_session_state_change_type() {
  _impl_.session_state_change_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::_internal_session_state_change_type() const {
  return static_cast< ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType >(_impl_.session_state_change_type_);
}
inline ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::session_state_change_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.session_state_change_type)
  return _internal_session_state_change_type();
}
inline void AppInstallReportLogEvent::_internal_set_session_state_change_type(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType value) {
  assert(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.session_state_change_type_ = value;
}
inline void AppInstallReportLogEvent::set_session_state_change_type(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType value) {
  _internal_set_session_state_change_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.session_state_change_type)
}

// optional int64 android_id = 9;
inline bool AppInstallReportLogEvent::_internal_has_android_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AppInstallReportLogEvent::has_android_id() const {
  return _internal_has_android_id();
}
inline void AppInstallReportLogEvent::clear_android_id() {
  _impl_.android_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t AppInstallReportLogEvent::_internal_android_id() const {
  return _impl_.android_id_;
}
inline int64_t AppInstallReportLogEvent::android_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportLogEvent.android_id)
  return _internal_android_id();
}
inline void AppInstallReportLogEvent::_internal_set_android_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.android_id_ = value;
}
inline void AppInstallReportLogEvent::set_android_id(int64_t value) {
  _internal_set_android_id(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReportLogEvent.android_id)
}

// -------------------------------------------------------------------

// ExtensionInstallReport

// optional string extension_id = 1;
inline bool ExtensionInstallReport::_internal_has_extension_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtensionInstallReport::has_extension_id() const {
  return _internal_has_extension_id();
}
inline void ExtensionInstallReport::clear_extension_id() {
  _impl_.extension_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionInstallReport::extension_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReport.extension_id)
  return _internal_extension_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtensionInstallReport::set_extension_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.extension_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReport.extension_id)
}
inline std::string* ExtensionInstallReport::mutable_extension_id() {
  std::string* _s = _internal_mutable_extension_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionInstallReport.extension_id)
  return _s;
}
inline const std::string& ExtensionInstallReport::_internal_extension_id() const {
  return _impl_.extension_id_.Get();
}
inline void ExtensionInstallReport::_internal_set_extension_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.extension_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionInstallReport::_internal_mutable_extension_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.extension_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionInstallReport::release_extension_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ExtensionInstallReport.extension_id)
  if (!_internal_has_extension_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.extension_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_id_.IsDefault()) {
    _impl_.extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtensionInstallReport::set_allocated_extension_id(std::string* extension_id) {
  if (extension_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.extension_id_.SetAllocated(extension_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extension_id_.IsDefault()) {
    _impl_.extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ExtensionInstallReport.extension_id)
}

// optional bool incomplete = 2;
inline bool ExtensionInstallReport::_internal_has_incomplete() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtensionInstallReport::has_incomplete() const {
  return _internal_has_incomplete();
}
inline void ExtensionInstallReport::clear_incomplete() {
  _impl_.incomplete_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ExtensionInstallReport::_internal_incomplete() const {
  return _impl_.incomplete_;
}
inline bool ExtensionInstallReport::incomplete() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReport.incomplete)
  return _internal_incomplete();
}
inline void ExtensionInstallReport::_internal_set_incomplete(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.incomplete_ = value;
}
inline void ExtensionInstallReport::set_incomplete(bool value) {
  _internal_set_incomplete(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ExtensionInstallReport.incomplete)
}

// repeated .enterprise_management.ExtensionInstallReportLogEvent logs = 3;
inline int ExtensionInstallReport::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int ExtensionInstallReport::logs_size() const {
  return _internal_logs_size();
}
inline void ExtensionInstallReport::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::enterprise_management::ExtensionInstallReportLogEvent* ExtensionInstallReport::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionInstallReport.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent >*
ExtensionInstallReport::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ExtensionInstallReport.logs)
  return &_impl_.logs_;
}
inline const ::enterprise_management::ExtensionInstallReportLogEvent& ExtensionInstallReport::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::enterprise_management::ExtensionInstallReportLogEvent& ExtensionInstallReport::logs(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReport.logs)
  return _internal_logs(index);
}
inline ::enterprise_management::ExtensionInstallReportLogEvent* ExtensionInstallReport::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::enterprise_management::ExtensionInstallReportLogEvent* ExtensionInstallReport::add_logs() {
  ::enterprise_management::ExtensionInstallReportLogEvent* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:enterprise_management.ExtensionInstallReport.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReportLogEvent >&
ExtensionInstallReport::logs() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ExtensionInstallReport.logs)
  return _impl_.logs_;
}

// -------------------------------------------------------------------

// AppInstallReport

// optional string package = 1;
inline bool AppInstallReport::_internal_has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppInstallReport::has_package() const {
  return _internal_has_package();
}
inline void AppInstallReport::clear_package() {
  _impl_.package_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInstallReport::package() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReport.package)
  return _internal_package();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInstallReport::set_package(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReport.package)
}
inline std::string* AppInstallReport::mutable_package() {
  std::string* _s = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppInstallReport.package)
  return _s;
}
inline const std::string& AppInstallReport::_internal_package() const {
  return _impl_.package_.Get();
}
inline void AppInstallReport::_internal_set_package(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_.Set(value, GetArenaForAllocation());
}
inline std::string* AppInstallReport::_internal_mutable_package() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_.Mutable(GetArenaForAllocation());
}
inline std::string* AppInstallReport::release_package() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppInstallReport.package)
  if (!_internal_has_package()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_.IsDefault()) {
    _impl_.package_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppInstallReport::set_allocated_package(std::string* package) {
  if (package != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_.SetAllocated(package, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_.IsDefault()) {
    _impl_.package_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppInstallReport.package)
}

// optional bool incomplete = 2;
inline bool AppInstallReport::_internal_has_incomplete() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppInstallReport::has_incomplete() const {
  return _internal_has_incomplete();
}
inline void AppInstallReport::clear_incomplete() {
  _impl_.incomplete_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AppInstallReport::_internal_incomplete() const {
  return _impl_.incomplete_;
}
inline bool AppInstallReport::incomplete() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReport.incomplete)
  return _internal_incomplete();
}
inline void AppInstallReport::_internal_set_incomplete(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.incomplete_ = value;
}
inline void AppInstallReport::set_incomplete(bool value) {
  _internal_set_incomplete(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppInstallReport.incomplete)
}

// repeated .enterprise_management.AppInstallReportLogEvent logs = 3;
inline int AppInstallReport::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int AppInstallReport::logs_size() const {
  return _internal_logs_size();
}
inline void AppInstallReport::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::enterprise_management::AppInstallReportLogEvent* AppInstallReport::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppInstallReport.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent >*
AppInstallReport::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.AppInstallReport.logs)
  return &_impl_.logs_;
}
inline const ::enterprise_management::AppInstallReportLogEvent& AppInstallReport::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::enterprise_management::AppInstallReportLogEvent& AppInstallReport::logs(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReport.logs)
  return _internal_logs(index);
}
inline ::enterprise_management::AppInstallReportLogEvent* AppInstallReport::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::enterprise_management::AppInstallReportLogEvent* AppInstallReport::add_logs() {
  ::enterprise_management::AppInstallReportLogEvent* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:enterprise_management.AppInstallReport.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReportLogEvent >&
AppInstallReport::logs() const {
  // @@protoc_insertion_point(field_list:enterprise_management.AppInstallReport.logs)
  return _impl_.logs_;
}

// -------------------------------------------------------------------

// AppInstallReportRequest

// repeated .enterprise_management.AppInstallReport app_install_reports = 1;
inline int AppInstallReportRequest::_internal_app_install_reports_size() const {
  return _impl_.app_install_reports_.size();
}
inline int AppInstallReportRequest::app_install_reports_size() const {
  return _internal_app_install_reports_size();
}
inline void AppInstallReportRequest::clear_app_install_reports() {
  _impl_.app_install_reports_.Clear();
}
inline ::enterprise_management::AppInstallReport* AppInstallReportRequest::mutable_app_install_reports(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppInstallReportRequest.app_install_reports)
  return _impl_.app_install_reports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport >*
AppInstallReportRequest::mutable_app_install_reports() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.AppInstallReportRequest.app_install_reports)
  return &_impl_.app_install_reports_;
}
inline const ::enterprise_management::AppInstallReport& AppInstallReportRequest::_internal_app_install_reports(int index) const {
  return _impl_.app_install_reports_.Get(index);
}
inline const ::enterprise_management::AppInstallReport& AppInstallReportRequest::app_install_reports(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppInstallReportRequest.app_install_reports)
  return _internal_app_install_reports(index);
}
inline ::enterprise_management::AppInstallReport* AppInstallReportRequest::_internal_add_app_install_reports() {
  return _impl_.app_install_reports_.Add();
}
inline ::enterprise_management::AppInstallReport* AppInstallReportRequest::add_app_install_reports() {
  ::enterprise_management::AppInstallReport* _add = _internal_add_app_install_reports();
  // @@protoc_insertion_point(field_add:enterprise_management.AppInstallReportRequest.app_install_reports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppInstallReport >&
AppInstallReportRequest::app_install_reports() const {
  // @@protoc_insertion_point(field_list:enterprise_management.AppInstallReportRequest.app_install_reports)
  return _impl_.app_install_reports_;
}

// -------------------------------------------------------------------

// ExtensionInstallReportRequest

// repeated .enterprise_management.ExtensionInstallReport extension_install_reports = 1;
inline int ExtensionInstallReportRequest::_internal_extension_install_reports_size() const {
  return _impl_.extension_install_reports_.size();
}
inline int ExtensionInstallReportRequest::extension_install_reports_size() const {
  return _internal_extension_install_reports_size();
}
inline void ExtensionInstallReportRequest::clear_extension_install_reports() {
  _impl_.extension_install_reports_.Clear();
}
inline ::enterprise_management::ExtensionInstallReport* ExtensionInstallReportRequest::mutable_extension_install_reports(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
  return _impl_.extension_install_reports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport >*
ExtensionInstallReportRequest::mutable_extension_install_reports() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
  return &_impl_.extension_install_reports_;
}
inline const ::enterprise_management::ExtensionInstallReport& ExtensionInstallReportRequest::_internal_extension_install_reports(int index) const {
  return _impl_.extension_install_reports_.Get(index);
}
inline const ::enterprise_management::ExtensionInstallReport& ExtensionInstallReportRequest::extension_install_reports(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
  return _internal_extension_install_reports(index);
}
inline ::enterprise_management::ExtensionInstallReport* ExtensionInstallReportRequest::_internal_add_extension_install_reports() {
  return _impl_.extension_install_reports_.Add();
}
inline ::enterprise_management::ExtensionInstallReport* ExtensionInstallReportRequest::add_extension_install_reports() {
  ::enterprise_management::ExtensionInstallReport* _add = _internal_add_extension_install_reports();
  // @@protoc_insertion_point(field_add:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ExtensionInstallReport >&
ExtensionInstallReportRequest::extension_install_reports() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ExtensionInstallReportRequest.extension_install_reports)
  return _impl_.extension_install_reports_;
}

// -------------------------------------------------------------------

// AppInstallReportResponse

// -------------------------------------------------------------------

// RefreshAccountRequest

// optional .enterprise_management.RefreshAccountRequest.AccountType account_type = 1;
inline bool RefreshAccountRequest::_internal_has_account_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RefreshAccountRequest::has_account_type() const {
  return _internal_has_account_type();
}
inline void RefreshAccountRequest::clear_account_type() {
  _impl_.account_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::RefreshAccountRequest_AccountType RefreshAccountRequest::_internal_account_type() const {
  return static_cast< ::enterprise_management::RefreshAccountRequest_AccountType >(_impl_.account_type_);
}
inline ::enterprise_management::RefreshAccountRequest_AccountType RefreshAccountRequest::account_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RefreshAccountRequest.account_type)
  return _internal_account_type();
}
inline void RefreshAccountRequest::_internal_set_account_type(::enterprise_management::RefreshAccountRequest_AccountType value) {
  assert(::enterprise_management::RefreshAccountRequest_AccountType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_type_ = value;
}
inline void RefreshAccountRequest::set_account_type(::enterprise_management::RefreshAccountRequest_AccountType value) {
  _internal_set_account_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RefreshAccountRequest.account_type)
}

// -------------------------------------------------------------------

// RefreshAccountResponse

// -------------------------------------------------------------------

// RsuLookupKeyUploadRequest

// optional bytes board_id = 1;
inline bool RsuLookupKeyUploadRequest::_internal_has_board_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RsuLookupKeyUploadRequest::has_board_id() const {
  return _internal_has_board_id();
}
inline void RsuLookupKeyUploadRequest::clear_board_id() {
  _impl_.board_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RsuLookupKeyUploadRequest::board_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RsuLookupKeyUploadRequest.board_id)
  return _internal_board_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsuLookupKeyUploadRequest::set_board_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.board_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RsuLookupKeyUploadRequest.board_id)
}
inline std::string* RsuLookupKeyUploadRequest::mutable_board_id() {
  std::string* _s = _internal_mutable_board_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RsuLookupKeyUploadRequest.board_id)
  return _s;
}
inline const std::string& RsuLookupKeyUploadRequest::_internal_board_id() const {
  return _impl_.board_id_.Get();
}
inline void RsuLookupKeyUploadRequest::_internal_set_board_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.board_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RsuLookupKeyUploadRequest::_internal_mutable_board_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.board_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RsuLookupKeyUploadRequest::release_board_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.RsuLookupKeyUploadRequest.board_id)
  if (!_internal_has_board_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.board_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.board_id_.IsDefault()) {
    _impl_.board_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RsuLookupKeyUploadRequest::set_allocated_board_id(std::string* board_id) {
  if (board_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.board_id_.SetAllocated(board_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.board_id_.IsDefault()) {
    _impl_.board_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RsuLookupKeyUploadRequest.board_id)
}

// optional bytes cr50_hashed_device_id = 2;
inline bool RsuLookupKeyUploadRequest::_internal_has_cr50_hashed_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RsuLookupKeyUploadRequest::has_cr50_hashed_device_id() const {
  return _internal_has_cr50_hashed_device_id();
}
inline void RsuLookupKeyUploadRequest::clear_cr50_hashed_device_id() {
  _impl_.cr50_hashed_device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RsuLookupKeyUploadRequest::cr50_hashed_device_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
  return _internal_cr50_hashed_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsuLookupKeyUploadRequest::set_cr50_hashed_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cr50_hashed_device_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
}
inline std::string* RsuLookupKeyUploadRequest::mutable_cr50_hashed_device_id() {
  std::string* _s = _internal_mutable_cr50_hashed_device_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
  return _s;
}
inline const std::string& RsuLookupKeyUploadRequest::_internal_cr50_hashed_device_id() const {
  return _impl_.cr50_hashed_device_id_.Get();
}
inline void RsuLookupKeyUploadRequest::_internal_set_cr50_hashed_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cr50_hashed_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RsuLookupKeyUploadRequest::_internal_mutable_cr50_hashed_device_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cr50_hashed_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RsuLookupKeyUploadRequest::release_cr50_hashed_device_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
  if (!_internal_has_cr50_hashed_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cr50_hashed_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cr50_hashed_device_id_.IsDefault()) {
    _impl_.cr50_hashed_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RsuLookupKeyUploadRequest::set_allocated_cr50_hashed_device_id(std::string* cr50_hashed_device_id) {
  if (cr50_hashed_device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cr50_hashed_device_id_.SetAllocated(cr50_hashed_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cr50_hashed_device_id_.IsDefault()) {
    _impl_.cr50_hashed_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.RsuLookupKeyUploadRequest.cr50_hashed_device_id)
}

// -------------------------------------------------------------------

// RsuLookupKeyUploadResponse

// optional bool rsu_lookup_key_updated = 1;
inline bool RsuLookupKeyUploadResponse::_internal_has_rsu_lookup_key_updated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RsuLookupKeyUploadResponse::has_rsu_lookup_key_updated() const {
  return _internal_has_rsu_lookup_key_updated();
}
inline void RsuLookupKeyUploadResponse::clear_rsu_lookup_key_updated() {
  _impl_.rsu_lookup_key_updated_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RsuLookupKeyUploadResponse::_internal_rsu_lookup_key_updated() const {
  return _impl_.rsu_lookup_key_updated_;
}
inline bool RsuLookupKeyUploadResponse::rsu_lookup_key_updated() const {
  // @@protoc_insertion_point(field_get:enterprise_management.RsuLookupKeyUploadResponse.rsu_lookup_key_updated)
  return _internal_rsu_lookup_key_updated();
}
inline void RsuLookupKeyUploadResponse::_internal_set_rsu_lookup_key_updated(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rsu_lookup_key_updated_ = value;
}
inline void RsuLookupKeyUploadResponse::set_rsu_lookup_key_updated(bool value) {
  _internal_set_rsu_lookup_key_updated(value);
  // @@protoc_insertion_point(field_set:enterprise_management.RsuLookupKeyUploadResponse.rsu_lookup_key_updated)
}

// -------------------------------------------------------------------

// ESimProfileInfo

// optional string iccid = 1;
inline bool ESimProfileInfo::_internal_has_iccid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ESimProfileInfo::has_iccid() const {
  return _internal_has_iccid();
}
inline void ESimProfileInfo::clear_iccid() {
  _impl_.iccid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ESimProfileInfo::iccid() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ESimProfileInfo.iccid)
  return _internal_iccid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ESimProfileInfo::set_iccid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.iccid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ESimProfileInfo.iccid)
}
inline std::string* ESimProfileInfo::mutable_iccid() {
  std::string* _s = _internal_mutable_iccid();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ESimProfileInfo.iccid)
  return _s;
}
inline const std::string& ESimProfileInfo::_internal_iccid() const {
  return _impl_.iccid_.Get();
}
inline void ESimProfileInfo::_internal_set_iccid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.iccid_.Set(value, GetArenaForAllocation());
}
inline std::string* ESimProfileInfo::_internal_mutable_iccid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.iccid_.Mutable(GetArenaForAllocation());
}
inline std::string* ESimProfileInfo::release_iccid() {
  // @@protoc_insertion_point(field_release:enterprise_management.ESimProfileInfo.iccid)
  if (!_internal_has_iccid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.iccid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iccid_.IsDefault()) {
    _impl_.iccid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ESimProfileInfo::set_allocated_iccid(std::string* iccid) {
  if (iccid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.iccid_.SetAllocated(iccid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iccid_.IsDefault()) {
    _impl_.iccid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ESimProfileInfo.iccid)
}

// optional string smdp_address = 2;
inline bool ESimProfileInfo::_internal_has_smdp_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ESimProfileInfo::has_smdp_address() const {
  return _internal_has_smdp_address();
}
inline void ESimProfileInfo::clear_smdp_address() {
  _impl_.smdp_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ESimProfileInfo::smdp_address() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ESimProfileInfo.smdp_address)
  return _internal_smdp_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ESimProfileInfo::set_smdp_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.smdp_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ESimProfileInfo.smdp_address)
}
inline std::string* ESimProfileInfo::mutable_smdp_address() {
  std::string* _s = _internal_mutable_smdp_address();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ESimProfileInfo.smdp_address)
  return _s;
}
inline const std::string& ESimProfileInfo::_internal_smdp_address() const {
  return _impl_.smdp_address_.Get();
}
inline void ESimProfileInfo::_internal_set_smdp_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.smdp_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ESimProfileInfo::_internal_mutable_smdp_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.smdp_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ESimProfileInfo::release_smdp_address() {
  // @@protoc_insertion_point(field_release:enterprise_management.ESimProfileInfo.smdp_address)
  if (!_internal_has_smdp_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.smdp_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smdp_address_.IsDefault()) {
    _impl_.smdp_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ESimProfileInfo::set_allocated_smdp_address(std::string* smdp_address) {
  if (smdp_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.smdp_address_.SetAllocated(smdp_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.smdp_address_.IsDefault()) {
    _impl_.smdp_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ESimProfileInfo.smdp_address)
}

// -------------------------------------------------------------------

// UploadEuiccInfoRequest

// optional uint32 euicc_count = 1;
inline bool UploadEuiccInfoRequest::_internal_has_euicc_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UploadEuiccInfoRequest::has_euicc_count() const {
  return _internal_has_euicc_count();
}
inline void UploadEuiccInfoRequest::clear_euicc_count() {
  _impl_.euicc_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t UploadEuiccInfoRequest::_internal_euicc_count() const {
  return _impl_.euicc_count_;
}
inline uint32_t UploadEuiccInfoRequest::euicc_count() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UploadEuiccInfoRequest.euicc_count)
  return _internal_euicc_count();
}
inline void UploadEuiccInfoRequest::_internal_set_euicc_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.euicc_count_ = value;
}
inline void UploadEuiccInfoRequest::set_euicc_count(uint32_t value) {
  _internal_set_euicc_count(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UploadEuiccInfoRequest.euicc_count)
}

// repeated .enterprise_management.ESimProfileInfo esim_profiles = 2;
inline int UploadEuiccInfoRequest::_internal_esim_profiles_size() const {
  return _impl_.esim_profiles_.size();
}
inline int UploadEuiccInfoRequest::esim_profiles_size() const {
  return _internal_esim_profiles_size();
}
inline void UploadEuiccInfoRequest::clear_esim_profiles() {
  _impl_.esim_profiles_.Clear();
}
inline ::enterprise_management::ESimProfileInfo* UploadEuiccInfoRequest::mutable_esim_profiles(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.UploadEuiccInfoRequest.esim_profiles)
  return _impl_.esim_profiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ESimProfileInfo >*
UploadEuiccInfoRequest::mutable_esim_profiles() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.UploadEuiccInfoRequest.esim_profiles)
  return &_impl_.esim_profiles_;
}
inline const ::enterprise_management::ESimProfileInfo& UploadEuiccInfoRequest::_internal_esim_profiles(int index) const {
  return _impl_.esim_profiles_.Get(index);
}
inline const ::enterprise_management::ESimProfileInfo& UploadEuiccInfoRequest::esim_profiles(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.UploadEuiccInfoRequest.esim_profiles)
  return _internal_esim_profiles(index);
}
inline ::enterprise_management::ESimProfileInfo* UploadEuiccInfoRequest::_internal_add_esim_profiles() {
  return _impl_.esim_profiles_.Add();
}
inline ::enterprise_management::ESimProfileInfo* UploadEuiccInfoRequest::add_esim_profiles() {
  ::enterprise_management::ESimProfileInfo* _add = _internal_add_esim_profiles();
  // @@protoc_insertion_point(field_add:enterprise_management.UploadEuiccInfoRequest.esim_profiles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ESimProfileInfo >&
UploadEuiccInfoRequest::esim_profiles() const {
  // @@protoc_insertion_point(field_list:enterprise_management.UploadEuiccInfoRequest.esim_profiles)
  return _impl_.esim_profiles_;
}

// optional bool clear_profile_list = 3;
inline bool UploadEuiccInfoRequest::_internal_has_clear_profile_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UploadEuiccInfoRequest::has_clear_profile_list() const {
  return _internal_has_clear_profile_list();
}
inline void UploadEuiccInfoRequest::clear_clear_profile_list() {
  _impl_.clear_profile_list_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UploadEuiccInfoRequest::_internal_clear_profile_list() const {
  return _impl_.clear_profile_list_;
}
inline bool UploadEuiccInfoRequest::clear_profile_list() const {
  // @@protoc_insertion_point(field_get:enterprise_management.UploadEuiccInfoRequest.clear_profile_list)
  return _internal_clear_profile_list();
}
inline void UploadEuiccInfoRequest::_internal_set_clear_profile_list(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.clear_profile_list_ = value;
}
inline void UploadEuiccInfoRequest::set_clear_profile_list(bool value) {
  _internal_set_clear_profile_list(value);
  // @@protoc_insertion_point(field_set:enterprise_management.UploadEuiccInfoRequest.clear_profile_list)
}

// -------------------------------------------------------------------

// UploadEuiccInfoResponse

// -------------------------------------------------------------------

// PrintJobEvent_PrintJobConfiguration

// optional string id = 1;
inline bool PrintJobEvent_PrintJobConfiguration::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintJobConfiguration::has_id() const {
  return _internal_has_id();
}
inline void PrintJobEvent_PrintJobConfiguration::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrintJobEvent_PrintJobConfiguration::id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintJobConfiguration.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrintJobEvent_PrintJobConfiguration::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintJobConfiguration.id)
}
inline std::string* PrintJobEvent_PrintJobConfiguration::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.PrintJobConfiguration.id)
  return _s;
}
inline const std::string& PrintJobEvent_PrintJobConfiguration::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PrintJobEvent_PrintJobConfiguration::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PrintJobEvent_PrintJobConfiguration::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PrintJobEvent_PrintJobConfiguration::release_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.PrintJobConfiguration.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrintJobEvent_PrintJobConfiguration::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.PrintJobConfiguration.id)
}

// optional string title = 2;
inline bool PrintJobEvent_PrintJobConfiguration::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintJobConfiguration::has_title() const {
  return _internal_has_title();
}
inline void PrintJobEvent_PrintJobConfiguration::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PrintJobEvent_PrintJobConfiguration::title() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintJobConfiguration.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrintJobEvent_PrintJobConfiguration::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintJobConfiguration.title)
}
inline std::string* PrintJobEvent_PrintJobConfiguration::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.PrintJobConfiguration.title)
  return _s;
}
inline const std::string& PrintJobEvent_PrintJobConfiguration::_internal_title() const {
  return _impl_.title_.Get();
}
inline void PrintJobEvent_PrintJobConfiguration::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* PrintJobEvent_PrintJobConfiguration::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* PrintJobEvent_PrintJobConfiguration::release_title() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.PrintJobConfiguration.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrintJobEvent_PrintJobConfiguration::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.PrintJobConfiguration.title)
}

// optional int32 status = 3;
inline bool PrintJobEvent_PrintJobConfiguration::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintJobConfiguration::has_status() const {
  return _internal_has_status();
}
inline void PrintJobEvent_PrintJobConfiguration::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t PrintJobEvent_PrintJobConfiguration::_internal_status() const {
  return _impl_.status_;
}
inline int32_t PrintJobEvent_PrintJobConfiguration::status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintJobConfiguration.status)
  return _internal_status();
}
inline void PrintJobEvent_PrintJobConfiguration::_internal_set_status(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_ = value;
}
inline void PrintJobEvent_PrintJobConfiguration::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintJobConfiguration.status)
}

// optional int64 creation_timestamp_ms = 4;
inline bool PrintJobEvent_PrintJobConfiguration::_internal_has_creation_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintJobConfiguration::has_creation_timestamp_ms() const {
  return _internal_has_creation_timestamp_ms();
}
inline void PrintJobEvent_PrintJobConfiguration::clear_creation_timestamp_ms() {
  _impl_.creation_timestamp_ms_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t PrintJobEvent_PrintJobConfiguration::_internal_creation_timestamp_ms() const {
  return _impl_.creation_timestamp_ms_;
}
inline int64_t PrintJobEvent_PrintJobConfiguration::creation_timestamp_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintJobConfiguration.creation_timestamp_ms)
  return _internal_creation_timestamp_ms();
}
inline void PrintJobEvent_PrintJobConfiguration::_internal_set_creation_timestamp_ms(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.creation_timestamp_ms_ = value;
}
inline void PrintJobEvent_PrintJobConfiguration::set_creation_timestamp_ms(int64_t value) {
  _internal_set_creation_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintJobConfiguration.creation_timestamp_ms)
}

// optional int64 completion_timestamp_ms = 5;
inline bool PrintJobEvent_PrintJobConfiguration::_internal_has_completion_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintJobConfiguration::has_completion_timestamp_ms() const {
  return _internal_has_completion_timestamp_ms();
}
inline void PrintJobEvent_PrintJobConfiguration::clear_completion_timestamp_ms() {
  _impl_.completion_timestamp_ms_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t PrintJobEvent_PrintJobConfiguration::_internal_completion_timestamp_ms() const {
  return _impl_.completion_timestamp_ms_;
}
inline int64_t PrintJobEvent_PrintJobConfiguration::completion_timestamp_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintJobConfiguration.completion_timestamp_ms)
  return _internal_completion_timestamp_ms();
}
inline void PrintJobEvent_PrintJobConfiguration::_internal_set_completion_timestamp_ms(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.completion_timestamp_ms_ = value;
}
inline void PrintJobEvent_PrintJobConfiguration::set_completion_timestamp_ms(int64_t value) {
  _internal_set_completion_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintJobConfiguration.completion_timestamp_ms)
}

// optional int32 number_of_pages = 6;
inline bool PrintJobEvent_PrintJobConfiguration::_internal_has_number_of_pages() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintJobConfiguration::has_number_of_pages() const {
  return _internal_has_number_of_pages();
}
inline void PrintJobEvent_PrintJobConfiguration::clear_number_of_pages() {
  _impl_.number_of_pages_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t PrintJobEvent_PrintJobConfiguration::_internal_number_of_pages() const {
  return _impl_.number_of_pages_;
}
inline int32_t PrintJobEvent_PrintJobConfiguration::number_of_pages() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintJobConfiguration.number_of_pages)
  return _internal_number_of_pages();
}
inline void PrintJobEvent_PrintJobConfiguration::_internal_set_number_of_pages(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.number_of_pages_ = value;
}
inline void PrintJobEvent_PrintJobConfiguration::set_number_of_pages(int32_t value) {
  _internal_set_number_of_pages(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintJobConfiguration.number_of_pages)
}

// optional .enterprise_management.PrintJobEvent.PrintSettings settings = 7;
inline bool PrintJobEvent_PrintJobConfiguration::_internal_has_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
  return value;
}
inline bool PrintJobEvent_PrintJobConfiguration::has_settings() const {
  return _internal_has_settings();
}
inline void PrintJobEvent_PrintJobConfiguration::clear_settings() {
  if (_impl_.settings_ != nullptr) _impl_.settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::PrintJobEvent_PrintSettings& PrintJobEvent_PrintJobConfiguration::_internal_settings() const {
  const ::enterprise_management::PrintJobEvent_PrintSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PrintJobEvent_PrintSettings&>(
      ::enterprise_management::_PrintJobEvent_PrintSettings_default_instance_);
}
inline const ::enterprise_management::PrintJobEvent_PrintSettings& PrintJobEvent_PrintJobConfiguration::settings() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintJobConfiguration.settings)
  return _internal_settings();
}
inline void PrintJobEvent_PrintJobConfiguration::unsafe_arena_set_allocated_settings(
    ::enterprise_management::PrintJobEvent_PrintSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrintJobEvent.PrintJobConfiguration.settings)
}
inline ::enterprise_management::PrintJobEvent_PrintSettings* PrintJobEvent_PrintJobConfiguration::release_settings() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::PrintJobEvent_PrintSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PrintJobEvent_PrintSettings* PrintJobEvent_PrintJobConfiguration::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.PrintJobConfiguration.settings)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::PrintJobEvent_PrintSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::enterprise_management::PrintJobEvent_PrintSettings* PrintJobEvent_PrintJobConfiguration::_internal_mutable_settings() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PrintJobEvent_PrintSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::enterprise_management::PrintJobEvent_PrintSettings* PrintJobEvent_PrintJobConfiguration::mutable_settings() {
  ::enterprise_management::PrintJobEvent_PrintSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.PrintJobConfiguration.settings)
  return _msg;
}
inline void PrintJobEvent_PrintJobConfiguration::set_allocated_settings(::enterprise_management::PrintJobEvent_PrintSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.PrintJobConfiguration.settings)
}

// -------------------------------------------------------------------

// PrintJobEvent_Printer

// optional string name = 1;
inline bool PrintJobEvent_Printer::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrintJobEvent_Printer::has_name() const {
  return _internal_has_name();
}
inline void PrintJobEvent_Printer::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrintJobEvent_Printer::name() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.Printer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrintJobEvent_Printer::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.Printer.name)
}
inline std::string* PrintJobEvent_Printer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.Printer.name)
  return _s;
}
inline const std::string& PrintJobEvent_Printer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PrintJobEvent_Printer::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PrintJobEvent_Printer::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PrintJobEvent_Printer::release_name() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.Printer.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrintJobEvent_Printer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.Printer.name)
}

// optional string uri = 2;
inline bool PrintJobEvent_Printer::_internal_has_uri() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrintJobEvent_Printer::has_uri() const {
  return _internal_has_uri();
}
inline void PrintJobEvent_Printer::clear_uri() {
  _impl_.uri_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PrintJobEvent_Printer::uri() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.Printer.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrintJobEvent_Printer::set_uri(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.Printer.uri)
}
inline std::string* PrintJobEvent_Printer::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.Printer.uri)
  return _s;
}
inline const std::string& PrintJobEvent_Printer::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void PrintJobEvent_Printer::_internal_set_uri(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* PrintJobEvent_Printer::_internal_mutable_uri() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* PrintJobEvent_Printer::release_uri() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.Printer.uri)
  if (!_internal_has_uri()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.uri_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrintJobEvent_Printer::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.Printer.uri)
}

// optional string id = 3;
inline bool PrintJobEvent_Printer::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PrintJobEvent_Printer::has_id() const {
  return _internal_has_id();
}
inline void PrintJobEvent_Printer::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PrintJobEvent_Printer::id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.Printer.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrintJobEvent_Printer::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.Printer.id)
}
inline std::string* PrintJobEvent_Printer::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.Printer.id)
  return _s;
}
inline const std::string& PrintJobEvent_Printer::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PrintJobEvent_Printer::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PrintJobEvent_Printer::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PrintJobEvent_Printer::release_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.Printer.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrintJobEvent_Printer::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.Printer.id)
}

// -------------------------------------------------------------------

// PrintJobEvent_PrintSettings_MediaSize

// optional int32 width = 1;
inline bool PrintJobEvent_PrintSettings_MediaSize::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintSettings_MediaSize::has_width() const {
  return _internal_has_width();
}
inline void PrintJobEvent_PrintSettings_MediaSize::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t PrintJobEvent_PrintSettings_MediaSize::_internal_width() const {
  return _impl_.width_;
}
inline int32_t PrintJobEvent_PrintSettings_MediaSize::width() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.width)
  return _internal_width();
}
inline void PrintJobEvent_PrintSettings_MediaSize::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.width_ = value;
}
inline void PrintJobEvent_PrintSettings_MediaSize::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.width)
}

// optional int32 height = 2;
inline bool PrintJobEvent_PrintSettings_MediaSize::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintSettings_MediaSize::has_height() const {
  return _internal_has_height();
}
inline void PrintJobEvent_PrintSettings_MediaSize::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t PrintJobEvent_PrintSettings_MediaSize::_internal_height() const {
  return _impl_.height_;
}
inline int32_t PrintJobEvent_PrintSettings_MediaSize::height() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.height)
  return _internal_height();
}
inline void PrintJobEvent_PrintSettings_MediaSize::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_ = value;
}
inline void PrintJobEvent_PrintSettings_MediaSize::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.height)
}

// optional string vendor_id = 3;
inline bool PrintJobEvent_PrintSettings_MediaSize::_internal_has_vendor_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintSettings_MediaSize::has_vendor_id() const {
  return _internal_has_vendor_id();
}
inline void PrintJobEvent_PrintSettings_MediaSize::clear_vendor_id() {
  _impl_.vendor_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrintJobEvent_PrintSettings_MediaSize::vendor_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.vendor_id)
  return _internal_vendor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrintJobEvent_PrintSettings_MediaSize::set_vendor_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vendor_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.vendor_id)
}
inline std::string* PrintJobEvent_PrintSettings_MediaSize::mutable_vendor_id() {
  std::string* _s = _internal_mutable_vendor_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.vendor_id)
  return _s;
}
inline const std::string& PrintJobEvent_PrintSettings_MediaSize::_internal_vendor_id() const {
  return _impl_.vendor_id_.Get();
}
inline void PrintJobEvent_PrintSettings_MediaSize::_internal_set_vendor_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vendor_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PrintJobEvent_PrintSettings_MediaSize::_internal_mutable_vendor_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vendor_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PrintJobEvent_PrintSettings_MediaSize::release_vendor_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.vendor_id)
  if (!_internal_has_vendor_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vendor_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_id_.IsDefault()) {
    _impl_.vendor_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrintJobEvent_PrintSettings_MediaSize::set_allocated_vendor_id(std::string* vendor_id) {
  if (vendor_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vendor_id_.SetAllocated(vendor_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_id_.IsDefault()) {
    _impl_.vendor_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.PrintSettings.MediaSize.vendor_id)
}

// -------------------------------------------------------------------

// PrintJobEvent_PrintSettings

// optional .enterprise_management.PrintJobEvent.PrintSettings.ColorMode color = 1;
inline bool PrintJobEvent_PrintSettings::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintSettings::has_color() const {
  return _internal_has_color();
}
inline void PrintJobEvent_PrintSettings::clear_color() {
  _impl_.color_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings::_internal_color() const {
  return static_cast< ::enterprise_management::PrintJobEvent_PrintSettings_ColorMode >(_impl_.color_);
}
inline ::enterprise_management::PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings::color() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintSettings.color)
  return _internal_color();
}
inline void PrintJobEvent_PrintSettings::_internal_set_color(::enterprise_management::PrintJobEvent_PrintSettings_ColorMode value) {
  assert(::enterprise_management::PrintJobEvent_PrintSettings_ColorMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.color_ = value;
}
inline void PrintJobEvent_PrintSettings::set_color(::enterprise_management::PrintJobEvent_PrintSettings_ColorMode value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintSettings.color)
}

// optional .enterprise_management.PrintJobEvent.PrintSettings.DuplexMode duplex = 2;
inline bool PrintJobEvent_PrintSettings::_internal_has_duplex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintSettings::has_duplex() const {
  return _internal_has_duplex();
}
inline void PrintJobEvent_PrintSettings::clear_duplex() {
  _impl_.duplex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings::_internal_duplex() const {
  return static_cast< ::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode >(_impl_.duplex_);
}
inline ::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings::duplex() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintSettings.duplex)
  return _internal_duplex();
}
inline void PrintJobEvent_PrintSettings::_internal_set_duplex(::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode value) {
  assert(::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.duplex_ = value;
}
inline void PrintJobEvent_PrintSettings::set_duplex(::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode value) {
  _internal_set_duplex(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintSettings.duplex)
}

// optional .enterprise_management.PrintJobEvent.PrintSettings.MediaSize media_size = 3;
inline bool PrintJobEvent_PrintSettings::_internal_has_media_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.media_size_ != nullptr);
  return value;
}
inline bool PrintJobEvent_PrintSettings::has_media_size() const {
  return _internal_has_media_size();
}
inline void PrintJobEvent_PrintSettings::clear_media_size() {
  if (_impl_.media_size_ != nullptr) _impl_.media_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize& PrintJobEvent_PrintSettings::_internal_media_size() const {
  const ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* p = _impl_.media_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize&>(
      ::enterprise_management::_PrintJobEvent_PrintSettings_MediaSize_default_instance_);
}
inline const ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize& PrintJobEvent_PrintSettings::media_size() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintSettings.media_size)
  return _internal_media_size();
}
inline void PrintJobEvent_PrintSettings::unsafe_arena_set_allocated_media_size(
    ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* media_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.media_size_);
  }
  _impl_.media_size_ = media_size;
  if (media_size) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrintJobEvent.PrintSettings.media_size)
}
inline ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* PrintJobEvent_PrintSettings::release_media_size() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* temp = _impl_.media_size_;
  _impl_.media_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* PrintJobEvent_PrintSettings::unsafe_arena_release_media_size() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.PrintSettings.media_size)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* temp = _impl_.media_size_;
  _impl_.media_size_ = nullptr;
  return temp;
}
inline ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* PrintJobEvent_PrintSettings::_internal_mutable_media_size() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.media_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PrintJobEvent_PrintSettings_MediaSize>(GetArenaForAllocation());
    _impl_.media_size_ = p;
  }
  return _impl_.media_size_;
}
inline ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* PrintJobEvent_PrintSettings::mutable_media_size() {
  ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* _msg = _internal_mutable_media_size();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.PrintSettings.media_size)
  return _msg;
}
inline void PrintJobEvent_PrintSettings::set_allocated_media_size(::enterprise_management::PrintJobEvent_PrintSettings_MediaSize* media_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.media_size_;
  }
  if (media_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(media_size);
    if (message_arena != submessage_arena) {
      media_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, media_size, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.media_size_ = media_size;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.PrintSettings.media_size)
}

// optional int32 copies = 4;
inline bool PrintJobEvent_PrintSettings::_internal_has_copies() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PrintJobEvent_PrintSettings::has_copies() const {
  return _internal_has_copies();
}
inline void PrintJobEvent_PrintSettings::clear_copies() {
  _impl_.copies_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t PrintJobEvent_PrintSettings::_internal_copies() const {
  return _impl_.copies_;
}
inline int32_t PrintJobEvent_PrintSettings::copies() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.PrintSettings.copies)
  return _internal_copies();
}
inline void PrintJobEvent_PrintSettings::_internal_set_copies(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.copies_ = value;
}
inline void PrintJobEvent_PrintSettings::set_copies(int32_t value) {
  _internal_set_copies(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.PrintSettings.copies)
}

// -------------------------------------------------------------------

// PrintJobEvent

// optional .enterprise_management.PrintJobEvent.PrintJobConfiguration job_configuration = 1;
inline bool PrintJobEvent::_internal_has_job_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.job_configuration_ != nullptr);
  return value;
}
inline bool PrintJobEvent::has_job_configuration() const {
  return _internal_has_job_configuration();
}
inline void PrintJobEvent::clear_job_configuration() {
  if (_impl_.job_configuration_ != nullptr) _impl_.job_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::PrintJobEvent_PrintJobConfiguration& PrintJobEvent::_internal_job_configuration() const {
  const ::enterprise_management::PrintJobEvent_PrintJobConfiguration* p = _impl_.job_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PrintJobEvent_PrintJobConfiguration&>(
      ::enterprise_management::_PrintJobEvent_PrintJobConfiguration_default_instance_);
}
inline const ::enterprise_management::PrintJobEvent_PrintJobConfiguration& PrintJobEvent::job_configuration() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.job_configuration)
  return _internal_job_configuration();
}
inline void PrintJobEvent::unsafe_arena_set_allocated_job_configuration(
    ::enterprise_management::PrintJobEvent_PrintJobConfiguration* job_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_configuration_);
  }
  _impl_.job_configuration_ = job_configuration;
  if (job_configuration) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrintJobEvent.job_configuration)
}
inline ::enterprise_management::PrintJobEvent_PrintJobConfiguration* PrintJobEvent::release_job_configuration() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PrintJobEvent_PrintJobConfiguration* temp = _impl_.job_configuration_;
  _impl_.job_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PrintJobEvent_PrintJobConfiguration* PrintJobEvent::unsafe_arena_release_job_configuration() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.job_configuration)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::PrintJobEvent_PrintJobConfiguration* temp = _impl_.job_configuration_;
  _impl_.job_configuration_ = nullptr;
  return temp;
}
inline ::enterprise_management::PrintJobEvent_PrintJobConfiguration* PrintJobEvent::_internal_mutable_job_configuration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.job_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PrintJobEvent_PrintJobConfiguration>(GetArenaForAllocation());
    _impl_.job_configuration_ = p;
  }
  return _impl_.job_configuration_;
}
inline ::enterprise_management::PrintJobEvent_PrintJobConfiguration* PrintJobEvent::mutable_job_configuration() {
  ::enterprise_management::PrintJobEvent_PrintJobConfiguration* _msg = _internal_mutable_job_configuration();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.job_configuration)
  return _msg;
}
inline void PrintJobEvent::set_allocated_job_configuration(::enterprise_management::PrintJobEvent_PrintJobConfiguration* job_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_configuration_;
  }
  if (job_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job_configuration);
    if (message_arena != submessage_arena) {
      job_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job_configuration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.job_configuration_ = job_configuration;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.job_configuration)
}

// optional .enterprise_management.PrintJobEvent.UserType user_type = 2;
inline bool PrintJobEvent::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PrintJobEvent::has_user_type() const {
  return _internal_has_user_type();
}
inline void PrintJobEvent::clear_user_type() {
  _impl_.user_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::PrintJobEvent_UserType PrintJobEvent::_internal_user_type() const {
  return static_cast< ::enterprise_management::PrintJobEvent_UserType >(_impl_.user_type_);
}
inline ::enterprise_management::PrintJobEvent_UserType PrintJobEvent::user_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.user_type)
  return _internal_user_type();
}
inline void PrintJobEvent::_internal_set_user_type(::enterprise_management::PrintJobEvent_UserType value) {
  assert(::enterprise_management::PrintJobEvent_UserType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.user_type_ = value;
}
inline void PrintJobEvent::set_user_type(::enterprise_management::PrintJobEvent_UserType value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.PrintJobEvent.user_type)
}

// optional .enterprise_management.PrintJobEvent.Printer printer = 3;
inline bool PrintJobEvent::_internal_has_printer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.printer_ != nullptr);
  return value;
}
inline bool PrintJobEvent::has_printer() const {
  return _internal_has_printer();
}
inline void PrintJobEvent::clear_printer() {
  if (_impl_.printer_ != nullptr) _impl_.printer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::PrintJobEvent_Printer& PrintJobEvent::_internal_printer() const {
  const ::enterprise_management::PrintJobEvent_Printer* p = _impl_.printer_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PrintJobEvent_Printer&>(
      ::enterprise_management::_PrintJobEvent_Printer_default_instance_);
}
inline const ::enterprise_management::PrintJobEvent_Printer& PrintJobEvent::printer() const {
  // @@protoc_insertion_point(field_get:enterprise_management.PrintJobEvent.printer)
  return _internal_printer();
}
inline void PrintJobEvent::unsafe_arena_set_allocated_printer(
    ::enterprise_management::PrintJobEvent_Printer* printer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.printer_);
  }
  _impl_.printer_ = printer;
  if (printer) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.PrintJobEvent.printer)
}
inline ::enterprise_management::PrintJobEvent_Printer* PrintJobEvent::release_printer() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::PrintJobEvent_Printer* temp = _impl_.printer_;
  _impl_.printer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PrintJobEvent_Printer* PrintJobEvent::unsafe_arena_release_printer() {
  // @@protoc_insertion_point(field_release:enterprise_management.PrintJobEvent.printer)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::PrintJobEvent_Printer* temp = _impl_.printer_;
  _impl_.printer_ = nullptr;
  return temp;
}
inline ::enterprise_management::PrintJobEvent_Printer* PrintJobEvent::_internal_mutable_printer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.printer_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PrintJobEvent_Printer>(GetArenaForAllocation());
    _impl_.printer_ = p;
  }
  return _impl_.printer_;
}
inline ::enterprise_management::PrintJobEvent_Printer* PrintJobEvent::mutable_printer() {
  ::enterprise_management::PrintJobEvent_Printer* _msg = _internal_mutable_printer();
  // @@protoc_insertion_point(field_mutable:enterprise_management.PrintJobEvent.printer)
  return _msg;
}
inline void PrintJobEvent::set_allocated_printer(::enterprise_management::PrintJobEvent_Printer* printer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.printer_;
  }
  if (printer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(printer);
    if (message_arena != submessage_arena) {
      printer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, printer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.printer_ = printer;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.PrintJobEvent.printer)
}

// -------------------------------------------------------------------

// App

// optional string app_id = 1;
inline bool App::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool App::has_app_id() const {
  return _internal_has_app_id();
}
inline void App::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& App::app_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.App.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_app_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.App.app_id)
}
inline std::string* App::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.App.app_id)
  return _s;
}
inline const std::string& App::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void App::_internal_set_app_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_app_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_app_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.App.app_id)
  if (!_internal_has_app_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void App::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.App.app_id)
}

// optional .enterprise_management.App.AppType app_type = 2;
inline bool App::_internal_has_app_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool App::has_app_type() const {
  return _internal_has_app_type();
}
inline void App::clear_app_type() {
  _impl_.app_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_management::App_AppType App::_internal_app_type() const {
  return static_cast< ::enterprise_management::App_AppType >(_impl_.app_type_);
}
inline ::enterprise_management::App_AppType App::app_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.App.app_type)
  return _internal_app_type();
}
inline void App::_internal_set_app_type(::enterprise_management::App_AppType value) {
  assert(::enterprise_management::App_AppType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_type_ = value;
}
inline void App::set_app_type(::enterprise_management::App_AppType value) {
  _internal_set_app_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.App.app_type)
}

// repeated string additional_app_id = 3;
inline int App::_internal_additional_app_id_size() const {
  return _impl_.additional_app_id_.size();
}
inline int App::additional_app_id_size() const {
  return _internal_additional_app_id_size();
}
inline void App::clear_additional_app_id() {
  _impl_.additional_app_id_.Clear();
}
inline std::string* App::add_additional_app_id() {
  std::string* _s = _internal_add_additional_app_id();
  // @@protoc_insertion_point(field_add_mutable:enterprise_management.App.additional_app_id)
  return _s;
}
inline const std::string& App::_internal_additional_app_id(int index) const {
  return _impl_.additional_app_id_.Get(index);
}
inline const std::string& App::additional_app_id(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.App.additional_app_id)
  return _internal_additional_app_id(index);
}
inline std::string* App::mutable_additional_app_id(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.App.additional_app_id)
  return _impl_.additional_app_id_.Mutable(index);
}
inline void App::set_additional_app_id(int index, const std::string& value) {
  _impl_.additional_app_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:enterprise_management.App.additional_app_id)
}
inline void App::set_additional_app_id(int index, std::string&& value) {
  _impl_.additional_app_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:enterprise_management.App.additional_app_id)
}
inline void App::set_additional_app_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.additional_app_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:enterprise_management.App.additional_app_id)
}
inline void App::set_additional_app_id(int index, const char* value, size_t size) {
  _impl_.additional_app_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:enterprise_management.App.additional_app_id)
}
inline std::string* App::_internal_add_additional_app_id() {
  return _impl_.additional_app_id_.Add();
}
inline void App::add_additional_app_id(const std::string& value) {
  _impl_.additional_app_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:enterprise_management.App.additional_app_id)
}
inline void App::add_additional_app_id(std::string&& value) {
  _impl_.additional_app_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:enterprise_management.App.additional_app_id)
}
inline void App::add_additional_app_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.additional_app_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:enterprise_management.App.additional_app_id)
}
inline void App::add_additional_app_id(const char* value, size_t size) {
  _impl_.additional_app_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:enterprise_management.App.additional_app_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
App::additional_app_id() const {
  // @@protoc_insertion_point(field_list:enterprise_management.App.additional_app_id)
  return _impl_.additional_app_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
App::mutable_additional_app_id() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.App.additional_app_id)
  return &_impl_.additional_app_id_;
}

// -------------------------------------------------------------------

// AppActivity

// optional .enterprise_management.App app_info = 1;
inline bool AppActivity::_internal_has_app_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_info_ != nullptr);
  return value;
}
inline bool AppActivity::has_app_info() const {
  return _internal_has_app_info();
}
inline void AppActivity::clear_app_info() {
  if (_impl_.app_info_ != nullptr) _impl_.app_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::App& AppActivity::_internal_app_info() const {
  const ::enterprise_management::App* p = _impl_.app_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::App&>(
      ::enterprise_management::_App_default_instance_);
}
inline const ::enterprise_management::App& AppActivity::app_info() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppActivity.app_info)
  return _internal_app_info();
}
inline void AppActivity::unsafe_arena_set_allocated_app_info(
    ::enterprise_management::App* app_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_info_);
  }
  _impl_.app_info_ = app_info;
  if (app_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.AppActivity.app_info)
}
inline ::enterprise_management::App* AppActivity::release_app_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::App* temp = _impl_.app_info_;
  _impl_.app_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::App* AppActivity::unsafe_arena_release_app_info() {
  // @@protoc_insertion_point(field_release:enterprise_management.AppActivity.app_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::App* temp = _impl_.app_info_;
  _impl_.app_info_ = nullptr;
  return temp;
}
inline ::enterprise_management::App* AppActivity::_internal_mutable_app_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.app_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::App>(GetArenaForAllocation());
    _impl_.app_info_ = p;
  }
  return _impl_.app_info_;
}
inline ::enterprise_management::App* AppActivity::mutable_app_info() {
  ::enterprise_management::App* _msg = _internal_mutable_app_info();
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppActivity.app_info)
  return _msg;
}
inline void AppActivity::set_allocated_app_info(::enterprise_management::App* app_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_info_;
  }
  if (app_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_info);
    if (message_arena != submessage_arena) {
      app_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_info_ = app_info;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.AppActivity.app_info)
}

// repeated .enterprise_management.TimePeriod active_time_periods = 2;
inline int AppActivity::_internal_active_time_periods_size() const {
  return _impl_.active_time_periods_.size();
}
inline int AppActivity::active_time_periods_size() const {
  return _internal_active_time_periods_size();
}
inline void AppActivity::clear_active_time_periods() {
  _impl_.active_time_periods_.Clear();
}
inline ::enterprise_management::TimePeriod* AppActivity::mutable_active_time_periods(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.AppActivity.active_time_periods)
  return _impl_.active_time_periods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >*
AppActivity::mutable_active_time_periods() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.AppActivity.active_time_periods)
  return &_impl_.active_time_periods_;
}
inline const ::enterprise_management::TimePeriod& AppActivity::_internal_active_time_periods(int index) const {
  return _impl_.active_time_periods_.Get(index);
}
inline const ::enterprise_management::TimePeriod& AppActivity::active_time_periods(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppActivity.active_time_periods)
  return _internal_active_time_periods(index);
}
inline ::enterprise_management::TimePeriod* AppActivity::_internal_add_active_time_periods() {
  return _impl_.active_time_periods_.Add();
}
inline ::enterprise_management::TimePeriod* AppActivity::add_active_time_periods() {
  ::enterprise_management::TimePeriod* _add = _internal_add_active_time_periods();
  // @@protoc_insertion_point(field_add:enterprise_management.AppActivity.active_time_periods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::TimePeriod >&
AppActivity::active_time_periods() const {
  // @@protoc_insertion_point(field_list:enterprise_management.AppActivity.active_time_periods)
  return _impl_.active_time_periods_;
}

// optional int64 populated_at = 3;
inline bool AppActivity::_internal_has_populated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppActivity::has_populated_at() const {
  return _internal_has_populated_at();
}
inline void AppActivity::clear_populated_at() {
  _impl_.populated_at_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t AppActivity::_internal_populated_at() const {
  return _impl_.populated_at_;
}
inline int64_t AppActivity::populated_at() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppActivity.populated_at)
  return _internal_populated_at();
}
inline void AppActivity::_internal_set_populated_at(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.populated_at_ = value;
}
inline void AppActivity::set_populated_at(int64_t value) {
  _internal_set_populated_at(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppActivity.populated_at)
}

// optional .enterprise_management.AppActivity.AppState app_state = 4;
inline bool AppActivity::_internal_has_app_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AppActivity::has_app_state() const {
  return _internal_has_app_state();
}
inline void AppActivity::clear_app_state() {
  _impl_.app_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::AppActivity_AppState AppActivity::_internal_app_state() const {
  return static_cast< ::enterprise_management::AppActivity_AppState >(_impl_.app_state_);
}
inline ::enterprise_management::AppActivity_AppState AppActivity::app_state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.AppActivity.app_state)
  return _internal_app_state();
}
inline void AppActivity::_internal_set_app_state(::enterprise_management::AppActivity_AppState value) {
  assert(::enterprise_management::AppActivity_AppState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_state_ = value;
}
inline void AppActivity::set_app_state(::enterprise_management::AppActivity_AppState value) {
  _internal_set_app_state(value);
  // @@protoc_insertion_point(field_set:enterprise_management.AppActivity.app_state)
}

// -------------------------------------------------------------------

// ScreenTimeSpan

// optional .enterprise_management.TimePeriod time_period = 1;
inline bool ScreenTimeSpan::_internal_has_time_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_period_ != nullptr);
  return value;
}
inline bool ScreenTimeSpan::has_time_period() const {
  return _internal_has_time_period();
}
inline void ScreenTimeSpan::clear_time_period() {
  if (_impl_.time_period_ != nullptr) _impl_.time_period_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::TimePeriod& ScreenTimeSpan::_internal_time_period() const {
  const ::enterprise_management::TimePeriod* p = _impl_.time_period_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::TimePeriod&>(
      ::enterprise_management::_TimePeriod_default_instance_);
}
inline const ::enterprise_management::TimePeriod& ScreenTimeSpan::time_period() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ScreenTimeSpan.time_period)
  return _internal_time_period();
}
inline void ScreenTimeSpan::unsafe_arena_set_allocated_time_period(
    ::enterprise_management::TimePeriod* time_period) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_period_);
  }
  _impl_.time_period_ = time_period;
  if (time_period) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ScreenTimeSpan.time_period)
}
inline ::enterprise_management::TimePeriod* ScreenTimeSpan::release_time_period() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::TimePeriod* temp = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::TimePeriod* ScreenTimeSpan::unsafe_arena_release_time_period() {
  // @@protoc_insertion_point(field_release:enterprise_management.ScreenTimeSpan.time_period)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::TimePeriod* temp = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
  return temp;
}
inline ::enterprise_management::TimePeriod* ScreenTimeSpan::_internal_mutable_time_period() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.time_period_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::TimePeriod>(GetArenaForAllocation());
    _impl_.time_period_ = p;
  }
  return _impl_.time_period_;
}
inline ::enterprise_management::TimePeriod* ScreenTimeSpan::mutable_time_period() {
  ::enterprise_management::TimePeriod* _msg = _internal_mutable_time_period();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ScreenTimeSpan.time_period)
  return _msg;
}
inline void ScreenTimeSpan::set_allocated_time_period(::enterprise_management::TimePeriod* time_period) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_period_;
  }
  if (time_period) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time_period);
    if (message_arena != submessage_arena) {
      time_period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_period, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.time_period_ = time_period;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ScreenTimeSpan.time_period)
}

// optional int64 active_duration_ms = 2;
inline bool ScreenTimeSpan::_internal_has_active_duration_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScreenTimeSpan::has_active_duration_ms() const {
  return _internal_has_active_duration_ms();
}
inline void ScreenTimeSpan::clear_active_duration_ms() {
  _impl_.active_duration_ms_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t ScreenTimeSpan::_internal_active_duration_ms() const {
  return _impl_.active_duration_ms_;
}
inline int64_t ScreenTimeSpan::active_duration_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ScreenTimeSpan.active_duration_ms)
  return _internal_active_duration_ms();
}
inline void ScreenTimeSpan::_internal_set_active_duration_ms(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.active_duration_ms_ = value;
}
inline void ScreenTimeSpan::set_active_duration_ms(int64_t value) {
  _internal_set_active_duration_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ScreenTimeSpan.active_duration_ms)
}

// -------------------------------------------------------------------

// ChildStatusReportRequest

// optional string user_dm_token = 1;
inline bool ChildStatusReportRequest::_internal_has_user_dm_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChildStatusReportRequest::has_user_dm_token() const {
  return _internal_has_user_dm_token();
}
inline void ChildStatusReportRequest::clear_user_dm_token() {
  _impl_.user_dm_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChildStatusReportRequest::user_dm_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.user_dm_token)
  return _internal_user_dm_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChildStatusReportRequest::set_user_dm_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_dm_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.user_dm_token)
}
inline std::string* ChildStatusReportRequest::mutable_user_dm_token() {
  std::string* _s = _internal_mutable_user_dm_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.user_dm_token)
  return _s;
}
inline const std::string& ChildStatusReportRequest::_internal_user_dm_token() const {
  return _impl_.user_dm_token_.Get();
}
inline void ChildStatusReportRequest::_internal_set_user_dm_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ChildStatusReportRequest::_internal_mutable_user_dm_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ChildStatusReportRequest::release_user_dm_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.user_dm_token)
  if (!_internal_has_user_dm_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_dm_token_.IsDefault()) {
    _impl_.user_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChildStatusReportRequest::set_allocated_user_dm_token(std::string* user_dm_token) {
  if (user_dm_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_dm_token_.SetAllocated(user_dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_dm_token_.IsDefault()) {
    _impl_.user_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.user_dm_token)
}

// optional int64 timestamp_ms = 2;
inline bool ChildStatusReportRequest::_internal_has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChildStatusReportRequest::has_timestamp_ms() const {
  return _internal_has_timestamp_ms();
}
inline void ChildStatusReportRequest::clear_timestamp_ms() {
  _impl_.timestamp_ms_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t ChildStatusReportRequest::_internal_timestamp_ms() const {
  return _impl_.timestamp_ms_;
}
inline int64_t ChildStatusReportRequest::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void ChildStatusReportRequest::_internal_set_timestamp_ms(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.timestamp_ms_ = value;
}
inline void ChildStatusReportRequest::set_timestamp_ms(int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.timestamp_ms)
}

// optional string time_zone = 3;
inline bool ChildStatusReportRequest::_internal_has_time_zone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChildStatusReportRequest::has_time_zone() const {
  return _internal_has_time_zone();
}
inline void ChildStatusReportRequest::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChildStatusReportRequest::time_zone() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChildStatusReportRequest::set_time_zone(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.time_zone)
}
inline std::string* ChildStatusReportRequest::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.time_zone)
  return _s;
}
inline const std::string& ChildStatusReportRequest::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void ChildStatusReportRequest::_internal_set_time_zone(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* ChildStatusReportRequest::_internal_mutable_time_zone() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* ChildStatusReportRequest::release_time_zone() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.time_zone)
  if (!_internal_has_time_zone()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.time_zone_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChildStatusReportRequest::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.time_zone)
}

// repeated .enterprise_management.ScreenTimeSpan screen_time_span = 4;
inline int ChildStatusReportRequest::_internal_screen_time_span_size() const {
  return _impl_.screen_time_span_.size();
}
inline int ChildStatusReportRequest::screen_time_span_size() const {
  return _internal_screen_time_span_size();
}
inline void ChildStatusReportRequest::clear_screen_time_span() {
  _impl_.screen_time_span_.Clear();
}
inline ::enterprise_management::ScreenTimeSpan* ChildStatusReportRequest::mutable_screen_time_span(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.screen_time_span)
  return _impl_.screen_time_span_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan >*
ChildStatusReportRequest::mutable_screen_time_span() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChildStatusReportRequest.screen_time_span)
  return &_impl_.screen_time_span_;
}
inline const ::enterprise_management::ScreenTimeSpan& ChildStatusReportRequest::_internal_screen_time_span(int index) const {
  return _impl_.screen_time_span_.Get(index);
}
inline const ::enterprise_management::ScreenTimeSpan& ChildStatusReportRequest::screen_time_span(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.screen_time_span)
  return _internal_screen_time_span(index);
}
inline ::enterprise_management::ScreenTimeSpan* ChildStatusReportRequest::_internal_add_screen_time_span() {
  return _impl_.screen_time_span_.Add();
}
inline ::enterprise_management::ScreenTimeSpan* ChildStatusReportRequest::add_screen_time_span() {
  ::enterprise_management::ScreenTimeSpan* _add = _internal_add_screen_time_span();
  // @@protoc_insertion_point(field_add:enterprise_management.ChildStatusReportRequest.screen_time_span)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::ScreenTimeSpan >&
ChildStatusReportRequest::screen_time_span() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChildStatusReportRequest.screen_time_span)
  return _impl_.screen_time_span_;
}

// optional .enterprise_management.AndroidStatus android_status = 5;
inline bool ChildStatusReportRequest::_internal_has_android_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.android_status_ != nullptr);
  return value;
}
inline bool ChildStatusReportRequest::has_android_status() const {
  return _internal_has_android_status();
}
inline void ChildStatusReportRequest::clear_android_status() {
  if (_impl_.android_status_ != nullptr) _impl_.android_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::AndroidStatus& ChildStatusReportRequest::_internal_android_status() const {
  const ::enterprise_management::AndroidStatus* p = _impl_.android_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AndroidStatus&>(
      ::enterprise_management::_AndroidStatus_default_instance_);
}
inline const ::enterprise_management::AndroidStatus& ChildStatusReportRequest::android_status() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.android_status)
  return _internal_android_status();
}
inline void ChildStatusReportRequest::unsafe_arena_set_allocated_android_status(
    ::enterprise_management::AndroidStatus* android_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.android_status_);
  }
  _impl_.android_status_ = android_status;
  if (android_status) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ChildStatusReportRequest.android_status)
}
inline ::enterprise_management::AndroidStatus* ChildStatusReportRequest::release_android_status() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::AndroidStatus* temp = _impl_.android_status_;
  _impl_.android_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AndroidStatus* ChildStatusReportRequest::unsafe_arena_release_android_status() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.android_status)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::AndroidStatus* temp = _impl_.android_status_;
  _impl_.android_status_ = nullptr;
  return temp;
}
inline ::enterprise_management::AndroidStatus* ChildStatusReportRequest::_internal_mutable_android_status() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.android_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AndroidStatus>(GetArenaForAllocation());
    _impl_.android_status_ = p;
  }
  return _impl_.android_status_;
}
inline ::enterprise_management::AndroidStatus* ChildStatusReportRequest::mutable_android_status() {
  ::enterprise_management::AndroidStatus* _msg = _internal_mutable_android_status();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.android_status)
  return _msg;
}
inline void ChildStatusReportRequest::set_allocated_android_status(::enterprise_management::AndroidStatus* android_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.android_status_;
  }
  if (android_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(android_status);
    if (message_arena != submessage_arena) {
      android_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, android_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.android_status_ = android_status;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.android_status)
}

// optional string os_version = 6;
inline bool ChildStatusReportRequest::_internal_has_os_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChildStatusReportRequest::has_os_version() const {
  return _internal_has_os_version();
}
inline void ChildStatusReportRequest::clear_os_version() {
  _impl_.os_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ChildStatusReportRequest::os_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.os_version)
  return _internal_os_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChildStatusReportRequest::set_os_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.os_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.os_version)
}
inline std::string* ChildStatusReportRequest::mutable_os_version() {
  std::string* _s = _internal_mutable_os_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.os_version)
  return _s;
}
inline const std::string& ChildStatusReportRequest::_internal_os_version() const {
  return _impl_.os_version_.Get();
}
inline void ChildStatusReportRequest::_internal_set_os_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.os_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ChildStatusReportRequest::_internal_mutable_os_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.os_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ChildStatusReportRequest::release_os_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.os_version)
  if (!_internal_has_os_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.os_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChildStatusReportRequest::set_allocated_os_version(std::string* os_version) {
  if (os_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.os_version_.SetAllocated(os_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.os_version)
}

// optional string boot_mode = 7;
inline bool ChildStatusReportRequest::_internal_has_boot_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChildStatusReportRequest::has_boot_mode() const {
  return _internal_has_boot_mode();
}
inline void ChildStatusReportRequest::clear_boot_mode() {
  _impl_.boot_mode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ChildStatusReportRequest::boot_mode() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.boot_mode)
  return _internal_boot_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChildStatusReportRequest::set_boot_mode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.boot_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportRequest.boot_mode)
}
inline std::string* ChildStatusReportRequest::mutable_boot_mode() {
  std::string* _s = _internal_mutable_boot_mode();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.boot_mode)
  return _s;
}
inline const std::string& ChildStatusReportRequest::_internal_boot_mode() const {
  return _impl_.boot_mode_.Get();
}
inline void ChildStatusReportRequest::_internal_set_boot_mode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.boot_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* ChildStatusReportRequest::_internal_mutable_boot_mode() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.boot_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* ChildStatusReportRequest::release_boot_mode() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportRequest.boot_mode)
  if (!_internal_has_boot_mode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.boot_mode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boot_mode_.IsDefault()) {
    _impl_.boot_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChildStatusReportRequest::set_allocated_boot_mode(std::string* boot_mode) {
  if (boot_mode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.boot_mode_.SetAllocated(boot_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boot_mode_.IsDefault()) {
    _impl_.boot_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportRequest.boot_mode)
}

// repeated .enterprise_management.AppActivity app_activity = 8;
inline int ChildStatusReportRequest::_internal_app_activity_size() const {
  return _impl_.app_activity_.size();
}
inline int ChildStatusReportRequest::app_activity_size() const {
  return _internal_app_activity_size();
}
inline void ChildStatusReportRequest::clear_app_activity() {
  _impl_.app_activity_.Clear();
}
inline ::enterprise_management::AppActivity* ChildStatusReportRequest::mutable_app_activity(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.app_activity)
  return _impl_.app_activity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity >*
ChildStatusReportRequest::mutable_app_activity() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChildStatusReportRequest.app_activity)
  return &_impl_.app_activity_;
}
inline const ::enterprise_management::AppActivity& ChildStatusReportRequest::_internal_app_activity(int index) const {
  return _impl_.app_activity_.Get(index);
}
inline const ::enterprise_management::AppActivity& ChildStatusReportRequest::app_activity(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.app_activity)
  return _internal_app_activity(index);
}
inline ::enterprise_management::AppActivity* ChildStatusReportRequest::_internal_add_app_activity() {
  return _impl_.app_activity_.Add();
}
inline ::enterprise_management::AppActivity* ChildStatusReportRequest::add_app_activity() {
  ::enterprise_management::AppActivity* _add = _internal_add_app_activity();
  // @@protoc_insertion_point(field_add:enterprise_management.ChildStatusReportRequest.app_activity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::AppActivity >&
ChildStatusReportRequest::app_activity() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChildStatusReportRequest.app_activity)
  return _impl_.app_activity_;
}

// repeated .enterprise_management.App hidden_app = 9;
inline int ChildStatusReportRequest::_internal_hidden_app_size() const {
  return _impl_.hidden_app_.size();
}
inline int ChildStatusReportRequest::hidden_app_size() const {
  return _internal_hidden_app_size();
}
inline void ChildStatusReportRequest::clear_hidden_app() {
  _impl_.hidden_app_.Clear();
}
inline ::enterprise_management::App* ChildStatusReportRequest::mutable_hidden_app(int index) {
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportRequest.hidden_app)
  return _impl_.hidden_app_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::App >*
ChildStatusReportRequest::mutable_hidden_app() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.ChildStatusReportRequest.hidden_app)
  return &_impl_.hidden_app_;
}
inline const ::enterprise_management::App& ChildStatusReportRequest::_internal_hidden_app(int index) const {
  return _impl_.hidden_app_.Get(index);
}
inline const ::enterprise_management::App& ChildStatusReportRequest::hidden_app(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportRequest.hidden_app)
  return _internal_hidden_app(index);
}
inline ::enterprise_management::App* ChildStatusReportRequest::_internal_add_hidden_app() {
  return _impl_.hidden_app_.Add();
}
inline ::enterprise_management::App* ChildStatusReportRequest::add_hidden_app() {
  ::enterprise_management::App* _add = _internal_add_hidden_app();
  // @@protoc_insertion_point(field_add:enterprise_management.ChildStatusReportRequest.hidden_app)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::enterprise_management::App >&
ChildStatusReportRequest::hidden_app() const {
  // @@protoc_insertion_point(field_list:enterprise_management.ChildStatusReportRequest.hidden_app)
  return _impl_.hidden_app_;
}

// -------------------------------------------------------------------

// ChildStatusReportResponse

// optional int32 error_code = 1;
inline bool ChildStatusReportResponse::_internal_has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChildStatusReportResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void ChildStatusReportResponse::clear_error_code() {
  _impl_.error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ChildStatusReportResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t ChildStatusReportResponse::error_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportResponse.error_code)
  return _internal_error_code();
}
inline void ChildStatusReportResponse::_internal_set_error_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_code_ = value;
}
inline void ChildStatusReportResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportResponse.error_code)
}

// optional string error_message = 2;
inline bool ChildStatusReportResponse::_internal_has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChildStatusReportResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void ChildStatusReportResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChildStatusReportResponse::error_message() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ChildStatusReportResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChildStatusReportResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ChildStatusReportResponse.error_message)
}
inline std::string* ChildStatusReportResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ChildStatusReportResponse.error_message)
  return _s;
}
inline const std::string& ChildStatusReportResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ChildStatusReportResponse::_internal_set_error_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ChildStatusReportResponse::_internal_mutable_error_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ChildStatusReportResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:enterprise_management.ChildStatusReportResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChildStatusReportResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ChildStatusReportResponse.error_message)
}

// -------------------------------------------------------------------

// StartCsrRequest

// -------------------------------------------------------------------

// StartCsrResponse

// optional string invalidation_topic = 1;
inline bool StartCsrResponse::_internal_has_invalidation_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StartCsrResponse::has_invalidation_topic() const {
  return _internal_has_invalidation_topic();
}
inline void StartCsrResponse::clear_invalidation_topic() {
  _impl_.invalidation_topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StartCsrResponse::invalidation_topic() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.invalidation_topic)
  return _internal_invalidation_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartCsrResponse::set_invalidation_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.invalidation_topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.invalidation_topic)
}
inline std::string* StartCsrResponse::mutable_invalidation_topic() {
  std::string* _s = _internal_mutable_invalidation_topic();
  // @@protoc_insertion_point(field_mutable:enterprise_management.StartCsrResponse.invalidation_topic)
  return _s;
}
inline const std::string& StartCsrResponse::_internal_invalidation_topic() const {
  return _impl_.invalidation_topic_.Get();
}
inline void StartCsrResponse::_internal_set_invalidation_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.invalidation_topic_.Set(value, GetArenaForAllocation());
}
inline std::string* StartCsrResponse::_internal_mutable_invalidation_topic() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.invalidation_topic_.Mutable(GetArenaForAllocation());
}
inline std::string* StartCsrResponse::release_invalidation_topic() {
  // @@protoc_insertion_point(field_release:enterprise_management.StartCsrResponse.invalidation_topic)
  if (!_internal_has_invalidation_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.invalidation_topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invalidation_topic_.IsDefault()) {
    _impl_.invalidation_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StartCsrResponse::set_allocated_invalidation_topic(std::string* invalidation_topic) {
  if (invalidation_topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.invalidation_topic_.SetAllocated(invalidation_topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invalidation_topic_.IsDefault()) {
    _impl_.invalidation_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.StartCsrResponse.invalidation_topic)
}

// optional bytes va_challenge = 2;
inline bool StartCsrResponse::_internal_has_va_challenge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StartCsrResponse::has_va_challenge() const {
  return _internal_has_va_challenge();
}
inline void StartCsrResponse::clear_va_challenge() {
  _impl_.va_challenge_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StartCsrResponse::va_challenge() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.va_challenge)
  return _internal_va_challenge();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartCsrResponse::set_va_challenge(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.va_challenge_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.va_challenge)
}
inline std::string* StartCsrResponse::mutable_va_challenge() {
  std::string* _s = _internal_mutable_va_challenge();
  // @@protoc_insertion_point(field_mutable:enterprise_management.StartCsrResponse.va_challenge)
  return _s;
}
inline const std::string& StartCsrResponse::_internal_va_challenge() const {
  return _impl_.va_challenge_.Get();
}
inline void StartCsrResponse::_internal_set_va_challenge(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.va_challenge_.Set(value, GetArenaForAllocation());
}
inline std::string* StartCsrResponse::_internal_mutable_va_challenge() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.va_challenge_.Mutable(GetArenaForAllocation());
}
inline std::string* StartCsrResponse::release_va_challenge() {
  // @@protoc_insertion_point(field_release:enterprise_management.StartCsrResponse.va_challenge)
  if (!_internal_has_va_challenge()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.va_challenge_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.va_challenge_.IsDefault()) {
    _impl_.va_challenge_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StartCsrResponse::set_allocated_va_challenge(std::string* va_challenge) {
  if (va_challenge != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.va_challenge_.SetAllocated(va_challenge, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.va_challenge_.IsDefault()) {
    _impl_.va_challenge_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.StartCsrResponse.va_challenge)
}

// optional .enterprise_management.HashingAlgorithm hashing_algorithm = 5;
inline bool StartCsrResponse::_internal_has_hashing_algorithm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StartCsrResponse::has_hashing_algorithm() const {
  return _internal_has_hashing_algorithm();
}
inline void StartCsrResponse::clear_hashing_algorithm() {
  _impl_.hashing_algorithm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::enterprise_management::HashingAlgorithm StartCsrResponse::_internal_hashing_algorithm() const {
  return static_cast< ::enterprise_management::HashingAlgorithm >(_impl_.hashing_algorithm_);
}
inline ::enterprise_management::HashingAlgorithm StartCsrResponse::hashing_algorithm() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.hashing_algorithm)
  return _internal_hashing_algorithm();
}
inline void StartCsrResponse::_internal_set_hashing_algorithm(::enterprise_management::HashingAlgorithm value) {
  assert(::enterprise_management::HashingAlgorithm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.hashing_algorithm_ = value;
}
inline void StartCsrResponse::set_hashing_algorithm(::enterprise_management::HashingAlgorithm value) {
  _internal_set_hashing_algorithm(value);
  // @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.hashing_algorithm)
}

// optional .enterprise_management.SigningAlgorithm signing_algorithm = 3;
inline bool StartCsrResponse::_internal_has_signing_algorithm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StartCsrResponse::has_signing_algorithm() const {
  return _internal_has_signing_algorithm();
}
inline void StartCsrResponse::clear_signing_algorithm() {
  _impl_.signing_algorithm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::SigningAlgorithm StartCsrResponse::_internal_signing_algorithm() const {
  return static_cast< ::enterprise_management::SigningAlgorithm >(_impl_.signing_algorithm_);
}
inline ::enterprise_management::SigningAlgorithm StartCsrResponse::signing_algorithm() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.signing_algorithm)
  return _internal_signing_algorithm();
}
inline void StartCsrResponse::_internal_set_signing_algorithm(::enterprise_management::SigningAlgorithm value) {
  assert(::enterprise_management::SigningAlgorithm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.signing_algorithm_ = value;
}
inline void StartCsrResponse::set_signing_algorithm(::enterprise_management::SigningAlgorithm value) {
  _internal_set_signing_algorithm(value);
  // @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.signing_algorithm)
}

// optional bytes data_to_sign = 4;
inline bool StartCsrResponse::_internal_has_data_to_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StartCsrResponse::has_data_to_sign() const {
  return _internal_has_data_to_sign();
}
inline void StartCsrResponse::clear_data_to_sign() {
  _impl_.data_to_sign_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StartCsrResponse::data_to_sign() const {
  // @@protoc_insertion_point(field_get:enterprise_management.StartCsrResponse.data_to_sign)
  return _internal_data_to_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartCsrResponse::set_data_to_sign(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.data_to_sign_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.StartCsrResponse.data_to_sign)
}
inline std::string* StartCsrResponse::mutable_data_to_sign() {
  std::string* _s = _internal_mutable_data_to_sign();
  // @@protoc_insertion_point(field_mutable:enterprise_management.StartCsrResponse.data_to_sign)
  return _s;
}
inline const std::string& StartCsrResponse::_internal_data_to_sign() const {
  return _impl_.data_to_sign_.Get();
}
inline void StartCsrResponse::_internal_set_data_to_sign(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_to_sign_.Set(value, GetArenaForAllocation());
}
inline std::string* StartCsrResponse::_internal_mutable_data_to_sign() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.data_to_sign_.Mutable(GetArenaForAllocation());
}
inline std::string* StartCsrResponse::release_data_to_sign() {
  // @@protoc_insertion_point(field_release:enterprise_management.StartCsrResponse.data_to_sign)
  if (!_internal_has_data_to_sign()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.data_to_sign_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_to_sign_.IsDefault()) {
    _impl_.data_to_sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StartCsrResponse::set_allocated_data_to_sign(std::string* data_to_sign) {
  if (data_to_sign != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.data_to_sign_.SetAllocated(data_to_sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_to_sign_.IsDefault()) {
    _impl_.data_to_sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.StartCsrResponse.data_to_sign)
}

// -------------------------------------------------------------------

// FinishCsrRequest

// optional bytes va_challenge_response = 1;
inline bool FinishCsrRequest::_internal_has_va_challenge_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FinishCsrRequest::has_va_challenge_response() const {
  return _internal_has_va_challenge_response();
}
inline void FinishCsrRequest::clear_va_challenge_response() {
  _impl_.va_challenge_response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FinishCsrRequest::va_challenge_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.FinishCsrRequest.va_challenge_response)
  return _internal_va_challenge_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinishCsrRequest::set_va_challenge_response(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.va_challenge_response_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.FinishCsrRequest.va_challenge_response)
}
inline std::string* FinishCsrRequest::mutable_va_challenge_response() {
  std::string* _s = _internal_mutable_va_challenge_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.FinishCsrRequest.va_challenge_response)
  return _s;
}
inline const std::string& FinishCsrRequest::_internal_va_challenge_response() const {
  return _impl_.va_challenge_response_.Get();
}
inline void FinishCsrRequest::_internal_set_va_challenge_response(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.va_challenge_response_.Set(value, GetArenaForAllocation());
}
inline std::string* FinishCsrRequest::_internal_mutable_va_challenge_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.va_challenge_response_.Mutable(GetArenaForAllocation());
}
inline std::string* FinishCsrRequest::release_va_challenge_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.FinishCsrRequest.va_challenge_response)
  if (!_internal_has_va_challenge_response()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.va_challenge_response_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.va_challenge_response_.IsDefault()) {
    _impl_.va_challenge_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FinishCsrRequest::set_allocated_va_challenge_response(std::string* va_challenge_response) {
  if (va_challenge_response != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.va_challenge_response_.SetAllocated(va_challenge_response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.va_challenge_response_.IsDefault()) {
    _impl_.va_challenge_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.FinishCsrRequest.va_challenge_response)
}

// optional bytes signature = 2;
inline bool FinishCsrRequest::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FinishCsrRequest::has_signature() const {
  return _internal_has_signature();
}
inline void FinishCsrRequest::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FinishCsrRequest::signature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.FinishCsrRequest.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinishCsrRequest::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.FinishCsrRequest.signature)
}
inline std::string* FinishCsrRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:enterprise_management.FinishCsrRequest.signature)
  return _s;
}
inline const std::string& FinishCsrRequest::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void FinishCsrRequest::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* FinishCsrRequest::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* FinishCsrRequest::release_signature() {
  // @@protoc_insertion_point(field_release:enterprise_management.FinishCsrRequest.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FinishCsrRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.FinishCsrRequest.signature)
}

// -------------------------------------------------------------------

// FinishCsrResponse

// -------------------------------------------------------------------

// DownloadCertRequest

// -------------------------------------------------------------------

// DownloadCertResponse

// optional string pem_encoded_certificate = 1;
inline bool DownloadCertResponse::_internal_has_pem_encoded_certificate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DownloadCertResponse::has_pem_encoded_certificate() const {
  return _internal_has_pem_encoded_certificate();
}
inline void DownloadCertResponse::clear_pem_encoded_certificate() {
  _impl_.pem_encoded_certificate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DownloadCertResponse::pem_encoded_certificate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
  return _internal_pem_encoded_certificate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadCertResponse::set_pem_encoded_certificate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pem_encoded_certificate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
}
inline std::string* DownloadCertResponse::mutable_pem_encoded_certificate() {
  std::string* _s = _internal_mutable_pem_encoded_certificate();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
  return _s;
}
inline const std::string& DownloadCertResponse::_internal_pem_encoded_certificate() const {
  return _impl_.pem_encoded_certificate_.Get();
}
inline void DownloadCertResponse::_internal_set_pem_encoded_certificate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pem_encoded_certificate_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadCertResponse::_internal_mutable_pem_encoded_certificate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pem_encoded_certificate_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadCertResponse::release_pem_encoded_certificate() {
  // @@protoc_insertion_point(field_release:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
  if (!_internal_has_pem_encoded_certificate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pem_encoded_certificate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pem_encoded_certificate_.IsDefault()) {
    _impl_.pem_encoded_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DownloadCertResponse::set_allocated_pem_encoded_certificate(std::string* pem_encoded_certificate) {
  if (pem_encoded_certificate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pem_encoded_certificate_.SetAllocated(pem_encoded_certificate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pem_encoded_certificate_.IsDefault()) {
    _impl_.pem_encoded_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DownloadCertResponse.pem_encoded_certificate)
}

// -------------------------------------------------------------------

// CertProvStartOrContinueRequest

// -------------------------------------------------------------------

// CertProvAuthorizeRequest

// optional bytes va_challenge_response = 1;
inline bool CertProvAuthorizeRequest::_internal_has_va_challenge_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertProvAuthorizeRequest::has_va_challenge_response() const {
  return _internal_has_va_challenge_response();
}
inline void CertProvAuthorizeRequest::clear_va_challenge_response() {
  _impl_.va_challenge_response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertProvAuthorizeRequest::va_challenge_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvAuthorizeRequest.va_challenge_response)
  return _internal_va_challenge_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertProvAuthorizeRequest::set_va_challenge_response(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.va_challenge_response_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CertProvAuthorizeRequest.va_challenge_response)
}
inline std::string* CertProvAuthorizeRequest::mutable_va_challenge_response() {
  std::string* _s = _internal_mutable_va_challenge_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvAuthorizeRequest.va_challenge_response)
  return _s;
}
inline const std::string& CertProvAuthorizeRequest::_internal_va_challenge_response() const {
  return _impl_.va_challenge_response_.Get();
}
inline void CertProvAuthorizeRequest::_internal_set_va_challenge_response(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.va_challenge_response_.Set(value, GetArenaForAllocation());
}
inline std::string* CertProvAuthorizeRequest::_internal_mutable_va_challenge_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.va_challenge_response_.Mutable(GetArenaForAllocation());
}
inline std::string* CertProvAuthorizeRequest::release_va_challenge_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvAuthorizeRequest.va_challenge_response)
  if (!_internal_has_va_challenge_response()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.va_challenge_response_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.va_challenge_response_.IsDefault()) {
    _impl_.va_challenge_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CertProvAuthorizeRequest::set_allocated_va_challenge_response(std::string* va_challenge_response) {
  if (va_challenge_response != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.va_challenge_response_.SetAllocated(va_challenge_response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.va_challenge_response_.IsDefault()) {
    _impl_.va_challenge_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvAuthorizeRequest.va_challenge_response)
}

// -------------------------------------------------------------------

// CertProvUploadProofOfPossessionRequest

// optional bytes signature = 1;
inline bool CertProvUploadProofOfPossessionRequest::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertProvUploadProofOfPossessionRequest::has_signature() const {
  return _internal_has_signature();
}
inline void CertProvUploadProofOfPossessionRequest::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertProvUploadProofOfPossessionRequest::signature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvUploadProofOfPossessionRequest.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertProvUploadProofOfPossessionRequest::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CertProvUploadProofOfPossessionRequest.signature)
}
inline std::string* CertProvUploadProofOfPossessionRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvUploadProofOfPossessionRequest.signature)
  return _s;
}
inline const std::string& CertProvUploadProofOfPossessionRequest::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void CertProvUploadProofOfPossessionRequest::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* CertProvUploadProofOfPossessionRequest::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* CertProvUploadProofOfPossessionRequest::release_signature() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvUploadProofOfPossessionRequest.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CertProvUploadProofOfPossessionRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvUploadProofOfPossessionRequest.signature)
}

// -------------------------------------------------------------------

// CertProvTryLaterInstruction

// optional int64 delay_ms = 1;
inline bool CertProvTryLaterInstruction::_internal_has_delay_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertProvTryLaterInstruction::has_delay_ms() const {
  return _internal_has_delay_ms();
}
inline void CertProvTryLaterInstruction::clear_delay_ms() {
  _impl_.delay_ms_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t CertProvTryLaterInstruction::_internal_delay_ms() const {
  return _impl_.delay_ms_;
}
inline int64_t CertProvTryLaterInstruction::delay_ms() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvTryLaterInstruction.delay_ms)
  return _internal_delay_ms();
}
inline void CertProvTryLaterInstruction::_internal_set_delay_ms(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.delay_ms_ = value;
}
inline void CertProvTryLaterInstruction::set_delay_ms(int64_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:enterprise_management.CertProvTryLaterInstruction.delay_ms)
}

// -------------------------------------------------------------------

// CertProvAuthorizeInstruction

// optional bytes va_challenge = 1;
inline bool CertProvAuthorizeInstruction::_internal_has_va_challenge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertProvAuthorizeInstruction::has_va_challenge() const {
  return _internal_has_va_challenge();
}
inline void CertProvAuthorizeInstruction::clear_va_challenge() {
  _impl_.va_challenge_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertProvAuthorizeInstruction::va_challenge() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvAuthorizeInstruction.va_challenge)
  return _internal_va_challenge();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertProvAuthorizeInstruction::set_va_challenge(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.va_challenge_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CertProvAuthorizeInstruction.va_challenge)
}
inline std::string* CertProvAuthorizeInstruction::mutable_va_challenge() {
  std::string* _s = _internal_mutable_va_challenge();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvAuthorizeInstruction.va_challenge)
  return _s;
}
inline const std::string& CertProvAuthorizeInstruction::_internal_va_challenge() const {
  return _impl_.va_challenge_.Get();
}
inline void CertProvAuthorizeInstruction::_internal_set_va_challenge(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.va_challenge_.Set(value, GetArenaForAllocation());
}
inline std::string* CertProvAuthorizeInstruction::_internal_mutable_va_challenge() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.va_challenge_.Mutable(GetArenaForAllocation());
}
inline std::string* CertProvAuthorizeInstruction::release_va_challenge() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvAuthorizeInstruction.va_challenge)
  if (!_internal_has_va_challenge()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.va_challenge_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.va_challenge_.IsDefault()) {
    _impl_.va_challenge_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CertProvAuthorizeInstruction::set_allocated_va_challenge(std::string* va_challenge) {
  if (va_challenge != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.va_challenge_.SetAllocated(va_challenge, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.va_challenge_.IsDefault()) {
    _impl_.va_challenge_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvAuthorizeInstruction.va_challenge)
}

// -------------------------------------------------------------------

// CertProvProofOfPossessionInstruction

// optional bytes data_to_sign = 2;
inline bool CertProvProofOfPossessionInstruction::_internal_has_data_to_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertProvProofOfPossessionInstruction::has_data_to_sign() const {
  return _internal_has_data_to_sign();
}
inline void CertProvProofOfPossessionInstruction::clear_data_to_sign() {
  _impl_.data_to_sign_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertProvProofOfPossessionInstruction::data_to_sign() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvProofOfPossessionInstruction.data_to_sign)
  return _internal_data_to_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertProvProofOfPossessionInstruction::set_data_to_sign(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_to_sign_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CertProvProofOfPossessionInstruction.data_to_sign)
}
inline std::string* CertProvProofOfPossessionInstruction::mutable_data_to_sign() {
  std::string* _s = _internal_mutable_data_to_sign();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvProofOfPossessionInstruction.data_to_sign)
  return _s;
}
inline const std::string& CertProvProofOfPossessionInstruction::_internal_data_to_sign() const {
  return _impl_.data_to_sign_.Get();
}
inline void CertProvProofOfPossessionInstruction::_internal_set_data_to_sign(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_to_sign_.Set(value, GetArenaForAllocation());
}
inline std::string* CertProvProofOfPossessionInstruction::_internal_mutable_data_to_sign() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_to_sign_.Mutable(GetArenaForAllocation());
}
inline std::string* CertProvProofOfPossessionInstruction::release_data_to_sign() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvProofOfPossessionInstruction.data_to_sign)
  if (!_internal_has_data_to_sign()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_to_sign_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_to_sign_.IsDefault()) {
    _impl_.data_to_sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CertProvProofOfPossessionInstruction::set_allocated_data_to_sign(std::string* data_to_sign) {
  if (data_to_sign != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_to_sign_.SetAllocated(data_to_sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_to_sign_.IsDefault()) {
    _impl_.data_to_sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvProofOfPossessionInstruction.data_to_sign)
}

// -------------------------------------------------------------------

// CertProvImportCertificateInstruction

// optional string pem_encoded_certificate = 1;
inline bool CertProvImportCertificateInstruction::_internal_has_pem_encoded_certificate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertProvImportCertificateInstruction::has_pem_encoded_certificate() const {
  return _internal_has_pem_encoded_certificate();
}
inline void CertProvImportCertificateInstruction::clear_pem_encoded_certificate() {
  _impl_.pem_encoded_certificate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertProvImportCertificateInstruction::pem_encoded_certificate() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvImportCertificateInstruction.pem_encoded_certificate)
  return _internal_pem_encoded_certificate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertProvImportCertificateInstruction::set_pem_encoded_certificate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pem_encoded_certificate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CertProvImportCertificateInstruction.pem_encoded_certificate)
}
inline std::string* CertProvImportCertificateInstruction::mutable_pem_encoded_certificate() {
  std::string* _s = _internal_mutable_pem_encoded_certificate();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvImportCertificateInstruction.pem_encoded_certificate)
  return _s;
}
inline const std::string& CertProvImportCertificateInstruction::_internal_pem_encoded_certificate() const {
  return _impl_.pem_encoded_certificate_.Get();
}
inline void CertProvImportCertificateInstruction::_internal_set_pem_encoded_certificate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pem_encoded_certificate_.Set(value, GetArenaForAllocation());
}
inline std::string* CertProvImportCertificateInstruction::_internal_mutable_pem_encoded_certificate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pem_encoded_certificate_.Mutable(GetArenaForAllocation());
}
inline std::string* CertProvImportCertificateInstruction::release_pem_encoded_certificate() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvImportCertificateInstruction.pem_encoded_certificate)
  if (!_internal_has_pem_encoded_certificate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pem_encoded_certificate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pem_encoded_certificate_.IsDefault()) {
    _impl_.pem_encoded_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CertProvImportCertificateInstruction::set_allocated_pem_encoded_certificate(std::string* pem_encoded_certificate) {
  if (pem_encoded_certificate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pem_encoded_certificate_.SetAllocated(pem_encoded_certificate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pem_encoded_certificate_.IsDefault()) {
    _impl_.pem_encoded_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvImportCertificateInstruction.pem_encoded_certificate)
}

// -------------------------------------------------------------------

// CertProvNextActionResponse

// optional string invalidation_topic = 1;
inline bool CertProvNextActionResponse::_internal_has_invalidation_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertProvNextActionResponse::has_invalidation_topic() const {
  return _internal_has_invalidation_topic();
}
inline void CertProvNextActionResponse::clear_invalidation_topic() {
  _impl_.invalidation_topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertProvNextActionResponse::invalidation_topic() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvNextActionResponse.invalidation_topic)
  return _internal_invalidation_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertProvNextActionResponse::set_invalidation_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.invalidation_topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.CertProvNextActionResponse.invalidation_topic)
}
inline std::string* CertProvNextActionResponse::mutable_invalidation_topic() {
  std::string* _s = _internal_mutable_invalidation_topic();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvNextActionResponse.invalidation_topic)
  return _s;
}
inline const std::string& CertProvNextActionResponse::_internal_invalidation_topic() const {
  return _impl_.invalidation_topic_.Get();
}
inline void CertProvNextActionResponse::_internal_set_invalidation_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.invalidation_topic_.Set(value, GetArenaForAllocation());
}
inline std::string* CertProvNextActionResponse::_internal_mutable_invalidation_topic() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.invalidation_topic_.Mutable(GetArenaForAllocation());
}
inline std::string* CertProvNextActionResponse::release_invalidation_topic() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvNextActionResponse.invalidation_topic)
  if (!_internal_has_invalidation_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.invalidation_topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invalidation_topic_.IsDefault()) {
    _impl_.invalidation_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CertProvNextActionResponse::set_allocated_invalidation_topic(std::string* invalidation_topic) {
  if (invalidation_topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.invalidation_topic_.SetAllocated(invalidation_topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invalidation_topic_.IsDefault()) {
    _impl_.invalidation_topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvNextActionResponse.invalidation_topic)
}

// .enterprise_management.CertProvTryLaterInstruction try_later_instruction = 5;
inline bool CertProvNextActionResponse::_internal_has_try_later_instruction() const {
  return instruction_case() == kTryLaterInstruction;
}
inline bool CertProvNextActionResponse::has_try_later_instruction() const {
  return _internal_has_try_later_instruction();
}
inline void CertProvNextActionResponse::set_has_try_later_instruction() {
  _impl_._oneof_case_[0] = kTryLaterInstruction;
}
inline void CertProvNextActionResponse::clear_try_later_instruction() {
  if (_internal_has_try_later_instruction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.instruction_.try_later_instruction_;
    }
    clear_has_instruction();
  }
}
inline ::enterprise_management::CertProvTryLaterInstruction* CertProvNextActionResponse::release_try_later_instruction() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvNextActionResponse.try_later_instruction)
  if (_internal_has_try_later_instruction()) {
    clear_has_instruction();
    ::enterprise_management::CertProvTryLaterInstruction* temp = _impl_.instruction_.try_later_instruction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.instruction_.try_later_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::CertProvTryLaterInstruction& CertProvNextActionResponse::_internal_try_later_instruction() const {
  return _internal_has_try_later_instruction()
      ? *_impl_.instruction_.try_later_instruction_
      : reinterpret_cast< ::enterprise_management::CertProvTryLaterInstruction&>(::enterprise_management::_CertProvTryLaterInstruction_default_instance_);
}
inline const ::enterprise_management::CertProvTryLaterInstruction& CertProvNextActionResponse::try_later_instruction() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvNextActionResponse.try_later_instruction)
  return _internal_try_later_instruction();
}
inline ::enterprise_management::CertProvTryLaterInstruction* CertProvNextActionResponse::unsafe_arena_release_try_later_instruction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.CertProvNextActionResponse.try_later_instruction)
  if (_internal_has_try_later_instruction()) {
    clear_has_instruction();
    ::enterprise_management::CertProvTryLaterInstruction* temp = _impl_.instruction_.try_later_instruction_;
    _impl_.instruction_.try_later_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CertProvNextActionResponse::unsafe_arena_set_allocated_try_later_instruction(::enterprise_management::CertProvTryLaterInstruction* try_later_instruction) {
  clear_instruction();
  if (try_later_instruction) {
    set_has_try_later_instruction();
    _impl_.instruction_.try_later_instruction_ = try_later_instruction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.CertProvNextActionResponse.try_later_instruction)
}
inline ::enterprise_management::CertProvTryLaterInstruction* CertProvNextActionResponse::_internal_mutable_try_later_instruction() {
  if (!_internal_has_try_later_instruction()) {
    clear_instruction();
    set_has_try_later_instruction();
    _impl_.instruction_.try_later_instruction_ = CreateMaybeMessage< ::enterprise_management::CertProvTryLaterInstruction >(GetArenaForAllocation());
  }
  return _impl_.instruction_.try_later_instruction_;
}
inline ::enterprise_management::CertProvTryLaterInstruction* CertProvNextActionResponse::mutable_try_later_instruction() {
  ::enterprise_management::CertProvTryLaterInstruction* _msg = _internal_mutable_try_later_instruction();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvNextActionResponse.try_later_instruction)
  return _msg;
}

// .enterprise_management.CertProvAuthorizeInstruction authorize_instruction = 2;
inline bool CertProvNextActionResponse::_internal_has_authorize_instruction() const {
  return instruction_case() == kAuthorizeInstruction;
}
inline bool CertProvNextActionResponse::has_authorize_instruction() const {
  return _internal_has_authorize_instruction();
}
inline void CertProvNextActionResponse::set_has_authorize_instruction() {
  _impl_._oneof_case_[0] = kAuthorizeInstruction;
}
inline void CertProvNextActionResponse::clear_authorize_instruction() {
  if (_internal_has_authorize_instruction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.instruction_.authorize_instruction_;
    }
    clear_has_instruction();
  }
}
inline ::enterprise_management::CertProvAuthorizeInstruction* CertProvNextActionResponse::release_authorize_instruction() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvNextActionResponse.authorize_instruction)
  if (_internal_has_authorize_instruction()) {
    clear_has_instruction();
    ::enterprise_management::CertProvAuthorizeInstruction* temp = _impl_.instruction_.authorize_instruction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.instruction_.authorize_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::CertProvAuthorizeInstruction& CertProvNextActionResponse::_internal_authorize_instruction() const {
  return _internal_has_authorize_instruction()
      ? *_impl_.instruction_.authorize_instruction_
      : reinterpret_cast< ::enterprise_management::CertProvAuthorizeInstruction&>(::enterprise_management::_CertProvAuthorizeInstruction_default_instance_);
}
inline const ::enterprise_management::CertProvAuthorizeInstruction& CertProvNextActionResponse::authorize_instruction() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvNextActionResponse.authorize_instruction)
  return _internal_authorize_instruction();
}
inline ::enterprise_management::CertProvAuthorizeInstruction* CertProvNextActionResponse::unsafe_arena_release_authorize_instruction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.CertProvNextActionResponse.authorize_instruction)
  if (_internal_has_authorize_instruction()) {
    clear_has_instruction();
    ::enterprise_management::CertProvAuthorizeInstruction* temp = _impl_.instruction_.authorize_instruction_;
    _impl_.instruction_.authorize_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CertProvNextActionResponse::unsafe_arena_set_allocated_authorize_instruction(::enterprise_management::CertProvAuthorizeInstruction* authorize_instruction) {
  clear_instruction();
  if (authorize_instruction) {
    set_has_authorize_instruction();
    _impl_.instruction_.authorize_instruction_ = authorize_instruction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.CertProvNextActionResponse.authorize_instruction)
}
inline ::enterprise_management::CertProvAuthorizeInstruction* CertProvNextActionResponse::_internal_mutable_authorize_instruction() {
  if (!_internal_has_authorize_instruction()) {
    clear_instruction();
    set_has_authorize_instruction();
    _impl_.instruction_.authorize_instruction_ = CreateMaybeMessage< ::enterprise_management::CertProvAuthorizeInstruction >(GetArenaForAllocation());
  }
  return _impl_.instruction_.authorize_instruction_;
}
inline ::enterprise_management::CertProvAuthorizeInstruction* CertProvNextActionResponse::mutable_authorize_instruction() {
  ::enterprise_management::CertProvAuthorizeInstruction* _msg = _internal_mutable_authorize_instruction();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvNextActionResponse.authorize_instruction)
  return _msg;
}

// .enterprise_management.CertProvProofOfPossessionInstruction proof_of_possession_instruction = 3;
inline bool CertProvNextActionResponse::_internal_has_proof_of_possession_instruction() const {
  return instruction_case() == kProofOfPossessionInstruction;
}
inline bool CertProvNextActionResponse::has_proof_of_possession_instruction() const {
  return _internal_has_proof_of_possession_instruction();
}
inline void CertProvNextActionResponse::set_has_proof_of_possession_instruction() {
  _impl_._oneof_case_[0] = kProofOfPossessionInstruction;
}
inline void CertProvNextActionResponse::clear_proof_of_possession_instruction() {
  if (_internal_has_proof_of_possession_instruction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.instruction_.proof_of_possession_instruction_;
    }
    clear_has_instruction();
  }
}
inline ::enterprise_management::CertProvProofOfPossessionInstruction* CertProvNextActionResponse::release_proof_of_possession_instruction() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvNextActionResponse.proof_of_possession_instruction)
  if (_internal_has_proof_of_possession_instruction()) {
    clear_has_instruction();
    ::enterprise_management::CertProvProofOfPossessionInstruction* temp = _impl_.instruction_.proof_of_possession_instruction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.instruction_.proof_of_possession_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::CertProvProofOfPossessionInstruction& CertProvNextActionResponse::_internal_proof_of_possession_instruction() const {
  return _internal_has_proof_of_possession_instruction()
      ? *_impl_.instruction_.proof_of_possession_instruction_
      : reinterpret_cast< ::enterprise_management::CertProvProofOfPossessionInstruction&>(::enterprise_management::_CertProvProofOfPossessionInstruction_default_instance_);
}
inline const ::enterprise_management::CertProvProofOfPossessionInstruction& CertProvNextActionResponse::proof_of_possession_instruction() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvNextActionResponse.proof_of_possession_instruction)
  return _internal_proof_of_possession_instruction();
}
inline ::enterprise_management::CertProvProofOfPossessionInstruction* CertProvNextActionResponse::unsafe_arena_release_proof_of_possession_instruction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.CertProvNextActionResponse.proof_of_possession_instruction)
  if (_internal_has_proof_of_possession_instruction()) {
    clear_has_instruction();
    ::enterprise_management::CertProvProofOfPossessionInstruction* temp = _impl_.instruction_.proof_of_possession_instruction_;
    _impl_.instruction_.proof_of_possession_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CertProvNextActionResponse::unsafe_arena_set_allocated_proof_of_possession_instruction(::enterprise_management::CertProvProofOfPossessionInstruction* proof_of_possession_instruction) {
  clear_instruction();
  if (proof_of_possession_instruction) {
    set_has_proof_of_possession_instruction();
    _impl_.instruction_.proof_of_possession_instruction_ = proof_of_possession_instruction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.CertProvNextActionResponse.proof_of_possession_instruction)
}
inline ::enterprise_management::CertProvProofOfPossessionInstruction* CertProvNextActionResponse::_internal_mutable_proof_of_possession_instruction() {
  if (!_internal_has_proof_of_possession_instruction()) {
    clear_instruction();
    set_has_proof_of_possession_instruction();
    _impl_.instruction_.proof_of_possession_instruction_ = CreateMaybeMessage< ::enterprise_management::CertProvProofOfPossessionInstruction >(GetArenaForAllocation());
  }
  return _impl_.instruction_.proof_of_possession_instruction_;
}
inline ::enterprise_management::CertProvProofOfPossessionInstruction* CertProvNextActionResponse::mutable_proof_of_possession_instruction() {
  ::enterprise_management::CertProvProofOfPossessionInstruction* _msg = _internal_mutable_proof_of_possession_instruction();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvNextActionResponse.proof_of_possession_instruction)
  return _msg;
}

// .enterprise_management.CertProvImportCertificateInstruction import_certificate_instruction = 4;
inline bool CertProvNextActionResponse::_internal_has_import_certificate_instruction() const {
  return instruction_case() == kImportCertificateInstruction;
}
inline bool CertProvNextActionResponse::has_import_certificate_instruction() const {
  return _internal_has_import_certificate_instruction();
}
inline void CertProvNextActionResponse::set_has_import_certificate_instruction() {
  _impl_._oneof_case_[0] = kImportCertificateInstruction;
}
inline void CertProvNextActionResponse::clear_import_certificate_instruction() {
  if (_internal_has_import_certificate_instruction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.instruction_.import_certificate_instruction_;
    }
    clear_has_instruction();
  }
}
inline ::enterprise_management::CertProvImportCertificateInstruction* CertProvNextActionResponse::release_import_certificate_instruction() {
  // @@protoc_insertion_point(field_release:enterprise_management.CertProvNextActionResponse.import_certificate_instruction)
  if (_internal_has_import_certificate_instruction()) {
    clear_has_instruction();
    ::enterprise_management::CertProvImportCertificateInstruction* temp = _impl_.instruction_.import_certificate_instruction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.instruction_.import_certificate_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::CertProvImportCertificateInstruction& CertProvNextActionResponse::_internal_import_certificate_instruction() const {
  return _internal_has_import_certificate_instruction()
      ? *_impl_.instruction_.import_certificate_instruction_
      : reinterpret_cast< ::enterprise_management::CertProvImportCertificateInstruction&>(::enterprise_management::_CertProvImportCertificateInstruction_default_instance_);
}
inline const ::enterprise_management::CertProvImportCertificateInstruction& CertProvNextActionResponse::import_certificate_instruction() const {
  // @@protoc_insertion_point(field_get:enterprise_management.CertProvNextActionResponse.import_certificate_instruction)
  return _internal_import_certificate_instruction();
}
inline ::enterprise_management::CertProvImportCertificateInstruction* CertProvNextActionResponse::unsafe_arena_release_import_certificate_instruction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.CertProvNextActionResponse.import_certificate_instruction)
  if (_internal_has_import_certificate_instruction()) {
    clear_has_instruction();
    ::enterprise_management::CertProvImportCertificateInstruction* temp = _impl_.instruction_.import_certificate_instruction_;
    _impl_.instruction_.import_certificate_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CertProvNextActionResponse::unsafe_arena_set_allocated_import_certificate_instruction(::enterprise_management::CertProvImportCertificateInstruction* import_certificate_instruction) {
  clear_instruction();
  if (import_certificate_instruction) {
    set_has_import_certificate_instruction();
    _impl_.instruction_.import_certificate_instruction_ = import_certificate_instruction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.CertProvNextActionResponse.import_certificate_instruction)
}
inline ::enterprise_management::CertProvImportCertificateInstruction* CertProvNextActionResponse::_internal_mutable_import_certificate_instruction() {
  if (!_internal_has_import_certificate_instruction()) {
    clear_instruction();
    set_has_import_certificate_instruction();
    _impl_.instruction_.import_certificate_instruction_ = CreateMaybeMessage< ::enterprise_management::CertProvImportCertificateInstruction >(GetArenaForAllocation());
  }
  return _impl_.instruction_.import_certificate_instruction_;
}
inline ::enterprise_management::CertProvImportCertificateInstruction* CertProvNextActionResponse::mutable_import_certificate_instruction() {
  ::enterprise_management::CertProvImportCertificateInstruction* _msg = _internal_mutable_import_certificate_instruction();
  // @@protoc_insertion_point(field_mutable:enterprise_management.CertProvNextActionResponse.import_certificate_instruction)
  return _msg;
}

inline bool CertProvNextActionResponse::has_instruction() const {
  return instruction_case() != INSTRUCTION_NOT_SET;
}
inline void CertProvNextActionResponse::clear_has_instruction() {
  _impl_._oneof_case_[0] = INSTRUCTION_NOT_SET;
}
inline CertProvNextActionResponse::InstructionCase CertProvNextActionResponse::instruction_case() const {
  return CertProvNextActionResponse::InstructionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientCertificateProvisioningRequest

// optional string certificate_scope = 1;
inline bool ClientCertificateProvisioningRequest::_internal_has_certificate_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientCertificateProvisioningRequest::has_certificate_scope() const {
  return _internal_has_certificate_scope();
}
inline void ClientCertificateProvisioningRequest::clear_certificate_scope() {
  _impl_.certificate_scope_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientCertificateProvisioningRequest::certificate_scope() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
  return _internal_certificate_scope();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientCertificateProvisioningRequest::set_certificate_scope(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.certificate_scope_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_certificate_scope() {
  std::string* _s = _internal_mutable_certificate_scope();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
  return _s;
}
inline const std::string& ClientCertificateProvisioningRequest::_internal_certificate_scope() const {
  return _impl_.certificate_scope_.Get();
}
inline void ClientCertificateProvisioningRequest::_internal_set_certificate_scope(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.certificate_scope_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::_internal_mutable_certificate_scope() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.certificate_scope_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::release_certificate_scope() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
  if (!_internal_has_certificate_scope()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.certificate_scope_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.certificate_scope_.IsDefault()) {
    _impl_.certificate_scope_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientCertificateProvisioningRequest::set_allocated_certificate_scope(std::string* certificate_scope) {
  if (certificate_scope != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.certificate_scope_.SetAllocated(certificate_scope, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.certificate_scope_.IsDefault()) {
    _impl_.certificate_scope_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.certificate_scope)
}

// optional string cert_profile_id = 2;
inline bool ClientCertificateProvisioningRequest::_internal_has_cert_profile_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientCertificateProvisioningRequest::has_cert_profile_id() const {
  return _internal_has_cert_profile_id();
}
inline void ClientCertificateProvisioningRequest::clear_cert_profile_id() {
  _impl_.cert_profile_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientCertificateProvisioningRequest::cert_profile_id() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
  return _internal_cert_profile_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientCertificateProvisioningRequest::set_cert_profile_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cert_profile_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_cert_profile_id() {
  std::string* _s = _internal_mutable_cert_profile_id();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
  return _s;
}
inline const std::string& ClientCertificateProvisioningRequest::_internal_cert_profile_id() const {
  return _impl_.cert_profile_id_.Get();
}
inline void ClientCertificateProvisioningRequest::_internal_set_cert_profile_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cert_profile_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::_internal_mutable_cert_profile_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cert_profile_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::release_cert_profile_id() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
  if (!_internal_has_cert_profile_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cert_profile_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cert_profile_id_.IsDefault()) {
    _impl_.cert_profile_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientCertificateProvisioningRequest::set_allocated_cert_profile_id(std::string* cert_profile_id) {
  if (cert_profile_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cert_profile_id_.SetAllocated(cert_profile_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cert_profile_id_.IsDefault()) {
    _impl_.cert_profile_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.cert_profile_id)
}

// optional bytes public_key = 3;
inline bool ClientCertificateProvisioningRequest::_internal_has_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientCertificateProvisioningRequest::has_public_key() const {
  return _internal_has_public_key();
}
inline void ClientCertificateProvisioningRequest::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientCertificateProvisioningRequest::public_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientCertificateProvisioningRequest::set_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.public_key)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.public_key)
  return _s;
}
inline const std::string& ClientCertificateProvisioningRequest::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void ClientCertificateProvisioningRequest::_internal_set_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::_internal_mutable_public_key() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientCertificateProvisioningRequest::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.public_key)
}

// optional string device_dm_token = 4;
inline bool ClientCertificateProvisioningRequest::_internal_has_device_dm_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientCertificateProvisioningRequest::has_device_dm_token() const {
  return _internal_has_device_dm_token();
}
inline void ClientCertificateProvisioningRequest::clear_device_dm_token() {
  _impl_.device_dm_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClientCertificateProvisioningRequest::device_dm_token() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
  return _internal_device_dm_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientCertificateProvisioningRequest::set_device_dm_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.device_dm_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_device_dm_token() {
  std::string* _s = _internal_mutable_device_dm_token();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
  return _s;
}
inline const std::string& ClientCertificateProvisioningRequest::_internal_device_dm_token() const {
  return _impl_.device_dm_token_.Get();
}
inline void ClientCertificateProvisioningRequest::_internal_set_device_dm_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.device_dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::_internal_mutable_device_dm_token() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.device_dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::release_device_dm_token() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
  if (!_internal_has_device_dm_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.device_dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_dm_token_.IsDefault()) {
    _impl_.device_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientCertificateProvisioningRequest::set_allocated_device_dm_token(std::string* device_dm_token) {
  if (device_dm_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.device_dm_token_.SetAllocated(device_dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_dm_token_.IsDefault()) {
    _impl_.device_dm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.device_dm_token)
}

// .enterprise_management.StartCsrRequest start_csr_request = 5;
inline bool ClientCertificateProvisioningRequest::_internal_has_start_csr_request() const {
  return request_case() == kStartCsrRequest;
}
inline bool ClientCertificateProvisioningRequest::has_start_csr_request() const {
  return _internal_has_start_csr_request();
}
inline void ClientCertificateProvisioningRequest::set_has_start_csr_request() {
  _impl_._oneof_case_[0] = kStartCsrRequest;
}
inline void ClientCertificateProvisioningRequest::clear_start_csr_request() {
  if (_internal_has_start_csr_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.start_csr_request_;
    }
    clear_has_request();
  }
}
inline ::enterprise_management::StartCsrRequest* ClientCertificateProvisioningRequest::release_start_csr_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
  if (_internal_has_start_csr_request()) {
    clear_has_request();
    ::enterprise_management::StartCsrRequest* temp = _impl_.request_.start_csr_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.start_csr_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::StartCsrRequest& ClientCertificateProvisioningRequest::_internal_start_csr_request() const {
  return _internal_has_start_csr_request()
      ? *_impl_.request_.start_csr_request_
      : reinterpret_cast< ::enterprise_management::StartCsrRequest&>(::enterprise_management::_StartCsrRequest_default_instance_);
}
inline const ::enterprise_management::StartCsrRequest& ClientCertificateProvisioningRequest::start_csr_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
  return _internal_start_csr_request();
}
inline ::enterprise_management::StartCsrRequest* ClientCertificateProvisioningRequest::unsafe_arena_release_start_csr_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
  if (_internal_has_start_csr_request()) {
    clear_has_request();
    ::enterprise_management::StartCsrRequest* temp = _impl_.request_.start_csr_request_;
    _impl_.request_.start_csr_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningRequest::unsafe_arena_set_allocated_start_csr_request(::enterprise_management::StartCsrRequest* start_csr_request) {
  clear_request();
  if (start_csr_request) {
    set_has_start_csr_request();
    _impl_.request_.start_csr_request_ = start_csr_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
}
inline ::enterprise_management::StartCsrRequest* ClientCertificateProvisioningRequest::_internal_mutable_start_csr_request() {
  if (!_internal_has_start_csr_request()) {
    clear_request();
    set_has_start_csr_request();
    _impl_.request_.start_csr_request_ = CreateMaybeMessage< ::enterprise_management::StartCsrRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.start_csr_request_;
}
inline ::enterprise_management::StartCsrRequest* ClientCertificateProvisioningRequest::mutable_start_csr_request() {
  ::enterprise_management::StartCsrRequest* _msg = _internal_mutable_start_csr_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
  return _msg;
}

// .enterprise_management.FinishCsrRequest finish_csr_request = 6;
inline bool ClientCertificateProvisioningRequest::_internal_has_finish_csr_request() const {
  return request_case() == kFinishCsrRequest;
}
inline bool ClientCertificateProvisioningRequest::has_finish_csr_request() const {
  return _internal_has_finish_csr_request();
}
inline void ClientCertificateProvisioningRequest::set_has_finish_csr_request() {
  _impl_._oneof_case_[0] = kFinishCsrRequest;
}
inline void ClientCertificateProvisioningRequest::clear_finish_csr_request() {
  if (_internal_has_finish_csr_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.finish_csr_request_;
    }
    clear_has_request();
  }
}
inline ::enterprise_management::FinishCsrRequest* ClientCertificateProvisioningRequest::release_finish_csr_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
  if (_internal_has_finish_csr_request()) {
    clear_has_request();
    ::enterprise_management::FinishCsrRequest* temp = _impl_.request_.finish_csr_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.finish_csr_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::FinishCsrRequest& ClientCertificateProvisioningRequest::_internal_finish_csr_request() const {
  return _internal_has_finish_csr_request()
      ? *_impl_.request_.finish_csr_request_
      : reinterpret_cast< ::enterprise_management::FinishCsrRequest&>(::enterprise_management::_FinishCsrRequest_default_instance_);
}
inline const ::enterprise_management::FinishCsrRequest& ClientCertificateProvisioningRequest::finish_csr_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
  return _internal_finish_csr_request();
}
inline ::enterprise_management::FinishCsrRequest* ClientCertificateProvisioningRequest::unsafe_arena_release_finish_csr_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
  if (_internal_has_finish_csr_request()) {
    clear_has_request();
    ::enterprise_management::FinishCsrRequest* temp = _impl_.request_.finish_csr_request_;
    _impl_.request_.finish_csr_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningRequest::unsafe_arena_set_allocated_finish_csr_request(::enterprise_management::FinishCsrRequest* finish_csr_request) {
  clear_request();
  if (finish_csr_request) {
    set_has_finish_csr_request();
    _impl_.request_.finish_csr_request_ = finish_csr_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
}
inline ::enterprise_management::FinishCsrRequest* ClientCertificateProvisioningRequest::_internal_mutable_finish_csr_request() {
  if (!_internal_has_finish_csr_request()) {
    clear_request();
    set_has_finish_csr_request();
    _impl_.request_.finish_csr_request_ = CreateMaybeMessage< ::enterprise_management::FinishCsrRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.finish_csr_request_;
}
inline ::enterprise_management::FinishCsrRequest* ClientCertificateProvisioningRequest::mutable_finish_csr_request() {
  ::enterprise_management::FinishCsrRequest* _msg = _internal_mutable_finish_csr_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
  return _msg;
}

// .enterprise_management.DownloadCertRequest download_cert_request = 7;
inline bool ClientCertificateProvisioningRequest::_internal_has_download_cert_request() const {
  return request_case() == kDownloadCertRequest;
}
inline bool ClientCertificateProvisioningRequest::has_download_cert_request() const {
  return _internal_has_download_cert_request();
}
inline void ClientCertificateProvisioningRequest::set_has_download_cert_request() {
  _impl_._oneof_case_[0] = kDownloadCertRequest;
}
inline void ClientCertificateProvisioningRequest::clear_download_cert_request() {
  if (_internal_has_download_cert_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.download_cert_request_;
    }
    clear_has_request();
  }
}
inline ::enterprise_management::DownloadCertRequest* ClientCertificateProvisioningRequest::release_download_cert_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
  if (_internal_has_download_cert_request()) {
    clear_has_request();
    ::enterprise_management::DownloadCertRequest* temp = _impl_.request_.download_cert_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.download_cert_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::DownloadCertRequest& ClientCertificateProvisioningRequest::_internal_download_cert_request() const {
  return _internal_has_download_cert_request()
      ? *_impl_.request_.download_cert_request_
      : reinterpret_cast< ::enterprise_management::DownloadCertRequest&>(::enterprise_management::_DownloadCertRequest_default_instance_);
}
inline const ::enterprise_management::DownloadCertRequest& ClientCertificateProvisioningRequest::download_cert_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
  return _internal_download_cert_request();
}
inline ::enterprise_management::DownloadCertRequest* ClientCertificateProvisioningRequest::unsafe_arena_release_download_cert_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
  if (_internal_has_download_cert_request()) {
    clear_has_request();
    ::enterprise_management::DownloadCertRequest* temp = _impl_.request_.download_cert_request_;
    _impl_.request_.download_cert_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningRequest::unsafe_arena_set_allocated_download_cert_request(::enterprise_management::DownloadCertRequest* download_cert_request) {
  clear_request();
  if (download_cert_request) {
    set_has_download_cert_request();
    _impl_.request_.download_cert_request_ = download_cert_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
}
inline ::enterprise_management::DownloadCertRequest* ClientCertificateProvisioningRequest::_internal_mutable_download_cert_request() {
  if (!_internal_has_download_cert_request()) {
    clear_request();
    set_has_download_cert_request();
    _impl_.request_.download_cert_request_ = CreateMaybeMessage< ::enterprise_management::DownloadCertRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.download_cert_request_;
}
inline ::enterprise_management::DownloadCertRequest* ClientCertificateProvisioningRequest::mutable_download_cert_request() {
  ::enterprise_management::DownloadCertRequest* _msg = _internal_mutable_download_cert_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
  return _msg;
}

// .enterprise_management.CertProvStartOrContinueRequest start_or_continue_request = 9;
inline bool ClientCertificateProvisioningRequest::_internal_has_start_or_continue_request() const {
  return request_case() == kStartOrContinueRequest;
}
inline bool ClientCertificateProvisioningRequest::has_start_or_continue_request() const {
  return _internal_has_start_or_continue_request();
}
inline void ClientCertificateProvisioningRequest::set_has_start_or_continue_request() {
  _impl_._oneof_case_[0] = kStartOrContinueRequest;
}
inline void ClientCertificateProvisioningRequest::clear_start_or_continue_request() {
  if (_internal_has_start_or_continue_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.start_or_continue_request_;
    }
    clear_has_request();
  }
}
inline ::enterprise_management::CertProvStartOrContinueRequest* ClientCertificateProvisioningRequest::release_start_or_continue_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.start_or_continue_request)
  if (_internal_has_start_or_continue_request()) {
    clear_has_request();
    ::enterprise_management::CertProvStartOrContinueRequest* temp = _impl_.request_.start_or_continue_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.start_or_continue_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::CertProvStartOrContinueRequest& ClientCertificateProvisioningRequest::_internal_start_or_continue_request() const {
  return _internal_has_start_or_continue_request()
      ? *_impl_.request_.start_or_continue_request_
      : reinterpret_cast< ::enterprise_management::CertProvStartOrContinueRequest&>(::enterprise_management::_CertProvStartOrContinueRequest_default_instance_);
}
inline const ::enterprise_management::CertProvStartOrContinueRequest& ClientCertificateProvisioningRequest::start_or_continue_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.start_or_continue_request)
  return _internal_start_or_continue_request();
}
inline ::enterprise_management::CertProvStartOrContinueRequest* ClientCertificateProvisioningRequest::unsafe_arena_release_start_or_continue_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningRequest.start_or_continue_request)
  if (_internal_has_start_or_continue_request()) {
    clear_has_request();
    ::enterprise_management::CertProvStartOrContinueRequest* temp = _impl_.request_.start_or_continue_request_;
    _impl_.request_.start_or_continue_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningRequest::unsafe_arena_set_allocated_start_or_continue_request(::enterprise_management::CertProvStartOrContinueRequest* start_or_continue_request) {
  clear_request();
  if (start_or_continue_request) {
    set_has_start_or_continue_request();
    _impl_.request_.start_or_continue_request_ = start_or_continue_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.start_or_continue_request)
}
inline ::enterprise_management::CertProvStartOrContinueRequest* ClientCertificateProvisioningRequest::_internal_mutable_start_or_continue_request() {
  if (!_internal_has_start_or_continue_request()) {
    clear_request();
    set_has_start_or_continue_request();
    _impl_.request_.start_or_continue_request_ = CreateMaybeMessage< ::enterprise_management::CertProvStartOrContinueRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.start_or_continue_request_;
}
inline ::enterprise_management::CertProvStartOrContinueRequest* ClientCertificateProvisioningRequest::mutable_start_or_continue_request() {
  ::enterprise_management::CertProvStartOrContinueRequest* _msg = _internal_mutable_start_or_continue_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.start_or_continue_request)
  return _msg;
}

// .enterprise_management.CertProvAuthorizeRequest authorize_request = 10;
inline bool ClientCertificateProvisioningRequest::_internal_has_authorize_request() const {
  return request_case() == kAuthorizeRequest;
}
inline bool ClientCertificateProvisioningRequest::has_authorize_request() const {
  return _internal_has_authorize_request();
}
inline void ClientCertificateProvisioningRequest::set_has_authorize_request() {
  _impl_._oneof_case_[0] = kAuthorizeRequest;
}
inline void ClientCertificateProvisioningRequest::clear_authorize_request() {
  if (_internal_has_authorize_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.authorize_request_;
    }
    clear_has_request();
  }
}
inline ::enterprise_management::CertProvAuthorizeRequest* ClientCertificateProvisioningRequest::release_authorize_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.authorize_request)
  if (_internal_has_authorize_request()) {
    clear_has_request();
    ::enterprise_management::CertProvAuthorizeRequest* temp = _impl_.request_.authorize_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.authorize_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::CertProvAuthorizeRequest& ClientCertificateProvisioningRequest::_internal_authorize_request() const {
  return _internal_has_authorize_request()
      ? *_impl_.request_.authorize_request_
      : reinterpret_cast< ::enterprise_management::CertProvAuthorizeRequest&>(::enterprise_management::_CertProvAuthorizeRequest_default_instance_);
}
inline const ::enterprise_management::CertProvAuthorizeRequest& ClientCertificateProvisioningRequest::authorize_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.authorize_request)
  return _internal_authorize_request();
}
inline ::enterprise_management::CertProvAuthorizeRequest* ClientCertificateProvisioningRequest::unsafe_arena_release_authorize_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningRequest.authorize_request)
  if (_internal_has_authorize_request()) {
    clear_has_request();
    ::enterprise_management::CertProvAuthorizeRequest* temp = _impl_.request_.authorize_request_;
    _impl_.request_.authorize_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningRequest::unsafe_arena_set_allocated_authorize_request(::enterprise_management::CertProvAuthorizeRequest* authorize_request) {
  clear_request();
  if (authorize_request) {
    set_has_authorize_request();
    _impl_.request_.authorize_request_ = authorize_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.authorize_request)
}
inline ::enterprise_management::CertProvAuthorizeRequest* ClientCertificateProvisioningRequest::_internal_mutable_authorize_request() {
  if (!_internal_has_authorize_request()) {
    clear_request();
    set_has_authorize_request();
    _impl_.request_.authorize_request_ = CreateMaybeMessage< ::enterprise_management::CertProvAuthorizeRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.authorize_request_;
}
inline ::enterprise_management::CertProvAuthorizeRequest* ClientCertificateProvisioningRequest::mutable_authorize_request() {
  ::enterprise_management::CertProvAuthorizeRequest* _msg = _internal_mutable_authorize_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.authorize_request)
  return _msg;
}

// .enterprise_management.CertProvUploadProofOfPossessionRequest upload_proof_of_possession_request = 11;
inline bool ClientCertificateProvisioningRequest::_internal_has_upload_proof_of_possession_request() const {
  return request_case() == kUploadProofOfPossessionRequest;
}
inline bool ClientCertificateProvisioningRequest::has_upload_proof_of_possession_request() const {
  return _internal_has_upload_proof_of_possession_request();
}
inline void ClientCertificateProvisioningRequest::set_has_upload_proof_of_possession_request() {
  _impl_._oneof_case_[0] = kUploadProofOfPossessionRequest;
}
inline void ClientCertificateProvisioningRequest::clear_upload_proof_of_possession_request() {
  if (_internal_has_upload_proof_of_possession_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.upload_proof_of_possession_request_;
    }
    clear_has_request();
  }
}
inline ::enterprise_management::CertProvUploadProofOfPossessionRequest* ClientCertificateProvisioningRequest::release_upload_proof_of_possession_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.upload_proof_of_possession_request)
  if (_internal_has_upload_proof_of_possession_request()) {
    clear_has_request();
    ::enterprise_management::CertProvUploadProofOfPossessionRequest* temp = _impl_.request_.upload_proof_of_possession_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.upload_proof_of_possession_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::CertProvUploadProofOfPossessionRequest& ClientCertificateProvisioningRequest::_internal_upload_proof_of_possession_request() const {
  return _internal_has_upload_proof_of_possession_request()
      ? *_impl_.request_.upload_proof_of_possession_request_
      : reinterpret_cast< ::enterprise_management::CertProvUploadProofOfPossessionRequest&>(::enterprise_management::_CertProvUploadProofOfPossessionRequest_default_instance_);
}
inline const ::enterprise_management::CertProvUploadProofOfPossessionRequest& ClientCertificateProvisioningRequest::upload_proof_of_possession_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.upload_proof_of_possession_request)
  return _internal_upload_proof_of_possession_request();
}
inline ::enterprise_management::CertProvUploadProofOfPossessionRequest* ClientCertificateProvisioningRequest::unsafe_arena_release_upload_proof_of_possession_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningRequest.upload_proof_of_possession_request)
  if (_internal_has_upload_proof_of_possession_request()) {
    clear_has_request();
    ::enterprise_management::CertProvUploadProofOfPossessionRequest* temp = _impl_.request_.upload_proof_of_possession_request_;
    _impl_.request_.upload_proof_of_possession_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningRequest::unsafe_arena_set_allocated_upload_proof_of_possession_request(::enterprise_management::CertProvUploadProofOfPossessionRequest* upload_proof_of_possession_request) {
  clear_request();
  if (upload_proof_of_possession_request) {
    set_has_upload_proof_of_possession_request();
    _impl_.request_.upload_proof_of_possession_request_ = upload_proof_of_possession_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.upload_proof_of_possession_request)
}
inline ::enterprise_management::CertProvUploadProofOfPossessionRequest* ClientCertificateProvisioningRequest::_internal_mutable_upload_proof_of_possession_request() {
  if (!_internal_has_upload_proof_of_possession_request()) {
    clear_request();
    set_has_upload_proof_of_possession_request();
    _impl_.request_.upload_proof_of_possession_request_ = CreateMaybeMessage< ::enterprise_management::CertProvUploadProofOfPossessionRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.upload_proof_of_possession_request_;
}
inline ::enterprise_management::CertProvUploadProofOfPossessionRequest* ClientCertificateProvisioningRequest::mutable_upload_proof_of_possession_request() {
  ::enterprise_management::CertProvUploadProofOfPossessionRequest* _msg = _internal_mutable_upload_proof_of_possession_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.upload_proof_of_possession_request)
  return _msg;
}

// optional bytes policy_version = 8;
inline bool ClientCertificateProvisioningRequest::_internal_has_policy_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ClientCertificateProvisioningRequest::has_policy_version() const {
  return _internal_has_policy_version();
}
inline void ClientCertificateProvisioningRequest::clear_policy_version() {
  _impl_.policy_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ClientCertificateProvisioningRequest::policy_version() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
  return _internal_policy_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientCertificateProvisioningRequest::set_policy_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.policy_version_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
}
inline std::string* ClientCertificateProvisioningRequest::mutable_policy_version() {
  std::string* _s = _internal_mutable_policy_version();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
  return _s;
}
inline const std::string& ClientCertificateProvisioningRequest::_internal_policy_version() const {
  return _impl_.policy_version_.Get();
}
inline void ClientCertificateProvisioningRequest::_internal_set_policy_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.policy_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::_internal_mutable_policy_version() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.policy_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientCertificateProvisioningRequest::release_policy_version() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
  if (!_internal_has_policy_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.policy_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_version_.IsDefault()) {
    _impl_.policy_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientCertificateProvisioningRequest::set_allocated_policy_version(std::string* policy_version) {
  if (policy_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.policy_version_.SetAllocated(policy_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_version_.IsDefault()) {
    _impl_.policy_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.policy_version)
}

inline bool ClientCertificateProvisioningRequest::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void ClientCertificateProvisioningRequest::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline ClientCertificateProvisioningRequest::RequestCase ClientCertificateProvisioningRequest::request_case() const {
  return ClientCertificateProvisioningRequest::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientCertificateProvisioningResponse

// optional int64 try_again_later = 1;
inline bool ClientCertificateProvisioningResponse::_internal_has_try_again_later() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientCertificateProvisioningResponse::has_try_again_later() const {
  return _internal_has_try_again_later();
}
inline void ClientCertificateProvisioningResponse::clear_try_again_later() {
  _impl_.try_again_later_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ClientCertificateProvisioningResponse::_internal_try_again_later() const {
  return _impl_.try_again_later_;
}
inline int64_t ClientCertificateProvisioningResponse::try_again_later() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.try_again_later)
  return _internal_try_again_later();
}
inline void ClientCertificateProvisioningResponse::_internal_set_try_again_later(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.try_again_later_ = value;
}
inline void ClientCertificateProvisioningResponse::set_try_again_later(int64_t value) {
  _internal_set_try_again_later(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningResponse.try_again_later)
}

// .enterprise_management.ClientCertificateProvisioningResponse.Error error = 2;
inline bool ClientCertificateProvisioningResponse::_internal_has_error() const {
  return response_case() == kError;
}
inline bool ClientCertificateProvisioningResponse::has_error() const {
  return _internal_has_error();
}
inline void ClientCertificateProvisioningResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void ClientCertificateProvisioningResponse::clear_error() {
  if (_internal_has_error()) {
    _impl_.response_.error_ = 0;
    clear_has_response();
  }
}
inline ::enterprise_management::ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::_internal_error() const {
  if (_internal_has_error()) {
    return static_cast< ::enterprise_management::ClientCertificateProvisioningResponse_Error >(_impl_.response_.error_);
  }
  return static_cast< ::enterprise_management::ClientCertificateProvisioningResponse_Error >(0);
}
inline ::enterprise_management::ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::error() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.error)
  return _internal_error();
}
inline void ClientCertificateProvisioningResponse::_internal_set_error(::enterprise_management::ClientCertificateProvisioningResponse_Error value) {
  assert(::enterprise_management::ClientCertificateProvisioningResponse_Error_IsValid(value));
  if (!_internal_has_error()) {
    clear_response();
    set_has_error();
  }
  _impl_.response_.error_ = value;
}
inline void ClientCertificateProvisioningResponse::set_error(::enterprise_management::ClientCertificateProvisioningResponse_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:enterprise_management.ClientCertificateProvisioningResponse.error)
}

// .enterprise_management.StartCsrResponse start_csr_response = 3;
inline bool ClientCertificateProvisioningResponse::_internal_has_start_csr_response() const {
  return response_case() == kStartCsrResponse;
}
inline bool ClientCertificateProvisioningResponse::has_start_csr_response() const {
  return _internal_has_start_csr_response();
}
inline void ClientCertificateProvisioningResponse::set_has_start_csr_response() {
  _impl_._oneof_case_[0] = kStartCsrResponse;
}
inline void ClientCertificateProvisioningResponse::clear_start_csr_response() {
  if (_internal_has_start_csr_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.start_csr_response_;
    }
    clear_has_response();
  }
}
inline ::enterprise_management::StartCsrResponse* ClientCertificateProvisioningResponse::release_start_csr_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
  if (_internal_has_start_csr_response()) {
    clear_has_response();
    ::enterprise_management::StartCsrResponse* temp = _impl_.response_.start_csr_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.start_csr_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::StartCsrResponse& ClientCertificateProvisioningResponse::_internal_start_csr_response() const {
  return _internal_has_start_csr_response()
      ? *_impl_.response_.start_csr_response_
      : reinterpret_cast< ::enterprise_management::StartCsrResponse&>(::enterprise_management::_StartCsrResponse_default_instance_);
}
inline const ::enterprise_management::StartCsrResponse& ClientCertificateProvisioningResponse::start_csr_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
  return _internal_start_csr_response();
}
inline ::enterprise_management::StartCsrResponse* ClientCertificateProvisioningResponse::unsafe_arena_release_start_csr_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
  if (_internal_has_start_csr_response()) {
    clear_has_response();
    ::enterprise_management::StartCsrResponse* temp = _impl_.response_.start_csr_response_;
    _impl_.response_.start_csr_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningResponse::unsafe_arena_set_allocated_start_csr_response(::enterprise_management::StartCsrResponse* start_csr_response) {
  clear_response();
  if (start_csr_response) {
    set_has_start_csr_response();
    _impl_.response_.start_csr_response_ = start_csr_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
}
inline ::enterprise_management::StartCsrResponse* ClientCertificateProvisioningResponse::_internal_mutable_start_csr_response() {
  if (!_internal_has_start_csr_response()) {
    clear_response();
    set_has_start_csr_response();
    _impl_.response_.start_csr_response_ = CreateMaybeMessage< ::enterprise_management::StartCsrResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.start_csr_response_;
}
inline ::enterprise_management::StartCsrResponse* ClientCertificateProvisioningResponse::mutable_start_csr_response() {
  ::enterprise_management::StartCsrResponse* _msg = _internal_mutable_start_csr_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
  return _msg;
}

// .enterprise_management.FinishCsrResponse finish_csr_response = 4;
inline bool ClientCertificateProvisioningResponse::_internal_has_finish_csr_response() const {
  return response_case() == kFinishCsrResponse;
}
inline bool ClientCertificateProvisioningResponse::has_finish_csr_response() const {
  return _internal_has_finish_csr_response();
}
inline void ClientCertificateProvisioningResponse::set_has_finish_csr_response() {
  _impl_._oneof_case_[0] = kFinishCsrResponse;
}
inline void ClientCertificateProvisioningResponse::clear_finish_csr_response() {
  if (_internal_has_finish_csr_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.finish_csr_response_;
    }
    clear_has_response();
  }
}
inline ::enterprise_management::FinishCsrResponse* ClientCertificateProvisioningResponse::release_finish_csr_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
  if (_internal_has_finish_csr_response()) {
    clear_has_response();
    ::enterprise_management::FinishCsrResponse* temp = _impl_.response_.finish_csr_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.finish_csr_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::FinishCsrResponse& ClientCertificateProvisioningResponse::_internal_finish_csr_response() const {
  return _internal_has_finish_csr_response()
      ? *_impl_.response_.finish_csr_response_
      : reinterpret_cast< ::enterprise_management::FinishCsrResponse&>(::enterprise_management::_FinishCsrResponse_default_instance_);
}
inline const ::enterprise_management::FinishCsrResponse& ClientCertificateProvisioningResponse::finish_csr_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
  return _internal_finish_csr_response();
}
inline ::enterprise_management::FinishCsrResponse* ClientCertificateProvisioningResponse::unsafe_arena_release_finish_csr_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
  if (_internal_has_finish_csr_response()) {
    clear_has_response();
    ::enterprise_management::FinishCsrResponse* temp = _impl_.response_.finish_csr_response_;
    _impl_.response_.finish_csr_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningResponse::unsafe_arena_set_allocated_finish_csr_response(::enterprise_management::FinishCsrResponse* finish_csr_response) {
  clear_response();
  if (finish_csr_response) {
    set_has_finish_csr_response();
    _impl_.response_.finish_csr_response_ = finish_csr_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
}
inline ::enterprise_management::FinishCsrResponse* ClientCertificateProvisioningResponse::_internal_mutable_finish_csr_response() {
  if (!_internal_has_finish_csr_response()) {
    clear_response();
    set_has_finish_csr_response();
    _impl_.response_.finish_csr_response_ = CreateMaybeMessage< ::enterprise_management::FinishCsrResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.finish_csr_response_;
}
inline ::enterprise_management::FinishCsrResponse* ClientCertificateProvisioningResponse::mutable_finish_csr_response() {
  ::enterprise_management::FinishCsrResponse* _msg = _internal_mutable_finish_csr_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
  return _msg;
}

// .enterprise_management.DownloadCertResponse download_cert_response = 5;
inline bool ClientCertificateProvisioningResponse::_internal_has_download_cert_response() const {
  return response_case() == kDownloadCertResponse;
}
inline bool ClientCertificateProvisioningResponse::has_download_cert_response() const {
  return _internal_has_download_cert_response();
}
inline void ClientCertificateProvisioningResponse::set_has_download_cert_response() {
  _impl_._oneof_case_[0] = kDownloadCertResponse;
}
inline void ClientCertificateProvisioningResponse::clear_download_cert_response() {
  if (_internal_has_download_cert_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.download_cert_response_;
    }
    clear_has_response();
  }
}
inline ::enterprise_management::DownloadCertResponse* ClientCertificateProvisioningResponse::release_download_cert_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
  if (_internal_has_download_cert_response()) {
    clear_has_response();
    ::enterprise_management::DownloadCertResponse* temp = _impl_.response_.download_cert_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.download_cert_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::DownloadCertResponse& ClientCertificateProvisioningResponse::_internal_download_cert_response() const {
  return _internal_has_download_cert_response()
      ? *_impl_.response_.download_cert_response_
      : reinterpret_cast< ::enterprise_management::DownloadCertResponse&>(::enterprise_management::_DownloadCertResponse_default_instance_);
}
inline const ::enterprise_management::DownloadCertResponse& ClientCertificateProvisioningResponse::download_cert_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
  return _internal_download_cert_response();
}
inline ::enterprise_management::DownloadCertResponse* ClientCertificateProvisioningResponse::unsafe_arena_release_download_cert_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
  if (_internal_has_download_cert_response()) {
    clear_has_response();
    ::enterprise_management::DownloadCertResponse* temp = _impl_.response_.download_cert_response_;
    _impl_.response_.download_cert_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningResponse::unsafe_arena_set_allocated_download_cert_response(::enterprise_management::DownloadCertResponse* download_cert_response) {
  clear_response();
  if (download_cert_response) {
    set_has_download_cert_response();
    _impl_.response_.download_cert_response_ = download_cert_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
}
inline ::enterprise_management::DownloadCertResponse* ClientCertificateProvisioningResponse::_internal_mutable_download_cert_response() {
  if (!_internal_has_download_cert_response()) {
    clear_response();
    set_has_download_cert_response();
    _impl_.response_.download_cert_response_ = CreateMaybeMessage< ::enterprise_management::DownloadCertResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.download_cert_response_;
}
inline ::enterprise_management::DownloadCertResponse* ClientCertificateProvisioningResponse::mutable_download_cert_response() {
  ::enterprise_management::DownloadCertResponse* _msg = _internal_mutable_download_cert_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
  return _msg;
}

// .enterprise_management.CertProvNextActionResponse next_action_response = 6;
inline bool ClientCertificateProvisioningResponse::_internal_has_next_action_response() const {
  return response_case() == kNextActionResponse;
}
inline bool ClientCertificateProvisioningResponse::has_next_action_response() const {
  return _internal_has_next_action_response();
}
inline void ClientCertificateProvisioningResponse::set_has_next_action_response() {
  _impl_._oneof_case_[0] = kNextActionResponse;
}
inline void ClientCertificateProvisioningResponse::clear_next_action_response() {
  if (_internal_has_next_action_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.next_action_response_;
    }
    clear_has_response();
  }
}
inline ::enterprise_management::CertProvNextActionResponse* ClientCertificateProvisioningResponse::release_next_action_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.ClientCertificateProvisioningResponse.next_action_response)
  if (_internal_has_next_action_response()) {
    clear_has_response();
    ::enterprise_management::CertProvNextActionResponse* temp = _impl_.response_.next_action_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.next_action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::enterprise_management::CertProvNextActionResponse& ClientCertificateProvisioningResponse::_internal_next_action_response() const {
  return _internal_has_next_action_response()
      ? *_impl_.response_.next_action_response_
      : reinterpret_cast< ::enterprise_management::CertProvNextActionResponse&>(::enterprise_management::_CertProvNextActionResponse_default_instance_);
}
inline const ::enterprise_management::CertProvNextActionResponse& ClientCertificateProvisioningResponse::next_action_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.ClientCertificateProvisioningResponse.next_action_response)
  return _internal_next_action_response();
}
inline ::enterprise_management::CertProvNextActionResponse* ClientCertificateProvisioningResponse::unsafe_arena_release_next_action_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:enterprise_management.ClientCertificateProvisioningResponse.next_action_response)
  if (_internal_has_next_action_response()) {
    clear_has_response();
    ::enterprise_management::CertProvNextActionResponse* temp = _impl_.response_.next_action_response_;
    _impl_.response_.next_action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientCertificateProvisioningResponse::unsafe_arena_set_allocated_next_action_response(::enterprise_management::CertProvNextActionResponse* next_action_response) {
  clear_response();
  if (next_action_response) {
    set_has_next_action_response();
    _impl_.response_.next_action_response_ = next_action_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.ClientCertificateProvisioningResponse.next_action_response)
}
inline ::enterprise_management::CertProvNextActionResponse* ClientCertificateProvisioningResponse::_internal_mutable_next_action_response() {
  if (!_internal_has_next_action_response()) {
    clear_response();
    set_has_next_action_response();
    _impl_.response_.next_action_response_ = CreateMaybeMessage< ::enterprise_management::CertProvNextActionResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.next_action_response_;
}
inline ::enterprise_management::CertProvNextActionResponse* ClientCertificateProvisioningResponse::mutable_next_action_response() {
  ::enterprise_management::CertProvNextActionResponse* _msg = _internal_mutable_next_action_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.ClientCertificateProvisioningResponse.next_action_response)
  return _msg;
}

inline bool ClientCertificateProvisioningResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ClientCertificateProvisioningResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ClientCertificateProvisioningResponse::ResponseCase ClientCertificateProvisioningResponse::response_case() const {
  return ClientCertificateProvisioningResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BrowserPublicKeyUploadRequest

// optional bytes public_key = 1;
inline bool BrowserPublicKeyUploadRequest::_internal_has_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BrowserPublicKeyUploadRequest::has_public_key() const {
  return _internal_has_public_key();
}
inline void BrowserPublicKeyUploadRequest::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BrowserPublicKeyUploadRequest::public_key() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserPublicKeyUploadRequest.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BrowserPublicKeyUploadRequest::set_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserPublicKeyUploadRequest.public_key)
}
inline std::string* BrowserPublicKeyUploadRequest::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserPublicKeyUploadRequest.public_key)
  return _s;
}
inline const std::string& BrowserPublicKeyUploadRequest::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void BrowserPublicKeyUploadRequest::_internal_set_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* BrowserPublicKeyUploadRequest::_internal_mutable_public_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* BrowserPublicKeyUploadRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:enterprise_management.BrowserPublicKeyUploadRequest.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BrowserPublicKeyUploadRequest::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserPublicKeyUploadRequest.public_key)
}

// optional bytes signature = 2;
inline bool BrowserPublicKeyUploadRequest::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BrowserPublicKeyUploadRequest::has_signature() const {
  return _internal_has_signature();
}
inline void BrowserPublicKeyUploadRequest::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BrowserPublicKeyUploadRequest::signature() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserPublicKeyUploadRequest.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BrowserPublicKeyUploadRequest::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserPublicKeyUploadRequest.signature)
}
inline std::string* BrowserPublicKeyUploadRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:enterprise_management.BrowserPublicKeyUploadRequest.signature)
  return _s;
}
inline const std::string& BrowserPublicKeyUploadRequest::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void BrowserPublicKeyUploadRequest::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* BrowserPublicKeyUploadRequest::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* BrowserPublicKeyUploadRequest::release_signature() {
  // @@protoc_insertion_point(field_release:enterprise_management.BrowserPublicKeyUploadRequest.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BrowserPublicKeyUploadRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.BrowserPublicKeyUploadRequest.signature)
}

// optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyTrustLevel key_trust_level = 3;
inline bool BrowserPublicKeyUploadRequest::_internal_has_key_trust_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BrowserPublicKeyUploadRequest::has_key_trust_level() const {
  return _internal_has_key_trust_level();
}
inline void BrowserPublicKeyUploadRequest::clear_key_trust_level() {
  _impl_.key_trust_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest::_internal_key_trust_level() const {
  return static_cast< ::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel >(_impl_.key_trust_level_);
}
inline ::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest::key_trust_level() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserPublicKeyUploadRequest.key_trust_level)
  return _internal_key_trust_level();
}
inline void BrowserPublicKeyUploadRequest::_internal_set_key_trust_level(::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel value) {
  assert(::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.key_trust_level_ = value;
}
inline void BrowserPublicKeyUploadRequest::set_key_trust_level(::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel value) {
  _internal_set_key_trust_level(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserPublicKeyUploadRequest.key_trust_level)
}

// optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyType key_type = 4;
inline bool BrowserPublicKeyUploadRequest::_internal_has_key_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BrowserPublicKeyUploadRequest::has_key_type() const {
  return _internal_has_key_type();
}
inline void BrowserPublicKeyUploadRequest::clear_key_type() {
  _impl_.key_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_management::BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest::_internal_key_type() const {
  return static_cast< ::enterprise_management::BrowserPublicKeyUploadRequest_KeyType >(_impl_.key_type_);
}
inline ::enterprise_management::BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest::key_type() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserPublicKeyUploadRequest.key_type)
  return _internal_key_type();
}
inline void BrowserPublicKeyUploadRequest::_internal_set_key_type(::enterprise_management::BrowserPublicKeyUploadRequest_KeyType value) {
  assert(::enterprise_management::BrowserPublicKeyUploadRequest_KeyType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.key_type_ = value;
}
inline void BrowserPublicKeyUploadRequest::set_key_type(::enterprise_management::BrowserPublicKeyUploadRequest_KeyType value) {
  _internal_set_key_type(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserPublicKeyUploadRequest.key_type)
}

// -------------------------------------------------------------------

// BrowserPublicKeyUploadResponse

// optional .enterprise_management.BrowserPublicKeyUploadResponse.ResponseCode response_code = 1;
inline bool BrowserPublicKeyUploadResponse::_internal_has_response_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BrowserPublicKeyUploadResponse::has_response_code() const {
  return _internal_has_response_code();
}
inline void BrowserPublicKeyUploadResponse::clear_response_code() {
  _impl_.response_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse::_internal_response_code() const {
  return static_cast< ::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode >(_impl_.response_code_);
}
inline ::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse::response_code() const {
  // @@protoc_insertion_point(field_get:enterprise_management.BrowserPublicKeyUploadResponse.response_code)
  return _internal_response_code();
}
inline void BrowserPublicKeyUploadResponse::_internal_set_response_code(::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode value) {
  assert(::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_code_ = value;
}
inline void BrowserPublicKeyUploadResponse::set_response_code(::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode value) {
  _internal_set_response_code(value);
  // @@protoc_insertion_point(field_set:enterprise_management.BrowserPublicKeyUploadResponse.response_code)
}

// -------------------------------------------------------------------

// DeviceManagementRequest

// optional .enterprise_management.DeviceRegisterRequest register_request = 1;
inline bool DeviceManagementRequest::_internal_has_register_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.register_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_register_request() const {
  return _internal_has_register_request();
}
inline void DeviceManagementRequest::clear_register_request() {
  if (_impl_.register_request_ != nullptr) _impl_.register_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_management::DeviceRegisterRequest& DeviceManagementRequest::_internal_register_request() const {
  const ::enterprise_management::DeviceRegisterRequest* p = _impl_.register_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRegisterRequest&>(
      ::enterprise_management::_DeviceRegisterRequest_default_instance_);
}
inline const ::enterprise_management::DeviceRegisterRequest& DeviceManagementRequest::register_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.register_request)
  return _internal_register_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_register_request(
    ::enterprise_management::DeviceRegisterRequest* register_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.register_request_);
  }
  _impl_.register_request_ = register_request;
  if (register_request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.register_request)
}
inline ::enterprise_management::DeviceRegisterRequest* DeviceManagementRequest::release_register_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DeviceRegisterRequest* temp = _impl_.register_request_;
  _impl_.register_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRegisterRequest* DeviceManagementRequest::unsafe_arena_release_register_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.register_request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::enterprise_management::DeviceRegisterRequest* temp = _impl_.register_request_;
  _impl_.register_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRegisterRequest* DeviceManagementRequest::_internal_mutable_register_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.register_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterRequest>(GetArenaForAllocation());
    _impl_.register_request_ = p;
  }
  return _impl_.register_request_;
}
inline ::enterprise_management::DeviceRegisterRequest* DeviceManagementRequest::mutable_register_request() {
  ::enterprise_management::DeviceRegisterRequest* _msg = _internal_mutable_register_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.register_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_register_request(::enterprise_management::DeviceRegisterRequest* register_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.register_request_;
  }
  if (register_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(register_request);
    if (message_arena != submessage_arena) {
      register_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, register_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.register_request_ = register_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.register_request)
}

// optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
inline bool DeviceManagementRequest::_internal_has_unregister_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unregister_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_unregister_request() const {
  return _internal_has_unregister_request();
}
inline void DeviceManagementRequest::clear_unregister_request() {
  if (_impl_.unregister_request_ != nullptr) _impl_.unregister_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DeviceUnregisterRequest& DeviceManagementRequest::_internal_unregister_request() const {
  const ::enterprise_management::DeviceUnregisterRequest* p = _impl_.unregister_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceUnregisterRequest&>(
      ::enterprise_management::_DeviceUnregisterRequest_default_instance_);
}
inline const ::enterprise_management::DeviceUnregisterRequest& DeviceManagementRequest::unregister_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.unregister_request)
  return _internal_unregister_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_unregister_request(
    ::enterprise_management::DeviceUnregisterRequest* unregister_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unregister_request_);
  }
  _impl_.unregister_request_ = unregister_request;
  if (unregister_request) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.unregister_request)
}
inline ::enterprise_management::DeviceUnregisterRequest* DeviceManagementRequest::release_unregister_request() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DeviceUnregisterRequest* temp = _impl_.unregister_request_;
  _impl_.unregister_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceUnregisterRequest* DeviceManagementRequest::unsafe_arena_release_unregister_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.unregister_request)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DeviceUnregisterRequest* temp = _impl_.unregister_request_;
  _impl_.unregister_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceUnregisterRequest* DeviceManagementRequest::_internal_mutable_unregister_request() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.unregister_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceUnregisterRequest>(GetArenaForAllocation());
    _impl_.unregister_request_ = p;
  }
  return _impl_.unregister_request_;
}
inline ::enterprise_management::DeviceUnregisterRequest* DeviceManagementRequest::mutable_unregister_request() {
  ::enterprise_management::DeviceUnregisterRequest* _msg = _internal_mutable_unregister_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.unregister_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_unregister_request(::enterprise_management::DeviceUnregisterRequest* unregister_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.unregister_request_;
  }
  if (unregister_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unregister_request);
    if (message_arena != submessage_arena) {
      unregister_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unregister_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.unregister_request_ = unregister_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.unregister_request)
}

// optional .enterprise_management.DevicePolicyRequest policy_request = 3;
inline bool DeviceManagementRequest::_internal_has_policy_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.policy_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_policy_request() const {
  return _internal_has_policy_request();
}
inline void DeviceManagementRequest::clear_policy_request() {
  if (_impl_.policy_request_ != nullptr) _impl_.policy_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::DevicePolicyRequest& DeviceManagementRequest::_internal_policy_request() const {
  const ::enterprise_management::DevicePolicyRequest* p = _impl_.policy_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePolicyRequest&>(
      ::enterprise_management::_DevicePolicyRequest_default_instance_);
}
inline const ::enterprise_management::DevicePolicyRequest& DeviceManagementRequest::policy_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.policy_request)
  return _internal_policy_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_policy_request(
    ::enterprise_management::DevicePolicyRequest* policy_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.policy_request_);
  }
  _impl_.policy_request_ = policy_request;
  if (policy_request) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.policy_request)
}
inline ::enterprise_management::DevicePolicyRequest* DeviceManagementRequest::release_policy_request() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::DevicePolicyRequest* temp = _impl_.policy_request_;
  _impl_.policy_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePolicyRequest* DeviceManagementRequest::unsafe_arena_release_policy_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.policy_request)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::DevicePolicyRequest* temp = _impl_.policy_request_;
  _impl_.policy_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePolicyRequest* DeviceManagementRequest::_internal_mutable_policy_request() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.policy_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePolicyRequest>(GetArenaForAllocation());
    _impl_.policy_request_ = p;
  }
  return _impl_.policy_request_;
}
inline ::enterprise_management::DevicePolicyRequest* DeviceManagementRequest::mutable_policy_request() {
  ::enterprise_management::DevicePolicyRequest* _msg = _internal_mutable_policy_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.policy_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_policy_request(::enterprise_management::DevicePolicyRequest* policy_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.policy_request_;
  }
  if (policy_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(policy_request);
    if (message_arena != submessage_arena) {
      policy_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policy_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.policy_request_ = policy_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.policy_request)
}

// optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
inline bool DeviceManagementRequest::_internal_has_device_status_report_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_status_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_device_status_report_request() const {
  return _internal_has_device_status_report_request();
}
inline void DeviceManagementRequest::clear_device_status_report_request() {
  if (_impl_.device_status_report_request_ != nullptr) _impl_.device_status_report_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::DeviceStatusReportRequest& DeviceManagementRequest::_internal_device_status_report_request() const {
  const ::enterprise_management::DeviceStatusReportRequest* p = _impl_.device_status_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceStatusReportRequest&>(
      ::enterprise_management::_DeviceStatusReportRequest_default_instance_);
}
inline const ::enterprise_management::DeviceStatusReportRequest& DeviceManagementRequest::device_status_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_status_report_request)
  return _internal_device_status_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_device_status_report_request(
    ::enterprise_management::DeviceStatusReportRequest* device_status_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_status_report_request_);
  }
  _impl_.device_status_report_request_ = device_status_report_request;
  if (device_status_report_request) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.device_status_report_request)
}
inline ::enterprise_management::DeviceStatusReportRequest* DeviceManagementRequest::release_device_status_report_request() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::DeviceStatusReportRequest* temp = _impl_.device_status_report_request_;
  _impl_.device_status_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceStatusReportRequest* DeviceManagementRequest::unsafe_arena_release_device_status_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_status_report_request)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::DeviceStatusReportRequest* temp = _impl_.device_status_report_request_;
  _impl_.device_status_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceStatusReportRequest* DeviceManagementRequest::_internal_mutable_device_status_report_request() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.device_status_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceStatusReportRequest>(GetArenaForAllocation());
    _impl_.device_status_report_request_ = p;
  }
  return _impl_.device_status_report_request_;
}
inline ::enterprise_management::DeviceStatusReportRequest* DeviceManagementRequest::mutable_device_status_report_request() {
  ::enterprise_management::DeviceStatusReportRequest* _msg = _internal_mutable_device_status_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_status_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_device_status_report_request(::enterprise_management::DeviceStatusReportRequest* device_status_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_status_report_request_;
  }
  if (device_status_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_status_report_request);
    if (message_arena != submessage_arena) {
      device_status_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_status_report_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.device_status_report_request_ = device_status_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_status_report_request)
}

// optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
inline bool DeviceManagementRequest::_internal_has_session_status_report_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_status_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_session_status_report_request() const {
  return _internal_has_session_status_report_request();
}
inline void DeviceManagementRequest::clear_session_status_report_request() {
  if (_impl_.session_status_report_request_ != nullptr) _impl_.session_status_report_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::SessionStatusReportRequest& DeviceManagementRequest::_internal_session_status_report_request() const {
  const ::enterprise_management::SessionStatusReportRequest* p = _impl_.session_status_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SessionStatusReportRequest&>(
      ::enterprise_management::_SessionStatusReportRequest_default_instance_);
}
inline const ::enterprise_management::SessionStatusReportRequest& DeviceManagementRequest::session_status_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.session_status_report_request)
  return _internal_session_status_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_session_status_report_request(
    ::enterprise_management::SessionStatusReportRequest* session_status_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_status_report_request_);
  }
  _impl_.session_status_report_request_ = session_status_report_request;
  if (session_status_report_request) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.session_status_report_request)
}
inline ::enterprise_management::SessionStatusReportRequest* DeviceManagementRequest::release_session_status_report_request() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::SessionStatusReportRequest* temp = _impl_.session_status_report_request_;
  _impl_.session_status_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SessionStatusReportRequest* DeviceManagementRequest::unsafe_arena_release_session_status_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.session_status_report_request)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::SessionStatusReportRequest* temp = _impl_.session_status_report_request_;
  _impl_.session_status_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::SessionStatusReportRequest* DeviceManagementRequest::_internal_mutable_session_status_report_request() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.session_status_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SessionStatusReportRequest>(GetArenaForAllocation());
    _impl_.session_status_report_request_ = p;
  }
  return _impl_.session_status_report_request_;
}
inline ::enterprise_management::SessionStatusReportRequest* DeviceManagementRequest::mutable_session_status_report_request() {
  ::enterprise_management::SessionStatusReportRequest* _msg = _internal_mutable_session_status_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.session_status_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_session_status_report_request(::enterprise_management::SessionStatusReportRequest* session_status_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_status_report_request_;
  }
  if (session_status_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_status_report_request);
    if (message_arena != submessage_arena) {
      session_status_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_status_report_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.session_status_report_request_ = session_status_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.session_status_report_request)
}

// optional .enterprise_management.ChildStatusReportRequest child_status_report_request = 30;
inline bool DeviceManagementRequest::_internal_has_child_status_report_request() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_status_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_child_status_report_request() const {
  return _internal_has_child_status_report_request();
}
inline void DeviceManagementRequest::clear_child_status_report_request() {
  if (_impl_.child_status_report_request_ != nullptr) _impl_.child_status_report_request_->Clear();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const ::enterprise_management::ChildStatusReportRequest& DeviceManagementRequest::_internal_child_status_report_request() const {
  const ::enterprise_management::ChildStatusReportRequest* p = _impl_.child_status_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChildStatusReportRequest&>(
      ::enterprise_management::_ChildStatusReportRequest_default_instance_);
}
inline const ::enterprise_management::ChildStatusReportRequest& DeviceManagementRequest::child_status_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.child_status_report_request)
  return _internal_child_status_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_child_status_report_request(
    ::enterprise_management::ChildStatusReportRequest* child_status_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_status_report_request_);
  }
  _impl_.child_status_report_request_ = child_status_report_request;
  if (child_status_report_request) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.child_status_report_request)
}
inline ::enterprise_management::ChildStatusReportRequest* DeviceManagementRequest::release_child_status_report_request() {
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::enterprise_management::ChildStatusReportRequest* temp = _impl_.child_status_report_request_;
  _impl_.child_status_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChildStatusReportRequest* DeviceManagementRequest::unsafe_arena_release_child_status_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.child_status_report_request)
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::enterprise_management::ChildStatusReportRequest* temp = _impl_.child_status_report_request_;
  _impl_.child_status_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChildStatusReportRequest* DeviceManagementRequest::_internal_mutable_child_status_report_request() {
  _impl_._has_bits_[0] |= 0x10000000u;
  if (_impl_.child_status_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChildStatusReportRequest>(GetArenaForAllocation());
    _impl_.child_status_report_request_ = p;
  }
  return _impl_.child_status_report_request_;
}
inline ::enterprise_management::ChildStatusReportRequest* DeviceManagementRequest::mutable_child_status_report_request() {
  ::enterprise_management::ChildStatusReportRequest* _msg = _internal_mutable_child_status_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.child_status_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_child_status_report_request(::enterprise_management::ChildStatusReportRequest* child_status_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_status_report_request_;
  }
  if (child_status_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child_status_report_request);
    if (message_arena != submessage_arena) {
      child_status_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child_status_report_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.child_status_report_request_ = child_status_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.child_status_report_request)
}

// optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
inline bool DeviceManagementRequest::_internal_has_auto_enrollment_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auto_enrollment_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_auto_enrollment_request() const {
  return _internal_has_auto_enrollment_request();
}
inline void DeviceManagementRequest::clear_auto_enrollment_request() {
  if (_impl_.auto_enrollment_request_ != nullptr) _impl_.auto_enrollment_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_management::DeviceAutoEnrollmentRequest& DeviceManagementRequest::_internal_auto_enrollment_request() const {
  const ::enterprise_management::DeviceAutoEnrollmentRequest* p = _impl_.auto_enrollment_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAutoEnrollmentRequest&>(
      ::enterprise_management::_DeviceAutoEnrollmentRequest_default_instance_);
}
inline const ::enterprise_management::DeviceAutoEnrollmentRequest& DeviceManagementRequest::auto_enrollment_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
  return _internal_auto_enrollment_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_auto_enrollment_request(
    ::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auto_enrollment_request_);
  }
  _impl_.auto_enrollment_request_ = auto_enrollment_request;
  if (auto_enrollment_request) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest* DeviceManagementRequest::release_auto_enrollment_request() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::DeviceAutoEnrollmentRequest* temp = _impl_.auto_enrollment_request_;
  _impl_.auto_enrollment_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest* DeviceManagementRequest::unsafe_arena_release_auto_enrollment_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::DeviceAutoEnrollmentRequest* temp = _impl_.auto_enrollment_request_;
  _impl_.auto_enrollment_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest* DeviceManagementRequest::_internal_mutable_auto_enrollment_request() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.auto_enrollment_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAutoEnrollmentRequest>(GetArenaForAllocation());
    _impl_.auto_enrollment_request_ = p;
  }
  return _impl_.auto_enrollment_request_;
}
inline ::enterprise_management::DeviceAutoEnrollmentRequest* DeviceManagementRequest::mutable_auto_enrollment_request() {
  ::enterprise_management::DeviceAutoEnrollmentRequest* _msg = _internal_mutable_auto_enrollment_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_auto_enrollment_request(::enterprise_management::DeviceAutoEnrollmentRequest* auto_enrollment_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auto_enrollment_request_;
  }
  if (auto_enrollment_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_enrollment_request);
    if (message_arena != submessage_arena) {
      auto_enrollment_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_enrollment_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.auto_enrollment_request_ = auto_enrollment_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.auto_enrollment_request)
}

// optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
inline bool DeviceManagementRequest::_internal_has_cert_upload_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cert_upload_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_cert_upload_request() const {
  return _internal_has_cert_upload_request();
}
inline void DeviceManagementRequest::clear_cert_upload_request() {
  if (_impl_.cert_upload_request_ != nullptr) _impl_.cert_upload_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::DeviceCertUploadRequest& DeviceManagementRequest::_internal_cert_upload_request() const {
  const ::enterprise_management::DeviceCertUploadRequest* p = _impl_.cert_upload_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceCertUploadRequest&>(
      ::enterprise_management::_DeviceCertUploadRequest_default_instance_);
}
inline const ::enterprise_management::DeviceCertUploadRequest& DeviceManagementRequest::cert_upload_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.cert_upload_request)
  return _internal_cert_upload_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_cert_upload_request(
    ::enterprise_management::DeviceCertUploadRequest* cert_upload_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cert_upload_request_);
  }
  _impl_.cert_upload_request_ = cert_upload_request;
  if (cert_upload_request) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.cert_upload_request)
}
inline ::enterprise_management::DeviceCertUploadRequest* DeviceManagementRequest::release_cert_upload_request() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::DeviceCertUploadRequest* temp = _impl_.cert_upload_request_;
  _impl_.cert_upload_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceCertUploadRequest* DeviceManagementRequest::unsafe_arena_release_cert_upload_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.cert_upload_request)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::DeviceCertUploadRequest* temp = _impl_.cert_upload_request_;
  _impl_.cert_upload_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceCertUploadRequest* DeviceManagementRequest::_internal_mutable_cert_upload_request() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.cert_upload_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceCertUploadRequest>(GetArenaForAllocation());
    _impl_.cert_upload_request_ = p;
  }
  return _impl_.cert_upload_request_;
}
inline ::enterprise_management::DeviceCertUploadRequest* DeviceManagementRequest::mutable_cert_upload_request() {
  ::enterprise_management::DeviceCertUploadRequest* _msg = _internal_mutable_cert_upload_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.cert_upload_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_cert_upload_request(::enterprise_management::DeviceCertUploadRequest* cert_upload_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cert_upload_request_;
  }
  if (cert_upload_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cert_upload_request);
    if (message_arena != submessage_arena) {
      cert_upload_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cert_upload_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.cert_upload_request_ = cert_upload_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.cert_upload_request)
}

// optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
inline bool DeviceManagementRequest::_internal_has_service_api_access_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.service_api_access_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_service_api_access_request() const {
  return _internal_has_service_api_access_request();
}
inline void DeviceManagementRequest::clear_service_api_access_request() {
  if (_impl_.service_api_access_request_ != nullptr) _impl_.service_api_access_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::enterprise_management::DeviceServiceApiAccessRequest& DeviceManagementRequest::_internal_service_api_access_request() const {
  const ::enterprise_management::DeviceServiceApiAccessRequest* p = _impl_.service_api_access_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceServiceApiAccessRequest&>(
      ::enterprise_management::_DeviceServiceApiAccessRequest_default_instance_);
}
inline const ::enterprise_management::DeviceServiceApiAccessRequest& DeviceManagementRequest::service_api_access_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.service_api_access_request)
  return _internal_service_api_access_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_service_api_access_request(
    ::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_api_access_request_);
  }
  _impl_.service_api_access_request_ = service_api_access_request;
  if (service_api_access_request) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.service_api_access_request)
}
inline ::enterprise_management::DeviceServiceApiAccessRequest* DeviceManagementRequest::release_service_api_access_request() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::DeviceServiceApiAccessRequest* temp = _impl_.service_api_access_request_;
  _impl_.service_api_access_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceServiceApiAccessRequest* DeviceManagementRequest::unsafe_arena_release_service_api_access_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.service_api_access_request)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::DeviceServiceApiAccessRequest* temp = _impl_.service_api_access_request_;
  _impl_.service_api_access_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceServiceApiAccessRequest* DeviceManagementRequest::_internal_mutable_service_api_access_request() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.service_api_access_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceServiceApiAccessRequest>(GetArenaForAllocation());
    _impl_.service_api_access_request_ = p;
  }
  return _impl_.service_api_access_request_;
}
inline ::enterprise_management::DeviceServiceApiAccessRequest* DeviceManagementRequest::mutable_service_api_access_request() {
  ::enterprise_management::DeviceServiceApiAccessRequest* _msg = _internal_mutable_service_api_access_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.service_api_access_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_service_api_access_request(::enterprise_management::DeviceServiceApiAccessRequest* service_api_access_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_api_access_request_;
  }
  if (service_api_access_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_api_access_request);
    if (message_arena != submessage_arena) {
      service_api_access_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_api_access_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.service_api_access_request_ = service_api_access_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.service_api_access_request)
}

// optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
inline bool DeviceManagementRequest::_internal_has_device_state_retrieval_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_state_retrieval_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_device_state_retrieval_request() const {
  return _internal_has_device_state_retrieval_request();
}
inline void DeviceManagementRequest::clear_device_state_retrieval_request() {
  if (_impl_.device_state_retrieval_request_ != nullptr) _impl_.device_state_retrieval_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::enterprise_management::DeviceStateRetrievalRequest& DeviceManagementRequest::_internal_device_state_retrieval_request() const {
  const ::enterprise_management::DeviceStateRetrievalRequest* p = _impl_.device_state_retrieval_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceStateRetrievalRequest&>(
      ::enterprise_management::_DeviceStateRetrievalRequest_default_instance_);
}
inline const ::enterprise_management::DeviceStateRetrievalRequest& DeviceManagementRequest::device_state_retrieval_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
  return _internal_device_state_retrieval_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_device_state_retrieval_request(
    ::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_state_retrieval_request_);
  }
  _impl_.device_state_retrieval_request_ = device_state_retrieval_request;
  if (device_state_retrieval_request) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
}
inline ::enterprise_management::DeviceStateRetrievalRequest* DeviceManagementRequest::release_device_state_retrieval_request() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::DeviceStateRetrievalRequest* temp = _impl_.device_state_retrieval_request_;
  _impl_.device_state_retrieval_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceStateRetrievalRequest* DeviceManagementRequest::unsafe_arena_release_device_state_retrieval_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::DeviceStateRetrievalRequest* temp = _impl_.device_state_retrieval_request_;
  _impl_.device_state_retrieval_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceStateRetrievalRequest* DeviceManagementRequest::_internal_mutable_device_state_retrieval_request() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.device_state_retrieval_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalRequest>(GetArenaForAllocation());
    _impl_.device_state_retrieval_request_ = p;
  }
  return _impl_.device_state_retrieval_request_;
}
inline ::enterprise_management::DeviceStateRetrievalRequest* DeviceManagementRequest::mutable_device_state_retrieval_request() {
  ::enterprise_management::DeviceStateRetrievalRequest* _msg = _internal_mutable_device_state_retrieval_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_device_state_retrieval_request(::enterprise_management::DeviceStateRetrievalRequest* device_state_retrieval_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_state_retrieval_request_;
  }
  if (device_state_retrieval_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_state_retrieval_request);
    if (message_arena != submessage_arena) {
      device_state_retrieval_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_state_retrieval_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.device_state_retrieval_request_ = device_state_retrieval_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_state_retrieval_request)
}

// optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
inline bool DeviceManagementRequest::_internal_has_device_state_key_update_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_state_key_update_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_device_state_key_update_request() const {
  return _internal_has_device_state_key_update_request();
}
inline void DeviceManagementRequest::clear_device_state_key_update_request() {
  if (_impl_.device_state_key_update_request_ != nullptr) _impl_.device_state_key_update_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::enterprise_management::DeviceStateKeyUpdateRequest& DeviceManagementRequest::_internal_device_state_key_update_request() const {
  const ::enterprise_management::DeviceStateKeyUpdateRequest* p = _impl_.device_state_key_update_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceStateKeyUpdateRequest&>(
      ::enterprise_management::_DeviceStateKeyUpdateRequest_default_instance_);
}
inline const ::enterprise_management::DeviceStateKeyUpdateRequest& DeviceManagementRequest::device_state_key_update_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
  return _internal_device_state_key_update_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_device_state_key_update_request(
    ::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_state_key_update_request_);
  }
  _impl_.device_state_key_update_request_ = device_state_key_update_request;
  if (device_state_key_update_request) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
}
inline ::enterprise_management::DeviceStateKeyUpdateRequest* DeviceManagementRequest::release_device_state_key_update_request() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::DeviceStateKeyUpdateRequest* temp = _impl_.device_state_key_update_request_;
  _impl_.device_state_key_update_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceStateKeyUpdateRequest* DeviceManagementRequest::unsafe_arena_release_device_state_key_update_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::DeviceStateKeyUpdateRequest* temp = _impl_.device_state_key_update_request_;
  _impl_.device_state_key_update_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceStateKeyUpdateRequest* DeviceManagementRequest::_internal_mutable_device_state_key_update_request() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.device_state_key_update_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceStateKeyUpdateRequest>(GetArenaForAllocation());
    _impl_.device_state_key_update_request_ = p;
  }
  return _impl_.device_state_key_update_request_;
}
inline ::enterprise_management::DeviceStateKeyUpdateRequest* DeviceManagementRequest::mutable_device_state_key_update_request() {
  ::enterprise_management::DeviceStateKeyUpdateRequest* _msg = _internal_mutable_device_state_key_update_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_device_state_key_update_request(::enterprise_management::DeviceStateKeyUpdateRequest* device_state_key_update_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_state_key_update_request_;
  }
  if (device_state_key_update_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_state_key_update_request);
    if (message_arena != submessage_arena) {
      device_state_key_update_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_state_key_update_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.device_state_key_update_request_ = device_state_key_update_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_state_key_update_request)
}

// optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
inline bool DeviceManagementRequest::_internal_has_device_pairing_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_pairing_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_device_pairing_request() const {
  return _internal_has_device_pairing_request();
}
inline void DeviceManagementRequest::clear_device_pairing_request() {
  if (_impl_.device_pairing_request_ != nullptr) _impl_.device_pairing_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::DevicePairingRequest& DeviceManagementRequest::_internal_device_pairing_request() const {
  const ::enterprise_management::DevicePairingRequest* p = _impl_.device_pairing_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePairingRequest&>(
      ::enterprise_management::_DevicePairingRequest_default_instance_);
}
inline const ::enterprise_management::DevicePairingRequest& DeviceManagementRequest::device_pairing_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_pairing_request)
  return _internal_device_pairing_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_device_pairing_request(
    ::enterprise_management::DevicePairingRequest* device_pairing_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_pairing_request_);
  }
  _impl_.device_pairing_request_ = device_pairing_request;
  if (device_pairing_request) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.device_pairing_request)
}
inline ::enterprise_management::DevicePairingRequest* DeviceManagementRequest::release_device_pairing_request() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::DevicePairingRequest* temp = _impl_.device_pairing_request_;
  _impl_.device_pairing_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePairingRequest* DeviceManagementRequest::unsafe_arena_release_device_pairing_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_pairing_request)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::DevicePairingRequest* temp = _impl_.device_pairing_request_;
  _impl_.device_pairing_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePairingRequest* DeviceManagementRequest::_internal_mutable_device_pairing_request() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.device_pairing_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePairingRequest>(GetArenaForAllocation());
    _impl_.device_pairing_request_ = p;
  }
  return _impl_.device_pairing_request_;
}
inline ::enterprise_management::DevicePairingRequest* DeviceManagementRequest::mutable_device_pairing_request() {
  ::enterprise_management::DevicePairingRequest* _msg = _internal_mutable_device_pairing_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_pairing_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_device_pairing_request(::enterprise_management::DevicePairingRequest* device_pairing_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_pairing_request_;
  }
  if (device_pairing_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_pairing_request);
    if (message_arena != submessage_arena) {
      device_pairing_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_pairing_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.device_pairing_request_ = device_pairing_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_pairing_request)
}

// optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
inline bool DeviceManagementRequest::_internal_has_check_device_pairing_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_device_pairing_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_check_device_pairing_request() const {
  return _internal_has_check_device_pairing_request();
}
inline void DeviceManagementRequest::clear_check_device_pairing_request() {
  if (_impl_.check_device_pairing_request_ != nullptr) _impl_.check_device_pairing_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::CheckDevicePairingRequest& DeviceManagementRequest::_internal_check_device_pairing_request() const {
  const ::enterprise_management::CheckDevicePairingRequest* p = _impl_.check_device_pairing_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CheckDevicePairingRequest&>(
      ::enterprise_management::_CheckDevicePairingRequest_default_instance_);
}
inline const ::enterprise_management::CheckDevicePairingRequest& DeviceManagementRequest::check_device_pairing_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
  return _internal_check_device_pairing_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_check_device_pairing_request(
    ::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_device_pairing_request_);
  }
  _impl_.check_device_pairing_request_ = check_device_pairing_request;
  if (check_device_pairing_request) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
}
inline ::enterprise_management::CheckDevicePairingRequest* DeviceManagementRequest::release_check_device_pairing_request() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::CheckDevicePairingRequest* temp = _impl_.check_device_pairing_request_;
  _impl_.check_device_pairing_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CheckDevicePairingRequest* DeviceManagementRequest::unsafe_arena_release_check_device_pairing_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::CheckDevicePairingRequest* temp = _impl_.check_device_pairing_request_;
  _impl_.check_device_pairing_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::CheckDevicePairingRequest* DeviceManagementRequest::_internal_mutable_check_device_pairing_request() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.check_device_pairing_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CheckDevicePairingRequest>(GetArenaForAllocation());
    _impl_.check_device_pairing_request_ = p;
  }
  return _impl_.check_device_pairing_request_;
}
inline ::enterprise_management::CheckDevicePairingRequest* DeviceManagementRequest::mutable_check_device_pairing_request() {
  ::enterprise_management::CheckDevicePairingRequest* _msg = _internal_mutable_check_device_pairing_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_check_device_pairing_request(::enterprise_management::CheckDevicePairingRequest* check_device_pairing_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_device_pairing_request_;
  }
  if (check_device_pairing_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_device_pairing_request);
    if (message_arena != submessage_arena) {
      check_device_pairing_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_device_pairing_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.check_device_pairing_request_ = check_device_pairing_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_device_pairing_request)
}

// optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
inline bool DeviceManagementRequest::_internal_has_remote_command_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.remote_command_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_remote_command_request() const {
  return _internal_has_remote_command_request();
}
inline void DeviceManagementRequest::clear_remote_command_request() {
  if (_impl_.remote_command_request_ != nullptr) _impl_.remote_command_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::enterprise_management::DeviceRemoteCommandRequest& DeviceManagementRequest::_internal_remote_command_request() const {
  const ::enterprise_management::DeviceRemoteCommandRequest* p = _impl_.remote_command_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRemoteCommandRequest&>(
      ::enterprise_management::_DeviceRemoteCommandRequest_default_instance_);
}
inline const ::enterprise_management::DeviceRemoteCommandRequest& DeviceManagementRequest::remote_command_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.remote_command_request)
  return _internal_remote_command_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_remote_command_request(
    ::enterprise_management::DeviceRemoteCommandRequest* remote_command_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remote_command_request_);
  }
  _impl_.remote_command_request_ = remote_command_request;
  if (remote_command_request) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.remote_command_request)
}
inline ::enterprise_management::DeviceRemoteCommandRequest* DeviceManagementRequest::release_remote_command_request() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::DeviceRemoteCommandRequest* temp = _impl_.remote_command_request_;
  _impl_.remote_command_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRemoteCommandRequest* DeviceManagementRequest::unsafe_arena_release_remote_command_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.remote_command_request)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::DeviceRemoteCommandRequest* temp = _impl_.remote_command_request_;
  _impl_.remote_command_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRemoteCommandRequest* DeviceManagementRequest::_internal_mutable_remote_command_request() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.remote_command_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRemoteCommandRequest>(GetArenaForAllocation());
    _impl_.remote_command_request_ = p;
  }
  return _impl_.remote_command_request_;
}
inline ::enterprise_management::DeviceRemoteCommandRequest* DeviceManagementRequest::mutable_remote_command_request() {
  ::enterprise_management::DeviceRemoteCommandRequest* _msg = _internal_mutable_remote_command_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.remote_command_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_remote_command_request(::enterprise_management::DeviceRemoteCommandRequest* remote_command_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remote_command_request_;
  }
  if (remote_command_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remote_command_request);
    if (message_arena != submessage_arena) {
      remote_command_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remote_command_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.remote_command_request_ = remote_command_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.remote_command_request)
}

// optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
inline bool DeviceManagementRequest::_internal_has_device_attribute_update_permission_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_attribute_update_permission_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_device_attribute_update_permission_request() const {
  return _internal_has_device_attribute_update_permission_request();
}
inline void DeviceManagementRequest::clear_device_attribute_update_permission_request() {
  if (_impl_.device_attribute_update_permission_request_ != nullptr) _impl_.device_attribute_update_permission_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& DeviceManagementRequest::_internal_device_attribute_update_permission_request() const {
  const ::enterprise_management::DeviceAttributeUpdatePermissionRequest* p = _impl_.device_attribute_update_permission_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAttributeUpdatePermissionRequest&>(
      ::enterprise_management::_DeviceAttributeUpdatePermissionRequest_default_instance_);
}
inline const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& DeviceManagementRequest::device_attribute_update_permission_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
  return _internal_device_attribute_update_permission_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_device_attribute_update_permission_request(
    ::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_attribute_update_permission_request_);
  }
  _impl_.device_attribute_update_permission_request_ = device_attribute_update_permission_request;
  if (device_attribute_update_permission_request) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionRequest* DeviceManagementRequest::release_device_attribute_update_permission_request() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::DeviceAttributeUpdatePermissionRequest* temp = _impl_.device_attribute_update_permission_request_;
  _impl_.device_attribute_update_permission_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionRequest* DeviceManagementRequest::unsafe_arena_release_device_attribute_update_permission_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::DeviceAttributeUpdatePermissionRequest* temp = _impl_.device_attribute_update_permission_request_;
  _impl_.device_attribute_update_permission_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionRequest* DeviceManagementRequest::_internal_mutable_device_attribute_update_permission_request() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.device_attribute_update_permission_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdatePermissionRequest>(GetArenaForAllocation());
    _impl_.device_attribute_update_permission_request_ = p;
  }
  return _impl_.device_attribute_update_permission_request_;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionRequest* DeviceManagementRequest::mutable_device_attribute_update_permission_request() {
  ::enterprise_management::DeviceAttributeUpdatePermissionRequest* _msg = _internal_mutable_device_attribute_update_permission_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_device_attribute_update_permission_request(::enterprise_management::DeviceAttributeUpdatePermissionRequest* device_attribute_update_permission_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_attribute_update_permission_request_;
  }
  if (device_attribute_update_permission_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_attribute_update_permission_request);
    if (message_arena != submessage_arena) {
      device_attribute_update_permission_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_attribute_update_permission_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.device_attribute_update_permission_request_ = device_attribute_update_permission_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_attribute_update_permission_request)
}

// optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
inline bool DeviceManagementRequest::_internal_has_device_attribute_update_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_attribute_update_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_device_attribute_update_request() const {
  return _internal_has_device_attribute_update_request();
}
inline void DeviceManagementRequest::clear_device_attribute_update_request() {
  if (_impl_.device_attribute_update_request_ != nullptr) _impl_.device_attribute_update_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::enterprise_management::DeviceAttributeUpdateRequest& DeviceManagementRequest::_internal_device_attribute_update_request() const {
  const ::enterprise_management::DeviceAttributeUpdateRequest* p = _impl_.device_attribute_update_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAttributeUpdateRequest&>(
      ::enterprise_management::_DeviceAttributeUpdateRequest_default_instance_);
}
inline const ::enterprise_management::DeviceAttributeUpdateRequest& DeviceManagementRequest::device_attribute_update_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
  return _internal_device_attribute_update_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_device_attribute_update_request(
    ::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_attribute_update_request_);
  }
  _impl_.device_attribute_update_request_ = device_attribute_update_request;
  if (device_attribute_update_request) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
}
inline ::enterprise_management::DeviceAttributeUpdateRequest* DeviceManagementRequest::release_device_attribute_update_request() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::DeviceAttributeUpdateRequest* temp = _impl_.device_attribute_update_request_;
  _impl_.device_attribute_update_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAttributeUpdateRequest* DeviceManagementRequest::unsafe_arena_release_device_attribute_update_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::DeviceAttributeUpdateRequest* temp = _impl_.device_attribute_update_request_;
  _impl_.device_attribute_update_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAttributeUpdateRequest* DeviceManagementRequest::_internal_mutable_device_attribute_update_request() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.device_attribute_update_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdateRequest>(GetArenaForAllocation());
    _impl_.device_attribute_update_request_ = p;
  }
  return _impl_.device_attribute_update_request_;
}
inline ::enterprise_management::DeviceAttributeUpdateRequest* DeviceManagementRequest::mutable_device_attribute_update_request() {
  ::enterprise_management::DeviceAttributeUpdateRequest* _msg = _internal_mutable_device_attribute_update_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_device_attribute_update_request(::enterprise_management::DeviceAttributeUpdateRequest* device_attribute_update_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_attribute_update_request_;
  }
  if (device_attribute_update_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_attribute_update_request);
    if (message_arena != submessage_arena) {
      device_attribute_update_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_attribute_update_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.device_attribute_update_request_ = device_attribute_update_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_attribute_update_request)
}

// optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
inline bool DeviceManagementRequest::_internal_has_gcm_id_update_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gcm_id_update_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_gcm_id_update_request() const {
  return _internal_has_gcm_id_update_request();
}
inline void DeviceManagementRequest::clear_gcm_id_update_request() {
  if (_impl_.gcm_id_update_request_ != nullptr) _impl_.gcm_id_update_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::enterprise_management::GcmIdUpdateRequest& DeviceManagementRequest::_internal_gcm_id_update_request() const {
  const ::enterprise_management::GcmIdUpdateRequest* p = _impl_.gcm_id_update_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::GcmIdUpdateRequest&>(
      ::enterprise_management::_GcmIdUpdateRequest_default_instance_);
}
inline const ::enterprise_management::GcmIdUpdateRequest& DeviceManagementRequest::gcm_id_update_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
  return _internal_gcm_id_update_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_gcm_id_update_request(
    ::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gcm_id_update_request_);
  }
  _impl_.gcm_id_update_request_ = gcm_id_update_request;
  if (gcm_id_update_request) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
}
inline ::enterprise_management::GcmIdUpdateRequest* DeviceManagementRequest::release_gcm_id_update_request() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::enterprise_management::GcmIdUpdateRequest* temp = _impl_.gcm_id_update_request_;
  _impl_.gcm_id_update_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::GcmIdUpdateRequest* DeviceManagementRequest::unsafe_arena_release_gcm_id_update_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::enterprise_management::GcmIdUpdateRequest* temp = _impl_.gcm_id_update_request_;
  _impl_.gcm_id_update_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::GcmIdUpdateRequest* DeviceManagementRequest::_internal_mutable_gcm_id_update_request() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.gcm_id_update_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::GcmIdUpdateRequest>(GetArenaForAllocation());
    _impl_.gcm_id_update_request_ = p;
  }
  return _impl_.gcm_id_update_request_;
}
inline ::enterprise_management::GcmIdUpdateRequest* DeviceManagementRequest::mutable_gcm_id_update_request() {
  ::enterprise_management::GcmIdUpdateRequest* _msg = _internal_mutable_gcm_id_update_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_gcm_id_update_request(::enterprise_management::GcmIdUpdateRequest* gcm_id_update_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gcm_id_update_request_;
  }
  if (gcm_id_update_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gcm_id_update_request);
    if (message_arena != submessage_arena) {
      gcm_id_update_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gcm_id_update_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.gcm_id_update_request_ = gcm_id_update_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.gcm_id_update_request)
}

// optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
inline bool DeviceManagementRequest::_internal_has_check_android_management_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_android_management_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_check_android_management_request() const {
  return _internal_has_check_android_management_request();
}
inline void DeviceManagementRequest::clear_check_android_management_request() {
  if (_impl_.check_android_management_request_ != nullptr) _impl_.check_android_management_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::enterprise_management::CheckAndroidManagementRequest& DeviceManagementRequest::_internal_check_android_management_request() const {
  const ::enterprise_management::CheckAndroidManagementRequest* p = _impl_.check_android_management_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CheckAndroidManagementRequest&>(
      ::enterprise_management::_CheckAndroidManagementRequest_default_instance_);
}
inline const ::enterprise_management::CheckAndroidManagementRequest& DeviceManagementRequest::check_android_management_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_android_management_request)
  return _internal_check_android_management_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_check_android_management_request(
    ::enterprise_management::CheckAndroidManagementRequest* check_android_management_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_android_management_request_);
  }
  _impl_.check_android_management_request_ = check_android_management_request;
  if (check_android_management_request) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.check_android_management_request)
}
inline ::enterprise_management::CheckAndroidManagementRequest* DeviceManagementRequest::release_check_android_management_request() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::enterprise_management::CheckAndroidManagementRequest* temp = _impl_.check_android_management_request_;
  _impl_.check_android_management_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CheckAndroidManagementRequest* DeviceManagementRequest::unsafe_arena_release_check_android_management_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_android_management_request)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::enterprise_management::CheckAndroidManagementRequest* temp = _impl_.check_android_management_request_;
  _impl_.check_android_management_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::CheckAndroidManagementRequest* DeviceManagementRequest::_internal_mutable_check_android_management_request() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.check_android_management_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CheckAndroidManagementRequest>(GetArenaForAllocation());
    _impl_.check_android_management_request_ = p;
  }
  return _impl_.check_android_management_request_;
}
inline ::enterprise_management::CheckAndroidManagementRequest* DeviceManagementRequest::mutable_check_android_management_request() {
  ::enterprise_management::CheckAndroidManagementRequest* _msg = _internal_mutable_check_android_management_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_android_management_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_check_android_management_request(::enterprise_management::CheckAndroidManagementRequest* check_android_management_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_android_management_request_;
  }
  if (check_android_management_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_android_management_request);
    if (message_arena != submessage_arena) {
      check_android_management_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_android_management_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.check_android_management_request_ = check_android_management_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_android_management_request)
}

// optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
inline bool DeviceManagementRequest::_internal_has_certificate_based_register_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.certificate_based_register_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_certificate_based_register_request() const {
  return _internal_has_certificate_based_register_request();
}
inline void DeviceManagementRequest::clear_certificate_based_register_request() {
  if (_impl_.certificate_based_register_request_ != nullptr) _impl_.certificate_based_register_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::enterprise_management::CertificateBasedDeviceRegisterRequest& DeviceManagementRequest::_internal_certificate_based_register_request() const {
  const ::enterprise_management::CertificateBasedDeviceRegisterRequest* p = _impl_.certificate_based_register_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CertificateBasedDeviceRegisterRequest&>(
      ::enterprise_management::_CertificateBasedDeviceRegisterRequest_default_instance_);
}
inline const ::enterprise_management::CertificateBasedDeviceRegisterRequest& DeviceManagementRequest::certificate_based_register_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
  return _internal_certificate_based_register_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_certificate_based_register_request(
    ::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.certificate_based_register_request_);
  }
  _impl_.certificate_based_register_request_ = certificate_based_register_request;
  if (certificate_based_register_request) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
}
inline ::enterprise_management::CertificateBasedDeviceRegisterRequest* DeviceManagementRequest::release_certificate_based_register_request() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::enterprise_management::CertificateBasedDeviceRegisterRequest* temp = _impl_.certificate_based_register_request_;
  _impl_.certificate_based_register_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CertificateBasedDeviceRegisterRequest* DeviceManagementRequest::unsafe_arena_release_certificate_based_register_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::enterprise_management::CertificateBasedDeviceRegisterRequest* temp = _impl_.certificate_based_register_request_;
  _impl_.certificate_based_register_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::CertificateBasedDeviceRegisterRequest* DeviceManagementRequest::_internal_mutable_certificate_based_register_request() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.certificate_based_register_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CertificateBasedDeviceRegisterRequest>(GetArenaForAllocation());
    _impl_.certificate_based_register_request_ = p;
  }
  return _impl_.certificate_based_register_request_;
}
inline ::enterprise_management::CertificateBasedDeviceRegisterRequest* DeviceManagementRequest::mutable_certificate_based_register_request() {
  ::enterprise_management::CertificateBasedDeviceRegisterRequest* _msg = _internal_mutable_certificate_based_register_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_certificate_based_register_request(::enterprise_management::CertificateBasedDeviceRegisterRequest* certificate_based_register_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.certificate_based_register_request_;
  }
  if (certificate_based_register_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(certificate_based_register_request);
    if (message_arena != submessage_arena) {
      certificate_based_register_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certificate_based_register_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.certificate_based_register_request_ = certificate_based_register_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.certificate_based_register_request)
}

// optional .enterprise_management.ActiveDirectoryEnrollPlayUserRequest active_directory_enroll_play_user_request = 19;
inline bool DeviceManagementRequest::_internal_has_active_directory_enroll_play_user_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_directory_enroll_play_user_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_active_directory_enroll_play_user_request() const {
  return _internal_has_active_directory_enroll_play_user_request();
}
inline void DeviceManagementRequest::clear_active_directory_enroll_play_user_request() {
  if (_impl_.active_directory_enroll_play_user_request_ != nullptr) _impl_.active_directory_enroll_play_user_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest& DeviceManagementRequest::_internal_active_directory_enroll_play_user_request() const {
  const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* p = _impl_.active_directory_enroll_play_user_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest&>(
      ::enterprise_management::_ActiveDirectoryEnrollPlayUserRequest_default_instance_);
}
inline const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest& DeviceManagementRequest::active_directory_enroll_play_user_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
  return _internal_active_directory_enroll_play_user_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_active_directory_enroll_play_user_request(
    ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* active_directory_enroll_play_user_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_directory_enroll_play_user_request_);
  }
  _impl_.active_directory_enroll_play_user_request_ = active_directory_enroll_play_user_request;
  if (active_directory_enroll_play_user_request) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* DeviceManagementRequest::release_active_directory_enroll_play_user_request() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* temp = _impl_.active_directory_enroll_play_user_request_;
  _impl_.active_directory_enroll_play_user_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* DeviceManagementRequest::unsafe_arena_release_active_directory_enroll_play_user_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* temp = _impl_.active_directory_enroll_play_user_request_;
  _impl_.active_directory_enroll_play_user_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* DeviceManagementRequest::_internal_mutable_active_directory_enroll_play_user_request() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.active_directory_enroll_play_user_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryEnrollPlayUserRequest>(GetArenaForAllocation());
    _impl_.active_directory_enroll_play_user_request_ = p;
  }
  return _impl_.active_directory_enroll_play_user_request_;
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* DeviceManagementRequest::mutable_active_directory_enroll_play_user_request() {
  ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* _msg = _internal_mutable_active_directory_enroll_play_user_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_active_directory_enroll_play_user_request(::enterprise_management::ActiveDirectoryEnrollPlayUserRequest* active_directory_enroll_play_user_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.active_directory_enroll_play_user_request_;
  }
  if (active_directory_enroll_play_user_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(active_directory_enroll_play_user_request);
    if (message_arena != submessage_arena) {
      active_directory_enroll_play_user_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_directory_enroll_play_user_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.active_directory_enroll_play_user_request_ = active_directory_enroll_play_user_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_enroll_play_user_request)
}

// optional .enterprise_management.ActiveDirectoryPlayActivityRequest active_directory_play_activity_request = 20;
inline bool DeviceManagementRequest::_internal_has_active_directory_play_activity_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_directory_play_activity_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_active_directory_play_activity_request() const {
  return _internal_has_active_directory_play_activity_request();
}
inline void DeviceManagementRequest::clear_active_directory_play_activity_request() {
  if (_impl_.active_directory_play_activity_request_ != nullptr) _impl_.active_directory_play_activity_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::enterprise_management::ActiveDirectoryPlayActivityRequest& DeviceManagementRequest::_internal_active_directory_play_activity_request() const {
  const ::enterprise_management::ActiveDirectoryPlayActivityRequest* p = _impl_.active_directory_play_activity_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ActiveDirectoryPlayActivityRequest&>(
      ::enterprise_management::_ActiveDirectoryPlayActivityRequest_default_instance_);
}
inline const ::enterprise_management::ActiveDirectoryPlayActivityRequest& DeviceManagementRequest::active_directory_play_activity_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
  return _internal_active_directory_play_activity_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_active_directory_play_activity_request(
    ::enterprise_management::ActiveDirectoryPlayActivityRequest* active_directory_play_activity_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_directory_play_activity_request_);
  }
  _impl_.active_directory_play_activity_request_ = active_directory_play_activity_request;
  if (active_directory_play_activity_request) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
}
inline ::enterprise_management::ActiveDirectoryPlayActivityRequest* DeviceManagementRequest::release_active_directory_play_activity_request() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::enterprise_management::ActiveDirectoryPlayActivityRequest* temp = _impl_.active_directory_play_activity_request_;
  _impl_.active_directory_play_activity_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ActiveDirectoryPlayActivityRequest* DeviceManagementRequest::unsafe_arena_release_active_directory_play_activity_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::enterprise_management::ActiveDirectoryPlayActivityRequest* temp = _impl_.active_directory_play_activity_request_;
  _impl_.active_directory_play_activity_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ActiveDirectoryPlayActivityRequest* DeviceManagementRequest::_internal_mutable_active_directory_play_activity_request() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.active_directory_play_activity_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryPlayActivityRequest>(GetArenaForAllocation());
    _impl_.active_directory_play_activity_request_ = p;
  }
  return _impl_.active_directory_play_activity_request_;
}
inline ::enterprise_management::ActiveDirectoryPlayActivityRequest* DeviceManagementRequest::mutable_active_directory_play_activity_request() {
  ::enterprise_management::ActiveDirectoryPlayActivityRequest* _msg = _internal_mutable_active_directory_play_activity_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_active_directory_play_activity_request(::enterprise_management::ActiveDirectoryPlayActivityRequest* active_directory_play_activity_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.active_directory_play_activity_request_;
  }
  if (active_directory_play_activity_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(active_directory_play_activity_request);
    if (message_arena != submessage_arena) {
      active_directory_play_activity_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_directory_play_activity_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.active_directory_play_activity_request_ = active_directory_play_activity_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_play_activity_request)
}

// optional .enterprise_management.CheckDeviceLicenseRequest check_device_license_request_deprecated = 21 [deprecated = true];
inline bool DeviceManagementRequest::_internal_has_check_device_license_request_deprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_device_license_request_deprecated_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_check_device_license_request_deprecated() const {
  return _internal_has_check_device_license_request_deprecated();
}
inline void DeviceManagementRequest::clear_check_device_license_request_deprecated() {
  if (_impl_.check_device_license_request_deprecated_ != nullptr) _impl_.check_device_license_request_deprecated_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::enterprise_management::CheckDeviceLicenseRequest& DeviceManagementRequest::_internal_check_device_license_request_deprecated() const {
  const ::enterprise_management::CheckDeviceLicenseRequest* p = _impl_.check_device_license_request_deprecated_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CheckDeviceLicenseRequest&>(
      ::enterprise_management::_CheckDeviceLicenseRequest_default_instance_);
}
inline const ::enterprise_management::CheckDeviceLicenseRequest& DeviceManagementRequest::check_device_license_request_deprecated() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
  return _internal_check_device_license_request_deprecated();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_check_device_license_request_deprecated(
    ::enterprise_management::CheckDeviceLicenseRequest* check_device_license_request_deprecated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_device_license_request_deprecated_);
  }
  _impl_.check_device_license_request_deprecated_ = check_device_license_request_deprecated;
  if (check_device_license_request_deprecated) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
}
inline ::enterprise_management::CheckDeviceLicenseRequest* DeviceManagementRequest::release_check_device_license_request_deprecated() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::enterprise_management::CheckDeviceLicenseRequest* temp = _impl_.check_device_license_request_deprecated_;
  _impl_.check_device_license_request_deprecated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CheckDeviceLicenseRequest* DeviceManagementRequest::unsafe_arena_release_check_device_license_request_deprecated() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::enterprise_management::CheckDeviceLicenseRequest* temp = _impl_.check_device_license_request_deprecated_;
  _impl_.check_device_license_request_deprecated_ = nullptr;
  return temp;
}
inline ::enterprise_management::CheckDeviceLicenseRequest* DeviceManagementRequest::_internal_mutable_check_device_license_request_deprecated() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.check_device_license_request_deprecated_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CheckDeviceLicenseRequest>(GetArenaForAllocation());
    _impl_.check_device_license_request_deprecated_ = p;
  }
  return _impl_.check_device_license_request_deprecated_;
}
inline ::enterprise_management::CheckDeviceLicenseRequest* DeviceManagementRequest::mutable_check_device_license_request_deprecated() {
  ::enterprise_management::CheckDeviceLicenseRequest* _msg = _internal_mutable_check_device_license_request_deprecated();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_check_device_license_request_deprecated(::enterprise_management::CheckDeviceLicenseRequest* check_device_license_request_deprecated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_device_license_request_deprecated_;
  }
  if (check_device_license_request_deprecated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_device_license_request_deprecated);
    if (message_arena != submessage_arena) {
      check_device_license_request_deprecated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_device_license_request_deprecated, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.check_device_license_request_deprecated_ = check_device_license_request_deprecated;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_device_license_request_deprecated)
}

// optional .enterprise_management.ActiveDirectoryUserSigninRequest active_directory_user_signin_request = 22;
inline bool DeviceManagementRequest::_internal_has_active_directory_user_signin_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_directory_user_signin_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_active_directory_user_signin_request() const {
  return _internal_has_active_directory_user_signin_request();
}
inline void DeviceManagementRequest::clear_active_directory_user_signin_request() {
  if (_impl_.active_directory_user_signin_request_ != nullptr) _impl_.active_directory_user_signin_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const ::enterprise_management::ActiveDirectoryUserSigninRequest& DeviceManagementRequest::_internal_active_directory_user_signin_request() const {
  const ::enterprise_management::ActiveDirectoryUserSigninRequest* p = _impl_.active_directory_user_signin_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ActiveDirectoryUserSigninRequest&>(
      ::enterprise_management::_ActiveDirectoryUserSigninRequest_default_instance_);
}
inline const ::enterprise_management::ActiveDirectoryUserSigninRequest& DeviceManagementRequest::active_directory_user_signin_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
  return _internal_active_directory_user_signin_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_active_directory_user_signin_request(
    ::enterprise_management::ActiveDirectoryUserSigninRequest* active_directory_user_signin_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_directory_user_signin_request_);
  }
  _impl_.active_directory_user_signin_request_ = active_directory_user_signin_request;
  if (active_directory_user_signin_request) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
}
inline ::enterprise_management::ActiveDirectoryUserSigninRequest* DeviceManagementRequest::release_active_directory_user_signin_request() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::enterprise_management::ActiveDirectoryUserSigninRequest* temp = _impl_.active_directory_user_signin_request_;
  _impl_.active_directory_user_signin_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ActiveDirectoryUserSigninRequest* DeviceManagementRequest::unsafe_arena_release_active_directory_user_signin_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::enterprise_management::ActiveDirectoryUserSigninRequest* temp = _impl_.active_directory_user_signin_request_;
  _impl_.active_directory_user_signin_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ActiveDirectoryUserSigninRequest* DeviceManagementRequest::_internal_mutable_active_directory_user_signin_request() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.active_directory_user_signin_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryUserSigninRequest>(GetArenaForAllocation());
    _impl_.active_directory_user_signin_request_ = p;
  }
  return _impl_.active_directory_user_signin_request_;
}
inline ::enterprise_management::ActiveDirectoryUserSigninRequest* DeviceManagementRequest::mutable_active_directory_user_signin_request() {
  ::enterprise_management::ActiveDirectoryUserSigninRequest* _msg = _internal_mutable_active_directory_user_signin_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_active_directory_user_signin_request(::enterprise_management::ActiveDirectoryUserSigninRequest* active_directory_user_signin_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.active_directory_user_signin_request_;
  }
  if (active_directory_user_signin_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(active_directory_user_signin_request);
    if (message_arena != submessage_arena) {
      active_directory_user_signin_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_directory_user_signin_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.active_directory_user_signin_request_ = active_directory_user_signin_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.active_directory_user_signin_request)
}

// optional .enterprise_management.RegisterBrowserRequest register_browser_request = 23;
inline bool DeviceManagementRequest::_internal_has_register_browser_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.register_browser_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_register_browser_request() const {
  return _internal_has_register_browser_request();
}
inline void DeviceManagementRequest::clear_register_browser_request() {
  if (_impl_.register_browser_request_ != nullptr) _impl_.register_browser_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::enterprise_management::RegisterBrowserRequest& DeviceManagementRequest::_internal_register_browser_request() const {
  const ::enterprise_management::RegisterBrowserRequest* p = _impl_.register_browser_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::RegisterBrowserRequest&>(
      ::enterprise_management::_RegisterBrowserRequest_default_instance_);
}
inline const ::enterprise_management::RegisterBrowserRequest& DeviceManagementRequest::register_browser_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.register_browser_request)
  return _internal_register_browser_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_register_browser_request(
    ::enterprise_management::RegisterBrowserRequest* register_browser_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.register_browser_request_);
  }
  _impl_.register_browser_request_ = register_browser_request;
  if (register_browser_request) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.register_browser_request)
}
inline ::enterprise_management::RegisterBrowserRequest* DeviceManagementRequest::release_register_browser_request() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::enterprise_management::RegisterBrowserRequest* temp = _impl_.register_browser_request_;
  _impl_.register_browser_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::RegisterBrowserRequest* DeviceManagementRequest::unsafe_arena_release_register_browser_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.register_browser_request)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::enterprise_management::RegisterBrowserRequest* temp = _impl_.register_browser_request_;
  _impl_.register_browser_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::RegisterBrowserRequest* DeviceManagementRequest::_internal_mutable_register_browser_request() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.register_browser_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::RegisterBrowserRequest>(GetArenaForAllocation());
    _impl_.register_browser_request_ = p;
  }
  return _impl_.register_browser_request_;
}
inline ::enterprise_management::RegisterBrowserRequest* DeviceManagementRequest::mutable_register_browser_request() {
  ::enterprise_management::RegisterBrowserRequest* _msg = _internal_mutable_register_browser_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.register_browser_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_register_browser_request(::enterprise_management::RegisterBrowserRequest* register_browser_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.register_browser_request_;
  }
  if (register_browser_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(register_browser_request);
    if (message_arena != submessage_arena) {
      register_browser_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, register_browser_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.register_browser_request_ = register_browser_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.register_browser_request)
}

// optional .enterprise_management.AppInstallReportRequest app_install_report_request = 25;
inline bool DeviceManagementRequest::_internal_has_app_install_report_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_install_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_app_install_report_request() const {
  return _internal_has_app_install_report_request();
}
inline void DeviceManagementRequest::clear_app_install_report_request() {
  if (_impl_.app_install_report_request_ != nullptr) _impl_.app_install_report_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::enterprise_management::AppInstallReportRequest& DeviceManagementRequest::_internal_app_install_report_request() const {
  const ::enterprise_management::AppInstallReportRequest* p = _impl_.app_install_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AppInstallReportRequest&>(
      ::enterprise_management::_AppInstallReportRequest_default_instance_);
}
inline const ::enterprise_management::AppInstallReportRequest& DeviceManagementRequest::app_install_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.app_install_report_request)
  return _internal_app_install_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_app_install_report_request(
    ::enterprise_management::AppInstallReportRequest* app_install_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_install_report_request_);
  }
  _impl_.app_install_report_request_ = app_install_report_request;
  if (app_install_report_request) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.app_install_report_request)
}
inline ::enterprise_management::AppInstallReportRequest* DeviceManagementRequest::release_app_install_report_request() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::enterprise_management::AppInstallReportRequest* temp = _impl_.app_install_report_request_;
  _impl_.app_install_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AppInstallReportRequest* DeviceManagementRequest::unsafe_arena_release_app_install_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.app_install_report_request)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::enterprise_management::AppInstallReportRequest* temp = _impl_.app_install_report_request_;
  _impl_.app_install_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::AppInstallReportRequest* DeviceManagementRequest::_internal_mutable_app_install_report_request() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.app_install_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AppInstallReportRequest>(GetArenaForAllocation());
    _impl_.app_install_report_request_ = p;
  }
  return _impl_.app_install_report_request_;
}
inline ::enterprise_management::AppInstallReportRequest* DeviceManagementRequest::mutable_app_install_report_request() {
  ::enterprise_management::AppInstallReportRequest* _msg = _internal_mutable_app_install_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.app_install_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_app_install_report_request(::enterprise_management::AppInstallReportRequest* app_install_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_install_report_request_;
  }
  if (app_install_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_install_report_request);
    if (message_arena != submessage_arena) {
      app_install_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_install_report_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.app_install_report_request_ = app_install_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.app_install_report_request)
}

// optional .enterprise_management.ChromeDesktopReportRequest chrome_desktop_report_request = 26;
inline bool DeviceManagementRequest::_internal_has_chrome_desktop_report_request() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chrome_desktop_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_chrome_desktop_report_request() const {
  return _internal_has_chrome_desktop_report_request();
}
inline void DeviceManagementRequest::clear_chrome_desktop_report_request() {
  if (_impl_.chrome_desktop_report_request_ != nullptr) _impl_.chrome_desktop_report_request_->Clear();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const ::enterprise_management::ChromeDesktopReportRequest& DeviceManagementRequest::_internal_chrome_desktop_report_request() const {
  const ::enterprise_management::ChromeDesktopReportRequest* p = _impl_.chrome_desktop_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChromeDesktopReportRequest&>(
      ::enterprise_management::_ChromeDesktopReportRequest_default_instance_);
}
inline const ::enterprise_management::ChromeDesktopReportRequest& DeviceManagementRequest::chrome_desktop_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
  return _internal_chrome_desktop_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_chrome_desktop_report_request(
    ::enterprise_management::ChromeDesktopReportRequest* chrome_desktop_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_desktop_report_request_);
  }
  _impl_.chrome_desktop_report_request_ = chrome_desktop_report_request;
  if (chrome_desktop_report_request) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
}
inline ::enterprise_management::ChromeDesktopReportRequest* DeviceManagementRequest::release_chrome_desktop_report_request() {
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::enterprise_management::ChromeDesktopReportRequest* temp = _impl_.chrome_desktop_report_request_;
  _impl_.chrome_desktop_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChromeDesktopReportRequest* DeviceManagementRequest::unsafe_arena_release_chrome_desktop_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::enterprise_management::ChromeDesktopReportRequest* temp = _impl_.chrome_desktop_report_request_;
  _impl_.chrome_desktop_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChromeDesktopReportRequest* DeviceManagementRequest::_internal_mutable_chrome_desktop_report_request() {
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.chrome_desktop_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChromeDesktopReportRequest>(GetArenaForAllocation());
    _impl_.chrome_desktop_report_request_ = p;
  }
  return _impl_.chrome_desktop_report_request_;
}
inline ::enterprise_management::ChromeDesktopReportRequest* DeviceManagementRequest::mutable_chrome_desktop_report_request() {
  ::enterprise_management::ChromeDesktopReportRequest* _msg = _internal_mutable_chrome_desktop_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_chrome_desktop_report_request(::enterprise_management::ChromeDesktopReportRequest* chrome_desktop_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chrome_desktop_report_request_;
  }
  if (chrome_desktop_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_desktop_report_request);
    if (message_arena != submessage_arena) {
      chrome_desktop_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_desktop_report_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.chrome_desktop_report_request_ = chrome_desktop_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.chrome_desktop_report_request)
}

// optional .enterprise_management.PolicyValidationReportRequest policy_validation_report_request = 27;
inline bool DeviceManagementRequest::_internal_has_policy_validation_report_request() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.policy_validation_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_policy_validation_report_request() const {
  return _internal_has_policy_validation_report_request();
}
inline void DeviceManagementRequest::clear_policy_validation_report_request() {
  if (_impl_.policy_validation_report_request_ != nullptr) _impl_.policy_validation_report_request_->Clear();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const ::enterprise_management::PolicyValidationReportRequest& DeviceManagementRequest::_internal_policy_validation_report_request() const {
  const ::enterprise_management::PolicyValidationReportRequest* p = _impl_.policy_validation_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyValidationReportRequest&>(
      ::enterprise_management::_PolicyValidationReportRequest_default_instance_);
}
inline const ::enterprise_management::PolicyValidationReportRequest& DeviceManagementRequest::policy_validation_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
  return _internal_policy_validation_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_policy_validation_report_request(
    ::enterprise_management::PolicyValidationReportRequest* policy_validation_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.policy_validation_report_request_);
  }
  _impl_.policy_validation_report_request_ = policy_validation_report_request;
  if (policy_validation_report_request) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
}
inline ::enterprise_management::PolicyValidationReportRequest* DeviceManagementRequest::release_policy_validation_report_request() {
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::enterprise_management::PolicyValidationReportRequest* temp = _impl_.policy_validation_report_request_;
  _impl_.policy_validation_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyValidationReportRequest* DeviceManagementRequest::unsafe_arena_release_policy_validation_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::enterprise_management::PolicyValidationReportRequest* temp = _impl_.policy_validation_report_request_;
  _impl_.policy_validation_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyValidationReportRequest* DeviceManagementRequest::_internal_mutable_policy_validation_report_request() {
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.policy_validation_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyValidationReportRequest>(GetArenaForAllocation());
    _impl_.policy_validation_report_request_ = p;
  }
  return _impl_.policy_validation_report_request_;
}
inline ::enterprise_management::PolicyValidationReportRequest* DeviceManagementRequest::mutable_policy_validation_report_request() {
  ::enterprise_management::PolicyValidationReportRequest* _msg = _internal_mutable_policy_validation_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_policy_validation_report_request(::enterprise_management::PolicyValidationReportRequest* policy_validation_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.policy_validation_report_request_;
  }
  if (policy_validation_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(policy_validation_report_request);
    if (message_arena != submessage_arena) {
      policy_validation_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policy_validation_report_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.policy_validation_report_request_ = policy_validation_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.policy_validation_report_request)
}

// optional .enterprise_management.DeviceInitialEnrollmentStateRequest device_initial_enrollment_state_request = 28;
inline bool DeviceManagementRequest::_internal_has_device_initial_enrollment_state_request() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_initial_enrollment_state_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_device_initial_enrollment_state_request() const {
  return _internal_has_device_initial_enrollment_state_request();
}
inline void DeviceManagementRequest::clear_device_initial_enrollment_state_request() {
  if (_impl_.device_initial_enrollment_state_request_ != nullptr) _impl_.device_initial_enrollment_state_request_->Clear();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const ::enterprise_management::DeviceInitialEnrollmentStateRequest& DeviceManagementRequest::_internal_device_initial_enrollment_state_request() const {
  const ::enterprise_management::DeviceInitialEnrollmentStateRequest* p = _impl_.device_initial_enrollment_state_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceInitialEnrollmentStateRequest&>(
      ::enterprise_management::_DeviceInitialEnrollmentStateRequest_default_instance_);
}
inline const ::enterprise_management::DeviceInitialEnrollmentStateRequest& DeviceManagementRequest::device_initial_enrollment_state_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
  return _internal_device_initial_enrollment_state_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_device_initial_enrollment_state_request(
    ::enterprise_management::DeviceInitialEnrollmentStateRequest* device_initial_enrollment_state_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_initial_enrollment_state_request_);
  }
  _impl_.device_initial_enrollment_state_request_ = device_initial_enrollment_state_request;
  if (device_initial_enrollment_state_request) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
}
inline ::enterprise_management::DeviceInitialEnrollmentStateRequest* DeviceManagementRequest::release_device_initial_enrollment_state_request() {
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::enterprise_management::DeviceInitialEnrollmentStateRequest* temp = _impl_.device_initial_enrollment_state_request_;
  _impl_.device_initial_enrollment_state_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateRequest* DeviceManagementRequest::unsafe_arena_release_device_initial_enrollment_state_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::enterprise_management::DeviceInitialEnrollmentStateRequest* temp = _impl_.device_initial_enrollment_state_request_;
  _impl_.device_initial_enrollment_state_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateRequest* DeviceManagementRequest::_internal_mutable_device_initial_enrollment_state_request() {
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.device_initial_enrollment_state_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateRequest>(GetArenaForAllocation());
    _impl_.device_initial_enrollment_state_request_ = p;
  }
  return _impl_.device_initial_enrollment_state_request_;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateRequest* DeviceManagementRequest::mutable_device_initial_enrollment_state_request() {
  ::enterprise_management::DeviceInitialEnrollmentStateRequest* _msg = _internal_mutable_device_initial_enrollment_state_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_device_initial_enrollment_state_request(::enterprise_management::DeviceInitialEnrollmentStateRequest* device_initial_enrollment_state_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_initial_enrollment_state_request_;
  }
  if (device_initial_enrollment_state_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_initial_enrollment_state_request);
    if (message_arena != submessage_arena) {
      device_initial_enrollment_state_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_initial_enrollment_state_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.device_initial_enrollment_state_request_ = device_initial_enrollment_state_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.device_initial_enrollment_state_request)
}

// optional .enterprise_management.RefreshAccountRequest refresh_account_request = 29;
inline bool DeviceManagementRequest::_internal_has_refresh_account_request() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.refresh_account_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_refresh_account_request() const {
  return _internal_has_refresh_account_request();
}
inline void DeviceManagementRequest::clear_refresh_account_request() {
  if (_impl_.refresh_account_request_ != nullptr) _impl_.refresh_account_request_->Clear();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const ::enterprise_management::RefreshAccountRequest& DeviceManagementRequest::_internal_refresh_account_request() const {
  const ::enterprise_management::RefreshAccountRequest* p = _impl_.refresh_account_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::RefreshAccountRequest&>(
      ::enterprise_management::_RefreshAccountRequest_default_instance_);
}
inline const ::enterprise_management::RefreshAccountRequest& DeviceManagementRequest::refresh_account_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.refresh_account_request)
  return _internal_refresh_account_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_refresh_account_request(
    ::enterprise_management::RefreshAccountRequest* refresh_account_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.refresh_account_request_);
  }
  _impl_.refresh_account_request_ = refresh_account_request;
  if (refresh_account_request) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.refresh_account_request)
}
inline ::enterprise_management::RefreshAccountRequest* DeviceManagementRequest::release_refresh_account_request() {
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::enterprise_management::RefreshAccountRequest* temp = _impl_.refresh_account_request_;
  _impl_.refresh_account_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::RefreshAccountRequest* DeviceManagementRequest::unsafe_arena_release_refresh_account_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.refresh_account_request)
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::enterprise_management::RefreshAccountRequest* temp = _impl_.refresh_account_request_;
  _impl_.refresh_account_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::RefreshAccountRequest* DeviceManagementRequest::_internal_mutable_refresh_account_request() {
  _impl_._has_bits_[0] |= 0x08000000u;
  if (_impl_.refresh_account_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::RefreshAccountRequest>(GetArenaForAllocation());
    _impl_.refresh_account_request_ = p;
  }
  return _impl_.refresh_account_request_;
}
inline ::enterprise_management::RefreshAccountRequest* DeviceManagementRequest::mutable_refresh_account_request() {
  ::enterprise_management::RefreshAccountRequest* _msg = _internal_mutable_refresh_account_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.refresh_account_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_refresh_account_request(::enterprise_management::RefreshAccountRequest* refresh_account_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.refresh_account_request_;
  }
  if (refresh_account_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(refresh_account_request);
    if (message_arena != submessage_arena) {
      refresh_account_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refresh_account_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.refresh_account_request_ = refresh_account_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.refresh_account_request)
}

// optional .enterprise_management.RsuLookupKeyUploadRequest rsu_lookup_key_upload_request = 31;
inline bool DeviceManagementRequest::_internal_has_rsu_lookup_key_upload_request() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rsu_lookup_key_upload_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_rsu_lookup_key_upload_request() const {
  return _internal_has_rsu_lookup_key_upload_request();
}
inline void DeviceManagementRequest::clear_rsu_lookup_key_upload_request() {
  if (_impl_.rsu_lookup_key_upload_request_ != nullptr) _impl_.rsu_lookup_key_upload_request_->Clear();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const ::enterprise_management::RsuLookupKeyUploadRequest& DeviceManagementRequest::_internal_rsu_lookup_key_upload_request() const {
  const ::enterprise_management::RsuLookupKeyUploadRequest* p = _impl_.rsu_lookup_key_upload_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::RsuLookupKeyUploadRequest&>(
      ::enterprise_management::_RsuLookupKeyUploadRequest_default_instance_);
}
inline const ::enterprise_management::RsuLookupKeyUploadRequest& DeviceManagementRequest::rsu_lookup_key_upload_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
  return _internal_rsu_lookup_key_upload_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_rsu_lookup_key_upload_request(
    ::enterprise_management::RsuLookupKeyUploadRequest* rsu_lookup_key_upload_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsu_lookup_key_upload_request_);
  }
  _impl_.rsu_lookup_key_upload_request_ = rsu_lookup_key_upload_request;
  if (rsu_lookup_key_upload_request) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
}
inline ::enterprise_management::RsuLookupKeyUploadRequest* DeviceManagementRequest::release_rsu_lookup_key_upload_request() {
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::enterprise_management::RsuLookupKeyUploadRequest* temp = _impl_.rsu_lookup_key_upload_request_;
  _impl_.rsu_lookup_key_upload_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::RsuLookupKeyUploadRequest* DeviceManagementRequest::unsafe_arena_release_rsu_lookup_key_upload_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::enterprise_management::RsuLookupKeyUploadRequest* temp = _impl_.rsu_lookup_key_upload_request_;
  _impl_.rsu_lookup_key_upload_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::RsuLookupKeyUploadRequest* DeviceManagementRequest::_internal_mutable_rsu_lookup_key_upload_request() {
  _impl_._has_bits_[0] |= 0x20000000u;
  if (_impl_.rsu_lookup_key_upload_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::RsuLookupKeyUploadRequest>(GetArenaForAllocation());
    _impl_.rsu_lookup_key_upload_request_ = p;
  }
  return _impl_.rsu_lookup_key_upload_request_;
}
inline ::enterprise_management::RsuLookupKeyUploadRequest* DeviceManagementRequest::mutable_rsu_lookup_key_upload_request() {
  ::enterprise_management::RsuLookupKeyUploadRequest* _msg = _internal_mutable_rsu_lookup_key_upload_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_rsu_lookup_key_upload_request(::enterprise_management::RsuLookupKeyUploadRequest* rsu_lookup_key_upload_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsu_lookup_key_upload_request_;
  }
  if (rsu_lookup_key_upload_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsu_lookup_key_upload_request);
    if (message_arena != submessage_arena) {
      rsu_lookup_key_upload_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsu_lookup_key_upload_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.rsu_lookup_key_upload_request_ = rsu_lookup_key_upload_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.rsu_lookup_key_upload_request)
}

// optional .enterprise_management.PublicSamlUserRequest public_saml_user_request = 32;
inline bool DeviceManagementRequest::_internal_has_public_saml_user_request() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public_saml_user_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_public_saml_user_request() const {
  return _internal_has_public_saml_user_request();
}
inline void DeviceManagementRequest::clear_public_saml_user_request() {
  if (_impl_.public_saml_user_request_ != nullptr) _impl_.public_saml_user_request_->Clear();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const ::enterprise_management::PublicSamlUserRequest& DeviceManagementRequest::_internal_public_saml_user_request() const {
  const ::enterprise_management::PublicSamlUserRequest* p = _impl_.public_saml_user_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PublicSamlUserRequest&>(
      ::enterprise_management::_PublicSamlUserRequest_default_instance_);
}
inline const ::enterprise_management::PublicSamlUserRequest& DeviceManagementRequest::public_saml_user_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.public_saml_user_request)
  return _internal_public_saml_user_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_public_saml_user_request(
    ::enterprise_management::PublicSamlUserRequest* public_saml_user_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_saml_user_request_);
  }
  _impl_.public_saml_user_request_ = public_saml_user_request;
  if (public_saml_user_request) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.public_saml_user_request)
}
inline ::enterprise_management::PublicSamlUserRequest* DeviceManagementRequest::release_public_saml_user_request() {
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::enterprise_management::PublicSamlUserRequest* temp = _impl_.public_saml_user_request_;
  _impl_.public_saml_user_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PublicSamlUserRequest* DeviceManagementRequest::unsafe_arena_release_public_saml_user_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.public_saml_user_request)
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::enterprise_management::PublicSamlUserRequest* temp = _impl_.public_saml_user_request_;
  _impl_.public_saml_user_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::PublicSamlUserRequest* DeviceManagementRequest::_internal_mutable_public_saml_user_request() {
  _impl_._has_bits_[0] |= 0x40000000u;
  if (_impl_.public_saml_user_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PublicSamlUserRequest>(GetArenaForAllocation());
    _impl_.public_saml_user_request_ = p;
  }
  return _impl_.public_saml_user_request_;
}
inline ::enterprise_management::PublicSamlUserRequest* DeviceManagementRequest::mutable_public_saml_user_request() {
  ::enterprise_management::PublicSamlUserRequest* _msg = _internal_mutable_public_saml_user_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.public_saml_user_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_public_saml_user_request(::enterprise_management::PublicSamlUserRequest* public_saml_user_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.public_saml_user_request_;
  }
  if (public_saml_user_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_saml_user_request);
    if (message_arena != submessage_arena) {
      public_saml_user_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_saml_user_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.public_saml_user_request_ = public_saml_user_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.public_saml_user_request)
}

// optional .enterprise_management.ChromeOsUserReportRequest chrome_os_user_report_request = 33;
inline bool DeviceManagementRequest::_internal_has_chrome_os_user_report_request() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chrome_os_user_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_chrome_os_user_report_request() const {
  return _internal_has_chrome_os_user_report_request();
}
inline void DeviceManagementRequest::clear_chrome_os_user_report_request() {
  if (_impl_.chrome_os_user_report_request_ != nullptr) _impl_.chrome_os_user_report_request_->Clear();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const ::enterprise_management::ChromeOsUserReportRequest& DeviceManagementRequest::_internal_chrome_os_user_report_request() const {
  const ::enterprise_management::ChromeOsUserReportRequest* p = _impl_.chrome_os_user_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChromeOsUserReportRequest&>(
      ::enterprise_management::_ChromeOsUserReportRequest_default_instance_);
}
inline const ::enterprise_management::ChromeOsUserReportRequest& DeviceManagementRequest::chrome_os_user_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
  return _internal_chrome_os_user_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_chrome_os_user_report_request(
    ::enterprise_management::ChromeOsUserReportRequest* chrome_os_user_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_os_user_report_request_);
  }
  _impl_.chrome_os_user_report_request_ = chrome_os_user_report_request;
  if (chrome_os_user_report_request) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
}
inline ::enterprise_management::ChromeOsUserReportRequest* DeviceManagementRequest::release_chrome_os_user_report_request() {
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::enterprise_management::ChromeOsUserReportRequest* temp = _impl_.chrome_os_user_report_request_;
  _impl_.chrome_os_user_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChromeOsUserReportRequest* DeviceManagementRequest::unsafe_arena_release_chrome_os_user_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::enterprise_management::ChromeOsUserReportRequest* temp = _impl_.chrome_os_user_report_request_;
  _impl_.chrome_os_user_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChromeOsUserReportRequest* DeviceManagementRequest::_internal_mutable_chrome_os_user_report_request() {
  _impl_._has_bits_[0] |= 0x80000000u;
  if (_impl_.chrome_os_user_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChromeOsUserReportRequest>(GetArenaForAllocation());
    _impl_.chrome_os_user_report_request_ = p;
  }
  return _impl_.chrome_os_user_report_request_;
}
inline ::enterprise_management::ChromeOsUserReportRequest* DeviceManagementRequest::mutable_chrome_os_user_report_request() {
  ::enterprise_management::ChromeOsUserReportRequest* _msg = _internal_mutable_chrome_os_user_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_chrome_os_user_report_request(::enterprise_management::ChromeOsUserReportRequest* chrome_os_user_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chrome_os_user_report_request_;
  }
  if (chrome_os_user_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_os_user_report_request);
    if (message_arena != submessage_arena) {
      chrome_os_user_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_os_user_report_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.chrome_os_user_report_request_ = chrome_os_user_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.chrome_os_user_report_request)
}

// optional .enterprise_management.ClientCertificateProvisioningRequest client_certificate_provisioning_request = 34;
inline bool DeviceManagementRequest::_internal_has_client_certificate_provisioning_request() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_certificate_provisioning_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_client_certificate_provisioning_request() const {
  return _internal_has_client_certificate_provisioning_request();
}
inline void DeviceManagementRequest::clear_client_certificate_provisioning_request() {
  if (_impl_.client_certificate_provisioning_request_ != nullptr) _impl_.client_certificate_provisioning_request_->Clear();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const ::enterprise_management::ClientCertificateProvisioningRequest& DeviceManagementRequest::_internal_client_certificate_provisioning_request() const {
  const ::enterprise_management::ClientCertificateProvisioningRequest* p = _impl_.client_certificate_provisioning_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ClientCertificateProvisioningRequest&>(
      ::enterprise_management::_ClientCertificateProvisioningRequest_default_instance_);
}
inline const ::enterprise_management::ClientCertificateProvisioningRequest& DeviceManagementRequest::client_certificate_provisioning_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
  return _internal_client_certificate_provisioning_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_client_certificate_provisioning_request(
    ::enterprise_management::ClientCertificateProvisioningRequest* client_certificate_provisioning_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_certificate_provisioning_request_);
  }
  _impl_.client_certificate_provisioning_request_ = client_certificate_provisioning_request;
  if (client_certificate_provisioning_request) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
}
inline ::enterprise_management::ClientCertificateProvisioningRequest* DeviceManagementRequest::release_client_certificate_provisioning_request() {
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::enterprise_management::ClientCertificateProvisioningRequest* temp = _impl_.client_certificate_provisioning_request_;
  _impl_.client_certificate_provisioning_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ClientCertificateProvisioningRequest* DeviceManagementRequest::unsafe_arena_release_client_certificate_provisioning_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::enterprise_management::ClientCertificateProvisioningRequest* temp = _impl_.client_certificate_provisioning_request_;
  _impl_.client_certificate_provisioning_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ClientCertificateProvisioningRequest* DeviceManagementRequest::_internal_mutable_client_certificate_provisioning_request() {
  _impl_._has_bits_[1] |= 0x00000001u;
  if (_impl_.client_certificate_provisioning_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ClientCertificateProvisioningRequest>(GetArenaForAllocation());
    _impl_.client_certificate_provisioning_request_ = p;
  }
  return _impl_.client_certificate_provisioning_request_;
}
inline ::enterprise_management::ClientCertificateProvisioningRequest* DeviceManagementRequest::mutable_client_certificate_provisioning_request() {
  ::enterprise_management::ClientCertificateProvisioningRequest* _msg = _internal_mutable_client_certificate_provisioning_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_client_certificate_provisioning_request(::enterprise_management::ClientCertificateProvisioningRequest* client_certificate_provisioning_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_certificate_provisioning_request_;
  }
  if (client_certificate_provisioning_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_certificate_provisioning_request);
    if (message_arena != submessage_arena) {
      client_certificate_provisioning_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_certificate_provisioning_request, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.client_certificate_provisioning_request_ = client_certificate_provisioning_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.client_certificate_provisioning_request)
}

// optional .enterprise_management.ExtensionInstallReportRequest extension_install_report_request = 35;
inline bool DeviceManagementRequest::_internal_has_extension_install_report_request() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extension_install_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_extension_install_report_request() const {
  return _internal_has_extension_install_report_request();
}
inline void DeviceManagementRequest::clear_extension_install_report_request() {
  if (_impl_.extension_install_report_request_ != nullptr) _impl_.extension_install_report_request_->Clear();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const ::enterprise_management::ExtensionInstallReportRequest& DeviceManagementRequest::_internal_extension_install_report_request() const {
  const ::enterprise_management::ExtensionInstallReportRequest* p = _impl_.extension_install_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ExtensionInstallReportRequest&>(
      ::enterprise_management::_ExtensionInstallReportRequest_default_instance_);
}
inline const ::enterprise_management::ExtensionInstallReportRequest& DeviceManagementRequest::extension_install_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.extension_install_report_request)
  return _internal_extension_install_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_extension_install_report_request(
    ::enterprise_management::ExtensionInstallReportRequest* extension_install_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_install_report_request_);
  }
  _impl_.extension_install_report_request_ = extension_install_report_request;
  if (extension_install_report_request) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.extension_install_report_request)
}
inline ::enterprise_management::ExtensionInstallReportRequest* DeviceManagementRequest::release_extension_install_report_request() {
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::enterprise_management::ExtensionInstallReportRequest* temp = _impl_.extension_install_report_request_;
  _impl_.extension_install_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ExtensionInstallReportRequest* DeviceManagementRequest::unsafe_arena_release_extension_install_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.extension_install_report_request)
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::enterprise_management::ExtensionInstallReportRequest* temp = _impl_.extension_install_report_request_;
  _impl_.extension_install_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ExtensionInstallReportRequest* DeviceManagementRequest::_internal_mutable_extension_install_report_request() {
  _impl_._has_bits_[1] |= 0x00000002u;
  if (_impl_.extension_install_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ExtensionInstallReportRequest>(GetArenaForAllocation());
    _impl_.extension_install_report_request_ = p;
  }
  return _impl_.extension_install_report_request_;
}
inline ::enterprise_management::ExtensionInstallReportRequest* DeviceManagementRequest::mutable_extension_install_report_request() {
  ::enterprise_management::ExtensionInstallReportRequest* _msg = _internal_mutable_extension_install_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.extension_install_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_extension_install_report_request(::enterprise_management::ExtensionInstallReportRequest* extension_install_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.extension_install_report_request_;
  }
  if (extension_install_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extension_install_report_request);
    if (message_arena != submessage_arena) {
      extension_install_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension_install_report_request, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.extension_install_report_request_ = extension_install_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.extension_install_report_request)
}

// optional .enterprise_management.CheckUserAccountRequest check_user_account_request = 36;
inline bool DeviceManagementRequest::_internal_has_check_user_account_request() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_user_account_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_check_user_account_request() const {
  return _internal_has_check_user_account_request();
}
inline void DeviceManagementRequest::clear_check_user_account_request() {
  if (_impl_.check_user_account_request_ != nullptr) _impl_.check_user_account_request_->Clear();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const ::enterprise_management::CheckUserAccountRequest& DeviceManagementRequest::_internal_check_user_account_request() const {
  const ::enterprise_management::CheckUserAccountRequest* p = _impl_.check_user_account_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CheckUserAccountRequest&>(
      ::enterprise_management::_CheckUserAccountRequest_default_instance_);
}
inline const ::enterprise_management::CheckUserAccountRequest& DeviceManagementRequest::check_user_account_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.check_user_account_request)
  return _internal_check_user_account_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_check_user_account_request(
    ::enterprise_management::CheckUserAccountRequest* check_user_account_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_user_account_request_);
  }
  _impl_.check_user_account_request_ = check_user_account_request;
  if (check_user_account_request) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.check_user_account_request)
}
inline ::enterprise_management::CheckUserAccountRequest* DeviceManagementRequest::release_check_user_account_request() {
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::enterprise_management::CheckUserAccountRequest* temp = _impl_.check_user_account_request_;
  _impl_.check_user_account_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CheckUserAccountRequest* DeviceManagementRequest::unsafe_arena_release_check_user_account_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.check_user_account_request)
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::enterprise_management::CheckUserAccountRequest* temp = _impl_.check_user_account_request_;
  _impl_.check_user_account_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::CheckUserAccountRequest* DeviceManagementRequest::_internal_mutable_check_user_account_request() {
  _impl_._has_bits_[1] |= 0x00000004u;
  if (_impl_.check_user_account_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CheckUserAccountRequest>(GetArenaForAllocation());
    _impl_.check_user_account_request_ = p;
  }
  return _impl_.check_user_account_request_;
}
inline ::enterprise_management::CheckUserAccountRequest* DeviceManagementRequest::mutable_check_user_account_request() {
  ::enterprise_management::CheckUserAccountRequest* _msg = _internal_mutable_check_user_account_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.check_user_account_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_check_user_account_request(::enterprise_management::CheckUserAccountRequest* check_user_account_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_user_account_request_;
  }
  if (check_user_account_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_user_account_request);
    if (message_arena != submessage_arena) {
      check_user_account_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_user_account_request, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.check_user_account_request_ = check_user_account_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.check_user_account_request)
}

// optional .enterprise_management.PrivateSetMembershipRequest private_set_membership_request = 37;
inline bool DeviceManagementRequest::_internal_has_private_set_membership_request() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.private_set_membership_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_private_set_membership_request() const {
  return _internal_has_private_set_membership_request();
}
inline void DeviceManagementRequest::clear_private_set_membership_request() {
  if (_impl_.private_set_membership_request_ != nullptr) _impl_.private_set_membership_request_->Clear();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const ::enterprise_management::PrivateSetMembershipRequest& DeviceManagementRequest::_internal_private_set_membership_request() const {
  const ::enterprise_management::PrivateSetMembershipRequest* p = _impl_.private_set_membership_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PrivateSetMembershipRequest&>(
      ::enterprise_management::_PrivateSetMembershipRequest_default_instance_);
}
inline const ::enterprise_management::PrivateSetMembershipRequest& DeviceManagementRequest::private_set_membership_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.private_set_membership_request)
  return _internal_private_set_membership_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_private_set_membership_request(
    ::enterprise_management::PrivateSetMembershipRequest* private_set_membership_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.private_set_membership_request_);
  }
  _impl_.private_set_membership_request_ = private_set_membership_request;
  if (private_set_membership_request) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.private_set_membership_request)
}
inline ::enterprise_management::PrivateSetMembershipRequest* DeviceManagementRequest::release_private_set_membership_request() {
  _impl_._has_bits_[1] &= ~0x00000008u;
  ::enterprise_management::PrivateSetMembershipRequest* temp = _impl_.private_set_membership_request_;
  _impl_.private_set_membership_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PrivateSetMembershipRequest* DeviceManagementRequest::unsafe_arena_release_private_set_membership_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.private_set_membership_request)
  _impl_._has_bits_[1] &= ~0x00000008u;
  ::enterprise_management::PrivateSetMembershipRequest* temp = _impl_.private_set_membership_request_;
  _impl_.private_set_membership_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::PrivateSetMembershipRequest* DeviceManagementRequest::_internal_mutable_private_set_membership_request() {
  _impl_._has_bits_[1] |= 0x00000008u;
  if (_impl_.private_set_membership_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PrivateSetMembershipRequest>(GetArenaForAllocation());
    _impl_.private_set_membership_request_ = p;
  }
  return _impl_.private_set_membership_request_;
}
inline ::enterprise_management::PrivateSetMembershipRequest* DeviceManagementRequest::mutable_private_set_membership_request() {
  ::enterprise_management::PrivateSetMembershipRequest* _msg = _internal_mutable_private_set_membership_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.private_set_membership_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_private_set_membership_request(::enterprise_management::PrivateSetMembershipRequest* private_set_membership_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.private_set_membership_request_;
  }
  if (private_set_membership_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(private_set_membership_request);
    if (message_arena != submessage_arena) {
      private_set_membership_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, private_set_membership_request, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  _impl_.private_set_membership_request_ = private_set_membership_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.private_set_membership_request)
}

// optional .enterprise_management.BrowserPublicKeyUploadRequest browser_public_key_upload_request = 38;
inline bool DeviceManagementRequest::_internal_has_browser_public_key_upload_request() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_public_key_upload_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_browser_public_key_upload_request() const {
  return _internal_has_browser_public_key_upload_request();
}
inline void DeviceManagementRequest::clear_browser_public_key_upload_request() {
  if (_impl_.browser_public_key_upload_request_ != nullptr) _impl_.browser_public_key_upload_request_->Clear();
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline const ::enterprise_management::BrowserPublicKeyUploadRequest& DeviceManagementRequest::_internal_browser_public_key_upload_request() const {
  const ::enterprise_management::BrowserPublicKeyUploadRequest* p = _impl_.browser_public_key_upload_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserPublicKeyUploadRequest&>(
      ::enterprise_management::_BrowserPublicKeyUploadRequest_default_instance_);
}
inline const ::enterprise_management::BrowserPublicKeyUploadRequest& DeviceManagementRequest::browser_public_key_upload_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.browser_public_key_upload_request)
  return _internal_browser_public_key_upload_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_browser_public_key_upload_request(
    ::enterprise_management::BrowserPublicKeyUploadRequest* browser_public_key_upload_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_public_key_upload_request_);
  }
  _impl_.browser_public_key_upload_request_ = browser_public_key_upload_request;
  if (browser_public_key_upload_request) {
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.browser_public_key_upload_request)
}
inline ::enterprise_management::BrowserPublicKeyUploadRequest* DeviceManagementRequest::release_browser_public_key_upload_request() {
  _impl_._has_bits_[1] &= ~0x00000010u;
  ::enterprise_management::BrowserPublicKeyUploadRequest* temp = _impl_.browser_public_key_upload_request_;
  _impl_.browser_public_key_upload_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserPublicKeyUploadRequest* DeviceManagementRequest::unsafe_arena_release_browser_public_key_upload_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.browser_public_key_upload_request)
  _impl_._has_bits_[1] &= ~0x00000010u;
  ::enterprise_management::BrowserPublicKeyUploadRequest* temp = _impl_.browser_public_key_upload_request_;
  _impl_.browser_public_key_upload_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserPublicKeyUploadRequest* DeviceManagementRequest::_internal_mutable_browser_public_key_upload_request() {
  _impl_._has_bits_[1] |= 0x00000010u;
  if (_impl_.browser_public_key_upload_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserPublicKeyUploadRequest>(GetArenaForAllocation());
    _impl_.browser_public_key_upload_request_ = p;
  }
  return _impl_.browser_public_key_upload_request_;
}
inline ::enterprise_management::BrowserPublicKeyUploadRequest* DeviceManagementRequest::mutable_browser_public_key_upload_request() {
  ::enterprise_management::BrowserPublicKeyUploadRequest* _msg = _internal_mutable_browser_public_key_upload_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.browser_public_key_upload_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_browser_public_key_upload_request(::enterprise_management::BrowserPublicKeyUploadRequest* browser_public_key_upload_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_public_key_upload_request_;
  }
  if (browser_public_key_upload_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_public_key_upload_request);
    if (message_arena != submessage_arena) {
      browser_public_key_upload_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_public_key_upload_request, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  _impl_.browser_public_key_upload_request_ = browser_public_key_upload_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.browser_public_key_upload_request)
}

// optional .enterprise_management.UploadEuiccInfoRequest upload_euicc_info_request = 39;
inline bool DeviceManagementRequest::_internal_has_upload_euicc_info_request() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.upload_euicc_info_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_upload_euicc_info_request() const {
  return _internal_has_upload_euicc_info_request();
}
inline void DeviceManagementRequest::clear_upload_euicc_info_request() {
  if (_impl_.upload_euicc_info_request_ != nullptr) _impl_.upload_euicc_info_request_->Clear();
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline const ::enterprise_management::UploadEuiccInfoRequest& DeviceManagementRequest::_internal_upload_euicc_info_request() const {
  const ::enterprise_management::UploadEuiccInfoRequest* p = _impl_.upload_euicc_info_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::UploadEuiccInfoRequest&>(
      ::enterprise_management::_UploadEuiccInfoRequest_default_instance_);
}
inline const ::enterprise_management::UploadEuiccInfoRequest& DeviceManagementRequest::upload_euicc_info_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.upload_euicc_info_request)
  return _internal_upload_euicc_info_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_upload_euicc_info_request(
    ::enterprise_management::UploadEuiccInfoRequest* upload_euicc_info_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upload_euicc_info_request_);
  }
  _impl_.upload_euicc_info_request_ = upload_euicc_info_request;
  if (upload_euicc_info_request) {
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.upload_euicc_info_request)
}
inline ::enterprise_management::UploadEuiccInfoRequest* DeviceManagementRequest::release_upload_euicc_info_request() {
  _impl_._has_bits_[1] &= ~0x00000020u;
  ::enterprise_management::UploadEuiccInfoRequest* temp = _impl_.upload_euicc_info_request_;
  _impl_.upload_euicc_info_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::UploadEuiccInfoRequest* DeviceManagementRequest::unsafe_arena_release_upload_euicc_info_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.upload_euicc_info_request)
  _impl_._has_bits_[1] &= ~0x00000020u;
  ::enterprise_management::UploadEuiccInfoRequest* temp = _impl_.upload_euicc_info_request_;
  _impl_.upload_euicc_info_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::UploadEuiccInfoRequest* DeviceManagementRequest::_internal_mutable_upload_euicc_info_request() {
  _impl_._has_bits_[1] |= 0x00000020u;
  if (_impl_.upload_euicc_info_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::UploadEuiccInfoRequest>(GetArenaForAllocation());
    _impl_.upload_euicc_info_request_ = p;
  }
  return _impl_.upload_euicc_info_request_;
}
inline ::enterprise_management::UploadEuiccInfoRequest* DeviceManagementRequest::mutable_upload_euicc_info_request() {
  ::enterprise_management::UploadEuiccInfoRequest* _msg = _internal_mutable_upload_euicc_info_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.upload_euicc_info_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_upload_euicc_info_request(::enterprise_management::UploadEuiccInfoRequest* upload_euicc_info_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upload_euicc_info_request_;
  }
  if (upload_euicc_info_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upload_euicc_info_request);
    if (message_arena != submessage_arena) {
      upload_euicc_info_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upload_euicc_info_request, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  _impl_.upload_euicc_info_request_ = upload_euicc_info_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.upload_euicc_info_request)
}

// optional .enterprise_management.ChromeProfileReportRequest chrome_profile_report_request = 40;
inline bool DeviceManagementRequest::_internal_has_chrome_profile_report_request() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chrome_profile_report_request_ != nullptr);
  return value;
}
inline bool DeviceManagementRequest::has_chrome_profile_report_request() const {
  return _internal_has_chrome_profile_report_request();
}
inline void DeviceManagementRequest::clear_chrome_profile_report_request() {
  if (_impl_.chrome_profile_report_request_ != nullptr) _impl_.chrome_profile_report_request_->Clear();
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline const ::enterprise_management::ChromeProfileReportRequest& DeviceManagementRequest::_internal_chrome_profile_report_request() const {
  const ::enterprise_management::ChromeProfileReportRequest* p = _impl_.chrome_profile_report_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChromeProfileReportRequest&>(
      ::enterprise_management::_ChromeProfileReportRequest_default_instance_);
}
inline const ::enterprise_management::ChromeProfileReportRequest& DeviceManagementRequest::chrome_profile_report_request() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementRequest.chrome_profile_report_request)
  return _internal_chrome_profile_report_request();
}
inline void DeviceManagementRequest::unsafe_arena_set_allocated_chrome_profile_report_request(
    ::enterprise_management::ChromeProfileReportRequest* chrome_profile_report_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_profile_report_request_);
  }
  _impl_.chrome_profile_report_request_ = chrome_profile_report_request;
  if (chrome_profile_report_request) {
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementRequest.chrome_profile_report_request)
}
inline ::enterprise_management::ChromeProfileReportRequest* DeviceManagementRequest::release_chrome_profile_report_request() {
  _impl_._has_bits_[1] &= ~0x00000040u;
  ::enterprise_management::ChromeProfileReportRequest* temp = _impl_.chrome_profile_report_request_;
  _impl_.chrome_profile_report_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChromeProfileReportRequest* DeviceManagementRequest::unsafe_arena_release_chrome_profile_report_request() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementRequest.chrome_profile_report_request)
  _impl_._has_bits_[1] &= ~0x00000040u;
  ::enterprise_management::ChromeProfileReportRequest* temp = _impl_.chrome_profile_report_request_;
  _impl_.chrome_profile_report_request_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChromeProfileReportRequest* DeviceManagementRequest::_internal_mutable_chrome_profile_report_request() {
  _impl_._has_bits_[1] |= 0x00000040u;
  if (_impl_.chrome_profile_report_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChromeProfileReportRequest>(GetArenaForAllocation());
    _impl_.chrome_profile_report_request_ = p;
  }
  return _impl_.chrome_profile_report_request_;
}
inline ::enterprise_management::ChromeProfileReportRequest* DeviceManagementRequest::mutable_chrome_profile_report_request() {
  ::enterprise_management::ChromeProfileReportRequest* _msg = _internal_mutable_chrome_profile_report_request();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementRequest.chrome_profile_report_request)
  return _msg;
}
inline void DeviceManagementRequest::set_allocated_chrome_profile_report_request(::enterprise_management::ChromeProfileReportRequest* chrome_profile_report_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chrome_profile_report_request_;
  }
  if (chrome_profile_report_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_profile_report_request);
    if (message_arena != submessage_arena) {
      chrome_profile_report_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_profile_report_request, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  _impl_.chrome_profile_report_request_ = chrome_profile_report_request;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementRequest.chrome_profile_report_request)
}

// -------------------------------------------------------------------

// DeviceManagementResponse

// optional string error_message = 2;
inline bool DeviceManagementResponse::_internal_has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceManagementResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void DeviceManagementResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceManagementResponse::error_message() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceManagementResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceManagementResponse.error_message)
}
inline std::string* DeviceManagementResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.error_message)
  return _s;
}
inline const std::string& DeviceManagementResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void DeviceManagementResponse::_internal_set_error_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceManagementResponse::_internal_mutable_error_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceManagementResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceManagementResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.error_message)
}

// repeated .enterprise_management.DeviceManagementErrorDetail error_detail = 39;
inline int DeviceManagementResponse::_internal_error_detail_size() const {
  return _impl_.error_detail_.size();
}
inline int DeviceManagementResponse::error_detail_size() const {
  return _internal_error_detail_size();
}
inline void DeviceManagementResponse::clear_error_detail() {
  _impl_.error_detail_.Clear();
}
inline ::enterprise_management::DeviceManagementErrorDetail DeviceManagementResponse::_internal_error_detail(int index) const {
  return static_cast< ::enterprise_management::DeviceManagementErrorDetail >(_impl_.error_detail_.Get(index));
}
inline ::enterprise_management::DeviceManagementErrorDetail DeviceManagementResponse::error_detail(int index) const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.error_detail)
  return _internal_error_detail(index);
}
inline void DeviceManagementResponse::set_error_detail(int index, ::enterprise_management::DeviceManagementErrorDetail value) {
  assert(::enterprise_management::DeviceManagementErrorDetail_IsValid(value));
  _impl_.error_detail_.Set(index, value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceManagementResponse.error_detail)
}
inline void DeviceManagementResponse::_internal_add_error_detail(::enterprise_management::DeviceManagementErrorDetail value) {
  assert(::enterprise_management::DeviceManagementErrorDetail_IsValid(value));
  _impl_.error_detail_.Add(value);
}
inline void DeviceManagementResponse::add_error_detail(::enterprise_management::DeviceManagementErrorDetail value) {
  _internal_add_error_detail(value);
  // @@protoc_insertion_point(field_add:enterprise_management.DeviceManagementResponse.error_detail)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
DeviceManagementResponse::error_detail() const {
  // @@protoc_insertion_point(field_list:enterprise_management.DeviceManagementResponse.error_detail)
  return _impl_.error_detail_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
DeviceManagementResponse::_internal_mutable_error_detail() {
  return &_impl_.error_detail_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
DeviceManagementResponse::mutable_error_detail() {
  // @@protoc_insertion_point(field_mutable_list:enterprise_management.DeviceManagementResponse.error_detail)
  return _internal_mutable_error_detail();
}

// optional .enterprise_management.DeviceRegisterResponse register_response = 3;
inline bool DeviceManagementResponse::_internal_has_register_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.register_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_register_response() const {
  return _internal_has_register_response();
}
inline void DeviceManagementResponse::clear_register_response() {
  if (_impl_.register_response_ != nullptr) _impl_.register_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_management::DeviceRegisterResponse& DeviceManagementResponse::_internal_register_response() const {
  const ::enterprise_management::DeviceRegisterResponse* p = _impl_.register_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRegisterResponse&>(
      ::enterprise_management::_DeviceRegisterResponse_default_instance_);
}
inline const ::enterprise_management::DeviceRegisterResponse& DeviceManagementResponse::register_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.register_response)
  return _internal_register_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_register_response(
    ::enterprise_management::DeviceRegisterResponse* register_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.register_response_);
  }
  _impl_.register_response_ = register_response;
  if (register_response) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.register_response)
}
inline ::enterprise_management::DeviceRegisterResponse* DeviceManagementResponse::release_register_response() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DeviceRegisterResponse* temp = _impl_.register_response_;
  _impl_.register_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRegisterResponse* DeviceManagementResponse::unsafe_arena_release_register_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.register_response)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::enterprise_management::DeviceRegisterResponse* temp = _impl_.register_response_;
  _impl_.register_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRegisterResponse* DeviceManagementResponse::_internal_mutable_register_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.register_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRegisterResponse>(GetArenaForAllocation());
    _impl_.register_response_ = p;
  }
  return _impl_.register_response_;
}
inline ::enterprise_management::DeviceRegisterResponse* DeviceManagementResponse::mutable_register_response() {
  ::enterprise_management::DeviceRegisterResponse* _msg = _internal_mutable_register_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.register_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_register_response(::enterprise_management::DeviceRegisterResponse* register_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.register_response_;
  }
  if (register_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(register_response);
    if (message_arena != submessage_arena) {
      register_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, register_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.register_response_ = register_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.register_response)
}

// optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
inline bool DeviceManagementResponse::_internal_has_unregister_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unregister_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_unregister_response() const {
  return _internal_has_unregister_response();
}
inline void DeviceManagementResponse::clear_unregister_response() {
  if (_impl_.unregister_response_ != nullptr) _impl_.unregister_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_management::DeviceUnregisterResponse& DeviceManagementResponse::_internal_unregister_response() const {
  const ::enterprise_management::DeviceUnregisterResponse* p = _impl_.unregister_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceUnregisterResponse&>(
      ::enterprise_management::_DeviceUnregisterResponse_default_instance_);
}
inline const ::enterprise_management::DeviceUnregisterResponse& DeviceManagementResponse::unregister_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.unregister_response)
  return _internal_unregister_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_unregister_response(
    ::enterprise_management::DeviceUnregisterResponse* unregister_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unregister_response_);
  }
  _impl_.unregister_response_ = unregister_response;
  if (unregister_response) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.unregister_response)
}
inline ::enterprise_management::DeviceUnregisterResponse* DeviceManagementResponse::release_unregister_response() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::DeviceUnregisterResponse* temp = _impl_.unregister_response_;
  _impl_.unregister_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceUnregisterResponse* DeviceManagementResponse::unsafe_arena_release_unregister_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.unregister_response)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::enterprise_management::DeviceUnregisterResponse* temp = _impl_.unregister_response_;
  _impl_.unregister_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceUnregisterResponse* DeviceManagementResponse::_internal_mutable_unregister_response() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.unregister_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceUnregisterResponse>(GetArenaForAllocation());
    _impl_.unregister_response_ = p;
  }
  return _impl_.unregister_response_;
}
inline ::enterprise_management::DeviceUnregisterResponse* DeviceManagementResponse::mutable_unregister_response() {
  ::enterprise_management::DeviceUnregisterResponse* _msg = _internal_mutable_unregister_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.unregister_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_unregister_response(::enterprise_management::DeviceUnregisterResponse* unregister_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.unregister_response_;
  }
  if (unregister_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unregister_response);
    if (message_arena != submessage_arena) {
      unregister_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unregister_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.unregister_response_ = unregister_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.unregister_response)
}

// optional .enterprise_management.DevicePolicyResponse policy_response = 5;
inline bool DeviceManagementResponse::_internal_has_policy_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.policy_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_policy_response() const {
  return _internal_has_policy_response();
}
inline void DeviceManagementResponse::clear_policy_response() {
  if (_impl_.policy_response_ != nullptr) _impl_.policy_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_management::DevicePolicyResponse& DeviceManagementResponse::_internal_policy_response() const {
  const ::enterprise_management::DevicePolicyResponse* p = _impl_.policy_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePolicyResponse&>(
      ::enterprise_management::_DevicePolicyResponse_default_instance_);
}
inline const ::enterprise_management::DevicePolicyResponse& DeviceManagementResponse::policy_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.policy_response)
  return _internal_policy_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_policy_response(
    ::enterprise_management::DevicePolicyResponse* policy_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.policy_response_);
  }
  _impl_.policy_response_ = policy_response;
  if (policy_response) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.policy_response)
}
inline ::enterprise_management::DevicePolicyResponse* DeviceManagementResponse::release_policy_response() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::DevicePolicyResponse* temp = _impl_.policy_response_;
  _impl_.policy_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePolicyResponse* DeviceManagementResponse::unsafe_arena_release_policy_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.policy_response)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::enterprise_management::DevicePolicyResponse* temp = _impl_.policy_response_;
  _impl_.policy_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePolicyResponse* DeviceManagementResponse::_internal_mutable_policy_response() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.policy_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePolicyResponse>(GetArenaForAllocation());
    _impl_.policy_response_ = p;
  }
  return _impl_.policy_response_;
}
inline ::enterprise_management::DevicePolicyResponse* DeviceManagementResponse::mutable_policy_response() {
  ::enterprise_management::DevicePolicyResponse* _msg = _internal_mutable_policy_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.policy_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_policy_response(::enterprise_management::DevicePolicyResponse* policy_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.policy_response_;
  }
  if (policy_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(policy_response);
    if (message_arena != submessage_arena) {
      policy_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policy_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.policy_response_ = policy_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.policy_response)
}

// optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
inline bool DeviceManagementResponse::_internal_has_device_status_report_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_status_report_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_device_status_report_response() const {
  return _internal_has_device_status_report_response();
}
inline void DeviceManagementResponse::clear_device_status_report_response() {
  if (_impl_.device_status_report_response_ != nullptr) _impl_.device_status_report_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_management::DeviceStatusReportResponse& DeviceManagementResponse::_internal_device_status_report_response() const {
  const ::enterprise_management::DeviceStatusReportResponse* p = _impl_.device_status_report_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceStatusReportResponse&>(
      ::enterprise_management::_DeviceStatusReportResponse_default_instance_);
}
inline const ::enterprise_management::DeviceStatusReportResponse& DeviceManagementResponse::device_status_report_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_status_report_response)
  return _internal_device_status_report_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_device_status_report_response(
    ::enterprise_management::DeviceStatusReportResponse* device_status_report_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_status_report_response_);
  }
  _impl_.device_status_report_response_ = device_status_report_response;
  if (device_status_report_response) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.device_status_report_response)
}
inline ::enterprise_management::DeviceStatusReportResponse* DeviceManagementResponse::release_device_status_report_response() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::DeviceStatusReportResponse* temp = _impl_.device_status_report_response_;
  _impl_.device_status_report_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceStatusReportResponse* DeviceManagementResponse::unsafe_arena_release_device_status_report_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_status_report_response)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::enterprise_management::DeviceStatusReportResponse* temp = _impl_.device_status_report_response_;
  _impl_.device_status_report_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceStatusReportResponse* DeviceManagementResponse::_internal_mutable_device_status_report_response() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.device_status_report_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceStatusReportResponse>(GetArenaForAllocation());
    _impl_.device_status_report_response_ = p;
  }
  return _impl_.device_status_report_response_;
}
inline ::enterprise_management::DeviceStatusReportResponse* DeviceManagementResponse::mutable_device_status_report_response() {
  ::enterprise_management::DeviceStatusReportResponse* _msg = _internal_mutable_device_status_report_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_status_report_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_device_status_report_response(::enterprise_management::DeviceStatusReportResponse* device_status_report_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_status_report_response_;
  }
  if (device_status_report_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_status_report_response);
    if (message_arena != submessage_arena) {
      device_status_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_status_report_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.device_status_report_response_ = device_status_report_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_status_report_response)
}

// optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
inline bool DeviceManagementResponse::_internal_has_session_status_report_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_status_report_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_session_status_report_response() const {
  return _internal_has_session_status_report_response();
}
inline void DeviceManagementResponse::clear_session_status_report_response() {
  if (_impl_.session_status_report_response_ != nullptr) _impl_.session_status_report_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_management::SessionStatusReportResponse& DeviceManagementResponse::_internal_session_status_report_response() const {
  const ::enterprise_management::SessionStatusReportResponse* p = _impl_.session_status_report_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::SessionStatusReportResponse&>(
      ::enterprise_management::_SessionStatusReportResponse_default_instance_);
}
inline const ::enterprise_management::SessionStatusReportResponse& DeviceManagementResponse::session_status_report_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.session_status_report_response)
  return _internal_session_status_report_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_session_status_report_response(
    ::enterprise_management::SessionStatusReportResponse* session_status_report_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_status_report_response_);
  }
  _impl_.session_status_report_response_ = session_status_report_response;
  if (session_status_report_response) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.session_status_report_response)
}
inline ::enterprise_management::SessionStatusReportResponse* DeviceManagementResponse::release_session_status_report_response() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::SessionStatusReportResponse* temp = _impl_.session_status_report_response_;
  _impl_.session_status_report_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::SessionStatusReportResponse* DeviceManagementResponse::unsafe_arena_release_session_status_report_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.session_status_report_response)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::enterprise_management::SessionStatusReportResponse* temp = _impl_.session_status_report_response_;
  _impl_.session_status_report_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::SessionStatusReportResponse* DeviceManagementResponse::_internal_mutable_session_status_report_response() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.session_status_report_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::SessionStatusReportResponse>(GetArenaForAllocation());
    _impl_.session_status_report_response_ = p;
  }
  return _impl_.session_status_report_response_;
}
inline ::enterprise_management::SessionStatusReportResponse* DeviceManagementResponse::mutable_session_status_report_response() {
  ::enterprise_management::SessionStatusReportResponse* _msg = _internal_mutable_session_status_report_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.session_status_report_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_session_status_report_response(::enterprise_management::SessionStatusReportResponse* session_status_report_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_status_report_response_;
  }
  if (session_status_report_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_status_report_response);
    if (message_arena != submessage_arena) {
      session_status_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_status_report_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.session_status_report_response_ = session_status_report_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.session_status_report_response)
}

// optional .enterprise_management.ChildStatusReportResponse child_status_report_response = 29;
inline bool DeviceManagementResponse::_internal_has_child_status_report_response() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_status_report_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_child_status_report_response() const {
  return _internal_has_child_status_report_response();
}
inline void DeviceManagementResponse::clear_child_status_report_response() {
  if (_impl_.child_status_report_response_ != nullptr) _impl_.child_status_report_response_->Clear();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const ::enterprise_management::ChildStatusReportResponse& DeviceManagementResponse::_internal_child_status_report_response() const {
  const ::enterprise_management::ChildStatusReportResponse* p = _impl_.child_status_report_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChildStatusReportResponse&>(
      ::enterprise_management::_ChildStatusReportResponse_default_instance_);
}
inline const ::enterprise_management::ChildStatusReportResponse& DeviceManagementResponse::child_status_report_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.child_status_report_response)
  return _internal_child_status_report_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_child_status_report_response(
    ::enterprise_management::ChildStatusReportResponse* child_status_report_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_status_report_response_);
  }
  _impl_.child_status_report_response_ = child_status_report_response;
  if (child_status_report_response) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.child_status_report_response)
}
inline ::enterprise_management::ChildStatusReportResponse* DeviceManagementResponse::release_child_status_report_response() {
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::enterprise_management::ChildStatusReportResponse* temp = _impl_.child_status_report_response_;
  _impl_.child_status_report_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChildStatusReportResponse* DeviceManagementResponse::unsafe_arena_release_child_status_report_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.child_status_report_response)
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::enterprise_management::ChildStatusReportResponse* temp = _impl_.child_status_report_response_;
  _impl_.child_status_report_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChildStatusReportResponse* DeviceManagementResponse::_internal_mutable_child_status_report_response() {
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.child_status_report_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChildStatusReportResponse>(GetArenaForAllocation());
    _impl_.child_status_report_response_ = p;
  }
  return _impl_.child_status_report_response_;
}
inline ::enterprise_management::ChildStatusReportResponse* DeviceManagementResponse::mutable_child_status_report_response() {
  ::enterprise_management::ChildStatusReportResponse* _msg = _internal_mutable_child_status_report_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.child_status_report_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_child_status_report_response(::enterprise_management::ChildStatusReportResponse* child_status_report_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_status_report_response_;
  }
  if (child_status_report_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child_status_report_response);
    if (message_arena != submessage_arena) {
      child_status_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child_status_report_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.child_status_report_response_ = child_status_report_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.child_status_report_response)
}

// optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
inline bool DeviceManagementResponse::_internal_has_auto_enrollment_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auto_enrollment_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_auto_enrollment_response() const {
  return _internal_has_auto_enrollment_response();
}
inline void DeviceManagementResponse::clear_auto_enrollment_response() {
  if (_impl_.auto_enrollment_response_ != nullptr) _impl_.auto_enrollment_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::enterprise_management::DeviceAutoEnrollmentResponse& DeviceManagementResponse::_internal_auto_enrollment_response() const {
  const ::enterprise_management::DeviceAutoEnrollmentResponse* p = _impl_.auto_enrollment_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAutoEnrollmentResponse&>(
      ::enterprise_management::_DeviceAutoEnrollmentResponse_default_instance_);
}
inline const ::enterprise_management::DeviceAutoEnrollmentResponse& DeviceManagementResponse::auto_enrollment_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
  return _internal_auto_enrollment_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_auto_enrollment_response(
    ::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auto_enrollment_response_);
  }
  _impl_.auto_enrollment_response_ = auto_enrollment_response;
  if (auto_enrollment_response) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
}
inline ::enterprise_management::DeviceAutoEnrollmentResponse* DeviceManagementResponse::release_auto_enrollment_response() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::DeviceAutoEnrollmentResponse* temp = _impl_.auto_enrollment_response_;
  _impl_.auto_enrollment_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAutoEnrollmentResponse* DeviceManagementResponse::unsafe_arena_release_auto_enrollment_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::enterprise_management::DeviceAutoEnrollmentResponse* temp = _impl_.auto_enrollment_response_;
  _impl_.auto_enrollment_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAutoEnrollmentResponse* DeviceManagementResponse::_internal_mutable_auto_enrollment_response() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.auto_enrollment_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAutoEnrollmentResponse>(GetArenaForAllocation());
    _impl_.auto_enrollment_response_ = p;
  }
  return _impl_.auto_enrollment_response_;
}
inline ::enterprise_management::DeviceAutoEnrollmentResponse* DeviceManagementResponse::mutable_auto_enrollment_response() {
  ::enterprise_management::DeviceAutoEnrollmentResponse* _msg = _internal_mutable_auto_enrollment_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_auto_enrollment_response(::enterprise_management::DeviceAutoEnrollmentResponse* auto_enrollment_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auto_enrollment_response_;
  }
  if (auto_enrollment_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_enrollment_response);
    if (message_arena != submessage_arena) {
      auto_enrollment_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_enrollment_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.auto_enrollment_response_ = auto_enrollment_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.auto_enrollment_response)
}

// optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
inline bool DeviceManagementResponse::_internal_has_cert_upload_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cert_upload_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_cert_upload_response() const {
  return _internal_has_cert_upload_response();
}
inline void DeviceManagementResponse::clear_cert_upload_response() {
  if (_impl_.cert_upload_response_ != nullptr) _impl_.cert_upload_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::enterprise_management::DeviceCertUploadResponse& DeviceManagementResponse::_internal_cert_upload_response() const {
  const ::enterprise_management::DeviceCertUploadResponse* p = _impl_.cert_upload_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceCertUploadResponse&>(
      ::enterprise_management::_DeviceCertUploadResponse_default_instance_);
}
inline const ::enterprise_management::DeviceCertUploadResponse& DeviceManagementResponse::cert_upload_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.cert_upload_response)
  return _internal_cert_upload_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_cert_upload_response(
    ::enterprise_management::DeviceCertUploadResponse* cert_upload_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cert_upload_response_);
  }
  _impl_.cert_upload_response_ = cert_upload_response;
  if (cert_upload_response) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.cert_upload_response)
}
inline ::enterprise_management::DeviceCertUploadResponse* DeviceManagementResponse::release_cert_upload_response() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::DeviceCertUploadResponse* temp = _impl_.cert_upload_response_;
  _impl_.cert_upload_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceCertUploadResponse* DeviceManagementResponse::unsafe_arena_release_cert_upload_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.cert_upload_response)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::enterprise_management::DeviceCertUploadResponse* temp = _impl_.cert_upload_response_;
  _impl_.cert_upload_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceCertUploadResponse* DeviceManagementResponse::_internal_mutable_cert_upload_response() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.cert_upload_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceCertUploadResponse>(GetArenaForAllocation());
    _impl_.cert_upload_response_ = p;
  }
  return _impl_.cert_upload_response_;
}
inline ::enterprise_management::DeviceCertUploadResponse* DeviceManagementResponse::mutable_cert_upload_response() {
  ::enterprise_management::DeviceCertUploadResponse* _msg = _internal_mutable_cert_upload_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.cert_upload_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_cert_upload_response(::enterprise_management::DeviceCertUploadResponse* cert_upload_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cert_upload_response_;
  }
  if (cert_upload_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cert_upload_response);
    if (message_arena != submessage_arena) {
      cert_upload_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cert_upload_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.cert_upload_response_ = cert_upload_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.cert_upload_response)
}

// optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
inline bool DeviceManagementResponse::_internal_has_service_api_access_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.service_api_access_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_service_api_access_response() const {
  return _internal_has_service_api_access_response();
}
inline void DeviceManagementResponse::clear_service_api_access_response() {
  if (_impl_.service_api_access_response_ != nullptr) _impl_.service_api_access_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::enterprise_management::DeviceServiceApiAccessResponse& DeviceManagementResponse::_internal_service_api_access_response() const {
  const ::enterprise_management::DeviceServiceApiAccessResponse* p = _impl_.service_api_access_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceServiceApiAccessResponse&>(
      ::enterprise_management::_DeviceServiceApiAccessResponse_default_instance_);
}
inline const ::enterprise_management::DeviceServiceApiAccessResponse& DeviceManagementResponse::service_api_access_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.service_api_access_response)
  return _internal_service_api_access_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_service_api_access_response(
    ::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_api_access_response_);
  }
  _impl_.service_api_access_response_ = service_api_access_response;
  if (service_api_access_response) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.service_api_access_response)
}
inline ::enterprise_management::DeviceServiceApiAccessResponse* DeviceManagementResponse::release_service_api_access_response() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::DeviceServiceApiAccessResponse* temp = _impl_.service_api_access_response_;
  _impl_.service_api_access_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceServiceApiAccessResponse* DeviceManagementResponse::unsafe_arena_release_service_api_access_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.service_api_access_response)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::enterprise_management::DeviceServiceApiAccessResponse* temp = _impl_.service_api_access_response_;
  _impl_.service_api_access_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceServiceApiAccessResponse* DeviceManagementResponse::_internal_mutable_service_api_access_response() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.service_api_access_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceServiceApiAccessResponse>(GetArenaForAllocation());
    _impl_.service_api_access_response_ = p;
  }
  return _impl_.service_api_access_response_;
}
inline ::enterprise_management::DeviceServiceApiAccessResponse* DeviceManagementResponse::mutable_service_api_access_response() {
  ::enterprise_management::DeviceServiceApiAccessResponse* _msg = _internal_mutable_service_api_access_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.service_api_access_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_service_api_access_response(::enterprise_management::DeviceServiceApiAccessResponse* service_api_access_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_api_access_response_;
  }
  if (service_api_access_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_api_access_response);
    if (message_arena != submessage_arena) {
      service_api_access_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_api_access_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.service_api_access_response_ = service_api_access_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.service_api_access_response)
}

// optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
inline bool DeviceManagementResponse::_internal_has_device_state_retrieval_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_state_retrieval_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_device_state_retrieval_response() const {
  return _internal_has_device_state_retrieval_response();
}
inline void DeviceManagementResponse::clear_device_state_retrieval_response() {
  if (_impl_.device_state_retrieval_response_ != nullptr) _impl_.device_state_retrieval_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::enterprise_management::DeviceStateRetrievalResponse& DeviceManagementResponse::_internal_device_state_retrieval_response() const {
  const ::enterprise_management::DeviceStateRetrievalResponse* p = _impl_.device_state_retrieval_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceStateRetrievalResponse&>(
      ::enterprise_management::_DeviceStateRetrievalResponse_default_instance_);
}
inline const ::enterprise_management::DeviceStateRetrievalResponse& DeviceManagementResponse::device_state_retrieval_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
  return _internal_device_state_retrieval_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_device_state_retrieval_response(
    ::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_state_retrieval_response_);
  }
  _impl_.device_state_retrieval_response_ = device_state_retrieval_response;
  if (device_state_retrieval_response) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
}
inline ::enterprise_management::DeviceStateRetrievalResponse* DeviceManagementResponse::release_device_state_retrieval_response() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::DeviceStateRetrievalResponse* temp = _impl_.device_state_retrieval_response_;
  _impl_.device_state_retrieval_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceStateRetrievalResponse* DeviceManagementResponse::unsafe_arena_release_device_state_retrieval_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::enterprise_management::DeviceStateRetrievalResponse* temp = _impl_.device_state_retrieval_response_;
  _impl_.device_state_retrieval_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceStateRetrievalResponse* DeviceManagementResponse::_internal_mutable_device_state_retrieval_response() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.device_state_retrieval_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceStateRetrievalResponse>(GetArenaForAllocation());
    _impl_.device_state_retrieval_response_ = p;
  }
  return _impl_.device_state_retrieval_response_;
}
inline ::enterprise_management::DeviceStateRetrievalResponse* DeviceManagementResponse::mutable_device_state_retrieval_response() {
  ::enterprise_management::DeviceStateRetrievalResponse* _msg = _internal_mutable_device_state_retrieval_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_device_state_retrieval_response(::enterprise_management::DeviceStateRetrievalResponse* device_state_retrieval_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_state_retrieval_response_;
  }
  if (device_state_retrieval_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_state_retrieval_response);
    if (message_arena != submessage_arena) {
      device_state_retrieval_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_state_retrieval_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.device_state_retrieval_response_ = device_state_retrieval_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_state_retrieval_response)
}

// optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
inline bool DeviceManagementResponse::_internal_has_device_pairing_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_pairing_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_device_pairing_response() const {
  return _internal_has_device_pairing_response();
}
inline void DeviceManagementResponse::clear_device_pairing_response() {
  if (_impl_.device_pairing_response_ != nullptr) _impl_.device_pairing_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::enterprise_management::DevicePairingResponse& DeviceManagementResponse::_internal_device_pairing_response() const {
  const ::enterprise_management::DevicePairingResponse* p = _impl_.device_pairing_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DevicePairingResponse&>(
      ::enterprise_management::_DevicePairingResponse_default_instance_);
}
inline const ::enterprise_management::DevicePairingResponse& DeviceManagementResponse::device_pairing_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_pairing_response)
  return _internal_device_pairing_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_device_pairing_response(
    ::enterprise_management::DevicePairingResponse* device_pairing_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_pairing_response_);
  }
  _impl_.device_pairing_response_ = device_pairing_response;
  if (device_pairing_response) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.device_pairing_response)
}
inline ::enterprise_management::DevicePairingResponse* DeviceManagementResponse::release_device_pairing_response() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::DevicePairingResponse* temp = _impl_.device_pairing_response_;
  _impl_.device_pairing_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DevicePairingResponse* DeviceManagementResponse::unsafe_arena_release_device_pairing_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_pairing_response)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::enterprise_management::DevicePairingResponse* temp = _impl_.device_pairing_response_;
  _impl_.device_pairing_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DevicePairingResponse* DeviceManagementResponse::_internal_mutable_device_pairing_response() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.device_pairing_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DevicePairingResponse>(GetArenaForAllocation());
    _impl_.device_pairing_response_ = p;
  }
  return _impl_.device_pairing_response_;
}
inline ::enterprise_management::DevicePairingResponse* DeviceManagementResponse::mutable_device_pairing_response() {
  ::enterprise_management::DevicePairingResponse* _msg = _internal_mutable_device_pairing_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_pairing_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_device_pairing_response(::enterprise_management::DevicePairingResponse* device_pairing_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_pairing_response_;
  }
  if (device_pairing_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_pairing_response);
    if (message_arena != submessage_arena) {
      device_pairing_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_pairing_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.device_pairing_response_ = device_pairing_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_pairing_response)
}

// optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
inline bool DeviceManagementResponse::_internal_has_check_device_pairing_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_device_pairing_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_check_device_pairing_response() const {
  return _internal_has_check_device_pairing_response();
}
inline void DeviceManagementResponse::clear_check_device_pairing_response() {
  if (_impl_.check_device_pairing_response_ != nullptr) _impl_.check_device_pairing_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_management::CheckDevicePairingResponse& DeviceManagementResponse::_internal_check_device_pairing_response() const {
  const ::enterprise_management::CheckDevicePairingResponse* p = _impl_.check_device_pairing_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CheckDevicePairingResponse&>(
      ::enterprise_management::_CheckDevicePairingResponse_default_instance_);
}
inline const ::enterprise_management::CheckDevicePairingResponse& DeviceManagementResponse::check_device_pairing_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
  return _internal_check_device_pairing_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_check_device_pairing_response(
    ::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_device_pairing_response_);
  }
  _impl_.check_device_pairing_response_ = check_device_pairing_response;
  if (check_device_pairing_response) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
}
inline ::enterprise_management::CheckDevicePairingResponse* DeviceManagementResponse::release_check_device_pairing_response() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::CheckDevicePairingResponse* temp = _impl_.check_device_pairing_response_;
  _impl_.check_device_pairing_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CheckDevicePairingResponse* DeviceManagementResponse::unsafe_arena_release_check_device_pairing_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::enterprise_management::CheckDevicePairingResponse* temp = _impl_.check_device_pairing_response_;
  _impl_.check_device_pairing_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::CheckDevicePairingResponse* DeviceManagementResponse::_internal_mutable_check_device_pairing_response() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.check_device_pairing_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CheckDevicePairingResponse>(GetArenaForAllocation());
    _impl_.check_device_pairing_response_ = p;
  }
  return _impl_.check_device_pairing_response_;
}
inline ::enterprise_management::CheckDevicePairingResponse* DeviceManagementResponse::mutable_check_device_pairing_response() {
  ::enterprise_management::CheckDevicePairingResponse* _msg = _internal_mutable_check_device_pairing_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_check_device_pairing_response(::enterprise_management::CheckDevicePairingResponse* check_device_pairing_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_device_pairing_response_;
  }
  if (check_device_pairing_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_device_pairing_response);
    if (message_arena != submessage_arena) {
      check_device_pairing_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_device_pairing_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.check_device_pairing_response_ = check_device_pairing_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_device_pairing_response)
}

// optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
inline bool DeviceManagementResponse::_internal_has_remote_command_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.remote_command_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_remote_command_response() const {
  return _internal_has_remote_command_response();
}
inline void DeviceManagementResponse::clear_remote_command_response() {
  if (_impl_.remote_command_response_ != nullptr) _impl_.remote_command_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::enterprise_management::DeviceRemoteCommandResponse& DeviceManagementResponse::_internal_remote_command_response() const {
  const ::enterprise_management::DeviceRemoteCommandResponse* p = _impl_.remote_command_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceRemoteCommandResponse&>(
      ::enterprise_management::_DeviceRemoteCommandResponse_default_instance_);
}
inline const ::enterprise_management::DeviceRemoteCommandResponse& DeviceManagementResponse::remote_command_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.remote_command_response)
  return _internal_remote_command_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_remote_command_response(
    ::enterprise_management::DeviceRemoteCommandResponse* remote_command_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remote_command_response_);
  }
  _impl_.remote_command_response_ = remote_command_response;
  if (remote_command_response) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.remote_command_response)
}
inline ::enterprise_management::DeviceRemoteCommandResponse* DeviceManagementResponse::release_remote_command_response() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::DeviceRemoteCommandResponse* temp = _impl_.remote_command_response_;
  _impl_.remote_command_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceRemoteCommandResponse* DeviceManagementResponse::unsafe_arena_release_remote_command_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.remote_command_response)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::enterprise_management::DeviceRemoteCommandResponse* temp = _impl_.remote_command_response_;
  _impl_.remote_command_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceRemoteCommandResponse* DeviceManagementResponse::_internal_mutable_remote_command_response() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.remote_command_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceRemoteCommandResponse>(GetArenaForAllocation());
    _impl_.remote_command_response_ = p;
  }
  return _impl_.remote_command_response_;
}
inline ::enterprise_management::DeviceRemoteCommandResponse* DeviceManagementResponse::mutable_remote_command_response() {
  ::enterprise_management::DeviceRemoteCommandResponse* _msg = _internal_mutable_remote_command_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.remote_command_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_remote_command_response(::enterprise_management::DeviceRemoteCommandResponse* remote_command_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remote_command_response_;
  }
  if (remote_command_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remote_command_response);
    if (message_arena != submessage_arena) {
      remote_command_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remote_command_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.remote_command_response_ = remote_command_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.remote_command_response)
}

// optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
inline bool DeviceManagementResponse::_internal_has_device_attribute_update_permission_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_attribute_update_permission_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_device_attribute_update_permission_response() const {
  return _internal_has_device_attribute_update_permission_response();
}
inline void DeviceManagementResponse::clear_device_attribute_update_permission_response() {
  if (_impl_.device_attribute_update_permission_response_ != nullptr) _impl_.device_attribute_update_permission_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& DeviceManagementResponse::_internal_device_attribute_update_permission_response() const {
  const ::enterprise_management::DeviceAttributeUpdatePermissionResponse* p = _impl_.device_attribute_update_permission_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAttributeUpdatePermissionResponse&>(
      ::enterprise_management::_DeviceAttributeUpdatePermissionResponse_default_instance_);
}
inline const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& DeviceManagementResponse::device_attribute_update_permission_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
  return _internal_device_attribute_update_permission_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_device_attribute_update_permission_response(
    ::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_attribute_update_permission_response_);
  }
  _impl_.device_attribute_update_permission_response_ = device_attribute_update_permission_response;
  if (device_attribute_update_permission_response) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse* DeviceManagementResponse::release_device_attribute_update_permission_response() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::DeviceAttributeUpdatePermissionResponse* temp = _impl_.device_attribute_update_permission_response_;
  _impl_.device_attribute_update_permission_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse* DeviceManagementResponse::unsafe_arena_release_device_attribute_update_permission_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::enterprise_management::DeviceAttributeUpdatePermissionResponse* temp = _impl_.device_attribute_update_permission_response_;
  _impl_.device_attribute_update_permission_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse* DeviceManagementResponse::_internal_mutable_device_attribute_update_permission_response() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.device_attribute_update_permission_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdatePermissionResponse>(GetArenaForAllocation());
    _impl_.device_attribute_update_permission_response_ = p;
  }
  return _impl_.device_attribute_update_permission_response_;
}
inline ::enterprise_management::DeviceAttributeUpdatePermissionResponse* DeviceManagementResponse::mutable_device_attribute_update_permission_response() {
  ::enterprise_management::DeviceAttributeUpdatePermissionResponse* _msg = _internal_mutable_device_attribute_update_permission_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_device_attribute_update_permission_response(::enterprise_management::DeviceAttributeUpdatePermissionResponse* device_attribute_update_permission_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_attribute_update_permission_response_;
  }
  if (device_attribute_update_permission_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_attribute_update_permission_response);
    if (message_arena != submessage_arena) {
      device_attribute_update_permission_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_attribute_update_permission_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.device_attribute_update_permission_response_ = device_attribute_update_permission_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_attribute_update_permission_response)
}

// optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
inline bool DeviceManagementResponse::_internal_has_device_attribute_update_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_attribute_update_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_device_attribute_update_response() const {
  return _internal_has_device_attribute_update_response();
}
inline void DeviceManagementResponse::clear_device_attribute_update_response() {
  if (_impl_.device_attribute_update_response_ != nullptr) _impl_.device_attribute_update_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::enterprise_management::DeviceAttributeUpdateResponse& DeviceManagementResponse::_internal_device_attribute_update_response() const {
  const ::enterprise_management::DeviceAttributeUpdateResponse* p = _impl_.device_attribute_update_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceAttributeUpdateResponse&>(
      ::enterprise_management::_DeviceAttributeUpdateResponse_default_instance_);
}
inline const ::enterprise_management::DeviceAttributeUpdateResponse& DeviceManagementResponse::device_attribute_update_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
  return _internal_device_attribute_update_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_device_attribute_update_response(
    ::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_attribute_update_response_);
  }
  _impl_.device_attribute_update_response_ = device_attribute_update_response;
  if (device_attribute_update_response) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
}
inline ::enterprise_management::DeviceAttributeUpdateResponse* DeviceManagementResponse::release_device_attribute_update_response() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::DeviceAttributeUpdateResponse* temp = _impl_.device_attribute_update_response_;
  _impl_.device_attribute_update_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceAttributeUpdateResponse* DeviceManagementResponse::unsafe_arena_release_device_attribute_update_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::enterprise_management::DeviceAttributeUpdateResponse* temp = _impl_.device_attribute_update_response_;
  _impl_.device_attribute_update_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceAttributeUpdateResponse* DeviceManagementResponse::_internal_mutable_device_attribute_update_response() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.device_attribute_update_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceAttributeUpdateResponse>(GetArenaForAllocation());
    _impl_.device_attribute_update_response_ = p;
  }
  return _impl_.device_attribute_update_response_;
}
inline ::enterprise_management::DeviceAttributeUpdateResponse* DeviceManagementResponse::mutable_device_attribute_update_response() {
  ::enterprise_management::DeviceAttributeUpdateResponse* _msg = _internal_mutable_device_attribute_update_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_device_attribute_update_response(::enterprise_management::DeviceAttributeUpdateResponse* device_attribute_update_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_attribute_update_response_;
  }
  if (device_attribute_update_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_attribute_update_response);
    if (message_arena != submessage_arena) {
      device_attribute_update_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_attribute_update_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.device_attribute_update_response_ = device_attribute_update_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_attribute_update_response)
}

// optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
inline bool DeviceManagementResponse::_internal_has_gcm_id_update_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gcm_id_update_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_gcm_id_update_response() const {
  return _internal_has_gcm_id_update_response();
}
inline void DeviceManagementResponse::clear_gcm_id_update_response() {
  if (_impl_.gcm_id_update_response_ != nullptr) _impl_.gcm_id_update_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::enterprise_management::GcmIdUpdateResponse& DeviceManagementResponse::_internal_gcm_id_update_response() const {
  const ::enterprise_management::GcmIdUpdateResponse* p = _impl_.gcm_id_update_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::GcmIdUpdateResponse&>(
      ::enterprise_management::_GcmIdUpdateResponse_default_instance_);
}
inline const ::enterprise_management::GcmIdUpdateResponse& DeviceManagementResponse::gcm_id_update_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
  return _internal_gcm_id_update_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_gcm_id_update_response(
    ::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gcm_id_update_response_);
  }
  _impl_.gcm_id_update_response_ = gcm_id_update_response;
  if (gcm_id_update_response) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
}
inline ::enterprise_management::GcmIdUpdateResponse* DeviceManagementResponse::release_gcm_id_update_response() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::enterprise_management::GcmIdUpdateResponse* temp = _impl_.gcm_id_update_response_;
  _impl_.gcm_id_update_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::GcmIdUpdateResponse* DeviceManagementResponse::unsafe_arena_release_gcm_id_update_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::enterprise_management::GcmIdUpdateResponse* temp = _impl_.gcm_id_update_response_;
  _impl_.gcm_id_update_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::GcmIdUpdateResponse* DeviceManagementResponse::_internal_mutable_gcm_id_update_response() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.gcm_id_update_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::GcmIdUpdateResponse>(GetArenaForAllocation());
    _impl_.gcm_id_update_response_ = p;
  }
  return _impl_.gcm_id_update_response_;
}
inline ::enterprise_management::GcmIdUpdateResponse* DeviceManagementResponse::mutable_gcm_id_update_response() {
  ::enterprise_management::GcmIdUpdateResponse* _msg = _internal_mutable_gcm_id_update_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_gcm_id_update_response(::enterprise_management::GcmIdUpdateResponse* gcm_id_update_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gcm_id_update_response_;
  }
  if (gcm_id_update_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gcm_id_update_response);
    if (message_arena != submessage_arena) {
      gcm_id_update_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gcm_id_update_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.gcm_id_update_response_ = gcm_id_update_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.gcm_id_update_response)
}

// optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
inline bool DeviceManagementResponse::_internal_has_check_android_management_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_android_management_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_check_android_management_response() const {
  return _internal_has_check_android_management_response();
}
inline void DeviceManagementResponse::clear_check_android_management_response() {
  if (_impl_.check_android_management_response_ != nullptr) _impl_.check_android_management_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::enterprise_management::CheckAndroidManagementResponse& DeviceManagementResponse::_internal_check_android_management_response() const {
  const ::enterprise_management::CheckAndroidManagementResponse* p = _impl_.check_android_management_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CheckAndroidManagementResponse&>(
      ::enterprise_management::_CheckAndroidManagementResponse_default_instance_);
}
inline const ::enterprise_management::CheckAndroidManagementResponse& DeviceManagementResponse::check_android_management_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_android_management_response)
  return _internal_check_android_management_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_check_android_management_response(
    ::enterprise_management::CheckAndroidManagementResponse* check_android_management_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_android_management_response_);
  }
  _impl_.check_android_management_response_ = check_android_management_response;
  if (check_android_management_response) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.check_android_management_response)
}
inline ::enterprise_management::CheckAndroidManagementResponse* DeviceManagementResponse::release_check_android_management_response() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::enterprise_management::CheckAndroidManagementResponse* temp = _impl_.check_android_management_response_;
  _impl_.check_android_management_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CheckAndroidManagementResponse* DeviceManagementResponse::unsafe_arena_release_check_android_management_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_android_management_response)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::enterprise_management::CheckAndroidManagementResponse* temp = _impl_.check_android_management_response_;
  _impl_.check_android_management_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::CheckAndroidManagementResponse* DeviceManagementResponse::_internal_mutable_check_android_management_response() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.check_android_management_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CheckAndroidManagementResponse>(GetArenaForAllocation());
    _impl_.check_android_management_response_ = p;
  }
  return _impl_.check_android_management_response_;
}
inline ::enterprise_management::CheckAndroidManagementResponse* DeviceManagementResponse::mutable_check_android_management_response() {
  ::enterprise_management::CheckAndroidManagementResponse* _msg = _internal_mutable_check_android_management_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_android_management_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_check_android_management_response(::enterprise_management::CheckAndroidManagementResponse* check_android_management_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_android_management_response_;
  }
  if (check_android_management_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_android_management_response);
    if (message_arena != submessage_arena) {
      check_android_management_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_android_management_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.check_android_management_response_ = check_android_management_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_android_management_response)
}

// optional .enterprise_management.ActiveDirectoryEnrollPlayUserResponse active_directory_enroll_play_user_response = 19;
inline bool DeviceManagementResponse::_internal_has_active_directory_enroll_play_user_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_directory_enroll_play_user_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_active_directory_enroll_play_user_response() const {
  return _internal_has_active_directory_enroll_play_user_response();
}
inline void DeviceManagementResponse::clear_active_directory_enroll_play_user_response() {
  if (_impl_.active_directory_enroll_play_user_response_ != nullptr) _impl_.active_directory_enroll_play_user_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse& DeviceManagementResponse::_internal_active_directory_enroll_play_user_response() const {
  const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* p = _impl_.active_directory_enroll_play_user_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse&>(
      ::enterprise_management::_ActiveDirectoryEnrollPlayUserResponse_default_instance_);
}
inline const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse& DeviceManagementResponse::active_directory_enroll_play_user_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
  return _internal_active_directory_enroll_play_user_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_active_directory_enroll_play_user_response(
    ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* active_directory_enroll_play_user_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_directory_enroll_play_user_response_);
  }
  _impl_.active_directory_enroll_play_user_response_ = active_directory_enroll_play_user_response;
  if (active_directory_enroll_play_user_response) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* DeviceManagementResponse::release_active_directory_enroll_play_user_response() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* temp = _impl_.active_directory_enroll_play_user_response_;
  _impl_.active_directory_enroll_play_user_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* DeviceManagementResponse::unsafe_arena_release_active_directory_enroll_play_user_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* temp = _impl_.active_directory_enroll_play_user_response_;
  _impl_.active_directory_enroll_play_user_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* DeviceManagementResponse::_internal_mutable_active_directory_enroll_play_user_response() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.active_directory_enroll_play_user_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryEnrollPlayUserResponse>(GetArenaForAllocation());
    _impl_.active_directory_enroll_play_user_response_ = p;
  }
  return _impl_.active_directory_enroll_play_user_response_;
}
inline ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* DeviceManagementResponse::mutable_active_directory_enroll_play_user_response() {
  ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* _msg = _internal_mutable_active_directory_enroll_play_user_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_active_directory_enroll_play_user_response(::enterprise_management::ActiveDirectoryEnrollPlayUserResponse* active_directory_enroll_play_user_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.active_directory_enroll_play_user_response_;
  }
  if (active_directory_enroll_play_user_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(active_directory_enroll_play_user_response);
    if (message_arena != submessage_arena) {
      active_directory_enroll_play_user_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_directory_enroll_play_user_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.active_directory_enroll_play_user_response_ = active_directory_enroll_play_user_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_enroll_play_user_response)
}

// optional .enterprise_management.ActiveDirectoryPlayActivityResponse active_directory_play_activity_response = 20;
inline bool DeviceManagementResponse::_internal_has_active_directory_play_activity_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_directory_play_activity_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_active_directory_play_activity_response() const {
  return _internal_has_active_directory_play_activity_response();
}
inline void DeviceManagementResponse::clear_active_directory_play_activity_response() {
  if (_impl_.active_directory_play_activity_response_ != nullptr) _impl_.active_directory_play_activity_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::enterprise_management::ActiveDirectoryPlayActivityResponse& DeviceManagementResponse::_internal_active_directory_play_activity_response() const {
  const ::enterprise_management::ActiveDirectoryPlayActivityResponse* p = _impl_.active_directory_play_activity_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ActiveDirectoryPlayActivityResponse&>(
      ::enterprise_management::_ActiveDirectoryPlayActivityResponse_default_instance_);
}
inline const ::enterprise_management::ActiveDirectoryPlayActivityResponse& DeviceManagementResponse::active_directory_play_activity_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
  return _internal_active_directory_play_activity_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_active_directory_play_activity_response(
    ::enterprise_management::ActiveDirectoryPlayActivityResponse* active_directory_play_activity_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_directory_play_activity_response_);
  }
  _impl_.active_directory_play_activity_response_ = active_directory_play_activity_response;
  if (active_directory_play_activity_response) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
}
inline ::enterprise_management::ActiveDirectoryPlayActivityResponse* DeviceManagementResponse::release_active_directory_play_activity_response() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::enterprise_management::ActiveDirectoryPlayActivityResponse* temp = _impl_.active_directory_play_activity_response_;
  _impl_.active_directory_play_activity_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ActiveDirectoryPlayActivityResponse* DeviceManagementResponse::unsafe_arena_release_active_directory_play_activity_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::enterprise_management::ActiveDirectoryPlayActivityResponse* temp = _impl_.active_directory_play_activity_response_;
  _impl_.active_directory_play_activity_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::ActiveDirectoryPlayActivityResponse* DeviceManagementResponse::_internal_mutable_active_directory_play_activity_response() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.active_directory_play_activity_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryPlayActivityResponse>(GetArenaForAllocation());
    _impl_.active_directory_play_activity_response_ = p;
  }
  return _impl_.active_directory_play_activity_response_;
}
inline ::enterprise_management::ActiveDirectoryPlayActivityResponse* DeviceManagementResponse::mutable_active_directory_play_activity_response() {
  ::enterprise_management::ActiveDirectoryPlayActivityResponse* _msg = _internal_mutable_active_directory_play_activity_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_active_directory_play_activity_response(::enterprise_management::ActiveDirectoryPlayActivityResponse* active_directory_play_activity_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.active_directory_play_activity_response_;
  }
  if (active_directory_play_activity_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(active_directory_play_activity_response);
    if (message_arena != submessage_arena) {
      active_directory_play_activity_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_directory_play_activity_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.active_directory_play_activity_response_ = active_directory_play_activity_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_play_activity_response)
}

// optional .enterprise_management.CheckDeviceLicenseResponse check_device_license_response_deprecated = 21 [deprecated = true];
inline bool DeviceManagementResponse::_internal_has_check_device_license_response_deprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_device_license_response_deprecated_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_check_device_license_response_deprecated() const {
  return _internal_has_check_device_license_response_deprecated();
}
inline void DeviceManagementResponse::clear_check_device_license_response_deprecated() {
  if (_impl_.check_device_license_response_deprecated_ != nullptr) _impl_.check_device_license_response_deprecated_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::enterprise_management::CheckDeviceLicenseResponse& DeviceManagementResponse::_internal_check_device_license_response_deprecated() const {
  const ::enterprise_management::CheckDeviceLicenseResponse* p = _impl_.check_device_license_response_deprecated_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CheckDeviceLicenseResponse&>(
      ::enterprise_management::_CheckDeviceLicenseResponse_default_instance_);
}
inline const ::enterprise_management::CheckDeviceLicenseResponse& DeviceManagementResponse::check_device_license_response_deprecated() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
  return _internal_check_device_license_response_deprecated();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_check_device_license_response_deprecated(
    ::enterprise_management::CheckDeviceLicenseResponse* check_device_license_response_deprecated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_device_license_response_deprecated_);
  }
  _impl_.check_device_license_response_deprecated_ = check_device_license_response_deprecated;
  if (check_device_license_response_deprecated) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
}
inline ::enterprise_management::CheckDeviceLicenseResponse* DeviceManagementResponse::release_check_device_license_response_deprecated() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::enterprise_management::CheckDeviceLicenseResponse* temp = _impl_.check_device_license_response_deprecated_;
  _impl_.check_device_license_response_deprecated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CheckDeviceLicenseResponse* DeviceManagementResponse::unsafe_arena_release_check_device_license_response_deprecated() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::enterprise_management::CheckDeviceLicenseResponse* temp = _impl_.check_device_license_response_deprecated_;
  _impl_.check_device_license_response_deprecated_ = nullptr;
  return temp;
}
inline ::enterprise_management::CheckDeviceLicenseResponse* DeviceManagementResponse::_internal_mutable_check_device_license_response_deprecated() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.check_device_license_response_deprecated_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CheckDeviceLicenseResponse>(GetArenaForAllocation());
    _impl_.check_device_license_response_deprecated_ = p;
  }
  return _impl_.check_device_license_response_deprecated_;
}
inline ::enterprise_management::CheckDeviceLicenseResponse* DeviceManagementResponse::mutable_check_device_license_response_deprecated() {
  ::enterprise_management::CheckDeviceLicenseResponse* _msg = _internal_mutable_check_device_license_response_deprecated();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_check_device_license_response_deprecated(::enterprise_management::CheckDeviceLicenseResponse* check_device_license_response_deprecated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_device_license_response_deprecated_;
  }
  if (check_device_license_response_deprecated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_device_license_response_deprecated);
    if (message_arena != submessage_arena) {
      check_device_license_response_deprecated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_device_license_response_deprecated, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.check_device_license_response_deprecated_ = check_device_license_response_deprecated;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_device_license_response_deprecated)
}

// optional .enterprise_management.ActiveDirectoryUserSigninResponse active_directory_user_signin_response = 22;
inline bool DeviceManagementResponse::_internal_has_active_directory_user_signin_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_directory_user_signin_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_active_directory_user_signin_response() const {
  return _internal_has_active_directory_user_signin_response();
}
inline void DeviceManagementResponse::clear_active_directory_user_signin_response() {
  if (_impl_.active_directory_user_signin_response_ != nullptr) _impl_.active_directory_user_signin_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::enterprise_management::ActiveDirectoryUserSigninResponse& DeviceManagementResponse::_internal_active_directory_user_signin_response() const {
  const ::enterprise_management::ActiveDirectoryUserSigninResponse* p = _impl_.active_directory_user_signin_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ActiveDirectoryUserSigninResponse&>(
      ::enterprise_management::_ActiveDirectoryUserSigninResponse_default_instance_);
}
inline const ::enterprise_management::ActiveDirectoryUserSigninResponse& DeviceManagementResponse::active_directory_user_signin_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
  return _internal_active_directory_user_signin_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_active_directory_user_signin_response(
    ::enterprise_management::ActiveDirectoryUserSigninResponse* active_directory_user_signin_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_directory_user_signin_response_);
  }
  _impl_.active_directory_user_signin_response_ = active_directory_user_signin_response;
  if (active_directory_user_signin_response) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
}
inline ::enterprise_management::ActiveDirectoryUserSigninResponse* DeviceManagementResponse::release_active_directory_user_signin_response() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::enterprise_management::ActiveDirectoryUserSigninResponse* temp = _impl_.active_directory_user_signin_response_;
  _impl_.active_directory_user_signin_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ActiveDirectoryUserSigninResponse* DeviceManagementResponse::unsafe_arena_release_active_directory_user_signin_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::enterprise_management::ActiveDirectoryUserSigninResponse* temp = _impl_.active_directory_user_signin_response_;
  _impl_.active_directory_user_signin_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::ActiveDirectoryUserSigninResponse* DeviceManagementResponse::_internal_mutable_active_directory_user_signin_response() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.active_directory_user_signin_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ActiveDirectoryUserSigninResponse>(GetArenaForAllocation());
    _impl_.active_directory_user_signin_response_ = p;
  }
  return _impl_.active_directory_user_signin_response_;
}
inline ::enterprise_management::ActiveDirectoryUserSigninResponse* DeviceManagementResponse::mutable_active_directory_user_signin_response() {
  ::enterprise_management::ActiveDirectoryUserSigninResponse* _msg = _internal_mutable_active_directory_user_signin_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_active_directory_user_signin_response(::enterprise_management::ActiveDirectoryUserSigninResponse* active_directory_user_signin_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.active_directory_user_signin_response_;
  }
  if (active_directory_user_signin_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(active_directory_user_signin_response);
    if (message_arena != submessage_arena) {
      active_directory_user_signin_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_directory_user_signin_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.active_directory_user_signin_response_ = active_directory_user_signin_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.active_directory_user_signin_response)
}

// optional .enterprise_management.ChromeDesktopReportResponse chrome_desktop_report_response = 23;
inline bool DeviceManagementResponse::_internal_has_chrome_desktop_report_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chrome_desktop_report_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_chrome_desktop_report_response() const {
  return _internal_has_chrome_desktop_report_response();
}
inline void DeviceManagementResponse::clear_chrome_desktop_report_response() {
  if (_impl_.chrome_desktop_report_response_ != nullptr) _impl_.chrome_desktop_report_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const ::enterprise_management::ChromeDesktopReportResponse& DeviceManagementResponse::_internal_chrome_desktop_report_response() const {
  const ::enterprise_management::ChromeDesktopReportResponse* p = _impl_.chrome_desktop_report_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChromeDesktopReportResponse&>(
      ::enterprise_management::_ChromeDesktopReportResponse_default_instance_);
}
inline const ::enterprise_management::ChromeDesktopReportResponse& DeviceManagementResponse::chrome_desktop_report_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
  return _internal_chrome_desktop_report_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_chrome_desktop_report_response(
    ::enterprise_management::ChromeDesktopReportResponse* chrome_desktop_report_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_desktop_report_response_);
  }
  _impl_.chrome_desktop_report_response_ = chrome_desktop_report_response;
  if (chrome_desktop_report_response) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
}
inline ::enterprise_management::ChromeDesktopReportResponse* DeviceManagementResponse::release_chrome_desktop_report_response() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::enterprise_management::ChromeDesktopReportResponse* temp = _impl_.chrome_desktop_report_response_;
  _impl_.chrome_desktop_report_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChromeDesktopReportResponse* DeviceManagementResponse::unsafe_arena_release_chrome_desktop_report_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::enterprise_management::ChromeDesktopReportResponse* temp = _impl_.chrome_desktop_report_response_;
  _impl_.chrome_desktop_report_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChromeDesktopReportResponse* DeviceManagementResponse::_internal_mutable_chrome_desktop_report_response() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.chrome_desktop_report_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChromeDesktopReportResponse>(GetArenaForAllocation());
    _impl_.chrome_desktop_report_response_ = p;
  }
  return _impl_.chrome_desktop_report_response_;
}
inline ::enterprise_management::ChromeDesktopReportResponse* DeviceManagementResponse::mutable_chrome_desktop_report_response() {
  ::enterprise_management::ChromeDesktopReportResponse* _msg = _internal_mutable_chrome_desktop_report_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_chrome_desktop_report_response(::enterprise_management::ChromeDesktopReportResponse* chrome_desktop_report_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chrome_desktop_report_response_;
  }
  if (chrome_desktop_report_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_desktop_report_response);
    if (message_arena != submessage_arena) {
      chrome_desktop_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_desktop_report_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.chrome_desktop_report_response_ = chrome_desktop_report_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.chrome_desktop_report_response)
}

// optional .enterprise_management.AppInstallReportResponse app_install_report_response = 25;
inline bool DeviceManagementResponse::_internal_has_app_install_report_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_install_report_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_app_install_report_response() const {
  return _internal_has_app_install_report_response();
}
inline void DeviceManagementResponse::clear_app_install_report_response() {
  if (_impl_.app_install_report_response_ != nullptr) _impl_.app_install_report_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::enterprise_management::AppInstallReportResponse& DeviceManagementResponse::_internal_app_install_report_response() const {
  const ::enterprise_management::AppInstallReportResponse* p = _impl_.app_install_report_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::AppInstallReportResponse&>(
      ::enterprise_management::_AppInstallReportResponse_default_instance_);
}
inline const ::enterprise_management::AppInstallReportResponse& DeviceManagementResponse::app_install_report_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.app_install_report_response)
  return _internal_app_install_report_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_app_install_report_response(
    ::enterprise_management::AppInstallReportResponse* app_install_report_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_install_report_response_);
  }
  _impl_.app_install_report_response_ = app_install_report_response;
  if (app_install_report_response) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.app_install_report_response)
}
inline ::enterprise_management::AppInstallReportResponse* DeviceManagementResponse::release_app_install_report_response() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::enterprise_management::AppInstallReportResponse* temp = _impl_.app_install_report_response_;
  _impl_.app_install_report_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::AppInstallReportResponse* DeviceManagementResponse::unsafe_arena_release_app_install_report_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.app_install_report_response)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::enterprise_management::AppInstallReportResponse* temp = _impl_.app_install_report_response_;
  _impl_.app_install_report_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::AppInstallReportResponse* DeviceManagementResponse::_internal_mutable_app_install_report_response() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.app_install_report_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::AppInstallReportResponse>(GetArenaForAllocation());
    _impl_.app_install_report_response_ = p;
  }
  return _impl_.app_install_report_response_;
}
inline ::enterprise_management::AppInstallReportResponse* DeviceManagementResponse::mutable_app_install_report_response() {
  ::enterprise_management::AppInstallReportResponse* _msg = _internal_mutable_app_install_report_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.app_install_report_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_app_install_report_response(::enterprise_management::AppInstallReportResponse* app_install_report_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_install_report_response_;
  }
  if (app_install_report_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_install_report_response);
    if (message_arena != submessage_arena) {
      app_install_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_install_report_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.app_install_report_response_ = app_install_report_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.app_install_report_response)
}

// optional .enterprise_management.PolicyValidationReportResponse policy_validation_report_response = 26;
inline bool DeviceManagementResponse::_internal_has_policy_validation_report_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.policy_validation_report_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_policy_validation_report_response() const {
  return _internal_has_policy_validation_report_response();
}
inline void DeviceManagementResponse::clear_policy_validation_report_response() {
  if (_impl_.policy_validation_report_response_ != nullptr) _impl_.policy_validation_report_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::enterprise_management::PolicyValidationReportResponse& DeviceManagementResponse::_internal_policy_validation_report_response() const {
  const ::enterprise_management::PolicyValidationReportResponse* p = _impl_.policy_validation_report_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PolicyValidationReportResponse&>(
      ::enterprise_management::_PolicyValidationReportResponse_default_instance_);
}
inline const ::enterprise_management::PolicyValidationReportResponse& DeviceManagementResponse::policy_validation_report_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
  return _internal_policy_validation_report_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_policy_validation_report_response(
    ::enterprise_management::PolicyValidationReportResponse* policy_validation_report_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.policy_validation_report_response_);
  }
  _impl_.policy_validation_report_response_ = policy_validation_report_response;
  if (policy_validation_report_response) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
}
inline ::enterprise_management::PolicyValidationReportResponse* DeviceManagementResponse::release_policy_validation_report_response() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::enterprise_management::PolicyValidationReportResponse* temp = _impl_.policy_validation_report_response_;
  _impl_.policy_validation_report_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PolicyValidationReportResponse* DeviceManagementResponse::unsafe_arena_release_policy_validation_report_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::enterprise_management::PolicyValidationReportResponse* temp = _impl_.policy_validation_report_response_;
  _impl_.policy_validation_report_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::PolicyValidationReportResponse* DeviceManagementResponse::_internal_mutable_policy_validation_report_response() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.policy_validation_report_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PolicyValidationReportResponse>(GetArenaForAllocation());
    _impl_.policy_validation_report_response_ = p;
  }
  return _impl_.policy_validation_report_response_;
}
inline ::enterprise_management::PolicyValidationReportResponse* DeviceManagementResponse::mutable_policy_validation_report_response() {
  ::enterprise_management::PolicyValidationReportResponse* _msg = _internal_mutable_policy_validation_report_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_policy_validation_report_response(::enterprise_management::PolicyValidationReportResponse* policy_validation_report_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.policy_validation_report_response_;
  }
  if (policy_validation_report_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(policy_validation_report_response);
    if (message_arena != submessage_arena) {
      policy_validation_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policy_validation_report_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.policy_validation_report_response_ = policy_validation_report_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.policy_validation_report_response)
}

// optional .enterprise_management.DeviceInitialEnrollmentStateResponse device_initial_enrollment_state_response = 27;
inline bool DeviceManagementResponse::_internal_has_device_initial_enrollment_state_response() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_initial_enrollment_state_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_device_initial_enrollment_state_response() const {
  return _internal_has_device_initial_enrollment_state_response();
}
inline void DeviceManagementResponse::clear_device_initial_enrollment_state_response() {
  if (_impl_.device_initial_enrollment_state_response_ != nullptr) _impl_.device_initial_enrollment_state_response_->Clear();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const ::enterprise_management::DeviceInitialEnrollmentStateResponse& DeviceManagementResponse::_internal_device_initial_enrollment_state_response() const {
  const ::enterprise_management::DeviceInitialEnrollmentStateResponse* p = _impl_.device_initial_enrollment_state_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::DeviceInitialEnrollmentStateResponse&>(
      ::enterprise_management::_DeviceInitialEnrollmentStateResponse_default_instance_);
}
inline const ::enterprise_management::DeviceInitialEnrollmentStateResponse& DeviceManagementResponse::device_initial_enrollment_state_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
  return _internal_device_initial_enrollment_state_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_device_initial_enrollment_state_response(
    ::enterprise_management::DeviceInitialEnrollmentStateResponse* device_initial_enrollment_state_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_initial_enrollment_state_response_);
  }
  _impl_.device_initial_enrollment_state_response_ = device_initial_enrollment_state_response;
  if (device_initial_enrollment_state_response) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceManagementResponse::release_device_initial_enrollment_state_response() {
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* temp = _impl_.device_initial_enrollment_state_response_;
  _impl_.device_initial_enrollment_state_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceManagementResponse::unsafe_arena_release_device_initial_enrollment_state_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* temp = _impl_.device_initial_enrollment_state_response_;
  _impl_.device_initial_enrollment_state_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceManagementResponse::_internal_mutable_device_initial_enrollment_state_response() {
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.device_initial_enrollment_state_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::DeviceInitialEnrollmentStateResponse>(GetArenaForAllocation());
    _impl_.device_initial_enrollment_state_response_ = p;
  }
  return _impl_.device_initial_enrollment_state_response_;
}
inline ::enterprise_management::DeviceInitialEnrollmentStateResponse* DeviceManagementResponse::mutable_device_initial_enrollment_state_response() {
  ::enterprise_management::DeviceInitialEnrollmentStateResponse* _msg = _internal_mutable_device_initial_enrollment_state_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_device_initial_enrollment_state_response(::enterprise_management::DeviceInitialEnrollmentStateResponse* device_initial_enrollment_state_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_initial_enrollment_state_response_;
  }
  if (device_initial_enrollment_state_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_initial_enrollment_state_response);
    if (message_arena != submessage_arena) {
      device_initial_enrollment_state_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_initial_enrollment_state_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.device_initial_enrollment_state_response_ = device_initial_enrollment_state_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.device_initial_enrollment_state_response)
}

// optional .enterprise_management.RefreshAccountResponse refresh_account_response = 28;
inline bool DeviceManagementResponse::_internal_has_refresh_account_response() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.refresh_account_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_refresh_account_response() const {
  return _internal_has_refresh_account_response();
}
inline void DeviceManagementResponse::clear_refresh_account_response() {
  if (_impl_.refresh_account_response_ != nullptr) _impl_.refresh_account_response_->Clear();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const ::enterprise_management::RefreshAccountResponse& DeviceManagementResponse::_internal_refresh_account_response() const {
  const ::enterprise_management::RefreshAccountResponse* p = _impl_.refresh_account_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::RefreshAccountResponse&>(
      ::enterprise_management::_RefreshAccountResponse_default_instance_);
}
inline const ::enterprise_management::RefreshAccountResponse& DeviceManagementResponse::refresh_account_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.refresh_account_response)
  return _internal_refresh_account_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_refresh_account_response(
    ::enterprise_management::RefreshAccountResponse* refresh_account_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.refresh_account_response_);
  }
  _impl_.refresh_account_response_ = refresh_account_response;
  if (refresh_account_response) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.refresh_account_response)
}
inline ::enterprise_management::RefreshAccountResponse* DeviceManagementResponse::release_refresh_account_response() {
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::enterprise_management::RefreshAccountResponse* temp = _impl_.refresh_account_response_;
  _impl_.refresh_account_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::RefreshAccountResponse* DeviceManagementResponse::unsafe_arena_release_refresh_account_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.refresh_account_response)
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::enterprise_management::RefreshAccountResponse* temp = _impl_.refresh_account_response_;
  _impl_.refresh_account_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::RefreshAccountResponse* DeviceManagementResponse::_internal_mutable_refresh_account_response() {
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.refresh_account_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::RefreshAccountResponse>(GetArenaForAllocation());
    _impl_.refresh_account_response_ = p;
  }
  return _impl_.refresh_account_response_;
}
inline ::enterprise_management::RefreshAccountResponse* DeviceManagementResponse::mutable_refresh_account_response() {
  ::enterprise_management::RefreshAccountResponse* _msg = _internal_mutable_refresh_account_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.refresh_account_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_refresh_account_response(::enterprise_management::RefreshAccountResponse* refresh_account_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.refresh_account_response_;
  }
  if (refresh_account_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(refresh_account_response);
    if (message_arena != submessage_arena) {
      refresh_account_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refresh_account_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.refresh_account_response_ = refresh_account_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.refresh_account_response)
}

// optional .enterprise_management.RsuLookupKeyUploadResponse rsu_lookup_key_upload_response = 30;
inline bool DeviceManagementResponse::_internal_has_rsu_lookup_key_upload_response() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rsu_lookup_key_upload_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_rsu_lookup_key_upload_response() const {
  return _internal_has_rsu_lookup_key_upload_response();
}
inline void DeviceManagementResponse::clear_rsu_lookup_key_upload_response() {
  if (_impl_.rsu_lookup_key_upload_response_ != nullptr) _impl_.rsu_lookup_key_upload_response_->Clear();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const ::enterprise_management::RsuLookupKeyUploadResponse& DeviceManagementResponse::_internal_rsu_lookup_key_upload_response() const {
  const ::enterprise_management::RsuLookupKeyUploadResponse* p = _impl_.rsu_lookup_key_upload_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::RsuLookupKeyUploadResponse&>(
      ::enterprise_management::_RsuLookupKeyUploadResponse_default_instance_);
}
inline const ::enterprise_management::RsuLookupKeyUploadResponse& DeviceManagementResponse::rsu_lookup_key_upload_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
  return _internal_rsu_lookup_key_upload_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_rsu_lookup_key_upload_response(
    ::enterprise_management::RsuLookupKeyUploadResponse* rsu_lookup_key_upload_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsu_lookup_key_upload_response_);
  }
  _impl_.rsu_lookup_key_upload_response_ = rsu_lookup_key_upload_response;
  if (rsu_lookup_key_upload_response) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
}
inline ::enterprise_management::RsuLookupKeyUploadResponse* DeviceManagementResponse::release_rsu_lookup_key_upload_response() {
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::enterprise_management::RsuLookupKeyUploadResponse* temp = _impl_.rsu_lookup_key_upload_response_;
  _impl_.rsu_lookup_key_upload_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::RsuLookupKeyUploadResponse* DeviceManagementResponse::unsafe_arena_release_rsu_lookup_key_upload_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::enterprise_management::RsuLookupKeyUploadResponse* temp = _impl_.rsu_lookup_key_upload_response_;
  _impl_.rsu_lookup_key_upload_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::RsuLookupKeyUploadResponse* DeviceManagementResponse::_internal_mutable_rsu_lookup_key_upload_response() {
  _impl_._has_bits_[0] |= 0x08000000u;
  if (_impl_.rsu_lookup_key_upload_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::RsuLookupKeyUploadResponse>(GetArenaForAllocation());
    _impl_.rsu_lookup_key_upload_response_ = p;
  }
  return _impl_.rsu_lookup_key_upload_response_;
}
inline ::enterprise_management::RsuLookupKeyUploadResponse* DeviceManagementResponse::mutable_rsu_lookup_key_upload_response() {
  ::enterprise_management::RsuLookupKeyUploadResponse* _msg = _internal_mutable_rsu_lookup_key_upload_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_rsu_lookup_key_upload_response(::enterprise_management::RsuLookupKeyUploadResponse* rsu_lookup_key_upload_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsu_lookup_key_upload_response_;
  }
  if (rsu_lookup_key_upload_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsu_lookup_key_upload_response);
    if (message_arena != submessage_arena) {
      rsu_lookup_key_upload_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsu_lookup_key_upload_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.rsu_lookup_key_upload_response_ = rsu_lookup_key_upload_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.rsu_lookup_key_upload_response)
}

// optional .enterprise_management.PublicSamlUserResponse public_saml_user_response = 31;
inline bool DeviceManagementResponse::_internal_has_public_saml_user_response() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public_saml_user_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_public_saml_user_response() const {
  return _internal_has_public_saml_user_response();
}
inline void DeviceManagementResponse::clear_public_saml_user_response() {
  if (_impl_.public_saml_user_response_ != nullptr) _impl_.public_saml_user_response_->Clear();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const ::enterprise_management::PublicSamlUserResponse& DeviceManagementResponse::_internal_public_saml_user_response() const {
  const ::enterprise_management::PublicSamlUserResponse* p = _impl_.public_saml_user_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PublicSamlUserResponse&>(
      ::enterprise_management::_PublicSamlUserResponse_default_instance_);
}
inline const ::enterprise_management::PublicSamlUserResponse& DeviceManagementResponse::public_saml_user_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.public_saml_user_response)
  return _internal_public_saml_user_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_public_saml_user_response(
    ::enterprise_management::PublicSamlUserResponse* public_saml_user_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_saml_user_response_);
  }
  _impl_.public_saml_user_response_ = public_saml_user_response;
  if (public_saml_user_response) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.public_saml_user_response)
}
inline ::enterprise_management::PublicSamlUserResponse* DeviceManagementResponse::release_public_saml_user_response() {
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::enterprise_management::PublicSamlUserResponse* temp = _impl_.public_saml_user_response_;
  _impl_.public_saml_user_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PublicSamlUserResponse* DeviceManagementResponse::unsafe_arena_release_public_saml_user_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.public_saml_user_response)
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::enterprise_management::PublicSamlUserResponse* temp = _impl_.public_saml_user_response_;
  _impl_.public_saml_user_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::PublicSamlUserResponse* DeviceManagementResponse::_internal_mutable_public_saml_user_response() {
  _impl_._has_bits_[0] |= 0x10000000u;
  if (_impl_.public_saml_user_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PublicSamlUserResponse>(GetArenaForAllocation());
    _impl_.public_saml_user_response_ = p;
  }
  return _impl_.public_saml_user_response_;
}
inline ::enterprise_management::PublicSamlUserResponse* DeviceManagementResponse::mutable_public_saml_user_response() {
  ::enterprise_management::PublicSamlUserResponse* _msg = _internal_mutable_public_saml_user_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.public_saml_user_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_public_saml_user_response(::enterprise_management::PublicSamlUserResponse* public_saml_user_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.public_saml_user_response_;
  }
  if (public_saml_user_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_saml_user_response);
    if (message_arena != submessage_arena) {
      public_saml_user_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_saml_user_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.public_saml_user_response_ = public_saml_user_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.public_saml_user_response)
}

// optional .enterprise_management.ChromeOsUserReportResponse chrome_os_user_report_response = 32;
inline bool DeviceManagementResponse::_internal_has_chrome_os_user_report_response() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chrome_os_user_report_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_chrome_os_user_report_response() const {
  return _internal_has_chrome_os_user_report_response();
}
inline void DeviceManagementResponse::clear_chrome_os_user_report_response() {
  if (_impl_.chrome_os_user_report_response_ != nullptr) _impl_.chrome_os_user_report_response_->Clear();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const ::enterprise_management::ChromeOsUserReportResponse& DeviceManagementResponse::_internal_chrome_os_user_report_response() const {
  const ::enterprise_management::ChromeOsUserReportResponse* p = _impl_.chrome_os_user_report_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChromeOsUserReportResponse&>(
      ::enterprise_management::_ChromeOsUserReportResponse_default_instance_);
}
inline const ::enterprise_management::ChromeOsUserReportResponse& DeviceManagementResponse::chrome_os_user_report_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
  return _internal_chrome_os_user_report_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_chrome_os_user_report_response(
    ::enterprise_management::ChromeOsUserReportResponse* chrome_os_user_report_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_os_user_report_response_);
  }
  _impl_.chrome_os_user_report_response_ = chrome_os_user_report_response;
  if (chrome_os_user_report_response) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
}
inline ::enterprise_management::ChromeOsUserReportResponse* DeviceManagementResponse::release_chrome_os_user_report_response() {
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::enterprise_management::ChromeOsUserReportResponse* temp = _impl_.chrome_os_user_report_response_;
  _impl_.chrome_os_user_report_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChromeOsUserReportResponse* DeviceManagementResponse::unsafe_arena_release_chrome_os_user_report_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::enterprise_management::ChromeOsUserReportResponse* temp = _impl_.chrome_os_user_report_response_;
  _impl_.chrome_os_user_report_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChromeOsUserReportResponse* DeviceManagementResponse::_internal_mutable_chrome_os_user_report_response() {
  _impl_._has_bits_[0] |= 0x20000000u;
  if (_impl_.chrome_os_user_report_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChromeOsUserReportResponse>(GetArenaForAllocation());
    _impl_.chrome_os_user_report_response_ = p;
  }
  return _impl_.chrome_os_user_report_response_;
}
inline ::enterprise_management::ChromeOsUserReportResponse* DeviceManagementResponse::mutable_chrome_os_user_report_response() {
  ::enterprise_management::ChromeOsUserReportResponse* _msg = _internal_mutable_chrome_os_user_report_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_chrome_os_user_report_response(::enterprise_management::ChromeOsUserReportResponse* chrome_os_user_report_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chrome_os_user_report_response_;
  }
  if (chrome_os_user_report_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_os_user_report_response);
    if (message_arena != submessage_arena) {
      chrome_os_user_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_os_user_report_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.chrome_os_user_report_response_ = chrome_os_user_report_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.chrome_os_user_report_response)
}

// optional .enterprise_management.ClientCertificateProvisioningResponse client_certificate_provisioning_response = 33;
inline bool DeviceManagementResponse::_internal_has_client_certificate_provisioning_response() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_certificate_provisioning_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_client_certificate_provisioning_response() const {
  return _internal_has_client_certificate_provisioning_response();
}
inline void DeviceManagementResponse::clear_client_certificate_provisioning_response() {
  if (_impl_.client_certificate_provisioning_response_ != nullptr) _impl_.client_certificate_provisioning_response_->Clear();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const ::enterprise_management::ClientCertificateProvisioningResponse& DeviceManagementResponse::_internal_client_certificate_provisioning_response() const {
  const ::enterprise_management::ClientCertificateProvisioningResponse* p = _impl_.client_certificate_provisioning_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ClientCertificateProvisioningResponse&>(
      ::enterprise_management::_ClientCertificateProvisioningResponse_default_instance_);
}
inline const ::enterprise_management::ClientCertificateProvisioningResponse& DeviceManagementResponse::client_certificate_provisioning_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
  return _internal_client_certificate_provisioning_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_client_certificate_provisioning_response(
    ::enterprise_management::ClientCertificateProvisioningResponse* client_certificate_provisioning_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_certificate_provisioning_response_);
  }
  _impl_.client_certificate_provisioning_response_ = client_certificate_provisioning_response;
  if (client_certificate_provisioning_response) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
}
inline ::enterprise_management::ClientCertificateProvisioningResponse* DeviceManagementResponse::release_client_certificate_provisioning_response() {
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::enterprise_management::ClientCertificateProvisioningResponse* temp = _impl_.client_certificate_provisioning_response_;
  _impl_.client_certificate_provisioning_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ClientCertificateProvisioningResponse* DeviceManagementResponse::unsafe_arena_release_client_certificate_provisioning_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::enterprise_management::ClientCertificateProvisioningResponse* temp = _impl_.client_certificate_provisioning_response_;
  _impl_.client_certificate_provisioning_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::ClientCertificateProvisioningResponse* DeviceManagementResponse::_internal_mutable_client_certificate_provisioning_response() {
  _impl_._has_bits_[0] |= 0x40000000u;
  if (_impl_.client_certificate_provisioning_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ClientCertificateProvisioningResponse>(GetArenaForAllocation());
    _impl_.client_certificate_provisioning_response_ = p;
  }
  return _impl_.client_certificate_provisioning_response_;
}
inline ::enterprise_management::ClientCertificateProvisioningResponse* DeviceManagementResponse::mutable_client_certificate_provisioning_response() {
  ::enterprise_management::ClientCertificateProvisioningResponse* _msg = _internal_mutable_client_certificate_provisioning_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_client_certificate_provisioning_response(::enterprise_management::ClientCertificateProvisioningResponse* client_certificate_provisioning_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_certificate_provisioning_response_;
  }
  if (client_certificate_provisioning_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_certificate_provisioning_response);
    if (message_arena != submessage_arena) {
      client_certificate_provisioning_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_certificate_provisioning_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.client_certificate_provisioning_response_ = client_certificate_provisioning_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.client_certificate_provisioning_response)
}

// optional .enterprise_management.CheckUserAccountResponse check_user_account_response = 34;
inline bool DeviceManagementResponse::_internal_has_check_user_account_response() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_user_account_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_check_user_account_response() const {
  return _internal_has_check_user_account_response();
}
inline void DeviceManagementResponse::clear_check_user_account_response() {
  if (_impl_.check_user_account_response_ != nullptr) _impl_.check_user_account_response_->Clear();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const ::enterprise_management::CheckUserAccountResponse& DeviceManagementResponse::_internal_check_user_account_response() const {
  const ::enterprise_management::CheckUserAccountResponse* p = _impl_.check_user_account_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::CheckUserAccountResponse&>(
      ::enterprise_management::_CheckUserAccountResponse_default_instance_);
}
inline const ::enterprise_management::CheckUserAccountResponse& DeviceManagementResponse::check_user_account_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.check_user_account_response)
  return _internal_check_user_account_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_check_user_account_response(
    ::enterprise_management::CheckUserAccountResponse* check_user_account_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_user_account_response_);
  }
  _impl_.check_user_account_response_ = check_user_account_response;
  if (check_user_account_response) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.check_user_account_response)
}
inline ::enterprise_management::CheckUserAccountResponse* DeviceManagementResponse::release_check_user_account_response() {
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::enterprise_management::CheckUserAccountResponse* temp = _impl_.check_user_account_response_;
  _impl_.check_user_account_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::CheckUserAccountResponse* DeviceManagementResponse::unsafe_arena_release_check_user_account_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.check_user_account_response)
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::enterprise_management::CheckUserAccountResponse* temp = _impl_.check_user_account_response_;
  _impl_.check_user_account_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::CheckUserAccountResponse* DeviceManagementResponse::_internal_mutable_check_user_account_response() {
  _impl_._has_bits_[0] |= 0x80000000u;
  if (_impl_.check_user_account_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::CheckUserAccountResponse>(GetArenaForAllocation());
    _impl_.check_user_account_response_ = p;
  }
  return _impl_.check_user_account_response_;
}
inline ::enterprise_management::CheckUserAccountResponse* DeviceManagementResponse::mutable_check_user_account_response() {
  ::enterprise_management::CheckUserAccountResponse* _msg = _internal_mutable_check_user_account_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.check_user_account_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_check_user_account_response(::enterprise_management::CheckUserAccountResponse* check_user_account_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_user_account_response_;
  }
  if (check_user_account_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_user_account_response);
    if (message_arena != submessage_arena) {
      check_user_account_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_user_account_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.check_user_account_response_ = check_user_account_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.check_user_account_response)
}

// optional .enterprise_management.PrivateSetMembershipResponse private_set_membership_response = 35;
inline bool DeviceManagementResponse::_internal_has_private_set_membership_response() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.private_set_membership_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_private_set_membership_response() const {
  return _internal_has_private_set_membership_response();
}
inline void DeviceManagementResponse::clear_private_set_membership_response() {
  if (_impl_.private_set_membership_response_ != nullptr) _impl_.private_set_membership_response_->Clear();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const ::enterprise_management::PrivateSetMembershipResponse& DeviceManagementResponse::_internal_private_set_membership_response() const {
  const ::enterprise_management::PrivateSetMembershipResponse* p = _impl_.private_set_membership_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::PrivateSetMembershipResponse&>(
      ::enterprise_management::_PrivateSetMembershipResponse_default_instance_);
}
inline const ::enterprise_management::PrivateSetMembershipResponse& DeviceManagementResponse::private_set_membership_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.private_set_membership_response)
  return _internal_private_set_membership_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_private_set_membership_response(
    ::enterprise_management::PrivateSetMembershipResponse* private_set_membership_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.private_set_membership_response_);
  }
  _impl_.private_set_membership_response_ = private_set_membership_response;
  if (private_set_membership_response) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.private_set_membership_response)
}
inline ::enterprise_management::PrivateSetMembershipResponse* DeviceManagementResponse::release_private_set_membership_response() {
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::enterprise_management::PrivateSetMembershipResponse* temp = _impl_.private_set_membership_response_;
  _impl_.private_set_membership_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::PrivateSetMembershipResponse* DeviceManagementResponse::unsafe_arena_release_private_set_membership_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.private_set_membership_response)
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::enterprise_management::PrivateSetMembershipResponse* temp = _impl_.private_set_membership_response_;
  _impl_.private_set_membership_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::PrivateSetMembershipResponse* DeviceManagementResponse::_internal_mutable_private_set_membership_response() {
  _impl_._has_bits_[1] |= 0x00000001u;
  if (_impl_.private_set_membership_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::PrivateSetMembershipResponse>(GetArenaForAllocation());
    _impl_.private_set_membership_response_ = p;
  }
  return _impl_.private_set_membership_response_;
}
inline ::enterprise_management::PrivateSetMembershipResponse* DeviceManagementResponse::mutable_private_set_membership_response() {
  ::enterprise_management::PrivateSetMembershipResponse* _msg = _internal_mutable_private_set_membership_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.private_set_membership_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_private_set_membership_response(::enterprise_management::PrivateSetMembershipResponse* private_set_membership_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.private_set_membership_response_;
  }
  if (private_set_membership_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(private_set_membership_response);
    if (message_arena != submessage_arena) {
      private_set_membership_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, private_set_membership_response, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.private_set_membership_response_ = private_set_membership_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.private_set_membership_response)
}

// optional .enterprise_management.BrowserPublicKeyUploadResponse browser_public_key_upload_response = 36;
inline bool DeviceManagementResponse::_internal_has_browser_public_key_upload_response() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_public_key_upload_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_browser_public_key_upload_response() const {
  return _internal_has_browser_public_key_upload_response();
}
inline void DeviceManagementResponse::clear_browser_public_key_upload_response() {
  if (_impl_.browser_public_key_upload_response_ != nullptr) _impl_.browser_public_key_upload_response_->Clear();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const ::enterprise_management::BrowserPublicKeyUploadResponse& DeviceManagementResponse::_internal_browser_public_key_upload_response() const {
  const ::enterprise_management::BrowserPublicKeyUploadResponse* p = _impl_.browser_public_key_upload_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::BrowserPublicKeyUploadResponse&>(
      ::enterprise_management::_BrowserPublicKeyUploadResponse_default_instance_);
}
inline const ::enterprise_management::BrowserPublicKeyUploadResponse& DeviceManagementResponse::browser_public_key_upload_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.browser_public_key_upload_response)
  return _internal_browser_public_key_upload_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_browser_public_key_upload_response(
    ::enterprise_management::BrowserPublicKeyUploadResponse* browser_public_key_upload_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_public_key_upload_response_);
  }
  _impl_.browser_public_key_upload_response_ = browser_public_key_upload_response;
  if (browser_public_key_upload_response) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.browser_public_key_upload_response)
}
inline ::enterprise_management::BrowserPublicKeyUploadResponse* DeviceManagementResponse::release_browser_public_key_upload_response() {
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::enterprise_management::BrowserPublicKeyUploadResponse* temp = _impl_.browser_public_key_upload_response_;
  _impl_.browser_public_key_upload_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::BrowserPublicKeyUploadResponse* DeviceManagementResponse::unsafe_arena_release_browser_public_key_upload_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.browser_public_key_upload_response)
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::enterprise_management::BrowserPublicKeyUploadResponse* temp = _impl_.browser_public_key_upload_response_;
  _impl_.browser_public_key_upload_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::BrowserPublicKeyUploadResponse* DeviceManagementResponse::_internal_mutable_browser_public_key_upload_response() {
  _impl_._has_bits_[1] |= 0x00000002u;
  if (_impl_.browser_public_key_upload_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::BrowserPublicKeyUploadResponse>(GetArenaForAllocation());
    _impl_.browser_public_key_upload_response_ = p;
  }
  return _impl_.browser_public_key_upload_response_;
}
inline ::enterprise_management::BrowserPublicKeyUploadResponse* DeviceManagementResponse::mutable_browser_public_key_upload_response() {
  ::enterprise_management::BrowserPublicKeyUploadResponse* _msg = _internal_mutable_browser_public_key_upload_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.browser_public_key_upload_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_browser_public_key_upload_response(::enterprise_management::BrowserPublicKeyUploadResponse* browser_public_key_upload_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_public_key_upload_response_;
  }
  if (browser_public_key_upload_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser_public_key_upload_response);
    if (message_arena != submessage_arena) {
      browser_public_key_upload_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser_public_key_upload_response, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.browser_public_key_upload_response_ = browser_public_key_upload_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.browser_public_key_upload_response)
}

// optional .enterprise_management.UploadEuiccInfoResponse upload_euicc_info_response = 37;
inline bool DeviceManagementResponse::_internal_has_upload_euicc_info_response() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.upload_euicc_info_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_upload_euicc_info_response() const {
  return _internal_has_upload_euicc_info_response();
}
inline void DeviceManagementResponse::clear_upload_euicc_info_response() {
  if (_impl_.upload_euicc_info_response_ != nullptr) _impl_.upload_euicc_info_response_->Clear();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const ::enterprise_management::UploadEuiccInfoResponse& DeviceManagementResponse::_internal_upload_euicc_info_response() const {
  const ::enterprise_management::UploadEuiccInfoResponse* p = _impl_.upload_euicc_info_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::UploadEuiccInfoResponse&>(
      ::enterprise_management::_UploadEuiccInfoResponse_default_instance_);
}
inline const ::enterprise_management::UploadEuiccInfoResponse& DeviceManagementResponse::upload_euicc_info_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.upload_euicc_info_response)
  return _internal_upload_euicc_info_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_upload_euicc_info_response(
    ::enterprise_management::UploadEuiccInfoResponse* upload_euicc_info_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upload_euicc_info_response_);
  }
  _impl_.upload_euicc_info_response_ = upload_euicc_info_response;
  if (upload_euicc_info_response) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.upload_euicc_info_response)
}
inline ::enterprise_management::UploadEuiccInfoResponse* DeviceManagementResponse::release_upload_euicc_info_response() {
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::enterprise_management::UploadEuiccInfoResponse* temp = _impl_.upload_euicc_info_response_;
  _impl_.upload_euicc_info_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::UploadEuiccInfoResponse* DeviceManagementResponse::unsafe_arena_release_upload_euicc_info_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.upload_euicc_info_response)
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::enterprise_management::UploadEuiccInfoResponse* temp = _impl_.upload_euicc_info_response_;
  _impl_.upload_euicc_info_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::UploadEuiccInfoResponse* DeviceManagementResponse::_internal_mutable_upload_euicc_info_response() {
  _impl_._has_bits_[1] |= 0x00000004u;
  if (_impl_.upload_euicc_info_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::UploadEuiccInfoResponse>(GetArenaForAllocation());
    _impl_.upload_euicc_info_response_ = p;
  }
  return _impl_.upload_euicc_info_response_;
}
inline ::enterprise_management::UploadEuiccInfoResponse* DeviceManagementResponse::mutable_upload_euicc_info_response() {
  ::enterprise_management::UploadEuiccInfoResponse* _msg = _internal_mutable_upload_euicc_info_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.upload_euicc_info_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_upload_euicc_info_response(::enterprise_management::UploadEuiccInfoResponse* upload_euicc_info_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upload_euicc_info_response_;
  }
  if (upload_euicc_info_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upload_euicc_info_response);
    if (message_arena != submessage_arena) {
      upload_euicc_info_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upload_euicc_info_response, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.upload_euicc_info_response_ = upload_euicc_info_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.upload_euicc_info_response)
}

// optional .enterprise_management.ChromeProfileReportResponse chrome_profile_report_response = 38;
inline bool DeviceManagementResponse::_internal_has_chrome_profile_report_response() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chrome_profile_report_response_ != nullptr);
  return value;
}
inline bool DeviceManagementResponse::has_chrome_profile_report_response() const {
  return _internal_has_chrome_profile_report_response();
}
inline void DeviceManagementResponse::clear_chrome_profile_report_response() {
  if (_impl_.chrome_profile_report_response_ != nullptr) _impl_.chrome_profile_report_response_->Clear();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const ::enterprise_management::ChromeProfileReportResponse& DeviceManagementResponse::_internal_chrome_profile_report_response() const {
  const ::enterprise_management::ChromeProfileReportResponse* p = _impl_.chrome_profile_report_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_management::ChromeProfileReportResponse&>(
      ::enterprise_management::_ChromeProfileReportResponse_default_instance_);
}
inline const ::enterprise_management::ChromeProfileReportResponse& DeviceManagementResponse::chrome_profile_report_response() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceManagementResponse.chrome_profile_report_response)
  return _internal_chrome_profile_report_response();
}
inline void DeviceManagementResponse::unsafe_arena_set_allocated_chrome_profile_report_response(
    ::enterprise_management::ChromeProfileReportResponse* chrome_profile_report_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_profile_report_response_);
  }
  _impl_.chrome_profile_report_response_ = chrome_profile_report_response;
  if (chrome_profile_report_response) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_management.DeviceManagementResponse.chrome_profile_report_response)
}
inline ::enterprise_management::ChromeProfileReportResponse* DeviceManagementResponse::release_chrome_profile_report_response() {
  _impl_._has_bits_[1] &= ~0x00000008u;
  ::enterprise_management::ChromeProfileReportResponse* temp = _impl_.chrome_profile_report_response_;
  _impl_.chrome_profile_report_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_management::ChromeProfileReportResponse* DeviceManagementResponse::unsafe_arena_release_chrome_profile_report_response() {
  // @@protoc_insertion_point(field_release:enterprise_management.DeviceManagementResponse.chrome_profile_report_response)
  _impl_._has_bits_[1] &= ~0x00000008u;
  ::enterprise_management::ChromeProfileReportResponse* temp = _impl_.chrome_profile_report_response_;
  _impl_.chrome_profile_report_response_ = nullptr;
  return temp;
}
inline ::enterprise_management::ChromeProfileReportResponse* DeviceManagementResponse::_internal_mutable_chrome_profile_report_response() {
  _impl_._has_bits_[1] |= 0x00000008u;
  if (_impl_.chrome_profile_report_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_management::ChromeProfileReportResponse>(GetArenaForAllocation());
    _impl_.chrome_profile_report_response_ = p;
  }
  return _impl_.chrome_profile_report_response_;
}
inline ::enterprise_management::ChromeProfileReportResponse* DeviceManagementResponse::mutable_chrome_profile_report_response() {
  ::enterprise_management::ChromeProfileReportResponse* _msg = _internal_mutable_chrome_profile_report_response();
  // @@protoc_insertion_point(field_mutable:enterprise_management.DeviceManagementResponse.chrome_profile_report_response)
  return _msg;
}
inline void DeviceManagementResponse::set_allocated_chrome_profile_report_response(::enterprise_management::ChromeProfileReportResponse* chrome_profile_report_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chrome_profile_report_response_;
  }
  if (chrome_profile_report_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_profile_report_response);
    if (message_arena != submessage_arena) {
      chrome_profile_report_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_profile_report_response, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  _impl_.chrome_profile_report_response_ = chrome_profile_report_response;
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.DeviceManagementResponse.chrome_profile_report_response)
}

// -------------------------------------------------------------------

// DeviceStateRetrievalInfo

// optional bool has_initial_state = 1;
inline bool DeviceStateRetrievalInfo::_internal_has_has_initial_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceStateRetrievalInfo::has_has_initial_state() const {
  return _internal_has_has_initial_state();
}
inline void DeviceStateRetrievalInfo::clear_has_initial_state() {
  _impl_.has_initial_state_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DeviceStateRetrievalInfo::_internal_has_initial_state() const {
  return _impl_.has_initial_state_;
}
inline bool DeviceStateRetrievalInfo::has_initial_state() const {
  // @@protoc_insertion_point(field_get:enterprise_management.DeviceStateRetrievalInfo.has_initial_state)
  return _internal_has_initial_state();
}
inline void DeviceStateRetrievalInfo::_internal_set_has_initial_state(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.has_initial_state_ = value;
}
inline void DeviceStateRetrievalInfo::set_has_initial_state(bool value) {
  _internal_set_has_initial_state(value);
  // @@protoc_insertion_point(field_set:enterprise_management.DeviceStateRetrievalInfo.has_initial_state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace enterprise_management

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::enterprise_management::LicenseType_LicenseTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterRequest_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterRequest_Flavor> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterRequest_Lifetime> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterRequest_PsmExecutionResult> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CheckUserAccountResponse_UserAccountType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceRegisterResponse_DeviceMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceCertUploadRequest_CertificateType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceServiceApiAccessRequest_DeviceType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyFetchRequest_SignatureType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceState_DeviceMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyData_AssociationState> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyData_ManagementMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyData_MarketSegment> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyData_MetricsLogSegment> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ActiveTimePeriod_SessionType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::NetworkInterface_NetworkDeviceType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::NetworkState_ConnectionState> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceUser_UserType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PowerStatus_PowerSource> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DiskInfo_DevicePurpose> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CpuInfo_Architecture> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CrashReportInfo_CrashReportUploadStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::BootInfo_BootMethod> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::OsUpdateStatus_UpdateStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppInfo_AppType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppInfo_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AndroidAppInfo_AndroidAppStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AndroidAppInfo_InstalledSource> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Extension_ExtensionType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Extension_InstallType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Policy_PolicyLevel> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Policy_PolicyScope> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Policy_PolicySource> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::OSReport_VersionType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PolicyValidationReportRequest_ValidationResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceStateRetrievalResponse_RestoreMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DevicePairingResponse_StatusCode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CheckDevicePairingResponse_StatusCode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::RemoteCommand_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::RemoteCommandResult_ResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceAttributeUpdateResponse_ResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::TpmVersionInfo_GscVersion> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_FailureReason> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_UserType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppInstallReportLogEvent_EventType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::RefreshAccountRequest_AccountType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PrintJobEvent_PrintSettings_ColorMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PrintJobEvent_UserType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::App_AppType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::AppActivity_AppState> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::ClientCertificateProvisioningResponse_Error> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::BrowserPublicKeyUploadRequest_KeyType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::UserSessionType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CrdSessionType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CrdSessionAvailability> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::Channel> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::BusDeviceClass> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::BusType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::PartialReportType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::CrostiniAppType> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::HashingAlgorithm> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::SigningAlgorithm> : ::std::true_type {};
template <> struct is_proto_enum< ::enterprise_management::DeviceManagementErrorDetail> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_device_5fmanagement_5fbackend_2eproto
