// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chrome_device_policy.proto

#include "chrome_device_policy.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace enterprise_management {
PROTOBUF_CONSTEXPR DevicePolicyRefreshRateProto::DevicePolicyRefreshRateProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_policy_refresh_rate_)*/int64_t{0}} {}
struct DevicePolicyRefreshRateProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePolicyRefreshRateProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePolicyRefreshRateProtoDefaultTypeInternal() {}
  union {
    DevicePolicyRefreshRateProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePolicyRefreshRateProtoDefaultTypeInternal _DevicePolicyRefreshRateProto_default_instance_;
PROTOBUF_CONSTEXPR UserWhitelistProto::UserWhitelistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_whitelist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserWhitelistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserWhitelistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserWhitelistProtoDefaultTypeInternal() {}
  union {
    UserWhitelistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserWhitelistProtoDefaultTypeInternal _UserWhitelistProto_default_instance_;
PROTOBUF_CONSTEXPR UserAllowlistProto::UserAllowlistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_allowlist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserAllowlistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserAllowlistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserAllowlistProtoDefaultTypeInternal() {}
  union {
    UserAllowlistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserAllowlistProtoDefaultTypeInternal _UserAllowlistProto_default_instance_;
PROTOBUF_CONSTEXPR AllowNewUsersProto::AllowNewUsersProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allow_new_users_)*/true} {}
struct AllowNewUsersProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllowNewUsersProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllowNewUsersProtoDefaultTypeInternal() {}
  union {
    AllowNewUsersProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllowNewUsersProtoDefaultTypeInternal _AllowNewUsersProto_default_instance_;
PROTOBUF_CONSTEXPR GuestModeEnabledProto::GuestModeEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.guest_mode_enabled_)*/true} {}
struct GuestModeEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuestModeEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuestModeEnabledProtoDefaultTypeInternal() {}
  union {
    GuestModeEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuestModeEnabledProtoDefaultTypeInternal _GuestModeEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR ShowUserNamesOnSigninProto::ShowUserNamesOnSigninProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.show_user_names_)*/true} {}
struct ShowUserNamesOnSigninProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowUserNamesOnSigninProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowUserNamesOnSigninProtoDefaultTypeInternal() {}
  union {
    ShowUserNamesOnSigninProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowUserNamesOnSigninProtoDefaultTypeInternal _ShowUserNamesOnSigninProto_default_instance_;
PROTOBUF_CONSTEXPR DataRoamingEnabledProto::DataRoamingEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_roaming_enabled_)*/false} {}
struct DataRoamingEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataRoamingEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataRoamingEnabledProtoDefaultTypeInternal() {}
  union {
    DataRoamingEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataRoamingEnabledProtoDefaultTypeInternal _DataRoamingEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_DeviceProxySettingsProto::OBSOLETE_DeviceProxySettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_proxy_mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obsolete_proxy_server_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obsolete_proxy_pac_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obsolete_proxy_bypass_list_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct OBSOLETE_DeviceProxySettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_DeviceProxySettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_DeviceProxySettingsProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_DeviceProxySettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_DeviceProxySettingsProtoDefaultTypeInternal _OBSOLETE_DeviceProxySettingsProto_default_instance_;
PROTOBUF_CONSTEXPR CameraEnabledProto::CameraEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.camera_enabled_)*/false} {}
struct CameraEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraEnabledProtoDefaultTypeInternal() {}
  union {
    CameraEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraEnabledProtoDefaultTypeInternal _CameraEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR MetricsEnabledProto::MetricsEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metrics_enabled_)*/false} {}
struct MetricsEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MetricsEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MetricsEnabledProtoDefaultTypeInternal() {}
  union {
    MetricsEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MetricsEnabledProtoDefaultTypeInternal _MetricsEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR ReleaseChannelProto::ReleaseChannelProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.release_channel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.release_lts_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.release_channel_delegated_)*/false} {}
struct ReleaseChannelProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReleaseChannelProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReleaseChannelProtoDefaultTypeInternal() {}
  union {
    ReleaseChannelProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReleaseChannelProtoDefaultTypeInternal _ReleaseChannelProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceOpenNetworkConfigurationProto::DeviceOpenNetworkConfigurationProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.open_network_configuration_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceOpenNetworkConfigurationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceOpenNetworkConfigurationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceOpenNetworkConfigurationProtoDefaultTypeInternal() {}
  union {
    DeviceOpenNetworkConfigurationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceOpenNetworkConfigurationProtoDefaultTypeInternal _DeviceOpenNetworkConfigurationProto_default_instance_;
PROTOBUF_CONSTEXPR NetworkHostnameProto::NetworkHostnameProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_hostname_template_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NetworkHostnameProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkHostnameProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkHostnameProtoDefaultTypeInternal() {}
  union {
    NetworkHostnameProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkHostnameProtoDefaultTypeInternal _NetworkHostnameProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceHindiInscriptLayoutEnabledProto::DeviceHindiInscriptLayoutEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceHindiInscriptLayoutEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceHindiInscriptLayoutEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceHindiInscriptLayoutEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceHindiInscriptLayoutEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceHindiInscriptLayoutEnabledProtoDefaultTypeInternal _DeviceHindiInscriptLayoutEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR HostnameUserConfigurableProto::HostnameUserConfigurableProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_hostname_user_configurable_)*/false} {}
struct HostnameUserConfigurableProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostnameUserConfigurableProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostnameUserConfigurableProtoDefaultTypeInternal() {}
  union {
    HostnameUserConfigurableProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostnameUserConfigurableProtoDefaultTypeInternal _HostnameUserConfigurableProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceReportingProto::DeviceReportingProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.report_signal_strength_event_driven_telemetry_)*/nullptr
  , /*decltype(_impl_.report_location_)*/false
  , /*decltype(_impl_.report_os_update_status_)*/false
  , /*decltype(_impl_.report_running_kiosk_app_)*/false
  , /*decltype(_impl_.report_power_status_)*/false
  , /*decltype(_impl_.report_storage_status_)*/false
  , /*decltype(_impl_.report_board_status_)*/false
  , /*decltype(_impl_.report_cpu_info_)*/false
  , /*decltype(_impl_.report_graphics_status_)*/false
  , /*decltype(_impl_.report_crash_report_info_)*/false
  , /*decltype(_impl_.report_timezone_info_)*/false
  , /*decltype(_impl_.report_memory_info_)*/false
  , /*decltype(_impl_.report_backlight_info_)*/false
  , /*decltype(_impl_.report_app_info_)*/false
  , /*decltype(_impl_.report_bluetooth_info_)*/false
  , /*decltype(_impl_.report_fan_info_)*/false
  , /*decltype(_impl_.report_vpd_info_)*/false
  , /*decltype(_impl_.report_system_info_)*/false
  , /*decltype(_impl_.report_print_jobs_)*/false
  , /*decltype(_impl_.report_login_logout_)*/false
  , /*decltype(_impl_.report_security_status_)*/false
  , /*decltype(_impl_.report_crd_sessions_)*/false
  , /*decltype(_impl_.report_peripherals_)*/false
  , /*decltype(_impl_.device_activity_heartbeat_enabled_)*/false
  , /*decltype(_impl_.report_network_configuration_)*/true
  , /*decltype(_impl_.report_network_status_)*/true
  , /*decltype(_impl_.enable_granular_reporting_)*/true
  , /*decltype(_impl_.report_version_info_)*/true
  , /*decltype(_impl_.report_activity_times_)*/true
  , /*decltype(_impl_.report_boot_mode_)*/true
  , /*decltype(_impl_.report_network_interfaces_)*/true
  , /*decltype(_impl_.report_users_)*/true
  , /*decltype(_impl_.report_hardware_status_)*/true
  , /*decltype(_impl_.report_session_status_)*/true
  , /*decltype(_impl_.report_audio_status_)*/true
  , /*decltype(_impl_.device_status_frequency_)*/int64_t{10800000}
  , /*decltype(_impl_.report_network_telemetry_collection_rate_ms_)*/int64_t{3600000}
  , /*decltype(_impl_.report_network_telemetry_event_checking_rate_ms_)*/int64_t{600000}
  , /*decltype(_impl_.report_device_audio_status_checking_rate_ms_)*/int64_t{600000}
  , /*decltype(_impl_.device_activity_heartbeat_collection_rate_ms_)*/int64_t{900000}} {}
struct DeviceReportingProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceReportingProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceReportingProtoDefaultTypeInternal() {}
  union {
    DeviceReportingProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceReportingProtoDefaultTypeInternal _DeviceReportingProto_default_instance_;
PROTOBUF_CONSTEXPR EphemeralUsersEnabledProto::EphemeralUsersEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ephemeral_users_enabled_)*/false} {}
struct EphemeralUsersEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EphemeralUsersEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EphemeralUsersEnabledProtoDefaultTypeInternal() {}
  union {
    EphemeralUsersEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EphemeralUsersEnabledProtoDefaultTypeInternal _EphemeralUsersEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceKeylockerForStorageEncryptionEnabledProto::DeviceKeylockerForStorageEncryptionEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceKeylockerForStorageEncryptionEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceKeylockerForStorageEncryptionEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceKeylockerForStorageEncryptionEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceKeylockerForStorageEncryptionEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceKeylockerForStorageEncryptionEnabledProtoDefaultTypeInternal _DeviceKeylockerForStorageEncryptionEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_AppPackEntryProto::OBSOLETE_AppPackEntryProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_extension_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obsolete_update_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obsolete_online_only_)*/false} {}
struct OBSOLETE_AppPackEntryProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_AppPackEntryProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_AppPackEntryProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_AppPackEntryProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_AppPackEntryProtoDefaultTypeInternal _OBSOLETE_AppPackEntryProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_AppPackProto::OBSOLETE_AppPackProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.app_pack_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OBSOLETE_AppPackProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_AppPackProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_AppPackProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_AppPackProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_AppPackProtoDefaultTypeInternal _OBSOLETE_AppPackProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_PinnedAppsProto::OBSOLETE_PinnedAppsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.obsolete_app_id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OBSOLETE_PinnedAppsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_PinnedAppsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_PinnedAppsProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_PinnedAppsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_PinnedAppsProtoDefaultTypeInternal _OBSOLETE_PinnedAppsProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_ForcedLogoutTimeoutsProto::OBSOLETE_ForcedLogoutTimeoutsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_idle_logout_timeout_)*/int64_t{0}
  , /*decltype(_impl_.obsolete_idle_logout_warning_duration_)*/int64_t{0}} {}
struct OBSOLETE_ForcedLogoutTimeoutsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_ForcedLogoutTimeoutsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_ForcedLogoutTimeoutsProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_ForcedLogoutTimeoutsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_ForcedLogoutTimeoutsProtoDefaultTypeInternal _OBSOLETE_ForcedLogoutTimeoutsProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_ScreenSaverProto::OBSOLETE_ScreenSaverProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_screen_saver_extension_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obsolete_screen_saver_timeout_)*/int64_t{0}} {}
struct OBSOLETE_ScreenSaverProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_ScreenSaverProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_ScreenSaverProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_ScreenSaverProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_ScreenSaverProtoDefaultTypeInternal _OBSOLETE_ScreenSaverProto_default_instance_;
PROTOBUF_CONSTEXPR AutoUpdateSettingsProto::AutoUpdateSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allowed_connection_types_)*/{}
  , /*decltype(_impl_.target_version_prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_version_display_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.disallowed_time_intervals_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.staging_schedule_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_quick_fix_build_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_version_selector_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scatter_factor_in_seconds_)*/int64_t{0}
  , /*decltype(_impl_.update_disabled_)*/false
  , /*decltype(_impl_.obsolete_reboot_after_update_)*/false
  , /*decltype(_impl_.http_downloads_enabled_)*/false
  , /*decltype(_impl_.reboot_after_update_)*/false
  , /*decltype(_impl_.p2p_enabled_)*/false
  , /*decltype(_impl_.rollback_allowed_milestones_)*/0
  , /*decltype(_impl_.rollback_to_target_version_)*/1
  , /*decltype(_impl_.channel_downgrade_behavior_)*/1} {}
struct AutoUpdateSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutoUpdateSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutoUpdateSettingsProtoDefaultTypeInternal() {}
  union {
    AutoUpdateSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutoUpdateSettingsProtoDefaultTypeInternal _AutoUpdateSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_StartUpUrlsProto::OBSOLETE_StartUpUrlsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.obsolete_start_up_urls_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OBSOLETE_StartUpUrlsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_StartUpUrlsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_StartUpUrlsProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_StartUpUrlsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_StartUpUrlsProtoDefaultTypeInternal _OBSOLETE_StartUpUrlsProto_default_instance_;
PROTOBUF_CONSTEXPR SystemTimezoneProto::SystemTimezoneProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timezone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timezone_detection_type_)*/0} {}
struct SystemTimezoneProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemTimezoneProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemTimezoneProtoDefaultTypeInternal() {}
  union {
    SystemTimezoneProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemTimezoneProtoDefaultTypeInternal _SystemTimezoneProto_default_instance_;
PROTOBUF_CONSTEXPR SystemUse24HourClockProto::SystemUse24HourClockProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.use_24hour_clock_)*/false} {}
struct SystemUse24HourClockProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemUse24HourClockProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemUse24HourClockProtoDefaultTypeInternal() {}
  union {
    SystemUse24HourClockProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemUse24HourClockProtoDefaultTypeInternal _SystemUse24HourClockProto_default_instance_;
PROTOBUF_CONSTEXPR KioskAppInfoProto::KioskAppInfoProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.app_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.update_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct KioskAppInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KioskAppInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KioskAppInfoProtoDefaultTypeInternal() {}
  union {
    KioskAppInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KioskAppInfoProtoDefaultTypeInternal _KioskAppInfoProto_default_instance_;
PROTOBUF_CONSTEXPR AndroidKioskAppInfoProto::AndroidKioskAppInfoProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.package_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.class_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.action_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.display_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct AndroidKioskAppInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AndroidKioskAppInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AndroidKioskAppInfoProtoDefaultTypeInternal() {}
  union {
    AndroidKioskAppInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AndroidKioskAppInfoProtoDefaultTypeInternal _AndroidKioskAppInfoProto_default_instance_;
PROTOBUF_CONSTEXPR WebKioskAppInfoProto::WebKioskAppInfoProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.icon_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct WebKioskAppInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WebKioskAppInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WebKioskAppInfoProtoDefaultTypeInternal() {}
  union {
    WebKioskAppInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebKioskAppInfoProtoDefaultTypeInternal _WebKioskAppInfoProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceLocalAccountInfoProto::DeviceLocalAccountInfoProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.deprecated_public_session_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kiosk_app_)*/nullptr
  , /*decltype(_impl_.android_kiosk_app_)*/nullptr
  , /*decltype(_impl_.web_kiosk_app_)*/nullptr
  , /*decltype(_impl_.type_)*/0} {}
struct DeviceLocalAccountInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLocalAccountInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLocalAccountInfoProtoDefaultTypeInternal() {}
  union {
    DeviceLocalAccountInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLocalAccountInfoProtoDefaultTypeInternal _DeviceLocalAccountInfoProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceLocalAccountsProto::DeviceLocalAccountsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_)*/{}
  , /*decltype(_impl_.auto_login_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.auto_login_delay_)*/int64_t{0}
  , /*decltype(_impl_.enable_auto_login_bailout_)*/true
  , /*decltype(_impl_.prompt_for_network_when_offline_)*/true} {}
struct DeviceLocalAccountsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLocalAccountsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLocalAccountsProtoDefaultTypeInternal() {}
  union {
    DeviceLocalAccountsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLocalAccountsProtoDefaultTypeInternal _DeviceLocalAccountsProto_default_instance_;
PROTOBUF_CONSTEXPR ManagedGuestSessionPrivacyWarningsProto::ManagedGuestSessionPrivacyWarningsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/true} {}
struct ManagedGuestSessionPrivacyWarningsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ManagedGuestSessionPrivacyWarningsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ManagedGuestSessionPrivacyWarningsProtoDefaultTypeInternal() {}
  union {
    ManagedGuestSessionPrivacyWarningsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ManagedGuestSessionPrivacyWarningsProtoDefaultTypeInternal _ManagedGuestSessionPrivacyWarningsProto_default_instance_;
PROTOBUF_CONSTEXPR AllowRedeemChromeOsRegistrationOffersProto::AllowRedeemChromeOsRegistrationOffersProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allow_redeem_offers_)*/true} {}
struct AllowRedeemChromeOsRegistrationOffersProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllowRedeemChromeOsRegistrationOffersProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllowRedeemChromeOsRegistrationOffersProtoDefaultTypeInternal() {}
  union {
    AllowRedeemChromeOsRegistrationOffersProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllowRedeemChromeOsRegistrationOffersProtoDefaultTypeInternal _AllowRedeemChromeOsRegistrationOffersProto_default_instance_;
PROTOBUF_CONSTEXPR FeatureFlagsProto::FeatureFlagsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.switches_)*/{}
  , /*decltype(_impl_.feature_flags_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeatureFlagsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureFlagsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureFlagsProtoDefaultTypeInternal() {}
  union {
    FeatureFlagsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureFlagsProtoDefaultTypeInternal _FeatureFlagsProto_default_instance_;
PROTOBUF_CONSTEXPR UptimeLimitProto::UptimeLimitProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_uptime_limit_)*/int64_t{0}
  , /*decltype(_impl_.uptime_limit_)*/int64_t{0}} {}
struct UptimeLimitProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UptimeLimitProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UptimeLimitProtoDefaultTypeInternal() {}
  union {
    UptimeLimitProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UptimeLimitProtoDefaultTypeInternal _UptimeLimitProto_default_instance_;
PROTOBUF_CONSTEXPR VariationsParameterProto::VariationsParameterProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parameter_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct VariationsParameterProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VariationsParameterProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VariationsParameterProtoDefaultTypeInternal() {}
  union {
    VariationsParameterProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VariationsParameterProtoDefaultTypeInternal _VariationsParameterProto_default_instance_;
PROTOBUF_CONSTEXPR AttestationSettingsProto::AttestationSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attestation_enabled_)*/false
  , /*decltype(_impl_.content_protection_enabled_)*/true} {}
struct AttestationSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttestationSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttestationSettingsProtoDefaultTypeInternal() {}
  union {
    AttestationSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttestationSettingsProtoDefaultTypeInternal _AttestationSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR AccessibilitySettingsProto::AccessibilitySettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.login_screen_large_cursor_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_spoken_feedback_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_high_contrast_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_virtual_keyboard_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_dictation_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_select_to_speak_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_cursor_highlight_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_caret_highlight_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_mono_audio_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_autoclick_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_sticky_keys_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_keyboard_focus_highlight_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_screen_magnifier_type_options_)*/nullptr
  , /*decltype(_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_shortcuts_enabled_options_)*/nullptr
  , /*decltype(_impl_.login_screen_default_large_cursor_enabled_)*/false
  , /*decltype(_impl_.login_screen_default_spoken_feedback_enabled_)*/false
  , /*decltype(_impl_.login_screen_default_high_contrast_enabled_)*/false
  , /*decltype(_impl_.login_screen_default_virtual_keyboard_enabled_)*/false
  , /*decltype(_impl_.login_screen_default_screen_magnifier_type_)*/0
  , /*decltype(_impl_.login_screen_large_cursor_enabled_)*/false
  , /*decltype(_impl_.login_screen_spoken_feedback_enabled_)*/false
  , /*decltype(_impl_.login_screen_high_contrast_enabled_)*/false
  , /*decltype(_impl_.login_screen_virtual_keyboard_enabled_)*/false
  , /*decltype(_impl_.login_screen_dictation_enabled_)*/false
  , /*decltype(_impl_.login_screen_select_to_speak_enabled_)*/false
  , /*decltype(_impl_.login_screen_cursor_highlight_enabled_)*/false
  , /*decltype(_impl_.login_screen_caret_highlight_enabled_)*/false
  , /*decltype(_impl_.login_screen_mono_audio_enabled_)*/false
  , /*decltype(_impl_.login_screen_autoclick_enabled_)*/false
  , /*decltype(_impl_.login_screen_sticky_keys_enabled_)*/false
  , /*decltype(_impl_.login_screen_keyboard_focus_highlight_enabled_)*/false
  , /*decltype(_impl_.login_screen_show_options_in_system_tray_menu_enabled_)*/false
  , /*decltype(_impl_.login_screen_shortcuts_enabled_)*/false
  , /*decltype(_impl_.login_screen_screen_magnifier_type_)*/int64_t{0}} {}
struct AccessibilitySettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccessibilitySettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccessibilitySettingsProtoDefaultTypeInternal() {}
  union {
    AccessibilitySettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccessibilitySettingsProtoDefaultTypeInternal _AccessibilitySettingsProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_SupervisedUsersSettingsProto::OBSOLETE_SupervisedUsersSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_supervised_users_enabled_)*/false} {}
struct OBSOLETE_SupervisedUsersSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_SupervisedUsersSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_SupervisedUsersSettingsProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_SupervisedUsersSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_SupervisedUsersSettingsProtoDefaultTypeInternal _OBSOLETE_SupervisedUsersSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR LoginScreenPowerManagementProto::LoginScreenPowerManagementProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.login_screen_power_management_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LoginScreenPowerManagementProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginScreenPowerManagementProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginScreenPowerManagementProtoDefaultTypeInternal() {}
  union {
    LoginScreenPowerManagementProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginScreenPowerManagementProtoDefaultTypeInternal _LoginScreenPowerManagementProto_default_instance_;
PROTOBUF_CONSTEXPR AutoCleanupSettigsProto::AutoCleanupSettigsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.clean_up_strategy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct AutoCleanupSettigsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutoCleanupSettigsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutoCleanupSettigsProtoDefaultTypeInternal() {}
  union {
    AutoCleanupSettigsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutoCleanupSettigsProtoDefaultTypeInternal _AutoCleanupSettigsProto_default_instance_;
PROTOBUF_CONSTEXPR SystemSettingsProto::SystemSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.block_devmode_)*/false} {}
struct SystemSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemSettingsProtoDefaultTypeInternal() {}
  union {
    SystemSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemSettingsProtoDefaultTypeInternal _SystemSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR SAMLSettingsProto::SAMLSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_url_parameter_to_autofill_saml_username_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.transfer_saml_cookies_)*/false} {}
struct SAMLSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SAMLSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SAMLSettingsProtoDefaultTypeInternal() {}
  union {
    SAMLSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SAMLSettingsProtoDefaultTypeInternal _SAMLSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR SAMLUsernameProto::SAMLUsernameProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_parameter_to_autofill_saml_username_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SAMLUsernameProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SAMLUsernameProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SAMLUsernameProtoDefaultTypeInternal() {}
  union {
    SAMLUsernameProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SAMLUsernameProtoDefaultTypeInternal _SAMLUsernameProto_default_instance_;
PROTOBUF_CONSTEXPR RebootOnShutdownProto::RebootOnShutdownProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reboot_on_shutdown_)*/false} {}
struct RebootOnShutdownProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RebootOnShutdownProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RebootOnShutdownProtoDefaultTypeInternal() {}
  union {
    RebootOnShutdownProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RebootOnShutdownProtoDefaultTypeInternal _RebootOnShutdownProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceHeartbeatSettingsProto::DeviceHeartbeatSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heartbeat_enabled_)*/false
  , /*decltype(_impl_.heartbeat_frequency_)*/int64_t{120000}} {}
struct DeviceHeartbeatSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceHeartbeatSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceHeartbeatSettingsProtoDefaultTypeInternal() {}
  union {
    DeviceHeartbeatSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceHeartbeatSettingsProtoDefaultTypeInternal _DeviceHeartbeatSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR ExtensionCacheSizeProto::ExtensionCacheSizeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.extension_cache_size_)*/int64_t{0}} {}
struct ExtensionCacheSizeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtensionCacheSizeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtensionCacheSizeProtoDefaultTypeInternal() {}
  union {
    ExtensionCacheSizeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionCacheSizeProtoDefaultTypeInternal _ExtensionCacheSizeProto_default_instance_;
PROTOBUF_CONSTEXPR LoginScreenDomainAutoCompleteProto::LoginScreenDomainAutoCompleteProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.login_screen_domain_auto_complete_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LoginScreenDomainAutoCompleteProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginScreenDomainAutoCompleteProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginScreenDomainAutoCompleteProtoDefaultTypeInternal() {}
  union {
    LoginScreenDomainAutoCompleteProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginScreenDomainAutoCompleteProtoDefaultTypeInternal _LoginScreenDomainAutoCompleteProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceLogUploadSettingsProto::DeviceLogUploadSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.system_log_upload_enabled_)*/false} {}
struct DeviceLogUploadSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLogUploadSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLogUploadSettingsProtoDefaultTypeInternal() {}
  union {
    DeviceLogUploadSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLogUploadSettingsProtoDefaultTypeInternal _DeviceLogUploadSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR DisplayRotationDefaultProto::DisplayRotationDefaultProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.display_rotation_default_)*/0} {}
struct DisplayRotationDefaultProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DisplayRotationDefaultProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DisplayRotationDefaultProtoDefaultTypeInternal() {}
  union {
    DisplayRotationDefaultProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisplayRotationDefaultProtoDefaultTypeInternal _DisplayRotationDefaultProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceLoginScreenPrivacyScreenEnabledProto::DeviceLoginScreenPrivacyScreenEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceLoginScreenPrivacyScreenEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLoginScreenPrivacyScreenEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLoginScreenPrivacyScreenEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceLoginScreenPrivacyScreenEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLoginScreenPrivacyScreenEnabledProtoDefaultTypeInternal _DeviceLoginScreenPrivacyScreenEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceDisplayResolutionProto::DeviceDisplayResolutionProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_display_resolution_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceDisplayResolutionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceDisplayResolutionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceDisplayResolutionProtoDefaultTypeInternal() {}
  union {
    DeviceDisplayResolutionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceDisplayResolutionProtoDefaultTypeInternal _DeviceDisplayResolutionProto_default_instance_;
PROTOBUF_CONSTEXPR AllowKioskAppControlChromeVersionProto::AllowKioskAppControlChromeVersionProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allow_kiosk_app_control_chrome_version_)*/false} {}
struct AllowKioskAppControlChromeVersionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllowKioskAppControlChromeVersionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllowKioskAppControlChromeVersionProtoDefaultTypeInternal() {}
  union {
    AllowKioskAppControlChromeVersionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllowKioskAppControlChromeVersionProtoDefaultTypeInternal _AllowKioskAppControlChromeVersionProto_default_instance_;
PROTOBUF_CONSTEXPR LoginAuthenticationBehaviorProto::LoginAuthenticationBehaviorProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.login_authentication_behavior_)*/0} {}
struct LoginAuthenticationBehaviorProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginAuthenticationBehaviorProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginAuthenticationBehaviorProtoDefaultTypeInternal() {}
  union {
    LoginAuthenticationBehaviorProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginAuthenticationBehaviorProtoDefaultTypeInternal _LoginAuthenticationBehaviorProto_default_instance_;
PROTOBUF_CONSTEXPR UsbDeviceIdProto::UsbDeviceIdProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vendor_id_)*/0
  , /*decltype(_impl_.product_id_)*/0} {}
struct UsbDeviceIdProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsbDeviceIdProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsbDeviceIdProtoDefaultTypeInternal() {}
  union {
    UsbDeviceIdProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsbDeviceIdProtoDefaultTypeInternal _UsbDeviceIdProto_default_instance_;
PROTOBUF_CONSTEXPR UsbDetachableWhitelistProto::UsbDetachableWhitelistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsbDetachableWhitelistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsbDetachableWhitelistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsbDetachableWhitelistProtoDefaultTypeInternal() {}
  union {
    UsbDetachableWhitelistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsbDetachableWhitelistProtoDefaultTypeInternal _UsbDetachableWhitelistProto_default_instance_;
PROTOBUF_CONSTEXPR UsbDeviceIdInclusiveProto::UsbDeviceIdInclusiveProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vendor_id_)*/0
  , /*decltype(_impl_.product_id_)*/0} {}
struct UsbDeviceIdInclusiveProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsbDeviceIdInclusiveProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsbDeviceIdInclusiveProtoDefaultTypeInternal() {}
  union {
    UsbDeviceIdInclusiveProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsbDeviceIdInclusiveProtoDefaultTypeInternal _UsbDeviceIdInclusiveProto_default_instance_;
PROTOBUF_CONSTEXPR UsbDetachableAllowlistProto::UsbDetachableAllowlistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsbDetachableAllowlistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsbDetachableAllowlistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsbDetachableAllowlistProtoDefaultTypeInternal() {}
  union {
    UsbDetachableAllowlistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsbDetachableAllowlistProtoDefaultTypeInternal _UsbDetachableAllowlistProto_default_instance_;
PROTOBUF_CONSTEXPR AllowBluetoothProto::AllowBluetoothProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allow_bluetooth_)*/true} {}
struct AllowBluetoothProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllowBluetoothProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllowBluetoothProtoDefaultTypeInternal() {}
  union {
    AllowBluetoothProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllowBluetoothProtoDefaultTypeInternal _AllowBluetoothProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceWiFiAllowedProto::DeviceWiFiAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_wifi_allowed_)*/true} {}
struct DeviceWiFiAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceWiFiAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceWiFiAllowedProtoDefaultTypeInternal() {}
  union {
    DeviceWiFiAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceWiFiAllowedProtoDefaultTypeInternal _DeviceWiFiAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceQuirksDownloadEnabledProto::DeviceQuirksDownloadEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.quirks_download_enabled_)*/false} {}
struct DeviceQuirksDownloadEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceQuirksDownloadEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceQuirksDownloadEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceQuirksDownloadEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceQuirksDownloadEnabledProtoDefaultTypeInternal _DeviceQuirksDownloadEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR LoginVideoCaptureAllowedUrlsProto::LoginVideoCaptureAllowedUrlsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.urls_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginVideoCaptureAllowedUrlsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginVideoCaptureAllowedUrlsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginVideoCaptureAllowedUrlsProtoDefaultTypeInternal() {}
  union {
    LoginVideoCaptureAllowedUrlsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginVideoCaptureAllowedUrlsProtoDefaultTypeInternal _LoginVideoCaptureAllowedUrlsProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceWiFiFastTransitionEnabledProto::DeviceWiFiFastTransitionEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_wifi_fast_transition_enabled_)*/false} {}
struct DeviceWiFiFastTransitionEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceWiFiFastTransitionEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceWiFiFastTransitionEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceWiFiFastTransitionEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceWiFiFastTransitionEnabledProtoDefaultTypeInternal _DeviceWiFiFastTransitionEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR NetworkThrottlingEnabledProto::NetworkThrottlingEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.upload_rate_kbits_)*/0
  , /*decltype(_impl_.download_rate_kbits_)*/0} {}
struct NetworkThrottlingEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkThrottlingEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkThrottlingEnabledProtoDefaultTypeInternal() {}
  union {
    NetworkThrottlingEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkThrottlingEnabledProtoDefaultTypeInternal _NetworkThrottlingEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceLoginScreenExtensionsProto::DeviceLoginScreenExtensionsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.device_login_screen_extensions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceLoginScreenExtensionsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLoginScreenExtensionsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLoginScreenExtensionsProtoDefaultTypeInternal() {}
  union {
    DeviceLoginScreenExtensionsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLoginScreenExtensionsProtoDefaultTypeInternal _DeviceLoginScreenExtensionsProto_default_instance_;
PROTOBUF_CONSTEXPR LoginScreenExtensionManifestV2AvailabilityProto::LoginScreenExtensionManifestV2AvailabilityProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.login_screen_extension_manifest_v2_availability_)*/0} {}
struct LoginScreenExtensionManifestV2AvailabilityProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginScreenExtensionManifestV2AvailabilityProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginScreenExtensionManifestV2AvailabilityProtoDefaultTypeInternal() {}
  union {
    LoginScreenExtensionManifestV2AvailabilityProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginScreenExtensionManifestV2AvailabilityProtoDefaultTypeInternal _LoginScreenExtensionManifestV2AvailabilityProto_default_instance_;
PROTOBUF_CONSTEXPR LoginScreenLocalesProto::LoginScreenLocalesProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.login_screen_locales_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginScreenLocalesProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginScreenLocalesProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginScreenLocalesProtoDefaultTypeInternal() {}
  union {
    LoginScreenLocalesProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginScreenLocalesProtoDefaultTypeInternal _LoginScreenLocalesProto_default_instance_;
PROTOBUF_CONSTEXPR LoginScreenInputMethodsProto::LoginScreenInputMethodsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.login_screen_input_methods_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginScreenInputMethodsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginScreenInputMethodsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginScreenInputMethodsProtoDefaultTypeInternal() {}
  union {
    LoginScreenInputMethodsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginScreenInputMethodsProtoDefaultTypeInternal _LoginScreenInputMethodsProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceWallpaperImageProto::DeviceWallpaperImageProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_wallpaper_image_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceWallpaperImageProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceWallpaperImageProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceWallpaperImageProtoDefaultTypeInternal() {}
  union {
    DeviceWallpaperImageProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceWallpaperImageProtoDefaultTypeInternal _DeviceWallpaperImageProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceScreensaverIdleTimeoutSecondsProto::DeviceScreensaverIdleTimeoutSecondsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_screensaver_idle_timeout_seconds_)*/int64_t{0}} {}
struct DeviceScreensaverIdleTimeoutSecondsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceScreensaverIdleTimeoutSecondsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceScreensaverIdleTimeoutSecondsProtoDefaultTypeInternal() {}
  union {
    DeviceScreensaverIdleTimeoutSecondsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceScreensaverIdleTimeoutSecondsProtoDefaultTypeInternal _DeviceScreensaverIdleTimeoutSecondsProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceScreensaverImageDisplayIntervalSecondsProto::DeviceScreensaverImageDisplayIntervalSecondsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_screensaver_image_display_interval_seconds_)*/int64_t{0}} {}
struct DeviceScreensaverImageDisplayIntervalSecondsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceScreensaverImageDisplayIntervalSecondsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceScreensaverImageDisplayIntervalSecondsProtoDefaultTypeInternal() {}
  union {
    DeviceScreensaverImageDisplayIntervalSecondsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceScreensaverImageDisplayIntervalSecondsProtoDefaultTypeInternal _DeviceScreensaverImageDisplayIntervalSecondsProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceScreensaverImagesProto::DeviceScreensaverImagesProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.device_screensaver_images_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceScreensaverImagesProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceScreensaverImagesProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceScreensaverImagesProtoDefaultTypeInternal() {}
  union {
    DeviceScreensaverImagesProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceScreensaverImagesProtoDefaultTypeInternal _DeviceScreensaverImagesProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceSystemAecEnabledProto::DeviceSystemAecEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_system_aec_enabled_)*/false} {}
struct DeviceSystemAecEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceSystemAecEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceSystemAecEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceSystemAecEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceSystemAecEnabledProtoDefaultTypeInternal _DeviceSystemAecEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceScreensaverEnabledProto::DeviceScreensaverEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_screensaver_enabled_)*/false} {}
struct DeviceScreensaverEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceScreensaverEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceScreensaverEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceScreensaverEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceScreensaverEnabledProtoDefaultTypeInternal _DeviceScreensaverEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceEcryptfsMigrationStrategyProto::DeviceEcryptfsMigrationStrategyProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.migration_strategy_)*/0} {}
struct DeviceEcryptfsMigrationStrategyProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceEcryptfsMigrationStrategyProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceEcryptfsMigrationStrategyProtoDefaultTypeInternal() {}
  union {
    DeviceEcryptfsMigrationStrategyProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceEcryptfsMigrationStrategyProtoDefaultTypeInternal _DeviceEcryptfsMigrationStrategyProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceSecondFactorAuthenticationProto::DeviceSecondFactorAuthenticationProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/0} {}
struct DeviceSecondFactorAuthenticationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceSecondFactorAuthenticationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceSecondFactorAuthenticationProtoDefaultTypeInternal() {}
  union {
    DeviceSecondFactorAuthenticationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceSecondFactorAuthenticationProtoDefaultTypeInternal _DeviceSecondFactorAuthenticationProto_default_instance_;
PROTOBUF_CONSTEXPR CastReceiverNameProto::CastReceiverNameProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CastReceiverNameProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CastReceiverNameProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CastReceiverNameProtoDefaultTypeInternal() {}
  union {
    CastReceiverNameProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CastReceiverNameProtoDefaultTypeInternal _CastReceiverNameProto_default_instance_;
PROTOBUF_CONSTEXPR WeeklyTimeProto::WeeklyTimeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.day_of_week_)*/0
  , /*decltype(_impl_.time_)*/0} {}
struct WeeklyTimeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WeeklyTimeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WeeklyTimeProtoDefaultTypeInternal() {}
  union {
    WeeklyTimeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WeeklyTimeProtoDefaultTypeInternal _WeeklyTimeProto_default_instance_;
PROTOBUF_CONSTEXPR WeeklyTimeIntervalProto::WeeklyTimeIntervalProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr} {}
struct WeeklyTimeIntervalProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WeeklyTimeIntervalProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WeeklyTimeIntervalProtoDefaultTypeInternal() {}
  union {
    WeeklyTimeIntervalProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WeeklyTimeIntervalProtoDefaultTypeInternal _WeeklyTimeIntervalProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceOffHoursProto::DeviceOffHoursProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.intervals_)*/{}
  , /*decltype(_impl_.ignored_policy_proto_tags_)*/{}
  , /*decltype(_impl_.timezone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceOffHoursProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceOffHoursProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceOffHoursProtoDefaultTypeInternal() {}
  union {
    DeviceOffHoursProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceOffHoursProtoDefaultTypeInternal _DeviceOffHoursProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceNativePrintersProto::DeviceNativePrintersProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.external_policy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceNativePrintersProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceNativePrintersProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceNativePrintersProtoDefaultTypeInternal() {}
  union {
    DeviceNativePrintersProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceNativePrintersProtoDefaultTypeInternal _DeviceNativePrintersProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceNativePrintersAccessModeProto::DeviceNativePrintersAccessModeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.access_mode_)*/0} {}
struct DeviceNativePrintersAccessModeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceNativePrintersAccessModeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceNativePrintersAccessModeProtoDefaultTypeInternal() {}
  union {
    DeviceNativePrintersAccessModeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceNativePrintersAccessModeProtoDefaultTypeInternal _DeviceNativePrintersAccessModeProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceNativePrintersBlacklistProto::DeviceNativePrintersBlacklistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.blacklist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceNativePrintersBlacklistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceNativePrintersBlacklistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceNativePrintersBlacklistProtoDefaultTypeInternal() {}
  union {
    DeviceNativePrintersBlacklistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceNativePrintersBlacklistProtoDefaultTypeInternal _DeviceNativePrintersBlacklistProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceNativePrintersWhitelistProto::DeviceNativePrintersWhitelistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.whitelist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceNativePrintersWhitelistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceNativePrintersWhitelistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceNativePrintersWhitelistProtoDefaultTypeInternal() {}
  union {
    DeviceNativePrintersWhitelistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceNativePrintersWhitelistProtoDefaultTypeInternal _DeviceNativePrintersWhitelistProto_default_instance_;
PROTOBUF_CONSTEXPR DevicePrintersProto::DevicePrintersProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.external_policy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DevicePrintersProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePrintersProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePrintersProtoDefaultTypeInternal() {}
  union {
    DevicePrintersProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePrintersProtoDefaultTypeInternal _DevicePrintersProto_default_instance_;
PROTOBUF_CONSTEXPR DevicePrintersAccessModeProto::DevicePrintersAccessModeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.access_mode_)*/0} {}
struct DevicePrintersAccessModeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePrintersAccessModeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePrintersAccessModeProtoDefaultTypeInternal() {}
  union {
    DevicePrintersAccessModeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePrintersAccessModeProtoDefaultTypeInternal _DevicePrintersAccessModeProto_default_instance_;
PROTOBUF_CONSTEXPR DevicePrintersBlocklistProto::DevicePrintersBlocklistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.blocklist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DevicePrintersBlocklistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePrintersBlocklistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePrintersBlocklistProtoDefaultTypeInternal() {}
  union {
    DevicePrintersBlocklistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePrintersBlocklistProtoDefaultTypeInternal _DevicePrintersBlocklistProto_default_instance_;
PROTOBUF_CONSTEXPR DevicePrintersAllowlistProto::DevicePrintersAllowlistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.allowlist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DevicePrintersAllowlistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePrintersAllowlistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePrintersAllowlistProtoDefaultTypeInternal() {}
  union {
    DevicePrintersAllowlistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePrintersAllowlistProtoDefaultTypeInternal _DevicePrintersAllowlistProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceExternalPrintServersProto::DeviceExternalPrintServersProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.external_policy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceExternalPrintServersProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceExternalPrintServersProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceExternalPrintServersProtoDefaultTypeInternal() {}
  union {
    DeviceExternalPrintServersProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceExternalPrintServersProtoDefaultTypeInternal _DeviceExternalPrintServersProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceExternalPrintServersAllowlistProto::DeviceExternalPrintServersAllowlistProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.allowlist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceExternalPrintServersAllowlistProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceExternalPrintServersAllowlistProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceExternalPrintServersAllowlistProtoDefaultTypeInternal() {}
  union {
    DeviceExternalPrintServersAllowlistProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceExternalPrintServersAllowlistProtoDefaultTypeInternal _DeviceExternalPrintServersAllowlistProto_default_instance_;
PROTOBUF_CONSTEXPR TPMFirmwareUpdateSettingsProto::TPMFirmwareUpdateSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allow_user_initiated_powerwash_)*/false
  , /*decltype(_impl_.allow_user_initiated_preserve_device_state_)*/false
  , /*decltype(_impl_.auto_update_mode_)*/1} {}
struct TPMFirmwareUpdateSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TPMFirmwareUpdateSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TPMFirmwareUpdateSettingsProtoDefaultTypeInternal() {}
  union {
    TPMFirmwareUpdateSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TPMFirmwareUpdateSettingsProtoDefaultTypeInternal _TPMFirmwareUpdateSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_MinimumRequiredVersionProto::OBSOLETE_MinimumRequiredVersionProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_chrome_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct OBSOLETE_MinimumRequiredVersionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_MinimumRequiredVersionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_MinimumRequiredVersionProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_MinimumRequiredVersionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_MinimumRequiredVersionProtoDefaultTypeInternal _OBSOLETE_MinimumRequiredVersionProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceLoginScreenAutoSelectCertificateForUrls::DeviceLoginScreenAutoSelectCertificateForUrls(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.login_screen_auto_select_certificate_rules_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceLoginScreenAutoSelectCertificateForUrlsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLoginScreenAutoSelectCertificateForUrlsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLoginScreenAutoSelectCertificateForUrlsDefaultTypeInternal() {}
  union {
    DeviceLoginScreenAutoSelectCertificateForUrls _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLoginScreenAutoSelectCertificateForUrlsDefaultTypeInternal _DeviceLoginScreenAutoSelectCertificateForUrls_default_instance_;
PROTOBUF_CONSTEXPR UnaffiliatedArcAllowedProto::UnaffiliatedArcAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unaffiliated_arc_allowed_)*/false} {}
struct UnaffiliatedArcAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnaffiliatedArcAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnaffiliatedArcAllowedProtoDefaultTypeInternal() {}
  union {
    UnaffiliatedArcAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnaffiliatedArcAllowedProtoDefaultTypeInternal _UnaffiliatedArcAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceKerberosEncryptionTypesProto::DeviceKerberosEncryptionTypesProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.types_)*/1} {}
struct DeviceKerberosEncryptionTypesProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceKerberosEncryptionTypesProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceKerberosEncryptionTypesProtoDefaultTypeInternal() {}
  union {
    DeviceKerberosEncryptionTypesProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceKerberosEncryptionTypesProtoDefaultTypeInternal _DeviceKerberosEncryptionTypesProto_default_instance_;
PROTOBUF_CONSTEXPR KeyboardBacklightColorProto::KeyboardBacklightColorProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/0} {}
struct KeyboardBacklightColorProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyboardBacklightColorProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyboardBacklightColorProtoDefaultTypeInternal() {}
  union {
    KeyboardBacklightColorProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyboardBacklightColorProtoDefaultTypeInternal _KeyboardBacklightColorProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceUserPolicyLoopbackProcessingModeProto::DeviceUserPolicyLoopbackProcessingModeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/0} {}
struct DeviceUserPolicyLoopbackProcessingModeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceUserPolicyLoopbackProcessingModeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceUserPolicyLoopbackProcessingModeProtoDefaultTypeInternal() {}
  union {
    DeviceUserPolicyLoopbackProcessingModeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceUserPolicyLoopbackProcessingModeProtoDefaultTypeInternal _DeviceUserPolicyLoopbackProcessingModeProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_DeviceLoginScreenIsolateOriginsProto::OBSOLETE_DeviceLoginScreenIsolateOriginsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_isolate_origins_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct OBSOLETE_DeviceLoginScreenIsolateOriginsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_DeviceLoginScreenIsolateOriginsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_DeviceLoginScreenIsolateOriginsProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_DeviceLoginScreenIsolateOriginsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_DeviceLoginScreenIsolateOriginsProtoDefaultTypeInternal _OBSOLETE_DeviceLoginScreenIsolateOriginsProto_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_DeviceLoginScreenSitePerProcessProto::OBSOLETE_DeviceLoginScreenSitePerProcessProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_site_per_process_)*/false} {}
struct OBSOLETE_DeviceLoginScreenSitePerProcessProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_DeviceLoginScreenSitePerProcessProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_DeviceLoginScreenSitePerProcessProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_DeviceLoginScreenSitePerProcessProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_DeviceLoginScreenSitePerProcessProtoDefaultTypeInternal _OBSOLETE_DeviceLoginScreenSitePerProcessProto_default_instance_;
PROTOBUF_CONSTEXPR VirtualMachinesAllowedProto::VirtualMachinesAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.virtual_machines_allowed_)*/false} {}
struct VirtualMachinesAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VirtualMachinesAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VirtualMachinesAllowedProtoDefaultTypeInternal() {}
  union {
    VirtualMachinesAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VirtualMachinesAllowedProtoDefaultTypeInternal _VirtualMachinesAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceMachinePasswordChangeRateProto::DeviceMachinePasswordChangeRateProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rate_days_)*/0} {}
struct DeviceMachinePasswordChangeRateProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceMachinePasswordChangeRateProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceMachinePasswordChangeRateProtoDefaultTypeInternal() {}
  union {
    DeviceMachinePasswordChangeRateProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceMachinePasswordChangeRateProtoDefaultTypeInternal _DeviceMachinePasswordChangeRateProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceGpoCacheLifetimeProto::DeviceGpoCacheLifetimeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lifetime_hours_)*/0} {}
struct DeviceGpoCacheLifetimeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceGpoCacheLifetimeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceGpoCacheLifetimeProtoDefaultTypeInternal() {}
  union {
    DeviceGpoCacheLifetimeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceGpoCacheLifetimeProtoDefaultTypeInternal _DeviceGpoCacheLifetimeProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceAuthDataCacheLifetimeProto::DeviceAuthDataCacheLifetimeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lifetime_hours_)*/0} {}
struct DeviceAuthDataCacheLifetimeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAuthDataCacheLifetimeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAuthDataCacheLifetimeProtoDefaultTypeInternal() {}
  union {
    DeviceAuthDataCacheLifetimeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAuthDataCacheLifetimeProtoDefaultTypeInternal _DeviceAuthDataCacheLifetimeProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceUnaffiliatedCrostiniAllowedProto::DeviceUnaffiliatedCrostiniAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_unaffiliated_crostini_allowed_)*/false} {}
struct DeviceUnaffiliatedCrostiniAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceUnaffiliatedCrostiniAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceUnaffiliatedCrostiniAllowedProtoDefaultTypeInternal() {}
  union {
    DeviceUnaffiliatedCrostiniAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceUnaffiliatedCrostiniAllowedProtoDefaultTypeInternal _DeviceUnaffiliatedCrostiniAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR PluginVmAllowedProto::PluginVmAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.plugin_vm_allowed_)*/false} {}
struct PluginVmAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PluginVmAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PluginVmAllowedProtoDefaultTypeInternal() {}
  union {
    PluginVmAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PluginVmAllowedProtoDefaultTypeInternal _PluginVmAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR PluginVmLicenseKeyProto::PluginVmLicenseKeyProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.plugin_vm_license_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PluginVmLicenseKeyProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PluginVmLicenseKeyProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PluginVmLicenseKeyProtoDefaultTypeInternal() {}
  union {
    PluginVmLicenseKeyProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PluginVmLicenseKeyProtoDefaultTypeInternal _PluginVmLicenseKeyProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceRebootOnUserSignoutProto::DeviceRebootOnUserSignoutProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reboot_on_signout_mode_)*/1} {}
struct DeviceRebootOnUserSignoutProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceRebootOnUserSignoutProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceRebootOnUserSignoutProtoDefaultTypeInternal() {}
  union {
    DeviceRebootOnUserSignoutProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceRebootOnUserSignoutProtoDefaultTypeInternal _DeviceRebootOnUserSignoutProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceWilcoDtcAllowedProto::DeviceWilcoDtcAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_wilco_dtc_allowed_)*/false} {}
struct DeviceWilcoDtcAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceWilcoDtcAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceWilcoDtcAllowedProtoDefaultTypeInternal() {}
  union {
    DeviceWilcoDtcAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceWilcoDtcAllowedProtoDefaultTypeInternal _DeviceWilcoDtcAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceWilcoDtcConfigurationProto::DeviceWilcoDtcConfigurationProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_wilco_dtc_configuration_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceWilcoDtcConfigurationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceWilcoDtcConfigurationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceWilcoDtcConfigurationProtoDefaultTypeInternal() {}
  union {
    DeviceWilcoDtcConfigurationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceWilcoDtcConfigurationProtoDefaultTypeInternal _DeviceWilcoDtcConfigurationProto_default_instance_;
PROTOBUF_CONSTEXPR DevicePowerPeakShiftProto::DevicePowerPeakShiftProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.day_configs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.battery_threshold_)*/0} {}
struct DevicePowerPeakShiftProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePowerPeakShiftProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePowerPeakShiftProtoDefaultTypeInternal() {}
  union {
    DevicePowerPeakShiftProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePowerPeakShiftProtoDefaultTypeInternal _DevicePowerPeakShiftProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceBootOnAcProto::DeviceBootOnAcProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceBootOnAcProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceBootOnAcProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceBootOnAcProtoDefaultTypeInternal() {}
  union {
    DeviceBootOnAcProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceBootOnAcProtoDefaultTypeInternal _DeviceBootOnAcProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceDockMacAddressSourceProto::DeviceDockMacAddressSourceProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.source_)*/0} {}
struct DeviceDockMacAddressSourceProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceDockMacAddressSourceProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceDockMacAddressSourceProtoDefaultTypeInternal() {}
  union {
    DeviceDockMacAddressSourceProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceDockMacAddressSourceProtoDefaultTypeInternal _DeviceDockMacAddressSourceProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceAdvancedBatteryChargeModeProto::DeviceAdvancedBatteryChargeModeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.day_configs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceAdvancedBatteryChargeModeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAdvancedBatteryChargeModeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAdvancedBatteryChargeModeProtoDefaultTypeInternal() {}
  union {
    DeviceAdvancedBatteryChargeModeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAdvancedBatteryChargeModeProtoDefaultTypeInternal _DeviceAdvancedBatteryChargeModeProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceBatteryChargeModeProto::DeviceBatteryChargeModeProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.battery_charge_mode_)*/0
  , /*decltype(_impl_.custom_charge_start_)*/0
  , /*decltype(_impl_.custom_charge_stop_)*/0} {}
struct DeviceBatteryChargeModeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceBatteryChargeModeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceBatteryChargeModeProtoDefaultTypeInternal() {}
  union {
    DeviceBatteryChargeModeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceBatteryChargeModeProtoDefaultTypeInternal _DeviceBatteryChargeModeProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceUsbPowerShareProto::DeviceUsbPowerShareProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceUsbPowerShareProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceUsbPowerShareProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceUsbPowerShareProtoDefaultTypeInternal() {}
  union {
    DeviceUsbPowerShareProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceUsbPowerShareProtoDefaultTypeInternal _DeviceUsbPowerShareProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceScheduledUpdateCheckProto::DeviceScheduledUpdateCheckProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_scheduled_update_check_settings_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceScheduledUpdateCheckProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceScheduledUpdateCheckProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceScheduledUpdateCheckProtoDefaultTypeInternal() {}
  union {
    DeviceScheduledUpdateCheckProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceScheduledUpdateCheckProtoDefaultTypeInternal _DeviceScheduledUpdateCheckProto_default_instance_;
PROTOBUF_CONSTEXPR DevicePowerwashAllowedProto::DevicePowerwashAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_powerwash_allowed_)*/false} {}
struct DevicePowerwashAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePowerwashAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePowerwashAllowedProtoDefaultTypeInternal() {}
  union {
    DevicePowerwashAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePowerwashAllowedProtoDefaultTypeInternal _DevicePowerwashAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_login_screen_webusb_allow_devices_for_urls_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceLoginScreenWebUsbAllowDevicesForUrlsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLoginScreenWebUsbAllowDevicesForUrlsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLoginScreenWebUsbAllowDevicesForUrlsProtoDefaultTypeInternal() {}
  union {
    DeviceLoginScreenWebUsbAllowDevicesForUrlsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLoginScreenWebUsbAllowDevicesForUrlsProtoDefaultTypeInternal _DeviceLoginScreenWebUsbAllowDevicesForUrlsProto_default_instance_;
PROTOBUF_CONSTEXPR SystemProxySettingsProto::SystemProxySettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.system_proxy_settings_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SystemProxySettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProxySettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProxySettingsProtoDefaultTypeInternal() {}
  union {
    SystemProxySettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProxySettingsProtoDefaultTypeInternal _SystemProxySettingsProto_default_instance_;
PROTOBUF_CONSTEXPR RequiredClientCertificateForDeviceProto::RequiredClientCertificateForDeviceProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.required_client_certificate_for_device_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct RequiredClientCertificateForDeviceProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequiredClientCertificateForDeviceProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequiredClientCertificateForDeviceProtoDefaultTypeInternal() {}
  union {
    RequiredClientCertificateForDeviceProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequiredClientCertificateForDeviceProtoDefaultTypeInternal _RequiredClientCertificateForDeviceProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceCrostiniArcAdbSideloadingAllowedProto::DeviceCrostiniArcAdbSideloadingAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/0} {}
struct DeviceCrostiniArcAdbSideloadingAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceCrostiniArcAdbSideloadingAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceCrostiniArcAdbSideloadingAllowedProtoDefaultTypeInternal() {}
  union {
    DeviceCrostiniArcAdbSideloadingAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceCrostiniArcAdbSideloadingAllowedProtoDefaultTypeInternal _DeviceCrostiniArcAdbSideloadingAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceShowLowDiskSpaceNotificationProto::DeviceShowLowDiskSpaceNotificationProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_show_low_disk_space_notification_)*/false} {}
struct DeviceShowLowDiskSpaceNotificationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceShowLowDiskSpaceNotificationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceShowLowDiskSpaceNotificationProtoDefaultTypeInternal() {}
  union {
    DeviceShowLowDiskSpaceNotificationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceShowLowDiskSpaceNotificationProtoDefaultTypeInternal _DeviceShowLowDiskSpaceNotificationProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceFamilyLinkAccountsAllowedProto::DeviceFamilyLinkAccountsAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.family_link_accounts_allowed_)*/false} {}
struct DeviceFamilyLinkAccountsAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceFamilyLinkAccountsAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceFamilyLinkAccountsAllowedProtoDefaultTypeInternal() {}
  union {
    DeviceFamilyLinkAccountsAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceFamilyLinkAccountsAllowedProtoDefaultTypeInternal _DeviceFamilyLinkAccountsAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceArcDataSnapshotHoursProto::DeviceArcDataSnapshotHoursProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.arc_data_snapshot_hours_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceArcDataSnapshotHoursProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceArcDataSnapshotHoursProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceArcDataSnapshotHoursProtoDefaultTypeInternal() {}
  union {
    DeviceArcDataSnapshotHoursProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceArcDataSnapshotHoursProtoDefaultTypeInternal _DeviceArcDataSnapshotHoursProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceSystemWideTracingEnabledProto::DeviceSystemWideTracingEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceSystemWideTracingEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceSystemWideTracingEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceSystemWideTracingEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceSystemWideTracingEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceSystemWideTracingEnabledProtoDefaultTypeInternal _DeviceSystemWideTracingEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DevicePciPeripheralDataAccessEnabledProto::DevicePciPeripheralDataAccessEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DevicePciPeripheralDataAccessEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePciPeripheralDataAccessEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePciPeripheralDataAccessEnabledProtoDefaultTypeInternal() {}
  union {
    DevicePciPeripheralDataAccessEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePciPeripheralDataAccessEnabledProtoDefaultTypeInternal _DevicePciPeripheralDataAccessEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DevicePciPeripheralDataAccessEnabledProtoV2::DevicePciPeripheralDataAccessEnabledProtoV2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DevicePciPeripheralDataAccessEnabledProtoV2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePciPeripheralDataAccessEnabledProtoV2DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePciPeripheralDataAccessEnabledProtoV2DefaultTypeInternal() {}
  union {
    DevicePciPeripheralDataAccessEnabledProtoV2 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePciPeripheralDataAccessEnabledProtoV2DefaultTypeInternal _DevicePciPeripheralDataAccessEnabledProtoV2_default_instance_;
PROTOBUF_CONSTEXPR OBSOLETE_DeviceBorealisAllowedProto::OBSOLETE_DeviceBorealisAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allowed_)*/true} {}
struct OBSOLETE_DeviceBorealisAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OBSOLETE_DeviceBorealisAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OBSOLETE_DeviceBorealisAllowedProtoDefaultTypeInternal() {}
  union {
    OBSOLETE_DeviceBorealisAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OBSOLETE_DeviceBorealisAllowedProtoDefaultTypeInternal _OBSOLETE_DeviceBorealisAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceAllowedBluetoothServicesProto::DeviceAllowedBluetoothServicesProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.allowlist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceAllowedBluetoothServicesProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAllowedBluetoothServicesProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAllowedBluetoothServicesProtoDefaultTypeInternal() {}
  union {
    DeviceAllowedBluetoothServicesProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAllowedBluetoothServicesProtoDefaultTypeInternal _DeviceAllowedBluetoothServicesProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceDebugPacketCaptureAllowedProto::DeviceDebugPacketCaptureAllowedProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allowed_)*/false} {}
struct DeviceDebugPacketCaptureAllowedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceDebugPacketCaptureAllowedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceDebugPacketCaptureAllowedProtoDefaultTypeInternal() {}
  union {
    DeviceDebugPacketCaptureAllowedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceDebugPacketCaptureAllowedProtoDefaultTypeInternal _DeviceDebugPacketCaptureAllowedProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceScheduledRebootProto::DeviceScheduledRebootProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_scheduled_reboot_settings_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceScheduledRebootProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceScheduledRebootProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceScheduledRebootProtoDefaultTypeInternal() {}
  union {
    DeviceScheduledRebootProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceScheduledRebootProtoDefaultTypeInternal _DeviceScheduledRebootProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceRestrictedManagedGuestSessionEnabledProto::DeviceRestrictedManagedGuestSessionEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceRestrictedManagedGuestSessionEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceRestrictedManagedGuestSessionEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceRestrictedManagedGuestSessionEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceRestrictedManagedGuestSessionEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceRestrictedManagedGuestSessionEnabledProtoDefaultTypeInternal _DeviceRestrictedManagedGuestSessionEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceI18nShortcutsEnabledProto::DeviceI18nShortcutsEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/true} {}
struct DeviceI18nShortcutsEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceI18nShortcutsEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceI18nShortcutsEnabledProtoDefaultTypeInternal() {}
  union {
    DeviceI18nShortcutsEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceI18nShortcutsEnabledProtoDefaultTypeInternal _DeviceI18nShortcutsEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR RevenDeviceHWDataUsageEnabledProto::RevenDeviceHWDataUsageEnabledProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hardware_data_usage_enabled_)*/false} {}
struct RevenDeviceHWDataUsageEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RevenDeviceHWDataUsageEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RevenDeviceHWDataUsageEnabledProtoDefaultTypeInternal() {}
  union {
    RevenDeviceHWDataUsageEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RevenDeviceHWDataUsageEnabledProtoDefaultTypeInternal _RevenDeviceHWDataUsageEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceLoginScreenWebUILazyLoadingProto::DeviceLoginScreenWebUILazyLoadingProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceLoginScreenWebUILazyLoadingProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLoginScreenWebUILazyLoadingProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLoginScreenWebUILazyLoadingProtoDefaultTypeInternal() {}
  union {
    DeviceLoginScreenWebUILazyLoadingProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLoginScreenWebUILazyLoadingProtoDefaultTypeInternal _DeviceLoginScreenWebUILazyLoadingProto_default_instance_;
PROTOBUF_CONSTEXPR EncryptedReportingPipelineConfigurationProto::EncryptedReportingPipelineConfigurationProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/true} {}
struct EncryptedReportingPipelineConfigurationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncryptedReportingPipelineConfigurationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncryptedReportingPipelineConfigurationProtoDefaultTypeInternal() {}
  union {
    EncryptedReportingPipelineConfigurationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncryptedReportingPipelineConfigurationProtoDefaultTypeInternal _EncryptedReportingPipelineConfigurationProto_default_instance_;
PROTOBUF_CONSTEXPR DeviceReportXDREventsProto::DeviceReportXDREventsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct DeviceReportXDREventsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceReportXDREventsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceReportXDREventsProtoDefaultTypeInternal() {}
  union {
    DeviceReportXDREventsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceReportXDREventsProtoDefaultTypeInternal _DeviceReportXDREventsProto_default_instance_;
PROTOBUF_CONSTEXPR ChromeDeviceSettingsProto::ChromeDeviceSettingsProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_policy_refresh_rate_)*/nullptr
  , /*decltype(_impl_.user_whitelist_)*/nullptr
  , /*decltype(_impl_.guest_mode_enabled_)*/nullptr
  , /*decltype(_impl_.device_proxy_settings_)*/nullptr
  , /*decltype(_impl_.camera_enabled_)*/nullptr
  , /*decltype(_impl_.show_user_names_)*/nullptr
  , /*decltype(_impl_.data_roaming_enabled_)*/nullptr
  , /*decltype(_impl_.allow_new_users_)*/nullptr
  , /*decltype(_impl_.metrics_enabled_)*/nullptr
  , /*decltype(_impl_.release_channel_)*/nullptr
  , /*decltype(_impl_.open_network_configuration_)*/nullptr
  , /*decltype(_impl_.device_reporting_)*/nullptr
  , /*decltype(_impl_.ephemeral_users_enabled_)*/nullptr
  , /*decltype(_impl_.app_pack_)*/nullptr
  , /*decltype(_impl_.forced_logout_timeouts_)*/nullptr
  , /*decltype(_impl_.login_screen_saver_)*/nullptr
  , /*decltype(_impl_.auto_update_settings_)*/nullptr
  , /*decltype(_impl_.start_up_urls_)*/nullptr
  , /*decltype(_impl_.pinned_apps_)*/nullptr
  , /*decltype(_impl_.system_timezone_)*/nullptr
  , /*decltype(_impl_.device_local_accounts_)*/nullptr
  , /*decltype(_impl_.allow_redeem_offers_)*/nullptr
  , /*decltype(_impl_.feature_flags_)*/nullptr
  , /*decltype(_impl_.uptime_limit_)*/nullptr
  , /*decltype(_impl_.variations_parameter_)*/nullptr
  , /*decltype(_impl_.attestation_settings_)*/nullptr
  , /*decltype(_impl_.accessibility_settings_)*/nullptr
  , /*decltype(_impl_.supervised_users_settings_)*/nullptr
  , /*decltype(_impl_.login_screen_power_management_)*/nullptr
  , /*decltype(_impl_.use_24hour_clock_)*/nullptr
  , /*decltype(_impl_.auto_clean_up_settings_)*/nullptr
  , /*decltype(_impl_.system_settings_)*/nullptr
  , /*decltype(_impl_.saml_settings_)*/nullptr
  , /*decltype(_impl_.reboot_on_shutdown_)*/nullptr
  , /*decltype(_impl_.device_heartbeat_settings_)*/nullptr
  , /*decltype(_impl_.extension_cache_size_)*/nullptr
  , /*decltype(_impl_.login_screen_domain_auto_complete_)*/nullptr
  , /*decltype(_impl_.device_log_upload_settings_)*/nullptr
  , /*decltype(_impl_.display_rotation_default_)*/nullptr
  , /*decltype(_impl_.allow_kiosk_app_control_chrome_version_)*/nullptr
  , /*decltype(_impl_.login_authentication_behavior_)*/nullptr
  , /*decltype(_impl_.usb_detachable_whitelist_)*/nullptr
  , /*decltype(_impl_.allow_bluetooth_)*/nullptr
  , /*decltype(_impl_.quirks_download_enabled_)*/nullptr
  , /*decltype(_impl_.login_video_capture_allowed_urls_)*/nullptr
  , /*decltype(_impl_.device_login_screen_extensions_)*/nullptr
  , /*decltype(_impl_.network_throttling_)*/nullptr
  , /*decltype(_impl_.device_wallpaper_image_)*/nullptr
  , /*decltype(_impl_.login_screen_locales_)*/nullptr
  , /*decltype(_impl_.login_screen_input_methods_)*/nullptr
  , /*decltype(_impl_.device_ecryptfs_migration_strategy_)*/nullptr
  , /*decltype(_impl_.device_second_factor_authentication_)*/nullptr
  , /*decltype(_impl_.cast_receiver_name_)*/nullptr
  , /*decltype(_impl_.device_off_hours_)*/nullptr
  , /*decltype(_impl_.native_device_printers_)*/nullptr
  , /*decltype(_impl_.native_device_printers_access_mode_)*/nullptr
  , /*decltype(_impl_.native_device_printers_blacklist_)*/nullptr
  , /*decltype(_impl_.native_device_printers_whitelist_)*/nullptr
  , /*decltype(_impl_.tpm_firmware_update_settings_)*/nullptr
  , /*decltype(_impl_.minimum_required_version_)*/nullptr
  , /*decltype(_impl_.device_login_screen_auto_select_certificate_for_urls_)*/nullptr
  , /*decltype(_impl_.unaffiliated_arc_allowed_)*/nullptr
  , /*decltype(_impl_.network_hostname_)*/nullptr
  , /*decltype(_impl_.device_kerberos_encryption_types_)*/nullptr
  , /*decltype(_impl_.device_user_policy_loopback_processing_mode_)*/nullptr
  , /*decltype(_impl_.device_login_screen_isolate_origins_)*/nullptr
  , /*decltype(_impl_.device_login_screen_site_per_process_)*/nullptr
  , /*decltype(_impl_.virtual_machines_allowed_)*/nullptr
  , /*decltype(_impl_.device_machine_password_change_rate_)*/nullptr
  , /*decltype(_impl_.device_unaffiliated_crostini_allowed_)*/nullptr
  , /*decltype(_impl_.device_wifi_fast_transition_enabled_)*/nullptr
  , /*decltype(_impl_.device_display_resolution_)*/nullptr
  , /*decltype(_impl_.plugin_vm_allowed_)*/nullptr
  , /*decltype(_impl_.device_gpo_cache_lifetime_)*/nullptr
  , /*decltype(_impl_.device_auth_data_cache_lifetime_)*/nullptr
  , /*decltype(_impl_.plugin_vm_license_key_)*/nullptr
  , /*decltype(_impl_.device_reboot_on_user_signout_)*/nullptr
  , /*decltype(_impl_.device_wilco_dtc_allowed_)*/nullptr
  , /*decltype(_impl_.device_wilco_dtc_configuration_)*/nullptr
  , /*decltype(_impl_.device_wifi_allowed_)*/nullptr
  , /*decltype(_impl_.device_power_peak_shift_)*/nullptr
  , /*decltype(_impl_.device_boot_on_ac_)*/nullptr
  , /*decltype(_impl_.device_dock_mac_address_source_)*/nullptr
  , /*decltype(_impl_.device_advanced_battery_charge_mode_)*/nullptr
  , /*decltype(_impl_.device_battery_charge_mode_)*/nullptr
  , /*decltype(_impl_.device_usb_power_share_)*/nullptr
  , /*decltype(_impl_.device_scheduled_update_check_)*/nullptr
  , /*decltype(_impl_.device_powerwash_allowed_)*/nullptr
  , /*decltype(_impl_.device_login_screen_webusb_allow_devices_for_urls_)*/nullptr
  , /*decltype(_impl_.device_login_screen_system_info_enforced_)*/nullptr
  , /*decltype(_impl_.device_web_based_attestation_allowed_urls_)*/nullptr
  , /*decltype(_impl_.device_show_numeric_keyboard_for_password_)*/nullptr
  , /*decltype(_impl_.login_screen_primary_mouse_button_switch_)*/nullptr
  , /*decltype(_impl_.device_minimum_version_)*/nullptr
  , /*decltype(_impl_.system_proxy_settings_)*/nullptr
  , /*decltype(_impl_.device_chrome_variations_type_)*/nullptr
  , /*decltype(_impl_.device_login_screen_privacy_screen_enabled_)*/nullptr
  , /*decltype(_impl_.required_client_certificate_for_device_)*/nullptr
  , /*decltype(_impl_.device_crostini_arc_adb_sideloading_allowed_)*/nullptr
  , /*decltype(_impl_.device_minimum_version_aue_message_)*/nullptr
  , /*decltype(_impl_.managed_guest_session_privacy_warnings_)*/nullptr
  , /*decltype(_impl_.external_print_servers_)*/nullptr
  , /*decltype(_impl_.external_print_servers_allowlist_)*/nullptr
  , /*decltype(_impl_.device_printers_access_mode_)*/nullptr
  , /*decltype(_impl_.device_printers_blocklist_)*/nullptr
  , /*decltype(_impl_.device_printers_allowlist_)*/nullptr
  , /*decltype(_impl_.device_printers_)*/nullptr
  , /*decltype(_impl_.device_show_low_disk_space_notification_)*/nullptr
  , /*decltype(_impl_.user_allowlist_)*/nullptr
  , /*decltype(_impl_.usb_detachable_allowlist_)*/nullptr
  , /*decltype(_impl_.family_link_accounts_allowed_)*/nullptr
  , /*decltype(_impl_.arc_data_snapshot_hours_)*/nullptr
  , /*decltype(_impl_.device_allow_mgs_to_store_display_properties_)*/nullptr
  , /*decltype(_impl_.device_system_wide_tracing_enabled_)*/nullptr
  , /*decltype(_impl_.device_pci_peripheral_data_access_enabled_)*/nullptr
  , /*decltype(_impl_.device_borealis_allowed_)*/nullptr
  , /*decltype(_impl_.device_allowed_bluetooth_services_)*/nullptr
  , /*decltype(_impl_.device_debug_packet_capture_allowed_)*/nullptr
  , /*decltype(_impl_.device_scheduled_reboot_)*/nullptr
  , /*decltype(_impl_.device_pci_peripheral_data_access_enabled_v2_)*/nullptr
  , /*decltype(_impl_.device_restricted_managed_guest_session_enabled_)*/nullptr
  , /*decltype(_impl_.hostname_user_configurable_)*/nullptr
  , /*decltype(_impl_.login_screen_prompt_on_multiple_matching_certificates_)*/nullptr
  , /*decltype(_impl_.kiosk_crx_manifest_update_url_ignored_)*/nullptr
  , /*decltype(_impl_.device_i18n_shortcuts_enabled_)*/nullptr
  , /*decltype(_impl_.chromad_to_cloud_migration_enabled_)*/nullptr
  , /*decltype(_impl_.hardware_data_usage_enabled_)*/nullptr
  , /*decltype(_impl_.login_web_ui_lazy_loading_)*/nullptr
  , /*decltype(_impl_.keylocker_for_storage_encryption_enabled_)*/nullptr
  , /*decltype(_impl_.device_run_automatic_cleanup_on_login_)*/nullptr
  , /*decltype(_impl_.device_encrypted_reporting_pipeline_enabled_)*/nullptr
  , /*decltype(_impl_.saml_username_)*/nullptr
  , /*decltype(_impl_.device_login_screen_context_aware_access_signals_allowlist_)*/nullptr
  , /*decltype(_impl_.device_printing_client_name_template_)*/nullptr
  , /*decltype(_impl_.device_report_xdr_events_)*/nullptr
  , /*decltype(_impl_.keyboard_backlight_color_)*/nullptr
  , /*decltype(_impl_.device_hindi_inscript_layout_enabled_)*/nullptr
  , /*decltype(_impl_.login_screen_extension_manifest_v2_availability_)*/nullptr
  , /*decltype(_impl_.device_screensaver_enabled_)*/nullptr
  , /*decltype(_impl_.device_screensaver_idle_timeout_seconds_)*/nullptr
  , /*decltype(_impl_.device_screensaver_image_display_interval_seconds_)*/nullptr
  , /*decltype(_impl_.device_screensaver_images_)*/nullptr
  , /*decltype(_impl_.device_system_aec_enabled_)*/nullptr} {}
struct ChromeDeviceSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeDeviceSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeDeviceSettingsProtoDefaultTypeInternal() {}
  union {
    ChromeDeviceSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeDeviceSettingsProtoDefaultTypeInternal _ChromeDeviceSettingsProto_default_instance_;
}  // namespace enterprise_management
namespace enterprise_management {
bool AutoUpdateSettingsProto_ConnectionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutoUpdateSettingsProto_ConnectionType_strings[5] = {};

static const char AutoUpdateSettingsProto_ConnectionType_names[] =
  "CONNECTION_TYPE_BLUETOOTH"
  "CONNECTION_TYPE_CELLULAR"
  "CONNECTION_TYPE_ETHERNET"
  "CONNECTION_TYPE_WIFI"
  "CONNECTION_TYPE_WIMAX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutoUpdateSettingsProto_ConnectionType_entries[] = {
  { {AutoUpdateSettingsProto_ConnectionType_names + 0, 25}, 3 },
  { {AutoUpdateSettingsProto_ConnectionType_names + 25, 24}, 4 },
  { {AutoUpdateSettingsProto_ConnectionType_names + 49, 24}, 0 },
  { {AutoUpdateSettingsProto_ConnectionType_names + 73, 20}, 1 },
  { {AutoUpdateSettingsProto_ConnectionType_names + 93, 21}, 2 },
};

static const int AutoUpdateSettingsProto_ConnectionType_entries_by_number[] = {
  2, // 0 -> CONNECTION_TYPE_ETHERNET
  3, // 1 -> CONNECTION_TYPE_WIFI
  4, // 2 -> CONNECTION_TYPE_WIMAX
  0, // 3 -> CONNECTION_TYPE_BLUETOOTH
  1, // 4 -> CONNECTION_TYPE_CELLULAR
};

const std::string& AutoUpdateSettingsProto_ConnectionType_Name(
    AutoUpdateSettingsProto_ConnectionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AutoUpdateSettingsProto_ConnectionType_entries,
          AutoUpdateSettingsProto_ConnectionType_entries_by_number,
          5, AutoUpdateSettingsProto_ConnectionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AutoUpdateSettingsProto_ConnectionType_entries,
      AutoUpdateSettingsProto_ConnectionType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AutoUpdateSettingsProto_ConnectionType_strings[idx].get();
}
bool AutoUpdateSettingsProto_ConnectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoUpdateSettingsProto_ConnectionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AutoUpdateSettingsProto_ConnectionType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<AutoUpdateSettingsProto_ConnectionType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::CONNECTION_TYPE_ETHERNET;
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::CONNECTION_TYPE_WIFI;
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::CONNECTION_TYPE_WIMAX;
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::CONNECTION_TYPE_BLUETOOTH;
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::CONNECTION_TYPE_CELLULAR;
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::ConnectionType_MIN;
constexpr AutoUpdateSettingsProto_ConnectionType AutoUpdateSettingsProto::ConnectionType_MAX;
constexpr int AutoUpdateSettingsProto::ConnectionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutoUpdateSettingsProto_RollbackToTargetVersion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutoUpdateSettingsProto_RollbackToTargetVersion_strings[4] = {};

static const char AutoUpdateSettingsProto_RollbackToTargetVersion_names[] =
  "ROLLBACK_AND_POWERWASH"
  "ROLLBACK_AND_RESTORE_IF_POSSIBLE"
  "ROLLBACK_DISABLED"
  "ROLLBACK_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutoUpdateSettingsProto_RollbackToTargetVersion_entries[] = {
  { {AutoUpdateSettingsProto_RollbackToTargetVersion_names + 0, 22}, 2 },
  { {AutoUpdateSettingsProto_RollbackToTargetVersion_names + 22, 32}, 3 },
  { {AutoUpdateSettingsProto_RollbackToTargetVersion_names + 54, 17}, 1 },
  { {AutoUpdateSettingsProto_RollbackToTargetVersion_names + 71, 20}, 0 },
};

static const int AutoUpdateSettingsProto_RollbackToTargetVersion_entries_by_number[] = {
  3, // 0 -> ROLLBACK_UNSPECIFIED
  2, // 1 -> ROLLBACK_DISABLED
  0, // 2 -> ROLLBACK_AND_POWERWASH
  1, // 3 -> ROLLBACK_AND_RESTORE_IF_POSSIBLE
};

const std::string& AutoUpdateSettingsProto_RollbackToTargetVersion_Name(
    AutoUpdateSettingsProto_RollbackToTargetVersion value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AutoUpdateSettingsProto_RollbackToTargetVersion_entries,
          AutoUpdateSettingsProto_RollbackToTargetVersion_entries_by_number,
          4, AutoUpdateSettingsProto_RollbackToTargetVersion_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AutoUpdateSettingsProto_RollbackToTargetVersion_entries,
      AutoUpdateSettingsProto_RollbackToTargetVersion_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AutoUpdateSettingsProto_RollbackToTargetVersion_strings[idx].get();
}
bool AutoUpdateSettingsProto_RollbackToTargetVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoUpdateSettingsProto_RollbackToTargetVersion* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AutoUpdateSettingsProto_RollbackToTargetVersion_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AutoUpdateSettingsProto_RollbackToTargetVersion>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto::ROLLBACK_UNSPECIFIED;
constexpr AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto::ROLLBACK_DISABLED;
constexpr AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto::ROLLBACK_AND_POWERWASH;
constexpr AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto::ROLLBACK_AND_RESTORE_IF_POSSIBLE;
constexpr AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto::RollbackToTargetVersion_MIN;
constexpr AutoUpdateSettingsProto_RollbackToTargetVersion AutoUpdateSettingsProto::RollbackToTargetVersion_MAX;
constexpr int AutoUpdateSettingsProto::RollbackToTargetVersion_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutoUpdateSettingsProto_ChannelDowngradeBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutoUpdateSettingsProto_ChannelDowngradeBehavior_strings[4] = {};

static const char AutoUpdateSettingsProto_ChannelDowngradeBehavior_names[] =
  "ALLOW_USER_TO_CONFIGURE"
  "CHANNEL_DOWNGRADE_BEHAVIOR_UNSPECIFIED"
  "ROLLBACK"
  "WAIT_FOR_VERSION_CATCH_UP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutoUpdateSettingsProto_ChannelDowngradeBehavior_entries[] = {
  { {AutoUpdateSettingsProto_ChannelDowngradeBehavior_names + 0, 23}, 3 },
  { {AutoUpdateSettingsProto_ChannelDowngradeBehavior_names + 23, 38}, 0 },
  { {AutoUpdateSettingsProto_ChannelDowngradeBehavior_names + 61, 8}, 2 },
  { {AutoUpdateSettingsProto_ChannelDowngradeBehavior_names + 69, 25}, 1 },
};

static const int AutoUpdateSettingsProto_ChannelDowngradeBehavior_entries_by_number[] = {
  1, // 0 -> CHANNEL_DOWNGRADE_BEHAVIOR_UNSPECIFIED
  3, // 1 -> WAIT_FOR_VERSION_CATCH_UP
  2, // 2 -> ROLLBACK
  0, // 3 -> ALLOW_USER_TO_CONFIGURE
};

const std::string& AutoUpdateSettingsProto_ChannelDowngradeBehavior_Name(
    AutoUpdateSettingsProto_ChannelDowngradeBehavior value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AutoUpdateSettingsProto_ChannelDowngradeBehavior_entries,
          AutoUpdateSettingsProto_ChannelDowngradeBehavior_entries_by_number,
          4, AutoUpdateSettingsProto_ChannelDowngradeBehavior_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AutoUpdateSettingsProto_ChannelDowngradeBehavior_entries,
      AutoUpdateSettingsProto_ChannelDowngradeBehavior_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AutoUpdateSettingsProto_ChannelDowngradeBehavior_strings[idx].get();
}
bool AutoUpdateSettingsProto_ChannelDowngradeBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoUpdateSettingsProto_ChannelDowngradeBehavior* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AutoUpdateSettingsProto_ChannelDowngradeBehavior_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AutoUpdateSettingsProto_ChannelDowngradeBehavior>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto::CHANNEL_DOWNGRADE_BEHAVIOR_UNSPECIFIED;
constexpr AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto::WAIT_FOR_VERSION_CATCH_UP;
constexpr AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto::ROLLBACK;
constexpr AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto::ALLOW_USER_TO_CONFIGURE;
constexpr AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto::ChannelDowngradeBehavior_MIN;
constexpr AutoUpdateSettingsProto_ChannelDowngradeBehavior AutoUpdateSettingsProto::ChannelDowngradeBehavior_MAX;
constexpr int AutoUpdateSettingsProto::ChannelDowngradeBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemTimezoneProto_AutomaticTimezoneDetectionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemTimezoneProto_AutomaticTimezoneDetectionType_strings[5] = {};

static const char SystemTimezoneProto_AutomaticTimezoneDetectionType_names[] =
  "DISABLED"
  "IP_ONLY"
  "SEND_ALL_LOCATION_INFO"
  "SEND_WIFI_ACCESS_POINTS"
  "USERS_DECIDE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemTimezoneProto_AutomaticTimezoneDetectionType_entries[] = {
  { {SystemTimezoneProto_AutomaticTimezoneDetectionType_names + 0, 8}, 1 },
  { {SystemTimezoneProto_AutomaticTimezoneDetectionType_names + 8, 7}, 2 },
  { {SystemTimezoneProto_AutomaticTimezoneDetectionType_names + 15, 22}, 4 },
  { {SystemTimezoneProto_AutomaticTimezoneDetectionType_names + 37, 23}, 3 },
  { {SystemTimezoneProto_AutomaticTimezoneDetectionType_names + 60, 12}, 0 },
};

static const int SystemTimezoneProto_AutomaticTimezoneDetectionType_entries_by_number[] = {
  4, // 0 -> USERS_DECIDE
  0, // 1 -> DISABLED
  1, // 2 -> IP_ONLY
  3, // 3 -> SEND_WIFI_ACCESS_POINTS
  2, // 4 -> SEND_ALL_LOCATION_INFO
};

const std::string& SystemTimezoneProto_AutomaticTimezoneDetectionType_Name(
    SystemTimezoneProto_AutomaticTimezoneDetectionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemTimezoneProto_AutomaticTimezoneDetectionType_entries,
          SystemTimezoneProto_AutomaticTimezoneDetectionType_entries_by_number,
          5, SystemTimezoneProto_AutomaticTimezoneDetectionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemTimezoneProto_AutomaticTimezoneDetectionType_entries,
      SystemTimezoneProto_AutomaticTimezoneDetectionType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemTimezoneProto_AutomaticTimezoneDetectionType_strings[idx].get();
}
bool SystemTimezoneProto_AutomaticTimezoneDetectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemTimezoneProto_AutomaticTimezoneDetectionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemTimezoneProto_AutomaticTimezoneDetectionType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SystemTimezoneProto_AutomaticTimezoneDetectionType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::USERS_DECIDE;
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::DISABLED;
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::IP_ONLY;
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::SEND_WIFI_ACCESS_POINTS;
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::SEND_ALL_LOCATION_INFO;
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::AutomaticTimezoneDetectionType_MIN;
constexpr SystemTimezoneProto_AutomaticTimezoneDetectionType SystemTimezoneProto::AutomaticTimezoneDetectionType_MAX;
constexpr int SystemTimezoneProto::AutomaticTimezoneDetectionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceLocalAccountInfoProto_AccountType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceLocalAccountInfoProto_AccountType_strings[5] = {};

static const char DeviceLocalAccountInfoProto_AccountType_names[] =
  "ACCOUNT_TYPE_KIOSK_ANDROID_APP"
  "ACCOUNT_TYPE_KIOSK_APP"
  "ACCOUNT_TYPE_PUBLIC_SESSION"
  "ACCOUNT_TYPE_SAML_PUBLIC_SESSION"
  "ACCOUNT_TYPE_WEB_KIOSK_APP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceLocalAccountInfoProto_AccountType_entries[] = {
  { {DeviceLocalAccountInfoProto_AccountType_names + 0, 30}, 2 },
  { {DeviceLocalAccountInfoProto_AccountType_names + 30, 22}, 1 },
  { {DeviceLocalAccountInfoProto_AccountType_names + 52, 27}, 0 },
  { {DeviceLocalAccountInfoProto_AccountType_names + 79, 32}, 3 },
  { {DeviceLocalAccountInfoProto_AccountType_names + 111, 26}, 4 },
};

static const int DeviceLocalAccountInfoProto_AccountType_entries_by_number[] = {
  2, // 0 -> ACCOUNT_TYPE_PUBLIC_SESSION
  1, // 1 -> ACCOUNT_TYPE_KIOSK_APP
  0, // 2 -> ACCOUNT_TYPE_KIOSK_ANDROID_APP
  3, // 3 -> ACCOUNT_TYPE_SAML_PUBLIC_SESSION
  4, // 4 -> ACCOUNT_TYPE_WEB_KIOSK_APP
};

const std::string& DeviceLocalAccountInfoProto_AccountType_Name(
    DeviceLocalAccountInfoProto_AccountType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceLocalAccountInfoProto_AccountType_entries,
          DeviceLocalAccountInfoProto_AccountType_entries_by_number,
          5, DeviceLocalAccountInfoProto_AccountType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceLocalAccountInfoProto_AccountType_entries,
      DeviceLocalAccountInfoProto_AccountType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceLocalAccountInfoProto_AccountType_strings[idx].get();
}
bool DeviceLocalAccountInfoProto_AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceLocalAccountInfoProto_AccountType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceLocalAccountInfoProto_AccountType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<DeviceLocalAccountInfoProto_AccountType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::ACCOUNT_TYPE_PUBLIC_SESSION;
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::ACCOUNT_TYPE_KIOSK_APP;
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::ACCOUNT_TYPE_KIOSK_ANDROID_APP;
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::ACCOUNT_TYPE_SAML_PUBLIC_SESSION;
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::ACCOUNT_TYPE_WEB_KIOSK_APP;
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::AccountType_MIN;
constexpr DeviceLocalAccountInfoProto_AccountType DeviceLocalAccountInfoProto::AccountType_MAX;
constexpr int DeviceLocalAccountInfoProto::AccountType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AccessibilitySettingsProto_ScreenMagnifierType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AccessibilitySettingsProto_ScreenMagnifierType_strings[2] = {};

static const char AccessibilitySettingsProto_ScreenMagnifierType_names[] =
  "SCREEN_MAGNIFIER_TYPE_FULL"
  "SCREEN_MAGNIFIER_TYPE_NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AccessibilitySettingsProto_ScreenMagnifierType_entries[] = {
  { {AccessibilitySettingsProto_ScreenMagnifierType_names + 0, 26}, 1 },
  { {AccessibilitySettingsProto_ScreenMagnifierType_names + 26, 26}, 0 },
};

static const int AccessibilitySettingsProto_ScreenMagnifierType_entries_by_number[] = {
  1, // 0 -> SCREEN_MAGNIFIER_TYPE_NONE
  0, // 1 -> SCREEN_MAGNIFIER_TYPE_FULL
};

const std::string& AccessibilitySettingsProto_ScreenMagnifierType_Name(
    AccessibilitySettingsProto_ScreenMagnifierType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AccessibilitySettingsProto_ScreenMagnifierType_entries,
          AccessibilitySettingsProto_ScreenMagnifierType_entries_by_number,
          2, AccessibilitySettingsProto_ScreenMagnifierType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AccessibilitySettingsProto_ScreenMagnifierType_entries,
      AccessibilitySettingsProto_ScreenMagnifierType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AccessibilitySettingsProto_ScreenMagnifierType_strings[idx].get();
}
bool AccessibilitySettingsProto_ScreenMagnifierType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccessibilitySettingsProto_ScreenMagnifierType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AccessibilitySettingsProto_ScreenMagnifierType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<AccessibilitySettingsProto_ScreenMagnifierType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AccessibilitySettingsProto_ScreenMagnifierType AccessibilitySettingsProto::SCREEN_MAGNIFIER_TYPE_NONE;
constexpr AccessibilitySettingsProto_ScreenMagnifierType AccessibilitySettingsProto::SCREEN_MAGNIFIER_TYPE_FULL;
constexpr AccessibilitySettingsProto_ScreenMagnifierType AccessibilitySettingsProto::ScreenMagnifierType_MIN;
constexpr AccessibilitySettingsProto_ScreenMagnifierType AccessibilitySettingsProto::ScreenMagnifierType_MAX;
constexpr int AccessibilitySettingsProto::ScreenMagnifierType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DisplayRotationDefaultProto_Rotation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DisplayRotationDefaultProto_Rotation_strings[4] = {};

static const char DisplayRotationDefaultProto_Rotation_names[] =
  "ROTATE_0"
  "ROTATE_180"
  "ROTATE_270"
  "ROTATE_90";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DisplayRotationDefaultProto_Rotation_entries[] = {
  { {DisplayRotationDefaultProto_Rotation_names + 0, 8}, 0 },
  { {DisplayRotationDefaultProto_Rotation_names + 8, 10}, 2 },
  { {DisplayRotationDefaultProto_Rotation_names + 18, 10}, 3 },
  { {DisplayRotationDefaultProto_Rotation_names + 28, 9}, 1 },
};

static const int DisplayRotationDefaultProto_Rotation_entries_by_number[] = {
  0, // 0 -> ROTATE_0
  3, // 1 -> ROTATE_90
  1, // 2 -> ROTATE_180
  2, // 3 -> ROTATE_270
};

const std::string& DisplayRotationDefaultProto_Rotation_Name(
    DisplayRotationDefaultProto_Rotation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DisplayRotationDefaultProto_Rotation_entries,
          DisplayRotationDefaultProto_Rotation_entries_by_number,
          4, DisplayRotationDefaultProto_Rotation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DisplayRotationDefaultProto_Rotation_entries,
      DisplayRotationDefaultProto_Rotation_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DisplayRotationDefaultProto_Rotation_strings[idx].get();
}
bool DisplayRotationDefaultProto_Rotation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DisplayRotationDefaultProto_Rotation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DisplayRotationDefaultProto_Rotation_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DisplayRotationDefaultProto_Rotation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto::ROTATE_0;
constexpr DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto::ROTATE_90;
constexpr DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto::ROTATE_180;
constexpr DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto::ROTATE_270;
constexpr DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto::Rotation_MIN;
constexpr DisplayRotationDefaultProto_Rotation DisplayRotationDefaultProto::Rotation_MAX;
constexpr int DisplayRotationDefaultProto::Rotation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginAuthenticationBehaviorProto_LoginBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginAuthenticationBehaviorProto_LoginBehavior_strings[2] = {};

static const char LoginAuthenticationBehaviorProto_LoginBehavior_names[] =
  "GAIA"
  "SAML_INTERSTITIAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginAuthenticationBehaviorProto_LoginBehavior_entries[] = {
  { {LoginAuthenticationBehaviorProto_LoginBehavior_names + 0, 4}, 0 },
  { {LoginAuthenticationBehaviorProto_LoginBehavior_names + 4, 17}, 1 },
};

static const int LoginAuthenticationBehaviorProto_LoginBehavior_entries_by_number[] = {
  0, // 0 -> GAIA
  1, // 1 -> SAML_INTERSTITIAL
};

const std::string& LoginAuthenticationBehaviorProto_LoginBehavior_Name(
    LoginAuthenticationBehaviorProto_LoginBehavior value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginAuthenticationBehaviorProto_LoginBehavior_entries,
          LoginAuthenticationBehaviorProto_LoginBehavior_entries_by_number,
          2, LoginAuthenticationBehaviorProto_LoginBehavior_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginAuthenticationBehaviorProto_LoginBehavior_entries,
      LoginAuthenticationBehaviorProto_LoginBehavior_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginAuthenticationBehaviorProto_LoginBehavior_strings[idx].get();
}
bool LoginAuthenticationBehaviorProto_LoginBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginAuthenticationBehaviorProto_LoginBehavior* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginAuthenticationBehaviorProto_LoginBehavior_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<LoginAuthenticationBehaviorProto_LoginBehavior>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginAuthenticationBehaviorProto_LoginBehavior LoginAuthenticationBehaviorProto::GAIA;
constexpr LoginAuthenticationBehaviorProto_LoginBehavior LoginAuthenticationBehaviorProto::SAML_INTERSTITIAL;
constexpr LoginAuthenticationBehaviorProto_LoginBehavior LoginAuthenticationBehaviorProto::LoginBehavior_MIN;
constexpr LoginAuthenticationBehaviorProto_LoginBehavior LoginAuthenticationBehaviorProto::LoginBehavior_MAX;
constexpr int LoginAuthenticationBehaviorProto::LoginBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginScreenExtensionManifestV2AvailabilityProto_Availability_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginScreenExtensionManifestV2AvailabilityProto_Availability_strings[4] = {};

static const char LoginScreenExtensionManifestV2AvailabilityProto_Availability_names[] =
  "DEFAULT"
  "DISABLE"
  "ENABLE"
  "ENABLE_FOR_FORCED_EXTENSIONS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginScreenExtensionManifestV2AvailabilityProto_Availability_entries[] = {
  { {LoginScreenExtensionManifestV2AvailabilityProto_Availability_names + 0, 7}, 0 },
  { {LoginScreenExtensionManifestV2AvailabilityProto_Availability_names + 7, 7}, 1 },
  { {LoginScreenExtensionManifestV2AvailabilityProto_Availability_names + 14, 6}, 2 },
  { {LoginScreenExtensionManifestV2AvailabilityProto_Availability_names + 20, 28}, 3 },
};

static const int LoginScreenExtensionManifestV2AvailabilityProto_Availability_entries_by_number[] = {
  0, // 0 -> DEFAULT
  1, // 1 -> DISABLE
  2, // 2 -> ENABLE
  3, // 3 -> ENABLE_FOR_FORCED_EXTENSIONS
};

const std::string& LoginScreenExtensionManifestV2AvailabilityProto_Availability_Name(
    LoginScreenExtensionManifestV2AvailabilityProto_Availability value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginScreenExtensionManifestV2AvailabilityProto_Availability_entries,
          LoginScreenExtensionManifestV2AvailabilityProto_Availability_entries_by_number,
          4, LoginScreenExtensionManifestV2AvailabilityProto_Availability_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginScreenExtensionManifestV2AvailabilityProto_Availability_entries,
      LoginScreenExtensionManifestV2AvailabilityProto_Availability_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginScreenExtensionManifestV2AvailabilityProto_Availability_strings[idx].get();
}
bool LoginScreenExtensionManifestV2AvailabilityProto_Availability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginScreenExtensionManifestV2AvailabilityProto_Availability* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginScreenExtensionManifestV2AvailabilityProto_Availability_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<LoginScreenExtensionManifestV2AvailabilityProto_Availability>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto::DEFAULT;
constexpr LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto::DISABLE;
constexpr LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto::ENABLE;
constexpr LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto::ENABLE_FOR_FORCED_EXTENSIONS;
constexpr LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto::Availability_MIN;
constexpr LoginScreenExtensionManifestV2AvailabilityProto_Availability LoginScreenExtensionManifestV2AvailabilityProto::Availability_MAX;
constexpr int LoginScreenExtensionManifestV2AvailabilityProto::Availability_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_strings[3] = {};

static const char DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_names[] =
  "ALLOW_MIGRATION"
  "DISALLOW_ARC"
  "UNSET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_entries[] = {
  { {DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_names + 0, 15}, 2 },
  { {DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_names + 15, 12}, 1 },
  { {DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_names + 27, 5}, 0 },
};

static const int DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_entries_by_number[] = {
  2, // 0 -> UNSET
  1, // 1 -> DISALLOW_ARC
  0, // 2 -> ALLOW_MIGRATION
};

const std::string& DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Name(
    DeviceEcryptfsMigrationStrategyProto_MigrationStrategy value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_entries,
          DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_entries_by_number,
          3, DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_entries,
      DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_strings[idx].get();
}
bool DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceEcryptfsMigrationStrategyProto_MigrationStrategy* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceEcryptfsMigrationStrategyProto_MigrationStrategy>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto::UNSET;
constexpr DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto::DISALLOW_ARC;
constexpr DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto::ALLOW_MIGRATION;
constexpr DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto::MigrationStrategy_MIN;
constexpr DeviceEcryptfsMigrationStrategyProto_MigrationStrategy DeviceEcryptfsMigrationStrategyProto::MigrationStrategy_MAX;
constexpr int DeviceEcryptfsMigrationStrategyProto::MigrationStrategy_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceSecondFactorAuthenticationProto_U2fMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceSecondFactorAuthenticationProto_U2fMode_strings[4] = {};

static const char DeviceSecondFactorAuthenticationProto_U2fMode_names[] =
  "DISABLED"
  "U2F"
  "U2F_EXTENDED"
  "UNSET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceSecondFactorAuthenticationProto_U2fMode_entries[] = {
  { {DeviceSecondFactorAuthenticationProto_U2fMode_names + 0, 8}, 1 },
  { {DeviceSecondFactorAuthenticationProto_U2fMode_names + 8, 3}, 2 },
  { {DeviceSecondFactorAuthenticationProto_U2fMode_names + 11, 12}, 3 },
  { {DeviceSecondFactorAuthenticationProto_U2fMode_names + 23, 5}, 0 },
};

static const int DeviceSecondFactorAuthenticationProto_U2fMode_entries_by_number[] = {
  3, // 0 -> UNSET
  0, // 1 -> DISABLED
  1, // 2 -> U2F
  2, // 3 -> U2F_EXTENDED
};

const std::string& DeviceSecondFactorAuthenticationProto_U2fMode_Name(
    DeviceSecondFactorAuthenticationProto_U2fMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceSecondFactorAuthenticationProto_U2fMode_entries,
          DeviceSecondFactorAuthenticationProto_U2fMode_entries_by_number,
          4, DeviceSecondFactorAuthenticationProto_U2fMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceSecondFactorAuthenticationProto_U2fMode_entries,
      DeviceSecondFactorAuthenticationProto_U2fMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceSecondFactorAuthenticationProto_U2fMode_strings[idx].get();
}
bool DeviceSecondFactorAuthenticationProto_U2fMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceSecondFactorAuthenticationProto_U2fMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceSecondFactorAuthenticationProto_U2fMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceSecondFactorAuthenticationProto_U2fMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto::UNSET;
constexpr DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto::DISABLED;
constexpr DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto::U2F;
constexpr DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto::U2F_EXTENDED;
constexpr DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto::U2fMode_MIN;
constexpr DeviceSecondFactorAuthenticationProto_U2fMode DeviceSecondFactorAuthenticationProto::U2fMode_MAX;
constexpr int DeviceSecondFactorAuthenticationProto::U2fMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WeeklyTimeProto_DayOfWeek_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WeeklyTimeProto_DayOfWeek_strings[8] = {};

static const char WeeklyTimeProto_DayOfWeek_names[] =
  "DAY_OF_WEEK_UNSPECIFIED"
  "FRIDAY"
  "MONDAY"
  "SATURDAY"
  "SUNDAY"
  "THURSDAY"
  "TUESDAY"
  "WEDNESDAY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WeeklyTimeProto_DayOfWeek_entries[] = {
  { {WeeklyTimeProto_DayOfWeek_names + 0, 23}, 0 },
  { {WeeklyTimeProto_DayOfWeek_names + 23, 6}, 5 },
  { {WeeklyTimeProto_DayOfWeek_names + 29, 6}, 1 },
  { {WeeklyTimeProto_DayOfWeek_names + 35, 8}, 6 },
  { {WeeklyTimeProto_DayOfWeek_names + 43, 6}, 7 },
  { {WeeklyTimeProto_DayOfWeek_names + 49, 8}, 4 },
  { {WeeklyTimeProto_DayOfWeek_names + 57, 7}, 2 },
  { {WeeklyTimeProto_DayOfWeek_names + 64, 9}, 3 },
};

static const int WeeklyTimeProto_DayOfWeek_entries_by_number[] = {
  0, // 0 -> DAY_OF_WEEK_UNSPECIFIED
  2, // 1 -> MONDAY
  6, // 2 -> TUESDAY
  7, // 3 -> WEDNESDAY
  5, // 4 -> THURSDAY
  1, // 5 -> FRIDAY
  3, // 6 -> SATURDAY
  4, // 7 -> SUNDAY
};

const std::string& WeeklyTimeProto_DayOfWeek_Name(
    WeeklyTimeProto_DayOfWeek value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WeeklyTimeProto_DayOfWeek_entries,
          WeeklyTimeProto_DayOfWeek_entries_by_number,
          8, WeeklyTimeProto_DayOfWeek_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WeeklyTimeProto_DayOfWeek_entries,
      WeeklyTimeProto_DayOfWeek_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WeeklyTimeProto_DayOfWeek_strings[idx].get();
}
bool WeeklyTimeProto_DayOfWeek_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeeklyTimeProto_DayOfWeek* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WeeklyTimeProto_DayOfWeek_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<WeeklyTimeProto_DayOfWeek>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::DAY_OF_WEEK_UNSPECIFIED;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::MONDAY;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::TUESDAY;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::WEDNESDAY;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::THURSDAY;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::FRIDAY;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::SATURDAY;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::SUNDAY;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::DayOfWeek_MIN;
constexpr WeeklyTimeProto_DayOfWeek WeeklyTimeProto::DayOfWeek_MAX;
constexpr int WeeklyTimeProto::DayOfWeek_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceNativePrintersAccessModeProto_AccessMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceNativePrintersAccessModeProto_AccessMode_strings[3] = {};

static const char DeviceNativePrintersAccessModeProto_AccessMode_names[] =
  "ACCESS_MODE_ALL"
  "ACCESS_MODE_BLACKLIST"
  "ACCESS_MODE_WHITELIST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceNativePrintersAccessModeProto_AccessMode_entries[] = {
  { {DeviceNativePrintersAccessModeProto_AccessMode_names + 0, 15}, 2 },
  { {DeviceNativePrintersAccessModeProto_AccessMode_names + 15, 21}, 0 },
  { {DeviceNativePrintersAccessModeProto_AccessMode_names + 36, 21}, 1 },
};

static const int DeviceNativePrintersAccessModeProto_AccessMode_entries_by_number[] = {
  1, // 0 -> ACCESS_MODE_BLACKLIST
  2, // 1 -> ACCESS_MODE_WHITELIST
  0, // 2 -> ACCESS_MODE_ALL
};

const std::string& DeviceNativePrintersAccessModeProto_AccessMode_Name(
    DeviceNativePrintersAccessModeProto_AccessMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceNativePrintersAccessModeProto_AccessMode_entries,
          DeviceNativePrintersAccessModeProto_AccessMode_entries_by_number,
          3, DeviceNativePrintersAccessModeProto_AccessMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceNativePrintersAccessModeProto_AccessMode_entries,
      DeviceNativePrintersAccessModeProto_AccessMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceNativePrintersAccessModeProto_AccessMode_strings[idx].get();
}
bool DeviceNativePrintersAccessModeProto_AccessMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceNativePrintersAccessModeProto_AccessMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceNativePrintersAccessModeProto_AccessMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceNativePrintersAccessModeProto_AccessMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto::ACCESS_MODE_BLACKLIST;
constexpr DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto::ACCESS_MODE_WHITELIST;
constexpr DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto::ACCESS_MODE_ALL;
constexpr DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto::AccessMode_MIN;
constexpr DeviceNativePrintersAccessModeProto_AccessMode DeviceNativePrintersAccessModeProto::AccessMode_MAX;
constexpr int DeviceNativePrintersAccessModeProto::AccessMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DevicePrintersAccessModeProto_AccessMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DevicePrintersAccessModeProto_AccessMode_strings[3] = {};

static const char DevicePrintersAccessModeProto_AccessMode_names[] =
  "ACCESS_MODE_ALL"
  "ACCESS_MODE_ALLOWLIST"
  "ACCESS_MODE_BLOCKLIST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DevicePrintersAccessModeProto_AccessMode_entries[] = {
  { {DevicePrintersAccessModeProto_AccessMode_names + 0, 15}, 2 },
  { {DevicePrintersAccessModeProto_AccessMode_names + 15, 21}, 1 },
  { {DevicePrintersAccessModeProto_AccessMode_names + 36, 21}, 0 },
};

static const int DevicePrintersAccessModeProto_AccessMode_entries_by_number[] = {
  2, // 0 -> ACCESS_MODE_BLOCKLIST
  1, // 1 -> ACCESS_MODE_ALLOWLIST
  0, // 2 -> ACCESS_MODE_ALL
};

const std::string& DevicePrintersAccessModeProto_AccessMode_Name(
    DevicePrintersAccessModeProto_AccessMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DevicePrintersAccessModeProto_AccessMode_entries,
          DevicePrintersAccessModeProto_AccessMode_entries_by_number,
          3, DevicePrintersAccessModeProto_AccessMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DevicePrintersAccessModeProto_AccessMode_entries,
      DevicePrintersAccessModeProto_AccessMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DevicePrintersAccessModeProto_AccessMode_strings[idx].get();
}
bool DevicePrintersAccessModeProto_AccessMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DevicePrintersAccessModeProto_AccessMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DevicePrintersAccessModeProto_AccessMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DevicePrintersAccessModeProto_AccessMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto::ACCESS_MODE_BLOCKLIST;
constexpr DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto::ACCESS_MODE_ALLOWLIST;
constexpr DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto::ACCESS_MODE_ALL;
constexpr DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto::AccessMode_MIN;
constexpr DevicePrintersAccessModeProto_AccessMode DevicePrintersAccessModeProto::AccessMode_MAX;
constexpr int DevicePrintersAccessModeProto::AccessMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TPMFirmwareUpdateSettingsProto_AutoUpdateMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TPMFirmwareUpdateSettingsProto_AutoUpdateMode_strings[5] = {};

static const char TPMFirmwareUpdateSettingsProto_AutoUpdateMode_names[] =
  "AUTO_UPDATE_MODE_UNSPECIFIED"
  "ENROLLMENT"
  "NEVER"
  "USER_ACKNOWLEDGMENT"
  "WITHOUT_ACKNOWLEDGMENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TPMFirmwareUpdateSettingsProto_AutoUpdateMode_entries[] = {
  { {TPMFirmwareUpdateSettingsProto_AutoUpdateMode_names + 0, 28}, 0 },
  { {TPMFirmwareUpdateSettingsProto_AutoUpdateMode_names + 28, 10}, 4 },
  { {TPMFirmwareUpdateSettingsProto_AutoUpdateMode_names + 38, 5}, 1 },
  { {TPMFirmwareUpdateSettingsProto_AutoUpdateMode_names + 43, 19}, 2 },
  { {TPMFirmwareUpdateSettingsProto_AutoUpdateMode_names + 62, 22}, 3 },
};

static const int TPMFirmwareUpdateSettingsProto_AutoUpdateMode_entries_by_number[] = {
  0, // 0 -> AUTO_UPDATE_MODE_UNSPECIFIED
  2, // 1 -> NEVER
  3, // 2 -> USER_ACKNOWLEDGMENT
  4, // 3 -> WITHOUT_ACKNOWLEDGMENT
  1, // 4 -> ENROLLMENT
};

const std::string& TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Name(
    TPMFirmwareUpdateSettingsProto_AutoUpdateMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TPMFirmwareUpdateSettingsProto_AutoUpdateMode_entries,
          TPMFirmwareUpdateSettingsProto_AutoUpdateMode_entries_by_number,
          5, TPMFirmwareUpdateSettingsProto_AutoUpdateMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TPMFirmwareUpdateSettingsProto_AutoUpdateMode_entries,
      TPMFirmwareUpdateSettingsProto_AutoUpdateMode_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TPMFirmwareUpdateSettingsProto_AutoUpdateMode_strings[idx].get();
}
bool TPMFirmwareUpdateSettingsProto_AutoUpdateMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TPMFirmwareUpdateSettingsProto_AutoUpdateMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TPMFirmwareUpdateSettingsProto_AutoUpdateMode_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<TPMFirmwareUpdateSettingsProto_AutoUpdateMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::AUTO_UPDATE_MODE_UNSPECIFIED;
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::NEVER;
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::USER_ACKNOWLEDGMENT;
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::WITHOUT_ACKNOWLEDGMENT;
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::ENROLLMENT;
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::AutoUpdateMode_MIN;
constexpr TPMFirmwareUpdateSettingsProto_AutoUpdateMode TPMFirmwareUpdateSettingsProto::AutoUpdateMode_MAX;
constexpr int TPMFirmwareUpdateSettingsProto::AutoUpdateMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceKerberosEncryptionTypesProto_Types_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceKerberosEncryptionTypesProto_Types_strings[3] = {};

static const char DeviceKerberosEncryptionTypesProto_Types_names[] =
  "ENC_TYPES_ALL"
  "ENC_TYPES_LEGACY"
  "ENC_TYPES_STRONG";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceKerberosEncryptionTypesProto_Types_entries[] = {
  { {DeviceKerberosEncryptionTypesProto_Types_names + 0, 13}, 0 },
  { {DeviceKerberosEncryptionTypesProto_Types_names + 13, 16}, 2 },
  { {DeviceKerberosEncryptionTypesProto_Types_names + 29, 16}, 1 },
};

static const int DeviceKerberosEncryptionTypesProto_Types_entries_by_number[] = {
  0, // 0 -> ENC_TYPES_ALL
  2, // 1 -> ENC_TYPES_STRONG
  1, // 2 -> ENC_TYPES_LEGACY
};

const std::string& DeviceKerberosEncryptionTypesProto_Types_Name(
    DeviceKerberosEncryptionTypesProto_Types value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceKerberosEncryptionTypesProto_Types_entries,
          DeviceKerberosEncryptionTypesProto_Types_entries_by_number,
          3, DeviceKerberosEncryptionTypesProto_Types_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceKerberosEncryptionTypesProto_Types_entries,
      DeviceKerberosEncryptionTypesProto_Types_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceKerberosEncryptionTypesProto_Types_strings[idx].get();
}
bool DeviceKerberosEncryptionTypesProto_Types_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceKerberosEncryptionTypesProto_Types* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceKerberosEncryptionTypesProto_Types_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceKerberosEncryptionTypesProto_Types>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto::ENC_TYPES_ALL;
constexpr DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto::ENC_TYPES_STRONG;
constexpr DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto::ENC_TYPES_LEGACY;
constexpr DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto::Types_MIN;
constexpr DeviceKerberosEncryptionTypesProto_Types DeviceKerberosEncryptionTypesProto::Types_MAX;
constexpr int DeviceKerberosEncryptionTypesProto::Types_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool KeyboardBacklightColorProto_BacklightColor_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 100:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KeyboardBacklightColorProto_BacklightColor_strings[9] = {};

static const char KeyboardBacklightColorProto_BacklightColor_names[] =
  "BACKLIGHT_BLUE"
  "BACKLIGHT_GREEN"
  "BACKLIGHT_INDIGO"
  "BACKLIGHT_PURPLE"
  "BACKLIGHT_RAINBOW"
  "BACKLIGHT_RED"
  "BACKLIGHT_UNSPECIFIED"
  "BACKLIGHT_WHITE"
  "BACKLIGHT_YELLOW";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KeyboardBacklightColorProto_BacklightColor_entries[] = {
  { {KeyboardBacklightColorProto_BacklightColor_names + 0, 14}, 5 },
  { {KeyboardBacklightColorProto_BacklightColor_names + 14, 15}, 4 },
  { {KeyboardBacklightColorProto_BacklightColor_names + 29, 16}, 6 },
  { {KeyboardBacklightColorProto_BacklightColor_names + 45, 16}, 7 },
  { {KeyboardBacklightColorProto_BacklightColor_names + 61, 17}, 100 },
  { {KeyboardBacklightColorProto_BacklightColor_names + 78, 13}, 2 },
  { {KeyboardBacklightColorProto_BacklightColor_names + 91, 21}, 0 },
  { {KeyboardBacklightColorProto_BacklightColor_names + 112, 15}, 1 },
  { {KeyboardBacklightColorProto_BacklightColor_names + 127, 16}, 3 },
};

static const int KeyboardBacklightColorProto_BacklightColor_entries_by_number[] = {
  6, // 0 -> BACKLIGHT_UNSPECIFIED
  7, // 1 -> BACKLIGHT_WHITE
  5, // 2 -> BACKLIGHT_RED
  8, // 3 -> BACKLIGHT_YELLOW
  1, // 4 -> BACKLIGHT_GREEN
  0, // 5 -> BACKLIGHT_BLUE
  2, // 6 -> BACKLIGHT_INDIGO
  3, // 7 -> BACKLIGHT_PURPLE
  4, // 100 -> BACKLIGHT_RAINBOW
};

const std::string& KeyboardBacklightColorProto_BacklightColor_Name(
    KeyboardBacklightColorProto_BacklightColor value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KeyboardBacklightColorProto_BacklightColor_entries,
          KeyboardBacklightColorProto_BacklightColor_entries_by_number,
          9, KeyboardBacklightColorProto_BacklightColor_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KeyboardBacklightColorProto_BacklightColor_entries,
      KeyboardBacklightColorProto_BacklightColor_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KeyboardBacklightColorProto_BacklightColor_strings[idx].get();
}
bool KeyboardBacklightColorProto_BacklightColor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyboardBacklightColorProto_BacklightColor* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KeyboardBacklightColorProto_BacklightColor_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<KeyboardBacklightColorProto_BacklightColor>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_UNSPECIFIED;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_WHITE;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_RED;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_YELLOW;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_GREEN;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_BLUE;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_INDIGO;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_PURPLE;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BACKLIGHT_RAINBOW;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BacklightColor_MIN;
constexpr KeyboardBacklightColorProto_BacklightColor KeyboardBacklightColorProto::BacklightColor_MAX;
constexpr int KeyboardBacklightColorProto::BacklightColor_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceUserPolicyLoopbackProcessingModeProto_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceUserPolicyLoopbackProcessingModeProto_Mode_strings[3] = {};

static const char DeviceUserPolicyLoopbackProcessingModeProto_Mode_names[] =
  "USER_POLICY_MODE_DEFAULT"
  "USER_POLICY_MODE_MERGE"
  "USER_POLICY_MODE_REPLACE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceUserPolicyLoopbackProcessingModeProto_Mode_entries[] = {
  { {DeviceUserPolicyLoopbackProcessingModeProto_Mode_names + 0, 24}, 0 },
  { {DeviceUserPolicyLoopbackProcessingModeProto_Mode_names + 24, 22}, 1 },
  { {DeviceUserPolicyLoopbackProcessingModeProto_Mode_names + 46, 24}, 2 },
};

static const int DeviceUserPolicyLoopbackProcessingModeProto_Mode_entries_by_number[] = {
  0, // 0 -> USER_POLICY_MODE_DEFAULT
  1, // 1 -> USER_POLICY_MODE_MERGE
  2, // 2 -> USER_POLICY_MODE_REPLACE
};

const std::string& DeviceUserPolicyLoopbackProcessingModeProto_Mode_Name(
    DeviceUserPolicyLoopbackProcessingModeProto_Mode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceUserPolicyLoopbackProcessingModeProto_Mode_entries,
          DeviceUserPolicyLoopbackProcessingModeProto_Mode_entries_by_number,
          3, DeviceUserPolicyLoopbackProcessingModeProto_Mode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceUserPolicyLoopbackProcessingModeProto_Mode_entries,
      DeviceUserPolicyLoopbackProcessingModeProto_Mode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceUserPolicyLoopbackProcessingModeProto_Mode_strings[idx].get();
}
bool DeviceUserPolicyLoopbackProcessingModeProto_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceUserPolicyLoopbackProcessingModeProto_Mode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceUserPolicyLoopbackProcessingModeProto_Mode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceUserPolicyLoopbackProcessingModeProto_Mode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto::USER_POLICY_MODE_DEFAULT;
constexpr DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto::USER_POLICY_MODE_MERGE;
constexpr DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto::USER_POLICY_MODE_REPLACE;
constexpr DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto::Mode_MIN;
constexpr DeviceUserPolicyLoopbackProcessingModeProto_Mode DeviceUserPolicyLoopbackProcessingModeProto::Mode_MAX;
constexpr int DeviceUserPolicyLoopbackProcessingModeProto::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_strings[5] = {};

static const char DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_names[] =
  "ALWAYS"
  "ARC_SESSION"
  "NEVER"
  "REBOOT_ON_SIGNOUT_MODE_UNSPECIFIED"
  "VM_STARTED_OR_ARC_SESSION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_entries[] = {
  { {DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_names + 0, 6}, 3 },
  { {DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_names + 6, 11}, 2 },
  { {DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_names + 17, 5}, 1 },
  { {DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_names + 22, 34}, 0 },
  { {DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_names + 56, 25}, 4 },
};

static const int DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_entries_by_number[] = {
  3, // 0 -> REBOOT_ON_SIGNOUT_MODE_UNSPECIFIED
  2, // 1 -> NEVER
  1, // 2 -> ARC_SESSION
  0, // 3 -> ALWAYS
  4, // 4 -> VM_STARTED_OR_ARC_SESSION
};

const std::string& DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Name(
    DeviceRebootOnUserSignoutProto_RebootOnSignoutMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_entries,
          DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_entries_by_number,
          5, DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_entries,
      DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_strings[idx].get();
}
bool DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRebootOnUserSignoutProto_RebootOnSignoutMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<DeviceRebootOnUserSignoutProto_RebootOnSignoutMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::REBOOT_ON_SIGNOUT_MODE_UNSPECIFIED;
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::NEVER;
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::ARC_SESSION;
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::ALWAYS;
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::VM_STARTED_OR_ARC_SESSION;
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::RebootOnSignoutMode_MIN;
constexpr DeviceRebootOnUserSignoutProto_RebootOnSignoutMode DeviceRebootOnUserSignoutProto::RebootOnSignoutMode_MAX;
constexpr int DeviceRebootOnUserSignoutProto::RebootOnSignoutMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceDockMacAddressSourceProto_Source_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceDockMacAddressSourceProto_Source_strings[4] = {};

static const char DeviceDockMacAddressSourceProto_Source_names[] =
  "DEVICE_DOCK_MAC_ADDRESS"
  "DEVICE_NIC_MAC_ADDRESS"
  "DOCK_NIC_MAC_ADDRESS"
  "SOURCE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceDockMacAddressSourceProto_Source_entries[] = {
  { {DeviceDockMacAddressSourceProto_Source_names + 0, 23}, 1 },
  { {DeviceDockMacAddressSourceProto_Source_names + 23, 22}, 2 },
  { {DeviceDockMacAddressSourceProto_Source_names + 45, 20}, 3 },
  { {DeviceDockMacAddressSourceProto_Source_names + 65, 18}, 0 },
};

static const int DeviceDockMacAddressSourceProto_Source_entries_by_number[] = {
  3, // 0 -> SOURCE_UNSPECIFIED
  0, // 1 -> DEVICE_DOCK_MAC_ADDRESS
  1, // 2 -> DEVICE_NIC_MAC_ADDRESS
  2, // 3 -> DOCK_NIC_MAC_ADDRESS
};

const std::string& DeviceDockMacAddressSourceProto_Source_Name(
    DeviceDockMacAddressSourceProto_Source value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceDockMacAddressSourceProto_Source_entries,
          DeviceDockMacAddressSourceProto_Source_entries_by_number,
          4, DeviceDockMacAddressSourceProto_Source_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceDockMacAddressSourceProto_Source_entries,
      DeviceDockMacAddressSourceProto_Source_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceDockMacAddressSourceProto_Source_strings[idx].get();
}
bool DeviceDockMacAddressSourceProto_Source_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceDockMacAddressSourceProto_Source* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceDockMacAddressSourceProto_Source_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceDockMacAddressSourceProto_Source>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto::SOURCE_UNSPECIFIED;
constexpr DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto::DEVICE_DOCK_MAC_ADDRESS;
constexpr DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto::DEVICE_NIC_MAC_ADDRESS;
constexpr DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto::DOCK_NIC_MAC_ADDRESS;
constexpr DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto::Source_MIN;
constexpr DeviceDockMacAddressSourceProto_Source DeviceDockMacAddressSourceProto::Source_MAX;
constexpr int DeviceDockMacAddressSourceProto::Source_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceBatteryChargeModeProto_BatteryChargeMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceBatteryChargeModeProto_BatteryChargeMode_strings[6] = {};

static const char DeviceBatteryChargeModeProto_BatteryChargeMode_names[] =
  "ADAPTIVE"
  "CUSTOM"
  "EXPRESS_CHARGE"
  "MODE_UNSPECIFIED"
  "PRIMARILY_AC_USE"
  "STANDARD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceBatteryChargeModeProto_BatteryChargeMode_entries[] = {
  { {DeviceBatteryChargeModeProto_BatteryChargeMode_names + 0, 8}, 4 },
  { {DeviceBatteryChargeModeProto_BatteryChargeMode_names + 8, 6}, 5 },
  { {DeviceBatteryChargeModeProto_BatteryChargeMode_names + 14, 14}, 2 },
  { {DeviceBatteryChargeModeProto_BatteryChargeMode_names + 28, 16}, 0 },
  { {DeviceBatteryChargeModeProto_BatteryChargeMode_names + 44, 16}, 3 },
  { {DeviceBatteryChargeModeProto_BatteryChargeMode_names + 60, 8}, 1 },
};

static const int DeviceBatteryChargeModeProto_BatteryChargeMode_entries_by_number[] = {
  3, // 0 -> MODE_UNSPECIFIED
  5, // 1 -> STANDARD
  2, // 2 -> EXPRESS_CHARGE
  4, // 3 -> PRIMARILY_AC_USE
  0, // 4 -> ADAPTIVE
  1, // 5 -> CUSTOM
};

const std::string& DeviceBatteryChargeModeProto_BatteryChargeMode_Name(
    DeviceBatteryChargeModeProto_BatteryChargeMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceBatteryChargeModeProto_BatteryChargeMode_entries,
          DeviceBatteryChargeModeProto_BatteryChargeMode_entries_by_number,
          6, DeviceBatteryChargeModeProto_BatteryChargeMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceBatteryChargeModeProto_BatteryChargeMode_entries,
      DeviceBatteryChargeModeProto_BatteryChargeMode_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceBatteryChargeModeProto_BatteryChargeMode_strings[idx].get();
}
bool DeviceBatteryChargeModeProto_BatteryChargeMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceBatteryChargeModeProto_BatteryChargeMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceBatteryChargeModeProto_BatteryChargeMode_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<DeviceBatteryChargeModeProto_BatteryChargeMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::MODE_UNSPECIFIED;
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::STANDARD;
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::EXPRESS_CHARGE;
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::PRIMARILY_AC_USE;
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::ADAPTIVE;
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::CUSTOM;
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::BatteryChargeMode_MIN;
constexpr DeviceBatteryChargeModeProto_BatteryChargeMode DeviceBatteryChargeModeProto::BatteryChargeMode_MAX;
constexpr int DeviceBatteryChargeModeProto::BatteryChargeMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_strings[3] = {};

static const char DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_names[] =
  "ALLOW_FOR_AFFILIATED_USERS"
  "DISALLOW"
  "DISALLOW_WITH_POWERWASH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_entries[] = {
  { {DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_names + 0, 26}, 2 },
  { {DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_names + 26, 8}, 0 },
  { {DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_names + 34, 23}, 1 },
};

static const int DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_entries_by_number[] = {
  1, // 0 -> DISALLOW
  2, // 1 -> DISALLOW_WITH_POWERWASH
  0, // 2 -> ALLOW_FOR_AFFILIATED_USERS
};

const std::string& DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Name(
    DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_entries,
          DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_entries_by_number,
          3, DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_entries,
      DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_strings[idx].get();
}
bool DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto::DISALLOW;
constexpr DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto::DISALLOW_WITH_POWERWASH;
constexpr DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto::ALLOW_FOR_AFFILIATED_USERS;
constexpr DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto::AllowanceMode_MIN;
constexpr DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode DeviceCrostiniArcAdbSideloadingAllowedProto::AllowanceMode_MAX;
constexpr int DeviceCrostiniArcAdbSideloadingAllowedProto::AllowanceMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class DevicePolicyRefreshRateProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePolicyRefreshRateProto>()._impl_._has_bits_);
  static void set_has_device_policy_refresh_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DevicePolicyRefreshRateProto::DevicePolicyRefreshRateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePolicyRefreshRateProto)
}
DevicePolicyRefreshRateProto::DevicePolicyRefreshRateProto(const DevicePolicyRefreshRateProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePolicyRefreshRateProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_policy_refresh_rate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_policy_refresh_rate_ = from._impl_.device_policy_refresh_rate_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePolicyRefreshRateProto)
}

inline void DevicePolicyRefreshRateProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_policy_refresh_rate_){int64_t{0}}
  };
}

DevicePolicyRefreshRateProto::~DevicePolicyRefreshRateProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePolicyRefreshRateProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePolicyRefreshRateProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DevicePolicyRefreshRateProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePolicyRefreshRateProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePolicyRefreshRateProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_policy_refresh_rate_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePolicyRefreshRateProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 device_policy_refresh_rate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_policy_refresh_rate(&has_bits);
          _impl_.device_policy_refresh_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePolicyRefreshRateProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePolicyRefreshRateProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 device_policy_refresh_rate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_device_policy_refresh_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePolicyRefreshRateProto)
  return target;
}

size_t DevicePolicyRefreshRateProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePolicyRefreshRateProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 device_policy_refresh_rate = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_device_policy_refresh_rate());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePolicyRefreshRateProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePolicyRefreshRateProto*>(
      &from));
}

void DevicePolicyRefreshRateProto::MergeFrom(const DevicePolicyRefreshRateProto& from) {
  DevicePolicyRefreshRateProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePolicyRefreshRateProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_policy_refresh_rate()) {
    _this->_internal_set_device_policy_refresh_rate(from._internal_device_policy_refresh_rate());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePolicyRefreshRateProto::CopyFrom(const DevicePolicyRefreshRateProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePolicyRefreshRateProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePolicyRefreshRateProto::IsInitialized() const {
  return true;
}

void DevicePolicyRefreshRateProto::InternalSwap(DevicePolicyRefreshRateProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_policy_refresh_rate_, other->_impl_.device_policy_refresh_rate_);
}

std::string DevicePolicyRefreshRateProto::GetTypeName() const {
  return "enterprise_management.DevicePolicyRefreshRateProto";
}


// ===================================================================

class UserWhitelistProto::_Internal {
 public:
};

UserWhitelistProto::UserWhitelistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UserWhitelistProto)
}
UserWhitelistProto::UserWhitelistProto(const UserWhitelistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserWhitelistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_whitelist_){from._impl_.user_whitelist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UserWhitelistProto)
}

inline void UserWhitelistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_whitelist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UserWhitelistProto::~UserWhitelistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.UserWhitelistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserWhitelistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_whitelist_.~RepeatedPtrField();
}

void UserWhitelistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserWhitelistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UserWhitelistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_whitelist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserWhitelistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string user_whitelist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_user_whitelist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserWhitelistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UserWhitelistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string user_whitelist = 1;
  for (int i = 0, n = this->_internal_user_whitelist_size(); i < n; i++) {
    const auto& s = this->_internal_user_whitelist(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UserWhitelistProto)
  return target;
}

size_t UserWhitelistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UserWhitelistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string user_whitelist = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.user_whitelist_.size());
  for (int i = 0, n = _impl_.user_whitelist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.user_whitelist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserWhitelistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserWhitelistProto*>(
      &from));
}

void UserWhitelistProto::MergeFrom(const UserWhitelistProto& from) {
  UserWhitelistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UserWhitelistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_whitelist_.MergeFrom(from._impl_.user_whitelist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserWhitelistProto::CopyFrom(const UserWhitelistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UserWhitelistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserWhitelistProto::IsInitialized() const {
  return true;
}

void UserWhitelistProto::InternalSwap(UserWhitelistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.user_whitelist_.InternalSwap(&other->_impl_.user_whitelist_);
}

std::string UserWhitelistProto::GetTypeName() const {
  return "enterprise_management.UserWhitelistProto";
}


// ===================================================================

class UserAllowlistProto::_Internal {
 public:
};

UserAllowlistProto::UserAllowlistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UserAllowlistProto)
}
UserAllowlistProto::UserAllowlistProto(const UserAllowlistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserAllowlistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_allowlist_){from._impl_.user_allowlist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UserAllowlistProto)
}

inline void UserAllowlistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_allowlist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UserAllowlistProto::~UserAllowlistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.UserAllowlistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserAllowlistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_allowlist_.~RepeatedPtrField();
}

void UserAllowlistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserAllowlistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UserAllowlistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_allowlist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserAllowlistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string user_allowlist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_user_allowlist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserAllowlistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UserAllowlistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string user_allowlist = 1;
  for (int i = 0, n = this->_internal_user_allowlist_size(); i < n; i++) {
    const auto& s = this->_internal_user_allowlist(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UserAllowlistProto)
  return target;
}

size_t UserAllowlistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UserAllowlistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string user_allowlist = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.user_allowlist_.size());
  for (int i = 0, n = _impl_.user_allowlist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.user_allowlist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserAllowlistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserAllowlistProto*>(
      &from));
}

void UserAllowlistProto::MergeFrom(const UserAllowlistProto& from) {
  UserAllowlistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UserAllowlistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_allowlist_.MergeFrom(from._impl_.user_allowlist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserAllowlistProto::CopyFrom(const UserAllowlistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UserAllowlistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserAllowlistProto::IsInitialized() const {
  return true;
}

void UserAllowlistProto::InternalSwap(UserAllowlistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.user_allowlist_.InternalSwap(&other->_impl_.user_allowlist_);
}

std::string UserAllowlistProto::GetTypeName() const {
  return "enterprise_management.UserAllowlistProto";
}


// ===================================================================

class AllowNewUsersProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AllowNewUsersProto>()._impl_._has_bits_);
  static void set_has_allow_new_users(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AllowNewUsersProto::AllowNewUsersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AllowNewUsersProto)
}
AllowNewUsersProto::AllowNewUsersProto(const AllowNewUsersProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllowNewUsersProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_new_users_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.allow_new_users_ = from._impl_.allow_new_users_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AllowNewUsersProto)
}

inline void AllowNewUsersProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_new_users_){true}
  };
}

AllowNewUsersProto::~AllowNewUsersProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AllowNewUsersProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllowNewUsersProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllowNewUsersProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllowNewUsersProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AllowNewUsersProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allow_new_users_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllowNewUsersProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allow_new_users = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allow_new_users(&has_bits);
          _impl_.allow_new_users_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllowNewUsersProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AllowNewUsersProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool allow_new_users = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allow_new_users(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AllowNewUsersProto)
  return target;
}

size_t AllowNewUsersProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AllowNewUsersProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool allow_new_users = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllowNewUsersProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllowNewUsersProto*>(
      &from));
}

void AllowNewUsersProto::MergeFrom(const AllowNewUsersProto& from) {
  AllowNewUsersProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AllowNewUsersProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_allow_new_users()) {
    _this->_internal_set_allow_new_users(from._internal_allow_new_users());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllowNewUsersProto::CopyFrom(const AllowNewUsersProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AllowNewUsersProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllowNewUsersProto::IsInitialized() const {
  return true;
}

void AllowNewUsersProto::InternalSwap(AllowNewUsersProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.allow_new_users_, other->_impl_.allow_new_users_);
}

std::string AllowNewUsersProto::GetTypeName() const {
  return "enterprise_management.AllowNewUsersProto";
}


// ===================================================================

class GuestModeEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GuestModeEnabledProto>()._impl_._has_bits_);
  static void set_has_guest_mode_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GuestModeEnabledProto::GuestModeEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.GuestModeEnabledProto)
}
GuestModeEnabledProto::GuestModeEnabledProto(const GuestModeEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GuestModeEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guest_mode_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.guest_mode_enabled_ = from._impl_.guest_mode_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.GuestModeEnabledProto)
}

inline void GuestModeEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guest_mode_enabled_){true}
  };
}

GuestModeEnabledProto::~GuestModeEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.GuestModeEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuestModeEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GuestModeEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuestModeEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.GuestModeEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.guest_mode_enabled_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GuestModeEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool guest_mode_enabled = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_mode_enabled(&has_bits);
          _impl_.guest_mode_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuestModeEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.GuestModeEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool guest_mode_enabled = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_guest_mode_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.GuestModeEnabledProto)
  return target;
}

size_t GuestModeEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.GuestModeEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool guest_mode_enabled = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GuestModeEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GuestModeEnabledProto*>(
      &from));
}

void GuestModeEnabledProto::MergeFrom(const GuestModeEnabledProto& from) {
  GuestModeEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.GuestModeEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_guest_mode_enabled()) {
    _this->_internal_set_guest_mode_enabled(from._internal_guest_mode_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GuestModeEnabledProto::CopyFrom(const GuestModeEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.GuestModeEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuestModeEnabledProto::IsInitialized() const {
  return true;
}

void GuestModeEnabledProto::InternalSwap(GuestModeEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.guest_mode_enabled_, other->_impl_.guest_mode_enabled_);
}

std::string GuestModeEnabledProto::GetTypeName() const {
  return "enterprise_management.GuestModeEnabledProto";
}


// ===================================================================

class ShowUserNamesOnSigninProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowUserNamesOnSigninProto>()._impl_._has_bits_);
  static void set_has_show_user_names(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ShowUserNamesOnSigninProto::ShowUserNamesOnSigninProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ShowUserNamesOnSigninProto)
}
ShowUserNamesOnSigninProto::ShowUserNamesOnSigninProto(const ShowUserNamesOnSigninProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ShowUserNamesOnSigninProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.show_user_names_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.show_user_names_ = from._impl_.show_user_names_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ShowUserNamesOnSigninProto)
}

inline void ShowUserNamesOnSigninProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.show_user_names_){true}
  };
}

ShowUserNamesOnSigninProto::~ShowUserNamesOnSigninProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.ShowUserNamesOnSigninProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowUserNamesOnSigninProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShowUserNamesOnSigninProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShowUserNamesOnSigninProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ShowUserNamesOnSigninProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.show_user_names_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowUserNamesOnSigninProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool show_user_names = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_show_user_names(&has_bits);
          _impl_.show_user_names_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowUserNamesOnSigninProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ShowUserNamesOnSigninProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool show_user_names = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_show_user_names(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ShowUserNamesOnSigninProto)
  return target;
}

size_t ShowUserNamesOnSigninProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ShowUserNamesOnSigninProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool show_user_names = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowUserNamesOnSigninProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowUserNamesOnSigninProto*>(
      &from));
}

void ShowUserNamesOnSigninProto::MergeFrom(const ShowUserNamesOnSigninProto& from) {
  ShowUserNamesOnSigninProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ShowUserNamesOnSigninProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_show_user_names()) {
    _this->_internal_set_show_user_names(from._internal_show_user_names());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowUserNamesOnSigninProto::CopyFrom(const ShowUserNamesOnSigninProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ShowUserNamesOnSigninProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowUserNamesOnSigninProto::IsInitialized() const {
  return true;
}

void ShowUserNamesOnSigninProto::InternalSwap(ShowUserNamesOnSigninProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.show_user_names_, other->_impl_.show_user_names_);
}

std::string ShowUserNamesOnSigninProto::GetTypeName() const {
  return "enterprise_management.ShowUserNamesOnSigninProto";
}


// ===================================================================

class DataRoamingEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DataRoamingEnabledProto>()._impl_._has_bits_);
  static void set_has_data_roaming_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DataRoamingEnabledProto::DataRoamingEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DataRoamingEnabledProto)
}
DataRoamingEnabledProto::DataRoamingEnabledProto(const DataRoamingEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DataRoamingEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_roaming_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.data_roaming_enabled_ = from._impl_.data_roaming_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DataRoamingEnabledProto)
}

inline void DataRoamingEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_roaming_enabled_){false}
  };
}

DataRoamingEnabledProto::~DataRoamingEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DataRoamingEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataRoamingEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DataRoamingEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataRoamingEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DataRoamingEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_roaming_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataRoamingEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool data_roaming_enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_data_roaming_enabled(&has_bits);
          _impl_.data_roaming_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataRoamingEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DataRoamingEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool data_roaming_enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_data_roaming_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DataRoamingEnabledProto)
  return target;
}

size_t DataRoamingEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DataRoamingEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool data_roaming_enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataRoamingEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataRoamingEnabledProto*>(
      &from));
}

void DataRoamingEnabledProto::MergeFrom(const DataRoamingEnabledProto& from) {
  DataRoamingEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DataRoamingEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_data_roaming_enabled()) {
    _this->_internal_set_data_roaming_enabled(from._internal_data_roaming_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataRoamingEnabledProto::CopyFrom(const DataRoamingEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DataRoamingEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataRoamingEnabledProto::IsInitialized() const {
  return true;
}

void DataRoamingEnabledProto::InternalSwap(DataRoamingEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.data_roaming_enabled_, other->_impl_.data_roaming_enabled_);
}

std::string DataRoamingEnabledProto::GetTypeName() const {
  return "enterprise_management.DataRoamingEnabledProto";
}


// ===================================================================

class OBSOLETE_DeviceProxySettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_DeviceProxySettingsProto>()._impl_._has_bits_);
  static void set_has_obsolete_proxy_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_obsolete_proxy_server(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_obsolete_proxy_pac_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_obsolete_proxy_bypass_list(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

OBSOLETE_DeviceProxySettingsProto::OBSOLETE_DeviceProxySettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
}
OBSOLETE_DeviceProxySettingsProto::OBSOLETE_DeviceProxySettingsProto(const OBSOLETE_DeviceProxySettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_DeviceProxySettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_proxy_mode_){}
    , decltype(_impl_.obsolete_proxy_server_){}
    , decltype(_impl_.obsolete_proxy_pac_url_){}
    , decltype(_impl_.obsolete_proxy_bypass_list_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.obsolete_proxy_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_proxy_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_proxy_mode()) {
    _this->_impl_.obsolete_proxy_mode_.Set(from._internal_obsolete_proxy_mode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.obsolete_proxy_server_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_proxy_server_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_proxy_server()) {
    _this->_impl_.obsolete_proxy_server_.Set(from._internal_obsolete_proxy_server(), 
      _this->GetArenaForAllocation());
  }
  _impl_.obsolete_proxy_pac_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_proxy_pac_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_proxy_pac_url()) {
    _this->_impl_.obsolete_proxy_pac_url_.Set(from._internal_obsolete_proxy_pac_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.obsolete_proxy_bypass_list_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_proxy_bypass_list_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_proxy_bypass_list()) {
    _this->_impl_.obsolete_proxy_bypass_list_.Set(from._internal_obsolete_proxy_bypass_list(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
}

inline void OBSOLETE_DeviceProxySettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_proxy_mode_){}
    , decltype(_impl_.obsolete_proxy_server_){}
    , decltype(_impl_.obsolete_proxy_pac_url_){}
    , decltype(_impl_.obsolete_proxy_bypass_list_){}
  };
  _impl_.obsolete_proxy_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_proxy_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.obsolete_proxy_server_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_proxy_server_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.obsolete_proxy_pac_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_proxy_pac_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.obsolete_proxy_bypass_list_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_proxy_bypass_list_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OBSOLETE_DeviceProxySettingsProto::~OBSOLETE_DeviceProxySettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_DeviceProxySettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_proxy_mode_.Destroy();
  _impl_.obsolete_proxy_server_.Destroy();
  _impl_.obsolete_proxy_pac_url_.Destroy();
  _impl_.obsolete_proxy_bypass_list_.Destroy();
}

void OBSOLETE_DeviceProxySettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_DeviceProxySettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.obsolete_proxy_mode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.obsolete_proxy_server_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.obsolete_proxy_pac_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.obsolete_proxy_bypass_list_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_DeviceProxySettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string OBSOLETE_proxy_mode = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_obsolete_proxy_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string OBSOLETE_proxy_server = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_obsolete_proxy_server();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string OBSOLETE_proxy_pac_url = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_obsolete_proxy_pac_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string OBSOLETE_proxy_bypass_list = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_obsolete_proxy_bypass_list();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_DeviceProxySettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string OBSOLETE_proxy_mode = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_obsolete_proxy_mode(), target);
  }

  // optional string OBSOLETE_proxy_server = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_obsolete_proxy_server(), target);
  }

  // optional string OBSOLETE_proxy_pac_url = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_obsolete_proxy_pac_url(), target);
  }

  // optional string OBSOLETE_proxy_bypass_list = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_obsolete_proxy_bypass_list(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
  return target;
}

size_t OBSOLETE_DeviceProxySettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string OBSOLETE_proxy_mode = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_proxy_mode());
    }

    // optional string OBSOLETE_proxy_server = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_proxy_server());
    }

    // optional string OBSOLETE_proxy_pac_url = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_proxy_pac_url());
    }

    // optional string OBSOLETE_proxy_bypass_list = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_proxy_bypass_list());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_DeviceProxySettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_DeviceProxySettingsProto*>(
      &from));
}

void OBSOLETE_DeviceProxySettingsProto::MergeFrom(const OBSOLETE_DeviceProxySettingsProto& from) {
  OBSOLETE_DeviceProxySettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_obsolete_proxy_mode(from._internal_obsolete_proxy_mode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_obsolete_proxy_server(from._internal_obsolete_proxy_server());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_obsolete_proxy_pac_url(from._internal_obsolete_proxy_pac_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_obsolete_proxy_bypass_list(from._internal_obsolete_proxy_bypass_list());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_DeviceProxySettingsProto::CopyFrom(const OBSOLETE_DeviceProxySettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_DeviceProxySettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_DeviceProxySettingsProto::IsInitialized() const {
  return true;
}

void OBSOLETE_DeviceProxySettingsProto::InternalSwap(OBSOLETE_DeviceProxySettingsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_proxy_mode_, lhs_arena,
      &other->_impl_.obsolete_proxy_mode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_proxy_server_, lhs_arena,
      &other->_impl_.obsolete_proxy_server_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_proxy_pac_url_, lhs_arena,
      &other->_impl_.obsolete_proxy_pac_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_proxy_bypass_list_, lhs_arena,
      &other->_impl_.obsolete_proxy_bypass_list_, rhs_arena
  );
}

std::string OBSOLETE_DeviceProxySettingsProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_DeviceProxySettingsProto";
}


// ===================================================================

class CameraEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraEnabledProto>()._impl_._has_bits_);
  static void set_has_camera_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CameraEnabledProto::CameraEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CameraEnabledProto)
}
CameraEnabledProto::CameraEnabledProto(const CameraEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CameraEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.camera_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.camera_enabled_ = from._impl_.camera_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CameraEnabledProto)
}

inline void CameraEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.camera_enabled_){false}
  };
}

CameraEnabledProto::~CameraEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.CameraEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CameraEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CameraEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CameraEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CameraEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.camera_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CameraEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool camera_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_camera_enabled(&has_bits);
          _impl_.camera_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CameraEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CameraEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool camera_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_camera_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CameraEnabledProto)
  return target;
}

size_t CameraEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CameraEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool camera_enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CameraEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CameraEnabledProto*>(
      &from));
}

void CameraEnabledProto::MergeFrom(const CameraEnabledProto& from) {
  CameraEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CameraEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_camera_enabled()) {
    _this->_internal_set_camera_enabled(from._internal_camera_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CameraEnabledProto::CopyFrom(const CameraEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CameraEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraEnabledProto::IsInitialized() const {
  return true;
}

void CameraEnabledProto::InternalSwap(CameraEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.camera_enabled_, other->_impl_.camera_enabled_);
}

std::string CameraEnabledProto::GetTypeName() const {
  return "enterprise_management.CameraEnabledProto";
}


// ===================================================================

class MetricsEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<MetricsEnabledProto>()._impl_._has_bits_);
  static void set_has_metrics_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MetricsEnabledProto::MetricsEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.MetricsEnabledProto)
}
MetricsEnabledProto::MetricsEnabledProto(const MetricsEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MetricsEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metrics_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.metrics_enabled_ = from._impl_.metrics_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.MetricsEnabledProto)
}

inline void MetricsEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metrics_enabled_){false}
  };
}

MetricsEnabledProto::~MetricsEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.MetricsEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MetricsEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MetricsEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MetricsEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.MetricsEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metrics_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MetricsEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool metrics_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_metrics_enabled(&has_bits);
          _impl_.metrics_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MetricsEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.MetricsEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool metrics_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_metrics_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.MetricsEnabledProto)
  return target;
}

size_t MetricsEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.MetricsEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool metrics_enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MetricsEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MetricsEnabledProto*>(
      &from));
}

void MetricsEnabledProto::MergeFrom(const MetricsEnabledProto& from) {
  MetricsEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.MetricsEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_metrics_enabled()) {
    _this->_internal_set_metrics_enabled(from._internal_metrics_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MetricsEnabledProto::CopyFrom(const MetricsEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.MetricsEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MetricsEnabledProto::IsInitialized() const {
  return true;
}

void MetricsEnabledProto::InternalSwap(MetricsEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.metrics_enabled_, other->_impl_.metrics_enabled_);
}

std::string MetricsEnabledProto::GetTypeName() const {
  return "enterprise_management.MetricsEnabledProto";
}


// ===================================================================

class ReleaseChannelProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ReleaseChannelProto>()._impl_._has_bits_);
  static void set_has_release_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_release_channel_delegated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_release_lts_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReleaseChannelProto::ReleaseChannelProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ReleaseChannelProto)
}
ReleaseChannelProto::ReleaseChannelProto(const ReleaseChannelProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ReleaseChannelProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.release_channel_){}
    , decltype(_impl_.release_lts_tag_){}
    , decltype(_impl_.release_channel_delegated_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.release_channel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.release_channel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_release_channel()) {
    _this->_impl_.release_channel_.Set(from._internal_release_channel(), 
      _this->GetArenaForAllocation());
  }
  _impl_.release_lts_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.release_lts_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_release_lts_tag()) {
    _this->_impl_.release_lts_tag_.Set(from._internal_release_lts_tag(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.release_channel_delegated_ = from._impl_.release_channel_delegated_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ReleaseChannelProto)
}

inline void ReleaseChannelProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.release_channel_){}
    , decltype(_impl_.release_lts_tag_){}
    , decltype(_impl_.release_channel_delegated_){false}
  };
  _impl_.release_channel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.release_channel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.release_lts_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.release_lts_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReleaseChannelProto::~ReleaseChannelProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.ReleaseChannelProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReleaseChannelProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.release_channel_.Destroy();
  _impl_.release_lts_tag_.Destroy();
}

void ReleaseChannelProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReleaseChannelProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ReleaseChannelProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.release_channel_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.release_lts_tag_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.release_channel_delegated_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReleaseChannelProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string release_channel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_release_channel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool release_channel_delegated = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_release_channel_delegated(&has_bits);
          _impl_.release_channel_delegated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string release_lts_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_release_lts_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReleaseChannelProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ReleaseChannelProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string release_channel = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_release_channel(), target);
  }

  // optional bool release_channel_delegated = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_release_channel_delegated(), target);
  }

  // optional string release_lts_tag = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_release_lts_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ReleaseChannelProto)
  return target;
}

size_t ReleaseChannelProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ReleaseChannelProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string release_channel = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_release_channel());
    }

    // optional string release_lts_tag = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_release_lts_tag());
    }

    // optional bool release_channel_delegated = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReleaseChannelProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ReleaseChannelProto*>(
      &from));
}

void ReleaseChannelProto::MergeFrom(const ReleaseChannelProto& from) {
  ReleaseChannelProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ReleaseChannelProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_release_channel(from._internal_release_channel());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_release_lts_tag(from._internal_release_lts_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.release_channel_delegated_ = from._impl_.release_channel_delegated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReleaseChannelProto::CopyFrom(const ReleaseChannelProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ReleaseChannelProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReleaseChannelProto::IsInitialized() const {
  return true;
}

void ReleaseChannelProto::InternalSwap(ReleaseChannelProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.release_channel_, lhs_arena,
      &other->_impl_.release_channel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.release_lts_tag_, lhs_arena,
      &other->_impl_.release_lts_tag_, rhs_arena
  );
  swap(_impl_.release_channel_delegated_, other->_impl_.release_channel_delegated_);
}

std::string ReleaseChannelProto::GetTypeName() const {
  return "enterprise_management.ReleaseChannelProto";
}


// ===================================================================

class DeviceOpenNetworkConfigurationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceOpenNetworkConfigurationProto>()._impl_._has_bits_);
  static void set_has_open_network_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceOpenNetworkConfigurationProto::DeviceOpenNetworkConfigurationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceOpenNetworkConfigurationProto)
}
DeviceOpenNetworkConfigurationProto::DeviceOpenNetworkConfigurationProto(const DeviceOpenNetworkConfigurationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceOpenNetworkConfigurationProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.open_network_configuration_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.open_network_configuration_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.open_network_configuration_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_open_network_configuration()) {
    _this->_impl_.open_network_configuration_.Set(from._internal_open_network_configuration(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceOpenNetworkConfigurationProto)
}

inline void DeviceOpenNetworkConfigurationProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.open_network_configuration_){}
  };
  _impl_.open_network_configuration_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.open_network_configuration_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceOpenNetworkConfigurationProto::~DeviceOpenNetworkConfigurationProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceOpenNetworkConfigurationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceOpenNetworkConfigurationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.open_network_configuration_.Destroy();
}

void DeviceOpenNetworkConfigurationProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceOpenNetworkConfigurationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceOpenNetworkConfigurationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.open_network_configuration_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceOpenNetworkConfigurationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string open_network_configuration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_open_network_configuration();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceOpenNetworkConfigurationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceOpenNetworkConfigurationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string open_network_configuration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_open_network_configuration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceOpenNetworkConfigurationProto)
  return target;
}

size_t DeviceOpenNetworkConfigurationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceOpenNetworkConfigurationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string open_network_configuration = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_open_network_configuration());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceOpenNetworkConfigurationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceOpenNetworkConfigurationProto*>(
      &from));
}

void DeviceOpenNetworkConfigurationProto::MergeFrom(const DeviceOpenNetworkConfigurationProto& from) {
  DeviceOpenNetworkConfigurationProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceOpenNetworkConfigurationProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_open_network_configuration()) {
    _this->_internal_set_open_network_configuration(from._internal_open_network_configuration());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceOpenNetworkConfigurationProto::CopyFrom(const DeviceOpenNetworkConfigurationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceOpenNetworkConfigurationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceOpenNetworkConfigurationProto::IsInitialized() const {
  return true;
}

void DeviceOpenNetworkConfigurationProto::InternalSwap(DeviceOpenNetworkConfigurationProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.open_network_configuration_, lhs_arena,
      &other->_impl_.open_network_configuration_, rhs_arena
  );
}

std::string DeviceOpenNetworkConfigurationProto::GetTypeName() const {
  return "enterprise_management.DeviceOpenNetworkConfigurationProto";
}


// ===================================================================

class NetworkHostnameProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NetworkHostnameProto>()._impl_._has_bits_);
  static void set_has_device_hostname_template(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NetworkHostnameProto::NetworkHostnameProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.NetworkHostnameProto)
}
NetworkHostnameProto::NetworkHostnameProto(const NetworkHostnameProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkHostnameProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_hostname_template_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_hostname_template_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_hostname_template_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_hostname_template()) {
    _this->_impl_.device_hostname_template_.Set(from._internal_device_hostname_template(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.NetworkHostnameProto)
}

inline void NetworkHostnameProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_hostname_template_){}
  };
  _impl_.device_hostname_template_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_hostname_template_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkHostnameProto::~NetworkHostnameProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.NetworkHostnameProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkHostnameProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_hostname_template_.Destroy();
}

void NetworkHostnameProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkHostnameProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.NetworkHostnameProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.device_hostname_template_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkHostnameProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_hostname_template = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_hostname_template();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkHostnameProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.NetworkHostnameProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_hostname_template = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_hostname_template(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.NetworkHostnameProto)
  return target;
}

size_t NetworkHostnameProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.NetworkHostnameProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_hostname_template = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_hostname_template());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkHostnameProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkHostnameProto*>(
      &from));
}

void NetworkHostnameProto::MergeFrom(const NetworkHostnameProto& from) {
  NetworkHostnameProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.NetworkHostnameProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_hostname_template()) {
    _this->_internal_set_device_hostname_template(from._internal_device_hostname_template());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkHostnameProto::CopyFrom(const NetworkHostnameProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.NetworkHostnameProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkHostnameProto::IsInitialized() const {
  return true;
}

void NetworkHostnameProto::InternalSwap(NetworkHostnameProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_hostname_template_, lhs_arena,
      &other->_impl_.device_hostname_template_, rhs_arena
  );
}

std::string NetworkHostnameProto::GetTypeName() const {
  return "enterprise_management.NetworkHostnameProto";
}


// ===================================================================

class DeviceHindiInscriptLayoutEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceHindiInscriptLayoutEnabledProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceHindiInscriptLayoutEnabledProto::DeviceHindiInscriptLayoutEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
}
DeviceHindiInscriptLayoutEnabledProto::DeviceHindiInscriptLayoutEnabledProto(const DeviceHindiInscriptLayoutEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceHindiInscriptLayoutEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
}

inline void DeviceHindiInscriptLayoutEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceHindiInscriptLayoutEnabledProto::~DeviceHindiInscriptLayoutEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceHindiInscriptLayoutEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceHindiInscriptLayoutEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceHindiInscriptLayoutEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceHindiInscriptLayoutEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceHindiInscriptLayoutEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
  return target;
}

size_t DeviceHindiInscriptLayoutEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceHindiInscriptLayoutEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceHindiInscriptLayoutEnabledProto*>(
      &from));
}

void DeviceHindiInscriptLayoutEnabledProto::MergeFrom(const DeviceHindiInscriptLayoutEnabledProto& from) {
  DeviceHindiInscriptLayoutEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceHindiInscriptLayoutEnabledProto::CopyFrom(const DeviceHindiInscriptLayoutEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceHindiInscriptLayoutEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceHindiInscriptLayoutEnabledProto::IsInitialized() const {
  return true;
}

void DeviceHindiInscriptLayoutEnabledProto::InternalSwap(DeviceHindiInscriptLayoutEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceHindiInscriptLayoutEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceHindiInscriptLayoutEnabledProto";
}


// ===================================================================

class HostnameUserConfigurableProto::_Internal {
 public:
  using HasBits = decltype(std::declval<HostnameUserConfigurableProto>()._impl_._has_bits_);
  static void set_has_device_hostname_user_configurable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

HostnameUserConfigurableProto::HostnameUserConfigurableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.HostnameUserConfigurableProto)
}
HostnameUserConfigurableProto::HostnameUserConfigurableProto(const HostnameUserConfigurableProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HostnameUserConfigurableProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_hostname_user_configurable_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_hostname_user_configurable_ = from._impl_.device_hostname_user_configurable_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.HostnameUserConfigurableProto)
}

inline void HostnameUserConfigurableProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_hostname_user_configurable_){false}
  };
}

HostnameUserConfigurableProto::~HostnameUserConfigurableProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.HostnameUserConfigurableProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostnameUserConfigurableProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HostnameUserConfigurableProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostnameUserConfigurableProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.HostnameUserConfigurableProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_hostname_user_configurable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HostnameUserConfigurableProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_hostname_user_configurable = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_hostname_user_configurable(&has_bits);
          _impl_.device_hostname_user_configurable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostnameUserConfigurableProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.HostnameUserConfigurableProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_hostname_user_configurable = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_hostname_user_configurable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.HostnameUserConfigurableProto)
  return target;
}

size_t HostnameUserConfigurableProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.HostnameUserConfigurableProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_hostname_user_configurable = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostnameUserConfigurableProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HostnameUserConfigurableProto*>(
      &from));
}

void HostnameUserConfigurableProto::MergeFrom(const HostnameUserConfigurableProto& from) {
  HostnameUserConfigurableProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.HostnameUserConfigurableProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_hostname_user_configurable()) {
    _this->_internal_set_device_hostname_user_configurable(from._internal_device_hostname_user_configurable());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostnameUserConfigurableProto::CopyFrom(const HostnameUserConfigurableProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.HostnameUserConfigurableProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostnameUserConfigurableProto::IsInitialized() const {
  return true;
}

void HostnameUserConfigurableProto::InternalSwap(HostnameUserConfigurableProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_hostname_user_configurable_, other->_impl_.device_hostname_user_configurable_);
}

std::string HostnameUserConfigurableProto::GetTypeName() const {
  return "enterprise_management.HostnameUserConfigurableProto";
}


// ===================================================================

class DeviceReportingProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceReportingProto>()._impl_._has_bits_);
  static void set_has_report_version_info(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_report_activity_times(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_report_boot_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_report_location(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_report_network_interfaces(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_report_users(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_report_hardware_status(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_report_session_status(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_report_os_update_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_report_running_kiosk_app(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_report_power_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_report_storage_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_report_board_status(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_report_cpu_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_report_graphics_status(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_report_crash_report_info(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_report_timezone_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_report_memory_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_report_backlight_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_report_app_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_report_bluetooth_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_report_fan_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_report_vpd_info(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_report_system_info(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_report_print_jobs(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_report_login_logout(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_report_audio_status(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_report_network_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_report_network_status(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_report_security_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_report_crd_sessions(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_report_peripherals(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_device_status_frequency(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_enable_granular_reporting(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_report_network_telemetry_collection_rate_ms(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_report_network_telemetry_event_checking_rate_ms(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_report_device_audio_status_checking_rate_ms(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static const ::enterprise_management::StringList& report_signal_strength_event_driven_telemetry(const DeviceReportingProto* msg);
  static void set_has_report_signal_strength_event_driven_telemetry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_activity_heartbeat_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_device_activity_heartbeat_collection_rate_ms(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
};

const ::enterprise_management::StringList&
DeviceReportingProto::_Internal::report_signal_strength_event_driven_telemetry(const DeviceReportingProto* msg) {
  return *msg->_impl_.report_signal_strength_event_driven_telemetry_;
}
void DeviceReportingProto::clear_report_signal_strength_event_driven_telemetry() {
  if (_impl_.report_signal_strength_event_driven_telemetry_ != nullptr) _impl_.report_signal_strength_event_driven_telemetry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
DeviceReportingProto::DeviceReportingProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceReportingProto)
}
DeviceReportingProto::DeviceReportingProto(const DeviceReportingProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceReportingProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.report_signal_strength_event_driven_telemetry_){nullptr}
    , decltype(_impl_.report_location_){}
    , decltype(_impl_.report_os_update_status_){}
    , decltype(_impl_.report_running_kiosk_app_){}
    , decltype(_impl_.report_power_status_){}
    , decltype(_impl_.report_storage_status_){}
    , decltype(_impl_.report_board_status_){}
    , decltype(_impl_.report_cpu_info_){}
    , decltype(_impl_.report_graphics_status_){}
    , decltype(_impl_.report_crash_report_info_){}
    , decltype(_impl_.report_timezone_info_){}
    , decltype(_impl_.report_memory_info_){}
    , decltype(_impl_.report_backlight_info_){}
    , decltype(_impl_.report_app_info_){}
    , decltype(_impl_.report_bluetooth_info_){}
    , decltype(_impl_.report_fan_info_){}
    , decltype(_impl_.report_vpd_info_){}
    , decltype(_impl_.report_system_info_){}
    , decltype(_impl_.report_print_jobs_){}
    , decltype(_impl_.report_login_logout_){}
    , decltype(_impl_.report_security_status_){}
    , decltype(_impl_.report_crd_sessions_){}
    , decltype(_impl_.report_peripherals_){}
    , decltype(_impl_.device_activity_heartbeat_enabled_){}
    , decltype(_impl_.report_network_configuration_){}
    , decltype(_impl_.report_network_status_){}
    , decltype(_impl_.enable_granular_reporting_){}
    , decltype(_impl_.report_version_info_){}
    , decltype(_impl_.report_activity_times_){}
    , decltype(_impl_.report_boot_mode_){}
    , decltype(_impl_.report_network_interfaces_){}
    , decltype(_impl_.report_users_){}
    , decltype(_impl_.report_hardware_status_){}
    , decltype(_impl_.report_session_status_){}
    , decltype(_impl_.report_audio_status_){}
    , decltype(_impl_.device_status_frequency_){}
    , decltype(_impl_.report_network_telemetry_collection_rate_ms_){}
    , decltype(_impl_.report_network_telemetry_event_checking_rate_ms_){}
    , decltype(_impl_.report_device_audio_status_checking_rate_ms_){}
    , decltype(_impl_.device_activity_heartbeat_collection_rate_ms_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_report_signal_strength_event_driven_telemetry()) {
    _this->_impl_.report_signal_strength_event_driven_telemetry_ = new ::enterprise_management::StringList(*from._impl_.report_signal_strength_event_driven_telemetry_);
  }
  ::memcpy(&_impl_.report_location_, &from._impl_.report_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.device_activity_heartbeat_collection_rate_ms_) -
    reinterpret_cast<char*>(&_impl_.report_location_)) + sizeof(_impl_.device_activity_heartbeat_collection_rate_ms_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceReportingProto)
}

inline void DeviceReportingProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.report_signal_strength_event_driven_telemetry_){nullptr}
    , decltype(_impl_.report_location_){false}
    , decltype(_impl_.report_os_update_status_){false}
    , decltype(_impl_.report_running_kiosk_app_){false}
    , decltype(_impl_.report_power_status_){false}
    , decltype(_impl_.report_storage_status_){false}
    , decltype(_impl_.report_board_status_){false}
    , decltype(_impl_.report_cpu_info_){false}
    , decltype(_impl_.report_graphics_status_){false}
    , decltype(_impl_.report_crash_report_info_){false}
    , decltype(_impl_.report_timezone_info_){false}
    , decltype(_impl_.report_memory_info_){false}
    , decltype(_impl_.report_backlight_info_){false}
    , decltype(_impl_.report_app_info_){false}
    , decltype(_impl_.report_bluetooth_info_){false}
    , decltype(_impl_.report_fan_info_){false}
    , decltype(_impl_.report_vpd_info_){false}
    , decltype(_impl_.report_system_info_){false}
    , decltype(_impl_.report_print_jobs_){false}
    , decltype(_impl_.report_login_logout_){false}
    , decltype(_impl_.report_security_status_){false}
    , decltype(_impl_.report_crd_sessions_){false}
    , decltype(_impl_.report_peripherals_){false}
    , decltype(_impl_.device_activity_heartbeat_enabled_){false}
    , decltype(_impl_.report_network_configuration_){true}
    , decltype(_impl_.report_network_status_){true}
    , decltype(_impl_.enable_granular_reporting_){true}
    , decltype(_impl_.report_version_info_){true}
    , decltype(_impl_.report_activity_times_){true}
    , decltype(_impl_.report_boot_mode_){true}
    , decltype(_impl_.report_network_interfaces_){true}
    , decltype(_impl_.report_users_){true}
    , decltype(_impl_.report_hardware_status_){true}
    , decltype(_impl_.report_session_status_){true}
    , decltype(_impl_.report_audio_status_){true}
    , decltype(_impl_.device_status_frequency_){int64_t{10800000}}
    , decltype(_impl_.report_network_telemetry_collection_rate_ms_){int64_t{3600000}}
    , decltype(_impl_.report_network_telemetry_event_checking_rate_ms_){int64_t{600000}}
    , decltype(_impl_.report_device_audio_status_checking_rate_ms_){int64_t{600000}}
    , decltype(_impl_.device_activity_heartbeat_collection_rate_ms_){int64_t{900000}}
  };
}

DeviceReportingProto::~DeviceReportingProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceReportingProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceReportingProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.report_signal_strength_event_driven_telemetry_;
}

void DeviceReportingProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceReportingProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceReportingProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.report_signal_strength_event_driven_telemetry_ != nullptr);
    _impl_.report_signal_strength_event_driven_telemetry_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.report_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.report_cpu_info_) -
        reinterpret_cast<char*>(&_impl_.report_location_)) + sizeof(_impl_.report_cpu_info_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.report_graphics_status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.report_fan_info_) -
        reinterpret_cast<char*>(&_impl_.report_graphics_status_)) + sizeof(_impl_.report_fan_info_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.report_vpd_info_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.device_activity_heartbeat_enabled_) -
        reinterpret_cast<char*>(&_impl_.report_vpd_info_)) + sizeof(_impl_.device_activity_heartbeat_enabled_));
  }
  if (cached_has_bits & 0xff000000u) {
    _impl_.report_network_configuration_ = true;
    _impl_.report_network_status_ = true;
    _impl_.enable_granular_reporting_ = true;
    _impl_.report_version_info_ = true;
    _impl_.report_activity_times_ = true;
    _impl_.report_boot_mode_ = true;
    _impl_.report_network_interfaces_ = true;
    _impl_.report_users_ = true;
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    _impl_.report_hardware_status_ = true;
    _impl_.report_session_status_ = true;
    _impl_.report_audio_status_ = true;
    _impl_.device_status_frequency_ = int64_t{10800000};
    _impl_.report_network_telemetry_collection_rate_ms_ = int64_t{3600000};
    _impl_.report_network_telemetry_event_checking_rate_ms_ = int64_t{600000};
    _impl_.report_device_audio_status_checking_rate_ms_ = int64_t{600000};
    _impl_.device_activity_heartbeat_collection_rate_ms_ = int64_t{900000};
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceReportingProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool report_version_info = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_report_version_info(&_impl_._has_bits_);
          _impl_.report_version_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_activity_times = 2 [default = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_report_activity_times(&_impl_._has_bits_);
          _impl_.report_activity_times_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_boot_mode = 3 [default = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_report_boot_mode(&_impl_._has_bits_);
          _impl_.report_boot_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_location = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_report_location(&_impl_._has_bits_);
          _impl_.report_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_network_interfaces = 5 [default = true, deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_report_network_interfaces(&_impl_._has_bits_);
          _impl_.report_network_interfaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_users = 6 [default = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_report_users(&_impl_._has_bits_);
          _impl_.report_users_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_hardware_status = 7 [default = true, deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_report_hardware_status(&_impl_._has_bits_);
          _impl_.report_hardware_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_session_status = 8 [default = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_report_session_status(&_impl_._has_bits_);
          _impl_.report_session_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 device_status_frequency = 9 [default = 10800000];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_device_status_frequency(&_impl_._has_bits_);
          _impl_.device_status_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_os_update_status = 10 [default = false];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_report_os_update_status(&_impl_._has_bits_);
          _impl_.report_os_update_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_running_kiosk_app = 11 [default = false];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_report_running_kiosk_app(&_impl_._has_bits_);
          _impl_.report_running_kiosk_app_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_power_status = 12 [default = false];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_report_power_status(&_impl_._has_bits_);
          _impl_.report_power_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_storage_status = 13 [default = false];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_report_storage_status(&_impl_._has_bits_);
          _impl_.report_storage_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_board_status = 14 [default = false];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_report_board_status(&_impl_._has_bits_);
          _impl_.report_board_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_cpu_info = 15 [default = false];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_report_cpu_info(&_impl_._has_bits_);
          _impl_.report_cpu_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_graphics_status = 16 [default = false];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_report_graphics_status(&_impl_._has_bits_);
          _impl_.report_graphics_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_crash_report_info = 17 [default = false];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_report_crash_report_info(&_impl_._has_bits_);
          _impl_.report_crash_report_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_timezone_info = 18 [default = false];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_report_timezone_info(&_impl_._has_bits_);
          _impl_.report_timezone_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_memory_info = 19 [default = false];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_report_memory_info(&_impl_._has_bits_);
          _impl_.report_memory_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_backlight_info = 20 [default = false];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_report_backlight_info(&_impl_._has_bits_);
          _impl_.report_backlight_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_app_info = 21 [default = false];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_report_app_info(&_impl_._has_bits_);
          _impl_.report_app_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_bluetooth_info = 22 [default = false];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_report_bluetooth_info(&_impl_._has_bits_);
          _impl_.report_bluetooth_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_fan_info = 23 [default = false];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_report_fan_info(&_impl_._has_bits_);
          _impl_.report_fan_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_vpd_info = 24 [default = false];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_report_vpd_info(&_impl_._has_bits_);
          _impl_.report_vpd_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_system_info = 25 [default = false];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_report_system_info(&_impl_._has_bits_);
          _impl_.report_system_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_print_jobs = 26 [default = false];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_report_print_jobs(&_impl_._has_bits_);
          _impl_.report_print_jobs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_login_logout = 27 [default = false];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_report_login_logout(&_impl_._has_bits_);
          _impl_.report_login_logout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_audio_status = 28 [default = true];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_report_audio_status(&_impl_._has_bits_);
          _impl_.report_audio_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_network_configuration = 29 [default = true];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_report_network_configuration(&_impl_._has_bits_);
          _impl_.report_network_configuration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_network_status = 30 [default = true];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_report_network_status(&_impl_._has_bits_);
          _impl_.report_network_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_security_status = 31 [default = false];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_report_security_status(&_impl_._has_bits_);
          _impl_.report_security_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_granular_reporting = 32 [default = true, deprecated = true];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_enable_granular_reporting(&_impl_._has_bits_);
          _impl_.enable_granular_reporting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 report_network_telemetry_collection_rate_ms = 33 [default = 3600000];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_report_network_telemetry_collection_rate_ms(&_impl_._has_bits_);
          _impl_.report_network_telemetry_collection_rate_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 report_network_telemetry_event_checking_rate_ms = 34 [default = 600000];
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_report_network_telemetry_event_checking_rate_ms(&_impl_._has_bits_);
          _impl_.report_network_telemetry_event_checking_rate_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 report_device_audio_status_checking_rate_ms = 35 [default = 600000];
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_report_device_audio_status_checking_rate_ms(&_impl_._has_bits_);
          _impl_.report_device_audio_status_checking_rate_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_crd_sessions = 36 [default = false];
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_report_crd_sessions(&_impl_._has_bits_);
          _impl_.report_crd_sessions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool report_peripherals = 37 [default = false];
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_report_peripherals(&_impl_._has_bits_);
          _impl_.report_peripherals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.StringList report_signal_strength_event_driven_telemetry = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_report_signal_strength_event_driven_telemetry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool device_activity_heartbeat_enabled = 39 [default = false];
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_device_activity_heartbeat_enabled(&_impl_._has_bits_);
          _impl_.device_activity_heartbeat_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 device_activity_heartbeat_collection_rate_ms = 40 [default = 900000];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_device_activity_heartbeat_collection_rate_ms(&_impl_._has_bits_);
          _impl_.device_activity_heartbeat_collection_rate_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceReportingProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceReportingProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool report_version_info = 1 [default = true];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_report_version_info(), target);
  }

  // optional bool report_activity_times = 2 [default = true];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_report_activity_times(), target);
  }

  // optional bool report_boot_mode = 3 [default = true];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_report_boot_mode(), target);
  }

  // optional bool report_location = 4 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_report_location(), target);
  }

  // optional bool report_network_interfaces = 5 [default = true, deprecated = true];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_report_network_interfaces(), target);
  }

  // optional bool report_users = 6 [default = true];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_report_users(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool report_hardware_status = 7 [default = true, deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_report_hardware_status(), target);
  }

  // optional bool report_session_status = 8 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_report_session_status(), target);
  }

  // optional int64 device_status_frequency = 9 [default = 10800000];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_device_status_frequency(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool report_os_update_status = 10 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_report_os_update_status(), target);
  }

  // optional bool report_running_kiosk_app = 11 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_report_running_kiosk_app(), target);
  }

  // optional bool report_power_status = 12 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_report_power_status(), target);
  }

  // optional bool report_storage_status = 13 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_report_storage_status(), target);
  }

  // optional bool report_board_status = 14 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_report_board_status(), target);
  }

  // optional bool report_cpu_info = 15 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_report_cpu_info(), target);
  }

  // optional bool report_graphics_status = 16 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_report_graphics_status(), target);
  }

  // optional bool report_crash_report_info = 17 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_report_crash_report_info(), target);
  }

  // optional bool report_timezone_info = 18 [default = false];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_report_timezone_info(), target);
  }

  // optional bool report_memory_info = 19 [default = false];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_report_memory_info(), target);
  }

  // optional bool report_backlight_info = 20 [default = false];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_report_backlight_info(), target);
  }

  // optional bool report_app_info = 21 [default = false];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_report_app_info(), target);
  }

  // optional bool report_bluetooth_info = 22 [default = false];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_report_bluetooth_info(), target);
  }

  // optional bool report_fan_info = 23 [default = false];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_report_fan_info(), target);
  }

  // optional bool report_vpd_info = 24 [default = false];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_report_vpd_info(), target);
  }

  // optional bool report_system_info = 25 [default = false];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_report_system_info(), target);
  }

  // optional bool report_print_jobs = 26 [default = false];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_report_print_jobs(), target);
  }

  // optional bool report_login_logout = 27 [default = false];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_report_login_logout(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool report_audio_status = 28 [default = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_report_audio_status(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool report_network_configuration = 29 [default = true];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_report_network_configuration(), target);
  }

  // optional bool report_network_status = 30 [default = true];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(30, this->_internal_report_network_status(), target);
  }

  // optional bool report_security_status = 31 [default = false];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_report_security_status(), target);
  }

  // optional bool enable_granular_reporting = 32 [default = true, deprecated = true];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(32, this->_internal_enable_granular_reporting(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int64 report_network_telemetry_collection_rate_ms = 33 [default = 3600000];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(33, this->_internal_report_network_telemetry_collection_rate_ms(), target);
  }

  // optional int64 report_network_telemetry_event_checking_rate_ms = 34 [default = 600000];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(34, this->_internal_report_network_telemetry_event_checking_rate_ms(), target);
  }

  // optional int64 report_device_audio_status_checking_rate_ms = 35 [default = 600000];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(35, this->_internal_report_device_audio_status_checking_rate_ms(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool report_crd_sessions = 36 [default = false];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(36, this->_internal_report_crd_sessions(), target);
  }

  // optional bool report_peripherals = 37 [default = false];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_report_peripherals(), target);
  }

  // optional .enterprise_management.StringList report_signal_strength_event_driven_telemetry = 38;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::report_signal_strength_event_driven_telemetry(this),
        _Internal::report_signal_strength_event_driven_telemetry(this).GetCachedSize(), target, stream);
  }

  // optional bool device_activity_heartbeat_enabled = 39 [default = false];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(39, this->_internal_device_activity_heartbeat_enabled(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int64 device_activity_heartbeat_collection_rate_ms = 40 [default = 900000];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(40, this->_internal_device_activity_heartbeat_collection_rate_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceReportingProto)
  return target;
}

size_t DeviceReportingProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceReportingProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.StringList report_signal_strength_event_driven_telemetry = 38;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.report_signal_strength_event_driven_telemetry_);
    }

    // optional bool report_location = 4 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool report_os_update_status = 10 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool report_running_kiosk_app = 11 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool report_power_status = 12 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool report_storage_status = 13 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool report_board_status = 14 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool report_cpu_info = 15 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool report_graphics_status = 16 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool report_crash_report_info = 17 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional bool report_timezone_info = 18 [default = false];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool report_memory_info = 19 [default = false];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool report_backlight_info = 20 [default = false];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool report_app_info = 21 [default = false];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool report_bluetooth_info = 22 [default = false];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool report_fan_info = 23 [default = false];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool report_vpd_info = 24 [default = false];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool report_system_info = 25 [default = false];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool report_print_jobs = 26 [default = false];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool report_login_logout = 27 [default = false];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool report_security_status = 31 [default = false];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool report_crd_sessions = 36 [default = false];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool report_peripherals = 37 [default = false];
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool device_activity_heartbeat_enabled = 39 [default = false];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool report_network_configuration = 29 [default = true];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool report_network_status = 30 [default = true];
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool enable_granular_reporting = 32 [default = true, deprecated = true];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool report_version_info = 1 [default = true];
    if (cached_has_bits & 0x08000000u) {
      total_size += 1 + 1;
    }

    // optional bool report_activity_times = 2 [default = true];
    if (cached_has_bits & 0x10000000u) {
      total_size += 1 + 1;
    }

    // optional bool report_boot_mode = 3 [default = true];
    if (cached_has_bits & 0x20000000u) {
      total_size += 1 + 1;
    }

    // optional bool report_network_interfaces = 5 [default = true, deprecated = true];
    if (cached_has_bits & 0x40000000u) {
      total_size += 1 + 1;
    }

    // optional bool report_users = 6 [default = true];
    if (cached_has_bits & 0x80000000u) {
      total_size += 1 + 1;
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool report_hardware_status = 7 [default = true, deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool report_session_status = 8 [default = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool report_audio_status = 28 [default = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional int64 device_status_frequency = 9 [default = 10800000];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_device_status_frequency());
    }

    // optional int64 report_network_telemetry_collection_rate_ms = 33 [default = 3600000];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_report_network_telemetry_collection_rate_ms());
    }

    // optional int64 report_network_telemetry_event_checking_rate_ms = 34 [default = 600000];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_report_network_telemetry_event_checking_rate_ms());
    }

    // optional int64 report_device_audio_status_checking_rate_ms = 35 [default = 600000];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_report_device_audio_status_checking_rate_ms());
    }

    // optional int64 device_activity_heartbeat_collection_rate_ms = 40 [default = 900000];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_device_activity_heartbeat_collection_rate_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceReportingProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceReportingProto*>(
      &from));
}

void DeviceReportingProto::MergeFrom(const DeviceReportingProto& from) {
  DeviceReportingProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceReportingProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_report_signal_strength_event_driven_telemetry()->::enterprise_management::StringList::MergeFrom(
          from._internal_report_signal_strength_event_driven_telemetry());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.report_location_ = from._impl_.report_location_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.report_os_update_status_ = from._impl_.report_os_update_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.report_running_kiosk_app_ = from._impl_.report_running_kiosk_app_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.report_power_status_ = from._impl_.report_power_status_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.report_storage_status_ = from._impl_.report_storage_status_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.report_board_status_ = from._impl_.report_board_status_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.report_cpu_info_ = from._impl_.report_cpu_info_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.report_graphics_status_ = from._impl_.report_graphics_status_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.report_crash_report_info_ = from._impl_.report_crash_report_info_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.report_timezone_info_ = from._impl_.report_timezone_info_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.report_memory_info_ = from._impl_.report_memory_info_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.report_backlight_info_ = from._impl_.report_backlight_info_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.report_app_info_ = from._impl_.report_app_info_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.report_bluetooth_info_ = from._impl_.report_bluetooth_info_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.report_fan_info_ = from._impl_.report_fan_info_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.report_vpd_info_ = from._impl_.report_vpd_info_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.report_system_info_ = from._impl_.report_system_info_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.report_print_jobs_ = from._impl_.report_print_jobs_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.report_login_logout_ = from._impl_.report_login_logout_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.report_security_status_ = from._impl_.report_security_status_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.report_crd_sessions_ = from._impl_.report_crd_sessions_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.report_peripherals_ = from._impl_.report_peripherals_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.device_activity_heartbeat_enabled_ = from._impl_.device_activity_heartbeat_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.report_network_configuration_ = from._impl_.report_network_configuration_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.report_network_status_ = from._impl_.report_network_status_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.enable_granular_reporting_ = from._impl_.enable_granular_reporting_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.report_version_info_ = from._impl_.report_version_info_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.report_activity_times_ = from._impl_.report_activity_times_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.report_boot_mode_ = from._impl_.report_boot_mode_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.report_network_interfaces_ = from._impl_.report_network_interfaces_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.report_users_ = from._impl_.report_users_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.report_hardware_status_ = from._impl_.report_hardware_status_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.report_session_status_ = from._impl_.report_session_status_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.report_audio_status_ = from._impl_.report_audio_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.device_status_frequency_ = from._impl_.device_status_frequency_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.report_network_telemetry_collection_rate_ms_ = from._impl_.report_network_telemetry_collection_rate_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.report_network_telemetry_event_checking_rate_ms_ = from._impl_.report_network_telemetry_event_checking_rate_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.report_device_audio_status_checking_rate_ms_ = from._impl_.report_device_audio_status_checking_rate_ms_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.device_activity_heartbeat_collection_rate_ms_ = from._impl_.device_activity_heartbeat_collection_rate_ms_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceReportingProto::CopyFrom(const DeviceReportingProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceReportingProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceReportingProto::IsInitialized() const {
  return true;
}

void DeviceReportingProto::InternalSwap(DeviceReportingProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceReportingProto, _impl_.device_activity_heartbeat_enabled_)
      + sizeof(DeviceReportingProto::_impl_.device_activity_heartbeat_enabled_)
      - PROTOBUF_FIELD_OFFSET(DeviceReportingProto, _impl_.report_signal_strength_event_driven_telemetry_)>(
          reinterpret_cast<char*>(&_impl_.report_signal_strength_event_driven_telemetry_),
          reinterpret_cast<char*>(&other->_impl_.report_signal_strength_event_driven_telemetry_));
  swap(_impl_.report_network_configuration_, other->_impl_.report_network_configuration_);
  swap(_impl_.report_network_status_, other->_impl_.report_network_status_);
  swap(_impl_.enable_granular_reporting_, other->_impl_.enable_granular_reporting_);
  swap(_impl_.report_version_info_, other->_impl_.report_version_info_);
  swap(_impl_.report_activity_times_, other->_impl_.report_activity_times_);
  swap(_impl_.report_boot_mode_, other->_impl_.report_boot_mode_);
  swap(_impl_.report_network_interfaces_, other->_impl_.report_network_interfaces_);
  swap(_impl_.report_users_, other->_impl_.report_users_);
  swap(_impl_.report_hardware_status_, other->_impl_.report_hardware_status_);
  swap(_impl_.report_session_status_, other->_impl_.report_session_status_);
  swap(_impl_.report_audio_status_, other->_impl_.report_audio_status_);
  swap(_impl_.device_status_frequency_, other->_impl_.device_status_frequency_);
  swap(_impl_.report_network_telemetry_collection_rate_ms_, other->_impl_.report_network_telemetry_collection_rate_ms_);
  swap(_impl_.report_network_telemetry_event_checking_rate_ms_, other->_impl_.report_network_telemetry_event_checking_rate_ms_);
  swap(_impl_.report_device_audio_status_checking_rate_ms_, other->_impl_.report_device_audio_status_checking_rate_ms_);
  swap(_impl_.device_activity_heartbeat_collection_rate_ms_, other->_impl_.device_activity_heartbeat_collection_rate_ms_);
}

std::string DeviceReportingProto::GetTypeName() const {
  return "enterprise_management.DeviceReportingProto";
}


// ===================================================================

class EphemeralUsersEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<EphemeralUsersEnabledProto>()._impl_._has_bits_);
  static void set_has_ephemeral_users_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EphemeralUsersEnabledProto::EphemeralUsersEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.EphemeralUsersEnabledProto)
}
EphemeralUsersEnabledProto::EphemeralUsersEnabledProto(const EphemeralUsersEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EphemeralUsersEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ephemeral_users_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.ephemeral_users_enabled_ = from._impl_.ephemeral_users_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.EphemeralUsersEnabledProto)
}

inline void EphemeralUsersEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ephemeral_users_enabled_){false}
  };
}

EphemeralUsersEnabledProto::~EphemeralUsersEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.EphemeralUsersEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EphemeralUsersEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EphemeralUsersEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EphemeralUsersEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.EphemeralUsersEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ephemeral_users_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EphemeralUsersEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool ephemeral_users_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ephemeral_users_enabled(&has_bits);
          _impl_.ephemeral_users_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EphemeralUsersEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.EphemeralUsersEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool ephemeral_users_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ephemeral_users_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.EphemeralUsersEnabledProto)
  return target;
}

size_t EphemeralUsersEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.EphemeralUsersEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool ephemeral_users_enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EphemeralUsersEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EphemeralUsersEnabledProto*>(
      &from));
}

void EphemeralUsersEnabledProto::MergeFrom(const EphemeralUsersEnabledProto& from) {
  EphemeralUsersEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.EphemeralUsersEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ephemeral_users_enabled()) {
    _this->_internal_set_ephemeral_users_enabled(from._internal_ephemeral_users_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EphemeralUsersEnabledProto::CopyFrom(const EphemeralUsersEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.EphemeralUsersEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EphemeralUsersEnabledProto::IsInitialized() const {
  return true;
}

void EphemeralUsersEnabledProto::InternalSwap(EphemeralUsersEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ephemeral_users_enabled_, other->_impl_.ephemeral_users_enabled_);
}

std::string EphemeralUsersEnabledProto::GetTypeName() const {
  return "enterprise_management.EphemeralUsersEnabledProto";
}


// ===================================================================

class DeviceKeylockerForStorageEncryptionEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceKeylockerForStorageEncryptionEnabledProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceKeylockerForStorageEncryptionEnabledProto::DeviceKeylockerForStorageEncryptionEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
}
DeviceKeylockerForStorageEncryptionEnabledProto::DeviceKeylockerForStorageEncryptionEnabledProto(const DeviceKeylockerForStorageEncryptionEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceKeylockerForStorageEncryptionEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
}

inline void DeviceKeylockerForStorageEncryptionEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceKeylockerForStorageEncryptionEnabledProto::~DeviceKeylockerForStorageEncryptionEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceKeylockerForStorageEncryptionEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceKeylockerForStorageEncryptionEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceKeylockerForStorageEncryptionEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceKeylockerForStorageEncryptionEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceKeylockerForStorageEncryptionEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
  return target;
}

size_t DeviceKeylockerForStorageEncryptionEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceKeylockerForStorageEncryptionEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceKeylockerForStorageEncryptionEnabledProto*>(
      &from));
}

void DeviceKeylockerForStorageEncryptionEnabledProto::MergeFrom(const DeviceKeylockerForStorageEncryptionEnabledProto& from) {
  DeviceKeylockerForStorageEncryptionEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceKeylockerForStorageEncryptionEnabledProto::CopyFrom(const DeviceKeylockerForStorageEncryptionEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceKeylockerForStorageEncryptionEnabledProto::IsInitialized() const {
  return true;
}

void DeviceKeylockerForStorageEncryptionEnabledProto::InternalSwap(DeviceKeylockerForStorageEncryptionEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceKeylockerForStorageEncryptionEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto";
}


// ===================================================================

class OBSOLETE_AppPackEntryProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_AppPackEntryProto>()._impl_._has_bits_);
  static void set_has_obsolete_extension_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_obsolete_update_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_obsolete_online_only(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

OBSOLETE_AppPackEntryProto::OBSOLETE_AppPackEntryProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_AppPackEntryProto)
}
OBSOLETE_AppPackEntryProto::OBSOLETE_AppPackEntryProto(const OBSOLETE_AppPackEntryProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_AppPackEntryProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_extension_id_){}
    , decltype(_impl_.obsolete_update_url_){}
    , decltype(_impl_.obsolete_online_only_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.obsolete_extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_extension_id()) {
    _this->_impl_.obsolete_extension_id_.Set(from._internal_obsolete_extension_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.obsolete_update_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_update_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_update_url()) {
    _this->_impl_.obsolete_update_url_.Set(from._internal_obsolete_update_url(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.obsolete_online_only_ = from._impl_.obsolete_online_only_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_AppPackEntryProto)
}

inline void OBSOLETE_AppPackEntryProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_extension_id_){}
    , decltype(_impl_.obsolete_update_url_){}
    , decltype(_impl_.obsolete_online_only_){false}
  };
  _impl_.obsolete_extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.obsolete_update_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_update_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OBSOLETE_AppPackEntryProto::~OBSOLETE_AppPackEntryProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_AppPackEntryProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_AppPackEntryProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_extension_id_.Destroy();
  _impl_.obsolete_update_url_.Destroy();
}

void OBSOLETE_AppPackEntryProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_AppPackEntryProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_AppPackEntryProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.obsolete_extension_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.obsolete_update_url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.obsolete_online_only_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_AppPackEntryProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string OBSOLETE_extension_id = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_obsolete_extension_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string OBSOLETE_update_url = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_obsolete_update_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool OBSOLETE_online_only = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_obsolete_online_only(&has_bits);
          _impl_.obsolete_online_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_AppPackEntryProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_AppPackEntryProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string OBSOLETE_extension_id = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_obsolete_extension_id(), target);
  }

  // optional string OBSOLETE_update_url = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_obsolete_update_url(), target);
  }

  // optional bool OBSOLETE_online_only = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_obsolete_online_only(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_AppPackEntryProto)
  return target;
}

size_t OBSOLETE_AppPackEntryProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_AppPackEntryProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string OBSOLETE_extension_id = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_extension_id());
    }

    // optional string OBSOLETE_update_url = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_update_url());
    }

    // optional bool OBSOLETE_online_only = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_AppPackEntryProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_AppPackEntryProto*>(
      &from));
}

void OBSOLETE_AppPackEntryProto::MergeFrom(const OBSOLETE_AppPackEntryProto& from) {
  OBSOLETE_AppPackEntryProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_AppPackEntryProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_obsolete_extension_id(from._internal_obsolete_extension_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_obsolete_update_url(from._internal_obsolete_update_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.obsolete_online_only_ = from._impl_.obsolete_online_only_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_AppPackEntryProto::CopyFrom(const OBSOLETE_AppPackEntryProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_AppPackEntryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_AppPackEntryProto::IsInitialized() const {
  return true;
}

void OBSOLETE_AppPackEntryProto::InternalSwap(OBSOLETE_AppPackEntryProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_extension_id_, lhs_arena,
      &other->_impl_.obsolete_extension_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_update_url_, lhs_arena,
      &other->_impl_.obsolete_update_url_, rhs_arena
  );
  swap(_impl_.obsolete_online_only_, other->_impl_.obsolete_online_only_);
}

std::string OBSOLETE_AppPackEntryProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_AppPackEntryProto";
}


// ===================================================================

class OBSOLETE_AppPackProto::_Internal {
 public:
};

OBSOLETE_AppPackProto::OBSOLETE_AppPackProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_AppPackProto)
}
OBSOLETE_AppPackProto::OBSOLETE_AppPackProto(const OBSOLETE_AppPackProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_AppPackProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.app_pack_){from._impl_.app_pack_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_AppPackProto)
}

inline void OBSOLETE_AppPackProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.app_pack_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OBSOLETE_AppPackProto::~OBSOLETE_AppPackProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_AppPackProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_AppPackProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.app_pack_.~RepeatedPtrField();
}

void OBSOLETE_AppPackProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_AppPackProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_AppPackProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.app_pack_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_AppPackProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.OBSOLETE_AppPackEntryProto app_pack = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_app_pack(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_AppPackProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_AppPackProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.OBSOLETE_AppPackEntryProto app_pack = 1 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_app_pack_size()); i < n; i++) {
    const auto& repfield = this->_internal_app_pack(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_AppPackProto)
  return target;
}

size_t OBSOLETE_AppPackProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_AppPackProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.OBSOLETE_AppPackEntryProto app_pack = 1 [deprecated = true];
  total_size += 1UL * this->_internal_app_pack_size();
  for (const auto& msg : this->_impl_.app_pack_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_AppPackProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_AppPackProto*>(
      &from));
}

void OBSOLETE_AppPackProto::MergeFrom(const OBSOLETE_AppPackProto& from) {
  OBSOLETE_AppPackProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_AppPackProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.app_pack_.MergeFrom(from._impl_.app_pack_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_AppPackProto::CopyFrom(const OBSOLETE_AppPackProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_AppPackProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_AppPackProto::IsInitialized() const {
  return true;
}

void OBSOLETE_AppPackProto::InternalSwap(OBSOLETE_AppPackProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.app_pack_.InternalSwap(&other->_impl_.app_pack_);
}

std::string OBSOLETE_AppPackProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_AppPackProto";
}


// ===================================================================

class OBSOLETE_PinnedAppsProto::_Internal {
 public:
};

OBSOLETE_PinnedAppsProto::OBSOLETE_PinnedAppsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_PinnedAppsProto)
}
OBSOLETE_PinnedAppsProto::OBSOLETE_PinnedAppsProto(const OBSOLETE_PinnedAppsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_PinnedAppsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.obsolete_app_id_){from._impl_.obsolete_app_id_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_PinnedAppsProto)
}

inline void OBSOLETE_PinnedAppsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.obsolete_app_id_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OBSOLETE_PinnedAppsProto::~OBSOLETE_PinnedAppsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_PinnedAppsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_PinnedAppsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_app_id_.~RepeatedPtrField();
}

void OBSOLETE_PinnedAppsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_PinnedAppsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_PinnedAppsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.obsolete_app_id_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_PinnedAppsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string OBSOLETE_app_id = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_obsolete_app_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_PinnedAppsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_PinnedAppsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string OBSOLETE_app_id = 1 [deprecated = true];
  for (int i = 0, n = this->_internal_obsolete_app_id_size(); i < n; i++) {
    const auto& s = this->_internal_obsolete_app_id(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_PinnedAppsProto)
  return target;
}

size_t OBSOLETE_PinnedAppsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_PinnedAppsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string OBSOLETE_app_id = 1 [deprecated = true];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.obsolete_app_id_.size());
  for (int i = 0, n = _impl_.obsolete_app_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.obsolete_app_id_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_PinnedAppsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_PinnedAppsProto*>(
      &from));
}

void OBSOLETE_PinnedAppsProto::MergeFrom(const OBSOLETE_PinnedAppsProto& from) {
  OBSOLETE_PinnedAppsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_PinnedAppsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.obsolete_app_id_.MergeFrom(from._impl_.obsolete_app_id_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_PinnedAppsProto::CopyFrom(const OBSOLETE_PinnedAppsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_PinnedAppsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_PinnedAppsProto::IsInitialized() const {
  return true;
}

void OBSOLETE_PinnedAppsProto::InternalSwap(OBSOLETE_PinnedAppsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.obsolete_app_id_.InternalSwap(&other->_impl_.obsolete_app_id_);
}

std::string OBSOLETE_PinnedAppsProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_PinnedAppsProto";
}


// ===================================================================

class OBSOLETE_ForcedLogoutTimeoutsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_ForcedLogoutTimeoutsProto>()._impl_._has_bits_);
  static void set_has_obsolete_idle_logout_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_obsolete_idle_logout_warning_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

OBSOLETE_ForcedLogoutTimeoutsProto::OBSOLETE_ForcedLogoutTimeoutsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
}
OBSOLETE_ForcedLogoutTimeoutsProto::OBSOLETE_ForcedLogoutTimeoutsProto(const OBSOLETE_ForcedLogoutTimeoutsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_ForcedLogoutTimeoutsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_idle_logout_timeout_){}
    , decltype(_impl_.obsolete_idle_logout_warning_duration_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.obsolete_idle_logout_timeout_, &from._impl_.obsolete_idle_logout_timeout_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.obsolete_idle_logout_warning_duration_) -
    reinterpret_cast<char*>(&_impl_.obsolete_idle_logout_timeout_)) + sizeof(_impl_.obsolete_idle_logout_warning_duration_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
}

inline void OBSOLETE_ForcedLogoutTimeoutsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_idle_logout_timeout_){int64_t{0}}
    , decltype(_impl_.obsolete_idle_logout_warning_duration_){int64_t{0}}
  };
}

OBSOLETE_ForcedLogoutTimeoutsProto::~OBSOLETE_ForcedLogoutTimeoutsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_ForcedLogoutTimeoutsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OBSOLETE_ForcedLogoutTimeoutsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_ForcedLogoutTimeoutsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.obsolete_idle_logout_timeout_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.obsolete_idle_logout_warning_duration_) -
        reinterpret_cast<char*>(&_impl_.obsolete_idle_logout_timeout_)) + sizeof(_impl_.obsolete_idle_logout_warning_duration_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_ForcedLogoutTimeoutsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 OBSOLETE_idle_logout_timeout = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_obsolete_idle_logout_timeout(&has_bits);
          _impl_.obsolete_idle_logout_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 OBSOLETE_idle_logout_warning_duration = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_obsolete_idle_logout_warning_duration(&has_bits);
          _impl_.obsolete_idle_logout_warning_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_ForcedLogoutTimeoutsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 OBSOLETE_idle_logout_timeout = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_obsolete_idle_logout_timeout(), target);
  }

  // optional int64 OBSOLETE_idle_logout_warning_duration = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_obsolete_idle_logout_warning_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
  return target;
}

size_t OBSOLETE_ForcedLogoutTimeoutsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 OBSOLETE_idle_logout_timeout = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_obsolete_idle_logout_timeout());
    }

    // optional int64 OBSOLETE_idle_logout_warning_duration = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_obsolete_idle_logout_warning_duration());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_ForcedLogoutTimeoutsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_ForcedLogoutTimeoutsProto*>(
      &from));
}

void OBSOLETE_ForcedLogoutTimeoutsProto::MergeFrom(const OBSOLETE_ForcedLogoutTimeoutsProto& from) {
  OBSOLETE_ForcedLogoutTimeoutsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.obsolete_idle_logout_timeout_ = from._impl_.obsolete_idle_logout_timeout_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.obsolete_idle_logout_warning_duration_ = from._impl_.obsolete_idle_logout_warning_duration_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_ForcedLogoutTimeoutsProto::CopyFrom(const OBSOLETE_ForcedLogoutTimeoutsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_ForcedLogoutTimeoutsProto::IsInitialized() const {
  return true;
}

void OBSOLETE_ForcedLogoutTimeoutsProto::InternalSwap(OBSOLETE_ForcedLogoutTimeoutsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OBSOLETE_ForcedLogoutTimeoutsProto, _impl_.obsolete_idle_logout_warning_duration_)
      + sizeof(OBSOLETE_ForcedLogoutTimeoutsProto::_impl_.obsolete_idle_logout_warning_duration_)
      - PROTOBUF_FIELD_OFFSET(OBSOLETE_ForcedLogoutTimeoutsProto, _impl_.obsolete_idle_logout_timeout_)>(
          reinterpret_cast<char*>(&_impl_.obsolete_idle_logout_timeout_),
          reinterpret_cast<char*>(&other->_impl_.obsolete_idle_logout_timeout_));
}

std::string OBSOLETE_ForcedLogoutTimeoutsProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto";
}


// ===================================================================

class OBSOLETE_ScreenSaverProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_ScreenSaverProto>()._impl_._has_bits_);
  static void set_has_obsolete_screen_saver_extension_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_obsolete_screen_saver_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

OBSOLETE_ScreenSaverProto::OBSOLETE_ScreenSaverProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_ScreenSaverProto)
}
OBSOLETE_ScreenSaverProto::OBSOLETE_ScreenSaverProto(const OBSOLETE_ScreenSaverProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_ScreenSaverProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_screen_saver_extension_id_){}
    , decltype(_impl_.obsolete_screen_saver_timeout_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.obsolete_screen_saver_extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_screen_saver_extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_screen_saver_extension_id()) {
    _this->_impl_.obsolete_screen_saver_extension_id_.Set(from._internal_obsolete_screen_saver_extension_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.obsolete_screen_saver_timeout_ = from._impl_.obsolete_screen_saver_timeout_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_ScreenSaverProto)
}

inline void OBSOLETE_ScreenSaverProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_screen_saver_extension_id_){}
    , decltype(_impl_.obsolete_screen_saver_timeout_){int64_t{0}}
  };
  _impl_.obsolete_screen_saver_extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_screen_saver_extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OBSOLETE_ScreenSaverProto::~OBSOLETE_ScreenSaverProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_ScreenSaverProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_ScreenSaverProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_screen_saver_extension_id_.Destroy();
}

void OBSOLETE_ScreenSaverProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_ScreenSaverProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_ScreenSaverProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.obsolete_screen_saver_extension_id_.ClearNonDefaultToEmpty();
  }
  _impl_.obsolete_screen_saver_timeout_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_ScreenSaverProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string OBSOLETE_screen_saver_extension_id = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_obsolete_screen_saver_extension_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 OBSOLETE_screen_saver_timeout = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_obsolete_screen_saver_timeout(&has_bits);
          _impl_.obsolete_screen_saver_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_ScreenSaverProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_ScreenSaverProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string OBSOLETE_screen_saver_extension_id = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_obsolete_screen_saver_extension_id(), target);
  }

  // optional int64 OBSOLETE_screen_saver_timeout = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_obsolete_screen_saver_timeout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_ScreenSaverProto)
  return target;
}

size_t OBSOLETE_ScreenSaverProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_ScreenSaverProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string OBSOLETE_screen_saver_extension_id = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_screen_saver_extension_id());
    }

    // optional int64 OBSOLETE_screen_saver_timeout = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_obsolete_screen_saver_timeout());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_ScreenSaverProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_ScreenSaverProto*>(
      &from));
}

void OBSOLETE_ScreenSaverProto::MergeFrom(const OBSOLETE_ScreenSaverProto& from) {
  OBSOLETE_ScreenSaverProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_ScreenSaverProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_obsolete_screen_saver_extension_id(from._internal_obsolete_screen_saver_extension_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.obsolete_screen_saver_timeout_ = from._impl_.obsolete_screen_saver_timeout_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_ScreenSaverProto::CopyFrom(const OBSOLETE_ScreenSaverProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_ScreenSaverProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_ScreenSaverProto::IsInitialized() const {
  return true;
}

void OBSOLETE_ScreenSaverProto::InternalSwap(OBSOLETE_ScreenSaverProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_screen_saver_extension_id_, lhs_arena,
      &other->_impl_.obsolete_screen_saver_extension_id_, rhs_arena
  );
  swap(_impl_.obsolete_screen_saver_timeout_, other->_impl_.obsolete_screen_saver_timeout_);
}

std::string OBSOLETE_ScreenSaverProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_ScreenSaverProto";
}


// ===================================================================

class AutoUpdateSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AutoUpdateSettingsProto>()._impl_._has_bits_);
  static void set_has_update_disabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_target_version_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_version_display_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scatter_factor_in_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_obsolete_reboot_after_update(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_http_downloads_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_reboot_after_update(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_p2p_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_rollback_to_target_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_rollback_allowed_milestones(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_disallowed_time_intervals(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_staging_schedule(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_device_quick_fix_build_token(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_channel_downgrade_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_target_version_selector(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

AutoUpdateSettingsProto::AutoUpdateSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AutoUpdateSettingsProto)
}
AutoUpdateSettingsProto::AutoUpdateSettingsProto(const AutoUpdateSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AutoUpdateSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_connection_types_){from._impl_.allowed_connection_types_}
    , decltype(_impl_.target_version_prefix_){}
    , decltype(_impl_.target_version_display_name_){}
    , decltype(_impl_.disallowed_time_intervals_){}
    , decltype(_impl_.staging_schedule_){}
    , decltype(_impl_.device_quick_fix_build_token_){}
    , decltype(_impl_.target_version_selector_){}
    , decltype(_impl_.scatter_factor_in_seconds_){}
    , decltype(_impl_.update_disabled_){}
    , decltype(_impl_.obsolete_reboot_after_update_){}
    , decltype(_impl_.http_downloads_enabled_){}
    , decltype(_impl_.reboot_after_update_){}
    , decltype(_impl_.p2p_enabled_){}
    , decltype(_impl_.rollback_allowed_milestones_){}
    , decltype(_impl_.rollback_to_target_version_){}
    , decltype(_impl_.channel_downgrade_behavior_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.target_version_prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_version_prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_target_version_prefix()) {
    _this->_impl_.target_version_prefix_.Set(from._internal_target_version_prefix(), 
      _this->GetArenaForAllocation());
  }
  _impl_.target_version_display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_version_display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_target_version_display_name()) {
    _this->_impl_.target_version_display_name_.Set(from._internal_target_version_display_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.disallowed_time_intervals_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.disallowed_time_intervals_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_disallowed_time_intervals()) {
    _this->_impl_.disallowed_time_intervals_.Set(from._internal_disallowed_time_intervals(), 
      _this->GetArenaForAllocation());
  }
  _impl_.staging_schedule_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.staging_schedule_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_staging_schedule()) {
    _this->_impl_.staging_schedule_.Set(from._internal_staging_schedule(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_quick_fix_build_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_quick_fix_build_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_quick_fix_build_token()) {
    _this->_impl_.device_quick_fix_build_token_.Set(from._internal_device_quick_fix_build_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.target_version_selector_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_version_selector_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_target_version_selector()) {
    _this->_impl_.target_version_selector_.Set(from._internal_target_version_selector(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.scatter_factor_in_seconds_, &from._impl_.scatter_factor_in_seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.channel_downgrade_behavior_) -
    reinterpret_cast<char*>(&_impl_.scatter_factor_in_seconds_)) + sizeof(_impl_.channel_downgrade_behavior_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AutoUpdateSettingsProto)
}

inline void AutoUpdateSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_connection_types_){arena}
    , decltype(_impl_.target_version_prefix_){}
    , decltype(_impl_.target_version_display_name_){}
    , decltype(_impl_.disallowed_time_intervals_){}
    , decltype(_impl_.staging_schedule_){}
    , decltype(_impl_.device_quick_fix_build_token_){}
    , decltype(_impl_.target_version_selector_){}
    , decltype(_impl_.scatter_factor_in_seconds_){int64_t{0}}
    , decltype(_impl_.update_disabled_){false}
    , decltype(_impl_.obsolete_reboot_after_update_){false}
    , decltype(_impl_.http_downloads_enabled_){false}
    , decltype(_impl_.reboot_after_update_){false}
    , decltype(_impl_.p2p_enabled_){false}
    , decltype(_impl_.rollback_allowed_milestones_){0}
    , decltype(_impl_.rollback_to_target_version_){1}
    , decltype(_impl_.channel_downgrade_behavior_){1}
  };
  _impl_.target_version_prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_version_prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_version_display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_version_display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.disallowed_time_intervals_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.disallowed_time_intervals_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.staging_schedule_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.staging_schedule_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_quick_fix_build_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_quick_fix_build_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_version_selector_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_version_selector_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutoUpdateSettingsProto::~AutoUpdateSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AutoUpdateSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutoUpdateSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allowed_connection_types_.~RepeatedField();
  _impl_.target_version_prefix_.Destroy();
  _impl_.target_version_display_name_.Destroy();
  _impl_.disallowed_time_intervals_.Destroy();
  _impl_.staging_schedule_.Destroy();
  _impl_.device_quick_fix_build_token_.Destroy();
  _impl_.target_version_selector_.Destroy();
}

void AutoUpdateSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AutoUpdateSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AutoUpdateSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowed_connection_types_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.target_version_prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.target_version_display_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.disallowed_time_intervals_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.staging_schedule_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.device_quick_fix_build_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.target_version_selector_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.scatter_factor_in_seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.update_disabled_) -
        reinterpret_cast<char*>(&_impl_.scatter_factor_in_seconds_)) + sizeof(_impl_.update_disabled_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.obsolete_reboot_after_update_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rollback_allowed_milestones_) -
        reinterpret_cast<char*>(&_impl_.obsolete_reboot_after_update_)) + sizeof(_impl_.rollback_allowed_milestones_));
    _impl_.rollback_to_target_version_ = 1;
    _impl_.channel_downgrade_behavior_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutoUpdateSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool update_disabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_update_disabled(&has_bits);
          _impl_.update_disabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string target_version_prefix = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_target_version_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string target_version_display_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_target_version_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 scatter_factor_in_seconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_scatter_factor_in_seconds(&has_bits);
          _impl_.scatter_factor_in_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.AutoUpdateSettingsProto.ConnectionType allowed_connection_types = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AutoUpdateSettingsProto_ConnectionType_IsValid(val))) {
              _internal_add_allowed_connection_types(static_cast<::enterprise_management::AutoUpdateSettingsProto_ConnectionType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_allowed_connection_types(), ptr, ctx, ::enterprise_management::AutoUpdateSettingsProto_ConnectionType_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool OBSOLETE_reboot_after_update = 6 [deprecated = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_obsolete_reboot_after_update(&has_bits);
          _impl_.obsolete_reboot_after_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool http_downloads_enabled = 7 [default = false];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_http_downloads_enabled(&has_bits);
          _impl_.http_downloads_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reboot_after_update = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reboot_after_update(&has_bits);
          _impl_.reboot_after_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool p2p_enabled = 9 [default = false];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_p2p_enabled(&has_bits);
          _impl_.p2p_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AutoUpdateSettingsProto.RollbackToTargetVersion rollback_to_target_version = 10 [default = ROLLBACK_DISABLED];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion_IsValid(val))) {
            _internal_set_rollback_to_target_version(static_cast<::enterprise_management::AutoUpdateSettingsProto_RollbackToTargetVersion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 rollback_allowed_milestones = 11 [default = 0];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_rollback_allowed_milestones(&has_bits);
          _impl_.rollback_allowed_milestones_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string disallowed_time_intervals = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_disallowed_time_intervals();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string staging_schedule = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_staging_schedule();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_quick_fix_build_token = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_device_quick_fix_build_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AutoUpdateSettingsProto.ChannelDowngradeBehavior channel_downgrade_behavior = 16 [default = WAIT_FOR_VERSION_CATCH_UP];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior_IsValid(val))) {
            _internal_set_channel_downgrade_behavior(static_cast<::enterprise_management::AutoUpdateSettingsProto_ChannelDowngradeBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string target_version_selector = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_target_version_selector();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutoUpdateSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AutoUpdateSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool update_disabled = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_update_disabled(), target);
  }

  // optional string target_version_prefix = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_target_version_prefix(), target);
  }

  // optional string target_version_display_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_target_version_display_name(), target);
  }

  // optional int64 scatter_factor_in_seconds = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_scatter_factor_in_seconds(), target);
  }

  // repeated .enterprise_management.AutoUpdateSettingsProto.ConnectionType allowed_connection_types = 5;
  for (int i = 0, n = this->_internal_allowed_connection_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_allowed_connection_types(i), target);
  }

  // optional bool OBSOLETE_reboot_after_update = 6 [deprecated = true];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_obsolete_reboot_after_update(), target);
  }

  // optional bool http_downloads_enabled = 7 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_http_downloads_enabled(), target);
  }

  // optional bool reboot_after_update = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_reboot_after_update(), target);
  }

  // optional bool p2p_enabled = 9 [default = false];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_p2p_enabled(), target);
  }

  // optional .enterprise_management.AutoUpdateSettingsProto.RollbackToTargetVersion rollback_to_target_version = 10 [default = ROLLBACK_DISABLED];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_rollback_to_target_version(), target);
  }

  // optional int32 rollback_allowed_milestones = 11 [default = 0];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_rollback_allowed_milestones(), target);
  }

  // optional string disallowed_time_intervals = 12;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_disallowed_time_intervals(), target);
  }

  // optional string staging_schedule = 14;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_staging_schedule(), target);
  }

  // optional string device_quick_fix_build_token = 15;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_device_quick_fix_build_token(), target);
  }

  // optional .enterprise_management.AutoUpdateSettingsProto.ChannelDowngradeBehavior channel_downgrade_behavior = 16 [default = WAIT_FOR_VERSION_CATCH_UP];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_channel_downgrade_behavior(), target);
  }

  // optional string target_version_selector = 17;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_target_version_selector(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AutoUpdateSettingsProto)
  return target;
}

size_t AutoUpdateSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AutoUpdateSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.AutoUpdateSettingsProto.ConnectionType allowed_connection_types = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_allowed_connection_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_allowed_connection_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string target_version_prefix = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_target_version_prefix());
    }

    // optional string target_version_display_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_target_version_display_name());
    }

    // optional string disallowed_time_intervals = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_disallowed_time_intervals());
    }

    // optional string staging_schedule = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_staging_schedule());
    }

    // optional string device_quick_fix_build_token = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_quick_fix_build_token());
    }

    // optional string target_version_selector = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_target_version_selector());
    }

    // optional int64 scatter_factor_in_seconds = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_scatter_factor_in_seconds());
    }

    // optional bool update_disabled = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool OBSOLETE_reboot_after_update = 6 [deprecated = true];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool http_downloads_enabled = 7 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool reboot_after_update = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool p2p_enabled = 9 [default = false];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional int32 rollback_allowed_milestones = 11 [default = 0];
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rollback_allowed_milestones());
    }

    // optional .enterprise_management.AutoUpdateSettingsProto.RollbackToTargetVersion rollback_to_target_version = 10 [default = ROLLBACK_DISABLED];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_rollback_to_target_version());
    }

    // optional .enterprise_management.AutoUpdateSettingsProto.ChannelDowngradeBehavior channel_downgrade_behavior = 16 [default = WAIT_FOR_VERSION_CATCH_UP];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_channel_downgrade_behavior());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutoUpdateSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutoUpdateSettingsProto*>(
      &from));
}

void AutoUpdateSettingsProto::MergeFrom(const AutoUpdateSettingsProto& from) {
  AutoUpdateSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AutoUpdateSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allowed_connection_types_.MergeFrom(from._impl_.allowed_connection_types_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_target_version_prefix(from._internal_target_version_prefix());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_target_version_display_name(from._internal_target_version_display_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_disallowed_time_intervals(from._internal_disallowed_time_intervals());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_staging_schedule(from._internal_staging_schedule());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_device_quick_fix_build_token(from._internal_device_quick_fix_build_token());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_target_version_selector(from._internal_target_version_selector());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.scatter_factor_in_seconds_ = from._impl_.scatter_factor_in_seconds_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.update_disabled_ = from._impl_.update_disabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.obsolete_reboot_after_update_ = from._impl_.obsolete_reboot_after_update_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.http_downloads_enabled_ = from._impl_.http_downloads_enabled_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.reboot_after_update_ = from._impl_.reboot_after_update_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.p2p_enabled_ = from._impl_.p2p_enabled_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.rollback_allowed_milestones_ = from._impl_.rollback_allowed_milestones_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.rollback_to_target_version_ = from._impl_.rollback_to_target_version_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.channel_downgrade_behavior_ = from._impl_.channel_downgrade_behavior_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutoUpdateSettingsProto::CopyFrom(const AutoUpdateSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AutoUpdateSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoUpdateSettingsProto::IsInitialized() const {
  return true;
}

void AutoUpdateSettingsProto::InternalSwap(AutoUpdateSettingsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.allowed_connection_types_.InternalSwap(&other->_impl_.allowed_connection_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_version_prefix_, lhs_arena,
      &other->_impl_.target_version_prefix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_version_display_name_, lhs_arena,
      &other->_impl_.target_version_display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.disallowed_time_intervals_, lhs_arena,
      &other->_impl_.disallowed_time_intervals_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.staging_schedule_, lhs_arena,
      &other->_impl_.staging_schedule_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_quick_fix_build_token_, lhs_arena,
      &other->_impl_.device_quick_fix_build_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_version_selector_, lhs_arena,
      &other->_impl_.target_version_selector_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutoUpdateSettingsProto, _impl_.rollback_allowed_milestones_)
      + sizeof(AutoUpdateSettingsProto::_impl_.rollback_allowed_milestones_)
      - PROTOBUF_FIELD_OFFSET(AutoUpdateSettingsProto, _impl_.scatter_factor_in_seconds_)>(
          reinterpret_cast<char*>(&_impl_.scatter_factor_in_seconds_),
          reinterpret_cast<char*>(&other->_impl_.scatter_factor_in_seconds_));
  swap(_impl_.rollback_to_target_version_, other->_impl_.rollback_to_target_version_);
  swap(_impl_.channel_downgrade_behavior_, other->_impl_.channel_downgrade_behavior_);
}

std::string AutoUpdateSettingsProto::GetTypeName() const {
  return "enterprise_management.AutoUpdateSettingsProto";
}


// ===================================================================

class OBSOLETE_StartUpUrlsProto::_Internal {
 public:
};

OBSOLETE_StartUpUrlsProto::OBSOLETE_StartUpUrlsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_StartUpUrlsProto)
}
OBSOLETE_StartUpUrlsProto::OBSOLETE_StartUpUrlsProto(const OBSOLETE_StartUpUrlsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_StartUpUrlsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.obsolete_start_up_urls_){from._impl_.obsolete_start_up_urls_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_StartUpUrlsProto)
}

inline void OBSOLETE_StartUpUrlsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.obsolete_start_up_urls_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OBSOLETE_StartUpUrlsProto::~OBSOLETE_StartUpUrlsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_StartUpUrlsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_StartUpUrlsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_start_up_urls_.~RepeatedPtrField();
}

void OBSOLETE_StartUpUrlsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_StartUpUrlsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_StartUpUrlsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.obsolete_start_up_urls_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_StartUpUrlsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string OBSOLETE_start_up_urls = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_obsolete_start_up_urls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_StartUpUrlsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_StartUpUrlsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string OBSOLETE_start_up_urls = 1 [deprecated = true];
  for (int i = 0, n = this->_internal_obsolete_start_up_urls_size(); i < n; i++) {
    const auto& s = this->_internal_obsolete_start_up_urls(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_StartUpUrlsProto)
  return target;
}

size_t OBSOLETE_StartUpUrlsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_StartUpUrlsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string OBSOLETE_start_up_urls = 1 [deprecated = true];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.obsolete_start_up_urls_.size());
  for (int i = 0, n = _impl_.obsolete_start_up_urls_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.obsolete_start_up_urls_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_StartUpUrlsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_StartUpUrlsProto*>(
      &from));
}

void OBSOLETE_StartUpUrlsProto::MergeFrom(const OBSOLETE_StartUpUrlsProto& from) {
  OBSOLETE_StartUpUrlsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_StartUpUrlsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.obsolete_start_up_urls_.MergeFrom(from._impl_.obsolete_start_up_urls_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_StartUpUrlsProto::CopyFrom(const OBSOLETE_StartUpUrlsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_StartUpUrlsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_StartUpUrlsProto::IsInitialized() const {
  return true;
}

void OBSOLETE_StartUpUrlsProto::InternalSwap(OBSOLETE_StartUpUrlsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.obsolete_start_up_urls_.InternalSwap(&other->_impl_.obsolete_start_up_urls_);
}

std::string OBSOLETE_StartUpUrlsProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_StartUpUrlsProto";
}


// ===================================================================

class SystemTimezoneProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemTimezoneProto>()._impl_._has_bits_);
  static void set_has_timezone(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timezone_detection_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SystemTimezoneProto::SystemTimezoneProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SystemTimezoneProto)
}
SystemTimezoneProto::SystemTimezoneProto(const SystemTimezoneProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemTimezoneProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timezone_){}
    , decltype(_impl_.timezone_detection_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timezone()) {
    _this->_impl_.timezone_.Set(from._internal_timezone(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.timezone_detection_type_ = from._impl_.timezone_detection_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SystemTimezoneProto)
}

inline void SystemTimezoneProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timezone_){}
    , decltype(_impl_.timezone_detection_type_){0}
  };
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemTimezoneProto::~SystemTimezoneProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.SystemTimezoneProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemTimezoneProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.timezone_.Destroy();
}

void SystemTimezoneProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemTimezoneProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SystemTimezoneProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.timezone_.ClearNonDefaultToEmpty();
  }
  _impl_.timezone_detection_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemTimezoneProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string timezone = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_timezone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SystemTimezoneProto.AutomaticTimezoneDetectionType timezone_detection_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType_IsValid(val))) {
            _internal_set_timezone_detection_type(static_cast<::enterprise_management::SystemTimezoneProto_AutomaticTimezoneDetectionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemTimezoneProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SystemTimezoneProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string timezone = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_timezone(), target);
  }

  // optional .enterprise_management.SystemTimezoneProto.AutomaticTimezoneDetectionType timezone_detection_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_timezone_detection_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SystemTimezoneProto)
  return target;
}

size_t SystemTimezoneProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SystemTimezoneProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string timezone = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_timezone());
    }

    // optional .enterprise_management.SystemTimezoneProto.AutomaticTimezoneDetectionType timezone_detection_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_timezone_detection_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemTimezoneProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemTimezoneProto*>(
      &from));
}

void SystemTimezoneProto::MergeFrom(const SystemTimezoneProto& from) {
  SystemTimezoneProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SystemTimezoneProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timezone(from._internal_timezone());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timezone_detection_type_ = from._impl_.timezone_detection_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemTimezoneProto::CopyFrom(const SystemTimezoneProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SystemTimezoneProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemTimezoneProto::IsInitialized() const {
  return true;
}

void SystemTimezoneProto::InternalSwap(SystemTimezoneProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.timezone_, lhs_arena,
      &other->_impl_.timezone_, rhs_arena
  );
  swap(_impl_.timezone_detection_type_, other->_impl_.timezone_detection_type_);
}

std::string SystemTimezoneProto::GetTypeName() const {
  return "enterprise_management.SystemTimezoneProto";
}


// ===================================================================

class SystemUse24HourClockProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemUse24HourClockProto>()._impl_._has_bits_);
  static void set_has_use_24hour_clock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SystemUse24HourClockProto::SystemUse24HourClockProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SystemUse24HourClockProto)
}
SystemUse24HourClockProto::SystemUse24HourClockProto(const SystemUse24HourClockProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemUse24HourClockProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.use_24hour_clock_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.use_24hour_clock_ = from._impl_.use_24hour_clock_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SystemUse24HourClockProto)
}

inline void SystemUse24HourClockProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.use_24hour_clock_){false}
  };
}

SystemUse24HourClockProto::~SystemUse24HourClockProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.SystemUse24HourClockProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemUse24HourClockProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemUse24HourClockProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemUse24HourClockProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SystemUse24HourClockProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.use_24hour_clock_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemUse24HourClockProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool use_24hour_clock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_use_24hour_clock(&has_bits);
          _impl_.use_24hour_clock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemUse24HourClockProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SystemUse24HourClockProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool use_24hour_clock = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_use_24hour_clock(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SystemUse24HourClockProto)
  return target;
}

size_t SystemUse24HourClockProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SystemUse24HourClockProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool use_24hour_clock = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemUse24HourClockProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemUse24HourClockProto*>(
      &from));
}

void SystemUse24HourClockProto::MergeFrom(const SystemUse24HourClockProto& from) {
  SystemUse24HourClockProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SystemUse24HourClockProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_use_24hour_clock()) {
    _this->_internal_set_use_24hour_clock(from._internal_use_24hour_clock());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemUse24HourClockProto::CopyFrom(const SystemUse24HourClockProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SystemUse24HourClockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemUse24HourClockProto::IsInitialized() const {
  return true;
}

void SystemUse24HourClockProto::InternalSwap(SystemUse24HourClockProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.use_24hour_clock_, other->_impl_.use_24hour_clock_);
}

std::string SystemUse24HourClockProto::GetTypeName() const {
  return "enterprise_management.SystemUse24HourClockProto";
}


// ===================================================================

class KioskAppInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<KioskAppInfoProto>()._impl_._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_update_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KioskAppInfoProto::KioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.KioskAppInfoProto)
}
KioskAppInfoProto::KioskAppInfoProto(const KioskAppInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KioskAppInfoProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.update_url_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_id()) {
    _this->_impl_.app_id_.Set(from._internal_app_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.update_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.update_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_update_url()) {
    _this->_impl_.update_url_.Set(from._internal_update_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.KioskAppInfoProto)
}

inline void KioskAppInfoProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.update_url_){}
  };
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.update_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.update_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KioskAppInfoProto::~KioskAppInfoProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.KioskAppInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KioskAppInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.app_id_.Destroy();
  _impl_.update_url_.Destroy();
}

void KioskAppInfoProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KioskAppInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.KioskAppInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.app_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.update_url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KioskAppInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string update_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_update_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KioskAppInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.KioskAppInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app_id(), target);
  }

  // optional string update_url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_update_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.KioskAppInfoProto)
  return target;
}

size_t KioskAppInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.KioskAppInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string app_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_id());
    }

    // optional string update_url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_update_url());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KioskAppInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KioskAppInfoProto*>(
      &from));
}

void KioskAppInfoProto::MergeFrom(const KioskAppInfoProto& from) {
  KioskAppInfoProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.KioskAppInfoProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_app_id(from._internal_app_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_update_url(from._internal_update_url());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KioskAppInfoProto::CopyFrom(const KioskAppInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.KioskAppInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KioskAppInfoProto::IsInitialized() const {
  return true;
}

void KioskAppInfoProto::InternalSwap(KioskAppInfoProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_id_, lhs_arena,
      &other->_impl_.app_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.update_url_, lhs_arena,
      &other->_impl_.update_url_, rhs_arena
  );
}

std::string KioskAppInfoProto::GetTypeName() const {
  return "enterprise_management.KioskAppInfoProto";
}


// ===================================================================

class AndroidKioskAppInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AndroidKioskAppInfoProto>()._impl_._has_bits_);
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_class_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_display_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

AndroidKioskAppInfoProto::AndroidKioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AndroidKioskAppInfoProto)
}
AndroidKioskAppInfoProto::AndroidKioskAppInfoProto(const AndroidKioskAppInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AndroidKioskAppInfoProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_name_){}
    , decltype(_impl_.class_name_){}
    , decltype(_impl_.action_){}
    , decltype(_impl_.display_name_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_name()) {
    _this->_impl_.package_name_.Set(from._internal_package_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.class_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_class_name()) {
    _this->_impl_.class_name_.Set(from._internal_class_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action()) {
    _this->_impl_.action_.Set(from._internal_action(), 
      _this->GetArenaForAllocation());
  }
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_display_name()) {
    _this->_impl_.display_name_.Set(from._internal_display_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AndroidKioskAppInfoProto)
}

inline void AndroidKioskAppInfoProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_name_){}
    , decltype(_impl_.class_name_){}
    , decltype(_impl_.action_){}
    , decltype(_impl_.display_name_){}
  };
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.class_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AndroidKioskAppInfoProto::~AndroidKioskAppInfoProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AndroidKioskAppInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AndroidKioskAppInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.package_name_.Destroy();
  _impl_.class_name_.Destroy();
  _impl_.action_.Destroy();
  _impl_.display_name_.Destroy();
}

void AndroidKioskAppInfoProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AndroidKioskAppInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AndroidKioskAppInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.package_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.class_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.action_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.display_name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AndroidKioskAppInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string package_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_package_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string class_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string action = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_action();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string display_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AndroidKioskAppInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AndroidKioskAppInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string package_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_package_name(), target);
  }

  // optional string class_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_name(), target);
  }

  // optional string action = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_action(), target);
  }

  // optional string display_name = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_display_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AndroidKioskAppInfoProto)
  return target;
}

size_t AndroidKioskAppInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AndroidKioskAppInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string package_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_name());
    }

    // optional string class_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_class_name());
    }

    // optional string action = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_action());
    }

    // optional string display_name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_display_name());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AndroidKioskAppInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AndroidKioskAppInfoProto*>(
      &from));
}

void AndroidKioskAppInfoProto::MergeFrom(const AndroidKioskAppInfoProto& from) {
  AndroidKioskAppInfoProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AndroidKioskAppInfoProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_package_name(from._internal_package_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_class_name(from._internal_class_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_action(from._internal_action());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_display_name(from._internal_display_name());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AndroidKioskAppInfoProto::CopyFrom(const AndroidKioskAppInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AndroidKioskAppInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AndroidKioskAppInfoProto::IsInitialized() const {
  return true;
}

void AndroidKioskAppInfoProto::InternalSwap(AndroidKioskAppInfoProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.package_name_, lhs_arena,
      &other->_impl_.package_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class_name_, lhs_arena,
      &other->_impl_.class_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.action_, lhs_arena,
      &other->_impl_.action_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_name_, lhs_arena,
      &other->_impl_.display_name_, rhs_arena
  );
}

std::string AndroidKioskAppInfoProto::GetTypeName() const {
  return "enterprise_management.AndroidKioskAppInfoProto";
}


// ===================================================================

class WebKioskAppInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<WebKioskAppInfoProto>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_icon_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

WebKioskAppInfoProto::WebKioskAppInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.WebKioskAppInfoProto)
}
WebKioskAppInfoProto::WebKioskAppInfoProto(const WebKioskAppInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WebKioskAppInfoProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.icon_url_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.icon_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_icon_url()) {
    _this->_impl_.icon_url_.Set(from._internal_icon_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.WebKioskAppInfoProto)
}

inline void WebKioskAppInfoProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.icon_url_){}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.icon_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WebKioskAppInfoProto::~WebKioskAppInfoProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.WebKioskAppInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WebKioskAppInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
  _impl_.title_.Destroy();
  _impl_.icon_url_.Destroy();
}

void WebKioskAppInfoProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WebKioskAppInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.WebKioskAppInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.icon_url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WebKioskAppInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string icon_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_icon_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WebKioskAppInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.WebKioskAppInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional string title = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // optional string icon_url = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_icon_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.WebKioskAppInfoProto)
  return target;
}

size_t WebKioskAppInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.WebKioskAppInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string title = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string icon_url = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_icon_url());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WebKioskAppInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WebKioskAppInfoProto*>(
      &from));
}

void WebKioskAppInfoProto::MergeFrom(const WebKioskAppInfoProto& from) {
  WebKioskAppInfoProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.WebKioskAppInfoProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_icon_url(from._internal_icon_url());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebKioskAppInfoProto::CopyFrom(const WebKioskAppInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.WebKioskAppInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WebKioskAppInfoProto::IsInitialized() const {
  return true;
}

void WebKioskAppInfoProto::InternalSwap(WebKioskAppInfoProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.icon_url_, lhs_arena,
      &other->_impl_.icon_url_, rhs_arena
  );
}

std::string WebKioskAppInfoProto::GetTypeName() const {
  return "enterprise_management.WebKioskAppInfoProto";
}


// ===================================================================

class DeviceLocalAccountInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceLocalAccountInfoProto>()._impl_._has_bits_);
  static void set_has_deprecated_public_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::enterprise_management::KioskAppInfoProto& kiosk_app(const DeviceLocalAccountInfoProto* msg);
  static void set_has_kiosk_app(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::AndroidKioskAppInfoProto& android_kiosk_app(const DeviceLocalAccountInfoProto* msg);
  static void set_has_android_kiosk_app(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::enterprise_management::WebKioskAppInfoProto& web_kiosk_app(const DeviceLocalAccountInfoProto* msg);
  static void set_has_web_kiosk_app(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::enterprise_management::KioskAppInfoProto&
DeviceLocalAccountInfoProto::_Internal::kiosk_app(const DeviceLocalAccountInfoProto* msg) {
  return *msg->_impl_.kiosk_app_;
}
const ::enterprise_management::AndroidKioskAppInfoProto&
DeviceLocalAccountInfoProto::_Internal::android_kiosk_app(const DeviceLocalAccountInfoProto* msg) {
  return *msg->_impl_.android_kiosk_app_;
}
const ::enterprise_management::WebKioskAppInfoProto&
DeviceLocalAccountInfoProto::_Internal::web_kiosk_app(const DeviceLocalAccountInfoProto* msg) {
  return *msg->_impl_.web_kiosk_app_;
}
DeviceLocalAccountInfoProto::DeviceLocalAccountInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceLocalAccountInfoProto)
}
DeviceLocalAccountInfoProto::DeviceLocalAccountInfoProto(const DeviceLocalAccountInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceLocalAccountInfoProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.deprecated_public_session_id_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.kiosk_app_){nullptr}
    , decltype(_impl_.android_kiosk_app_){nullptr}
    , decltype(_impl_.web_kiosk_app_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.deprecated_public_session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_public_session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_deprecated_public_session_id()) {
    _this->_impl_.deprecated_public_session_id_.Set(from._internal_deprecated_public_session_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_id()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_kiosk_app()) {
    _this->_impl_.kiosk_app_ = new ::enterprise_management::KioskAppInfoProto(*from._impl_.kiosk_app_);
  }
  if (from._internal_has_android_kiosk_app()) {
    _this->_impl_.android_kiosk_app_ = new ::enterprise_management::AndroidKioskAppInfoProto(*from._impl_.android_kiosk_app_);
  }
  if (from._internal_has_web_kiosk_app()) {
    _this->_impl_.web_kiosk_app_ = new ::enterprise_management::WebKioskAppInfoProto(*from._impl_.web_kiosk_app_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceLocalAccountInfoProto)
}

inline void DeviceLocalAccountInfoProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.deprecated_public_session_id_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.kiosk_app_){nullptr}
    , decltype(_impl_.android_kiosk_app_){nullptr}
    , decltype(_impl_.web_kiosk_app_){nullptr}
    , decltype(_impl_.type_){0}
  };
  _impl_.deprecated_public_session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_public_session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceLocalAccountInfoProto::~DeviceLocalAccountInfoProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceLocalAccountInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLocalAccountInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.deprecated_public_session_id_.Destroy();
  _impl_.account_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.kiosk_app_;
  if (this != internal_default_instance()) delete _impl_.android_kiosk_app_;
  if (this != internal_default_instance()) delete _impl_.web_kiosk_app_;
}

void DeviceLocalAccountInfoProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLocalAccountInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceLocalAccountInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.deprecated_public_session_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.account_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.kiosk_app_ != nullptr);
      _impl_.kiosk_app_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.android_kiosk_app_ != nullptr);
      _impl_.android_kiosk_app_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.web_kiosk_app_ != nullptr);
      _impl_.web_kiosk_app_->Clear();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceLocalAccountInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string deprecated_public_session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_deprecated_public_session_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceLocalAccountInfoProto.AccountType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceLocalAccountInfoProto_AccountType_IsValid(val))) {
            _internal_set_type(static_cast<::enterprise_management::DeviceLocalAccountInfoProto_AccountType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.KioskAppInfoProto kiosk_app = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_kiosk_app(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AndroidKioskAppInfoProto android_kiosk_app = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_android_kiosk_app(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.WebKioskAppInfoProto web_kiosk_app = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_web_kiosk_app(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLocalAccountInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceLocalAccountInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string deprecated_public_session_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_deprecated_public_session_id(), target);
  }

  // optional string account_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_account_id(), target);
  }

  // optional .enterprise_management.DeviceLocalAccountInfoProto.AccountType type = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // optional .enterprise_management.KioskAppInfoProto kiosk_app = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::kiosk_app(this),
        _Internal::kiosk_app(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AndroidKioskAppInfoProto android_kiosk_app = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::android_kiosk_app(this),
        _Internal::android_kiosk_app(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.WebKioskAppInfoProto web_kiosk_app = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::web_kiosk_app(this),
        _Internal::web_kiosk_app(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceLocalAccountInfoProto)
  return target;
}

size_t DeviceLocalAccountInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceLocalAccountInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string deprecated_public_session_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_deprecated_public_session_id());
    }

    // optional string account_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_account_id());
    }

    // optional .enterprise_management.KioskAppInfoProto kiosk_app = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kiosk_app_);
    }

    // optional .enterprise_management.AndroidKioskAppInfoProto android_kiosk_app = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.android_kiosk_app_);
    }

    // optional .enterprise_management.WebKioskAppInfoProto web_kiosk_app = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.web_kiosk_app_);
    }

    // optional .enterprise_management.DeviceLocalAccountInfoProto.AccountType type = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceLocalAccountInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceLocalAccountInfoProto*>(
      &from));
}

void DeviceLocalAccountInfoProto::MergeFrom(const DeviceLocalAccountInfoProto& from) {
  DeviceLocalAccountInfoProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceLocalAccountInfoProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_deprecated_public_session_id(from._internal_deprecated_public_session_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_account_id(from._internal_account_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_kiosk_app()->::enterprise_management::KioskAppInfoProto::MergeFrom(
          from._internal_kiosk_app());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_android_kiosk_app()->::enterprise_management::AndroidKioskAppInfoProto::MergeFrom(
          from._internal_android_kiosk_app());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_web_kiosk_app()->::enterprise_management::WebKioskAppInfoProto::MergeFrom(
          from._internal_web_kiosk_app());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceLocalAccountInfoProto::CopyFrom(const DeviceLocalAccountInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceLocalAccountInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLocalAccountInfoProto::IsInitialized() const {
  return true;
}

void DeviceLocalAccountInfoProto::InternalSwap(DeviceLocalAccountInfoProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.deprecated_public_session_id_, lhs_arena,
      &other->_impl_.deprecated_public_session_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_id_, lhs_arena,
      &other->_impl_.account_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceLocalAccountInfoProto, _impl_.type_)
      + sizeof(DeviceLocalAccountInfoProto::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(DeviceLocalAccountInfoProto, _impl_.kiosk_app_)>(
          reinterpret_cast<char*>(&_impl_.kiosk_app_),
          reinterpret_cast<char*>(&other->_impl_.kiosk_app_));
}

std::string DeviceLocalAccountInfoProto::GetTypeName() const {
  return "enterprise_management.DeviceLocalAccountInfoProto";
}


// ===================================================================

class DeviceLocalAccountsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceLocalAccountsProto>()._impl_._has_bits_);
  static void set_has_auto_login_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auto_login_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enable_auto_login_bailout(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prompt_for_network_when_offline(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DeviceLocalAccountsProto::DeviceLocalAccountsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceLocalAccountsProto)
}
DeviceLocalAccountsProto::DeviceLocalAccountsProto(const DeviceLocalAccountsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceLocalAccountsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_){from._impl_.account_}
    , decltype(_impl_.auto_login_id_){}
    , decltype(_impl_.auto_login_delay_){}
    , decltype(_impl_.enable_auto_login_bailout_){}
    , decltype(_impl_.prompt_for_network_when_offline_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.auto_login_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auto_login_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auto_login_id()) {
    _this->_impl_.auto_login_id_.Set(from._internal_auto_login_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.auto_login_delay_, &from._impl_.auto_login_delay_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prompt_for_network_when_offline_) -
    reinterpret_cast<char*>(&_impl_.auto_login_delay_)) + sizeof(_impl_.prompt_for_network_when_offline_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceLocalAccountsProto)
}

inline void DeviceLocalAccountsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_){arena}
    , decltype(_impl_.auto_login_id_){}
    , decltype(_impl_.auto_login_delay_){int64_t{0}}
    , decltype(_impl_.enable_auto_login_bailout_){true}
    , decltype(_impl_.prompt_for_network_when_offline_){true}
  };
  _impl_.auto_login_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auto_login_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceLocalAccountsProto::~DeviceLocalAccountsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceLocalAccountsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLocalAccountsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_.~RepeatedPtrField();
  _impl_.auto_login_id_.Destroy();
}

void DeviceLocalAccountsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLocalAccountsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceLocalAccountsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.auto_login_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    _impl_.auto_login_delay_ = int64_t{0};
    _impl_.enable_auto_login_bailout_ = true;
    _impl_.prompt_for_network_when_offline_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceLocalAccountsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.DeviceLocalAccountInfoProto account = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_account(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string auto_login_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_auto_login_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 auto_login_delay = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_auto_login_delay(&has_bits);
          _impl_.auto_login_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_auto_login_bailout = 4 [default = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_enable_auto_login_bailout(&has_bits);
          _impl_.enable_auto_login_bailout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool prompt_for_network_when_offline = 5 [default = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_prompt_for_network_when_offline(&has_bits);
          _impl_.prompt_for_network_when_offline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLocalAccountsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceLocalAccountsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.DeviceLocalAccountInfoProto account = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_account_size()); i < n; i++) {
    const auto& repfield = this->_internal_account(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string auto_login_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_auto_login_id(), target);
  }

  // optional int64 auto_login_delay = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_auto_login_delay(), target);
  }

  // optional bool enable_auto_login_bailout = 4 [default = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_enable_auto_login_bailout(), target);
  }

  // optional bool prompt_for_network_when_offline = 5 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_prompt_for_network_when_offline(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceLocalAccountsProto)
  return target;
}

size_t DeviceLocalAccountsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceLocalAccountsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.DeviceLocalAccountInfoProto account = 1;
  total_size += 1UL * this->_internal_account_size();
  for (const auto& msg : this->_impl_.account_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string auto_login_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_auto_login_id());
    }

    // optional int64 auto_login_delay = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_auto_login_delay());
    }

    // optional bool enable_auto_login_bailout = 4 [default = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool prompt_for_network_when_offline = 5 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceLocalAccountsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceLocalAccountsProto*>(
      &from));
}

void DeviceLocalAccountsProto::MergeFrom(const DeviceLocalAccountsProto& from) {
  DeviceLocalAccountsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceLocalAccountsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.account_.MergeFrom(from._impl_.account_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_auto_login_id(from._internal_auto_login_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.auto_login_delay_ = from._impl_.auto_login_delay_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.enable_auto_login_bailout_ = from._impl_.enable_auto_login_bailout_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.prompt_for_network_when_offline_ = from._impl_.prompt_for_network_when_offline_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceLocalAccountsProto::CopyFrom(const DeviceLocalAccountsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceLocalAccountsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLocalAccountsProto::IsInitialized() const {
  return true;
}

void DeviceLocalAccountsProto::InternalSwap(DeviceLocalAccountsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.account_.InternalSwap(&other->_impl_.account_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auto_login_id_, lhs_arena,
      &other->_impl_.auto_login_id_, rhs_arena
  );
  swap(_impl_.auto_login_delay_, other->_impl_.auto_login_delay_);
  swap(_impl_.enable_auto_login_bailout_, other->_impl_.enable_auto_login_bailout_);
  swap(_impl_.prompt_for_network_when_offline_, other->_impl_.prompt_for_network_when_offline_);
}

std::string DeviceLocalAccountsProto::GetTypeName() const {
  return "enterprise_management.DeviceLocalAccountsProto";
}


// ===================================================================

class ManagedGuestSessionPrivacyWarningsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ManagedGuestSessionPrivacyWarningsProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ManagedGuestSessionPrivacyWarningsProto::ManagedGuestSessionPrivacyWarningsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
}
ManagedGuestSessionPrivacyWarningsProto::ManagedGuestSessionPrivacyWarningsProto(const ManagedGuestSessionPrivacyWarningsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ManagedGuestSessionPrivacyWarningsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
}

inline void ManagedGuestSessionPrivacyWarningsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){true}
  };
}

ManagedGuestSessionPrivacyWarningsProto::~ManagedGuestSessionPrivacyWarningsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ManagedGuestSessionPrivacyWarningsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ManagedGuestSessionPrivacyWarningsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ManagedGuestSessionPrivacyWarningsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ManagedGuestSessionPrivacyWarningsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ManagedGuestSessionPrivacyWarningsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
  return target;
}

size_t ManagedGuestSessionPrivacyWarningsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ManagedGuestSessionPrivacyWarningsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ManagedGuestSessionPrivacyWarningsProto*>(
      &from));
}

void ManagedGuestSessionPrivacyWarningsProto::MergeFrom(const ManagedGuestSessionPrivacyWarningsProto& from) {
  ManagedGuestSessionPrivacyWarningsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ManagedGuestSessionPrivacyWarningsProto::CopyFrom(const ManagedGuestSessionPrivacyWarningsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ManagedGuestSessionPrivacyWarningsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ManagedGuestSessionPrivacyWarningsProto::IsInitialized() const {
  return true;
}

void ManagedGuestSessionPrivacyWarningsProto::InternalSwap(ManagedGuestSessionPrivacyWarningsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string ManagedGuestSessionPrivacyWarningsProto::GetTypeName() const {
  return "enterprise_management.ManagedGuestSessionPrivacyWarningsProto";
}


// ===================================================================

class AllowRedeemChromeOsRegistrationOffersProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AllowRedeemChromeOsRegistrationOffersProto>()._impl_._has_bits_);
  static void set_has_allow_redeem_offers(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AllowRedeemChromeOsRegistrationOffersProto::AllowRedeemChromeOsRegistrationOffersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
}
AllowRedeemChromeOsRegistrationOffersProto::AllowRedeemChromeOsRegistrationOffersProto(const AllowRedeemChromeOsRegistrationOffersProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllowRedeemChromeOsRegistrationOffersProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_redeem_offers_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.allow_redeem_offers_ = from._impl_.allow_redeem_offers_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
}

inline void AllowRedeemChromeOsRegistrationOffersProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_redeem_offers_){true}
  };
}

AllowRedeemChromeOsRegistrationOffersProto::~AllowRedeemChromeOsRegistrationOffersProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllowRedeemChromeOsRegistrationOffersProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllowRedeemChromeOsRegistrationOffersProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllowRedeemChromeOsRegistrationOffersProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allow_redeem_offers_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllowRedeemChromeOsRegistrationOffersProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allow_redeem_offers = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allow_redeem_offers(&has_bits);
          _impl_.allow_redeem_offers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllowRedeemChromeOsRegistrationOffersProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool allow_redeem_offers = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allow_redeem_offers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
  return target;
}

size_t AllowRedeemChromeOsRegistrationOffersProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool allow_redeem_offers = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllowRedeemChromeOsRegistrationOffersProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllowRedeemChromeOsRegistrationOffersProto*>(
      &from));
}

void AllowRedeemChromeOsRegistrationOffersProto::MergeFrom(const AllowRedeemChromeOsRegistrationOffersProto& from) {
  AllowRedeemChromeOsRegistrationOffersProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_allow_redeem_offers()) {
    _this->_internal_set_allow_redeem_offers(from._internal_allow_redeem_offers());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllowRedeemChromeOsRegistrationOffersProto::CopyFrom(const AllowRedeemChromeOsRegistrationOffersProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AllowRedeemChromeOsRegistrationOffersProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllowRedeemChromeOsRegistrationOffersProto::IsInitialized() const {
  return true;
}

void AllowRedeemChromeOsRegistrationOffersProto::InternalSwap(AllowRedeemChromeOsRegistrationOffersProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.allow_redeem_offers_, other->_impl_.allow_redeem_offers_);
}

std::string AllowRedeemChromeOsRegistrationOffersProto::GetTypeName() const {
  return "enterprise_management.AllowRedeemChromeOsRegistrationOffersProto";
}


// ===================================================================

class FeatureFlagsProto::_Internal {
 public:
};

FeatureFlagsProto::FeatureFlagsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.FeatureFlagsProto)
}
FeatureFlagsProto::FeatureFlagsProto(const FeatureFlagsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FeatureFlagsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.switches_){from._impl_.switches_}
    , decltype(_impl_.feature_flags_){from._impl_.feature_flags_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.FeatureFlagsProto)
}

inline void FeatureFlagsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.switches_){arena}
    , decltype(_impl_.feature_flags_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeatureFlagsProto::~FeatureFlagsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.FeatureFlagsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeatureFlagsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.switches_.~RepeatedPtrField();
  _impl_.feature_flags_.~RepeatedPtrField();
}

void FeatureFlagsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeatureFlagsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.FeatureFlagsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.switches_.Clear();
  _impl_.feature_flags_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FeatureFlagsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string switches = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_switches();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string feature_flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_feature_flags();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeatureFlagsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.FeatureFlagsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string switches = 1 [deprecated = true];
  for (int i = 0, n = this->_internal_switches_size(); i < n; i++) {
    const auto& s = this->_internal_switches(i);
    target = stream->WriteString(1, s, target);
  }

  // repeated string feature_flags = 2;
  for (int i = 0, n = this->_internal_feature_flags_size(); i < n; i++) {
    const auto& s = this->_internal_feature_flags(i);
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.FeatureFlagsProto)
  return target;
}

size_t FeatureFlagsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.FeatureFlagsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string switches = 1 [deprecated = true];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.switches_.size());
  for (int i = 0, n = _impl_.switches_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.switches_.Get(i));
  }

  // repeated string feature_flags = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.feature_flags_.size());
  for (int i = 0, n = _impl_.feature_flags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.feature_flags_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FeatureFlagsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FeatureFlagsProto*>(
      &from));
}

void FeatureFlagsProto::MergeFrom(const FeatureFlagsProto& from) {
  FeatureFlagsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.FeatureFlagsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.switches_.MergeFrom(from._impl_.switches_);
  _this->_impl_.feature_flags_.MergeFrom(from._impl_.feature_flags_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FeatureFlagsProto::CopyFrom(const FeatureFlagsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.FeatureFlagsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureFlagsProto::IsInitialized() const {
  return true;
}

void FeatureFlagsProto::InternalSwap(FeatureFlagsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.switches_.InternalSwap(&other->_impl_.switches_);
  _impl_.feature_flags_.InternalSwap(&other->_impl_.feature_flags_);
}

std::string FeatureFlagsProto::GetTypeName() const {
  return "enterprise_management.FeatureFlagsProto";
}


// ===================================================================

class UptimeLimitProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UptimeLimitProto>()._impl_._has_bits_);
  static void set_has_obsolete_uptime_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uptime_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UptimeLimitProto::UptimeLimitProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UptimeLimitProto)
}
UptimeLimitProto::UptimeLimitProto(const UptimeLimitProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UptimeLimitProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_uptime_limit_){}
    , decltype(_impl_.uptime_limit_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.obsolete_uptime_limit_, &from._impl_.obsolete_uptime_limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.uptime_limit_) -
    reinterpret_cast<char*>(&_impl_.obsolete_uptime_limit_)) + sizeof(_impl_.uptime_limit_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UptimeLimitProto)
}

inline void UptimeLimitProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_uptime_limit_){int64_t{0}}
    , decltype(_impl_.uptime_limit_){int64_t{0}}
  };
}

UptimeLimitProto::~UptimeLimitProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.UptimeLimitProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UptimeLimitProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UptimeLimitProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UptimeLimitProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UptimeLimitProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.obsolete_uptime_limit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.uptime_limit_) -
        reinterpret_cast<char*>(&_impl_.obsolete_uptime_limit_)) + sizeof(_impl_.uptime_limit_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UptimeLimitProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 OBSOLETE_uptime_limit = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_obsolete_uptime_limit(&has_bits);
          _impl_.obsolete_uptime_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 uptime_limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_uptime_limit(&has_bits);
          _impl_.uptime_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UptimeLimitProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UptimeLimitProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 OBSOLETE_uptime_limit = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_obsolete_uptime_limit(), target);
  }

  // optional int64 uptime_limit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_uptime_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UptimeLimitProto)
  return target;
}

size_t UptimeLimitProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UptimeLimitProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 OBSOLETE_uptime_limit = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_obsolete_uptime_limit());
    }

    // optional int64 uptime_limit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_uptime_limit());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UptimeLimitProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UptimeLimitProto*>(
      &from));
}

void UptimeLimitProto::MergeFrom(const UptimeLimitProto& from) {
  UptimeLimitProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UptimeLimitProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.obsolete_uptime_limit_ = from._impl_.obsolete_uptime_limit_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.uptime_limit_ = from._impl_.uptime_limit_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UptimeLimitProto::CopyFrom(const UptimeLimitProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UptimeLimitProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UptimeLimitProto::IsInitialized() const {
  return true;
}

void UptimeLimitProto::InternalSwap(UptimeLimitProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UptimeLimitProto, _impl_.uptime_limit_)
      + sizeof(UptimeLimitProto::_impl_.uptime_limit_)
      - PROTOBUF_FIELD_OFFSET(UptimeLimitProto, _impl_.obsolete_uptime_limit_)>(
          reinterpret_cast<char*>(&_impl_.obsolete_uptime_limit_),
          reinterpret_cast<char*>(&other->_impl_.obsolete_uptime_limit_));
}

std::string UptimeLimitProto::GetTypeName() const {
  return "enterprise_management.UptimeLimitProto";
}


// ===================================================================

class VariationsParameterProto::_Internal {
 public:
  using HasBits = decltype(std::declval<VariationsParameterProto>()._impl_._has_bits_);
  static void set_has_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

VariationsParameterProto::VariationsParameterProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.VariationsParameterProto)
}
VariationsParameterProto::VariationsParameterProto(const VariationsParameterProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VariationsParameterProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parameter_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.parameter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parameter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_parameter()) {
    _this->_impl_.parameter_.Set(from._internal_parameter(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.VariationsParameterProto)
}

inline void VariationsParameterProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parameter_){}
  };
  _impl_.parameter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parameter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VariationsParameterProto::~VariationsParameterProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.VariationsParameterProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VariationsParameterProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parameter_.Destroy();
}

void VariationsParameterProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VariationsParameterProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.VariationsParameterProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.parameter_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VariationsParameterProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string parameter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parameter();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VariationsParameterProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.VariationsParameterProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string parameter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parameter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.VariationsParameterProto)
  return target;
}

size_t VariationsParameterProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.VariationsParameterProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string parameter = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parameter());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VariationsParameterProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VariationsParameterProto*>(
      &from));
}

void VariationsParameterProto::MergeFrom(const VariationsParameterProto& from) {
  VariationsParameterProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.VariationsParameterProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_parameter()) {
    _this->_internal_set_parameter(from._internal_parameter());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VariationsParameterProto::CopyFrom(const VariationsParameterProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.VariationsParameterProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VariationsParameterProto::IsInitialized() const {
  return true;
}

void VariationsParameterProto::InternalSwap(VariationsParameterProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parameter_, lhs_arena,
      &other->_impl_.parameter_, rhs_arena
  );
}

std::string VariationsParameterProto::GetTypeName() const {
  return "enterprise_management.VariationsParameterProto";
}


// ===================================================================

class AttestationSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AttestationSettingsProto>()._impl_._has_bits_);
  static void set_has_attestation_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_content_protection_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AttestationSettingsProto::AttestationSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AttestationSettingsProto)
}
AttestationSettingsProto::AttestationSettingsProto(const AttestationSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AttestationSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attestation_enabled_){}
    , decltype(_impl_.content_protection_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.attestation_enabled_, &from._impl_.attestation_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.content_protection_enabled_) -
    reinterpret_cast<char*>(&_impl_.attestation_enabled_)) + sizeof(_impl_.content_protection_enabled_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AttestationSettingsProto)
}

inline void AttestationSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attestation_enabled_){false}
    , decltype(_impl_.content_protection_enabled_){true}
  };
}

AttestationSettingsProto::~AttestationSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AttestationSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AttestationSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AttestationSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AttestationSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AttestationSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.attestation_enabled_ = false;
    _impl_.content_protection_enabled_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AttestationSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool attestation_enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_attestation_enabled(&has_bits);
          _impl_.attestation_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool content_protection_enabled = 2 [default = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_content_protection_enabled(&has_bits);
          _impl_.content_protection_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AttestationSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AttestationSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool attestation_enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_attestation_enabled(), target);
  }

  // optional bool content_protection_enabled = 2 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_content_protection_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AttestationSettingsProto)
  return target;
}

size_t AttestationSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AttestationSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool attestation_enabled = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool content_protection_enabled = 2 [default = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AttestationSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AttestationSettingsProto*>(
      &from));
}

void AttestationSettingsProto::MergeFrom(const AttestationSettingsProto& from) {
  AttestationSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AttestationSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.attestation_enabled_ = from._impl_.attestation_enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.content_protection_enabled_ = from._impl_.content_protection_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AttestationSettingsProto::CopyFrom(const AttestationSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AttestationSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttestationSettingsProto::IsInitialized() const {
  return true;
}

void AttestationSettingsProto::InternalSwap(AttestationSettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.attestation_enabled_, other->_impl_.attestation_enabled_);
  swap(_impl_.content_protection_enabled_, other->_impl_.content_protection_enabled_);
}

std::string AttestationSettingsProto::GetTypeName() const {
  return "enterprise_management.AttestationSettingsProto";
}


// ===================================================================

class AccessibilitySettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AccessibilitySettingsProto>()._impl_._has_bits_);
  static void set_has_login_screen_default_large_cursor_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_login_screen_default_spoken_feedback_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_login_screen_default_high_contrast_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_login_screen_default_screen_magnifier_type(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_login_screen_default_virtual_keyboard_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_login_screen_large_cursor_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_large_cursor_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_large_cursor_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_login_screen_spoken_feedback_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_spoken_feedback_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_spoken_feedback_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_login_screen_high_contrast_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_high_contrast_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_high_contrast_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_login_screen_virtual_keyboard_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_virtual_keyboard_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_virtual_keyboard_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_login_screen_dictation_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_dictation_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_dictation_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_login_screen_select_to_speak_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_select_to_speak_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_select_to_speak_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_login_screen_cursor_highlight_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_cursor_highlight_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_cursor_highlight_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_login_screen_caret_highlight_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_caret_highlight_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_caret_highlight_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_login_screen_mono_audio_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_mono_audio_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_mono_audio_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_login_screen_autoclick_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_autoclick_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_autoclick_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_login_screen_sticky_keys_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_sticky_keys_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_sticky_keys_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_login_screen_keyboard_focus_highlight_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_keyboard_focus_highlight_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_keyboard_focus_highlight_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_login_screen_screen_magnifier_type(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_screen_magnifier_type_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_screen_magnifier_type_options(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_login_screen_show_options_in_system_tray_menu_enabled(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_show_options_in_system_tray_menu_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_show_options_in_system_tray_menu_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_login_screen_shortcuts_enabled(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::enterprise_management::PolicyOptions& login_screen_shortcuts_enabled_options(const AccessibilitySettingsProto* msg);
  static void set_has_login_screen_shortcuts_enabled_options(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_large_cursor_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_large_cursor_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_spoken_feedback_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_spoken_feedback_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_high_contrast_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_high_contrast_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_virtual_keyboard_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_virtual_keyboard_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_dictation_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_dictation_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_select_to_speak_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_select_to_speak_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_cursor_highlight_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_cursor_highlight_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_caret_highlight_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_caret_highlight_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_mono_audio_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_mono_audio_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_autoclick_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_autoclick_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_sticky_keys_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_sticky_keys_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_keyboard_focus_highlight_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_keyboard_focus_highlight_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_screen_magnifier_type_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_screen_magnifier_type_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_show_options_in_system_tray_menu_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_;
}
const ::enterprise_management::PolicyOptions&
AccessibilitySettingsProto::_Internal::login_screen_shortcuts_enabled_options(const AccessibilitySettingsProto* msg) {
  return *msg->_impl_.login_screen_shortcuts_enabled_options_;
}
void AccessibilitySettingsProto::clear_login_screen_large_cursor_enabled_options() {
  if (_impl_.login_screen_large_cursor_enabled_options_ != nullptr) _impl_.login_screen_large_cursor_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void AccessibilitySettingsProto::clear_login_screen_spoken_feedback_enabled_options() {
  if (_impl_.login_screen_spoken_feedback_enabled_options_ != nullptr) _impl_.login_screen_spoken_feedback_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void AccessibilitySettingsProto::clear_login_screen_high_contrast_enabled_options() {
  if (_impl_.login_screen_high_contrast_enabled_options_ != nullptr) _impl_.login_screen_high_contrast_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void AccessibilitySettingsProto::clear_login_screen_virtual_keyboard_enabled_options() {
  if (_impl_.login_screen_virtual_keyboard_enabled_options_ != nullptr) _impl_.login_screen_virtual_keyboard_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void AccessibilitySettingsProto::clear_login_screen_dictation_enabled_options() {
  if (_impl_.login_screen_dictation_enabled_options_ != nullptr) _impl_.login_screen_dictation_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void AccessibilitySettingsProto::clear_login_screen_select_to_speak_enabled_options() {
  if (_impl_.login_screen_select_to_speak_enabled_options_ != nullptr) _impl_.login_screen_select_to_speak_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void AccessibilitySettingsProto::clear_login_screen_cursor_highlight_enabled_options() {
  if (_impl_.login_screen_cursor_highlight_enabled_options_ != nullptr) _impl_.login_screen_cursor_highlight_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void AccessibilitySettingsProto::clear_login_screen_caret_highlight_enabled_options() {
  if (_impl_.login_screen_caret_highlight_enabled_options_ != nullptr) _impl_.login_screen_caret_highlight_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void AccessibilitySettingsProto::clear_login_screen_mono_audio_enabled_options() {
  if (_impl_.login_screen_mono_audio_enabled_options_ != nullptr) _impl_.login_screen_mono_audio_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void AccessibilitySettingsProto::clear_login_screen_autoclick_enabled_options() {
  if (_impl_.login_screen_autoclick_enabled_options_ != nullptr) _impl_.login_screen_autoclick_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void AccessibilitySettingsProto::clear_login_screen_sticky_keys_enabled_options() {
  if (_impl_.login_screen_sticky_keys_enabled_options_ != nullptr) _impl_.login_screen_sticky_keys_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void AccessibilitySettingsProto::clear_login_screen_keyboard_focus_highlight_enabled_options() {
  if (_impl_.login_screen_keyboard_focus_highlight_enabled_options_ != nullptr) _impl_.login_screen_keyboard_focus_highlight_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void AccessibilitySettingsProto::clear_login_screen_screen_magnifier_type_options() {
  if (_impl_.login_screen_screen_magnifier_type_options_ != nullptr) _impl_.login_screen_screen_magnifier_type_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
void AccessibilitySettingsProto::clear_login_screen_show_options_in_system_tray_menu_enabled_options() {
  if (_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ != nullptr) _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
void AccessibilitySettingsProto::clear_login_screen_shortcuts_enabled_options() {
  if (_impl_.login_screen_shortcuts_enabled_options_ != nullptr) _impl_.login_screen_shortcuts_enabled_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
AccessibilitySettingsProto::AccessibilitySettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AccessibilitySettingsProto)
}
AccessibilitySettingsProto::AccessibilitySettingsProto(const AccessibilitySettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AccessibilitySettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_screen_large_cursor_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_spoken_feedback_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_high_contrast_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_virtual_keyboard_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_dictation_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_select_to_speak_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_cursor_highlight_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_caret_highlight_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_mono_audio_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_autoclick_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_sticky_keys_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_keyboard_focus_highlight_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_screen_magnifier_type_options_){nullptr}
    , decltype(_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_shortcuts_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_default_large_cursor_enabled_){}
    , decltype(_impl_.login_screen_default_spoken_feedback_enabled_){}
    , decltype(_impl_.login_screen_default_high_contrast_enabled_){}
    , decltype(_impl_.login_screen_default_virtual_keyboard_enabled_){}
    , decltype(_impl_.login_screen_default_screen_magnifier_type_){}
    , decltype(_impl_.login_screen_large_cursor_enabled_){}
    , decltype(_impl_.login_screen_spoken_feedback_enabled_){}
    , decltype(_impl_.login_screen_high_contrast_enabled_){}
    , decltype(_impl_.login_screen_virtual_keyboard_enabled_){}
    , decltype(_impl_.login_screen_dictation_enabled_){}
    , decltype(_impl_.login_screen_select_to_speak_enabled_){}
    , decltype(_impl_.login_screen_cursor_highlight_enabled_){}
    , decltype(_impl_.login_screen_caret_highlight_enabled_){}
    , decltype(_impl_.login_screen_mono_audio_enabled_){}
    , decltype(_impl_.login_screen_autoclick_enabled_){}
    , decltype(_impl_.login_screen_sticky_keys_enabled_){}
    , decltype(_impl_.login_screen_keyboard_focus_highlight_enabled_){}
    , decltype(_impl_.login_screen_show_options_in_system_tray_menu_enabled_){}
    , decltype(_impl_.login_screen_shortcuts_enabled_){}
    , decltype(_impl_.login_screen_screen_magnifier_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_login_screen_large_cursor_enabled_options()) {
    _this->_impl_.login_screen_large_cursor_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_large_cursor_enabled_options_);
  }
  if (from._internal_has_login_screen_spoken_feedback_enabled_options()) {
    _this->_impl_.login_screen_spoken_feedback_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_spoken_feedback_enabled_options_);
  }
  if (from._internal_has_login_screen_high_contrast_enabled_options()) {
    _this->_impl_.login_screen_high_contrast_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_high_contrast_enabled_options_);
  }
  if (from._internal_has_login_screen_virtual_keyboard_enabled_options()) {
    _this->_impl_.login_screen_virtual_keyboard_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_virtual_keyboard_enabled_options_);
  }
  if (from._internal_has_login_screen_dictation_enabled_options()) {
    _this->_impl_.login_screen_dictation_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_dictation_enabled_options_);
  }
  if (from._internal_has_login_screen_select_to_speak_enabled_options()) {
    _this->_impl_.login_screen_select_to_speak_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_select_to_speak_enabled_options_);
  }
  if (from._internal_has_login_screen_cursor_highlight_enabled_options()) {
    _this->_impl_.login_screen_cursor_highlight_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_cursor_highlight_enabled_options_);
  }
  if (from._internal_has_login_screen_caret_highlight_enabled_options()) {
    _this->_impl_.login_screen_caret_highlight_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_caret_highlight_enabled_options_);
  }
  if (from._internal_has_login_screen_mono_audio_enabled_options()) {
    _this->_impl_.login_screen_mono_audio_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_mono_audio_enabled_options_);
  }
  if (from._internal_has_login_screen_autoclick_enabled_options()) {
    _this->_impl_.login_screen_autoclick_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_autoclick_enabled_options_);
  }
  if (from._internal_has_login_screen_sticky_keys_enabled_options()) {
    _this->_impl_.login_screen_sticky_keys_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_sticky_keys_enabled_options_);
  }
  if (from._internal_has_login_screen_keyboard_focus_highlight_enabled_options()) {
    _this->_impl_.login_screen_keyboard_focus_highlight_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_keyboard_focus_highlight_enabled_options_);
  }
  if (from._internal_has_login_screen_screen_magnifier_type_options()) {
    _this->_impl_.login_screen_screen_magnifier_type_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_screen_magnifier_type_options_);
  }
  if (from._internal_has_login_screen_show_options_in_system_tray_menu_enabled_options()) {
    _this->_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_show_options_in_system_tray_menu_enabled_options_);
  }
  if (from._internal_has_login_screen_shortcuts_enabled_options()) {
    _this->_impl_.login_screen_shortcuts_enabled_options_ = new ::enterprise_management::PolicyOptions(*from._impl_.login_screen_shortcuts_enabled_options_);
  }
  ::memcpy(&_impl_.login_screen_default_large_cursor_enabled_, &from._impl_.login_screen_default_large_cursor_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.login_screen_screen_magnifier_type_) -
    reinterpret_cast<char*>(&_impl_.login_screen_default_large_cursor_enabled_)) + sizeof(_impl_.login_screen_screen_magnifier_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AccessibilitySettingsProto)
}

inline void AccessibilitySettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_screen_large_cursor_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_spoken_feedback_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_high_contrast_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_virtual_keyboard_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_dictation_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_select_to_speak_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_cursor_highlight_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_caret_highlight_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_mono_audio_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_autoclick_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_sticky_keys_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_keyboard_focus_highlight_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_screen_magnifier_type_options_){nullptr}
    , decltype(_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_shortcuts_enabled_options_){nullptr}
    , decltype(_impl_.login_screen_default_large_cursor_enabled_){false}
    , decltype(_impl_.login_screen_default_spoken_feedback_enabled_){false}
    , decltype(_impl_.login_screen_default_high_contrast_enabled_){false}
    , decltype(_impl_.login_screen_default_virtual_keyboard_enabled_){false}
    , decltype(_impl_.login_screen_default_screen_magnifier_type_){0}
    , decltype(_impl_.login_screen_large_cursor_enabled_){false}
    , decltype(_impl_.login_screen_spoken_feedback_enabled_){false}
    , decltype(_impl_.login_screen_high_contrast_enabled_){false}
    , decltype(_impl_.login_screen_virtual_keyboard_enabled_){false}
    , decltype(_impl_.login_screen_dictation_enabled_){false}
    , decltype(_impl_.login_screen_select_to_speak_enabled_){false}
    , decltype(_impl_.login_screen_cursor_highlight_enabled_){false}
    , decltype(_impl_.login_screen_caret_highlight_enabled_){false}
    , decltype(_impl_.login_screen_mono_audio_enabled_){false}
    , decltype(_impl_.login_screen_autoclick_enabled_){false}
    , decltype(_impl_.login_screen_sticky_keys_enabled_){false}
    , decltype(_impl_.login_screen_keyboard_focus_highlight_enabled_){false}
    , decltype(_impl_.login_screen_show_options_in_system_tray_menu_enabled_){false}
    , decltype(_impl_.login_screen_shortcuts_enabled_){false}
    , decltype(_impl_.login_screen_screen_magnifier_type_){int64_t{0}}
  };
}

AccessibilitySettingsProto::~AccessibilitySettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AccessibilitySettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccessibilitySettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.login_screen_large_cursor_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_spoken_feedback_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_high_contrast_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_virtual_keyboard_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_dictation_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_select_to_speak_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_cursor_highlight_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_caret_highlight_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_mono_audio_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_autoclick_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_sticky_keys_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_keyboard_focus_highlight_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_screen_magnifier_type_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_;
  if (this != internal_default_instance()) delete _impl_.login_screen_shortcuts_enabled_options_;
}

void AccessibilitySettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccessibilitySettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AccessibilitySettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.login_screen_large_cursor_enabled_options_ != nullptr);
      _impl_.login_screen_large_cursor_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.login_screen_spoken_feedback_enabled_options_ != nullptr);
      _impl_.login_screen_spoken_feedback_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.login_screen_high_contrast_enabled_options_ != nullptr);
      _impl_.login_screen_high_contrast_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.login_screen_virtual_keyboard_enabled_options_ != nullptr);
      _impl_.login_screen_virtual_keyboard_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.login_screen_dictation_enabled_options_ != nullptr);
      _impl_.login_screen_dictation_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.login_screen_select_to_speak_enabled_options_ != nullptr);
      _impl_.login_screen_select_to_speak_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.login_screen_cursor_highlight_enabled_options_ != nullptr);
      _impl_.login_screen_cursor_highlight_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.login_screen_caret_highlight_enabled_options_ != nullptr);
      _impl_.login_screen_caret_highlight_enabled_options_->Clear();
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.login_screen_mono_audio_enabled_options_ != nullptr);
      _impl_.login_screen_mono_audio_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.login_screen_autoclick_enabled_options_ != nullptr);
      _impl_.login_screen_autoclick_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.login_screen_sticky_keys_enabled_options_ != nullptr);
      _impl_.login_screen_sticky_keys_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.login_screen_keyboard_focus_highlight_enabled_options_ != nullptr);
      _impl_.login_screen_keyboard_focus_highlight_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.login_screen_screen_magnifier_type_options_ != nullptr);
      _impl_.login_screen_screen_magnifier_type_options_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_ != nullptr);
      _impl_.login_screen_show_options_in_system_tray_menu_enabled_options_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.login_screen_shortcuts_enabled_options_ != nullptr);
      _impl_.login_screen_shortcuts_enabled_options_->Clear();
    }
  }
  _impl_.login_screen_default_large_cursor_enabled_ = false;
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.login_screen_default_spoken_feedback_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.login_screen_virtual_keyboard_enabled_) -
        reinterpret_cast<char*>(&_impl_.login_screen_default_spoken_feedback_enabled_)) + sizeof(_impl_.login_screen_virtual_keyboard_enabled_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.login_screen_dictation_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.login_screen_keyboard_focus_highlight_enabled_) -
        reinterpret_cast<char*>(&_impl_.login_screen_dictation_enabled_)) + sizeof(_impl_.login_screen_keyboard_focus_highlight_enabled_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.login_screen_show_options_in_system_tray_menu_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.login_screen_screen_magnifier_type_) -
        reinterpret_cast<char*>(&_impl_.login_screen_show_options_in_system_tray_menu_enabled_)) + sizeof(_impl_.login_screen_screen_magnifier_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AccessibilitySettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool login_screen_default_large_cursor_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_login_screen_default_large_cursor_enabled(&_impl_._has_bits_);
          _impl_.login_screen_default_large_cursor_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_default_spoken_feedback_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_login_screen_default_spoken_feedback_enabled(&_impl_._has_bits_);
          _impl_.login_screen_default_spoken_feedback_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_default_high_contrast_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_login_screen_default_high_contrast_enabled(&_impl_._has_bits_);
          _impl_.login_screen_default_high_contrast_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AccessibilitySettingsProto.ScreenMagnifierType login_screen_default_screen_magnifier_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType_IsValid(val))) {
            _internal_set_login_screen_default_screen_magnifier_type(static_cast<::enterprise_management::AccessibilitySettingsProto_ScreenMagnifierType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_default_virtual_keyboard_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_login_screen_default_virtual_keyboard_enabled(&_impl_._has_bits_);
          _impl_.login_screen_default_virtual_keyboard_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_large_cursor_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_login_screen_large_cursor_enabled(&_impl_._has_bits_);
          _impl_.login_screen_large_cursor_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_large_cursor_enabled_options = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_large_cursor_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_spoken_feedback_enabled = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_login_screen_spoken_feedback_enabled(&_impl_._has_bits_);
          _impl_.login_screen_spoken_feedback_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_spoken_feedback_enabled_options = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_spoken_feedback_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_high_contrast_enabled = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_login_screen_high_contrast_enabled(&_impl_._has_bits_);
          _impl_.login_screen_high_contrast_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_high_contrast_enabled_options = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_high_contrast_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_virtual_keyboard_enabled = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_login_screen_virtual_keyboard_enabled(&_impl_._has_bits_);
          _impl_.login_screen_virtual_keyboard_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_virtual_keyboard_enabled_options = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_virtual_keyboard_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_dictation_enabled = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_login_screen_dictation_enabled(&_impl_._has_bits_);
          _impl_.login_screen_dictation_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_dictation_enabled_options = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_dictation_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_select_to_speak_enabled = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_login_screen_select_to_speak_enabled(&_impl_._has_bits_);
          _impl_.login_screen_select_to_speak_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_select_to_speak_enabled_options = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_select_to_speak_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_cursor_highlight_enabled = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_login_screen_cursor_highlight_enabled(&_impl_._has_bits_);
          _impl_.login_screen_cursor_highlight_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_cursor_highlight_enabled_options = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_cursor_highlight_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_caret_highlight_enabled = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_login_screen_caret_highlight_enabled(&_impl_._has_bits_);
          _impl_.login_screen_caret_highlight_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_caret_highlight_enabled_options = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_caret_highlight_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_mono_audio_enabled = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_login_screen_mono_audio_enabled(&_impl_._has_bits_);
          _impl_.login_screen_mono_audio_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_mono_audio_enabled_options = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_mono_audio_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_autoclick_enabled = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_login_screen_autoclick_enabled(&_impl_._has_bits_);
          _impl_.login_screen_autoclick_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_autoclick_enabled_options = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_autoclick_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_sticky_keys_enabled = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_login_screen_sticky_keys_enabled(&_impl_._has_bits_);
          _impl_.login_screen_sticky_keys_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_sticky_keys_enabled_options = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_sticky_keys_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_keyboard_focus_highlight_enabled = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_login_screen_keyboard_focus_highlight_enabled(&_impl_._has_bits_);
          _impl_.login_screen_keyboard_focus_highlight_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_keyboard_focus_highlight_enabled_options = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_keyboard_focus_highlight_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 login_screen_screen_magnifier_type = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_login_screen_screen_magnifier_type(&_impl_._has_bits_);
          _impl_.login_screen_screen_magnifier_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_screen_magnifier_type_options = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_screen_magnifier_type_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_show_options_in_system_tray_menu_enabled = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_login_screen_show_options_in_system_tray_menu_enabled(&_impl_._has_bits_);
          _impl_.login_screen_show_options_in_system_tray_menu_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_show_options_in_system_tray_menu_enabled_options = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_show_options_in_system_tray_menu_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_screen_shortcuts_enabled = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_login_screen_shortcuts_enabled(&_impl_._has_bits_);
          _impl_.login_screen_shortcuts_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyOptions login_screen_shortcuts_enabled_options = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_shortcuts_enabled_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccessibilitySettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AccessibilitySettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool login_screen_default_large_cursor_enabled = 1;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_login_screen_default_large_cursor_enabled(), target);
  }

  // optional bool login_screen_default_spoken_feedback_enabled = 2;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_login_screen_default_spoken_feedback_enabled(), target);
  }

  // optional bool login_screen_default_high_contrast_enabled = 3;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_login_screen_default_high_contrast_enabled(), target);
  }

  // optional .enterprise_management.AccessibilitySettingsProto.ScreenMagnifierType login_screen_default_screen_magnifier_type = 4;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_login_screen_default_screen_magnifier_type(), target);
  }

  // optional bool login_screen_default_virtual_keyboard_enabled = 5;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_login_screen_default_virtual_keyboard_enabled(), target);
  }

  // optional bool login_screen_large_cursor_enabled = 6;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_login_screen_large_cursor_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_large_cursor_enabled_options = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::login_screen_large_cursor_enabled_options(this),
        _Internal::login_screen_large_cursor_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_spoken_feedback_enabled = 8;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_login_screen_spoken_feedback_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_spoken_feedback_enabled_options = 9;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::login_screen_spoken_feedback_enabled_options(this),
        _Internal::login_screen_spoken_feedback_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_high_contrast_enabled = 10;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_login_screen_high_contrast_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_high_contrast_enabled_options = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::login_screen_high_contrast_enabled_options(this),
        _Internal::login_screen_high_contrast_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_virtual_keyboard_enabled = 12;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_login_screen_virtual_keyboard_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_virtual_keyboard_enabled_options = 13;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::login_screen_virtual_keyboard_enabled_options(this),
        _Internal::login_screen_virtual_keyboard_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_dictation_enabled = 14;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_login_screen_dictation_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_dictation_enabled_options = 15;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::login_screen_dictation_enabled_options(this),
        _Internal::login_screen_dictation_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_select_to_speak_enabled = 16;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_login_screen_select_to_speak_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_select_to_speak_enabled_options = 17;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::login_screen_select_to_speak_enabled_options(this),
        _Internal::login_screen_select_to_speak_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_cursor_highlight_enabled = 18;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_login_screen_cursor_highlight_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_cursor_highlight_enabled_options = 19;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::login_screen_cursor_highlight_enabled_options(this),
        _Internal::login_screen_cursor_highlight_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_caret_highlight_enabled = 20;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_login_screen_caret_highlight_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_caret_highlight_enabled_options = 21;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::login_screen_caret_highlight_enabled_options(this),
        _Internal::login_screen_caret_highlight_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_mono_audio_enabled = 22;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_login_screen_mono_audio_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_mono_audio_enabled_options = 23;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::login_screen_mono_audio_enabled_options(this),
        _Internal::login_screen_mono_audio_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_autoclick_enabled = 24;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_login_screen_autoclick_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_autoclick_enabled_options = 25;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::login_screen_autoclick_enabled_options(this),
        _Internal::login_screen_autoclick_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_sticky_keys_enabled = 26;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_login_screen_sticky_keys_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_sticky_keys_enabled_options = 27;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::login_screen_sticky_keys_enabled_options(this),
        _Internal::login_screen_sticky_keys_enabled_options(this).GetCachedSize(), target, stream);
  }

  // optional bool login_screen_keyboard_focus_highlight_enabled = 28;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_login_screen_keyboard_focus_highlight_enabled(), target);
  }

  // optional .enterprise_management.PolicyOptions login_screen_keyboard_focus_highlight_enabled_options = 29;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::login_screen_keyboard_focus_highlight_enabled_options(this),
        _Internal::login_screen_keyboard_focus_highlight_enabled_options(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int64 login_screen_screen_magnifier_type = 30;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(30, this->_internal_login_screen_screen_magnifier_type(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.PolicyOptions login_screen_screen_magnifier_type_options = 31;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::login_screen_screen_magnifier_type_options(this),
        _Internal::login_screen_screen_magnifier_type_options(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool login_screen_show_options_in_system_tray_menu_enabled = 32;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(32, this->_internal_login_screen_show_options_in_system_tray_menu_enabled(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.PolicyOptions login_screen_show_options_in_system_tray_menu_enabled_options = 33;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::login_screen_show_options_in_system_tray_menu_enabled_options(this),
        _Internal::login_screen_show_options_in_system_tray_menu_enabled_options(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool login_screen_shortcuts_enabled = 34;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(34, this->_internal_login_screen_shortcuts_enabled(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.PolicyOptions login_screen_shortcuts_enabled_options = 35;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::login_screen_shortcuts_enabled_options(this),
        _Internal::login_screen_shortcuts_enabled_options(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AccessibilitySettingsProto)
  return target;
}

size_t AccessibilitySettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AccessibilitySettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.PolicyOptions login_screen_large_cursor_enabled_options = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_large_cursor_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_spoken_feedback_enabled_options = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_spoken_feedback_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_high_contrast_enabled_options = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_high_contrast_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_virtual_keyboard_enabled_options = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_virtual_keyboard_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_dictation_enabled_options = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_dictation_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_select_to_speak_enabled_options = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_select_to_speak_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_cursor_highlight_enabled_options = 19;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_cursor_highlight_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_caret_highlight_enabled_options = 21;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_caret_highlight_enabled_options_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.PolicyOptions login_screen_mono_audio_enabled_options = 23;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_mono_audio_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_autoclick_enabled_options = 25;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_autoclick_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_sticky_keys_enabled_options = 27;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_sticky_keys_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_keyboard_focus_highlight_enabled_options = 29;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_keyboard_focus_highlight_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_screen_magnifier_type_options = 31;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_screen_magnifier_type_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_show_options_in_system_tray_menu_enabled_options = 33;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_show_options_in_system_tray_menu_enabled_options_);
    }

    // optional .enterprise_management.PolicyOptions login_screen_shortcuts_enabled_options = 35;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_shortcuts_enabled_options_);
    }

    // optional bool login_screen_default_large_cursor_enabled = 1;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool login_screen_default_spoken_feedback_enabled = 2;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 1;
    }

    // optional bool login_screen_default_high_contrast_enabled = 3;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

    // optional bool login_screen_default_virtual_keyboard_enabled = 5;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional .enterprise_management.AccessibilitySettingsProto.ScreenMagnifierType login_screen_default_screen_magnifier_type = 4;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_login_screen_default_screen_magnifier_type());
    }

    // optional bool login_screen_large_cursor_enabled = 6;
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 + 1;
    }

    // optional bool login_screen_spoken_feedback_enabled = 8;
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 + 1;
    }

    // optional bool login_screen_high_contrast_enabled = 10;
    if (cached_has_bits & 0x00400000u) {
      total_size += 1 + 1;
    }

    // optional bool login_screen_virtual_keyboard_enabled = 12;
    if (cached_has_bits & 0x00800000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool login_screen_dictation_enabled = 14;
    if (cached_has_bits & 0x01000000u) {
      total_size += 1 + 1;
    }

    // optional bool login_screen_select_to_speak_enabled = 16;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool login_screen_cursor_highlight_enabled = 18;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool login_screen_caret_highlight_enabled = 20;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool login_screen_mono_audio_enabled = 22;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool login_screen_autoclick_enabled = 24;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional bool login_screen_sticky_keys_enabled = 26;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 1;
    }

    // optional bool login_screen_keyboard_focus_highlight_enabled = 28;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 1;
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000007u) {
    // optional bool login_screen_show_options_in_system_tray_menu_enabled = 32;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional bool login_screen_shortcuts_enabled = 34;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional int64 login_screen_screen_magnifier_type = 30;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_login_screen_screen_magnifier_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AccessibilitySettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AccessibilitySettingsProto*>(
      &from));
}

void AccessibilitySettingsProto::MergeFrom(const AccessibilitySettingsProto& from) {
  AccessibilitySettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AccessibilitySettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_login_screen_large_cursor_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_large_cursor_enabled_options());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_login_screen_spoken_feedback_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_spoken_feedback_enabled_options());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_login_screen_high_contrast_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_high_contrast_enabled_options());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_login_screen_virtual_keyboard_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_virtual_keyboard_enabled_options());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_login_screen_dictation_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_dictation_enabled_options());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_login_screen_select_to_speak_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_select_to_speak_enabled_options());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_login_screen_cursor_highlight_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_cursor_highlight_enabled_options());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_login_screen_caret_highlight_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_caret_highlight_enabled_options());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_login_screen_mono_audio_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_mono_audio_enabled_options());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_login_screen_autoclick_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_autoclick_enabled_options());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_login_screen_sticky_keys_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_sticky_keys_enabled_options());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_login_screen_keyboard_focus_highlight_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_keyboard_focus_highlight_enabled_options());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_login_screen_screen_magnifier_type_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_screen_magnifier_type_options());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_login_screen_show_options_in_system_tray_menu_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_show_options_in_system_tray_menu_enabled_options());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_login_screen_shortcuts_enabled_options()->::enterprise_management::PolicyOptions::MergeFrom(
          from._internal_login_screen_shortcuts_enabled_options());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.login_screen_default_large_cursor_enabled_ = from._impl_.login_screen_default_large_cursor_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.login_screen_default_spoken_feedback_enabled_ = from._impl_.login_screen_default_spoken_feedback_enabled_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.login_screen_default_high_contrast_enabled_ = from._impl_.login_screen_default_high_contrast_enabled_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.login_screen_default_virtual_keyboard_enabled_ = from._impl_.login_screen_default_virtual_keyboard_enabled_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.login_screen_default_screen_magnifier_type_ = from._impl_.login_screen_default_screen_magnifier_type_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.login_screen_large_cursor_enabled_ = from._impl_.login_screen_large_cursor_enabled_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.login_screen_spoken_feedback_enabled_ = from._impl_.login_screen_spoken_feedback_enabled_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.login_screen_high_contrast_enabled_ = from._impl_.login_screen_high_contrast_enabled_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.login_screen_virtual_keyboard_enabled_ = from._impl_.login_screen_virtual_keyboard_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.login_screen_dictation_enabled_ = from._impl_.login_screen_dictation_enabled_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.login_screen_select_to_speak_enabled_ = from._impl_.login_screen_select_to_speak_enabled_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.login_screen_cursor_highlight_enabled_ = from._impl_.login_screen_cursor_highlight_enabled_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.login_screen_caret_highlight_enabled_ = from._impl_.login_screen_caret_highlight_enabled_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.login_screen_mono_audio_enabled_ = from._impl_.login_screen_mono_audio_enabled_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.login_screen_autoclick_enabled_ = from._impl_.login_screen_autoclick_enabled_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.login_screen_sticky_keys_enabled_ = from._impl_.login_screen_sticky_keys_enabled_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.login_screen_keyboard_focus_highlight_enabled_ = from._impl_.login_screen_keyboard_focus_highlight_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.login_screen_show_options_in_system_tray_menu_enabled_ = from._impl_.login_screen_show_options_in_system_tray_menu_enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.login_screen_shortcuts_enabled_ = from._impl_.login_screen_shortcuts_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.login_screen_screen_magnifier_type_ = from._impl_.login_screen_screen_magnifier_type_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AccessibilitySettingsProto::CopyFrom(const AccessibilitySettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AccessibilitySettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccessibilitySettingsProto::IsInitialized() const {
  return true;
}

void AccessibilitySettingsProto::InternalSwap(AccessibilitySettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccessibilitySettingsProto, _impl_.login_screen_screen_magnifier_type_)
      + sizeof(AccessibilitySettingsProto::_impl_.login_screen_screen_magnifier_type_)
      - PROTOBUF_FIELD_OFFSET(AccessibilitySettingsProto, _impl_.login_screen_large_cursor_enabled_options_)>(
          reinterpret_cast<char*>(&_impl_.login_screen_large_cursor_enabled_options_),
          reinterpret_cast<char*>(&other->_impl_.login_screen_large_cursor_enabled_options_));
}

std::string AccessibilitySettingsProto::GetTypeName() const {
  return "enterprise_management.AccessibilitySettingsProto";
}


// ===================================================================

class OBSOLETE_SupervisedUsersSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_SupervisedUsersSettingsProto>()._impl_._has_bits_);
  static void set_has_obsolete_supervised_users_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OBSOLETE_SupervisedUsersSettingsProto::OBSOLETE_SupervisedUsersSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
}
OBSOLETE_SupervisedUsersSettingsProto::OBSOLETE_SupervisedUsersSettingsProto(const OBSOLETE_SupervisedUsersSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_SupervisedUsersSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_supervised_users_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.obsolete_supervised_users_enabled_ = from._impl_.obsolete_supervised_users_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
}

inline void OBSOLETE_SupervisedUsersSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_supervised_users_enabled_){false}
  };
}

OBSOLETE_SupervisedUsersSettingsProto::~OBSOLETE_SupervisedUsersSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_SupervisedUsersSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OBSOLETE_SupervisedUsersSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_SupervisedUsersSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.obsolete_supervised_users_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_SupervisedUsersSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool OBSOLETE_supervised_users_enabled = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_obsolete_supervised_users_enabled(&has_bits);
          _impl_.obsolete_supervised_users_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_SupervisedUsersSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool OBSOLETE_supervised_users_enabled = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_obsolete_supervised_users_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
  return target;
}

size_t OBSOLETE_SupervisedUsersSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool OBSOLETE_supervised_users_enabled = 1 [deprecated = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_SupervisedUsersSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_SupervisedUsersSettingsProto*>(
      &from));
}

void OBSOLETE_SupervisedUsersSettingsProto::MergeFrom(const OBSOLETE_SupervisedUsersSettingsProto& from) {
  OBSOLETE_SupervisedUsersSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_obsolete_supervised_users_enabled()) {
    _this->_internal_set_obsolete_supervised_users_enabled(from._internal_obsolete_supervised_users_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_SupervisedUsersSettingsProto::CopyFrom(const OBSOLETE_SupervisedUsersSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_SupervisedUsersSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_SupervisedUsersSettingsProto::IsInitialized() const {
  return true;
}

void OBSOLETE_SupervisedUsersSettingsProto::InternalSwap(OBSOLETE_SupervisedUsersSettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.obsolete_supervised_users_enabled_, other->_impl_.obsolete_supervised_users_enabled_);
}

std::string OBSOLETE_SupervisedUsersSettingsProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_SupervisedUsersSettingsProto";
}


// ===================================================================

class LoginScreenPowerManagementProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginScreenPowerManagementProto>()._impl_._has_bits_);
  static void set_has_login_screen_power_management(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoginScreenPowerManagementProto::LoginScreenPowerManagementProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LoginScreenPowerManagementProto)
}
LoginScreenPowerManagementProto::LoginScreenPowerManagementProto(const LoginScreenPowerManagementProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginScreenPowerManagementProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_screen_power_management_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.login_screen_power_management_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_screen_power_management_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_login_screen_power_management()) {
    _this->_impl_.login_screen_power_management_.Set(from._internal_login_screen_power_management(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LoginScreenPowerManagementProto)
}

inline void LoginScreenPowerManagementProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_screen_power_management_){}
  };
  _impl_.login_screen_power_management_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_screen_power_management_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginScreenPowerManagementProto::~LoginScreenPowerManagementProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.LoginScreenPowerManagementProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginScreenPowerManagementProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.login_screen_power_management_.Destroy();
}

void LoginScreenPowerManagementProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginScreenPowerManagementProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LoginScreenPowerManagementProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.login_screen_power_management_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginScreenPowerManagementProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string login_screen_power_management = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_login_screen_power_management();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginScreenPowerManagementProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LoginScreenPowerManagementProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string login_screen_power_management = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_login_screen_power_management(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LoginScreenPowerManagementProto)
  return target;
}

size_t LoginScreenPowerManagementProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LoginScreenPowerManagementProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string login_screen_power_management = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_login_screen_power_management());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginScreenPowerManagementProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginScreenPowerManagementProto*>(
      &from));
}

void LoginScreenPowerManagementProto::MergeFrom(const LoginScreenPowerManagementProto& from) {
  LoginScreenPowerManagementProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LoginScreenPowerManagementProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_login_screen_power_management()) {
    _this->_internal_set_login_screen_power_management(from._internal_login_screen_power_management());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginScreenPowerManagementProto::CopyFrom(const LoginScreenPowerManagementProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LoginScreenPowerManagementProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginScreenPowerManagementProto::IsInitialized() const {
  return true;
}

void LoginScreenPowerManagementProto::InternalSwap(LoginScreenPowerManagementProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.login_screen_power_management_, lhs_arena,
      &other->_impl_.login_screen_power_management_, rhs_arena
  );
}

std::string LoginScreenPowerManagementProto::GetTypeName() const {
  return "enterprise_management.LoginScreenPowerManagementProto";
}


// ===================================================================

class AutoCleanupSettigsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AutoCleanupSettigsProto>()._impl_._has_bits_);
  static void set_has_clean_up_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AutoCleanupSettigsProto::AutoCleanupSettigsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AutoCleanupSettigsProto)
}
AutoCleanupSettigsProto::AutoCleanupSettigsProto(const AutoCleanupSettigsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AutoCleanupSettigsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.clean_up_strategy_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.clean_up_strategy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clean_up_strategy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_clean_up_strategy()) {
    _this->_impl_.clean_up_strategy_.Set(from._internal_clean_up_strategy(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AutoCleanupSettigsProto)
}

inline void AutoCleanupSettigsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.clean_up_strategy_){}
  };
  _impl_.clean_up_strategy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clean_up_strategy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutoCleanupSettigsProto::~AutoCleanupSettigsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AutoCleanupSettigsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutoCleanupSettigsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.clean_up_strategy_.Destroy();
}

void AutoCleanupSettigsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AutoCleanupSettigsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AutoCleanupSettigsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.clean_up_strategy_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutoCleanupSettigsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string clean_up_strategy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_clean_up_strategy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutoCleanupSettigsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AutoCleanupSettigsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string clean_up_strategy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_clean_up_strategy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AutoCleanupSettigsProto)
  return target;
}

size_t AutoCleanupSettigsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AutoCleanupSettigsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string clean_up_strategy = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_clean_up_strategy());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutoCleanupSettigsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutoCleanupSettigsProto*>(
      &from));
}

void AutoCleanupSettigsProto::MergeFrom(const AutoCleanupSettigsProto& from) {
  AutoCleanupSettigsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AutoCleanupSettigsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_clean_up_strategy()) {
    _this->_internal_set_clean_up_strategy(from._internal_clean_up_strategy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutoCleanupSettigsProto::CopyFrom(const AutoCleanupSettigsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AutoCleanupSettigsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoCleanupSettigsProto::IsInitialized() const {
  return true;
}

void AutoCleanupSettigsProto::InternalSwap(AutoCleanupSettigsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.clean_up_strategy_, lhs_arena,
      &other->_impl_.clean_up_strategy_, rhs_arena
  );
}

std::string AutoCleanupSettigsProto::GetTypeName() const {
  return "enterprise_management.AutoCleanupSettigsProto";
}


// ===================================================================

class SystemSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemSettingsProto>()._impl_._has_bits_);
  static void set_has_block_devmode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SystemSettingsProto::SystemSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SystemSettingsProto)
}
SystemSettingsProto::SystemSettingsProto(const SystemSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.block_devmode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.block_devmode_ = from._impl_.block_devmode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SystemSettingsProto)
}

inline void SystemSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.block_devmode_){false}
  };
}

SystemSettingsProto::~SystemSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.SystemSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SystemSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.block_devmode_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool block_devmode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_block_devmode(&has_bits);
          _impl_.block_devmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SystemSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool block_devmode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_block_devmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SystemSettingsProto)
  return target;
}

size_t SystemSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SystemSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool block_devmode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemSettingsProto*>(
      &from));
}

void SystemSettingsProto::MergeFrom(const SystemSettingsProto& from) {
  SystemSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SystemSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_block_devmode()) {
    _this->_internal_set_block_devmode(from._internal_block_devmode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemSettingsProto::CopyFrom(const SystemSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SystemSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemSettingsProto::IsInitialized() const {
  return true;
}

void SystemSettingsProto::InternalSwap(SystemSettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.block_devmode_, other->_impl_.block_devmode_);
}

std::string SystemSettingsProto::GetTypeName() const {
  return "enterprise_management.SystemSettingsProto";
}


// ===================================================================

class SAMLSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SAMLSettingsProto>()._impl_._has_bits_);
  static void set_has_transfer_saml_cookies(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_obsolete_url_parameter_to_autofill_saml_username(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SAMLSettingsProto::SAMLSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SAMLSettingsProto)
}
SAMLSettingsProto::SAMLSettingsProto(const SAMLSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SAMLSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_url_parameter_to_autofill_saml_username_){}
    , decltype(_impl_.transfer_saml_cookies_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.obsolete_url_parameter_to_autofill_saml_username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_url_parameter_to_autofill_saml_username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_url_parameter_to_autofill_saml_username()) {
    _this->_impl_.obsolete_url_parameter_to_autofill_saml_username_.Set(from._internal_obsolete_url_parameter_to_autofill_saml_username(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.transfer_saml_cookies_ = from._impl_.transfer_saml_cookies_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SAMLSettingsProto)
}

inline void SAMLSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_url_parameter_to_autofill_saml_username_){}
    , decltype(_impl_.transfer_saml_cookies_){false}
  };
  _impl_.obsolete_url_parameter_to_autofill_saml_username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_url_parameter_to_autofill_saml_username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SAMLSettingsProto::~SAMLSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.SAMLSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SAMLSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_url_parameter_to_autofill_saml_username_.Destroy();
}

void SAMLSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SAMLSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SAMLSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.obsolete_url_parameter_to_autofill_saml_username_.ClearNonDefaultToEmpty();
  }
  _impl_.transfer_saml_cookies_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SAMLSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool transfer_saml_cookies = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_transfer_saml_cookies(&has_bits);
          _impl_.transfer_saml_cookies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string OBSOLETE_url_parameter_to_autofill_saml_username = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_obsolete_url_parameter_to_autofill_saml_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SAMLSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SAMLSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool transfer_saml_cookies = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_transfer_saml_cookies(), target);
  }

  // optional string OBSOLETE_url_parameter_to_autofill_saml_username = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_obsolete_url_parameter_to_autofill_saml_username(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SAMLSettingsProto)
  return target;
}

size_t SAMLSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SAMLSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string OBSOLETE_url_parameter_to_autofill_saml_username = 2 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_url_parameter_to_autofill_saml_username());
    }

    // optional bool transfer_saml_cookies = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SAMLSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SAMLSettingsProto*>(
      &from));
}

void SAMLSettingsProto::MergeFrom(const SAMLSettingsProto& from) {
  SAMLSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SAMLSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_obsolete_url_parameter_to_autofill_saml_username(from._internal_obsolete_url_parameter_to_autofill_saml_username());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.transfer_saml_cookies_ = from._impl_.transfer_saml_cookies_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SAMLSettingsProto::CopyFrom(const SAMLSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SAMLSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SAMLSettingsProto::IsInitialized() const {
  return true;
}

void SAMLSettingsProto::InternalSwap(SAMLSettingsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_url_parameter_to_autofill_saml_username_, lhs_arena,
      &other->_impl_.obsolete_url_parameter_to_autofill_saml_username_, rhs_arena
  );
  swap(_impl_.transfer_saml_cookies_, other->_impl_.transfer_saml_cookies_);
}

std::string SAMLSettingsProto::GetTypeName() const {
  return "enterprise_management.SAMLSettingsProto";
}


// ===================================================================

class SAMLUsernameProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SAMLUsernameProto>()._impl_._has_bits_);
  static void set_has_url_parameter_to_autofill_saml_username(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SAMLUsernameProto::SAMLUsernameProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SAMLUsernameProto)
}
SAMLUsernameProto::SAMLUsernameProto(const SAMLUsernameProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SAMLUsernameProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_parameter_to_autofill_saml_username_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_parameter_to_autofill_saml_username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_parameter_to_autofill_saml_username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url_parameter_to_autofill_saml_username()) {
    _this->_impl_.url_parameter_to_autofill_saml_username_.Set(from._internal_url_parameter_to_autofill_saml_username(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SAMLUsernameProto)
}

inline void SAMLUsernameProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_parameter_to_autofill_saml_username_){}
  };
  _impl_.url_parameter_to_autofill_saml_username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_parameter_to_autofill_saml_username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SAMLUsernameProto::~SAMLUsernameProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.SAMLUsernameProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SAMLUsernameProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_parameter_to_autofill_saml_username_.Destroy();
}

void SAMLUsernameProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SAMLUsernameProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SAMLUsernameProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.url_parameter_to_autofill_saml_username_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SAMLUsernameProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url_parameter_to_autofill_saml_username = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url_parameter_to_autofill_saml_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SAMLUsernameProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SAMLUsernameProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string url_parameter_to_autofill_saml_username = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url_parameter_to_autofill_saml_username(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SAMLUsernameProto)
  return target;
}

size_t SAMLUsernameProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SAMLUsernameProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string url_parameter_to_autofill_saml_username = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url_parameter_to_autofill_saml_username());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SAMLUsernameProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SAMLUsernameProto*>(
      &from));
}

void SAMLUsernameProto::MergeFrom(const SAMLUsernameProto& from) {
  SAMLUsernameProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SAMLUsernameProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_url_parameter_to_autofill_saml_username()) {
    _this->_internal_set_url_parameter_to_autofill_saml_username(from._internal_url_parameter_to_autofill_saml_username());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SAMLUsernameProto::CopyFrom(const SAMLUsernameProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SAMLUsernameProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SAMLUsernameProto::IsInitialized() const {
  return true;
}

void SAMLUsernameProto::InternalSwap(SAMLUsernameProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_parameter_to_autofill_saml_username_, lhs_arena,
      &other->_impl_.url_parameter_to_autofill_saml_username_, rhs_arena
  );
}

std::string SAMLUsernameProto::GetTypeName() const {
  return "enterprise_management.SAMLUsernameProto";
}


// ===================================================================

class RebootOnShutdownProto::_Internal {
 public:
  using HasBits = decltype(std::declval<RebootOnShutdownProto>()._impl_._has_bits_);
  static void set_has_reboot_on_shutdown(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RebootOnShutdownProto::RebootOnShutdownProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RebootOnShutdownProto)
}
RebootOnShutdownProto::RebootOnShutdownProto(const RebootOnShutdownProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RebootOnShutdownProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reboot_on_shutdown_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.reboot_on_shutdown_ = from._impl_.reboot_on_shutdown_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RebootOnShutdownProto)
}

inline void RebootOnShutdownProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reboot_on_shutdown_){false}
  };
}

RebootOnShutdownProto::~RebootOnShutdownProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.RebootOnShutdownProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RebootOnShutdownProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RebootOnShutdownProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RebootOnShutdownProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RebootOnShutdownProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reboot_on_shutdown_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RebootOnShutdownProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool reboot_on_shutdown = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reboot_on_shutdown(&has_bits);
          _impl_.reboot_on_shutdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RebootOnShutdownProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RebootOnShutdownProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool reboot_on_shutdown = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_reboot_on_shutdown(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RebootOnShutdownProto)
  return target;
}

size_t RebootOnShutdownProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RebootOnShutdownProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool reboot_on_shutdown = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RebootOnShutdownProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RebootOnShutdownProto*>(
      &from));
}

void RebootOnShutdownProto::MergeFrom(const RebootOnShutdownProto& from) {
  RebootOnShutdownProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RebootOnShutdownProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reboot_on_shutdown()) {
    _this->_internal_set_reboot_on_shutdown(from._internal_reboot_on_shutdown());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RebootOnShutdownProto::CopyFrom(const RebootOnShutdownProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RebootOnShutdownProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RebootOnShutdownProto::IsInitialized() const {
  return true;
}

void RebootOnShutdownProto::InternalSwap(RebootOnShutdownProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.reboot_on_shutdown_, other->_impl_.reboot_on_shutdown_);
}

std::string RebootOnShutdownProto::GetTypeName() const {
  return "enterprise_management.RebootOnShutdownProto";
}


// ===================================================================

class DeviceHeartbeatSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceHeartbeatSettingsProto>()._impl_._has_bits_);
  static void set_has_heartbeat_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_heartbeat_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DeviceHeartbeatSettingsProto::DeviceHeartbeatSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceHeartbeatSettingsProto)
}
DeviceHeartbeatSettingsProto::DeviceHeartbeatSettingsProto(const DeviceHeartbeatSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceHeartbeatSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heartbeat_enabled_){}
    , decltype(_impl_.heartbeat_frequency_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.heartbeat_enabled_, &from._impl_.heartbeat_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.heartbeat_frequency_) -
    reinterpret_cast<char*>(&_impl_.heartbeat_enabled_)) + sizeof(_impl_.heartbeat_frequency_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceHeartbeatSettingsProto)
}

inline void DeviceHeartbeatSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heartbeat_enabled_){false}
    , decltype(_impl_.heartbeat_frequency_){int64_t{120000}}
  };
}

DeviceHeartbeatSettingsProto::~DeviceHeartbeatSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceHeartbeatSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceHeartbeatSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceHeartbeatSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceHeartbeatSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceHeartbeatSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.heartbeat_enabled_ = false;
    _impl_.heartbeat_frequency_ = int64_t{120000};
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceHeartbeatSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool heartbeat_enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_heartbeat_enabled(&has_bits);
          _impl_.heartbeat_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 heartbeat_frequency = 2 [default = 120000];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_heartbeat_frequency(&has_bits);
          _impl_.heartbeat_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceHeartbeatSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceHeartbeatSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool heartbeat_enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_heartbeat_enabled(), target);
  }

  // optional int64 heartbeat_frequency = 2 [default = 120000];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_heartbeat_frequency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceHeartbeatSettingsProto)
  return target;
}

size_t DeviceHeartbeatSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceHeartbeatSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool heartbeat_enabled = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int64 heartbeat_frequency = 2 [default = 120000];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_heartbeat_frequency());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceHeartbeatSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceHeartbeatSettingsProto*>(
      &from));
}

void DeviceHeartbeatSettingsProto::MergeFrom(const DeviceHeartbeatSettingsProto& from) {
  DeviceHeartbeatSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceHeartbeatSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.heartbeat_enabled_ = from._impl_.heartbeat_enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.heartbeat_frequency_ = from._impl_.heartbeat_frequency_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceHeartbeatSettingsProto::CopyFrom(const DeviceHeartbeatSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceHeartbeatSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceHeartbeatSettingsProto::IsInitialized() const {
  return true;
}

void DeviceHeartbeatSettingsProto::InternalSwap(DeviceHeartbeatSettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.heartbeat_enabled_, other->_impl_.heartbeat_enabled_);
  swap(_impl_.heartbeat_frequency_, other->_impl_.heartbeat_frequency_);
}

std::string DeviceHeartbeatSettingsProto::GetTypeName() const {
  return "enterprise_management.DeviceHeartbeatSettingsProto";
}


// ===================================================================

class ExtensionCacheSizeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtensionCacheSizeProto>()._impl_._has_bits_);
  static void set_has_extension_cache_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ExtensionCacheSizeProto::ExtensionCacheSizeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ExtensionCacheSizeProto)
}
ExtensionCacheSizeProto::ExtensionCacheSizeProto(const ExtensionCacheSizeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ExtensionCacheSizeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extension_cache_size_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.extension_cache_size_ = from._impl_.extension_cache_size_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ExtensionCacheSizeProto)
}

inline void ExtensionCacheSizeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extension_cache_size_){int64_t{0}}
  };
}

ExtensionCacheSizeProto::~ExtensionCacheSizeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.ExtensionCacheSizeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExtensionCacheSizeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExtensionCacheSizeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExtensionCacheSizeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ExtensionCacheSizeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_cache_size_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExtensionCacheSizeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 extension_cache_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_extension_cache_size(&has_bits);
          _impl_.extension_cache_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExtensionCacheSizeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ExtensionCacheSizeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 extension_cache_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_extension_cache_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ExtensionCacheSizeProto)
  return target;
}

size_t ExtensionCacheSizeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ExtensionCacheSizeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 extension_cache_size = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_extension_cache_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtensionCacheSizeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExtensionCacheSizeProto*>(
      &from));
}

void ExtensionCacheSizeProto::MergeFrom(const ExtensionCacheSizeProto& from) {
  ExtensionCacheSizeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ExtensionCacheSizeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_extension_cache_size()) {
    _this->_internal_set_extension_cache_size(from._internal_extension_cache_size());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionCacheSizeProto::CopyFrom(const ExtensionCacheSizeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ExtensionCacheSizeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtensionCacheSizeProto::IsInitialized() const {
  return true;
}

void ExtensionCacheSizeProto::InternalSwap(ExtensionCacheSizeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.extension_cache_size_, other->_impl_.extension_cache_size_);
}

std::string ExtensionCacheSizeProto::GetTypeName() const {
  return "enterprise_management.ExtensionCacheSizeProto";
}


// ===================================================================

class LoginScreenDomainAutoCompleteProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginScreenDomainAutoCompleteProto>()._impl_._has_bits_);
  static void set_has_login_screen_domain_auto_complete(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoginScreenDomainAutoCompleteProto::LoginScreenDomainAutoCompleteProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LoginScreenDomainAutoCompleteProto)
}
LoginScreenDomainAutoCompleteProto::LoginScreenDomainAutoCompleteProto(const LoginScreenDomainAutoCompleteProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginScreenDomainAutoCompleteProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_screen_domain_auto_complete_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.login_screen_domain_auto_complete_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_screen_domain_auto_complete_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_login_screen_domain_auto_complete()) {
    _this->_impl_.login_screen_domain_auto_complete_.Set(from._internal_login_screen_domain_auto_complete(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LoginScreenDomainAutoCompleteProto)
}

inline void LoginScreenDomainAutoCompleteProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_screen_domain_auto_complete_){}
  };
  _impl_.login_screen_domain_auto_complete_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_screen_domain_auto_complete_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginScreenDomainAutoCompleteProto::~LoginScreenDomainAutoCompleteProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.LoginScreenDomainAutoCompleteProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginScreenDomainAutoCompleteProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.login_screen_domain_auto_complete_.Destroy();
}

void LoginScreenDomainAutoCompleteProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginScreenDomainAutoCompleteProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LoginScreenDomainAutoCompleteProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.login_screen_domain_auto_complete_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginScreenDomainAutoCompleteProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string login_screen_domain_auto_complete = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_login_screen_domain_auto_complete();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginScreenDomainAutoCompleteProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LoginScreenDomainAutoCompleteProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string login_screen_domain_auto_complete = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_login_screen_domain_auto_complete(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LoginScreenDomainAutoCompleteProto)
  return target;
}

size_t LoginScreenDomainAutoCompleteProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LoginScreenDomainAutoCompleteProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string login_screen_domain_auto_complete = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_login_screen_domain_auto_complete());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginScreenDomainAutoCompleteProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginScreenDomainAutoCompleteProto*>(
      &from));
}

void LoginScreenDomainAutoCompleteProto::MergeFrom(const LoginScreenDomainAutoCompleteProto& from) {
  LoginScreenDomainAutoCompleteProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LoginScreenDomainAutoCompleteProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_login_screen_domain_auto_complete()) {
    _this->_internal_set_login_screen_domain_auto_complete(from._internal_login_screen_domain_auto_complete());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginScreenDomainAutoCompleteProto::CopyFrom(const LoginScreenDomainAutoCompleteProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LoginScreenDomainAutoCompleteProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginScreenDomainAutoCompleteProto::IsInitialized() const {
  return true;
}

void LoginScreenDomainAutoCompleteProto::InternalSwap(LoginScreenDomainAutoCompleteProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.login_screen_domain_auto_complete_, lhs_arena,
      &other->_impl_.login_screen_domain_auto_complete_, rhs_arena
  );
}

std::string LoginScreenDomainAutoCompleteProto::GetTypeName() const {
  return "enterprise_management.LoginScreenDomainAutoCompleteProto";
}


// ===================================================================

class DeviceLogUploadSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceLogUploadSettingsProto>()._impl_._has_bits_);
  static void set_has_system_log_upload_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceLogUploadSettingsProto::DeviceLogUploadSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceLogUploadSettingsProto)
}
DeviceLogUploadSettingsProto::DeviceLogUploadSettingsProto(const DeviceLogUploadSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceLogUploadSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.system_log_upload_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.system_log_upload_enabled_ = from._impl_.system_log_upload_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceLogUploadSettingsProto)
}

inline void DeviceLogUploadSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.system_log_upload_enabled_){false}
  };
}

DeviceLogUploadSettingsProto::~DeviceLogUploadSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceLogUploadSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLogUploadSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceLogUploadSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLogUploadSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceLogUploadSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.system_log_upload_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceLogUploadSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool system_log_upload_enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_system_log_upload_enabled(&has_bits);
          _impl_.system_log_upload_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLogUploadSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceLogUploadSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool system_log_upload_enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_system_log_upload_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceLogUploadSettingsProto)
  return target;
}

size_t DeviceLogUploadSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceLogUploadSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool system_log_upload_enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceLogUploadSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceLogUploadSettingsProto*>(
      &from));
}

void DeviceLogUploadSettingsProto::MergeFrom(const DeviceLogUploadSettingsProto& from) {
  DeviceLogUploadSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceLogUploadSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_system_log_upload_enabled()) {
    _this->_internal_set_system_log_upload_enabled(from._internal_system_log_upload_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceLogUploadSettingsProto::CopyFrom(const DeviceLogUploadSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceLogUploadSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLogUploadSettingsProto::IsInitialized() const {
  return true;
}

void DeviceLogUploadSettingsProto::InternalSwap(DeviceLogUploadSettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.system_log_upload_enabled_, other->_impl_.system_log_upload_enabled_);
}

std::string DeviceLogUploadSettingsProto::GetTypeName() const {
  return "enterprise_management.DeviceLogUploadSettingsProto";
}


// ===================================================================

class DisplayRotationDefaultProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DisplayRotationDefaultProto>()._impl_._has_bits_);
  static void set_has_display_rotation_default(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DisplayRotationDefaultProto::DisplayRotationDefaultProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DisplayRotationDefaultProto)
}
DisplayRotationDefaultProto::DisplayRotationDefaultProto(const DisplayRotationDefaultProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DisplayRotationDefaultProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.display_rotation_default_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.display_rotation_default_ = from._impl_.display_rotation_default_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DisplayRotationDefaultProto)
}

inline void DisplayRotationDefaultProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.display_rotation_default_){0}
  };
}

DisplayRotationDefaultProto::~DisplayRotationDefaultProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DisplayRotationDefaultProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DisplayRotationDefaultProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DisplayRotationDefaultProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DisplayRotationDefaultProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DisplayRotationDefaultProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.display_rotation_default_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DisplayRotationDefaultProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DisplayRotationDefaultProto.Rotation display_rotation_default = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DisplayRotationDefaultProto_Rotation_IsValid(val))) {
            _internal_set_display_rotation_default(static_cast<::enterprise_management::DisplayRotationDefaultProto_Rotation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DisplayRotationDefaultProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DisplayRotationDefaultProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DisplayRotationDefaultProto.Rotation display_rotation_default = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_display_rotation_default(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DisplayRotationDefaultProto)
  return target;
}

size_t DisplayRotationDefaultProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DisplayRotationDefaultProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DisplayRotationDefaultProto.Rotation display_rotation_default = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_display_rotation_default());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DisplayRotationDefaultProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DisplayRotationDefaultProto*>(
      &from));
}

void DisplayRotationDefaultProto::MergeFrom(const DisplayRotationDefaultProto& from) {
  DisplayRotationDefaultProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DisplayRotationDefaultProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_display_rotation_default()) {
    _this->_internal_set_display_rotation_default(from._internal_display_rotation_default());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisplayRotationDefaultProto::CopyFrom(const DisplayRotationDefaultProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DisplayRotationDefaultProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisplayRotationDefaultProto::IsInitialized() const {
  return true;
}

void DisplayRotationDefaultProto::InternalSwap(DisplayRotationDefaultProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.display_rotation_default_, other->_impl_.display_rotation_default_);
}

std::string DisplayRotationDefaultProto::GetTypeName() const {
  return "enterprise_management.DisplayRotationDefaultProto";
}


// ===================================================================

class DeviceLoginScreenPrivacyScreenEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceLoginScreenPrivacyScreenEnabledProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceLoginScreenPrivacyScreenEnabledProto::DeviceLoginScreenPrivacyScreenEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
}
DeviceLoginScreenPrivacyScreenEnabledProto::DeviceLoginScreenPrivacyScreenEnabledProto(const DeviceLoginScreenPrivacyScreenEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceLoginScreenPrivacyScreenEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
}

inline void DeviceLoginScreenPrivacyScreenEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceLoginScreenPrivacyScreenEnabledProto::~DeviceLoginScreenPrivacyScreenEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLoginScreenPrivacyScreenEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceLoginScreenPrivacyScreenEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLoginScreenPrivacyScreenEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceLoginScreenPrivacyScreenEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLoginScreenPrivacyScreenEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
  return target;
}

size_t DeviceLoginScreenPrivacyScreenEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceLoginScreenPrivacyScreenEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceLoginScreenPrivacyScreenEnabledProto*>(
      &from));
}

void DeviceLoginScreenPrivacyScreenEnabledProto::MergeFrom(const DeviceLoginScreenPrivacyScreenEnabledProto& from) {
  DeviceLoginScreenPrivacyScreenEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceLoginScreenPrivacyScreenEnabledProto::CopyFrom(const DeviceLoginScreenPrivacyScreenEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLoginScreenPrivacyScreenEnabledProto::IsInitialized() const {
  return true;
}

void DeviceLoginScreenPrivacyScreenEnabledProto::InternalSwap(DeviceLoginScreenPrivacyScreenEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceLoginScreenPrivacyScreenEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto";
}


// ===================================================================

class DeviceDisplayResolutionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceDisplayResolutionProto>()._impl_._has_bits_);
  static void set_has_device_display_resolution(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceDisplayResolutionProto::DeviceDisplayResolutionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceDisplayResolutionProto)
}
DeviceDisplayResolutionProto::DeviceDisplayResolutionProto(const DeviceDisplayResolutionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceDisplayResolutionProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_display_resolution_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_display_resolution_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_display_resolution_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_display_resolution()) {
    _this->_impl_.device_display_resolution_.Set(from._internal_device_display_resolution(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceDisplayResolutionProto)
}

inline void DeviceDisplayResolutionProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_display_resolution_){}
  };
  _impl_.device_display_resolution_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_display_resolution_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceDisplayResolutionProto::~DeviceDisplayResolutionProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceDisplayResolutionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceDisplayResolutionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_display_resolution_.Destroy();
}

void DeviceDisplayResolutionProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceDisplayResolutionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceDisplayResolutionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.device_display_resolution_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceDisplayResolutionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_display_resolution = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_display_resolution();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceDisplayResolutionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceDisplayResolutionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_display_resolution = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_display_resolution(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceDisplayResolutionProto)
  return target;
}

size_t DeviceDisplayResolutionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceDisplayResolutionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_display_resolution = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_display_resolution());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceDisplayResolutionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceDisplayResolutionProto*>(
      &from));
}

void DeviceDisplayResolutionProto::MergeFrom(const DeviceDisplayResolutionProto& from) {
  DeviceDisplayResolutionProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceDisplayResolutionProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_display_resolution()) {
    _this->_internal_set_device_display_resolution(from._internal_device_display_resolution());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceDisplayResolutionProto::CopyFrom(const DeviceDisplayResolutionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceDisplayResolutionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceDisplayResolutionProto::IsInitialized() const {
  return true;
}

void DeviceDisplayResolutionProto::InternalSwap(DeviceDisplayResolutionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_display_resolution_, lhs_arena,
      &other->_impl_.device_display_resolution_, rhs_arena
  );
}

std::string DeviceDisplayResolutionProto::GetTypeName() const {
  return "enterprise_management.DeviceDisplayResolutionProto";
}


// ===================================================================

class AllowKioskAppControlChromeVersionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AllowKioskAppControlChromeVersionProto>()._impl_._has_bits_);
  static void set_has_allow_kiosk_app_control_chrome_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AllowKioskAppControlChromeVersionProto::AllowKioskAppControlChromeVersionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AllowKioskAppControlChromeVersionProto)
}
AllowKioskAppControlChromeVersionProto::AllowKioskAppControlChromeVersionProto(const AllowKioskAppControlChromeVersionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllowKioskAppControlChromeVersionProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_kiosk_app_control_chrome_version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.allow_kiosk_app_control_chrome_version_ = from._impl_.allow_kiosk_app_control_chrome_version_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AllowKioskAppControlChromeVersionProto)
}

inline void AllowKioskAppControlChromeVersionProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_kiosk_app_control_chrome_version_){false}
  };
}

AllowKioskAppControlChromeVersionProto::~AllowKioskAppControlChromeVersionProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AllowKioskAppControlChromeVersionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllowKioskAppControlChromeVersionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllowKioskAppControlChromeVersionProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllowKioskAppControlChromeVersionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AllowKioskAppControlChromeVersionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allow_kiosk_app_control_chrome_version_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllowKioskAppControlChromeVersionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allow_kiosk_app_control_chrome_version = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allow_kiosk_app_control_chrome_version(&has_bits);
          _impl_.allow_kiosk_app_control_chrome_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllowKioskAppControlChromeVersionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AllowKioskAppControlChromeVersionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool allow_kiosk_app_control_chrome_version = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allow_kiosk_app_control_chrome_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AllowKioskAppControlChromeVersionProto)
  return target;
}

size_t AllowKioskAppControlChromeVersionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AllowKioskAppControlChromeVersionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool allow_kiosk_app_control_chrome_version = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllowKioskAppControlChromeVersionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllowKioskAppControlChromeVersionProto*>(
      &from));
}

void AllowKioskAppControlChromeVersionProto::MergeFrom(const AllowKioskAppControlChromeVersionProto& from) {
  AllowKioskAppControlChromeVersionProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AllowKioskAppControlChromeVersionProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_allow_kiosk_app_control_chrome_version()) {
    _this->_internal_set_allow_kiosk_app_control_chrome_version(from._internal_allow_kiosk_app_control_chrome_version());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllowKioskAppControlChromeVersionProto::CopyFrom(const AllowKioskAppControlChromeVersionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AllowKioskAppControlChromeVersionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllowKioskAppControlChromeVersionProto::IsInitialized() const {
  return true;
}

void AllowKioskAppControlChromeVersionProto::InternalSwap(AllowKioskAppControlChromeVersionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.allow_kiosk_app_control_chrome_version_, other->_impl_.allow_kiosk_app_control_chrome_version_);
}

std::string AllowKioskAppControlChromeVersionProto::GetTypeName() const {
  return "enterprise_management.AllowKioskAppControlChromeVersionProto";
}


// ===================================================================

class LoginAuthenticationBehaviorProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginAuthenticationBehaviorProto>()._impl_._has_bits_);
  static void set_has_login_authentication_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoginAuthenticationBehaviorProto::LoginAuthenticationBehaviorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LoginAuthenticationBehaviorProto)
}
LoginAuthenticationBehaviorProto::LoginAuthenticationBehaviorProto(const LoginAuthenticationBehaviorProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginAuthenticationBehaviorProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_authentication_behavior_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.login_authentication_behavior_ = from._impl_.login_authentication_behavior_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LoginAuthenticationBehaviorProto)
}

inline void LoginAuthenticationBehaviorProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_authentication_behavior_){0}
  };
}

LoginAuthenticationBehaviorProto::~LoginAuthenticationBehaviorProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.LoginAuthenticationBehaviorProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginAuthenticationBehaviorProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoginAuthenticationBehaviorProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginAuthenticationBehaviorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LoginAuthenticationBehaviorProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.login_authentication_behavior_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginAuthenticationBehaviorProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.LoginAuthenticationBehaviorProto.LoginBehavior login_authentication_behavior = 1 [default = GAIA];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior_IsValid(val))) {
            _internal_set_login_authentication_behavior(static_cast<::enterprise_management::LoginAuthenticationBehaviorProto_LoginBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginAuthenticationBehaviorProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LoginAuthenticationBehaviorProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.LoginAuthenticationBehaviorProto.LoginBehavior login_authentication_behavior = 1 [default = GAIA];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_login_authentication_behavior(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LoginAuthenticationBehaviorProto)
  return target;
}

size_t LoginAuthenticationBehaviorProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LoginAuthenticationBehaviorProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.LoginAuthenticationBehaviorProto.LoginBehavior login_authentication_behavior = 1 [default = GAIA];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_login_authentication_behavior());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginAuthenticationBehaviorProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginAuthenticationBehaviorProto*>(
      &from));
}

void LoginAuthenticationBehaviorProto::MergeFrom(const LoginAuthenticationBehaviorProto& from) {
  LoginAuthenticationBehaviorProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LoginAuthenticationBehaviorProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_login_authentication_behavior()) {
    _this->_internal_set_login_authentication_behavior(from._internal_login_authentication_behavior());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginAuthenticationBehaviorProto::CopyFrom(const LoginAuthenticationBehaviorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LoginAuthenticationBehaviorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginAuthenticationBehaviorProto::IsInitialized() const {
  return true;
}

void LoginAuthenticationBehaviorProto::InternalSwap(LoginAuthenticationBehaviorProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.login_authentication_behavior_, other->_impl_.login_authentication_behavior_);
}

std::string LoginAuthenticationBehaviorProto::GetTypeName() const {
  return "enterprise_management.LoginAuthenticationBehaviorProto";
}


// ===================================================================

class UsbDeviceIdProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceIdProto>()._impl_._has_bits_);
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_product_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbDeviceIdProto::UsbDeviceIdProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UsbDeviceIdProto)
}
UsbDeviceIdProto::UsbDeviceIdProto(const UsbDeviceIdProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UsbDeviceIdProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vendor_id_){}
    , decltype(_impl_.product_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vendor_id_, &from._impl_.vendor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.product_id_) -
    reinterpret_cast<char*>(&_impl_.vendor_id_)) + sizeof(_impl_.product_id_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UsbDeviceIdProto)
}

inline void UsbDeviceIdProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vendor_id_){0}
    , decltype(_impl_.product_id_){0}
  };
}

UsbDeviceIdProto::~UsbDeviceIdProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.UsbDeviceIdProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsbDeviceIdProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UsbDeviceIdProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsbDeviceIdProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UsbDeviceIdProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vendor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.product_id_) -
        reinterpret_cast<char*>(&_impl_.vendor_id_)) + sizeof(_impl_.product_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UsbDeviceIdProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 vendor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vendor_id(&has_bits);
          _impl_.vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 product_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_product_id(&has_bits);
          _impl_.product_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsbDeviceIdProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UsbDeviceIdProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 vendor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_vendor_id(), target);
  }

  // optional int32 product_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_product_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UsbDeviceIdProto)
  return target;
}

size_t UsbDeviceIdProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UsbDeviceIdProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 vendor_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vendor_id());
    }

    // optional int32 product_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_product_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceIdProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UsbDeviceIdProto*>(
      &from));
}

void UsbDeviceIdProto::MergeFrom(const UsbDeviceIdProto& from) {
  UsbDeviceIdProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UsbDeviceIdProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vendor_id_ = from._impl_.vendor_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.product_id_ = from._impl_.product_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UsbDeviceIdProto::CopyFrom(const UsbDeviceIdProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UsbDeviceIdProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceIdProto::IsInitialized() const {
  return true;
}

void UsbDeviceIdProto::InternalSwap(UsbDeviceIdProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UsbDeviceIdProto, _impl_.product_id_)
      + sizeof(UsbDeviceIdProto::_impl_.product_id_)
      - PROTOBUF_FIELD_OFFSET(UsbDeviceIdProto, _impl_.vendor_id_)>(
          reinterpret_cast<char*>(&_impl_.vendor_id_),
          reinterpret_cast<char*>(&other->_impl_.vendor_id_));
}

std::string UsbDeviceIdProto::GetTypeName() const {
  return "enterprise_management.UsbDeviceIdProto";
}


// ===================================================================

class UsbDetachableWhitelistProto::_Internal {
 public:
};

UsbDetachableWhitelistProto::UsbDetachableWhitelistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UsbDetachableWhitelistProto)
}
UsbDetachableWhitelistProto::UsbDetachableWhitelistProto(const UsbDetachableWhitelistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UsbDetachableWhitelistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){from._impl_.id_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UsbDetachableWhitelistProto)
}

inline void UsbDetachableWhitelistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UsbDetachableWhitelistProto::~UsbDetachableWhitelistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.UsbDetachableWhitelistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsbDetachableWhitelistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.~RepeatedPtrField();
}

void UsbDetachableWhitelistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsbDetachableWhitelistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UsbDetachableWhitelistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UsbDetachableWhitelistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.UsbDeviceIdProto id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_id(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsbDetachableWhitelistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UsbDetachableWhitelistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.UsbDeviceIdProto id = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_id_size()); i < n; i++) {
    const auto& repfield = this->_internal_id(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UsbDetachableWhitelistProto)
  return target;
}

size_t UsbDetachableWhitelistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UsbDetachableWhitelistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.UsbDeviceIdProto id = 1;
  total_size += 1UL * this->_internal_id_size();
  for (const auto& msg : this->_impl_.id_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDetachableWhitelistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UsbDetachableWhitelistProto*>(
      &from));
}

void UsbDetachableWhitelistProto::MergeFrom(const UsbDetachableWhitelistProto& from) {
  UsbDetachableWhitelistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UsbDetachableWhitelistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.id_.MergeFrom(from._impl_.id_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UsbDetachableWhitelistProto::CopyFrom(const UsbDetachableWhitelistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UsbDetachableWhitelistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDetachableWhitelistProto::IsInitialized() const {
  return true;
}

void UsbDetachableWhitelistProto::InternalSwap(UsbDetachableWhitelistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.id_.InternalSwap(&other->_impl_.id_);
}

std::string UsbDetachableWhitelistProto::GetTypeName() const {
  return "enterprise_management.UsbDetachableWhitelistProto";
}


// ===================================================================

class UsbDeviceIdInclusiveProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UsbDeviceIdInclusiveProto>()._impl_._has_bits_);
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_product_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UsbDeviceIdInclusiveProto::UsbDeviceIdInclusiveProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UsbDeviceIdInclusiveProto)
}
UsbDeviceIdInclusiveProto::UsbDeviceIdInclusiveProto(const UsbDeviceIdInclusiveProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UsbDeviceIdInclusiveProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vendor_id_){}
    , decltype(_impl_.product_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vendor_id_, &from._impl_.vendor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.product_id_) -
    reinterpret_cast<char*>(&_impl_.vendor_id_)) + sizeof(_impl_.product_id_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UsbDeviceIdInclusiveProto)
}

inline void UsbDeviceIdInclusiveProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vendor_id_){0}
    , decltype(_impl_.product_id_){0}
  };
}

UsbDeviceIdInclusiveProto::~UsbDeviceIdInclusiveProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.UsbDeviceIdInclusiveProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsbDeviceIdInclusiveProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UsbDeviceIdInclusiveProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsbDeviceIdInclusiveProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UsbDeviceIdInclusiveProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vendor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.product_id_) -
        reinterpret_cast<char*>(&_impl_.vendor_id_)) + sizeof(_impl_.product_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UsbDeviceIdInclusiveProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 vendor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vendor_id(&has_bits);
          _impl_.vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 product_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_product_id(&has_bits);
          _impl_.product_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsbDeviceIdInclusiveProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UsbDeviceIdInclusiveProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 vendor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_vendor_id(), target);
  }

  // optional int32 product_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_product_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UsbDeviceIdInclusiveProto)
  return target;
}

size_t UsbDeviceIdInclusiveProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UsbDeviceIdInclusiveProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 vendor_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vendor_id());
    }

    // optional int32 product_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_product_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDeviceIdInclusiveProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UsbDeviceIdInclusiveProto*>(
      &from));
}

void UsbDeviceIdInclusiveProto::MergeFrom(const UsbDeviceIdInclusiveProto& from) {
  UsbDeviceIdInclusiveProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UsbDeviceIdInclusiveProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vendor_id_ = from._impl_.vendor_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.product_id_ = from._impl_.product_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UsbDeviceIdInclusiveProto::CopyFrom(const UsbDeviceIdInclusiveProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UsbDeviceIdInclusiveProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDeviceIdInclusiveProto::IsInitialized() const {
  return true;
}

void UsbDeviceIdInclusiveProto::InternalSwap(UsbDeviceIdInclusiveProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UsbDeviceIdInclusiveProto, _impl_.product_id_)
      + sizeof(UsbDeviceIdInclusiveProto::_impl_.product_id_)
      - PROTOBUF_FIELD_OFFSET(UsbDeviceIdInclusiveProto, _impl_.vendor_id_)>(
          reinterpret_cast<char*>(&_impl_.vendor_id_),
          reinterpret_cast<char*>(&other->_impl_.vendor_id_));
}

std::string UsbDeviceIdInclusiveProto::GetTypeName() const {
  return "enterprise_management.UsbDeviceIdInclusiveProto";
}


// ===================================================================

class UsbDetachableAllowlistProto::_Internal {
 public:
};

UsbDetachableAllowlistProto::UsbDetachableAllowlistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UsbDetachableAllowlistProto)
}
UsbDetachableAllowlistProto::UsbDetachableAllowlistProto(const UsbDetachableAllowlistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UsbDetachableAllowlistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){from._impl_.id_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UsbDetachableAllowlistProto)
}

inline void UsbDetachableAllowlistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UsbDetachableAllowlistProto::~UsbDetachableAllowlistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.UsbDetachableAllowlistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsbDetachableAllowlistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.~RepeatedPtrField();
}

void UsbDetachableAllowlistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsbDetachableAllowlistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UsbDetachableAllowlistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UsbDetachableAllowlistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.UsbDeviceIdInclusiveProto id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_id(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsbDetachableAllowlistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UsbDetachableAllowlistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.UsbDeviceIdInclusiveProto id = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_id_size()); i < n; i++) {
    const auto& repfield = this->_internal_id(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UsbDetachableAllowlistProto)
  return target;
}

size_t UsbDetachableAllowlistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UsbDetachableAllowlistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.UsbDeviceIdInclusiveProto id = 1;
  total_size += 1UL * this->_internal_id_size();
  for (const auto& msg : this->_impl_.id_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsbDetachableAllowlistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UsbDetachableAllowlistProto*>(
      &from));
}

void UsbDetachableAllowlistProto::MergeFrom(const UsbDetachableAllowlistProto& from) {
  UsbDetachableAllowlistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UsbDetachableAllowlistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.id_.MergeFrom(from._impl_.id_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UsbDetachableAllowlistProto::CopyFrom(const UsbDetachableAllowlistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UsbDetachableAllowlistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsbDetachableAllowlistProto::IsInitialized() const {
  return true;
}

void UsbDetachableAllowlistProto::InternalSwap(UsbDetachableAllowlistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.id_.InternalSwap(&other->_impl_.id_);
}

std::string UsbDetachableAllowlistProto::GetTypeName() const {
  return "enterprise_management.UsbDetachableAllowlistProto";
}


// ===================================================================

class AllowBluetoothProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AllowBluetoothProto>()._impl_._has_bits_);
  static void set_has_allow_bluetooth(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AllowBluetoothProto::AllowBluetoothProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AllowBluetoothProto)
}
AllowBluetoothProto::AllowBluetoothProto(const AllowBluetoothProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllowBluetoothProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_bluetooth_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.allow_bluetooth_ = from._impl_.allow_bluetooth_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AllowBluetoothProto)
}

inline void AllowBluetoothProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_bluetooth_){true}
  };
}

AllowBluetoothProto::~AllowBluetoothProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.AllowBluetoothProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllowBluetoothProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllowBluetoothProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllowBluetoothProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AllowBluetoothProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allow_bluetooth_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllowBluetoothProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allow_bluetooth = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allow_bluetooth(&has_bits);
          _impl_.allow_bluetooth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllowBluetoothProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AllowBluetoothProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool allow_bluetooth = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allow_bluetooth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AllowBluetoothProto)
  return target;
}

size_t AllowBluetoothProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AllowBluetoothProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool allow_bluetooth = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllowBluetoothProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllowBluetoothProto*>(
      &from));
}

void AllowBluetoothProto::MergeFrom(const AllowBluetoothProto& from) {
  AllowBluetoothProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AllowBluetoothProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_allow_bluetooth()) {
    _this->_internal_set_allow_bluetooth(from._internal_allow_bluetooth());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllowBluetoothProto::CopyFrom(const AllowBluetoothProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AllowBluetoothProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllowBluetoothProto::IsInitialized() const {
  return true;
}

void AllowBluetoothProto::InternalSwap(AllowBluetoothProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.allow_bluetooth_, other->_impl_.allow_bluetooth_);
}

std::string AllowBluetoothProto::GetTypeName() const {
  return "enterprise_management.AllowBluetoothProto";
}


// ===================================================================

class DeviceWiFiAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceWiFiAllowedProto>()._impl_._has_bits_);
  static void set_has_device_wifi_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceWiFiAllowedProto::DeviceWiFiAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceWiFiAllowedProto)
}
DeviceWiFiAllowedProto::DeviceWiFiAllowedProto(const DeviceWiFiAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceWiFiAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wifi_allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_wifi_allowed_ = from._impl_.device_wifi_allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceWiFiAllowedProto)
}

inline void DeviceWiFiAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wifi_allowed_){true}
  };
}

DeviceWiFiAllowedProto::~DeviceWiFiAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceWiFiAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceWiFiAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceWiFiAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceWiFiAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceWiFiAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_wifi_allowed_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceWiFiAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_wifi_allowed = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_wifi_allowed(&has_bits);
          _impl_.device_wifi_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceWiFiAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceWiFiAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_wifi_allowed = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_wifi_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceWiFiAllowedProto)
  return target;
}

size_t DeviceWiFiAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceWiFiAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_wifi_allowed = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceWiFiAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceWiFiAllowedProto*>(
      &from));
}

void DeviceWiFiAllowedProto::MergeFrom(const DeviceWiFiAllowedProto& from) {
  DeviceWiFiAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceWiFiAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_wifi_allowed()) {
    _this->_internal_set_device_wifi_allowed(from._internal_device_wifi_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceWiFiAllowedProto::CopyFrom(const DeviceWiFiAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceWiFiAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceWiFiAllowedProto::IsInitialized() const {
  return true;
}

void DeviceWiFiAllowedProto::InternalSwap(DeviceWiFiAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_wifi_allowed_, other->_impl_.device_wifi_allowed_);
}

std::string DeviceWiFiAllowedProto::GetTypeName() const {
  return "enterprise_management.DeviceWiFiAllowedProto";
}


// ===================================================================

class DeviceQuirksDownloadEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceQuirksDownloadEnabledProto>()._impl_._has_bits_);
  static void set_has_quirks_download_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceQuirksDownloadEnabledProto::DeviceQuirksDownloadEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceQuirksDownloadEnabledProto)
}
DeviceQuirksDownloadEnabledProto::DeviceQuirksDownloadEnabledProto(const DeviceQuirksDownloadEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceQuirksDownloadEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.quirks_download_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.quirks_download_enabled_ = from._impl_.quirks_download_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceQuirksDownloadEnabledProto)
}

inline void DeviceQuirksDownloadEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.quirks_download_enabled_){false}
  };
}

DeviceQuirksDownloadEnabledProto::~DeviceQuirksDownloadEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceQuirksDownloadEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceQuirksDownloadEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceQuirksDownloadEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceQuirksDownloadEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceQuirksDownloadEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.quirks_download_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceQuirksDownloadEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool quirks_download_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_quirks_download_enabled(&has_bits);
          _impl_.quirks_download_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceQuirksDownloadEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceQuirksDownloadEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool quirks_download_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_quirks_download_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceQuirksDownloadEnabledProto)
  return target;
}

size_t DeviceQuirksDownloadEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceQuirksDownloadEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool quirks_download_enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceQuirksDownloadEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceQuirksDownloadEnabledProto*>(
      &from));
}

void DeviceQuirksDownloadEnabledProto::MergeFrom(const DeviceQuirksDownloadEnabledProto& from) {
  DeviceQuirksDownloadEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceQuirksDownloadEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_quirks_download_enabled()) {
    _this->_internal_set_quirks_download_enabled(from._internal_quirks_download_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceQuirksDownloadEnabledProto::CopyFrom(const DeviceQuirksDownloadEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceQuirksDownloadEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceQuirksDownloadEnabledProto::IsInitialized() const {
  return true;
}

void DeviceQuirksDownloadEnabledProto::InternalSwap(DeviceQuirksDownloadEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.quirks_download_enabled_, other->_impl_.quirks_download_enabled_);
}

std::string DeviceQuirksDownloadEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceQuirksDownloadEnabledProto";
}


// ===================================================================

class LoginVideoCaptureAllowedUrlsProto::_Internal {
 public:
};

LoginVideoCaptureAllowedUrlsProto::LoginVideoCaptureAllowedUrlsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
}
LoginVideoCaptureAllowedUrlsProto::LoginVideoCaptureAllowedUrlsProto(const LoginVideoCaptureAllowedUrlsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginVideoCaptureAllowedUrlsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.urls_){from._impl_.urls_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
}

inline void LoginVideoCaptureAllowedUrlsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.urls_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LoginVideoCaptureAllowedUrlsProto::~LoginVideoCaptureAllowedUrlsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginVideoCaptureAllowedUrlsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.urls_.~RepeatedPtrField();
}

void LoginVideoCaptureAllowedUrlsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginVideoCaptureAllowedUrlsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.urls_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginVideoCaptureAllowedUrlsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string urls = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_urls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginVideoCaptureAllowedUrlsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string urls = 1;
  for (int i = 0, n = this->_internal_urls_size(); i < n; i++) {
    const auto& s = this->_internal_urls(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
  return target;
}

size_t LoginVideoCaptureAllowedUrlsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string urls = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.urls_.size());
  for (int i = 0, n = _impl_.urls_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.urls_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginVideoCaptureAllowedUrlsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginVideoCaptureAllowedUrlsProto*>(
      &from));
}

void LoginVideoCaptureAllowedUrlsProto::MergeFrom(const LoginVideoCaptureAllowedUrlsProto& from) {
  LoginVideoCaptureAllowedUrlsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.urls_.MergeFrom(from._impl_.urls_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginVideoCaptureAllowedUrlsProto::CopyFrom(const LoginVideoCaptureAllowedUrlsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LoginVideoCaptureAllowedUrlsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginVideoCaptureAllowedUrlsProto::IsInitialized() const {
  return true;
}

void LoginVideoCaptureAllowedUrlsProto::InternalSwap(LoginVideoCaptureAllowedUrlsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.urls_.InternalSwap(&other->_impl_.urls_);
}

std::string LoginVideoCaptureAllowedUrlsProto::GetTypeName() const {
  return "enterprise_management.LoginVideoCaptureAllowedUrlsProto";
}


// ===================================================================

class DeviceWiFiFastTransitionEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceWiFiFastTransitionEnabledProto>()._impl_._has_bits_);
  static void set_has_device_wifi_fast_transition_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceWiFiFastTransitionEnabledProto::DeviceWiFiFastTransitionEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
}
DeviceWiFiFastTransitionEnabledProto::DeviceWiFiFastTransitionEnabledProto(const DeviceWiFiFastTransitionEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceWiFiFastTransitionEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wifi_fast_transition_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_wifi_fast_transition_enabled_ = from._impl_.device_wifi_fast_transition_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
}

inline void DeviceWiFiFastTransitionEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wifi_fast_transition_enabled_){false}
  };
}

DeviceWiFiFastTransitionEnabledProto::~DeviceWiFiFastTransitionEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceWiFiFastTransitionEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceWiFiFastTransitionEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceWiFiFastTransitionEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_wifi_fast_transition_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceWiFiFastTransitionEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_wifi_fast_transition_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_wifi_fast_transition_enabled(&has_bits);
          _impl_.device_wifi_fast_transition_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceWiFiFastTransitionEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_wifi_fast_transition_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_wifi_fast_transition_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
  return target;
}

size_t DeviceWiFiFastTransitionEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_wifi_fast_transition_enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceWiFiFastTransitionEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceWiFiFastTransitionEnabledProto*>(
      &from));
}

void DeviceWiFiFastTransitionEnabledProto::MergeFrom(const DeviceWiFiFastTransitionEnabledProto& from) {
  DeviceWiFiFastTransitionEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_wifi_fast_transition_enabled()) {
    _this->_internal_set_device_wifi_fast_transition_enabled(from._internal_device_wifi_fast_transition_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceWiFiFastTransitionEnabledProto::CopyFrom(const DeviceWiFiFastTransitionEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceWiFiFastTransitionEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceWiFiFastTransitionEnabledProto::IsInitialized() const {
  return true;
}

void DeviceWiFiFastTransitionEnabledProto::InternalSwap(DeviceWiFiFastTransitionEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_wifi_fast_transition_enabled_, other->_impl_.device_wifi_fast_transition_enabled_);
}

std::string DeviceWiFiFastTransitionEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceWiFiFastTransitionEnabledProto";
}


// ===================================================================

class NetworkThrottlingEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NetworkThrottlingEnabledProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_upload_rate_kbits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_download_rate_kbits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

NetworkThrottlingEnabledProto::NetworkThrottlingEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.NetworkThrottlingEnabledProto)
}
NetworkThrottlingEnabledProto::NetworkThrottlingEnabledProto(const NetworkThrottlingEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkThrottlingEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.upload_rate_kbits_){}
    , decltype(_impl_.download_rate_kbits_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.download_rate_kbits_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.download_rate_kbits_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.NetworkThrottlingEnabledProto)
}

inline void NetworkThrottlingEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.upload_rate_kbits_){0}
    , decltype(_impl_.download_rate_kbits_){0}
  };
}

NetworkThrottlingEnabledProto::~NetworkThrottlingEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.NetworkThrottlingEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkThrottlingEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NetworkThrottlingEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkThrottlingEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.NetworkThrottlingEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.download_rate_kbits_) -
        reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.download_rate_kbits_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkThrottlingEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 upload_rate_kbits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_upload_rate_kbits(&has_bits);
          _impl_.upload_rate_kbits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 download_rate_kbits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_download_rate_kbits(&has_bits);
          _impl_.download_rate_kbits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkThrottlingEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.NetworkThrottlingEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // optional int32 upload_rate_kbits = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_upload_rate_kbits(), target);
  }

  // optional int32 download_rate_kbits = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_download_rate_kbits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.NetworkThrottlingEnabledProto)
  return target;
}

size_t NetworkThrottlingEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.NetworkThrottlingEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool enabled = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 upload_rate_kbits = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_upload_rate_kbits());
    }

    // optional int32 download_rate_kbits = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_download_rate_kbits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkThrottlingEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkThrottlingEnabledProto*>(
      &from));
}

void NetworkThrottlingEnabledProto::MergeFrom(const NetworkThrottlingEnabledProto& from) {
  NetworkThrottlingEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.NetworkThrottlingEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.upload_rate_kbits_ = from._impl_.upload_rate_kbits_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.download_rate_kbits_ = from._impl_.download_rate_kbits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkThrottlingEnabledProto::CopyFrom(const NetworkThrottlingEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.NetworkThrottlingEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkThrottlingEnabledProto::IsInitialized() const {
  return true;
}

void NetworkThrottlingEnabledProto::InternalSwap(NetworkThrottlingEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetworkThrottlingEnabledProto, _impl_.download_rate_kbits_)
      + sizeof(NetworkThrottlingEnabledProto::_impl_.download_rate_kbits_)
      - PROTOBUF_FIELD_OFFSET(NetworkThrottlingEnabledProto, _impl_.enabled_)>(
          reinterpret_cast<char*>(&_impl_.enabled_),
          reinterpret_cast<char*>(&other->_impl_.enabled_));
}

std::string NetworkThrottlingEnabledProto::GetTypeName() const {
  return "enterprise_management.NetworkThrottlingEnabledProto";
}


// ===================================================================

class DeviceLoginScreenExtensionsProto::_Internal {
 public:
};

DeviceLoginScreenExtensionsProto::DeviceLoginScreenExtensionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceLoginScreenExtensionsProto)
}
DeviceLoginScreenExtensionsProto::DeviceLoginScreenExtensionsProto(const DeviceLoginScreenExtensionsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceLoginScreenExtensionsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.device_login_screen_extensions_){from._impl_.device_login_screen_extensions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceLoginScreenExtensionsProto)
}

inline void DeviceLoginScreenExtensionsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.device_login_screen_extensions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceLoginScreenExtensionsProto::~DeviceLoginScreenExtensionsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceLoginScreenExtensionsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLoginScreenExtensionsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_login_screen_extensions_.~RepeatedPtrField();
}

void DeviceLoginScreenExtensionsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLoginScreenExtensionsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceLoginScreenExtensionsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_login_screen_extensions_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceLoginScreenExtensionsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string device_login_screen_extensions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_device_login_screen_extensions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLoginScreenExtensionsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceLoginScreenExtensionsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string device_login_screen_extensions = 1;
  for (int i = 0, n = this->_internal_device_login_screen_extensions_size(); i < n; i++) {
    const auto& s = this->_internal_device_login_screen_extensions(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceLoginScreenExtensionsProto)
  return target;
}

size_t DeviceLoginScreenExtensionsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceLoginScreenExtensionsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string device_login_screen_extensions = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.device_login_screen_extensions_.size());
  for (int i = 0, n = _impl_.device_login_screen_extensions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.device_login_screen_extensions_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceLoginScreenExtensionsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceLoginScreenExtensionsProto*>(
      &from));
}

void DeviceLoginScreenExtensionsProto::MergeFrom(const DeviceLoginScreenExtensionsProto& from) {
  DeviceLoginScreenExtensionsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceLoginScreenExtensionsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.device_login_screen_extensions_.MergeFrom(from._impl_.device_login_screen_extensions_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceLoginScreenExtensionsProto::CopyFrom(const DeviceLoginScreenExtensionsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceLoginScreenExtensionsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLoginScreenExtensionsProto::IsInitialized() const {
  return true;
}

void DeviceLoginScreenExtensionsProto::InternalSwap(DeviceLoginScreenExtensionsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.device_login_screen_extensions_.InternalSwap(&other->_impl_.device_login_screen_extensions_);
}

std::string DeviceLoginScreenExtensionsProto::GetTypeName() const {
  return "enterprise_management.DeviceLoginScreenExtensionsProto";
}


// ===================================================================

class LoginScreenExtensionManifestV2AvailabilityProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginScreenExtensionManifestV2AvailabilityProto>()._impl_._has_bits_);
  static void set_has_login_screen_extension_manifest_v2_availability(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoginScreenExtensionManifestV2AvailabilityProto::LoginScreenExtensionManifestV2AvailabilityProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
}
LoginScreenExtensionManifestV2AvailabilityProto::LoginScreenExtensionManifestV2AvailabilityProto(const LoginScreenExtensionManifestV2AvailabilityProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginScreenExtensionManifestV2AvailabilityProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_screen_extension_manifest_v2_availability_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.login_screen_extension_manifest_v2_availability_ = from._impl_.login_screen_extension_manifest_v2_availability_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
}

inline void LoginScreenExtensionManifestV2AvailabilityProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.login_screen_extension_manifest_v2_availability_){0}
  };
}

LoginScreenExtensionManifestV2AvailabilityProto::~LoginScreenExtensionManifestV2AvailabilityProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginScreenExtensionManifestV2AvailabilityProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoginScreenExtensionManifestV2AvailabilityProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginScreenExtensionManifestV2AvailabilityProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.login_screen_extension_manifest_v2_availability_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginScreenExtensionManifestV2AvailabilityProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto.Availability login_screen_extension_manifest_v2_availability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability_IsValid(val))) {
            _internal_set_login_screen_extension_manifest_v2_availability(static_cast<::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto_Availability>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginScreenExtensionManifestV2AvailabilityProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto.Availability login_screen_extension_manifest_v2_availability = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_login_screen_extension_manifest_v2_availability(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
  return target;
}

size_t LoginScreenExtensionManifestV2AvailabilityProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto.Availability login_screen_extension_manifest_v2_availability = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_login_screen_extension_manifest_v2_availability());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginScreenExtensionManifestV2AvailabilityProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginScreenExtensionManifestV2AvailabilityProto*>(
      &from));
}

void LoginScreenExtensionManifestV2AvailabilityProto::MergeFrom(const LoginScreenExtensionManifestV2AvailabilityProto& from) {
  LoginScreenExtensionManifestV2AvailabilityProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_login_screen_extension_manifest_v2_availability()) {
    _this->_internal_set_login_screen_extension_manifest_v2_availability(from._internal_login_screen_extension_manifest_v2_availability());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginScreenExtensionManifestV2AvailabilityProto::CopyFrom(const LoginScreenExtensionManifestV2AvailabilityProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginScreenExtensionManifestV2AvailabilityProto::IsInitialized() const {
  return true;
}

void LoginScreenExtensionManifestV2AvailabilityProto::InternalSwap(LoginScreenExtensionManifestV2AvailabilityProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.login_screen_extension_manifest_v2_availability_, other->_impl_.login_screen_extension_manifest_v2_availability_);
}

std::string LoginScreenExtensionManifestV2AvailabilityProto::GetTypeName() const {
  return "enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto";
}


// ===================================================================

class LoginScreenLocalesProto::_Internal {
 public:
};

LoginScreenLocalesProto::LoginScreenLocalesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LoginScreenLocalesProto)
}
LoginScreenLocalesProto::LoginScreenLocalesProto(const LoginScreenLocalesProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginScreenLocalesProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.login_screen_locales_){from._impl_.login_screen_locales_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LoginScreenLocalesProto)
}

inline void LoginScreenLocalesProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.login_screen_locales_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LoginScreenLocalesProto::~LoginScreenLocalesProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.LoginScreenLocalesProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginScreenLocalesProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.login_screen_locales_.~RepeatedPtrField();
}

void LoginScreenLocalesProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginScreenLocalesProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LoginScreenLocalesProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.login_screen_locales_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginScreenLocalesProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string login_screen_locales = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_login_screen_locales();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginScreenLocalesProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LoginScreenLocalesProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string login_screen_locales = 1;
  for (int i = 0, n = this->_internal_login_screen_locales_size(); i < n; i++) {
    const auto& s = this->_internal_login_screen_locales(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LoginScreenLocalesProto)
  return target;
}

size_t LoginScreenLocalesProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LoginScreenLocalesProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string login_screen_locales = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.login_screen_locales_.size());
  for (int i = 0, n = _impl_.login_screen_locales_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.login_screen_locales_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginScreenLocalesProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginScreenLocalesProto*>(
      &from));
}

void LoginScreenLocalesProto::MergeFrom(const LoginScreenLocalesProto& from) {
  LoginScreenLocalesProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LoginScreenLocalesProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.login_screen_locales_.MergeFrom(from._impl_.login_screen_locales_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginScreenLocalesProto::CopyFrom(const LoginScreenLocalesProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LoginScreenLocalesProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginScreenLocalesProto::IsInitialized() const {
  return true;
}

void LoginScreenLocalesProto::InternalSwap(LoginScreenLocalesProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.login_screen_locales_.InternalSwap(&other->_impl_.login_screen_locales_);
}

std::string LoginScreenLocalesProto::GetTypeName() const {
  return "enterprise_management.LoginScreenLocalesProto";
}


// ===================================================================

class LoginScreenInputMethodsProto::_Internal {
 public:
};

LoginScreenInputMethodsProto::LoginScreenInputMethodsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LoginScreenInputMethodsProto)
}
LoginScreenInputMethodsProto::LoginScreenInputMethodsProto(const LoginScreenInputMethodsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginScreenInputMethodsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.login_screen_input_methods_){from._impl_.login_screen_input_methods_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LoginScreenInputMethodsProto)
}

inline void LoginScreenInputMethodsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.login_screen_input_methods_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LoginScreenInputMethodsProto::~LoginScreenInputMethodsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.LoginScreenInputMethodsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginScreenInputMethodsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.login_screen_input_methods_.~RepeatedPtrField();
}

void LoginScreenInputMethodsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginScreenInputMethodsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LoginScreenInputMethodsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.login_screen_input_methods_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginScreenInputMethodsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string login_screen_input_methods = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_login_screen_input_methods();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginScreenInputMethodsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LoginScreenInputMethodsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string login_screen_input_methods = 1;
  for (int i = 0, n = this->_internal_login_screen_input_methods_size(); i < n; i++) {
    const auto& s = this->_internal_login_screen_input_methods(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LoginScreenInputMethodsProto)
  return target;
}

size_t LoginScreenInputMethodsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LoginScreenInputMethodsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string login_screen_input_methods = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.login_screen_input_methods_.size());
  for (int i = 0, n = _impl_.login_screen_input_methods_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.login_screen_input_methods_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginScreenInputMethodsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginScreenInputMethodsProto*>(
      &from));
}

void LoginScreenInputMethodsProto::MergeFrom(const LoginScreenInputMethodsProto& from) {
  LoginScreenInputMethodsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LoginScreenInputMethodsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.login_screen_input_methods_.MergeFrom(from._impl_.login_screen_input_methods_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginScreenInputMethodsProto::CopyFrom(const LoginScreenInputMethodsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LoginScreenInputMethodsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginScreenInputMethodsProto::IsInitialized() const {
  return true;
}

void LoginScreenInputMethodsProto::InternalSwap(LoginScreenInputMethodsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.login_screen_input_methods_.InternalSwap(&other->_impl_.login_screen_input_methods_);
}

std::string LoginScreenInputMethodsProto::GetTypeName() const {
  return "enterprise_management.LoginScreenInputMethodsProto";
}


// ===================================================================

class DeviceWallpaperImageProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceWallpaperImageProto>()._impl_._has_bits_);
  static void set_has_device_wallpaper_image(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceWallpaperImageProto::DeviceWallpaperImageProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceWallpaperImageProto)
}
DeviceWallpaperImageProto::DeviceWallpaperImageProto(const DeviceWallpaperImageProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceWallpaperImageProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wallpaper_image_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_wallpaper_image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_wallpaper_image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_wallpaper_image()) {
    _this->_impl_.device_wallpaper_image_.Set(from._internal_device_wallpaper_image(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceWallpaperImageProto)
}

inline void DeviceWallpaperImageProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wallpaper_image_){}
  };
  _impl_.device_wallpaper_image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_wallpaper_image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceWallpaperImageProto::~DeviceWallpaperImageProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceWallpaperImageProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceWallpaperImageProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_wallpaper_image_.Destroy();
}

void DeviceWallpaperImageProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceWallpaperImageProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceWallpaperImageProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.device_wallpaper_image_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceWallpaperImageProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_wallpaper_image = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_wallpaper_image();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceWallpaperImageProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceWallpaperImageProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_wallpaper_image = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_wallpaper_image(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceWallpaperImageProto)
  return target;
}

size_t DeviceWallpaperImageProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceWallpaperImageProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_wallpaper_image = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_wallpaper_image());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceWallpaperImageProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceWallpaperImageProto*>(
      &from));
}

void DeviceWallpaperImageProto::MergeFrom(const DeviceWallpaperImageProto& from) {
  DeviceWallpaperImageProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceWallpaperImageProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_wallpaper_image()) {
    _this->_internal_set_device_wallpaper_image(from._internal_device_wallpaper_image());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceWallpaperImageProto::CopyFrom(const DeviceWallpaperImageProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceWallpaperImageProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceWallpaperImageProto::IsInitialized() const {
  return true;
}

void DeviceWallpaperImageProto::InternalSwap(DeviceWallpaperImageProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_wallpaper_image_, lhs_arena,
      &other->_impl_.device_wallpaper_image_, rhs_arena
  );
}

std::string DeviceWallpaperImageProto::GetTypeName() const {
  return "enterprise_management.DeviceWallpaperImageProto";
}


// ===================================================================

class DeviceScreensaverIdleTimeoutSecondsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceScreensaverIdleTimeoutSecondsProto>()._impl_._has_bits_);
  static void set_has_device_screensaver_idle_timeout_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceScreensaverIdleTimeoutSecondsProto::DeviceScreensaverIdleTimeoutSecondsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
}
DeviceScreensaverIdleTimeoutSecondsProto::DeviceScreensaverIdleTimeoutSecondsProto(const DeviceScreensaverIdleTimeoutSecondsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceScreensaverIdleTimeoutSecondsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_screensaver_idle_timeout_seconds_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_screensaver_idle_timeout_seconds_ = from._impl_.device_screensaver_idle_timeout_seconds_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
}

inline void DeviceScreensaverIdleTimeoutSecondsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_screensaver_idle_timeout_seconds_){int64_t{0}}
  };
}

DeviceScreensaverIdleTimeoutSecondsProto::~DeviceScreensaverIdleTimeoutSecondsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceScreensaverIdleTimeoutSecondsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceScreensaverIdleTimeoutSecondsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceScreensaverIdleTimeoutSecondsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_screensaver_idle_timeout_seconds_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceScreensaverIdleTimeoutSecondsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 device_screensaver_idle_timeout_seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_screensaver_idle_timeout_seconds(&has_bits);
          _impl_.device_screensaver_idle_timeout_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceScreensaverIdleTimeoutSecondsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 device_screensaver_idle_timeout_seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_device_screensaver_idle_timeout_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
  return target;
}

size_t DeviceScreensaverIdleTimeoutSecondsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 device_screensaver_idle_timeout_seconds = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_device_screensaver_idle_timeout_seconds());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceScreensaverIdleTimeoutSecondsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceScreensaverIdleTimeoutSecondsProto*>(
      &from));
}

void DeviceScreensaverIdleTimeoutSecondsProto::MergeFrom(const DeviceScreensaverIdleTimeoutSecondsProto& from) {
  DeviceScreensaverIdleTimeoutSecondsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_screensaver_idle_timeout_seconds()) {
    _this->_internal_set_device_screensaver_idle_timeout_seconds(from._internal_device_screensaver_idle_timeout_seconds());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceScreensaverIdleTimeoutSecondsProto::CopyFrom(const DeviceScreensaverIdleTimeoutSecondsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceScreensaverIdleTimeoutSecondsProto::IsInitialized() const {
  return true;
}

void DeviceScreensaverIdleTimeoutSecondsProto::InternalSwap(DeviceScreensaverIdleTimeoutSecondsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_screensaver_idle_timeout_seconds_, other->_impl_.device_screensaver_idle_timeout_seconds_);
}

std::string DeviceScreensaverIdleTimeoutSecondsProto::GetTypeName() const {
  return "enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto";
}


// ===================================================================

class DeviceScreensaverImageDisplayIntervalSecondsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceScreensaverImageDisplayIntervalSecondsProto>()._impl_._has_bits_);
  static void set_has_device_screensaver_image_display_interval_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceScreensaverImageDisplayIntervalSecondsProto::DeviceScreensaverImageDisplayIntervalSecondsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
}
DeviceScreensaverImageDisplayIntervalSecondsProto::DeviceScreensaverImageDisplayIntervalSecondsProto(const DeviceScreensaverImageDisplayIntervalSecondsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceScreensaverImageDisplayIntervalSecondsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_screensaver_image_display_interval_seconds_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_screensaver_image_display_interval_seconds_ = from._impl_.device_screensaver_image_display_interval_seconds_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
}

inline void DeviceScreensaverImageDisplayIntervalSecondsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_screensaver_image_display_interval_seconds_){int64_t{0}}
  };
}

DeviceScreensaverImageDisplayIntervalSecondsProto::~DeviceScreensaverImageDisplayIntervalSecondsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceScreensaverImageDisplayIntervalSecondsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceScreensaverImageDisplayIntervalSecondsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceScreensaverImageDisplayIntervalSecondsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_screensaver_image_display_interval_seconds_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceScreensaverImageDisplayIntervalSecondsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 device_screensaver_image_display_interval_seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_screensaver_image_display_interval_seconds(&has_bits);
          _impl_.device_screensaver_image_display_interval_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceScreensaverImageDisplayIntervalSecondsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 device_screensaver_image_display_interval_seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_device_screensaver_image_display_interval_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
  return target;
}

size_t DeviceScreensaverImageDisplayIntervalSecondsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 device_screensaver_image_display_interval_seconds = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_device_screensaver_image_display_interval_seconds());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceScreensaverImageDisplayIntervalSecondsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceScreensaverImageDisplayIntervalSecondsProto*>(
      &from));
}

void DeviceScreensaverImageDisplayIntervalSecondsProto::MergeFrom(const DeviceScreensaverImageDisplayIntervalSecondsProto& from) {
  DeviceScreensaverImageDisplayIntervalSecondsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_screensaver_image_display_interval_seconds()) {
    _this->_internal_set_device_screensaver_image_display_interval_seconds(from._internal_device_screensaver_image_display_interval_seconds());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceScreensaverImageDisplayIntervalSecondsProto::CopyFrom(const DeviceScreensaverImageDisplayIntervalSecondsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceScreensaverImageDisplayIntervalSecondsProto::IsInitialized() const {
  return true;
}

void DeviceScreensaverImageDisplayIntervalSecondsProto::InternalSwap(DeviceScreensaverImageDisplayIntervalSecondsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_screensaver_image_display_interval_seconds_, other->_impl_.device_screensaver_image_display_interval_seconds_);
}

std::string DeviceScreensaverImageDisplayIntervalSecondsProto::GetTypeName() const {
  return "enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto";
}


// ===================================================================

class DeviceScreensaverImagesProto::_Internal {
 public:
};

DeviceScreensaverImagesProto::DeviceScreensaverImagesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceScreensaverImagesProto)
}
DeviceScreensaverImagesProto::DeviceScreensaverImagesProto(const DeviceScreensaverImagesProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceScreensaverImagesProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.device_screensaver_images_){from._impl_.device_screensaver_images_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceScreensaverImagesProto)
}

inline void DeviceScreensaverImagesProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.device_screensaver_images_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceScreensaverImagesProto::~DeviceScreensaverImagesProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceScreensaverImagesProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceScreensaverImagesProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_screensaver_images_.~RepeatedPtrField();
}

void DeviceScreensaverImagesProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceScreensaverImagesProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceScreensaverImagesProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_screensaver_images_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceScreensaverImagesProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string device_screensaver_images = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_device_screensaver_images();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceScreensaverImagesProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceScreensaverImagesProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string device_screensaver_images = 1;
  for (int i = 0, n = this->_internal_device_screensaver_images_size(); i < n; i++) {
    const auto& s = this->_internal_device_screensaver_images(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceScreensaverImagesProto)
  return target;
}

size_t DeviceScreensaverImagesProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceScreensaverImagesProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string device_screensaver_images = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.device_screensaver_images_.size());
  for (int i = 0, n = _impl_.device_screensaver_images_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.device_screensaver_images_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceScreensaverImagesProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceScreensaverImagesProto*>(
      &from));
}

void DeviceScreensaverImagesProto::MergeFrom(const DeviceScreensaverImagesProto& from) {
  DeviceScreensaverImagesProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceScreensaverImagesProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.device_screensaver_images_.MergeFrom(from._impl_.device_screensaver_images_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceScreensaverImagesProto::CopyFrom(const DeviceScreensaverImagesProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceScreensaverImagesProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceScreensaverImagesProto::IsInitialized() const {
  return true;
}

void DeviceScreensaverImagesProto::InternalSwap(DeviceScreensaverImagesProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.device_screensaver_images_.InternalSwap(&other->_impl_.device_screensaver_images_);
}

std::string DeviceScreensaverImagesProto::GetTypeName() const {
  return "enterprise_management.DeviceScreensaverImagesProto";
}


// ===================================================================

class DeviceSystemAecEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceSystemAecEnabledProto>()._impl_._has_bits_);
  static void set_has_device_system_aec_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceSystemAecEnabledProto::DeviceSystemAecEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceSystemAecEnabledProto)
}
DeviceSystemAecEnabledProto::DeviceSystemAecEnabledProto(const DeviceSystemAecEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceSystemAecEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_system_aec_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_system_aec_enabled_ = from._impl_.device_system_aec_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceSystemAecEnabledProto)
}

inline void DeviceSystemAecEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_system_aec_enabled_){false}
  };
}

DeviceSystemAecEnabledProto::~DeviceSystemAecEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceSystemAecEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceSystemAecEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceSystemAecEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceSystemAecEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceSystemAecEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_system_aec_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceSystemAecEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_system_aec_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_system_aec_enabled(&has_bits);
          _impl_.device_system_aec_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceSystemAecEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceSystemAecEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_system_aec_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_system_aec_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceSystemAecEnabledProto)
  return target;
}

size_t DeviceSystemAecEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceSystemAecEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_system_aec_enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceSystemAecEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceSystemAecEnabledProto*>(
      &from));
}

void DeviceSystemAecEnabledProto::MergeFrom(const DeviceSystemAecEnabledProto& from) {
  DeviceSystemAecEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceSystemAecEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_system_aec_enabled()) {
    _this->_internal_set_device_system_aec_enabled(from._internal_device_system_aec_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceSystemAecEnabledProto::CopyFrom(const DeviceSystemAecEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceSystemAecEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceSystemAecEnabledProto::IsInitialized() const {
  return true;
}

void DeviceSystemAecEnabledProto::InternalSwap(DeviceSystemAecEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_system_aec_enabled_, other->_impl_.device_system_aec_enabled_);
}

std::string DeviceSystemAecEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceSystemAecEnabledProto";
}


// ===================================================================

class DeviceScreensaverEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceScreensaverEnabledProto>()._impl_._has_bits_);
  static void set_has_device_screensaver_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceScreensaverEnabledProto::DeviceScreensaverEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceScreensaverEnabledProto)
}
DeviceScreensaverEnabledProto::DeviceScreensaverEnabledProto(const DeviceScreensaverEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceScreensaverEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_screensaver_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_screensaver_enabled_ = from._impl_.device_screensaver_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceScreensaverEnabledProto)
}

inline void DeviceScreensaverEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_screensaver_enabled_){false}
  };
}

DeviceScreensaverEnabledProto::~DeviceScreensaverEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceScreensaverEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceScreensaverEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceScreensaverEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceScreensaverEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceScreensaverEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_screensaver_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceScreensaverEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_screensaver_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_screensaver_enabled(&has_bits);
          _impl_.device_screensaver_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceScreensaverEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceScreensaverEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_screensaver_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_screensaver_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceScreensaverEnabledProto)
  return target;
}

size_t DeviceScreensaverEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceScreensaverEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_screensaver_enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceScreensaverEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceScreensaverEnabledProto*>(
      &from));
}

void DeviceScreensaverEnabledProto::MergeFrom(const DeviceScreensaverEnabledProto& from) {
  DeviceScreensaverEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceScreensaverEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_screensaver_enabled()) {
    _this->_internal_set_device_screensaver_enabled(from._internal_device_screensaver_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceScreensaverEnabledProto::CopyFrom(const DeviceScreensaverEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceScreensaverEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceScreensaverEnabledProto::IsInitialized() const {
  return true;
}

void DeviceScreensaverEnabledProto::InternalSwap(DeviceScreensaverEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_screensaver_enabled_, other->_impl_.device_screensaver_enabled_);
}

std::string DeviceScreensaverEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceScreensaverEnabledProto";
}


// ===================================================================

class DeviceEcryptfsMigrationStrategyProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceEcryptfsMigrationStrategyProto>()._impl_._has_bits_);
  static void set_has_migration_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceEcryptfsMigrationStrategyProto::DeviceEcryptfsMigrationStrategyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
}
DeviceEcryptfsMigrationStrategyProto::DeviceEcryptfsMigrationStrategyProto(const DeviceEcryptfsMigrationStrategyProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceEcryptfsMigrationStrategyProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.migration_strategy_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.migration_strategy_ = from._impl_.migration_strategy_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
}

inline void DeviceEcryptfsMigrationStrategyProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.migration_strategy_){0}
  };
}

DeviceEcryptfsMigrationStrategyProto::~DeviceEcryptfsMigrationStrategyProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceEcryptfsMigrationStrategyProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceEcryptfsMigrationStrategyProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceEcryptfsMigrationStrategyProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.migration_strategy_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceEcryptfsMigrationStrategyProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto.MigrationStrategy migration_strategy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy_IsValid(val))) {
            _internal_set_migration_strategy(static_cast<::enterprise_management::DeviceEcryptfsMigrationStrategyProto_MigrationStrategy>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceEcryptfsMigrationStrategyProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto.MigrationStrategy migration_strategy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_migration_strategy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
  return target;
}

size_t DeviceEcryptfsMigrationStrategyProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto.MigrationStrategy migration_strategy = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_migration_strategy());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceEcryptfsMigrationStrategyProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceEcryptfsMigrationStrategyProto*>(
      &from));
}

void DeviceEcryptfsMigrationStrategyProto::MergeFrom(const DeviceEcryptfsMigrationStrategyProto& from) {
  DeviceEcryptfsMigrationStrategyProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_migration_strategy()) {
    _this->_internal_set_migration_strategy(from._internal_migration_strategy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceEcryptfsMigrationStrategyProto::CopyFrom(const DeviceEcryptfsMigrationStrategyProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceEcryptfsMigrationStrategyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceEcryptfsMigrationStrategyProto::IsInitialized() const {
  return true;
}

void DeviceEcryptfsMigrationStrategyProto::InternalSwap(DeviceEcryptfsMigrationStrategyProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.migration_strategy_, other->_impl_.migration_strategy_);
}

std::string DeviceEcryptfsMigrationStrategyProto::GetTypeName() const {
  return "enterprise_management.DeviceEcryptfsMigrationStrategyProto";
}


// ===================================================================

class DeviceSecondFactorAuthenticationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceSecondFactorAuthenticationProto>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceSecondFactorAuthenticationProto::DeviceSecondFactorAuthenticationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceSecondFactorAuthenticationProto)
}
DeviceSecondFactorAuthenticationProto::DeviceSecondFactorAuthenticationProto(const DeviceSecondFactorAuthenticationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceSecondFactorAuthenticationProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceSecondFactorAuthenticationProto)
}

inline void DeviceSecondFactorAuthenticationProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){0}
  };
}

DeviceSecondFactorAuthenticationProto::~DeviceSecondFactorAuthenticationProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceSecondFactorAuthenticationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceSecondFactorAuthenticationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceSecondFactorAuthenticationProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceSecondFactorAuthenticationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceSecondFactorAuthenticationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceSecondFactorAuthenticationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceSecondFactorAuthenticationProto.U2fMode mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode_IsValid(val))) {
            _internal_set_mode(static_cast<::enterprise_management::DeviceSecondFactorAuthenticationProto_U2fMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceSecondFactorAuthenticationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceSecondFactorAuthenticationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceSecondFactorAuthenticationProto.U2fMode mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceSecondFactorAuthenticationProto)
  return target;
}

size_t DeviceSecondFactorAuthenticationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceSecondFactorAuthenticationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceSecondFactorAuthenticationProto.U2fMode mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceSecondFactorAuthenticationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceSecondFactorAuthenticationProto*>(
      &from));
}

void DeviceSecondFactorAuthenticationProto::MergeFrom(const DeviceSecondFactorAuthenticationProto& from) {
  DeviceSecondFactorAuthenticationProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceSecondFactorAuthenticationProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mode()) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceSecondFactorAuthenticationProto::CopyFrom(const DeviceSecondFactorAuthenticationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceSecondFactorAuthenticationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceSecondFactorAuthenticationProto::IsInitialized() const {
  return true;
}

void DeviceSecondFactorAuthenticationProto::InternalSwap(DeviceSecondFactorAuthenticationProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.mode_, other->_impl_.mode_);
}

std::string DeviceSecondFactorAuthenticationProto::GetTypeName() const {
  return "enterprise_management.DeviceSecondFactorAuthenticationProto";
}


// ===================================================================

class CastReceiverNameProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CastReceiverNameProto>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CastReceiverNameProto::CastReceiverNameProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CastReceiverNameProto)
}
CastReceiverNameProto::CastReceiverNameProto(const CastReceiverNameProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CastReceiverNameProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CastReceiverNameProto)
}

inline void CastReceiverNameProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CastReceiverNameProto::~CastReceiverNameProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.CastReceiverNameProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CastReceiverNameProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CastReceiverNameProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CastReceiverNameProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CastReceiverNameProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CastReceiverNameProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CastReceiverNameProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CastReceiverNameProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CastReceiverNameProto)
  return target;
}

size_t CastReceiverNameProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CastReceiverNameProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CastReceiverNameProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CastReceiverNameProto*>(
      &from));
}

void CastReceiverNameProto::MergeFrom(const CastReceiverNameProto& from) {
  CastReceiverNameProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CastReceiverNameProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_name()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CastReceiverNameProto::CopyFrom(const CastReceiverNameProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CastReceiverNameProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CastReceiverNameProto::IsInitialized() const {
  return true;
}

void CastReceiverNameProto::InternalSwap(CastReceiverNameProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

std::string CastReceiverNameProto::GetTypeName() const {
  return "enterprise_management.CastReceiverNameProto";
}


// ===================================================================

class WeeklyTimeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<WeeklyTimeProto>()._impl_._has_bits_);
  static void set_has_day_of_week(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

WeeklyTimeProto::WeeklyTimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.WeeklyTimeProto)
}
WeeklyTimeProto::WeeklyTimeProto(const WeeklyTimeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WeeklyTimeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.day_of_week_){}
    , decltype(_impl_.time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.day_of_week_, &from._impl_.day_of_week_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_) -
    reinterpret_cast<char*>(&_impl_.day_of_week_)) + sizeof(_impl_.time_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.WeeklyTimeProto)
}

inline void WeeklyTimeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.day_of_week_){0}
    , decltype(_impl_.time_){0}
  };
}

WeeklyTimeProto::~WeeklyTimeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.WeeklyTimeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WeeklyTimeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WeeklyTimeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WeeklyTimeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.WeeklyTimeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.day_of_week_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.time_) -
        reinterpret_cast<char*>(&_impl_.day_of_week_)) + sizeof(_impl_.time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WeeklyTimeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.WeeklyTimeProto.DayOfWeek day_of_week = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::WeeklyTimeProto_DayOfWeek_IsValid(val))) {
            _internal_set_day_of_week(static_cast<::enterprise_management::WeeklyTimeProto_DayOfWeek>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WeeklyTimeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.WeeklyTimeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.WeeklyTimeProto.DayOfWeek day_of_week = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_day_of_week(), target);
  }

  // optional int32 time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.WeeklyTimeProto)
  return target;
}

size_t WeeklyTimeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.WeeklyTimeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .enterprise_management.WeeklyTimeProto.DayOfWeek day_of_week = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_day_of_week());
    }

    // optional int32 time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WeeklyTimeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WeeklyTimeProto*>(
      &from));
}

void WeeklyTimeProto::MergeFrom(const WeeklyTimeProto& from) {
  WeeklyTimeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.WeeklyTimeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.day_of_week_ = from._impl_.day_of_week_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WeeklyTimeProto::CopyFrom(const WeeklyTimeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.WeeklyTimeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeeklyTimeProto::IsInitialized() const {
  return true;
}

void WeeklyTimeProto::InternalSwap(WeeklyTimeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WeeklyTimeProto, _impl_.time_)
      + sizeof(WeeklyTimeProto::_impl_.time_)
      - PROTOBUF_FIELD_OFFSET(WeeklyTimeProto, _impl_.day_of_week_)>(
          reinterpret_cast<char*>(&_impl_.day_of_week_),
          reinterpret_cast<char*>(&other->_impl_.day_of_week_));
}

std::string WeeklyTimeProto::GetTypeName() const {
  return "enterprise_management.WeeklyTimeProto";
}


// ===================================================================

class WeeklyTimeIntervalProto::_Internal {
 public:
  using HasBits = decltype(std::declval<WeeklyTimeIntervalProto>()._impl_._has_bits_);
  static const ::enterprise_management::WeeklyTimeProto& start(const WeeklyTimeIntervalProto* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::WeeklyTimeProto& end(const WeeklyTimeIntervalProto* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::enterprise_management::WeeklyTimeProto&
WeeklyTimeIntervalProto::_Internal::start(const WeeklyTimeIntervalProto* msg) {
  return *msg->_impl_.start_;
}
const ::enterprise_management::WeeklyTimeProto&
WeeklyTimeIntervalProto::_Internal::end(const WeeklyTimeIntervalProto* msg) {
  return *msg->_impl_.end_;
}
WeeklyTimeIntervalProto::WeeklyTimeIntervalProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.WeeklyTimeIntervalProto)
}
WeeklyTimeIntervalProto::WeeklyTimeIntervalProto(const WeeklyTimeIntervalProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WeeklyTimeIntervalProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::enterprise_management::WeeklyTimeProto(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::enterprise_management::WeeklyTimeProto(*from._impl_.end_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.WeeklyTimeIntervalProto)
}

inline void WeeklyTimeIntervalProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
  };
}

WeeklyTimeIntervalProto::~WeeklyTimeIntervalProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.WeeklyTimeIntervalProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WeeklyTimeIntervalProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}

void WeeklyTimeIntervalProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WeeklyTimeIntervalProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.WeeklyTimeIntervalProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WeeklyTimeIntervalProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.WeeklyTimeProto start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.WeeklyTimeProto end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WeeklyTimeIntervalProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.WeeklyTimeIntervalProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.WeeklyTimeProto start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.WeeklyTimeProto end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.WeeklyTimeIntervalProto)
  return target;
}

size_t WeeklyTimeIntervalProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.WeeklyTimeIntervalProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .enterprise_management.WeeklyTimeProto start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .enterprise_management.WeeklyTimeProto end = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WeeklyTimeIntervalProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WeeklyTimeIntervalProto*>(
      &from));
}

void WeeklyTimeIntervalProto::MergeFrom(const WeeklyTimeIntervalProto& from) {
  WeeklyTimeIntervalProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.WeeklyTimeIntervalProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_start()->::enterprise_management::WeeklyTimeProto::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_end()->::enterprise_management::WeeklyTimeProto::MergeFrom(
          from._internal_end());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WeeklyTimeIntervalProto::CopyFrom(const WeeklyTimeIntervalProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.WeeklyTimeIntervalProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeeklyTimeIntervalProto::IsInitialized() const {
  return true;
}

void WeeklyTimeIntervalProto::InternalSwap(WeeklyTimeIntervalProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WeeklyTimeIntervalProto, _impl_.end_)
      + sizeof(WeeklyTimeIntervalProto::_impl_.end_)
      - PROTOBUF_FIELD_OFFSET(WeeklyTimeIntervalProto, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

std::string WeeklyTimeIntervalProto::GetTypeName() const {
  return "enterprise_management.WeeklyTimeIntervalProto";
}


// ===================================================================

class DeviceOffHoursProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceOffHoursProto>()._impl_._has_bits_);
  static void set_has_timezone(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceOffHoursProto::DeviceOffHoursProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceOffHoursProto)
}
DeviceOffHoursProto::DeviceOffHoursProto(const DeviceOffHoursProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceOffHoursProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.intervals_){from._impl_.intervals_}
    , decltype(_impl_.ignored_policy_proto_tags_){from._impl_.ignored_policy_proto_tags_}
    , decltype(_impl_.timezone_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_timezone()) {
    _this->_impl_.timezone_.Set(from._internal_timezone(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceOffHoursProto)
}

inline void DeviceOffHoursProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.intervals_){arena}
    , decltype(_impl_.ignored_policy_proto_tags_){arena}
    , decltype(_impl_.timezone_){}
  };
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceOffHoursProto::~DeviceOffHoursProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceOffHoursProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceOffHoursProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.intervals_.~RepeatedPtrField();
  _impl_.ignored_policy_proto_tags_.~RepeatedField();
  _impl_.timezone_.Destroy();
}

void DeviceOffHoursProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceOffHoursProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceOffHoursProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.intervals_.Clear();
  _impl_.ignored_policy_proto_tags_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.timezone_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceOffHoursProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.WeeklyTimeIntervalProto intervals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_intervals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string timezone = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_timezone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 ignored_policy_proto_tags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ignored_policy_proto_tags(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_ignored_policy_proto_tags(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceOffHoursProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceOffHoursProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.WeeklyTimeIntervalProto intervals = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_intervals_size()); i < n; i++) {
    const auto& repfield = this->_internal_intervals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string timezone = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_timezone(), target);
  }

  // repeated int32 ignored_policy_proto_tags = 3;
  for (int i = 0, n = this->_internal_ignored_policy_proto_tags_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ignored_policy_proto_tags(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceOffHoursProto)
  return target;
}

size_t DeviceOffHoursProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceOffHoursProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.WeeklyTimeIntervalProto intervals = 1;
  total_size += 1UL * this->_internal_intervals_size();
  for (const auto& msg : this->_impl_.intervals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 ignored_policy_proto_tags = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.ignored_policy_proto_tags_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ignored_policy_proto_tags_size());
    total_size += data_size;
  }

  // optional string timezone = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_timezone());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceOffHoursProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceOffHoursProto*>(
      &from));
}

void DeviceOffHoursProto::MergeFrom(const DeviceOffHoursProto& from) {
  DeviceOffHoursProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceOffHoursProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.intervals_.MergeFrom(from._impl_.intervals_);
  _this->_impl_.ignored_policy_proto_tags_.MergeFrom(from._impl_.ignored_policy_proto_tags_);
  if (from._internal_has_timezone()) {
    _this->_internal_set_timezone(from._internal_timezone());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceOffHoursProto::CopyFrom(const DeviceOffHoursProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceOffHoursProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceOffHoursProto::IsInitialized() const {
  return true;
}

void DeviceOffHoursProto::InternalSwap(DeviceOffHoursProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.intervals_.InternalSwap(&other->_impl_.intervals_);
  _impl_.ignored_policy_proto_tags_.InternalSwap(&other->_impl_.ignored_policy_proto_tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.timezone_, lhs_arena,
      &other->_impl_.timezone_, rhs_arena
  );
}

std::string DeviceOffHoursProto::GetTypeName() const {
  return "enterprise_management.DeviceOffHoursProto";
}


// ===================================================================

class DeviceNativePrintersProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceNativePrintersProto>()._impl_._has_bits_);
  static void set_has_external_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceNativePrintersProto::DeviceNativePrintersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceNativePrintersProto)
}
DeviceNativePrintersProto::DeviceNativePrintersProto(const DeviceNativePrintersProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceNativePrintersProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.external_policy_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.external_policy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_external_policy()) {
    _this->_impl_.external_policy_.Set(from._internal_external_policy(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceNativePrintersProto)
}

inline void DeviceNativePrintersProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.external_policy_){}
  };
  _impl_.external_policy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceNativePrintersProto::~DeviceNativePrintersProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceNativePrintersProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceNativePrintersProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.external_policy_.Destroy();
}

void DeviceNativePrintersProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceNativePrintersProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceNativePrintersProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.external_policy_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceNativePrintersProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string external_policy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_external_policy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceNativePrintersProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceNativePrintersProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string external_policy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_external_policy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceNativePrintersProto)
  return target;
}

size_t DeviceNativePrintersProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceNativePrintersProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string external_policy = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_external_policy());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceNativePrintersProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceNativePrintersProto*>(
      &from));
}

void DeviceNativePrintersProto::MergeFrom(const DeviceNativePrintersProto& from) {
  DeviceNativePrintersProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceNativePrintersProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_external_policy()) {
    _this->_internal_set_external_policy(from._internal_external_policy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceNativePrintersProto::CopyFrom(const DeviceNativePrintersProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceNativePrintersProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceNativePrintersProto::IsInitialized() const {
  return true;
}

void DeviceNativePrintersProto::InternalSwap(DeviceNativePrintersProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.external_policy_, lhs_arena,
      &other->_impl_.external_policy_, rhs_arena
  );
}

std::string DeviceNativePrintersProto::GetTypeName() const {
  return "enterprise_management.DeviceNativePrintersProto";
}


// ===================================================================

class DeviceNativePrintersAccessModeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceNativePrintersAccessModeProto>()._impl_._has_bits_);
  static void set_has_access_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceNativePrintersAccessModeProto::DeviceNativePrintersAccessModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceNativePrintersAccessModeProto)
}
DeviceNativePrintersAccessModeProto::DeviceNativePrintersAccessModeProto(const DeviceNativePrintersAccessModeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceNativePrintersAccessModeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.access_mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.access_mode_ = from._impl_.access_mode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceNativePrintersAccessModeProto)
}

inline void DeviceNativePrintersAccessModeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.access_mode_){0}
  };
}

DeviceNativePrintersAccessModeProto::~DeviceNativePrintersAccessModeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceNativePrintersAccessModeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceNativePrintersAccessModeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceNativePrintersAccessModeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceNativePrintersAccessModeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceNativePrintersAccessModeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.access_mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceNativePrintersAccessModeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceNativePrintersAccessModeProto.AccessMode access_mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode_IsValid(val))) {
            _internal_set_access_mode(static_cast<::enterprise_management::DeviceNativePrintersAccessModeProto_AccessMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceNativePrintersAccessModeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceNativePrintersAccessModeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceNativePrintersAccessModeProto.AccessMode access_mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_access_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceNativePrintersAccessModeProto)
  return target;
}

size_t DeviceNativePrintersAccessModeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceNativePrintersAccessModeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceNativePrintersAccessModeProto.AccessMode access_mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_access_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceNativePrintersAccessModeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceNativePrintersAccessModeProto*>(
      &from));
}

void DeviceNativePrintersAccessModeProto::MergeFrom(const DeviceNativePrintersAccessModeProto& from) {
  DeviceNativePrintersAccessModeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceNativePrintersAccessModeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_access_mode()) {
    _this->_internal_set_access_mode(from._internal_access_mode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceNativePrintersAccessModeProto::CopyFrom(const DeviceNativePrintersAccessModeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceNativePrintersAccessModeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceNativePrintersAccessModeProto::IsInitialized() const {
  return true;
}

void DeviceNativePrintersAccessModeProto::InternalSwap(DeviceNativePrintersAccessModeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.access_mode_, other->_impl_.access_mode_);
}

std::string DeviceNativePrintersAccessModeProto::GetTypeName() const {
  return "enterprise_management.DeviceNativePrintersAccessModeProto";
}


// ===================================================================

class DeviceNativePrintersBlacklistProto::_Internal {
 public:
};

DeviceNativePrintersBlacklistProto::DeviceNativePrintersBlacklistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceNativePrintersBlacklistProto)
}
DeviceNativePrintersBlacklistProto::DeviceNativePrintersBlacklistProto(const DeviceNativePrintersBlacklistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceNativePrintersBlacklistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.blacklist_){from._impl_.blacklist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceNativePrintersBlacklistProto)
}

inline void DeviceNativePrintersBlacklistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.blacklist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceNativePrintersBlacklistProto::~DeviceNativePrintersBlacklistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceNativePrintersBlacklistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceNativePrintersBlacklistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.blacklist_.~RepeatedPtrField();
}

void DeviceNativePrintersBlacklistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceNativePrintersBlacklistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceNativePrintersBlacklistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.blacklist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceNativePrintersBlacklistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string blacklist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_blacklist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceNativePrintersBlacklistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceNativePrintersBlacklistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string blacklist = 1;
  for (int i = 0, n = this->_internal_blacklist_size(); i < n; i++) {
    const auto& s = this->_internal_blacklist(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceNativePrintersBlacklistProto)
  return target;
}

size_t DeviceNativePrintersBlacklistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceNativePrintersBlacklistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string blacklist = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.blacklist_.size());
  for (int i = 0, n = _impl_.blacklist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.blacklist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceNativePrintersBlacklistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceNativePrintersBlacklistProto*>(
      &from));
}

void DeviceNativePrintersBlacklistProto::MergeFrom(const DeviceNativePrintersBlacklistProto& from) {
  DeviceNativePrintersBlacklistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceNativePrintersBlacklistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.blacklist_.MergeFrom(from._impl_.blacklist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceNativePrintersBlacklistProto::CopyFrom(const DeviceNativePrintersBlacklistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceNativePrintersBlacklistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceNativePrintersBlacklistProto::IsInitialized() const {
  return true;
}

void DeviceNativePrintersBlacklistProto::InternalSwap(DeviceNativePrintersBlacklistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.blacklist_.InternalSwap(&other->_impl_.blacklist_);
}

std::string DeviceNativePrintersBlacklistProto::GetTypeName() const {
  return "enterprise_management.DeviceNativePrintersBlacklistProto";
}


// ===================================================================

class DeviceNativePrintersWhitelistProto::_Internal {
 public:
};

DeviceNativePrintersWhitelistProto::DeviceNativePrintersWhitelistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceNativePrintersWhitelistProto)
}
DeviceNativePrintersWhitelistProto::DeviceNativePrintersWhitelistProto(const DeviceNativePrintersWhitelistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceNativePrintersWhitelistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.whitelist_){from._impl_.whitelist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceNativePrintersWhitelistProto)
}

inline void DeviceNativePrintersWhitelistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.whitelist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceNativePrintersWhitelistProto::~DeviceNativePrintersWhitelistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceNativePrintersWhitelistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceNativePrintersWhitelistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.whitelist_.~RepeatedPtrField();
}

void DeviceNativePrintersWhitelistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceNativePrintersWhitelistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceNativePrintersWhitelistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.whitelist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceNativePrintersWhitelistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string whitelist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_whitelist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceNativePrintersWhitelistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceNativePrintersWhitelistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string whitelist = 1;
  for (int i = 0, n = this->_internal_whitelist_size(); i < n; i++) {
    const auto& s = this->_internal_whitelist(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceNativePrintersWhitelistProto)
  return target;
}

size_t DeviceNativePrintersWhitelistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceNativePrintersWhitelistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string whitelist = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.whitelist_.size());
  for (int i = 0, n = _impl_.whitelist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.whitelist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceNativePrintersWhitelistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceNativePrintersWhitelistProto*>(
      &from));
}

void DeviceNativePrintersWhitelistProto::MergeFrom(const DeviceNativePrintersWhitelistProto& from) {
  DeviceNativePrintersWhitelistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceNativePrintersWhitelistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.whitelist_.MergeFrom(from._impl_.whitelist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceNativePrintersWhitelistProto::CopyFrom(const DeviceNativePrintersWhitelistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceNativePrintersWhitelistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceNativePrintersWhitelistProto::IsInitialized() const {
  return true;
}

void DeviceNativePrintersWhitelistProto::InternalSwap(DeviceNativePrintersWhitelistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.whitelist_.InternalSwap(&other->_impl_.whitelist_);
}

std::string DeviceNativePrintersWhitelistProto::GetTypeName() const {
  return "enterprise_management.DeviceNativePrintersWhitelistProto";
}


// ===================================================================

class DevicePrintersProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePrintersProto>()._impl_._has_bits_);
  static void set_has_external_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DevicePrintersProto::DevicePrintersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePrintersProto)
}
DevicePrintersProto::DevicePrintersProto(const DevicePrintersProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePrintersProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.external_policy_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.external_policy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_external_policy()) {
    _this->_impl_.external_policy_.Set(from._internal_external_policy(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePrintersProto)
}

inline void DevicePrintersProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.external_policy_){}
  };
  _impl_.external_policy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DevicePrintersProto::~DevicePrintersProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePrintersProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePrintersProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.external_policy_.Destroy();
}

void DevicePrintersProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePrintersProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePrintersProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.external_policy_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePrintersProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string external_policy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_external_policy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePrintersProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePrintersProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string external_policy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_external_policy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePrintersProto)
  return target;
}

size_t DevicePrintersProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePrintersProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string external_policy = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_external_policy());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePrintersProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePrintersProto*>(
      &from));
}

void DevicePrintersProto::MergeFrom(const DevicePrintersProto& from) {
  DevicePrintersProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePrintersProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_external_policy()) {
    _this->_internal_set_external_policy(from._internal_external_policy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePrintersProto::CopyFrom(const DevicePrintersProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePrintersProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePrintersProto::IsInitialized() const {
  return true;
}

void DevicePrintersProto::InternalSwap(DevicePrintersProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.external_policy_, lhs_arena,
      &other->_impl_.external_policy_, rhs_arena
  );
}

std::string DevicePrintersProto::GetTypeName() const {
  return "enterprise_management.DevicePrintersProto";
}


// ===================================================================

class DevicePrintersAccessModeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePrintersAccessModeProto>()._impl_._has_bits_);
  static void set_has_access_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DevicePrintersAccessModeProto::DevicePrintersAccessModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePrintersAccessModeProto)
}
DevicePrintersAccessModeProto::DevicePrintersAccessModeProto(const DevicePrintersAccessModeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePrintersAccessModeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.access_mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.access_mode_ = from._impl_.access_mode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePrintersAccessModeProto)
}

inline void DevicePrintersAccessModeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.access_mode_){0}
  };
}

DevicePrintersAccessModeProto::~DevicePrintersAccessModeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePrintersAccessModeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePrintersAccessModeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DevicePrintersAccessModeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePrintersAccessModeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePrintersAccessModeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.access_mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePrintersAccessModeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DevicePrintersAccessModeProto.AccessMode access_mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DevicePrintersAccessModeProto_AccessMode_IsValid(val))) {
            _internal_set_access_mode(static_cast<::enterprise_management::DevicePrintersAccessModeProto_AccessMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePrintersAccessModeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePrintersAccessModeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DevicePrintersAccessModeProto.AccessMode access_mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_access_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePrintersAccessModeProto)
  return target;
}

size_t DevicePrintersAccessModeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePrintersAccessModeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DevicePrintersAccessModeProto.AccessMode access_mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_access_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePrintersAccessModeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePrintersAccessModeProto*>(
      &from));
}

void DevicePrintersAccessModeProto::MergeFrom(const DevicePrintersAccessModeProto& from) {
  DevicePrintersAccessModeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePrintersAccessModeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_access_mode()) {
    _this->_internal_set_access_mode(from._internal_access_mode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePrintersAccessModeProto::CopyFrom(const DevicePrintersAccessModeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePrintersAccessModeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePrintersAccessModeProto::IsInitialized() const {
  return true;
}

void DevicePrintersAccessModeProto::InternalSwap(DevicePrintersAccessModeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.access_mode_, other->_impl_.access_mode_);
}

std::string DevicePrintersAccessModeProto::GetTypeName() const {
  return "enterprise_management.DevicePrintersAccessModeProto";
}


// ===================================================================

class DevicePrintersBlocklistProto::_Internal {
 public:
};

DevicePrintersBlocklistProto::DevicePrintersBlocklistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePrintersBlocklistProto)
}
DevicePrintersBlocklistProto::DevicePrintersBlocklistProto(const DevicePrintersBlocklistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePrintersBlocklistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.blocklist_){from._impl_.blocklist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePrintersBlocklistProto)
}

inline void DevicePrintersBlocklistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.blocklist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DevicePrintersBlocklistProto::~DevicePrintersBlocklistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePrintersBlocklistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePrintersBlocklistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.blocklist_.~RepeatedPtrField();
}

void DevicePrintersBlocklistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePrintersBlocklistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePrintersBlocklistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.blocklist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePrintersBlocklistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string blocklist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_blocklist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePrintersBlocklistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePrintersBlocklistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string blocklist = 1;
  for (int i = 0, n = this->_internal_blocklist_size(); i < n; i++) {
    const auto& s = this->_internal_blocklist(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePrintersBlocklistProto)
  return target;
}

size_t DevicePrintersBlocklistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePrintersBlocklistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string blocklist = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.blocklist_.size());
  for (int i = 0, n = _impl_.blocklist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.blocklist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePrintersBlocklistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePrintersBlocklistProto*>(
      &from));
}

void DevicePrintersBlocklistProto::MergeFrom(const DevicePrintersBlocklistProto& from) {
  DevicePrintersBlocklistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePrintersBlocklistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.blocklist_.MergeFrom(from._impl_.blocklist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePrintersBlocklistProto::CopyFrom(const DevicePrintersBlocklistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePrintersBlocklistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePrintersBlocklistProto::IsInitialized() const {
  return true;
}

void DevicePrintersBlocklistProto::InternalSwap(DevicePrintersBlocklistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.blocklist_.InternalSwap(&other->_impl_.blocklist_);
}

std::string DevicePrintersBlocklistProto::GetTypeName() const {
  return "enterprise_management.DevicePrintersBlocklistProto";
}


// ===================================================================

class DevicePrintersAllowlistProto::_Internal {
 public:
};

DevicePrintersAllowlistProto::DevicePrintersAllowlistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePrintersAllowlistProto)
}
DevicePrintersAllowlistProto::DevicePrintersAllowlistProto(const DevicePrintersAllowlistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePrintersAllowlistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.allowlist_){from._impl_.allowlist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePrintersAllowlistProto)
}

inline void DevicePrintersAllowlistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.allowlist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DevicePrintersAllowlistProto::~DevicePrintersAllowlistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePrintersAllowlistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePrintersAllowlistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allowlist_.~RepeatedPtrField();
}

void DevicePrintersAllowlistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePrintersAllowlistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePrintersAllowlistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowlist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePrintersAllowlistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string allowlist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allowlist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePrintersAllowlistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePrintersAllowlistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string allowlist = 1;
  for (int i = 0, n = this->_internal_allowlist_size(); i < n; i++) {
    const auto& s = this->_internal_allowlist(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePrintersAllowlistProto)
  return target;
}

size_t DevicePrintersAllowlistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePrintersAllowlistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string allowlist = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.allowlist_.size());
  for (int i = 0, n = _impl_.allowlist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.allowlist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePrintersAllowlistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePrintersAllowlistProto*>(
      &from));
}

void DevicePrintersAllowlistProto::MergeFrom(const DevicePrintersAllowlistProto& from) {
  DevicePrintersAllowlistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePrintersAllowlistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allowlist_.MergeFrom(from._impl_.allowlist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePrintersAllowlistProto::CopyFrom(const DevicePrintersAllowlistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePrintersAllowlistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePrintersAllowlistProto::IsInitialized() const {
  return true;
}

void DevicePrintersAllowlistProto::InternalSwap(DevicePrintersAllowlistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.allowlist_.InternalSwap(&other->_impl_.allowlist_);
}

std::string DevicePrintersAllowlistProto::GetTypeName() const {
  return "enterprise_management.DevicePrintersAllowlistProto";
}


// ===================================================================

class DeviceExternalPrintServersProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceExternalPrintServersProto>()._impl_._has_bits_);
  static void set_has_external_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceExternalPrintServersProto::DeviceExternalPrintServersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceExternalPrintServersProto)
}
DeviceExternalPrintServersProto::DeviceExternalPrintServersProto(const DeviceExternalPrintServersProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceExternalPrintServersProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.external_policy_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.external_policy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_external_policy()) {
    _this->_impl_.external_policy_.Set(from._internal_external_policy(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceExternalPrintServersProto)
}

inline void DeviceExternalPrintServersProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.external_policy_){}
  };
  _impl_.external_policy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_policy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceExternalPrintServersProto::~DeviceExternalPrintServersProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceExternalPrintServersProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceExternalPrintServersProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.external_policy_.Destroy();
}

void DeviceExternalPrintServersProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceExternalPrintServersProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceExternalPrintServersProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.external_policy_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceExternalPrintServersProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string external_policy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_external_policy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceExternalPrintServersProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceExternalPrintServersProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string external_policy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_external_policy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceExternalPrintServersProto)
  return target;
}

size_t DeviceExternalPrintServersProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceExternalPrintServersProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string external_policy = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_external_policy());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceExternalPrintServersProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceExternalPrintServersProto*>(
      &from));
}

void DeviceExternalPrintServersProto::MergeFrom(const DeviceExternalPrintServersProto& from) {
  DeviceExternalPrintServersProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceExternalPrintServersProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_external_policy()) {
    _this->_internal_set_external_policy(from._internal_external_policy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceExternalPrintServersProto::CopyFrom(const DeviceExternalPrintServersProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceExternalPrintServersProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceExternalPrintServersProto::IsInitialized() const {
  return true;
}

void DeviceExternalPrintServersProto::InternalSwap(DeviceExternalPrintServersProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.external_policy_, lhs_arena,
      &other->_impl_.external_policy_, rhs_arena
  );
}

std::string DeviceExternalPrintServersProto::GetTypeName() const {
  return "enterprise_management.DeviceExternalPrintServersProto";
}


// ===================================================================

class DeviceExternalPrintServersAllowlistProto::_Internal {
 public:
};

DeviceExternalPrintServersAllowlistProto::DeviceExternalPrintServersAllowlistProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceExternalPrintServersAllowlistProto)
}
DeviceExternalPrintServersAllowlistProto::DeviceExternalPrintServersAllowlistProto(const DeviceExternalPrintServersAllowlistProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceExternalPrintServersAllowlistProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.allowlist_){from._impl_.allowlist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceExternalPrintServersAllowlistProto)
}

inline void DeviceExternalPrintServersAllowlistProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.allowlist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceExternalPrintServersAllowlistProto::~DeviceExternalPrintServersAllowlistProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceExternalPrintServersAllowlistProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceExternalPrintServersAllowlistProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allowlist_.~RepeatedPtrField();
}

void DeviceExternalPrintServersAllowlistProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceExternalPrintServersAllowlistProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceExternalPrintServersAllowlistProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowlist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceExternalPrintServersAllowlistProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string allowlist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allowlist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceExternalPrintServersAllowlistProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceExternalPrintServersAllowlistProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string allowlist = 1;
  for (int i = 0, n = this->_internal_allowlist_size(); i < n; i++) {
    const auto& s = this->_internal_allowlist(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceExternalPrintServersAllowlistProto)
  return target;
}

size_t DeviceExternalPrintServersAllowlistProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceExternalPrintServersAllowlistProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string allowlist = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.allowlist_.size());
  for (int i = 0, n = _impl_.allowlist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.allowlist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceExternalPrintServersAllowlistProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceExternalPrintServersAllowlistProto*>(
      &from));
}

void DeviceExternalPrintServersAllowlistProto::MergeFrom(const DeviceExternalPrintServersAllowlistProto& from) {
  DeviceExternalPrintServersAllowlistProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceExternalPrintServersAllowlistProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allowlist_.MergeFrom(from._impl_.allowlist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceExternalPrintServersAllowlistProto::CopyFrom(const DeviceExternalPrintServersAllowlistProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceExternalPrintServersAllowlistProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceExternalPrintServersAllowlistProto::IsInitialized() const {
  return true;
}

void DeviceExternalPrintServersAllowlistProto::InternalSwap(DeviceExternalPrintServersAllowlistProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.allowlist_.InternalSwap(&other->_impl_.allowlist_);
}

std::string DeviceExternalPrintServersAllowlistProto::GetTypeName() const {
  return "enterprise_management.DeviceExternalPrintServersAllowlistProto";
}


// ===================================================================

class TPMFirmwareUpdateSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TPMFirmwareUpdateSettingsProto>()._impl_._has_bits_);
  static void set_has_allow_user_initiated_powerwash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_user_initiated_preserve_device_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_auto_update_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TPMFirmwareUpdateSettingsProto::TPMFirmwareUpdateSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.TPMFirmwareUpdateSettingsProto)
}
TPMFirmwareUpdateSettingsProto::TPMFirmwareUpdateSettingsProto(const TPMFirmwareUpdateSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TPMFirmwareUpdateSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_user_initiated_powerwash_){}
    , decltype(_impl_.allow_user_initiated_preserve_device_state_){}
    , decltype(_impl_.auto_update_mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.allow_user_initiated_powerwash_, &from._impl_.allow_user_initiated_powerwash_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auto_update_mode_) -
    reinterpret_cast<char*>(&_impl_.allow_user_initiated_powerwash_)) + sizeof(_impl_.auto_update_mode_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.TPMFirmwareUpdateSettingsProto)
}

inline void TPMFirmwareUpdateSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allow_user_initiated_powerwash_){false}
    , decltype(_impl_.allow_user_initiated_preserve_device_state_){false}
    , decltype(_impl_.auto_update_mode_){1}
  };
}

TPMFirmwareUpdateSettingsProto::~TPMFirmwareUpdateSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.TPMFirmwareUpdateSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TPMFirmwareUpdateSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TPMFirmwareUpdateSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TPMFirmwareUpdateSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.TPMFirmwareUpdateSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.allow_user_initiated_powerwash_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.allow_user_initiated_preserve_device_state_) -
      reinterpret_cast<char*>(&_impl_.allow_user_initiated_powerwash_)) + sizeof(_impl_.allow_user_initiated_preserve_device_state_));
  _impl_.auto_update_mode_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TPMFirmwareUpdateSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allow_user_initiated_powerwash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allow_user_initiated_powerwash(&has_bits);
          _impl_.allow_user_initiated_powerwash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_user_initiated_preserve_device_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_allow_user_initiated_preserve_device_state(&has_bits);
          _impl_.allow_user_initiated_preserve_device_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.TPMFirmwareUpdateSettingsProto.AutoUpdateMode auto_update_mode = 3 [default = NEVER];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode_IsValid(val))) {
            _internal_set_auto_update_mode(static_cast<::enterprise_management::TPMFirmwareUpdateSettingsProto_AutoUpdateMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TPMFirmwareUpdateSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.TPMFirmwareUpdateSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool allow_user_initiated_powerwash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allow_user_initiated_powerwash(), target);
  }

  // optional bool allow_user_initiated_preserve_device_state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_user_initiated_preserve_device_state(), target);
  }

  // optional .enterprise_management.TPMFirmwareUpdateSettingsProto.AutoUpdateMode auto_update_mode = 3 [default = NEVER];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_auto_update_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.TPMFirmwareUpdateSettingsProto)
  return target;
}

size_t TPMFirmwareUpdateSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.TPMFirmwareUpdateSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool allow_user_initiated_powerwash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool allow_user_initiated_preserve_device_state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .enterprise_management.TPMFirmwareUpdateSettingsProto.AutoUpdateMode auto_update_mode = 3 [default = NEVER];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_auto_update_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TPMFirmwareUpdateSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TPMFirmwareUpdateSettingsProto*>(
      &from));
}

void TPMFirmwareUpdateSettingsProto::MergeFrom(const TPMFirmwareUpdateSettingsProto& from) {
  TPMFirmwareUpdateSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.TPMFirmwareUpdateSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.allow_user_initiated_powerwash_ = from._impl_.allow_user_initiated_powerwash_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.allow_user_initiated_preserve_device_state_ = from._impl_.allow_user_initiated_preserve_device_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.auto_update_mode_ = from._impl_.auto_update_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TPMFirmwareUpdateSettingsProto::CopyFrom(const TPMFirmwareUpdateSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.TPMFirmwareUpdateSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TPMFirmwareUpdateSettingsProto::IsInitialized() const {
  return true;
}

void TPMFirmwareUpdateSettingsProto::InternalSwap(TPMFirmwareUpdateSettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TPMFirmwareUpdateSettingsProto, _impl_.allow_user_initiated_preserve_device_state_)
      + sizeof(TPMFirmwareUpdateSettingsProto::_impl_.allow_user_initiated_preserve_device_state_)
      - PROTOBUF_FIELD_OFFSET(TPMFirmwareUpdateSettingsProto, _impl_.allow_user_initiated_powerwash_)>(
          reinterpret_cast<char*>(&_impl_.allow_user_initiated_powerwash_),
          reinterpret_cast<char*>(&other->_impl_.allow_user_initiated_powerwash_));
  swap(_impl_.auto_update_mode_, other->_impl_.auto_update_mode_);
}

std::string TPMFirmwareUpdateSettingsProto::GetTypeName() const {
  return "enterprise_management.TPMFirmwareUpdateSettingsProto";
}


// ===================================================================

class OBSOLETE_MinimumRequiredVersionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_MinimumRequiredVersionProto>()._impl_._has_bits_);
  static void set_has_obsolete_chrome_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OBSOLETE_MinimumRequiredVersionProto::OBSOLETE_MinimumRequiredVersionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
}
OBSOLETE_MinimumRequiredVersionProto::OBSOLETE_MinimumRequiredVersionProto(const OBSOLETE_MinimumRequiredVersionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_MinimumRequiredVersionProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_chrome_version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.obsolete_chrome_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_chrome_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_chrome_version()) {
    _this->_impl_.obsolete_chrome_version_.Set(from._internal_obsolete_chrome_version(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
}

inline void OBSOLETE_MinimumRequiredVersionProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_chrome_version_){}
  };
  _impl_.obsolete_chrome_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_chrome_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OBSOLETE_MinimumRequiredVersionProto::~OBSOLETE_MinimumRequiredVersionProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_MinimumRequiredVersionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_chrome_version_.Destroy();
}

void OBSOLETE_MinimumRequiredVersionProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_MinimumRequiredVersionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.obsolete_chrome_version_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_MinimumRequiredVersionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string OBSOLETE_chrome_version = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_obsolete_chrome_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_MinimumRequiredVersionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string OBSOLETE_chrome_version = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_obsolete_chrome_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
  return target;
}

size_t OBSOLETE_MinimumRequiredVersionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string OBSOLETE_chrome_version = 1 [deprecated = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_obsolete_chrome_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_MinimumRequiredVersionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_MinimumRequiredVersionProto*>(
      &from));
}

void OBSOLETE_MinimumRequiredVersionProto::MergeFrom(const OBSOLETE_MinimumRequiredVersionProto& from) {
  OBSOLETE_MinimumRequiredVersionProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_obsolete_chrome_version()) {
    _this->_internal_set_obsolete_chrome_version(from._internal_obsolete_chrome_version());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_MinimumRequiredVersionProto::CopyFrom(const OBSOLETE_MinimumRequiredVersionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_MinimumRequiredVersionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_MinimumRequiredVersionProto::IsInitialized() const {
  return true;
}

void OBSOLETE_MinimumRequiredVersionProto::InternalSwap(OBSOLETE_MinimumRequiredVersionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_chrome_version_, lhs_arena,
      &other->_impl_.obsolete_chrome_version_, rhs_arena
  );
}

std::string OBSOLETE_MinimumRequiredVersionProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_MinimumRequiredVersionProto";
}


// ===================================================================

class DeviceLoginScreenAutoSelectCertificateForUrls::_Internal {
 public:
};

DeviceLoginScreenAutoSelectCertificateForUrls::DeviceLoginScreenAutoSelectCertificateForUrls(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
}
DeviceLoginScreenAutoSelectCertificateForUrls::DeviceLoginScreenAutoSelectCertificateForUrls(const DeviceLoginScreenAutoSelectCertificateForUrls& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceLoginScreenAutoSelectCertificateForUrls* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.login_screen_auto_select_certificate_rules_){from._impl_.login_screen_auto_select_certificate_rules_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
}

inline void DeviceLoginScreenAutoSelectCertificateForUrls::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.login_screen_auto_select_certificate_rules_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceLoginScreenAutoSelectCertificateForUrls::~DeviceLoginScreenAutoSelectCertificateForUrls() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLoginScreenAutoSelectCertificateForUrls::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.login_screen_auto_select_certificate_rules_.~RepeatedPtrField();
}

void DeviceLoginScreenAutoSelectCertificateForUrls::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLoginScreenAutoSelectCertificateForUrls::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.login_screen_auto_select_certificate_rules_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceLoginScreenAutoSelectCertificateForUrls::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string login_screen_auto_select_certificate_rules = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_login_screen_auto_select_certificate_rules();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLoginScreenAutoSelectCertificateForUrls::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string login_screen_auto_select_certificate_rules = 1;
  for (int i = 0, n = this->_internal_login_screen_auto_select_certificate_rules_size(); i < n; i++) {
    const auto& s = this->_internal_login_screen_auto_select_certificate_rules(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
  return target;
}

size_t DeviceLoginScreenAutoSelectCertificateForUrls::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string login_screen_auto_select_certificate_rules = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.login_screen_auto_select_certificate_rules_.size());
  for (int i = 0, n = _impl_.login_screen_auto_select_certificate_rules_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.login_screen_auto_select_certificate_rules_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceLoginScreenAutoSelectCertificateForUrls::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceLoginScreenAutoSelectCertificateForUrls*>(
      &from));
}

void DeviceLoginScreenAutoSelectCertificateForUrls::MergeFrom(const DeviceLoginScreenAutoSelectCertificateForUrls& from) {
  DeviceLoginScreenAutoSelectCertificateForUrls* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.login_screen_auto_select_certificate_rules_.MergeFrom(from._impl_.login_screen_auto_select_certificate_rules_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceLoginScreenAutoSelectCertificateForUrls::CopyFrom(const DeviceLoginScreenAutoSelectCertificateForUrls& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLoginScreenAutoSelectCertificateForUrls::IsInitialized() const {
  return true;
}

void DeviceLoginScreenAutoSelectCertificateForUrls::InternalSwap(DeviceLoginScreenAutoSelectCertificateForUrls* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.login_screen_auto_select_certificate_rules_.InternalSwap(&other->_impl_.login_screen_auto_select_certificate_rules_);
}

std::string DeviceLoginScreenAutoSelectCertificateForUrls::GetTypeName() const {
  return "enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls";
}


// ===================================================================

class UnaffiliatedArcAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UnaffiliatedArcAllowedProto>()._impl_._has_bits_);
  static void set_has_unaffiliated_arc_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UnaffiliatedArcAllowedProto::UnaffiliatedArcAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UnaffiliatedArcAllowedProto)
}
UnaffiliatedArcAllowedProto::UnaffiliatedArcAllowedProto(const UnaffiliatedArcAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UnaffiliatedArcAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unaffiliated_arc_allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.unaffiliated_arc_allowed_ = from._impl_.unaffiliated_arc_allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UnaffiliatedArcAllowedProto)
}

inline void UnaffiliatedArcAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unaffiliated_arc_allowed_){false}
  };
}

UnaffiliatedArcAllowedProto::~UnaffiliatedArcAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.UnaffiliatedArcAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnaffiliatedArcAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UnaffiliatedArcAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnaffiliatedArcAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UnaffiliatedArcAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.unaffiliated_arc_allowed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UnaffiliatedArcAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool unaffiliated_arc_allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_unaffiliated_arc_allowed(&has_bits);
          _impl_.unaffiliated_arc_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnaffiliatedArcAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UnaffiliatedArcAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool unaffiliated_arc_allowed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_unaffiliated_arc_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UnaffiliatedArcAllowedProto)
  return target;
}

size_t UnaffiliatedArcAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UnaffiliatedArcAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool unaffiliated_arc_allowed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnaffiliatedArcAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UnaffiliatedArcAllowedProto*>(
      &from));
}

void UnaffiliatedArcAllowedProto::MergeFrom(const UnaffiliatedArcAllowedProto& from) {
  UnaffiliatedArcAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UnaffiliatedArcAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_unaffiliated_arc_allowed()) {
    _this->_internal_set_unaffiliated_arc_allowed(from._internal_unaffiliated_arc_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UnaffiliatedArcAllowedProto::CopyFrom(const UnaffiliatedArcAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UnaffiliatedArcAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnaffiliatedArcAllowedProto::IsInitialized() const {
  return true;
}

void UnaffiliatedArcAllowedProto::InternalSwap(UnaffiliatedArcAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.unaffiliated_arc_allowed_, other->_impl_.unaffiliated_arc_allowed_);
}

std::string UnaffiliatedArcAllowedProto::GetTypeName() const {
  return "enterprise_management.UnaffiliatedArcAllowedProto";
}


// ===================================================================

class DeviceKerberosEncryptionTypesProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceKerberosEncryptionTypesProto>()._impl_._has_bits_);
  static void set_has_types(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceKerberosEncryptionTypesProto::DeviceKerberosEncryptionTypesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceKerberosEncryptionTypesProto)
}
DeviceKerberosEncryptionTypesProto::DeviceKerberosEncryptionTypesProto(const DeviceKerberosEncryptionTypesProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceKerberosEncryptionTypesProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.types_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.types_ = from._impl_.types_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceKerberosEncryptionTypesProto)
}

inline void DeviceKerberosEncryptionTypesProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.types_){1}
  };
}

DeviceKerberosEncryptionTypesProto::~DeviceKerberosEncryptionTypesProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceKerberosEncryptionTypesProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceKerberosEncryptionTypesProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceKerberosEncryptionTypesProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceKerberosEncryptionTypesProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceKerberosEncryptionTypesProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.types_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceKerberosEncryptionTypesProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceKerberosEncryptionTypesProto.Types types = 1 [default = ENC_TYPES_STRONG];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceKerberosEncryptionTypesProto_Types_IsValid(val))) {
            _internal_set_types(static_cast<::enterprise_management::DeviceKerberosEncryptionTypesProto_Types>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceKerberosEncryptionTypesProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceKerberosEncryptionTypesProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceKerberosEncryptionTypesProto.Types types = 1 [default = ENC_TYPES_STRONG];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_types(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceKerberosEncryptionTypesProto)
  return target;
}

size_t DeviceKerberosEncryptionTypesProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceKerberosEncryptionTypesProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceKerberosEncryptionTypesProto.Types types = 1 [default = ENC_TYPES_STRONG];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_types());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceKerberosEncryptionTypesProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceKerberosEncryptionTypesProto*>(
      &from));
}

void DeviceKerberosEncryptionTypesProto::MergeFrom(const DeviceKerberosEncryptionTypesProto& from) {
  DeviceKerberosEncryptionTypesProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceKerberosEncryptionTypesProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_types()) {
    _this->_internal_set_types(from._internal_types());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceKerberosEncryptionTypesProto::CopyFrom(const DeviceKerberosEncryptionTypesProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceKerberosEncryptionTypesProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceKerberosEncryptionTypesProto::IsInitialized() const {
  return true;
}

void DeviceKerberosEncryptionTypesProto::InternalSwap(DeviceKerberosEncryptionTypesProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.types_, other->_impl_.types_);
}

std::string DeviceKerberosEncryptionTypesProto::GetTypeName() const {
  return "enterprise_management.DeviceKerberosEncryptionTypesProto";
}


// ===================================================================

class KeyboardBacklightColorProto::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyboardBacklightColorProto>()._impl_._has_bits_);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KeyboardBacklightColorProto::KeyboardBacklightColorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.KeyboardBacklightColorProto)
}
KeyboardBacklightColorProto::KeyboardBacklightColorProto(const KeyboardBacklightColorProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KeyboardBacklightColorProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.color_ = from._impl_.color_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.KeyboardBacklightColorProto)
}

inline void KeyboardBacklightColorProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){0}
  };
}

KeyboardBacklightColorProto::~KeyboardBacklightColorProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.KeyboardBacklightColorProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyboardBacklightColorProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeyboardBacklightColorProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyboardBacklightColorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.KeyboardBacklightColorProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyboardBacklightColorProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.KeyboardBacklightColorProto.BacklightColor color = 1 [default = BACKLIGHT_UNSPECIFIED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::KeyboardBacklightColorProto_BacklightColor_IsValid(val))) {
            _internal_set_color(static_cast<::enterprise_management::KeyboardBacklightColorProto_BacklightColor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyboardBacklightColorProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.KeyboardBacklightColorProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.KeyboardBacklightColorProto.BacklightColor color = 1 [default = BACKLIGHT_UNSPECIFIED];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.KeyboardBacklightColorProto)
  return target;
}

size_t KeyboardBacklightColorProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.KeyboardBacklightColorProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.KeyboardBacklightColorProto.BacklightColor color = 1 [default = BACKLIGHT_UNSPECIFIED];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_color());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyboardBacklightColorProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KeyboardBacklightColorProto*>(
      &from));
}

void KeyboardBacklightColorProto::MergeFrom(const KeyboardBacklightColorProto& from) {
  KeyboardBacklightColorProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.KeyboardBacklightColorProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_color()) {
    _this->_internal_set_color(from._internal_color());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyboardBacklightColorProto::CopyFrom(const KeyboardBacklightColorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.KeyboardBacklightColorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyboardBacklightColorProto::IsInitialized() const {
  return true;
}

void KeyboardBacklightColorProto::InternalSwap(KeyboardBacklightColorProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.color_, other->_impl_.color_);
}

std::string KeyboardBacklightColorProto::GetTypeName() const {
  return "enterprise_management.KeyboardBacklightColorProto";
}


// ===================================================================

class DeviceUserPolicyLoopbackProcessingModeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceUserPolicyLoopbackProcessingModeProto>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceUserPolicyLoopbackProcessingModeProto::DeviceUserPolicyLoopbackProcessingModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
}
DeviceUserPolicyLoopbackProcessingModeProto::DeviceUserPolicyLoopbackProcessingModeProto(const DeviceUserPolicyLoopbackProcessingModeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceUserPolicyLoopbackProcessingModeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
}

inline void DeviceUserPolicyLoopbackProcessingModeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){0}
  };
}

DeviceUserPolicyLoopbackProcessingModeProto::~DeviceUserPolicyLoopbackProcessingModeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceUserPolicyLoopbackProcessingModeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceUserPolicyLoopbackProcessingModeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceUserPolicyLoopbackProcessingModeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceUserPolicyLoopbackProcessingModeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto.Mode mode = 1 [default = USER_POLICY_MODE_DEFAULT];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode_IsValid(val))) {
            _internal_set_mode(static_cast<::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceUserPolicyLoopbackProcessingModeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto.Mode mode = 1 [default = USER_POLICY_MODE_DEFAULT];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
  return target;
}

size_t DeviceUserPolicyLoopbackProcessingModeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto.Mode mode = 1 [default = USER_POLICY_MODE_DEFAULT];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceUserPolicyLoopbackProcessingModeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceUserPolicyLoopbackProcessingModeProto*>(
      &from));
}

void DeviceUserPolicyLoopbackProcessingModeProto::MergeFrom(const DeviceUserPolicyLoopbackProcessingModeProto& from) {
  DeviceUserPolicyLoopbackProcessingModeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mode()) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceUserPolicyLoopbackProcessingModeProto::CopyFrom(const DeviceUserPolicyLoopbackProcessingModeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceUserPolicyLoopbackProcessingModeProto::IsInitialized() const {
  return true;
}

void DeviceUserPolicyLoopbackProcessingModeProto::InternalSwap(DeviceUserPolicyLoopbackProcessingModeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.mode_, other->_impl_.mode_);
}

std::string DeviceUserPolicyLoopbackProcessingModeProto::GetTypeName() const {
  return "enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto";
}


// ===================================================================

class OBSOLETE_DeviceLoginScreenIsolateOriginsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_DeviceLoginScreenIsolateOriginsProto>()._impl_._has_bits_);
  static void set_has_obsolete_isolate_origins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OBSOLETE_DeviceLoginScreenIsolateOriginsProto::OBSOLETE_DeviceLoginScreenIsolateOriginsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
}
OBSOLETE_DeviceLoginScreenIsolateOriginsProto::OBSOLETE_DeviceLoginScreenIsolateOriginsProto(const OBSOLETE_DeviceLoginScreenIsolateOriginsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_DeviceLoginScreenIsolateOriginsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_isolate_origins_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.obsolete_isolate_origins_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_isolate_origins_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_isolate_origins()) {
    _this->_impl_.obsolete_isolate_origins_.Set(from._internal_obsolete_isolate_origins(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
}

inline void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_isolate_origins_){}
  };
  _impl_.obsolete_isolate_origins_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_isolate_origins_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OBSOLETE_DeviceLoginScreenIsolateOriginsProto::~OBSOLETE_DeviceLoginScreenIsolateOriginsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_isolate_origins_.Destroy();
}

void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.obsolete_isolate_origins_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_DeviceLoginScreenIsolateOriginsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string OBSOLETE_isolate_origins = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_obsolete_isolate_origins();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_DeviceLoginScreenIsolateOriginsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string OBSOLETE_isolate_origins = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_obsolete_isolate_origins(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
  return target;
}

size_t OBSOLETE_DeviceLoginScreenIsolateOriginsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string OBSOLETE_isolate_origins = 1 [deprecated = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_obsolete_isolate_origins());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_DeviceLoginScreenIsolateOriginsProto*>(
      &from));
}

void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::MergeFrom(const OBSOLETE_DeviceLoginScreenIsolateOriginsProto& from) {
  OBSOLETE_DeviceLoginScreenIsolateOriginsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_obsolete_isolate_origins()) {
    _this->_internal_set_obsolete_isolate_origins(from._internal_obsolete_isolate_origins());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::CopyFrom(const OBSOLETE_DeviceLoginScreenIsolateOriginsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_DeviceLoginScreenIsolateOriginsProto::IsInitialized() const {
  return true;
}

void OBSOLETE_DeviceLoginScreenIsolateOriginsProto::InternalSwap(OBSOLETE_DeviceLoginScreenIsolateOriginsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_isolate_origins_, lhs_arena,
      &other->_impl_.obsolete_isolate_origins_, rhs_arena
  );
}

std::string OBSOLETE_DeviceLoginScreenIsolateOriginsProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto";
}


// ===================================================================

class OBSOLETE_DeviceLoginScreenSitePerProcessProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_DeviceLoginScreenSitePerProcessProto>()._impl_._has_bits_);
  static void set_has_obsolete_site_per_process(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OBSOLETE_DeviceLoginScreenSitePerProcessProto::OBSOLETE_DeviceLoginScreenSitePerProcessProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
}
OBSOLETE_DeviceLoginScreenSitePerProcessProto::OBSOLETE_DeviceLoginScreenSitePerProcessProto(const OBSOLETE_DeviceLoginScreenSitePerProcessProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_DeviceLoginScreenSitePerProcessProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_site_per_process_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.obsolete_site_per_process_ = from._impl_.obsolete_site_per_process_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
}

inline void OBSOLETE_DeviceLoginScreenSitePerProcessProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_site_per_process_){false}
  };
}

OBSOLETE_DeviceLoginScreenSitePerProcessProto::~OBSOLETE_DeviceLoginScreenSitePerProcessProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_DeviceLoginScreenSitePerProcessProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OBSOLETE_DeviceLoginScreenSitePerProcessProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_DeviceLoginScreenSitePerProcessProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.obsolete_site_per_process_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_DeviceLoginScreenSitePerProcessProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool OBSOLETE_site_per_process = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_obsolete_site_per_process(&has_bits);
          _impl_.obsolete_site_per_process_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_DeviceLoginScreenSitePerProcessProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool OBSOLETE_site_per_process = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_obsolete_site_per_process(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
  return target;
}

size_t OBSOLETE_DeviceLoginScreenSitePerProcessProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool OBSOLETE_site_per_process = 1 [deprecated = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_DeviceLoginScreenSitePerProcessProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_DeviceLoginScreenSitePerProcessProto*>(
      &from));
}

void OBSOLETE_DeviceLoginScreenSitePerProcessProto::MergeFrom(const OBSOLETE_DeviceLoginScreenSitePerProcessProto& from) {
  OBSOLETE_DeviceLoginScreenSitePerProcessProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_obsolete_site_per_process()) {
    _this->_internal_set_obsolete_site_per_process(from._internal_obsolete_site_per_process());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_DeviceLoginScreenSitePerProcessProto::CopyFrom(const OBSOLETE_DeviceLoginScreenSitePerProcessProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_DeviceLoginScreenSitePerProcessProto::IsInitialized() const {
  return true;
}

void OBSOLETE_DeviceLoginScreenSitePerProcessProto::InternalSwap(OBSOLETE_DeviceLoginScreenSitePerProcessProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.obsolete_site_per_process_, other->_impl_.obsolete_site_per_process_);
}

std::string OBSOLETE_DeviceLoginScreenSitePerProcessProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto";
}


// ===================================================================

class VirtualMachinesAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<VirtualMachinesAllowedProto>()._impl_._has_bits_);
  static void set_has_virtual_machines_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

VirtualMachinesAllowedProto::VirtualMachinesAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.VirtualMachinesAllowedProto)
}
VirtualMachinesAllowedProto::VirtualMachinesAllowedProto(const VirtualMachinesAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VirtualMachinesAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.virtual_machines_allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.virtual_machines_allowed_ = from._impl_.virtual_machines_allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.VirtualMachinesAllowedProto)
}

inline void VirtualMachinesAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.virtual_machines_allowed_){false}
  };
}

VirtualMachinesAllowedProto::~VirtualMachinesAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.VirtualMachinesAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VirtualMachinesAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VirtualMachinesAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VirtualMachinesAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.VirtualMachinesAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.virtual_machines_allowed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VirtualMachinesAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool virtual_machines_allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_virtual_machines_allowed(&has_bits);
          _impl_.virtual_machines_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VirtualMachinesAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.VirtualMachinesAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool virtual_machines_allowed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_virtual_machines_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.VirtualMachinesAllowedProto)
  return target;
}

size_t VirtualMachinesAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.VirtualMachinesAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool virtual_machines_allowed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VirtualMachinesAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VirtualMachinesAllowedProto*>(
      &from));
}

void VirtualMachinesAllowedProto::MergeFrom(const VirtualMachinesAllowedProto& from) {
  VirtualMachinesAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.VirtualMachinesAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_virtual_machines_allowed()) {
    _this->_internal_set_virtual_machines_allowed(from._internal_virtual_machines_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VirtualMachinesAllowedProto::CopyFrom(const VirtualMachinesAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.VirtualMachinesAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VirtualMachinesAllowedProto::IsInitialized() const {
  return true;
}

void VirtualMachinesAllowedProto::InternalSwap(VirtualMachinesAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.virtual_machines_allowed_, other->_impl_.virtual_machines_allowed_);
}

std::string VirtualMachinesAllowedProto::GetTypeName() const {
  return "enterprise_management.VirtualMachinesAllowedProto";
}


// ===================================================================

class DeviceMachinePasswordChangeRateProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceMachinePasswordChangeRateProto>()._impl_._has_bits_);
  static void set_has_rate_days(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceMachinePasswordChangeRateProto::DeviceMachinePasswordChangeRateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceMachinePasswordChangeRateProto)
}
DeviceMachinePasswordChangeRateProto::DeviceMachinePasswordChangeRateProto(const DeviceMachinePasswordChangeRateProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceMachinePasswordChangeRateProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rate_days_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.rate_days_ = from._impl_.rate_days_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceMachinePasswordChangeRateProto)
}

inline void DeviceMachinePasswordChangeRateProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rate_days_){0}
  };
}

DeviceMachinePasswordChangeRateProto::~DeviceMachinePasswordChangeRateProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceMachinePasswordChangeRateProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceMachinePasswordChangeRateProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceMachinePasswordChangeRateProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceMachinePasswordChangeRateProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceMachinePasswordChangeRateProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rate_days_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceMachinePasswordChangeRateProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 rate_days = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rate_days(&has_bits);
          _impl_.rate_days_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceMachinePasswordChangeRateProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceMachinePasswordChangeRateProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 rate_days = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_rate_days(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceMachinePasswordChangeRateProto)
  return target;
}

size_t DeviceMachinePasswordChangeRateProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceMachinePasswordChangeRateProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 rate_days = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rate_days());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceMachinePasswordChangeRateProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceMachinePasswordChangeRateProto*>(
      &from));
}

void DeviceMachinePasswordChangeRateProto::MergeFrom(const DeviceMachinePasswordChangeRateProto& from) {
  DeviceMachinePasswordChangeRateProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceMachinePasswordChangeRateProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rate_days()) {
    _this->_internal_set_rate_days(from._internal_rate_days());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceMachinePasswordChangeRateProto::CopyFrom(const DeviceMachinePasswordChangeRateProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceMachinePasswordChangeRateProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceMachinePasswordChangeRateProto::IsInitialized() const {
  return true;
}

void DeviceMachinePasswordChangeRateProto::InternalSwap(DeviceMachinePasswordChangeRateProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.rate_days_, other->_impl_.rate_days_);
}

std::string DeviceMachinePasswordChangeRateProto::GetTypeName() const {
  return "enterprise_management.DeviceMachinePasswordChangeRateProto";
}


// ===================================================================

class DeviceGpoCacheLifetimeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceGpoCacheLifetimeProto>()._impl_._has_bits_);
  static void set_has_lifetime_hours(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceGpoCacheLifetimeProto::DeviceGpoCacheLifetimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceGpoCacheLifetimeProto)
}
DeviceGpoCacheLifetimeProto::DeviceGpoCacheLifetimeProto(const DeviceGpoCacheLifetimeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceGpoCacheLifetimeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lifetime_hours_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.lifetime_hours_ = from._impl_.lifetime_hours_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceGpoCacheLifetimeProto)
}

inline void DeviceGpoCacheLifetimeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lifetime_hours_){0}
  };
}

DeviceGpoCacheLifetimeProto::~DeviceGpoCacheLifetimeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceGpoCacheLifetimeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceGpoCacheLifetimeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceGpoCacheLifetimeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceGpoCacheLifetimeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceGpoCacheLifetimeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lifetime_hours_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceGpoCacheLifetimeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 lifetime_hours = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_lifetime_hours(&has_bits);
          _impl_.lifetime_hours_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceGpoCacheLifetimeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceGpoCacheLifetimeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 lifetime_hours = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_lifetime_hours(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceGpoCacheLifetimeProto)
  return target;
}

size_t DeviceGpoCacheLifetimeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceGpoCacheLifetimeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 lifetime_hours = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lifetime_hours());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceGpoCacheLifetimeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceGpoCacheLifetimeProto*>(
      &from));
}

void DeviceGpoCacheLifetimeProto::MergeFrom(const DeviceGpoCacheLifetimeProto& from) {
  DeviceGpoCacheLifetimeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceGpoCacheLifetimeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_lifetime_hours()) {
    _this->_internal_set_lifetime_hours(from._internal_lifetime_hours());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceGpoCacheLifetimeProto::CopyFrom(const DeviceGpoCacheLifetimeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceGpoCacheLifetimeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceGpoCacheLifetimeProto::IsInitialized() const {
  return true;
}

void DeviceGpoCacheLifetimeProto::InternalSwap(DeviceGpoCacheLifetimeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.lifetime_hours_, other->_impl_.lifetime_hours_);
}

std::string DeviceGpoCacheLifetimeProto::GetTypeName() const {
  return "enterprise_management.DeviceGpoCacheLifetimeProto";
}


// ===================================================================

class DeviceAuthDataCacheLifetimeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceAuthDataCacheLifetimeProto>()._impl_._has_bits_);
  static void set_has_lifetime_hours(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceAuthDataCacheLifetimeProto::DeviceAuthDataCacheLifetimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAuthDataCacheLifetimeProto)
}
DeviceAuthDataCacheLifetimeProto::DeviceAuthDataCacheLifetimeProto(const DeviceAuthDataCacheLifetimeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAuthDataCacheLifetimeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lifetime_hours_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.lifetime_hours_ = from._impl_.lifetime_hours_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAuthDataCacheLifetimeProto)
}

inline void DeviceAuthDataCacheLifetimeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lifetime_hours_){0}
  };
}

DeviceAuthDataCacheLifetimeProto::~DeviceAuthDataCacheLifetimeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAuthDataCacheLifetimeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAuthDataCacheLifetimeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceAuthDataCacheLifetimeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAuthDataCacheLifetimeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAuthDataCacheLifetimeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lifetime_hours_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAuthDataCacheLifetimeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 lifetime_hours = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_lifetime_hours(&has_bits);
          _impl_.lifetime_hours_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAuthDataCacheLifetimeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAuthDataCacheLifetimeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 lifetime_hours = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_lifetime_hours(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAuthDataCacheLifetimeProto)
  return target;
}

size_t DeviceAuthDataCacheLifetimeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAuthDataCacheLifetimeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 lifetime_hours = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lifetime_hours());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAuthDataCacheLifetimeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAuthDataCacheLifetimeProto*>(
      &from));
}

void DeviceAuthDataCacheLifetimeProto::MergeFrom(const DeviceAuthDataCacheLifetimeProto& from) {
  DeviceAuthDataCacheLifetimeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAuthDataCacheLifetimeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_lifetime_hours()) {
    _this->_internal_set_lifetime_hours(from._internal_lifetime_hours());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAuthDataCacheLifetimeProto::CopyFrom(const DeviceAuthDataCacheLifetimeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAuthDataCacheLifetimeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAuthDataCacheLifetimeProto::IsInitialized() const {
  return true;
}

void DeviceAuthDataCacheLifetimeProto::InternalSwap(DeviceAuthDataCacheLifetimeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.lifetime_hours_, other->_impl_.lifetime_hours_);
}

std::string DeviceAuthDataCacheLifetimeProto::GetTypeName() const {
  return "enterprise_management.DeviceAuthDataCacheLifetimeProto";
}


// ===================================================================

class DeviceUnaffiliatedCrostiniAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceUnaffiliatedCrostiniAllowedProto>()._impl_._has_bits_);
  static void set_has_device_unaffiliated_crostini_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceUnaffiliatedCrostiniAllowedProto::DeviceUnaffiliatedCrostiniAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
}
DeviceUnaffiliatedCrostiniAllowedProto::DeviceUnaffiliatedCrostiniAllowedProto(const DeviceUnaffiliatedCrostiniAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceUnaffiliatedCrostiniAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_unaffiliated_crostini_allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_unaffiliated_crostini_allowed_ = from._impl_.device_unaffiliated_crostini_allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
}

inline void DeviceUnaffiliatedCrostiniAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_unaffiliated_crostini_allowed_){false}
  };
}

DeviceUnaffiliatedCrostiniAllowedProto::~DeviceUnaffiliatedCrostiniAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceUnaffiliatedCrostiniAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceUnaffiliatedCrostiniAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceUnaffiliatedCrostiniAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_unaffiliated_crostini_allowed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceUnaffiliatedCrostiniAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_unaffiliated_crostini_allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_unaffiliated_crostini_allowed(&has_bits);
          _impl_.device_unaffiliated_crostini_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceUnaffiliatedCrostiniAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_unaffiliated_crostini_allowed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_unaffiliated_crostini_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
  return target;
}

size_t DeviceUnaffiliatedCrostiniAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_unaffiliated_crostini_allowed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceUnaffiliatedCrostiniAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceUnaffiliatedCrostiniAllowedProto*>(
      &from));
}

void DeviceUnaffiliatedCrostiniAllowedProto::MergeFrom(const DeviceUnaffiliatedCrostiniAllowedProto& from) {
  DeviceUnaffiliatedCrostiniAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_unaffiliated_crostini_allowed()) {
    _this->_internal_set_device_unaffiliated_crostini_allowed(from._internal_device_unaffiliated_crostini_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceUnaffiliatedCrostiniAllowedProto::CopyFrom(const DeviceUnaffiliatedCrostiniAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceUnaffiliatedCrostiniAllowedProto::IsInitialized() const {
  return true;
}

void DeviceUnaffiliatedCrostiniAllowedProto::InternalSwap(DeviceUnaffiliatedCrostiniAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_unaffiliated_crostini_allowed_, other->_impl_.device_unaffiliated_crostini_allowed_);
}

std::string DeviceUnaffiliatedCrostiniAllowedProto::GetTypeName() const {
  return "enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto";
}


// ===================================================================

class PluginVmAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PluginVmAllowedProto>()._impl_._has_bits_);
  static void set_has_plugin_vm_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PluginVmAllowedProto::PluginVmAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PluginVmAllowedProto)
}
PluginVmAllowedProto::PluginVmAllowedProto(const PluginVmAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PluginVmAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.plugin_vm_allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.plugin_vm_allowed_ = from._impl_.plugin_vm_allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PluginVmAllowedProto)
}

inline void PluginVmAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.plugin_vm_allowed_){false}
  };
}

PluginVmAllowedProto::~PluginVmAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.PluginVmAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PluginVmAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PluginVmAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PluginVmAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PluginVmAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.plugin_vm_allowed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PluginVmAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool plugin_vm_allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_plugin_vm_allowed(&has_bits);
          _impl_.plugin_vm_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PluginVmAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PluginVmAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool plugin_vm_allowed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_plugin_vm_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PluginVmAllowedProto)
  return target;
}

size_t PluginVmAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PluginVmAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool plugin_vm_allowed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PluginVmAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PluginVmAllowedProto*>(
      &from));
}

void PluginVmAllowedProto::MergeFrom(const PluginVmAllowedProto& from) {
  PluginVmAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PluginVmAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_plugin_vm_allowed()) {
    _this->_internal_set_plugin_vm_allowed(from._internal_plugin_vm_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PluginVmAllowedProto::CopyFrom(const PluginVmAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PluginVmAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PluginVmAllowedProto::IsInitialized() const {
  return true;
}

void PluginVmAllowedProto::InternalSwap(PluginVmAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.plugin_vm_allowed_, other->_impl_.plugin_vm_allowed_);
}

std::string PluginVmAllowedProto::GetTypeName() const {
  return "enterprise_management.PluginVmAllowedProto";
}


// ===================================================================

class PluginVmLicenseKeyProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PluginVmLicenseKeyProto>()._impl_._has_bits_);
  static void set_has_plugin_vm_license_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PluginVmLicenseKeyProto::PluginVmLicenseKeyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PluginVmLicenseKeyProto)
}
PluginVmLicenseKeyProto::PluginVmLicenseKeyProto(const PluginVmLicenseKeyProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PluginVmLicenseKeyProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.plugin_vm_license_key_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.plugin_vm_license_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plugin_vm_license_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_plugin_vm_license_key()) {
    _this->_impl_.plugin_vm_license_key_.Set(from._internal_plugin_vm_license_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PluginVmLicenseKeyProto)
}

inline void PluginVmLicenseKeyProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.plugin_vm_license_key_){}
  };
  _impl_.plugin_vm_license_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plugin_vm_license_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PluginVmLicenseKeyProto::~PluginVmLicenseKeyProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.PluginVmLicenseKeyProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PluginVmLicenseKeyProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.plugin_vm_license_key_.Destroy();
}

void PluginVmLicenseKeyProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PluginVmLicenseKeyProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PluginVmLicenseKeyProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.plugin_vm_license_key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PluginVmLicenseKeyProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string plugin_vm_license_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_plugin_vm_license_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PluginVmLicenseKeyProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PluginVmLicenseKeyProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string plugin_vm_license_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_plugin_vm_license_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PluginVmLicenseKeyProto)
  return target;
}

size_t PluginVmLicenseKeyProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PluginVmLicenseKeyProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string plugin_vm_license_key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_plugin_vm_license_key());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PluginVmLicenseKeyProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PluginVmLicenseKeyProto*>(
      &from));
}

void PluginVmLicenseKeyProto::MergeFrom(const PluginVmLicenseKeyProto& from) {
  PluginVmLicenseKeyProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PluginVmLicenseKeyProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_plugin_vm_license_key()) {
    _this->_internal_set_plugin_vm_license_key(from._internal_plugin_vm_license_key());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PluginVmLicenseKeyProto::CopyFrom(const PluginVmLicenseKeyProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PluginVmLicenseKeyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PluginVmLicenseKeyProto::IsInitialized() const {
  return true;
}

void PluginVmLicenseKeyProto::InternalSwap(PluginVmLicenseKeyProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.plugin_vm_license_key_, lhs_arena,
      &other->_impl_.plugin_vm_license_key_, rhs_arena
  );
}

std::string PluginVmLicenseKeyProto::GetTypeName() const {
  return "enterprise_management.PluginVmLicenseKeyProto";
}


// ===================================================================

class DeviceRebootOnUserSignoutProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceRebootOnUserSignoutProto>()._impl_._has_bits_);
  static void set_has_reboot_on_signout_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceRebootOnUserSignoutProto::DeviceRebootOnUserSignoutProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceRebootOnUserSignoutProto)
}
DeviceRebootOnUserSignoutProto::DeviceRebootOnUserSignoutProto(const DeviceRebootOnUserSignoutProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceRebootOnUserSignoutProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reboot_on_signout_mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.reboot_on_signout_mode_ = from._impl_.reboot_on_signout_mode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceRebootOnUserSignoutProto)
}

inline void DeviceRebootOnUserSignoutProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reboot_on_signout_mode_){1}
  };
}

DeviceRebootOnUserSignoutProto::~DeviceRebootOnUserSignoutProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceRebootOnUserSignoutProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceRebootOnUserSignoutProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceRebootOnUserSignoutProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceRebootOnUserSignoutProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceRebootOnUserSignoutProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reboot_on_signout_mode_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceRebootOnUserSignoutProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceRebootOnUserSignoutProto.RebootOnSignoutMode reboot_on_signout_mode = 1 [default = NEVER];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode_IsValid(val))) {
            _internal_set_reboot_on_signout_mode(static_cast<::enterprise_management::DeviceRebootOnUserSignoutProto_RebootOnSignoutMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceRebootOnUserSignoutProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceRebootOnUserSignoutProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceRebootOnUserSignoutProto.RebootOnSignoutMode reboot_on_signout_mode = 1 [default = NEVER];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reboot_on_signout_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceRebootOnUserSignoutProto)
  return target;
}

size_t DeviceRebootOnUserSignoutProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceRebootOnUserSignoutProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceRebootOnUserSignoutProto.RebootOnSignoutMode reboot_on_signout_mode = 1 [default = NEVER];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_reboot_on_signout_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceRebootOnUserSignoutProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceRebootOnUserSignoutProto*>(
      &from));
}

void DeviceRebootOnUserSignoutProto::MergeFrom(const DeviceRebootOnUserSignoutProto& from) {
  DeviceRebootOnUserSignoutProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceRebootOnUserSignoutProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reboot_on_signout_mode()) {
    _this->_internal_set_reboot_on_signout_mode(from._internal_reboot_on_signout_mode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceRebootOnUserSignoutProto::CopyFrom(const DeviceRebootOnUserSignoutProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceRebootOnUserSignoutProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRebootOnUserSignoutProto::IsInitialized() const {
  return true;
}

void DeviceRebootOnUserSignoutProto::InternalSwap(DeviceRebootOnUserSignoutProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.reboot_on_signout_mode_, other->_impl_.reboot_on_signout_mode_);
}

std::string DeviceRebootOnUserSignoutProto::GetTypeName() const {
  return "enterprise_management.DeviceRebootOnUserSignoutProto";
}


// ===================================================================

class DeviceWilcoDtcAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceWilcoDtcAllowedProto>()._impl_._has_bits_);
  static void set_has_device_wilco_dtc_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceWilcoDtcAllowedProto::DeviceWilcoDtcAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceWilcoDtcAllowedProto)
}
DeviceWilcoDtcAllowedProto::DeviceWilcoDtcAllowedProto(const DeviceWilcoDtcAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceWilcoDtcAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wilco_dtc_allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_wilco_dtc_allowed_ = from._impl_.device_wilco_dtc_allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceWilcoDtcAllowedProto)
}

inline void DeviceWilcoDtcAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wilco_dtc_allowed_){false}
  };
}

DeviceWilcoDtcAllowedProto::~DeviceWilcoDtcAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceWilcoDtcAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceWilcoDtcAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceWilcoDtcAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceWilcoDtcAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceWilcoDtcAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_wilco_dtc_allowed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceWilcoDtcAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_wilco_dtc_allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_wilco_dtc_allowed(&has_bits);
          _impl_.device_wilco_dtc_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceWilcoDtcAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceWilcoDtcAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_wilco_dtc_allowed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_wilco_dtc_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceWilcoDtcAllowedProto)
  return target;
}

size_t DeviceWilcoDtcAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceWilcoDtcAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_wilco_dtc_allowed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceWilcoDtcAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceWilcoDtcAllowedProto*>(
      &from));
}

void DeviceWilcoDtcAllowedProto::MergeFrom(const DeviceWilcoDtcAllowedProto& from) {
  DeviceWilcoDtcAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceWilcoDtcAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_wilco_dtc_allowed()) {
    _this->_internal_set_device_wilco_dtc_allowed(from._internal_device_wilco_dtc_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceWilcoDtcAllowedProto::CopyFrom(const DeviceWilcoDtcAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceWilcoDtcAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceWilcoDtcAllowedProto::IsInitialized() const {
  return true;
}

void DeviceWilcoDtcAllowedProto::InternalSwap(DeviceWilcoDtcAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_wilco_dtc_allowed_, other->_impl_.device_wilco_dtc_allowed_);
}

std::string DeviceWilcoDtcAllowedProto::GetTypeName() const {
  return "enterprise_management.DeviceWilcoDtcAllowedProto";
}


// ===================================================================

class DeviceWilcoDtcConfigurationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceWilcoDtcConfigurationProto>()._impl_._has_bits_);
  static void set_has_device_wilco_dtc_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceWilcoDtcConfigurationProto::DeviceWilcoDtcConfigurationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceWilcoDtcConfigurationProto)
}
DeviceWilcoDtcConfigurationProto::DeviceWilcoDtcConfigurationProto(const DeviceWilcoDtcConfigurationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceWilcoDtcConfigurationProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wilco_dtc_configuration_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_wilco_dtc_configuration_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_wilco_dtc_configuration_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_wilco_dtc_configuration()) {
    _this->_impl_.device_wilco_dtc_configuration_.Set(from._internal_device_wilco_dtc_configuration(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceWilcoDtcConfigurationProto)
}

inline void DeviceWilcoDtcConfigurationProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_wilco_dtc_configuration_){}
  };
  _impl_.device_wilco_dtc_configuration_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_wilco_dtc_configuration_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceWilcoDtcConfigurationProto::~DeviceWilcoDtcConfigurationProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceWilcoDtcConfigurationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceWilcoDtcConfigurationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_wilco_dtc_configuration_.Destroy();
}

void DeviceWilcoDtcConfigurationProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceWilcoDtcConfigurationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceWilcoDtcConfigurationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.device_wilco_dtc_configuration_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceWilcoDtcConfigurationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_wilco_dtc_configuration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_wilco_dtc_configuration();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceWilcoDtcConfigurationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceWilcoDtcConfigurationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_wilco_dtc_configuration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_wilco_dtc_configuration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceWilcoDtcConfigurationProto)
  return target;
}

size_t DeviceWilcoDtcConfigurationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceWilcoDtcConfigurationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_wilco_dtc_configuration = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_wilco_dtc_configuration());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceWilcoDtcConfigurationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceWilcoDtcConfigurationProto*>(
      &from));
}

void DeviceWilcoDtcConfigurationProto::MergeFrom(const DeviceWilcoDtcConfigurationProto& from) {
  DeviceWilcoDtcConfigurationProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceWilcoDtcConfigurationProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_wilco_dtc_configuration()) {
    _this->_internal_set_device_wilco_dtc_configuration(from._internal_device_wilco_dtc_configuration());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceWilcoDtcConfigurationProto::CopyFrom(const DeviceWilcoDtcConfigurationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceWilcoDtcConfigurationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceWilcoDtcConfigurationProto::IsInitialized() const {
  return true;
}

void DeviceWilcoDtcConfigurationProto::InternalSwap(DeviceWilcoDtcConfigurationProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_wilco_dtc_configuration_, lhs_arena,
      &other->_impl_.device_wilco_dtc_configuration_, rhs_arena
  );
}

std::string DeviceWilcoDtcConfigurationProto::GetTypeName() const {
  return "enterprise_management.DeviceWilcoDtcConfigurationProto";
}


// ===================================================================

class DevicePowerPeakShiftProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePowerPeakShiftProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_battery_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_day_configs(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DevicePowerPeakShiftProto::DevicePowerPeakShiftProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePowerPeakShiftProto)
}
DevicePowerPeakShiftProto::DevicePowerPeakShiftProto(const DevicePowerPeakShiftProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePowerPeakShiftProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.day_configs_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.battery_threshold_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.day_configs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.day_configs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_day_configs()) {
    _this->_impl_.day_configs_.Set(from._internal_day_configs(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.battery_threshold_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.battery_threshold_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePowerPeakShiftProto)
}

inline void DevicePowerPeakShiftProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.day_configs_){}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.battery_threshold_){0}
  };
  _impl_.day_configs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.day_configs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DevicePowerPeakShiftProto::~DevicePowerPeakShiftProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePowerPeakShiftProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePowerPeakShiftProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.day_configs_.Destroy();
}

void DevicePowerPeakShiftProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePowerPeakShiftProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePowerPeakShiftProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.day_configs_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.battery_threshold_) -
        reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.battery_threshold_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePowerPeakShiftProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 battery_threshold = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_battery_threshold(&has_bits);
          _impl_.battery_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string day_configs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_day_configs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePowerPeakShiftProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePowerPeakShiftProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // optional int32 battery_threshold = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_battery_threshold(), target);
  }

  // optional string day_configs = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_day_configs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePowerPeakShiftProto)
  return target;
}

size_t DevicePowerPeakShiftProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePowerPeakShiftProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string day_configs = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_day_configs());
    }

    // optional bool enabled = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 battery_threshold = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_battery_threshold());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePowerPeakShiftProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePowerPeakShiftProto*>(
      &from));
}

void DevicePowerPeakShiftProto::MergeFrom(const DevicePowerPeakShiftProto& from) {
  DevicePowerPeakShiftProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePowerPeakShiftProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_day_configs(from._internal_day_configs());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.battery_threshold_ = from._impl_.battery_threshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePowerPeakShiftProto::CopyFrom(const DevicePowerPeakShiftProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePowerPeakShiftProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePowerPeakShiftProto::IsInitialized() const {
  return true;
}

void DevicePowerPeakShiftProto::InternalSwap(DevicePowerPeakShiftProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.day_configs_, lhs_arena,
      &other->_impl_.day_configs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DevicePowerPeakShiftProto, _impl_.battery_threshold_)
      + sizeof(DevicePowerPeakShiftProto::_impl_.battery_threshold_)
      - PROTOBUF_FIELD_OFFSET(DevicePowerPeakShiftProto, _impl_.enabled_)>(
          reinterpret_cast<char*>(&_impl_.enabled_),
          reinterpret_cast<char*>(&other->_impl_.enabled_));
}

std::string DevicePowerPeakShiftProto::GetTypeName() const {
  return "enterprise_management.DevicePowerPeakShiftProto";
}


// ===================================================================

class DeviceBootOnAcProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceBootOnAcProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceBootOnAcProto::DeviceBootOnAcProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceBootOnAcProto)
}
DeviceBootOnAcProto::DeviceBootOnAcProto(const DeviceBootOnAcProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceBootOnAcProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceBootOnAcProto)
}

inline void DeviceBootOnAcProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceBootOnAcProto::~DeviceBootOnAcProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceBootOnAcProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceBootOnAcProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceBootOnAcProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceBootOnAcProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceBootOnAcProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceBootOnAcProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceBootOnAcProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceBootOnAcProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceBootOnAcProto)
  return target;
}

size_t DeviceBootOnAcProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceBootOnAcProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceBootOnAcProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceBootOnAcProto*>(
      &from));
}

void DeviceBootOnAcProto::MergeFrom(const DeviceBootOnAcProto& from) {
  DeviceBootOnAcProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceBootOnAcProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceBootOnAcProto::CopyFrom(const DeviceBootOnAcProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceBootOnAcProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceBootOnAcProto::IsInitialized() const {
  return true;
}

void DeviceBootOnAcProto::InternalSwap(DeviceBootOnAcProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceBootOnAcProto::GetTypeName() const {
  return "enterprise_management.DeviceBootOnAcProto";
}


// ===================================================================

class DeviceDockMacAddressSourceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceDockMacAddressSourceProto>()._impl_._has_bits_);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceDockMacAddressSourceProto::DeviceDockMacAddressSourceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceDockMacAddressSourceProto)
}
DeviceDockMacAddressSourceProto::DeviceDockMacAddressSourceProto(const DeviceDockMacAddressSourceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceDockMacAddressSourceProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.source_ = from._impl_.source_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceDockMacAddressSourceProto)
}

inline void DeviceDockMacAddressSourceProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_){0}
  };
}

DeviceDockMacAddressSourceProto::~DeviceDockMacAddressSourceProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceDockMacAddressSourceProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceDockMacAddressSourceProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceDockMacAddressSourceProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceDockMacAddressSourceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceDockMacAddressSourceProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceDockMacAddressSourceProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceDockMacAddressSourceProto.Source source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceDockMacAddressSourceProto_Source_IsValid(val))) {
            _internal_set_source(static_cast<::enterprise_management::DeviceDockMacAddressSourceProto_Source>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceDockMacAddressSourceProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceDockMacAddressSourceProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceDockMacAddressSourceProto.Source source = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_source(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceDockMacAddressSourceProto)
  return target;
}

size_t DeviceDockMacAddressSourceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceDockMacAddressSourceProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceDockMacAddressSourceProto.Source source = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_source());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceDockMacAddressSourceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceDockMacAddressSourceProto*>(
      &from));
}

void DeviceDockMacAddressSourceProto::MergeFrom(const DeviceDockMacAddressSourceProto& from) {
  DeviceDockMacAddressSourceProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceDockMacAddressSourceProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_source()) {
    _this->_internal_set_source(from._internal_source());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceDockMacAddressSourceProto::CopyFrom(const DeviceDockMacAddressSourceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceDockMacAddressSourceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceDockMacAddressSourceProto::IsInitialized() const {
  return true;
}

void DeviceDockMacAddressSourceProto::InternalSwap(DeviceDockMacAddressSourceProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.source_, other->_impl_.source_);
}

std::string DeviceDockMacAddressSourceProto::GetTypeName() const {
  return "enterprise_management.DeviceDockMacAddressSourceProto";
}


// ===================================================================

class DeviceAdvancedBatteryChargeModeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceAdvancedBatteryChargeModeProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_day_configs(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceAdvancedBatteryChargeModeProto::DeviceAdvancedBatteryChargeModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
}
DeviceAdvancedBatteryChargeModeProto::DeviceAdvancedBatteryChargeModeProto(const DeviceAdvancedBatteryChargeModeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAdvancedBatteryChargeModeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.day_configs_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.day_configs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.day_configs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_day_configs()) {
    _this->_impl_.day_configs_.Set(from._internal_day_configs(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
}

inline void DeviceAdvancedBatteryChargeModeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.day_configs_){}
    , decltype(_impl_.enabled_){false}
  };
  _impl_.day_configs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.day_configs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceAdvancedBatteryChargeModeProto::~DeviceAdvancedBatteryChargeModeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAdvancedBatteryChargeModeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.day_configs_.Destroy();
}

void DeviceAdvancedBatteryChargeModeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAdvancedBatteryChargeModeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.day_configs_.ClearNonDefaultToEmpty();
  }
  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAdvancedBatteryChargeModeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string day_configs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_day_configs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAdvancedBatteryChargeModeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // optional string day_configs = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_day_configs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
  return target;
}

size_t DeviceAdvancedBatteryChargeModeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string day_configs = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_day_configs());
    }

    // optional bool enabled = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAdvancedBatteryChargeModeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAdvancedBatteryChargeModeProto*>(
      &from));
}

void DeviceAdvancedBatteryChargeModeProto::MergeFrom(const DeviceAdvancedBatteryChargeModeProto& from) {
  DeviceAdvancedBatteryChargeModeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_day_configs(from._internal_day_configs());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAdvancedBatteryChargeModeProto::CopyFrom(const DeviceAdvancedBatteryChargeModeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAdvancedBatteryChargeModeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAdvancedBatteryChargeModeProto::IsInitialized() const {
  return true;
}

void DeviceAdvancedBatteryChargeModeProto::InternalSwap(DeviceAdvancedBatteryChargeModeProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.day_configs_, lhs_arena,
      &other->_impl_.day_configs_, rhs_arena
  );
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceAdvancedBatteryChargeModeProto::GetTypeName() const {
  return "enterprise_management.DeviceAdvancedBatteryChargeModeProto";
}


// ===================================================================

class DeviceBatteryChargeModeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceBatteryChargeModeProto>()._impl_._has_bits_);
  static void set_has_battery_charge_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_custom_charge_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_custom_charge_stop(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DeviceBatteryChargeModeProto::DeviceBatteryChargeModeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceBatteryChargeModeProto)
}
DeviceBatteryChargeModeProto::DeviceBatteryChargeModeProto(const DeviceBatteryChargeModeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceBatteryChargeModeProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.battery_charge_mode_){}
    , decltype(_impl_.custom_charge_start_){}
    , decltype(_impl_.custom_charge_stop_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.battery_charge_mode_, &from._impl_.battery_charge_mode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.custom_charge_stop_) -
    reinterpret_cast<char*>(&_impl_.battery_charge_mode_)) + sizeof(_impl_.custom_charge_stop_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceBatteryChargeModeProto)
}

inline void DeviceBatteryChargeModeProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.battery_charge_mode_){0}
    , decltype(_impl_.custom_charge_start_){0}
    , decltype(_impl_.custom_charge_stop_){0}
  };
}

DeviceBatteryChargeModeProto::~DeviceBatteryChargeModeProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceBatteryChargeModeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceBatteryChargeModeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceBatteryChargeModeProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceBatteryChargeModeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceBatteryChargeModeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.battery_charge_mode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.custom_charge_stop_) -
        reinterpret_cast<char*>(&_impl_.battery_charge_mode_)) + sizeof(_impl_.custom_charge_stop_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceBatteryChargeModeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceBatteryChargeModeProto.BatteryChargeMode battery_charge_mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode_IsValid(val))) {
            _internal_set_battery_charge_mode(static_cast<::enterprise_management::DeviceBatteryChargeModeProto_BatteryChargeMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 custom_charge_start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_custom_charge_start(&has_bits);
          _impl_.custom_charge_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 custom_charge_stop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_custom_charge_stop(&has_bits);
          _impl_.custom_charge_stop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceBatteryChargeModeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceBatteryChargeModeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceBatteryChargeModeProto.BatteryChargeMode battery_charge_mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_battery_charge_mode(), target);
  }

  // optional int32 custom_charge_start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_custom_charge_start(), target);
  }

  // optional int32 custom_charge_stop = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_custom_charge_stop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceBatteryChargeModeProto)
  return target;
}

size_t DeviceBatteryChargeModeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceBatteryChargeModeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .enterprise_management.DeviceBatteryChargeModeProto.BatteryChargeMode battery_charge_mode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_battery_charge_mode());
    }

    // optional int32 custom_charge_start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_custom_charge_start());
    }

    // optional int32 custom_charge_stop = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_custom_charge_stop());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceBatteryChargeModeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceBatteryChargeModeProto*>(
      &from));
}

void DeviceBatteryChargeModeProto::MergeFrom(const DeviceBatteryChargeModeProto& from) {
  DeviceBatteryChargeModeProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceBatteryChargeModeProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.battery_charge_mode_ = from._impl_.battery_charge_mode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.custom_charge_start_ = from._impl_.custom_charge_start_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.custom_charge_stop_ = from._impl_.custom_charge_stop_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceBatteryChargeModeProto::CopyFrom(const DeviceBatteryChargeModeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceBatteryChargeModeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceBatteryChargeModeProto::IsInitialized() const {
  return true;
}

void DeviceBatteryChargeModeProto::InternalSwap(DeviceBatteryChargeModeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceBatteryChargeModeProto, _impl_.custom_charge_stop_)
      + sizeof(DeviceBatteryChargeModeProto::_impl_.custom_charge_stop_)
      - PROTOBUF_FIELD_OFFSET(DeviceBatteryChargeModeProto, _impl_.battery_charge_mode_)>(
          reinterpret_cast<char*>(&_impl_.battery_charge_mode_),
          reinterpret_cast<char*>(&other->_impl_.battery_charge_mode_));
}

std::string DeviceBatteryChargeModeProto::GetTypeName() const {
  return "enterprise_management.DeviceBatteryChargeModeProto";
}


// ===================================================================

class DeviceUsbPowerShareProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceUsbPowerShareProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceUsbPowerShareProto::DeviceUsbPowerShareProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceUsbPowerShareProto)
}
DeviceUsbPowerShareProto::DeviceUsbPowerShareProto(const DeviceUsbPowerShareProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceUsbPowerShareProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceUsbPowerShareProto)
}

inline void DeviceUsbPowerShareProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceUsbPowerShareProto::~DeviceUsbPowerShareProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceUsbPowerShareProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceUsbPowerShareProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceUsbPowerShareProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceUsbPowerShareProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceUsbPowerShareProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceUsbPowerShareProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceUsbPowerShareProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceUsbPowerShareProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceUsbPowerShareProto)
  return target;
}

size_t DeviceUsbPowerShareProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceUsbPowerShareProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceUsbPowerShareProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceUsbPowerShareProto*>(
      &from));
}

void DeviceUsbPowerShareProto::MergeFrom(const DeviceUsbPowerShareProto& from) {
  DeviceUsbPowerShareProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceUsbPowerShareProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceUsbPowerShareProto::CopyFrom(const DeviceUsbPowerShareProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceUsbPowerShareProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceUsbPowerShareProto::IsInitialized() const {
  return true;
}

void DeviceUsbPowerShareProto::InternalSwap(DeviceUsbPowerShareProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceUsbPowerShareProto::GetTypeName() const {
  return "enterprise_management.DeviceUsbPowerShareProto";
}


// ===================================================================

class DeviceScheduledUpdateCheckProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceScheduledUpdateCheckProto>()._impl_._has_bits_);
  static void set_has_device_scheduled_update_check_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceScheduledUpdateCheckProto::DeviceScheduledUpdateCheckProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceScheduledUpdateCheckProto)
}
DeviceScheduledUpdateCheckProto::DeviceScheduledUpdateCheckProto(const DeviceScheduledUpdateCheckProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceScheduledUpdateCheckProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_scheduled_update_check_settings_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_scheduled_update_check_settings_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_scheduled_update_check_settings_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_scheduled_update_check_settings()) {
    _this->_impl_.device_scheduled_update_check_settings_.Set(from._internal_device_scheduled_update_check_settings(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceScheduledUpdateCheckProto)
}

inline void DeviceScheduledUpdateCheckProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_scheduled_update_check_settings_){}
  };
  _impl_.device_scheduled_update_check_settings_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_scheduled_update_check_settings_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceScheduledUpdateCheckProto::~DeviceScheduledUpdateCheckProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceScheduledUpdateCheckProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceScheduledUpdateCheckProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_scheduled_update_check_settings_.Destroy();
}

void DeviceScheduledUpdateCheckProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceScheduledUpdateCheckProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceScheduledUpdateCheckProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.device_scheduled_update_check_settings_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceScheduledUpdateCheckProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_scheduled_update_check_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_scheduled_update_check_settings();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceScheduledUpdateCheckProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceScheduledUpdateCheckProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_scheduled_update_check_settings = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_scheduled_update_check_settings(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceScheduledUpdateCheckProto)
  return target;
}

size_t DeviceScheduledUpdateCheckProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceScheduledUpdateCheckProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_scheduled_update_check_settings = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_scheduled_update_check_settings());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceScheduledUpdateCheckProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceScheduledUpdateCheckProto*>(
      &from));
}

void DeviceScheduledUpdateCheckProto::MergeFrom(const DeviceScheduledUpdateCheckProto& from) {
  DeviceScheduledUpdateCheckProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceScheduledUpdateCheckProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_scheduled_update_check_settings()) {
    _this->_internal_set_device_scheduled_update_check_settings(from._internal_device_scheduled_update_check_settings());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceScheduledUpdateCheckProto::CopyFrom(const DeviceScheduledUpdateCheckProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceScheduledUpdateCheckProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceScheduledUpdateCheckProto::IsInitialized() const {
  return true;
}

void DeviceScheduledUpdateCheckProto::InternalSwap(DeviceScheduledUpdateCheckProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_scheduled_update_check_settings_, lhs_arena,
      &other->_impl_.device_scheduled_update_check_settings_, rhs_arena
  );
}

std::string DeviceScheduledUpdateCheckProto::GetTypeName() const {
  return "enterprise_management.DeviceScheduledUpdateCheckProto";
}


// ===================================================================

class DevicePowerwashAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePowerwashAllowedProto>()._impl_._has_bits_);
  static void set_has_device_powerwash_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DevicePowerwashAllowedProto::DevicePowerwashAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePowerwashAllowedProto)
}
DevicePowerwashAllowedProto::DevicePowerwashAllowedProto(const DevicePowerwashAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePowerwashAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_powerwash_allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_powerwash_allowed_ = from._impl_.device_powerwash_allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePowerwashAllowedProto)
}

inline void DevicePowerwashAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_powerwash_allowed_){false}
  };
}

DevicePowerwashAllowedProto::~DevicePowerwashAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePowerwashAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePowerwashAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DevicePowerwashAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePowerwashAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePowerwashAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_powerwash_allowed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePowerwashAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_powerwash_allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_powerwash_allowed(&has_bits);
          _impl_.device_powerwash_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePowerwashAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePowerwashAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_powerwash_allowed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_powerwash_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePowerwashAllowedProto)
  return target;
}

size_t DevicePowerwashAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePowerwashAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_powerwash_allowed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePowerwashAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePowerwashAllowedProto*>(
      &from));
}

void DevicePowerwashAllowedProto::MergeFrom(const DevicePowerwashAllowedProto& from) {
  DevicePowerwashAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePowerwashAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_powerwash_allowed()) {
    _this->_internal_set_device_powerwash_allowed(from._internal_device_powerwash_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePowerwashAllowedProto::CopyFrom(const DevicePowerwashAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePowerwashAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePowerwashAllowedProto::IsInitialized() const {
  return true;
}

void DevicePowerwashAllowedProto::InternalSwap(DevicePowerwashAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_powerwash_allowed_, other->_impl_.device_powerwash_allowed_);
}

std::string DevicePowerwashAllowedProto::GetTypeName() const {
  return "enterprise_management.DevicePowerwashAllowedProto";
}


// ===================================================================

class DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceLoginScreenWebUsbAllowDevicesForUrlsProto>()._impl_._has_bits_);
  static void set_has_device_login_screen_webusb_allow_devices_for_urls(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
}
DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_login_screen_webusb_allow_devices_for_urls_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_login_screen_webusb_allow_devices_for_urls_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_login_screen_webusb_allow_devices_for_urls_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_login_screen_webusb_allow_devices_for_urls()) {
    _this->_impl_.device_login_screen_webusb_allow_devices_for_urls_.Set(from._internal_device_login_screen_webusb_allow_devices_for_urls(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
}

inline void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_login_screen_webusb_allow_devices_for_urls_){}
  };
  _impl_.device_login_screen_webusb_allow_devices_for_urls_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_login_screen_webusb_allow_devices_for_urls_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::~DeviceLoginScreenWebUsbAllowDevicesForUrlsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_login_screen_webusb_allow_devices_for_urls_.Destroy();
}

void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.device_login_screen_webusb_allow_devices_for_urls_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_login_screen_webusb_allow_devices_for_urls = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_login_screen_webusb_allow_devices_for_urls();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_login_screen_webusb_allow_devices_for_urls = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_login_screen_webusb_allow_devices_for_urls(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
  return target;
}

size_t DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_login_screen_webusb_allow_devices_for_urls = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_login_screen_webusb_allow_devices_for_urls());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto*>(
      &from));
}

void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::MergeFrom(const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& from) {
  DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_login_screen_webusb_allow_devices_for_urls()) {
    _this->_internal_set_device_login_screen_webusb_allow_devices_for_urls(from._internal_device_login_screen_webusb_allow_devices_for_urls());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::CopyFrom(const DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::IsInitialized() const {
  return true;
}

void DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::InternalSwap(DeviceLoginScreenWebUsbAllowDevicesForUrlsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_login_screen_webusb_allow_devices_for_urls_, lhs_arena,
      &other->_impl_.device_login_screen_webusb_allow_devices_for_urls_, rhs_arena
  );
}

std::string DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::GetTypeName() const {
  return "enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto";
}


// ===================================================================

class SystemProxySettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProxySettingsProto>()._impl_._has_bits_);
  static void set_has_system_proxy_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SystemProxySettingsProto::SystemProxySettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SystemProxySettingsProto)
}
SystemProxySettingsProto::SystemProxySettingsProto(const SystemProxySettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemProxySettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.system_proxy_settings_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.system_proxy_settings_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_proxy_settings_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_system_proxy_settings()) {
    _this->_impl_.system_proxy_settings_.Set(from._internal_system_proxy_settings(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SystemProxySettingsProto)
}

inline void SystemProxySettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.system_proxy_settings_){}
  };
  _impl_.system_proxy_settings_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_proxy_settings_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemProxySettingsProto::~SystemProxySettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.SystemProxySettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProxySettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.system_proxy_settings_.Destroy();
}

void SystemProxySettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemProxySettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SystemProxySettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.system_proxy_settings_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProxySettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string system_proxy_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_system_proxy_settings();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProxySettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SystemProxySettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string system_proxy_settings = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_system_proxy_settings(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SystemProxySettingsProto)
  return target;
}

size_t SystemProxySettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SystemProxySettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string system_proxy_settings = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_system_proxy_settings());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProxySettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProxySettingsProto*>(
      &from));
}

void SystemProxySettingsProto::MergeFrom(const SystemProxySettingsProto& from) {
  SystemProxySettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SystemProxySettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_system_proxy_settings()) {
    _this->_internal_set_system_proxy_settings(from._internal_system_proxy_settings());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProxySettingsProto::CopyFrom(const SystemProxySettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SystemProxySettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProxySettingsProto::IsInitialized() const {
  return true;
}

void SystemProxySettingsProto::InternalSwap(SystemProxySettingsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.system_proxy_settings_, lhs_arena,
      &other->_impl_.system_proxy_settings_, rhs_arena
  );
}

std::string SystemProxySettingsProto::GetTypeName() const {
  return "enterprise_management.SystemProxySettingsProto";
}


// ===================================================================

class RequiredClientCertificateForDeviceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<RequiredClientCertificateForDeviceProto>()._impl_._has_bits_);
  static void set_has_required_client_certificate_for_device(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequiredClientCertificateForDeviceProto::RequiredClientCertificateForDeviceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RequiredClientCertificateForDeviceProto)
}
RequiredClientCertificateForDeviceProto::RequiredClientCertificateForDeviceProto(const RequiredClientCertificateForDeviceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RequiredClientCertificateForDeviceProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.required_client_certificate_for_device_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.required_client_certificate_for_device_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.required_client_certificate_for_device_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_required_client_certificate_for_device()) {
    _this->_impl_.required_client_certificate_for_device_.Set(from._internal_required_client_certificate_for_device(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RequiredClientCertificateForDeviceProto)
}

inline void RequiredClientCertificateForDeviceProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.required_client_certificate_for_device_){}
  };
  _impl_.required_client_certificate_for_device_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.required_client_certificate_for_device_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequiredClientCertificateForDeviceProto::~RequiredClientCertificateForDeviceProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.RequiredClientCertificateForDeviceProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequiredClientCertificateForDeviceProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.required_client_certificate_for_device_.Destroy();
}

void RequiredClientCertificateForDeviceProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequiredClientCertificateForDeviceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RequiredClientCertificateForDeviceProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.required_client_certificate_for_device_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RequiredClientCertificateForDeviceProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string required_client_certificate_for_device = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_required_client_certificate_for_device();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequiredClientCertificateForDeviceProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RequiredClientCertificateForDeviceProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string required_client_certificate_for_device = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_required_client_certificate_for_device(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RequiredClientCertificateForDeviceProto)
  return target;
}

size_t RequiredClientCertificateForDeviceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RequiredClientCertificateForDeviceProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string required_client_certificate_for_device = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_required_client_certificate_for_device());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequiredClientCertificateForDeviceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RequiredClientCertificateForDeviceProto*>(
      &from));
}

void RequiredClientCertificateForDeviceProto::MergeFrom(const RequiredClientCertificateForDeviceProto& from) {
  RequiredClientCertificateForDeviceProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RequiredClientCertificateForDeviceProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_required_client_certificate_for_device()) {
    _this->_internal_set_required_client_certificate_for_device(from._internal_required_client_certificate_for_device());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RequiredClientCertificateForDeviceProto::CopyFrom(const RequiredClientCertificateForDeviceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RequiredClientCertificateForDeviceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequiredClientCertificateForDeviceProto::IsInitialized() const {
  return true;
}

void RequiredClientCertificateForDeviceProto::InternalSwap(RequiredClientCertificateForDeviceProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.required_client_certificate_for_device_, lhs_arena,
      &other->_impl_.required_client_certificate_for_device_, rhs_arena
  );
}

std::string RequiredClientCertificateForDeviceProto::GetTypeName() const {
  return "enterprise_management.RequiredClientCertificateForDeviceProto";
}


// ===================================================================

class DeviceCrostiniArcAdbSideloadingAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceCrostiniArcAdbSideloadingAllowedProto>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceCrostiniArcAdbSideloadingAllowedProto::DeviceCrostiniArcAdbSideloadingAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
}
DeviceCrostiniArcAdbSideloadingAllowedProto::DeviceCrostiniArcAdbSideloadingAllowedProto(const DeviceCrostiniArcAdbSideloadingAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceCrostiniArcAdbSideloadingAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
}

inline void DeviceCrostiniArcAdbSideloadingAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){0}
  };
}

DeviceCrostiniArcAdbSideloadingAllowedProto::~DeviceCrostiniArcAdbSideloadingAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceCrostiniArcAdbSideloadingAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceCrostiniArcAdbSideloadingAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceCrostiniArcAdbSideloadingAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceCrostiniArcAdbSideloadingAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto.AllowanceMode mode = 1 [default = DISALLOW];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode_IsValid(val))) {
            _internal_set_mode(static_cast<::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto_AllowanceMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceCrostiniArcAdbSideloadingAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto.AllowanceMode mode = 1 [default = DISALLOW];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
  return target;
}

size_t DeviceCrostiniArcAdbSideloadingAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto.AllowanceMode mode = 1 [default = DISALLOW];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceCrostiniArcAdbSideloadingAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceCrostiniArcAdbSideloadingAllowedProto*>(
      &from));
}

void DeviceCrostiniArcAdbSideloadingAllowedProto::MergeFrom(const DeviceCrostiniArcAdbSideloadingAllowedProto& from) {
  DeviceCrostiniArcAdbSideloadingAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mode()) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceCrostiniArcAdbSideloadingAllowedProto::CopyFrom(const DeviceCrostiniArcAdbSideloadingAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceCrostiniArcAdbSideloadingAllowedProto::IsInitialized() const {
  return true;
}

void DeviceCrostiniArcAdbSideloadingAllowedProto::InternalSwap(DeviceCrostiniArcAdbSideloadingAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.mode_, other->_impl_.mode_);
}

std::string DeviceCrostiniArcAdbSideloadingAllowedProto::GetTypeName() const {
  return "enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto";
}


// ===================================================================

class DeviceShowLowDiskSpaceNotificationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceShowLowDiskSpaceNotificationProto>()._impl_._has_bits_);
  static void set_has_device_show_low_disk_space_notification(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceShowLowDiskSpaceNotificationProto::DeviceShowLowDiskSpaceNotificationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
}
DeviceShowLowDiskSpaceNotificationProto::DeviceShowLowDiskSpaceNotificationProto(const DeviceShowLowDiskSpaceNotificationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceShowLowDiskSpaceNotificationProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_show_low_disk_space_notification_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.device_show_low_disk_space_notification_ = from._impl_.device_show_low_disk_space_notification_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
}

inline void DeviceShowLowDiskSpaceNotificationProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_show_low_disk_space_notification_){false}
  };
}

DeviceShowLowDiskSpaceNotificationProto::~DeviceShowLowDiskSpaceNotificationProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceShowLowDiskSpaceNotificationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceShowLowDiskSpaceNotificationProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceShowLowDiskSpaceNotificationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_show_low_disk_space_notification_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceShowLowDiskSpaceNotificationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool device_show_low_disk_space_notification = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_show_low_disk_space_notification(&has_bits);
          _impl_.device_show_low_disk_space_notification_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceShowLowDiskSpaceNotificationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool device_show_low_disk_space_notification = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_device_show_low_disk_space_notification(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
  return target;
}

size_t DeviceShowLowDiskSpaceNotificationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool device_show_low_disk_space_notification = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceShowLowDiskSpaceNotificationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceShowLowDiskSpaceNotificationProto*>(
      &from));
}

void DeviceShowLowDiskSpaceNotificationProto::MergeFrom(const DeviceShowLowDiskSpaceNotificationProto& from) {
  DeviceShowLowDiskSpaceNotificationProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_show_low_disk_space_notification()) {
    _this->_internal_set_device_show_low_disk_space_notification(from._internal_device_show_low_disk_space_notification());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceShowLowDiskSpaceNotificationProto::CopyFrom(const DeviceShowLowDiskSpaceNotificationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceShowLowDiskSpaceNotificationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceShowLowDiskSpaceNotificationProto::IsInitialized() const {
  return true;
}

void DeviceShowLowDiskSpaceNotificationProto::InternalSwap(DeviceShowLowDiskSpaceNotificationProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.device_show_low_disk_space_notification_, other->_impl_.device_show_low_disk_space_notification_);
}

std::string DeviceShowLowDiskSpaceNotificationProto::GetTypeName() const {
  return "enterprise_management.DeviceShowLowDiskSpaceNotificationProto";
}


// ===================================================================

class DeviceFamilyLinkAccountsAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceFamilyLinkAccountsAllowedProto>()._impl_._has_bits_);
  static void set_has_family_link_accounts_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceFamilyLinkAccountsAllowedProto::DeviceFamilyLinkAccountsAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
}
DeviceFamilyLinkAccountsAllowedProto::DeviceFamilyLinkAccountsAllowedProto(const DeviceFamilyLinkAccountsAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceFamilyLinkAccountsAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.family_link_accounts_allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.family_link_accounts_allowed_ = from._impl_.family_link_accounts_allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
}

inline void DeviceFamilyLinkAccountsAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.family_link_accounts_allowed_){false}
  };
}

DeviceFamilyLinkAccountsAllowedProto::~DeviceFamilyLinkAccountsAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceFamilyLinkAccountsAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceFamilyLinkAccountsAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceFamilyLinkAccountsAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.family_link_accounts_allowed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceFamilyLinkAccountsAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool family_link_accounts_allowed = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_family_link_accounts_allowed(&has_bits);
          _impl_.family_link_accounts_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceFamilyLinkAccountsAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool family_link_accounts_allowed = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_family_link_accounts_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
  return target;
}

size_t DeviceFamilyLinkAccountsAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool family_link_accounts_allowed = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceFamilyLinkAccountsAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceFamilyLinkAccountsAllowedProto*>(
      &from));
}

void DeviceFamilyLinkAccountsAllowedProto::MergeFrom(const DeviceFamilyLinkAccountsAllowedProto& from) {
  DeviceFamilyLinkAccountsAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_family_link_accounts_allowed()) {
    _this->_internal_set_family_link_accounts_allowed(from._internal_family_link_accounts_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceFamilyLinkAccountsAllowedProto::CopyFrom(const DeviceFamilyLinkAccountsAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceFamilyLinkAccountsAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceFamilyLinkAccountsAllowedProto::IsInitialized() const {
  return true;
}

void DeviceFamilyLinkAccountsAllowedProto::InternalSwap(DeviceFamilyLinkAccountsAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.family_link_accounts_allowed_, other->_impl_.family_link_accounts_allowed_);
}

std::string DeviceFamilyLinkAccountsAllowedProto::GetTypeName() const {
  return "enterprise_management.DeviceFamilyLinkAccountsAllowedProto";
}


// ===================================================================

class DeviceArcDataSnapshotHoursProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceArcDataSnapshotHoursProto>()._impl_._has_bits_);
  static void set_has_arc_data_snapshot_hours(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceArcDataSnapshotHoursProto::DeviceArcDataSnapshotHoursProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceArcDataSnapshotHoursProto)
}
DeviceArcDataSnapshotHoursProto::DeviceArcDataSnapshotHoursProto(const DeviceArcDataSnapshotHoursProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceArcDataSnapshotHoursProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.arc_data_snapshot_hours_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.arc_data_snapshot_hours_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.arc_data_snapshot_hours_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_arc_data_snapshot_hours()) {
    _this->_impl_.arc_data_snapshot_hours_.Set(from._internal_arc_data_snapshot_hours(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceArcDataSnapshotHoursProto)
}

inline void DeviceArcDataSnapshotHoursProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.arc_data_snapshot_hours_){}
  };
  _impl_.arc_data_snapshot_hours_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.arc_data_snapshot_hours_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceArcDataSnapshotHoursProto::~DeviceArcDataSnapshotHoursProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceArcDataSnapshotHoursProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceArcDataSnapshotHoursProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.arc_data_snapshot_hours_.Destroy();
}

void DeviceArcDataSnapshotHoursProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceArcDataSnapshotHoursProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceArcDataSnapshotHoursProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.arc_data_snapshot_hours_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceArcDataSnapshotHoursProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string arc_data_snapshot_hours = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_arc_data_snapshot_hours();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceArcDataSnapshotHoursProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceArcDataSnapshotHoursProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string arc_data_snapshot_hours = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_arc_data_snapshot_hours(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceArcDataSnapshotHoursProto)
  return target;
}

size_t DeviceArcDataSnapshotHoursProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceArcDataSnapshotHoursProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string arc_data_snapshot_hours = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_arc_data_snapshot_hours());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceArcDataSnapshotHoursProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceArcDataSnapshotHoursProto*>(
      &from));
}

void DeviceArcDataSnapshotHoursProto::MergeFrom(const DeviceArcDataSnapshotHoursProto& from) {
  DeviceArcDataSnapshotHoursProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceArcDataSnapshotHoursProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_arc_data_snapshot_hours()) {
    _this->_internal_set_arc_data_snapshot_hours(from._internal_arc_data_snapshot_hours());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceArcDataSnapshotHoursProto::CopyFrom(const DeviceArcDataSnapshotHoursProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceArcDataSnapshotHoursProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceArcDataSnapshotHoursProto::IsInitialized() const {
  return true;
}

void DeviceArcDataSnapshotHoursProto::InternalSwap(DeviceArcDataSnapshotHoursProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.arc_data_snapshot_hours_, lhs_arena,
      &other->_impl_.arc_data_snapshot_hours_, rhs_arena
  );
}

std::string DeviceArcDataSnapshotHoursProto::GetTypeName() const {
  return "enterprise_management.DeviceArcDataSnapshotHoursProto";
}


// ===================================================================

class DeviceSystemWideTracingEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceSystemWideTracingEnabledProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceSystemWideTracingEnabledProto::DeviceSystemWideTracingEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceSystemWideTracingEnabledProto)
}
DeviceSystemWideTracingEnabledProto::DeviceSystemWideTracingEnabledProto(const DeviceSystemWideTracingEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceSystemWideTracingEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceSystemWideTracingEnabledProto)
}

inline void DeviceSystemWideTracingEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceSystemWideTracingEnabledProto::~DeviceSystemWideTracingEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceSystemWideTracingEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceSystemWideTracingEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceSystemWideTracingEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceSystemWideTracingEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceSystemWideTracingEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceSystemWideTracingEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceSystemWideTracingEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceSystemWideTracingEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceSystemWideTracingEnabledProto)
  return target;
}

size_t DeviceSystemWideTracingEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceSystemWideTracingEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceSystemWideTracingEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceSystemWideTracingEnabledProto*>(
      &from));
}

void DeviceSystemWideTracingEnabledProto::MergeFrom(const DeviceSystemWideTracingEnabledProto& from) {
  DeviceSystemWideTracingEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceSystemWideTracingEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceSystemWideTracingEnabledProto::CopyFrom(const DeviceSystemWideTracingEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceSystemWideTracingEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceSystemWideTracingEnabledProto::IsInitialized() const {
  return true;
}

void DeviceSystemWideTracingEnabledProto::InternalSwap(DeviceSystemWideTracingEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceSystemWideTracingEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceSystemWideTracingEnabledProto";
}


// ===================================================================

class DevicePciPeripheralDataAccessEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePciPeripheralDataAccessEnabledProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DevicePciPeripheralDataAccessEnabledProto::DevicePciPeripheralDataAccessEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
}
DevicePciPeripheralDataAccessEnabledProto::DevicePciPeripheralDataAccessEnabledProto(const DevicePciPeripheralDataAccessEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePciPeripheralDataAccessEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
}

inline void DevicePciPeripheralDataAccessEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DevicePciPeripheralDataAccessEnabledProto::~DevicePciPeripheralDataAccessEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePciPeripheralDataAccessEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DevicePciPeripheralDataAccessEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePciPeripheralDataAccessEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePciPeripheralDataAccessEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePciPeripheralDataAccessEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
  return target;
}

size_t DevicePciPeripheralDataAccessEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePciPeripheralDataAccessEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePciPeripheralDataAccessEnabledProto*>(
      &from));
}

void DevicePciPeripheralDataAccessEnabledProto::MergeFrom(const DevicePciPeripheralDataAccessEnabledProto& from) {
  DevicePciPeripheralDataAccessEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePciPeripheralDataAccessEnabledProto::CopyFrom(const DevicePciPeripheralDataAccessEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePciPeripheralDataAccessEnabledProto::IsInitialized() const {
  return true;
}

void DevicePciPeripheralDataAccessEnabledProto::InternalSwap(DevicePciPeripheralDataAccessEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DevicePciPeripheralDataAccessEnabledProto::GetTypeName() const {
  return "enterprise_management.DevicePciPeripheralDataAccessEnabledProto";
}


// ===================================================================

class DevicePciPeripheralDataAccessEnabledProtoV2::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePciPeripheralDataAccessEnabledProtoV2>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DevicePciPeripheralDataAccessEnabledProtoV2::DevicePciPeripheralDataAccessEnabledProtoV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
}
DevicePciPeripheralDataAccessEnabledProtoV2::DevicePciPeripheralDataAccessEnabledProtoV2(const DevicePciPeripheralDataAccessEnabledProtoV2& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePciPeripheralDataAccessEnabledProtoV2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
}

inline void DevicePciPeripheralDataAccessEnabledProtoV2::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DevicePciPeripheralDataAccessEnabledProtoV2::~DevicePciPeripheralDataAccessEnabledProtoV2() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePciPeripheralDataAccessEnabledProtoV2::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DevicePciPeripheralDataAccessEnabledProtoV2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePciPeripheralDataAccessEnabledProtoV2::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePciPeripheralDataAccessEnabledProtoV2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePciPeripheralDataAccessEnabledProtoV2::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
  return target;
}

size_t DevicePciPeripheralDataAccessEnabledProtoV2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePciPeripheralDataAccessEnabledProtoV2::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePciPeripheralDataAccessEnabledProtoV2*>(
      &from));
}

void DevicePciPeripheralDataAccessEnabledProtoV2::MergeFrom(const DevicePciPeripheralDataAccessEnabledProtoV2& from) {
  DevicePciPeripheralDataAccessEnabledProtoV2* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePciPeripheralDataAccessEnabledProtoV2::CopyFrom(const DevicePciPeripheralDataAccessEnabledProtoV2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePciPeripheralDataAccessEnabledProtoV2::IsInitialized() const {
  return true;
}

void DevicePciPeripheralDataAccessEnabledProtoV2::InternalSwap(DevicePciPeripheralDataAccessEnabledProtoV2* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DevicePciPeripheralDataAccessEnabledProtoV2::GetTypeName() const {
  return "enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2";
}


// ===================================================================

class OBSOLETE_DeviceBorealisAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OBSOLETE_DeviceBorealisAllowedProto>()._impl_._has_bits_);
  static void set_has_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OBSOLETE_DeviceBorealisAllowedProto::OBSOLETE_DeviceBorealisAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
}
OBSOLETE_DeviceBorealisAllowedProto::OBSOLETE_DeviceBorealisAllowedProto(const OBSOLETE_DeviceBorealisAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OBSOLETE_DeviceBorealisAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.allowed_ = from._impl_.allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
}

inline void OBSOLETE_DeviceBorealisAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_){true}
  };
}

OBSOLETE_DeviceBorealisAllowedProto::~OBSOLETE_DeviceBorealisAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OBSOLETE_DeviceBorealisAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OBSOLETE_DeviceBorealisAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OBSOLETE_DeviceBorealisAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowed_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OBSOLETE_DeviceBorealisAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allowed = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allowed(&has_bits);
          _impl_.allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OBSOLETE_DeviceBorealisAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool allowed = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
  return target;
}

size_t OBSOLETE_DeviceBorealisAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool allowed = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBSOLETE_DeviceBorealisAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OBSOLETE_DeviceBorealisAllowedProto*>(
      &from));
}

void OBSOLETE_DeviceBorealisAllowedProto::MergeFrom(const OBSOLETE_DeviceBorealisAllowedProto& from) {
  OBSOLETE_DeviceBorealisAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_allowed()) {
    _this->_internal_set_allowed(from._internal_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OBSOLETE_DeviceBorealisAllowedProto::CopyFrom(const OBSOLETE_DeviceBorealisAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OBSOLETE_DeviceBorealisAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBSOLETE_DeviceBorealisAllowedProto::IsInitialized() const {
  return true;
}

void OBSOLETE_DeviceBorealisAllowedProto::InternalSwap(OBSOLETE_DeviceBorealisAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.allowed_, other->_impl_.allowed_);
}

std::string OBSOLETE_DeviceBorealisAllowedProto::GetTypeName() const {
  return "enterprise_management.OBSOLETE_DeviceBorealisAllowedProto";
}


// ===================================================================

class DeviceAllowedBluetoothServicesProto::_Internal {
 public:
};

DeviceAllowedBluetoothServicesProto::DeviceAllowedBluetoothServicesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAllowedBluetoothServicesProto)
}
DeviceAllowedBluetoothServicesProto::DeviceAllowedBluetoothServicesProto(const DeviceAllowedBluetoothServicesProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAllowedBluetoothServicesProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.allowlist_){from._impl_.allowlist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAllowedBluetoothServicesProto)
}

inline void DeviceAllowedBluetoothServicesProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.allowlist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceAllowedBluetoothServicesProto::~DeviceAllowedBluetoothServicesProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAllowedBluetoothServicesProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAllowedBluetoothServicesProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allowlist_.~RepeatedPtrField();
}

void DeviceAllowedBluetoothServicesProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAllowedBluetoothServicesProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAllowedBluetoothServicesProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowlist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAllowedBluetoothServicesProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string allowlist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allowlist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAllowedBluetoothServicesProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAllowedBluetoothServicesProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string allowlist = 1;
  for (int i = 0, n = this->_internal_allowlist_size(); i < n; i++) {
    const auto& s = this->_internal_allowlist(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAllowedBluetoothServicesProto)
  return target;
}

size_t DeviceAllowedBluetoothServicesProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAllowedBluetoothServicesProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string allowlist = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.allowlist_.size());
  for (int i = 0, n = _impl_.allowlist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.allowlist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAllowedBluetoothServicesProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAllowedBluetoothServicesProto*>(
      &from));
}

void DeviceAllowedBluetoothServicesProto::MergeFrom(const DeviceAllowedBluetoothServicesProto& from) {
  DeviceAllowedBluetoothServicesProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAllowedBluetoothServicesProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allowlist_.MergeFrom(from._impl_.allowlist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAllowedBluetoothServicesProto::CopyFrom(const DeviceAllowedBluetoothServicesProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAllowedBluetoothServicesProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAllowedBluetoothServicesProto::IsInitialized() const {
  return true;
}

void DeviceAllowedBluetoothServicesProto::InternalSwap(DeviceAllowedBluetoothServicesProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.allowlist_.InternalSwap(&other->_impl_.allowlist_);
}

std::string DeviceAllowedBluetoothServicesProto::GetTypeName() const {
  return "enterprise_management.DeviceAllowedBluetoothServicesProto";
}


// ===================================================================

class DeviceDebugPacketCaptureAllowedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceDebugPacketCaptureAllowedProto>()._impl_._has_bits_);
  static void set_has_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceDebugPacketCaptureAllowedProto::DeviceDebugPacketCaptureAllowedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
}
DeviceDebugPacketCaptureAllowedProto::DeviceDebugPacketCaptureAllowedProto(const DeviceDebugPacketCaptureAllowedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceDebugPacketCaptureAllowedProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.allowed_ = from._impl_.allowed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
}

inline void DeviceDebugPacketCaptureAllowedProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowed_){false}
  };
}

DeviceDebugPacketCaptureAllowedProto::~DeviceDebugPacketCaptureAllowedProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceDebugPacketCaptureAllowedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceDebugPacketCaptureAllowedProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceDebugPacketCaptureAllowedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allowed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceDebugPacketCaptureAllowedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allowed(&has_bits);
          _impl_.allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceDebugPacketCaptureAllowedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool allowed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allowed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
  return target;
}

size_t DeviceDebugPacketCaptureAllowedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool allowed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceDebugPacketCaptureAllowedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceDebugPacketCaptureAllowedProto*>(
      &from));
}

void DeviceDebugPacketCaptureAllowedProto::MergeFrom(const DeviceDebugPacketCaptureAllowedProto& from) {
  DeviceDebugPacketCaptureAllowedProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_allowed()) {
    _this->_internal_set_allowed(from._internal_allowed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceDebugPacketCaptureAllowedProto::CopyFrom(const DeviceDebugPacketCaptureAllowedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceDebugPacketCaptureAllowedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceDebugPacketCaptureAllowedProto::IsInitialized() const {
  return true;
}

void DeviceDebugPacketCaptureAllowedProto::InternalSwap(DeviceDebugPacketCaptureAllowedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.allowed_, other->_impl_.allowed_);
}

std::string DeviceDebugPacketCaptureAllowedProto::GetTypeName() const {
  return "enterprise_management.DeviceDebugPacketCaptureAllowedProto";
}


// ===================================================================

class DeviceScheduledRebootProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceScheduledRebootProto>()._impl_._has_bits_);
  static void set_has_device_scheduled_reboot_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceScheduledRebootProto::DeviceScheduledRebootProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceScheduledRebootProto)
}
DeviceScheduledRebootProto::DeviceScheduledRebootProto(const DeviceScheduledRebootProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceScheduledRebootProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_scheduled_reboot_settings_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_scheduled_reboot_settings_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_scheduled_reboot_settings_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_scheduled_reboot_settings()) {
    _this->_impl_.device_scheduled_reboot_settings_.Set(from._internal_device_scheduled_reboot_settings(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceScheduledRebootProto)
}

inline void DeviceScheduledRebootProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_scheduled_reboot_settings_){}
  };
  _impl_.device_scheduled_reboot_settings_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_scheduled_reboot_settings_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceScheduledRebootProto::~DeviceScheduledRebootProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceScheduledRebootProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceScheduledRebootProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_scheduled_reboot_settings_.Destroy();
}

void DeviceScheduledRebootProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceScheduledRebootProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceScheduledRebootProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.device_scheduled_reboot_settings_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceScheduledRebootProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_scheduled_reboot_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_scheduled_reboot_settings();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceScheduledRebootProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceScheduledRebootProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_scheduled_reboot_settings = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_scheduled_reboot_settings(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceScheduledRebootProto)
  return target;
}

size_t DeviceScheduledRebootProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceScheduledRebootProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_scheduled_reboot_settings = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_scheduled_reboot_settings());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceScheduledRebootProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceScheduledRebootProto*>(
      &from));
}

void DeviceScheduledRebootProto::MergeFrom(const DeviceScheduledRebootProto& from) {
  DeviceScheduledRebootProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceScheduledRebootProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_scheduled_reboot_settings()) {
    _this->_internal_set_device_scheduled_reboot_settings(from._internal_device_scheduled_reboot_settings());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceScheduledRebootProto::CopyFrom(const DeviceScheduledRebootProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceScheduledRebootProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceScheduledRebootProto::IsInitialized() const {
  return true;
}

void DeviceScheduledRebootProto::InternalSwap(DeviceScheduledRebootProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_scheduled_reboot_settings_, lhs_arena,
      &other->_impl_.device_scheduled_reboot_settings_, rhs_arena
  );
}

std::string DeviceScheduledRebootProto::GetTypeName() const {
  return "enterprise_management.DeviceScheduledRebootProto";
}


// ===================================================================

class DeviceRestrictedManagedGuestSessionEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceRestrictedManagedGuestSessionEnabledProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceRestrictedManagedGuestSessionEnabledProto::DeviceRestrictedManagedGuestSessionEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
}
DeviceRestrictedManagedGuestSessionEnabledProto::DeviceRestrictedManagedGuestSessionEnabledProto(const DeviceRestrictedManagedGuestSessionEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceRestrictedManagedGuestSessionEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
}

inline void DeviceRestrictedManagedGuestSessionEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceRestrictedManagedGuestSessionEnabledProto::~DeviceRestrictedManagedGuestSessionEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceRestrictedManagedGuestSessionEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceRestrictedManagedGuestSessionEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceRestrictedManagedGuestSessionEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceRestrictedManagedGuestSessionEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceRestrictedManagedGuestSessionEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
  return target;
}

size_t DeviceRestrictedManagedGuestSessionEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceRestrictedManagedGuestSessionEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceRestrictedManagedGuestSessionEnabledProto*>(
      &from));
}

void DeviceRestrictedManagedGuestSessionEnabledProto::MergeFrom(const DeviceRestrictedManagedGuestSessionEnabledProto& from) {
  DeviceRestrictedManagedGuestSessionEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceRestrictedManagedGuestSessionEnabledProto::CopyFrom(const DeviceRestrictedManagedGuestSessionEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRestrictedManagedGuestSessionEnabledProto::IsInitialized() const {
  return true;
}

void DeviceRestrictedManagedGuestSessionEnabledProto::InternalSwap(DeviceRestrictedManagedGuestSessionEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceRestrictedManagedGuestSessionEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto";
}


// ===================================================================

class DeviceI18nShortcutsEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceI18nShortcutsEnabledProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceI18nShortcutsEnabledProto::DeviceI18nShortcutsEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceI18nShortcutsEnabledProto)
}
DeviceI18nShortcutsEnabledProto::DeviceI18nShortcutsEnabledProto(const DeviceI18nShortcutsEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceI18nShortcutsEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceI18nShortcutsEnabledProto)
}

inline void DeviceI18nShortcutsEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){true}
  };
}

DeviceI18nShortcutsEnabledProto::~DeviceI18nShortcutsEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceI18nShortcutsEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceI18nShortcutsEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceI18nShortcutsEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceI18nShortcutsEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceI18nShortcutsEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceI18nShortcutsEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceI18nShortcutsEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceI18nShortcutsEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceI18nShortcutsEnabledProto)
  return target;
}

size_t DeviceI18nShortcutsEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceI18nShortcutsEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceI18nShortcutsEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceI18nShortcutsEnabledProto*>(
      &from));
}

void DeviceI18nShortcutsEnabledProto::MergeFrom(const DeviceI18nShortcutsEnabledProto& from) {
  DeviceI18nShortcutsEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceI18nShortcutsEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceI18nShortcutsEnabledProto::CopyFrom(const DeviceI18nShortcutsEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceI18nShortcutsEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceI18nShortcutsEnabledProto::IsInitialized() const {
  return true;
}

void DeviceI18nShortcutsEnabledProto::InternalSwap(DeviceI18nShortcutsEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceI18nShortcutsEnabledProto::GetTypeName() const {
  return "enterprise_management.DeviceI18nShortcutsEnabledProto";
}


// ===================================================================

class RevenDeviceHWDataUsageEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<RevenDeviceHWDataUsageEnabledProto>()._impl_._has_bits_);
  static void set_has_hardware_data_usage_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RevenDeviceHWDataUsageEnabledProto::RevenDeviceHWDataUsageEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
}
RevenDeviceHWDataUsageEnabledProto::RevenDeviceHWDataUsageEnabledProto(const RevenDeviceHWDataUsageEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RevenDeviceHWDataUsageEnabledProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hardware_data_usage_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.hardware_data_usage_enabled_ = from._impl_.hardware_data_usage_enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
}

inline void RevenDeviceHWDataUsageEnabledProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hardware_data_usage_enabled_){false}
  };
}

RevenDeviceHWDataUsageEnabledProto::~RevenDeviceHWDataUsageEnabledProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RevenDeviceHWDataUsageEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RevenDeviceHWDataUsageEnabledProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RevenDeviceHWDataUsageEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hardware_data_usage_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RevenDeviceHWDataUsageEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool hardware_data_usage_enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hardware_data_usage_enabled(&has_bits);
          _impl_.hardware_data_usage_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RevenDeviceHWDataUsageEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool hardware_data_usage_enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_hardware_data_usage_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
  return target;
}

size_t RevenDeviceHWDataUsageEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool hardware_data_usage_enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RevenDeviceHWDataUsageEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RevenDeviceHWDataUsageEnabledProto*>(
      &from));
}

void RevenDeviceHWDataUsageEnabledProto::MergeFrom(const RevenDeviceHWDataUsageEnabledProto& from) {
  RevenDeviceHWDataUsageEnabledProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hardware_data_usage_enabled()) {
    _this->_internal_set_hardware_data_usage_enabled(from._internal_hardware_data_usage_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RevenDeviceHWDataUsageEnabledProto::CopyFrom(const RevenDeviceHWDataUsageEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RevenDeviceHWDataUsageEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RevenDeviceHWDataUsageEnabledProto::IsInitialized() const {
  return true;
}

void RevenDeviceHWDataUsageEnabledProto::InternalSwap(RevenDeviceHWDataUsageEnabledProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.hardware_data_usage_enabled_, other->_impl_.hardware_data_usage_enabled_);
}

std::string RevenDeviceHWDataUsageEnabledProto::GetTypeName() const {
  return "enterprise_management.RevenDeviceHWDataUsageEnabledProto";
}


// ===================================================================

class DeviceLoginScreenWebUILazyLoadingProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceLoginScreenWebUILazyLoadingProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceLoginScreenWebUILazyLoadingProto::DeviceLoginScreenWebUILazyLoadingProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
}
DeviceLoginScreenWebUILazyLoadingProto::DeviceLoginScreenWebUILazyLoadingProto(const DeviceLoginScreenWebUILazyLoadingProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceLoginScreenWebUILazyLoadingProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
}

inline void DeviceLoginScreenWebUILazyLoadingProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceLoginScreenWebUILazyLoadingProto::~DeviceLoginScreenWebUILazyLoadingProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLoginScreenWebUILazyLoadingProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceLoginScreenWebUILazyLoadingProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLoginScreenWebUILazyLoadingProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceLoginScreenWebUILazyLoadingProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLoginScreenWebUILazyLoadingProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
  return target;
}

size_t DeviceLoginScreenWebUILazyLoadingProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceLoginScreenWebUILazyLoadingProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceLoginScreenWebUILazyLoadingProto*>(
      &from));
}

void DeviceLoginScreenWebUILazyLoadingProto::MergeFrom(const DeviceLoginScreenWebUILazyLoadingProto& from) {
  DeviceLoginScreenWebUILazyLoadingProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceLoginScreenWebUILazyLoadingProto::CopyFrom(const DeviceLoginScreenWebUILazyLoadingProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceLoginScreenWebUILazyLoadingProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLoginScreenWebUILazyLoadingProto::IsInitialized() const {
  return true;
}

void DeviceLoginScreenWebUILazyLoadingProto::InternalSwap(DeviceLoginScreenWebUILazyLoadingProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceLoginScreenWebUILazyLoadingProto::GetTypeName() const {
  return "enterprise_management.DeviceLoginScreenWebUILazyLoadingProto";
}


// ===================================================================

class EncryptedReportingPipelineConfigurationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<EncryptedReportingPipelineConfigurationProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EncryptedReportingPipelineConfigurationProto::EncryptedReportingPipelineConfigurationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.EncryptedReportingPipelineConfigurationProto)
}
EncryptedReportingPipelineConfigurationProto::EncryptedReportingPipelineConfigurationProto(const EncryptedReportingPipelineConfigurationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EncryptedReportingPipelineConfigurationProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.EncryptedReportingPipelineConfigurationProto)
}

inline void EncryptedReportingPipelineConfigurationProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){true}
  };
}

EncryptedReportingPipelineConfigurationProto::~EncryptedReportingPipelineConfigurationProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.EncryptedReportingPipelineConfigurationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EncryptedReportingPipelineConfigurationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EncryptedReportingPipelineConfigurationProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EncryptedReportingPipelineConfigurationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.EncryptedReportingPipelineConfigurationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EncryptedReportingPipelineConfigurationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EncryptedReportingPipelineConfigurationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.EncryptedReportingPipelineConfigurationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.EncryptedReportingPipelineConfigurationProto)
  return target;
}

size_t EncryptedReportingPipelineConfigurationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.EncryptedReportingPipelineConfigurationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EncryptedReportingPipelineConfigurationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EncryptedReportingPipelineConfigurationProto*>(
      &from));
}

void EncryptedReportingPipelineConfigurationProto::MergeFrom(const EncryptedReportingPipelineConfigurationProto& from) {
  EncryptedReportingPipelineConfigurationProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.EncryptedReportingPipelineConfigurationProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EncryptedReportingPipelineConfigurationProto::CopyFrom(const EncryptedReportingPipelineConfigurationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.EncryptedReportingPipelineConfigurationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptedReportingPipelineConfigurationProto::IsInitialized() const {
  return true;
}

void EncryptedReportingPipelineConfigurationProto::InternalSwap(EncryptedReportingPipelineConfigurationProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string EncryptedReportingPipelineConfigurationProto::GetTypeName() const {
  return "enterprise_management.EncryptedReportingPipelineConfigurationProto";
}


// ===================================================================

class DeviceReportXDREventsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceReportXDREventsProto>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceReportXDREventsProto::DeviceReportXDREventsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceReportXDREventsProto)
}
DeviceReportXDREventsProto::DeviceReportXDREventsProto(const DeviceReportXDREventsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceReportXDREventsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceReportXDREventsProto)
}

inline void DeviceReportXDREventsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

DeviceReportXDREventsProto::~DeviceReportXDREventsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceReportXDREventsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceReportXDREventsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceReportXDREventsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceReportXDREventsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceReportXDREventsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceReportXDREventsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceReportXDREventsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceReportXDREventsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceReportXDREventsProto)
  return target;
}

size_t DeviceReportXDREventsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceReportXDREventsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceReportXDREventsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceReportXDREventsProto*>(
      &from));
}

void DeviceReportXDREventsProto::MergeFrom(const DeviceReportXDREventsProto& from) {
  DeviceReportXDREventsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceReportXDREventsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceReportXDREventsProto::CopyFrom(const DeviceReportXDREventsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceReportXDREventsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceReportXDREventsProto::IsInitialized() const {
  return true;
}

void DeviceReportXDREventsProto::InternalSwap(DeviceReportXDREventsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string DeviceReportXDREventsProto::GetTypeName() const {
  return "enterprise_management.DeviceReportXDREventsProto";
}


// ===================================================================

class ChromeDeviceSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeDeviceSettingsProto>()._impl_._has_bits_);
  static const ::enterprise_management::DevicePolicyRefreshRateProto& device_policy_refresh_rate(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_policy_refresh_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::UserWhitelistProto& user_whitelist(const ChromeDeviceSettingsProto* msg);
  static void set_has_user_whitelist(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_management::GuestModeEnabledProto& guest_mode_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_guest_mode_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::OBSOLETE_DeviceProxySettingsProto& device_proxy_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_proxy_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::enterprise_management::CameraEnabledProto& camera_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_camera_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::enterprise_management::ShowUserNamesOnSigninProto& show_user_names(const ChromeDeviceSettingsProto* msg);
  static void set_has_show_user_names(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::enterprise_management::DataRoamingEnabledProto& data_roaming_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_data_roaming_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::enterprise_management::AllowNewUsersProto& allow_new_users(const ChromeDeviceSettingsProto* msg);
  static void set_has_allow_new_users(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::enterprise_management::MetricsEnabledProto& metrics_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_metrics_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::enterprise_management::ReleaseChannelProto& release_channel(const ChromeDeviceSettingsProto* msg);
  static void set_has_release_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::enterprise_management::DeviceOpenNetworkConfigurationProto& open_network_configuration(const ChromeDeviceSettingsProto* msg);
  static void set_has_open_network_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::enterprise_management::DeviceReportingProto& device_reporting(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_reporting(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::enterprise_management::EphemeralUsersEnabledProto& ephemeral_users_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_ephemeral_users_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::enterprise_management::OBSOLETE_AppPackProto& app_pack(const ChromeDeviceSettingsProto* msg);
  static void set_has_app_pack(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto& forced_logout_timeouts(const ChromeDeviceSettingsProto* msg);
  static void set_has_forced_logout_timeouts(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::enterprise_management::OBSOLETE_ScreenSaverProto& login_screen_saver(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_screen_saver(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::enterprise_management::AutoUpdateSettingsProto& auto_update_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_auto_update_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::enterprise_management::OBSOLETE_StartUpUrlsProto& start_up_urls(const ChromeDeviceSettingsProto* msg);
  static void set_has_start_up_urls(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::enterprise_management::OBSOLETE_PinnedAppsProto& pinned_apps(const ChromeDeviceSettingsProto* msg);
  static void set_has_pinned_apps(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::enterprise_management::SystemTimezoneProto& system_timezone(const ChromeDeviceSettingsProto* msg);
  static void set_has_system_timezone(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::enterprise_management::DeviceLocalAccountsProto& device_local_accounts(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_local_accounts(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto& allow_redeem_offers(const ChromeDeviceSettingsProto* msg);
  static void set_has_allow_redeem_offers(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::enterprise_management::FeatureFlagsProto& feature_flags(const ChromeDeviceSettingsProto* msg);
  static void set_has_feature_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::enterprise_management::UptimeLimitProto& uptime_limit(const ChromeDeviceSettingsProto* msg);
  static void set_has_uptime_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::enterprise_management::VariationsParameterProto& variations_parameter(const ChromeDeviceSettingsProto* msg);
  static void set_has_variations_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::enterprise_management::AttestationSettingsProto& attestation_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_attestation_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::enterprise_management::AccessibilitySettingsProto& accessibility_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_accessibility_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto& supervised_users_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_supervised_users_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::enterprise_management::LoginScreenPowerManagementProto& login_screen_power_management(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_screen_power_management(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::enterprise_management::SystemUse24HourClockProto& use_24hour_clock(const ChromeDeviceSettingsProto* msg);
  static void set_has_use_24hour_clock(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::enterprise_management::AutoCleanupSettigsProto& auto_clean_up_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_auto_clean_up_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::enterprise_management::SystemSettingsProto& system_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_system_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::enterprise_management::SAMLSettingsProto& saml_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_saml_settings(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::enterprise_management::RebootOnShutdownProto& reboot_on_shutdown(const ChromeDeviceSettingsProto* msg);
  static void set_has_reboot_on_shutdown(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::enterprise_management::DeviceHeartbeatSettingsProto& device_heartbeat_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_heartbeat_settings(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::enterprise_management::ExtensionCacheSizeProto& extension_cache_size(const ChromeDeviceSettingsProto* msg);
  static void set_has_extension_cache_size(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static const ::enterprise_management::LoginScreenDomainAutoCompleteProto& login_screen_domain_auto_complete(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_screen_domain_auto_complete(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static const ::enterprise_management::DeviceLogUploadSettingsProto& device_log_upload_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_log_upload_settings(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static const ::enterprise_management::DisplayRotationDefaultProto& display_rotation_default(const ChromeDeviceSettingsProto* msg);
  static void set_has_display_rotation_default(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static const ::enterprise_management::AllowKioskAppControlChromeVersionProto& allow_kiosk_app_control_chrome_version(const ChromeDeviceSettingsProto* msg);
  static void set_has_allow_kiosk_app_control_chrome_version(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static const ::enterprise_management::LoginAuthenticationBehaviorProto& login_authentication_behavior(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_authentication_behavior(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static const ::enterprise_management::UsbDetachableWhitelistProto& usb_detachable_whitelist(const ChromeDeviceSettingsProto* msg);
  static void set_has_usb_detachable_whitelist(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static const ::enterprise_management::AllowBluetoothProto& allow_bluetooth(const ChromeDeviceSettingsProto* msg);
  static void set_has_allow_bluetooth(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static const ::enterprise_management::DeviceQuirksDownloadEnabledProto& quirks_download_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_quirks_download_enabled(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static const ::enterprise_management::LoginVideoCaptureAllowedUrlsProto& login_video_capture_allowed_urls(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_video_capture_allowed_urls(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static const ::enterprise_management::DeviceLoginScreenExtensionsProto& device_login_screen_extensions(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_login_screen_extensions(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static const ::enterprise_management::NetworkThrottlingEnabledProto& network_throttling(const ChromeDeviceSettingsProto* msg);
  static void set_has_network_throttling(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static const ::enterprise_management::DeviceWallpaperImageProto& device_wallpaper_image(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_wallpaper_image(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static const ::enterprise_management::LoginScreenLocalesProto& login_screen_locales(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_screen_locales(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static const ::enterprise_management::LoginScreenInputMethodsProto& login_screen_input_methods(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_screen_input_methods(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static const ::enterprise_management::DeviceEcryptfsMigrationStrategyProto& device_ecryptfs_migration_strategy(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_ecryptfs_migration_strategy(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static const ::enterprise_management::DeviceSecondFactorAuthenticationProto& device_second_factor_authentication(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_second_factor_authentication(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static const ::enterprise_management::CastReceiverNameProto& cast_receiver_name(const ChromeDeviceSettingsProto* msg);
  static void set_has_cast_receiver_name(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static const ::enterprise_management::DeviceOffHoursProto& device_off_hours(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_off_hours(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static const ::enterprise_management::DeviceNativePrintersProto& native_device_printers(const ChromeDeviceSettingsProto* msg);
  static void set_has_native_device_printers(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static const ::enterprise_management::DeviceNativePrintersAccessModeProto& native_device_printers_access_mode(const ChromeDeviceSettingsProto* msg);
  static void set_has_native_device_printers_access_mode(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static const ::enterprise_management::DeviceNativePrintersBlacklistProto& native_device_printers_blacklist(const ChromeDeviceSettingsProto* msg);
  static void set_has_native_device_printers_blacklist(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static const ::enterprise_management::DeviceNativePrintersWhitelistProto& native_device_printers_whitelist(const ChromeDeviceSettingsProto* msg);
  static void set_has_native_device_printers_whitelist(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static const ::enterprise_management::TPMFirmwareUpdateSettingsProto& tpm_firmware_update_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_tpm_firmware_update_settings(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static const ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto& minimum_required_version(const ChromeDeviceSettingsProto* msg);
  static void set_has_minimum_required_version(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static const ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls& device_login_screen_auto_select_certificate_for_urls(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_login_screen_auto_select_certificate_for_urls(HasBits* has_bits) {
    (*has_bits)[1] |= 268435456u;
  }
  static const ::enterprise_management::UnaffiliatedArcAllowedProto& unaffiliated_arc_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_unaffiliated_arc_allowed(HasBits* has_bits) {
    (*has_bits)[1] |= 536870912u;
  }
  static const ::enterprise_management::NetworkHostnameProto& network_hostname(const ChromeDeviceSettingsProto* msg);
  static void set_has_network_hostname(HasBits* has_bits) {
    (*has_bits)[1] |= 1073741824u;
  }
  static const ::enterprise_management::DeviceKerberosEncryptionTypesProto& device_kerberos_encryption_types(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_kerberos_encryption_types(HasBits* has_bits) {
    (*has_bits)[1] |= 2147483648u;
  }
  static const ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto& device_user_policy_loopback_processing_mode(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_user_policy_loopback_processing_mode(HasBits* has_bits) {
    (*has_bits)[2] |= 1u;
  }
  static const ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto& device_login_screen_isolate_origins(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_login_screen_isolate_origins(HasBits* has_bits) {
    (*has_bits)[2] |= 2u;
  }
  static const ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto& device_login_screen_site_per_process(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_login_screen_site_per_process(HasBits* has_bits) {
    (*has_bits)[2] |= 4u;
  }
  static const ::enterprise_management::VirtualMachinesAllowedProto& virtual_machines_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_virtual_machines_allowed(HasBits* has_bits) {
    (*has_bits)[2] |= 8u;
  }
  static const ::enterprise_management::DeviceMachinePasswordChangeRateProto& device_machine_password_change_rate(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_machine_password_change_rate(HasBits* has_bits) {
    (*has_bits)[2] |= 16u;
  }
  static const ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto& device_unaffiliated_crostini_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_unaffiliated_crostini_allowed(HasBits* has_bits) {
    (*has_bits)[2] |= 32u;
  }
  static const ::enterprise_management::DeviceWiFiFastTransitionEnabledProto& device_wifi_fast_transition_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_wifi_fast_transition_enabled(HasBits* has_bits) {
    (*has_bits)[2] |= 64u;
  }
  static const ::enterprise_management::DeviceDisplayResolutionProto& device_display_resolution(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_display_resolution(HasBits* has_bits) {
    (*has_bits)[2] |= 128u;
  }
  static const ::enterprise_management::PluginVmAllowedProto& plugin_vm_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_plugin_vm_allowed(HasBits* has_bits) {
    (*has_bits)[2] |= 256u;
  }
  static const ::enterprise_management::DeviceGpoCacheLifetimeProto& device_gpo_cache_lifetime(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_gpo_cache_lifetime(HasBits* has_bits) {
    (*has_bits)[2] |= 512u;
  }
  static const ::enterprise_management::DeviceAuthDataCacheLifetimeProto& device_auth_data_cache_lifetime(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_auth_data_cache_lifetime(HasBits* has_bits) {
    (*has_bits)[2] |= 1024u;
  }
  static const ::enterprise_management::PluginVmLicenseKeyProto& plugin_vm_license_key(const ChromeDeviceSettingsProto* msg);
  static void set_has_plugin_vm_license_key(HasBits* has_bits) {
    (*has_bits)[2] |= 2048u;
  }
  static const ::enterprise_management::DeviceRebootOnUserSignoutProto& device_reboot_on_user_signout(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_reboot_on_user_signout(HasBits* has_bits) {
    (*has_bits)[2] |= 4096u;
  }
  static const ::enterprise_management::DeviceWilcoDtcAllowedProto& device_wilco_dtc_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_wilco_dtc_allowed(HasBits* has_bits) {
    (*has_bits)[2] |= 8192u;
  }
  static const ::enterprise_management::DeviceWilcoDtcConfigurationProto& device_wilco_dtc_configuration(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_wilco_dtc_configuration(HasBits* has_bits) {
    (*has_bits)[2] |= 16384u;
  }
  static const ::enterprise_management::DeviceWiFiAllowedProto& device_wifi_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_wifi_allowed(HasBits* has_bits) {
    (*has_bits)[2] |= 32768u;
  }
  static const ::enterprise_management::DevicePowerPeakShiftProto& device_power_peak_shift(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_power_peak_shift(HasBits* has_bits) {
    (*has_bits)[2] |= 65536u;
  }
  static const ::enterprise_management::DeviceBootOnAcProto& device_boot_on_ac(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_boot_on_ac(HasBits* has_bits) {
    (*has_bits)[2] |= 131072u;
  }
  static const ::enterprise_management::DeviceDockMacAddressSourceProto& device_dock_mac_address_source(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_dock_mac_address_source(HasBits* has_bits) {
    (*has_bits)[2] |= 262144u;
  }
  static const ::enterprise_management::DeviceAdvancedBatteryChargeModeProto& device_advanced_battery_charge_mode(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_advanced_battery_charge_mode(HasBits* has_bits) {
    (*has_bits)[2] |= 524288u;
  }
  static const ::enterprise_management::DeviceBatteryChargeModeProto& device_battery_charge_mode(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_battery_charge_mode(HasBits* has_bits) {
    (*has_bits)[2] |= 1048576u;
  }
  static const ::enterprise_management::DeviceUsbPowerShareProto& device_usb_power_share(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_usb_power_share(HasBits* has_bits) {
    (*has_bits)[2] |= 2097152u;
  }
  static const ::enterprise_management::DeviceScheduledUpdateCheckProto& device_scheduled_update_check(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_scheduled_update_check(HasBits* has_bits) {
    (*has_bits)[2] |= 4194304u;
  }
  static const ::enterprise_management::DevicePowerwashAllowedProto& device_powerwash_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_powerwash_allowed(HasBits* has_bits) {
    (*has_bits)[2] |= 8388608u;
  }
  static const ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto& device_login_screen_webusb_allow_devices_for_urls(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_login_screen_webusb_allow_devices_for_urls(HasBits* has_bits) {
    (*has_bits)[2] |= 16777216u;
  }
  static const ::enterprise_management::BooleanPolicyProto& device_login_screen_system_info_enforced(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_login_screen_system_info_enforced(HasBits* has_bits) {
    (*has_bits)[2] |= 33554432u;
  }
  static const ::enterprise_management::StringListPolicyProto& device_web_based_attestation_allowed_urls(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_web_based_attestation_allowed_urls(HasBits* has_bits) {
    (*has_bits)[2] |= 67108864u;
  }
  static const ::enterprise_management::BooleanPolicyProto& device_show_numeric_keyboard_for_password(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_show_numeric_keyboard_for_password(HasBits* has_bits) {
    (*has_bits)[2] |= 134217728u;
  }
  static const ::enterprise_management::BooleanPolicyProto& login_screen_primary_mouse_button_switch(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_screen_primary_mouse_button_switch(HasBits* has_bits) {
    (*has_bits)[2] |= 268435456u;
  }
  static const ::enterprise_management::StringPolicyProto& device_minimum_version(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_minimum_version(HasBits* has_bits) {
    (*has_bits)[2] |= 536870912u;
  }
  static const ::enterprise_management::SystemProxySettingsProto& system_proxy_settings(const ChromeDeviceSettingsProto* msg);
  static void set_has_system_proxy_settings(HasBits* has_bits) {
    (*has_bits)[2] |= 1073741824u;
  }
  static const ::enterprise_management::IntegerPolicyProto& device_chrome_variations_type(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_chrome_variations_type(HasBits* has_bits) {
    (*has_bits)[2] |= 2147483648u;
  }
  static const ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto& device_login_screen_privacy_screen_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_login_screen_privacy_screen_enabled(HasBits* has_bits) {
    (*has_bits)[3] |= 1u;
  }
  static const ::enterprise_management::RequiredClientCertificateForDeviceProto& required_client_certificate_for_device(const ChromeDeviceSettingsProto* msg);
  static void set_has_required_client_certificate_for_device(HasBits* has_bits) {
    (*has_bits)[3] |= 2u;
  }
  static const ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto& device_crostini_arc_adb_sideloading_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_crostini_arc_adb_sideloading_allowed(HasBits* has_bits) {
    (*has_bits)[3] |= 4u;
  }
  static const ::enterprise_management::StringPolicyProto& device_minimum_version_aue_message(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_minimum_version_aue_message(HasBits* has_bits) {
    (*has_bits)[3] |= 8u;
  }
  static const ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto& managed_guest_session_privacy_warnings(const ChromeDeviceSettingsProto* msg);
  static void set_has_managed_guest_session_privacy_warnings(HasBits* has_bits) {
    (*has_bits)[3] |= 16u;
  }
  static const ::enterprise_management::DeviceExternalPrintServersProto& external_print_servers(const ChromeDeviceSettingsProto* msg);
  static void set_has_external_print_servers(HasBits* has_bits) {
    (*has_bits)[3] |= 32u;
  }
  static const ::enterprise_management::DeviceExternalPrintServersAllowlistProto& external_print_servers_allowlist(const ChromeDeviceSettingsProto* msg);
  static void set_has_external_print_servers_allowlist(HasBits* has_bits) {
    (*has_bits)[3] |= 64u;
  }
  static const ::enterprise_management::DevicePrintersAccessModeProto& device_printers_access_mode(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_printers_access_mode(HasBits* has_bits) {
    (*has_bits)[3] |= 128u;
  }
  static const ::enterprise_management::DevicePrintersBlocklistProto& device_printers_blocklist(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_printers_blocklist(HasBits* has_bits) {
    (*has_bits)[3] |= 256u;
  }
  static const ::enterprise_management::DevicePrintersAllowlistProto& device_printers_allowlist(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_printers_allowlist(HasBits* has_bits) {
    (*has_bits)[3] |= 512u;
  }
  static const ::enterprise_management::DevicePrintersProto& device_printers(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_printers(HasBits* has_bits) {
    (*has_bits)[3] |= 1024u;
  }
  static const ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto& device_show_low_disk_space_notification(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_show_low_disk_space_notification(HasBits* has_bits) {
    (*has_bits)[3] |= 2048u;
  }
  static const ::enterprise_management::UserAllowlistProto& user_allowlist(const ChromeDeviceSettingsProto* msg);
  static void set_has_user_allowlist(HasBits* has_bits) {
    (*has_bits)[3] |= 4096u;
  }
  static const ::enterprise_management::UsbDetachableAllowlistProto& usb_detachable_allowlist(const ChromeDeviceSettingsProto* msg);
  static void set_has_usb_detachable_allowlist(HasBits* has_bits) {
    (*has_bits)[3] |= 8192u;
  }
  static const ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto& family_link_accounts_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_family_link_accounts_allowed(HasBits* has_bits) {
    (*has_bits)[3] |= 16384u;
  }
  static const ::enterprise_management::DeviceArcDataSnapshotHoursProto& arc_data_snapshot_hours(const ChromeDeviceSettingsProto* msg);
  static void set_has_arc_data_snapshot_hours(HasBits* has_bits) {
    (*has_bits)[3] |= 32768u;
  }
  static const ::enterprise_management::BooleanPolicyProto& device_allow_mgs_to_store_display_properties(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_allow_mgs_to_store_display_properties(HasBits* has_bits) {
    (*has_bits)[3] |= 65536u;
  }
  static const ::enterprise_management::DeviceSystemWideTracingEnabledProto& device_system_wide_tracing_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_system_wide_tracing_enabled(HasBits* has_bits) {
    (*has_bits)[3] |= 131072u;
  }
  static const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto& device_pci_peripheral_data_access_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_pci_peripheral_data_access_enabled(HasBits* has_bits) {
    (*has_bits)[3] |= 262144u;
  }
  static const ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto& device_borealis_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_borealis_allowed(HasBits* has_bits) {
    (*has_bits)[3] |= 524288u;
  }
  static const ::enterprise_management::DeviceAllowedBluetoothServicesProto& device_allowed_bluetooth_services(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_allowed_bluetooth_services(HasBits* has_bits) {
    (*has_bits)[3] |= 1048576u;
  }
  static const ::enterprise_management::DeviceDebugPacketCaptureAllowedProto& device_debug_packet_capture_allowed(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_debug_packet_capture_allowed(HasBits* has_bits) {
    (*has_bits)[3] |= 2097152u;
  }
  static const ::enterprise_management::DeviceScheduledRebootProto& device_scheduled_reboot(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_scheduled_reboot(HasBits* has_bits) {
    (*has_bits)[3] |= 4194304u;
  }
  static const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2& device_pci_peripheral_data_access_enabled_v2(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_pci_peripheral_data_access_enabled_v2(HasBits* has_bits) {
    (*has_bits)[3] |= 8388608u;
  }
  static const ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto& device_restricted_managed_guest_session_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_restricted_managed_guest_session_enabled(HasBits* has_bits) {
    (*has_bits)[3] |= 16777216u;
  }
  static const ::enterprise_management::HostnameUserConfigurableProto& hostname_user_configurable(const ChromeDeviceSettingsProto* msg);
  static void set_has_hostname_user_configurable(HasBits* has_bits) {
    (*has_bits)[3] |= 33554432u;
  }
  static const ::enterprise_management::BooleanPolicyProto& login_screen_prompt_on_multiple_matching_certificates(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_screen_prompt_on_multiple_matching_certificates(HasBits* has_bits) {
    (*has_bits)[3] |= 67108864u;
  }
  static const ::enterprise_management::BooleanPolicyProto& kiosk_crx_manifest_update_url_ignored(const ChromeDeviceSettingsProto* msg);
  static void set_has_kiosk_crx_manifest_update_url_ignored(HasBits* has_bits) {
    (*has_bits)[3] |= 134217728u;
  }
  static const ::enterprise_management::DeviceI18nShortcutsEnabledProto& device_i18n_shortcuts_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_i18n_shortcuts_enabled(HasBits* has_bits) {
    (*has_bits)[3] |= 268435456u;
  }
  static const ::enterprise_management::BooleanPolicyProto& chromad_to_cloud_migration_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_chromad_to_cloud_migration_enabled(HasBits* has_bits) {
    (*has_bits)[3] |= 536870912u;
  }
  static const ::enterprise_management::RevenDeviceHWDataUsageEnabledProto& hardware_data_usage_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_hardware_data_usage_enabled(HasBits* has_bits) {
    (*has_bits)[3] |= 1073741824u;
  }
  static const ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto& login_web_ui_lazy_loading(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_web_ui_lazy_loading(HasBits* has_bits) {
    (*has_bits)[3] |= 2147483648u;
  }
  static const ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto& keylocker_for_storage_encryption_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_keylocker_for_storage_encryption_enabled(HasBits* has_bits) {
    (*has_bits)[4] |= 1u;
  }
  static const ::enterprise_management::BooleanPolicyProto& device_run_automatic_cleanup_on_login(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_run_automatic_cleanup_on_login(HasBits* has_bits) {
    (*has_bits)[4] |= 2u;
  }
  static const ::enterprise_management::EncryptedReportingPipelineConfigurationProto& device_encrypted_reporting_pipeline_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_encrypted_reporting_pipeline_enabled(HasBits* has_bits) {
    (*has_bits)[4] |= 4u;
  }
  static const ::enterprise_management::SAMLUsernameProto& saml_username(const ChromeDeviceSettingsProto* msg);
  static void set_has_saml_username(HasBits* has_bits) {
    (*has_bits)[4] |= 8u;
  }
  static const ::enterprise_management::StringListPolicyProto& device_login_screen_context_aware_access_signals_allowlist(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_login_screen_context_aware_access_signals_allowlist(HasBits* has_bits) {
    (*has_bits)[4] |= 16u;
  }
  static const ::enterprise_management::StringPolicyProto& device_printing_client_name_template(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_printing_client_name_template(HasBits* has_bits) {
    (*has_bits)[4] |= 32u;
  }
  static const ::enterprise_management::DeviceReportXDREventsProto& device_report_xdr_events(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_report_xdr_events(HasBits* has_bits) {
    (*has_bits)[4] |= 64u;
  }
  static const ::enterprise_management::KeyboardBacklightColorProto& keyboard_backlight_color(const ChromeDeviceSettingsProto* msg);
  static void set_has_keyboard_backlight_color(HasBits* has_bits) {
    (*has_bits)[4] |= 128u;
  }
  static const ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto& device_hindi_inscript_layout_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_hindi_inscript_layout_enabled(HasBits* has_bits) {
    (*has_bits)[4] |= 256u;
  }
  static const ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto& login_screen_extension_manifest_v2_availability(const ChromeDeviceSettingsProto* msg);
  static void set_has_login_screen_extension_manifest_v2_availability(HasBits* has_bits) {
    (*has_bits)[4] |= 512u;
  }
  static const ::enterprise_management::DeviceScreensaverEnabledProto& device_screensaver_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_screensaver_enabled(HasBits* has_bits) {
    (*has_bits)[4] |= 1024u;
  }
  static const ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto& device_screensaver_idle_timeout_seconds(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_screensaver_idle_timeout_seconds(HasBits* has_bits) {
    (*has_bits)[4] |= 2048u;
  }
  static const ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto& device_screensaver_image_display_interval_seconds(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_screensaver_image_display_interval_seconds(HasBits* has_bits) {
    (*has_bits)[4] |= 4096u;
  }
  static const ::enterprise_management::DeviceScreensaverImagesProto& device_screensaver_images(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_screensaver_images(HasBits* has_bits) {
    (*has_bits)[4] |= 8192u;
  }
  static const ::enterprise_management::DeviceSystemAecEnabledProto& device_system_aec_enabled(const ChromeDeviceSettingsProto* msg);
  static void set_has_device_system_aec_enabled(HasBits* has_bits) {
    (*has_bits)[4] |= 16384u;
  }
};

const ::enterprise_management::DevicePolicyRefreshRateProto&
ChromeDeviceSettingsProto::_Internal::device_policy_refresh_rate(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_policy_refresh_rate_;
}
const ::enterprise_management::UserWhitelistProto&
ChromeDeviceSettingsProto::_Internal::user_whitelist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.user_whitelist_;
}
const ::enterprise_management::GuestModeEnabledProto&
ChromeDeviceSettingsProto::_Internal::guest_mode_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.guest_mode_enabled_;
}
const ::enterprise_management::OBSOLETE_DeviceProxySettingsProto&
ChromeDeviceSettingsProto::_Internal::device_proxy_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_proxy_settings_;
}
const ::enterprise_management::CameraEnabledProto&
ChromeDeviceSettingsProto::_Internal::camera_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.camera_enabled_;
}
const ::enterprise_management::ShowUserNamesOnSigninProto&
ChromeDeviceSettingsProto::_Internal::show_user_names(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.show_user_names_;
}
const ::enterprise_management::DataRoamingEnabledProto&
ChromeDeviceSettingsProto::_Internal::data_roaming_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.data_roaming_enabled_;
}
const ::enterprise_management::AllowNewUsersProto&
ChromeDeviceSettingsProto::_Internal::allow_new_users(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.allow_new_users_;
}
const ::enterprise_management::MetricsEnabledProto&
ChromeDeviceSettingsProto::_Internal::metrics_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.metrics_enabled_;
}
const ::enterprise_management::ReleaseChannelProto&
ChromeDeviceSettingsProto::_Internal::release_channel(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.release_channel_;
}
const ::enterprise_management::DeviceOpenNetworkConfigurationProto&
ChromeDeviceSettingsProto::_Internal::open_network_configuration(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.open_network_configuration_;
}
const ::enterprise_management::DeviceReportingProto&
ChromeDeviceSettingsProto::_Internal::device_reporting(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_reporting_;
}
const ::enterprise_management::EphemeralUsersEnabledProto&
ChromeDeviceSettingsProto::_Internal::ephemeral_users_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.ephemeral_users_enabled_;
}
const ::enterprise_management::OBSOLETE_AppPackProto&
ChromeDeviceSettingsProto::_Internal::app_pack(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.app_pack_;
}
const ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto&
ChromeDeviceSettingsProto::_Internal::forced_logout_timeouts(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.forced_logout_timeouts_;
}
const ::enterprise_management::OBSOLETE_ScreenSaverProto&
ChromeDeviceSettingsProto::_Internal::login_screen_saver(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_screen_saver_;
}
const ::enterprise_management::AutoUpdateSettingsProto&
ChromeDeviceSettingsProto::_Internal::auto_update_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.auto_update_settings_;
}
const ::enterprise_management::OBSOLETE_StartUpUrlsProto&
ChromeDeviceSettingsProto::_Internal::start_up_urls(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.start_up_urls_;
}
const ::enterprise_management::OBSOLETE_PinnedAppsProto&
ChromeDeviceSettingsProto::_Internal::pinned_apps(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.pinned_apps_;
}
const ::enterprise_management::SystemTimezoneProto&
ChromeDeviceSettingsProto::_Internal::system_timezone(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.system_timezone_;
}
const ::enterprise_management::DeviceLocalAccountsProto&
ChromeDeviceSettingsProto::_Internal::device_local_accounts(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_local_accounts_;
}
const ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto&
ChromeDeviceSettingsProto::_Internal::allow_redeem_offers(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.allow_redeem_offers_;
}
const ::enterprise_management::FeatureFlagsProto&
ChromeDeviceSettingsProto::_Internal::feature_flags(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.feature_flags_;
}
const ::enterprise_management::UptimeLimitProto&
ChromeDeviceSettingsProto::_Internal::uptime_limit(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.uptime_limit_;
}
const ::enterprise_management::VariationsParameterProto&
ChromeDeviceSettingsProto::_Internal::variations_parameter(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.variations_parameter_;
}
const ::enterprise_management::AttestationSettingsProto&
ChromeDeviceSettingsProto::_Internal::attestation_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.attestation_settings_;
}
const ::enterprise_management::AccessibilitySettingsProto&
ChromeDeviceSettingsProto::_Internal::accessibility_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.accessibility_settings_;
}
const ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto&
ChromeDeviceSettingsProto::_Internal::supervised_users_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.supervised_users_settings_;
}
const ::enterprise_management::LoginScreenPowerManagementProto&
ChromeDeviceSettingsProto::_Internal::login_screen_power_management(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_screen_power_management_;
}
const ::enterprise_management::SystemUse24HourClockProto&
ChromeDeviceSettingsProto::_Internal::use_24hour_clock(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.use_24hour_clock_;
}
const ::enterprise_management::AutoCleanupSettigsProto&
ChromeDeviceSettingsProto::_Internal::auto_clean_up_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.auto_clean_up_settings_;
}
const ::enterprise_management::SystemSettingsProto&
ChromeDeviceSettingsProto::_Internal::system_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.system_settings_;
}
const ::enterprise_management::SAMLSettingsProto&
ChromeDeviceSettingsProto::_Internal::saml_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.saml_settings_;
}
const ::enterprise_management::RebootOnShutdownProto&
ChromeDeviceSettingsProto::_Internal::reboot_on_shutdown(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.reboot_on_shutdown_;
}
const ::enterprise_management::DeviceHeartbeatSettingsProto&
ChromeDeviceSettingsProto::_Internal::device_heartbeat_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_heartbeat_settings_;
}
const ::enterprise_management::ExtensionCacheSizeProto&
ChromeDeviceSettingsProto::_Internal::extension_cache_size(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.extension_cache_size_;
}
const ::enterprise_management::LoginScreenDomainAutoCompleteProto&
ChromeDeviceSettingsProto::_Internal::login_screen_domain_auto_complete(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_screen_domain_auto_complete_;
}
const ::enterprise_management::DeviceLogUploadSettingsProto&
ChromeDeviceSettingsProto::_Internal::device_log_upload_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_log_upload_settings_;
}
const ::enterprise_management::DisplayRotationDefaultProto&
ChromeDeviceSettingsProto::_Internal::display_rotation_default(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.display_rotation_default_;
}
const ::enterprise_management::AllowKioskAppControlChromeVersionProto&
ChromeDeviceSettingsProto::_Internal::allow_kiosk_app_control_chrome_version(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.allow_kiosk_app_control_chrome_version_;
}
const ::enterprise_management::LoginAuthenticationBehaviorProto&
ChromeDeviceSettingsProto::_Internal::login_authentication_behavior(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_authentication_behavior_;
}
const ::enterprise_management::UsbDetachableWhitelistProto&
ChromeDeviceSettingsProto::_Internal::usb_detachable_whitelist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.usb_detachable_whitelist_;
}
const ::enterprise_management::AllowBluetoothProto&
ChromeDeviceSettingsProto::_Internal::allow_bluetooth(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.allow_bluetooth_;
}
const ::enterprise_management::DeviceQuirksDownloadEnabledProto&
ChromeDeviceSettingsProto::_Internal::quirks_download_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.quirks_download_enabled_;
}
const ::enterprise_management::LoginVideoCaptureAllowedUrlsProto&
ChromeDeviceSettingsProto::_Internal::login_video_capture_allowed_urls(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_video_capture_allowed_urls_;
}
const ::enterprise_management::DeviceLoginScreenExtensionsProto&
ChromeDeviceSettingsProto::_Internal::device_login_screen_extensions(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_login_screen_extensions_;
}
const ::enterprise_management::NetworkThrottlingEnabledProto&
ChromeDeviceSettingsProto::_Internal::network_throttling(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.network_throttling_;
}
const ::enterprise_management::DeviceWallpaperImageProto&
ChromeDeviceSettingsProto::_Internal::device_wallpaper_image(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_wallpaper_image_;
}
const ::enterprise_management::LoginScreenLocalesProto&
ChromeDeviceSettingsProto::_Internal::login_screen_locales(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_screen_locales_;
}
const ::enterprise_management::LoginScreenInputMethodsProto&
ChromeDeviceSettingsProto::_Internal::login_screen_input_methods(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_screen_input_methods_;
}
const ::enterprise_management::DeviceEcryptfsMigrationStrategyProto&
ChromeDeviceSettingsProto::_Internal::device_ecryptfs_migration_strategy(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_ecryptfs_migration_strategy_;
}
const ::enterprise_management::DeviceSecondFactorAuthenticationProto&
ChromeDeviceSettingsProto::_Internal::device_second_factor_authentication(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_second_factor_authentication_;
}
const ::enterprise_management::CastReceiverNameProto&
ChromeDeviceSettingsProto::_Internal::cast_receiver_name(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.cast_receiver_name_;
}
const ::enterprise_management::DeviceOffHoursProto&
ChromeDeviceSettingsProto::_Internal::device_off_hours(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_off_hours_;
}
const ::enterprise_management::DeviceNativePrintersProto&
ChromeDeviceSettingsProto::_Internal::native_device_printers(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.native_device_printers_;
}
const ::enterprise_management::DeviceNativePrintersAccessModeProto&
ChromeDeviceSettingsProto::_Internal::native_device_printers_access_mode(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.native_device_printers_access_mode_;
}
const ::enterprise_management::DeviceNativePrintersBlacklistProto&
ChromeDeviceSettingsProto::_Internal::native_device_printers_blacklist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.native_device_printers_blacklist_;
}
const ::enterprise_management::DeviceNativePrintersWhitelistProto&
ChromeDeviceSettingsProto::_Internal::native_device_printers_whitelist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.native_device_printers_whitelist_;
}
const ::enterprise_management::TPMFirmwareUpdateSettingsProto&
ChromeDeviceSettingsProto::_Internal::tpm_firmware_update_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.tpm_firmware_update_settings_;
}
const ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto&
ChromeDeviceSettingsProto::_Internal::minimum_required_version(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.minimum_required_version_;
}
const ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls&
ChromeDeviceSettingsProto::_Internal::device_login_screen_auto_select_certificate_for_urls(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_login_screen_auto_select_certificate_for_urls_;
}
const ::enterprise_management::UnaffiliatedArcAllowedProto&
ChromeDeviceSettingsProto::_Internal::unaffiliated_arc_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.unaffiliated_arc_allowed_;
}
const ::enterprise_management::NetworkHostnameProto&
ChromeDeviceSettingsProto::_Internal::network_hostname(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.network_hostname_;
}
const ::enterprise_management::DeviceKerberosEncryptionTypesProto&
ChromeDeviceSettingsProto::_Internal::device_kerberos_encryption_types(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_kerberos_encryption_types_;
}
const ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto&
ChromeDeviceSettingsProto::_Internal::device_user_policy_loopback_processing_mode(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_user_policy_loopback_processing_mode_;
}
const ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto&
ChromeDeviceSettingsProto::_Internal::device_login_screen_isolate_origins(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_login_screen_isolate_origins_;
}
const ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto&
ChromeDeviceSettingsProto::_Internal::device_login_screen_site_per_process(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_login_screen_site_per_process_;
}
const ::enterprise_management::VirtualMachinesAllowedProto&
ChromeDeviceSettingsProto::_Internal::virtual_machines_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.virtual_machines_allowed_;
}
const ::enterprise_management::DeviceMachinePasswordChangeRateProto&
ChromeDeviceSettingsProto::_Internal::device_machine_password_change_rate(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_machine_password_change_rate_;
}
const ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto&
ChromeDeviceSettingsProto::_Internal::device_unaffiliated_crostini_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_unaffiliated_crostini_allowed_;
}
const ::enterprise_management::DeviceWiFiFastTransitionEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_wifi_fast_transition_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_wifi_fast_transition_enabled_;
}
const ::enterprise_management::DeviceDisplayResolutionProto&
ChromeDeviceSettingsProto::_Internal::device_display_resolution(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_display_resolution_;
}
const ::enterprise_management::PluginVmAllowedProto&
ChromeDeviceSettingsProto::_Internal::plugin_vm_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.plugin_vm_allowed_;
}
const ::enterprise_management::DeviceGpoCacheLifetimeProto&
ChromeDeviceSettingsProto::_Internal::device_gpo_cache_lifetime(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_gpo_cache_lifetime_;
}
const ::enterprise_management::DeviceAuthDataCacheLifetimeProto&
ChromeDeviceSettingsProto::_Internal::device_auth_data_cache_lifetime(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_auth_data_cache_lifetime_;
}
const ::enterprise_management::PluginVmLicenseKeyProto&
ChromeDeviceSettingsProto::_Internal::plugin_vm_license_key(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.plugin_vm_license_key_;
}
const ::enterprise_management::DeviceRebootOnUserSignoutProto&
ChromeDeviceSettingsProto::_Internal::device_reboot_on_user_signout(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_reboot_on_user_signout_;
}
const ::enterprise_management::DeviceWilcoDtcAllowedProto&
ChromeDeviceSettingsProto::_Internal::device_wilco_dtc_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_wilco_dtc_allowed_;
}
const ::enterprise_management::DeviceWilcoDtcConfigurationProto&
ChromeDeviceSettingsProto::_Internal::device_wilco_dtc_configuration(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_wilco_dtc_configuration_;
}
const ::enterprise_management::DeviceWiFiAllowedProto&
ChromeDeviceSettingsProto::_Internal::device_wifi_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_wifi_allowed_;
}
const ::enterprise_management::DevicePowerPeakShiftProto&
ChromeDeviceSettingsProto::_Internal::device_power_peak_shift(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_power_peak_shift_;
}
const ::enterprise_management::DeviceBootOnAcProto&
ChromeDeviceSettingsProto::_Internal::device_boot_on_ac(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_boot_on_ac_;
}
const ::enterprise_management::DeviceDockMacAddressSourceProto&
ChromeDeviceSettingsProto::_Internal::device_dock_mac_address_source(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_dock_mac_address_source_;
}
const ::enterprise_management::DeviceAdvancedBatteryChargeModeProto&
ChromeDeviceSettingsProto::_Internal::device_advanced_battery_charge_mode(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_advanced_battery_charge_mode_;
}
const ::enterprise_management::DeviceBatteryChargeModeProto&
ChromeDeviceSettingsProto::_Internal::device_battery_charge_mode(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_battery_charge_mode_;
}
const ::enterprise_management::DeviceUsbPowerShareProto&
ChromeDeviceSettingsProto::_Internal::device_usb_power_share(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_usb_power_share_;
}
const ::enterprise_management::DeviceScheduledUpdateCheckProto&
ChromeDeviceSettingsProto::_Internal::device_scheduled_update_check(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_scheduled_update_check_;
}
const ::enterprise_management::DevicePowerwashAllowedProto&
ChromeDeviceSettingsProto::_Internal::device_powerwash_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_powerwash_allowed_;
}
const ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto&
ChromeDeviceSettingsProto::_Internal::device_login_screen_webusb_allow_devices_for_urls(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_login_screen_webusb_allow_devices_for_urls_;
}
const ::enterprise_management::BooleanPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_login_screen_system_info_enforced(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_login_screen_system_info_enforced_;
}
const ::enterprise_management::StringListPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_web_based_attestation_allowed_urls(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_web_based_attestation_allowed_urls_;
}
const ::enterprise_management::BooleanPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_show_numeric_keyboard_for_password(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_show_numeric_keyboard_for_password_;
}
const ::enterprise_management::BooleanPolicyProto&
ChromeDeviceSettingsProto::_Internal::login_screen_primary_mouse_button_switch(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_screen_primary_mouse_button_switch_;
}
const ::enterprise_management::StringPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_minimum_version(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_minimum_version_;
}
const ::enterprise_management::SystemProxySettingsProto&
ChromeDeviceSettingsProto::_Internal::system_proxy_settings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.system_proxy_settings_;
}
const ::enterprise_management::IntegerPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_chrome_variations_type(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_chrome_variations_type_;
}
const ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_login_screen_privacy_screen_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_login_screen_privacy_screen_enabled_;
}
const ::enterprise_management::RequiredClientCertificateForDeviceProto&
ChromeDeviceSettingsProto::_Internal::required_client_certificate_for_device(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.required_client_certificate_for_device_;
}
const ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto&
ChromeDeviceSettingsProto::_Internal::device_crostini_arc_adb_sideloading_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_crostini_arc_adb_sideloading_allowed_;
}
const ::enterprise_management::StringPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_minimum_version_aue_message(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_minimum_version_aue_message_;
}
const ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto&
ChromeDeviceSettingsProto::_Internal::managed_guest_session_privacy_warnings(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.managed_guest_session_privacy_warnings_;
}
const ::enterprise_management::DeviceExternalPrintServersProto&
ChromeDeviceSettingsProto::_Internal::external_print_servers(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.external_print_servers_;
}
const ::enterprise_management::DeviceExternalPrintServersAllowlistProto&
ChromeDeviceSettingsProto::_Internal::external_print_servers_allowlist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.external_print_servers_allowlist_;
}
const ::enterprise_management::DevicePrintersAccessModeProto&
ChromeDeviceSettingsProto::_Internal::device_printers_access_mode(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_printers_access_mode_;
}
const ::enterprise_management::DevicePrintersBlocklistProto&
ChromeDeviceSettingsProto::_Internal::device_printers_blocklist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_printers_blocklist_;
}
const ::enterprise_management::DevicePrintersAllowlistProto&
ChromeDeviceSettingsProto::_Internal::device_printers_allowlist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_printers_allowlist_;
}
const ::enterprise_management::DevicePrintersProto&
ChromeDeviceSettingsProto::_Internal::device_printers(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_printers_;
}
const ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto&
ChromeDeviceSettingsProto::_Internal::device_show_low_disk_space_notification(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_show_low_disk_space_notification_;
}
const ::enterprise_management::UserAllowlistProto&
ChromeDeviceSettingsProto::_Internal::user_allowlist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.user_allowlist_;
}
const ::enterprise_management::UsbDetachableAllowlistProto&
ChromeDeviceSettingsProto::_Internal::usb_detachable_allowlist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.usb_detachable_allowlist_;
}
const ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto&
ChromeDeviceSettingsProto::_Internal::family_link_accounts_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.family_link_accounts_allowed_;
}
const ::enterprise_management::DeviceArcDataSnapshotHoursProto&
ChromeDeviceSettingsProto::_Internal::arc_data_snapshot_hours(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.arc_data_snapshot_hours_;
}
const ::enterprise_management::BooleanPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_allow_mgs_to_store_display_properties(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_allow_mgs_to_store_display_properties_;
}
const ::enterprise_management::DeviceSystemWideTracingEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_system_wide_tracing_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_system_wide_tracing_enabled_;
}
const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_pci_peripheral_data_access_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_pci_peripheral_data_access_enabled_;
}
const ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto&
ChromeDeviceSettingsProto::_Internal::device_borealis_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_borealis_allowed_;
}
const ::enterprise_management::DeviceAllowedBluetoothServicesProto&
ChromeDeviceSettingsProto::_Internal::device_allowed_bluetooth_services(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_allowed_bluetooth_services_;
}
const ::enterprise_management::DeviceDebugPacketCaptureAllowedProto&
ChromeDeviceSettingsProto::_Internal::device_debug_packet_capture_allowed(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_debug_packet_capture_allowed_;
}
const ::enterprise_management::DeviceScheduledRebootProto&
ChromeDeviceSettingsProto::_Internal::device_scheduled_reboot(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_scheduled_reboot_;
}
const ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2&
ChromeDeviceSettingsProto::_Internal::device_pci_peripheral_data_access_enabled_v2(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_pci_peripheral_data_access_enabled_v2_;
}
const ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_restricted_managed_guest_session_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_restricted_managed_guest_session_enabled_;
}
const ::enterprise_management::HostnameUserConfigurableProto&
ChromeDeviceSettingsProto::_Internal::hostname_user_configurable(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.hostname_user_configurable_;
}
const ::enterprise_management::BooleanPolicyProto&
ChromeDeviceSettingsProto::_Internal::login_screen_prompt_on_multiple_matching_certificates(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_screen_prompt_on_multiple_matching_certificates_;
}
const ::enterprise_management::BooleanPolicyProto&
ChromeDeviceSettingsProto::_Internal::kiosk_crx_manifest_update_url_ignored(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.kiosk_crx_manifest_update_url_ignored_;
}
const ::enterprise_management::DeviceI18nShortcutsEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_i18n_shortcuts_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_i18n_shortcuts_enabled_;
}
const ::enterprise_management::BooleanPolicyProto&
ChromeDeviceSettingsProto::_Internal::chromad_to_cloud_migration_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.chromad_to_cloud_migration_enabled_;
}
const ::enterprise_management::RevenDeviceHWDataUsageEnabledProto&
ChromeDeviceSettingsProto::_Internal::hardware_data_usage_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.hardware_data_usage_enabled_;
}
const ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto&
ChromeDeviceSettingsProto::_Internal::login_web_ui_lazy_loading(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_web_ui_lazy_loading_;
}
const ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto&
ChromeDeviceSettingsProto::_Internal::keylocker_for_storage_encryption_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.keylocker_for_storage_encryption_enabled_;
}
const ::enterprise_management::BooleanPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_run_automatic_cleanup_on_login(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_run_automatic_cleanup_on_login_;
}
const ::enterprise_management::EncryptedReportingPipelineConfigurationProto&
ChromeDeviceSettingsProto::_Internal::device_encrypted_reporting_pipeline_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_encrypted_reporting_pipeline_enabled_;
}
const ::enterprise_management::SAMLUsernameProto&
ChromeDeviceSettingsProto::_Internal::saml_username(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.saml_username_;
}
const ::enterprise_management::StringListPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_login_screen_context_aware_access_signals_allowlist(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_login_screen_context_aware_access_signals_allowlist_;
}
const ::enterprise_management::StringPolicyProto&
ChromeDeviceSettingsProto::_Internal::device_printing_client_name_template(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_printing_client_name_template_;
}
const ::enterprise_management::DeviceReportXDREventsProto&
ChromeDeviceSettingsProto::_Internal::device_report_xdr_events(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_report_xdr_events_;
}
const ::enterprise_management::KeyboardBacklightColorProto&
ChromeDeviceSettingsProto::_Internal::keyboard_backlight_color(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.keyboard_backlight_color_;
}
const ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_hindi_inscript_layout_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_hindi_inscript_layout_enabled_;
}
const ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto&
ChromeDeviceSettingsProto::_Internal::login_screen_extension_manifest_v2_availability(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.login_screen_extension_manifest_v2_availability_;
}
const ::enterprise_management::DeviceScreensaverEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_screensaver_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_screensaver_enabled_;
}
const ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto&
ChromeDeviceSettingsProto::_Internal::device_screensaver_idle_timeout_seconds(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_screensaver_idle_timeout_seconds_;
}
const ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto&
ChromeDeviceSettingsProto::_Internal::device_screensaver_image_display_interval_seconds(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_screensaver_image_display_interval_seconds_;
}
const ::enterprise_management::DeviceScreensaverImagesProto&
ChromeDeviceSettingsProto::_Internal::device_screensaver_images(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_screensaver_images_;
}
const ::enterprise_management::DeviceSystemAecEnabledProto&
ChromeDeviceSettingsProto::_Internal::device_system_aec_enabled(const ChromeDeviceSettingsProto* msg) {
  return *msg->_impl_.device_system_aec_enabled_;
}
void ChromeDeviceSettingsProto::clear_device_login_screen_system_info_enforced() {
  if (_impl_.device_login_screen_system_info_enforced_ != nullptr) _impl_.device_login_screen_system_info_enforced_->Clear();
  _impl_._has_bits_[2] &= ~0x02000000u;
}
void ChromeDeviceSettingsProto::clear_device_web_based_attestation_allowed_urls() {
  if (_impl_.device_web_based_attestation_allowed_urls_ != nullptr) _impl_.device_web_based_attestation_allowed_urls_->Clear();
  _impl_._has_bits_[2] &= ~0x04000000u;
}
void ChromeDeviceSettingsProto::clear_device_show_numeric_keyboard_for_password() {
  if (_impl_.device_show_numeric_keyboard_for_password_ != nullptr) _impl_.device_show_numeric_keyboard_for_password_->Clear();
  _impl_._has_bits_[2] &= ~0x08000000u;
}
void ChromeDeviceSettingsProto::clear_login_screen_primary_mouse_button_switch() {
  if (_impl_.login_screen_primary_mouse_button_switch_ != nullptr) _impl_.login_screen_primary_mouse_button_switch_->Clear();
  _impl_._has_bits_[2] &= ~0x10000000u;
}
void ChromeDeviceSettingsProto::clear_device_minimum_version() {
  if (_impl_.device_minimum_version_ != nullptr) _impl_.device_minimum_version_->Clear();
  _impl_._has_bits_[2] &= ~0x20000000u;
}
void ChromeDeviceSettingsProto::clear_device_chrome_variations_type() {
  if (_impl_.device_chrome_variations_type_ != nullptr) _impl_.device_chrome_variations_type_->Clear();
  _impl_._has_bits_[2] &= ~0x80000000u;
}
void ChromeDeviceSettingsProto::clear_device_minimum_version_aue_message() {
  if (_impl_.device_minimum_version_aue_message_ != nullptr) _impl_.device_minimum_version_aue_message_->Clear();
  _impl_._has_bits_[3] &= ~0x00000008u;
}
void ChromeDeviceSettingsProto::clear_device_allow_mgs_to_store_display_properties() {
  if (_impl_.device_allow_mgs_to_store_display_properties_ != nullptr) _impl_.device_allow_mgs_to_store_display_properties_->Clear();
  _impl_._has_bits_[3] &= ~0x00010000u;
}
void ChromeDeviceSettingsProto::clear_login_screen_prompt_on_multiple_matching_certificates() {
  if (_impl_.login_screen_prompt_on_multiple_matching_certificates_ != nullptr) _impl_.login_screen_prompt_on_multiple_matching_certificates_->Clear();
  _impl_._has_bits_[3] &= ~0x04000000u;
}
void ChromeDeviceSettingsProto::clear_kiosk_crx_manifest_update_url_ignored() {
  if (_impl_.kiosk_crx_manifest_update_url_ignored_ != nullptr) _impl_.kiosk_crx_manifest_update_url_ignored_->Clear();
  _impl_._has_bits_[3] &= ~0x08000000u;
}
void ChromeDeviceSettingsProto::clear_chromad_to_cloud_migration_enabled() {
  if (_impl_.chromad_to_cloud_migration_enabled_ != nullptr) _impl_.chromad_to_cloud_migration_enabled_->Clear();
  _impl_._has_bits_[3] &= ~0x20000000u;
}
void ChromeDeviceSettingsProto::clear_device_run_automatic_cleanup_on_login() {
  if (_impl_.device_run_automatic_cleanup_on_login_ != nullptr) _impl_.device_run_automatic_cleanup_on_login_->Clear();
  _impl_._has_bits_[4] &= ~0x00000002u;
}
void ChromeDeviceSettingsProto::clear_device_login_screen_context_aware_access_signals_allowlist() {
  if (_impl_.device_login_screen_context_aware_access_signals_allowlist_ != nullptr) _impl_.device_login_screen_context_aware_access_signals_allowlist_->Clear();
  _impl_._has_bits_[4] &= ~0x00000010u;
}
void ChromeDeviceSettingsProto::clear_device_printing_client_name_template() {
  if (_impl_.device_printing_client_name_template_ != nullptr) _impl_.device_printing_client_name_template_->Clear();
  _impl_._has_bits_[4] &= ~0x00000020u;
}
ChromeDeviceSettingsProto::ChromeDeviceSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeDeviceSettingsProto)
}
ChromeDeviceSettingsProto::ChromeDeviceSettingsProto(const ChromeDeviceSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeDeviceSettingsProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_policy_refresh_rate_){nullptr}
    , decltype(_impl_.user_whitelist_){nullptr}
    , decltype(_impl_.guest_mode_enabled_){nullptr}
    , decltype(_impl_.device_proxy_settings_){nullptr}
    , decltype(_impl_.camera_enabled_){nullptr}
    , decltype(_impl_.show_user_names_){nullptr}
    , decltype(_impl_.data_roaming_enabled_){nullptr}
    , decltype(_impl_.allow_new_users_){nullptr}
    , decltype(_impl_.metrics_enabled_){nullptr}
    , decltype(_impl_.release_channel_){nullptr}
    , decltype(_impl_.open_network_configuration_){nullptr}
    , decltype(_impl_.device_reporting_){nullptr}
    , decltype(_impl_.ephemeral_users_enabled_){nullptr}
    , decltype(_impl_.app_pack_){nullptr}
    , decltype(_impl_.forced_logout_timeouts_){nullptr}
    , decltype(_impl_.login_screen_saver_){nullptr}
    , decltype(_impl_.auto_update_settings_){nullptr}
    , decltype(_impl_.start_up_urls_){nullptr}
    , decltype(_impl_.pinned_apps_){nullptr}
    , decltype(_impl_.system_timezone_){nullptr}
    , decltype(_impl_.device_local_accounts_){nullptr}
    , decltype(_impl_.allow_redeem_offers_){nullptr}
    , decltype(_impl_.feature_flags_){nullptr}
    , decltype(_impl_.uptime_limit_){nullptr}
    , decltype(_impl_.variations_parameter_){nullptr}
    , decltype(_impl_.attestation_settings_){nullptr}
    , decltype(_impl_.accessibility_settings_){nullptr}
    , decltype(_impl_.supervised_users_settings_){nullptr}
    , decltype(_impl_.login_screen_power_management_){nullptr}
    , decltype(_impl_.use_24hour_clock_){nullptr}
    , decltype(_impl_.auto_clean_up_settings_){nullptr}
    , decltype(_impl_.system_settings_){nullptr}
    , decltype(_impl_.saml_settings_){nullptr}
    , decltype(_impl_.reboot_on_shutdown_){nullptr}
    , decltype(_impl_.device_heartbeat_settings_){nullptr}
    , decltype(_impl_.extension_cache_size_){nullptr}
    , decltype(_impl_.login_screen_domain_auto_complete_){nullptr}
    , decltype(_impl_.device_log_upload_settings_){nullptr}
    , decltype(_impl_.display_rotation_default_){nullptr}
    , decltype(_impl_.allow_kiosk_app_control_chrome_version_){nullptr}
    , decltype(_impl_.login_authentication_behavior_){nullptr}
    , decltype(_impl_.usb_detachable_whitelist_){nullptr}
    , decltype(_impl_.allow_bluetooth_){nullptr}
    , decltype(_impl_.quirks_download_enabled_){nullptr}
    , decltype(_impl_.login_video_capture_allowed_urls_){nullptr}
    , decltype(_impl_.device_login_screen_extensions_){nullptr}
    , decltype(_impl_.network_throttling_){nullptr}
    , decltype(_impl_.device_wallpaper_image_){nullptr}
    , decltype(_impl_.login_screen_locales_){nullptr}
    , decltype(_impl_.login_screen_input_methods_){nullptr}
    , decltype(_impl_.device_ecryptfs_migration_strategy_){nullptr}
    , decltype(_impl_.device_second_factor_authentication_){nullptr}
    , decltype(_impl_.cast_receiver_name_){nullptr}
    , decltype(_impl_.device_off_hours_){nullptr}
    , decltype(_impl_.native_device_printers_){nullptr}
    , decltype(_impl_.native_device_printers_access_mode_){nullptr}
    , decltype(_impl_.native_device_printers_blacklist_){nullptr}
    , decltype(_impl_.native_device_printers_whitelist_){nullptr}
    , decltype(_impl_.tpm_firmware_update_settings_){nullptr}
    , decltype(_impl_.minimum_required_version_){nullptr}
    , decltype(_impl_.device_login_screen_auto_select_certificate_for_urls_){nullptr}
    , decltype(_impl_.unaffiliated_arc_allowed_){nullptr}
    , decltype(_impl_.network_hostname_){nullptr}
    , decltype(_impl_.device_kerberos_encryption_types_){nullptr}
    , decltype(_impl_.device_user_policy_loopback_processing_mode_){nullptr}
    , decltype(_impl_.device_login_screen_isolate_origins_){nullptr}
    , decltype(_impl_.device_login_screen_site_per_process_){nullptr}
    , decltype(_impl_.virtual_machines_allowed_){nullptr}
    , decltype(_impl_.device_machine_password_change_rate_){nullptr}
    , decltype(_impl_.device_unaffiliated_crostini_allowed_){nullptr}
    , decltype(_impl_.device_wifi_fast_transition_enabled_){nullptr}
    , decltype(_impl_.device_display_resolution_){nullptr}
    , decltype(_impl_.plugin_vm_allowed_){nullptr}
    , decltype(_impl_.device_gpo_cache_lifetime_){nullptr}
    , decltype(_impl_.device_auth_data_cache_lifetime_){nullptr}
    , decltype(_impl_.plugin_vm_license_key_){nullptr}
    , decltype(_impl_.device_reboot_on_user_signout_){nullptr}
    , decltype(_impl_.device_wilco_dtc_allowed_){nullptr}
    , decltype(_impl_.device_wilco_dtc_configuration_){nullptr}
    , decltype(_impl_.device_wifi_allowed_){nullptr}
    , decltype(_impl_.device_power_peak_shift_){nullptr}
    , decltype(_impl_.device_boot_on_ac_){nullptr}
    , decltype(_impl_.device_dock_mac_address_source_){nullptr}
    , decltype(_impl_.device_advanced_battery_charge_mode_){nullptr}
    , decltype(_impl_.device_battery_charge_mode_){nullptr}
    , decltype(_impl_.device_usb_power_share_){nullptr}
    , decltype(_impl_.device_scheduled_update_check_){nullptr}
    , decltype(_impl_.device_powerwash_allowed_){nullptr}
    , decltype(_impl_.device_login_screen_webusb_allow_devices_for_urls_){nullptr}
    , decltype(_impl_.device_login_screen_system_info_enforced_){nullptr}
    , decltype(_impl_.device_web_based_attestation_allowed_urls_){nullptr}
    , decltype(_impl_.device_show_numeric_keyboard_for_password_){nullptr}
    , decltype(_impl_.login_screen_primary_mouse_button_switch_){nullptr}
    , decltype(_impl_.device_minimum_version_){nullptr}
    , decltype(_impl_.system_proxy_settings_){nullptr}
    , decltype(_impl_.device_chrome_variations_type_){nullptr}
    , decltype(_impl_.device_login_screen_privacy_screen_enabled_){nullptr}
    , decltype(_impl_.required_client_certificate_for_device_){nullptr}
    , decltype(_impl_.device_crostini_arc_adb_sideloading_allowed_){nullptr}
    , decltype(_impl_.device_minimum_version_aue_message_){nullptr}
    , decltype(_impl_.managed_guest_session_privacy_warnings_){nullptr}
    , decltype(_impl_.external_print_servers_){nullptr}
    , decltype(_impl_.external_print_servers_allowlist_){nullptr}
    , decltype(_impl_.device_printers_access_mode_){nullptr}
    , decltype(_impl_.device_printers_blocklist_){nullptr}
    , decltype(_impl_.device_printers_allowlist_){nullptr}
    , decltype(_impl_.device_printers_){nullptr}
    , decltype(_impl_.device_show_low_disk_space_notification_){nullptr}
    , decltype(_impl_.user_allowlist_){nullptr}
    , decltype(_impl_.usb_detachable_allowlist_){nullptr}
    , decltype(_impl_.family_link_accounts_allowed_){nullptr}
    , decltype(_impl_.arc_data_snapshot_hours_){nullptr}
    , decltype(_impl_.device_allow_mgs_to_store_display_properties_){nullptr}
    , decltype(_impl_.device_system_wide_tracing_enabled_){nullptr}
    , decltype(_impl_.device_pci_peripheral_data_access_enabled_){nullptr}
    , decltype(_impl_.device_borealis_allowed_){nullptr}
    , decltype(_impl_.device_allowed_bluetooth_services_){nullptr}
    , decltype(_impl_.device_debug_packet_capture_allowed_){nullptr}
    , decltype(_impl_.device_scheduled_reboot_){nullptr}
    , decltype(_impl_.device_pci_peripheral_data_access_enabled_v2_){nullptr}
    , decltype(_impl_.device_restricted_managed_guest_session_enabled_){nullptr}
    , decltype(_impl_.hostname_user_configurable_){nullptr}
    , decltype(_impl_.login_screen_prompt_on_multiple_matching_certificates_){nullptr}
    , decltype(_impl_.kiosk_crx_manifest_update_url_ignored_){nullptr}
    , decltype(_impl_.device_i18n_shortcuts_enabled_){nullptr}
    , decltype(_impl_.chromad_to_cloud_migration_enabled_){nullptr}
    , decltype(_impl_.hardware_data_usage_enabled_){nullptr}
    , decltype(_impl_.login_web_ui_lazy_loading_){nullptr}
    , decltype(_impl_.keylocker_for_storage_encryption_enabled_){nullptr}
    , decltype(_impl_.device_run_automatic_cleanup_on_login_){nullptr}
    , decltype(_impl_.device_encrypted_reporting_pipeline_enabled_){nullptr}
    , decltype(_impl_.saml_username_){nullptr}
    , decltype(_impl_.device_login_screen_context_aware_access_signals_allowlist_){nullptr}
    , decltype(_impl_.device_printing_client_name_template_){nullptr}
    , decltype(_impl_.device_report_xdr_events_){nullptr}
    , decltype(_impl_.keyboard_backlight_color_){nullptr}
    , decltype(_impl_.device_hindi_inscript_layout_enabled_){nullptr}
    , decltype(_impl_.login_screen_extension_manifest_v2_availability_){nullptr}
    , decltype(_impl_.device_screensaver_enabled_){nullptr}
    , decltype(_impl_.device_screensaver_idle_timeout_seconds_){nullptr}
    , decltype(_impl_.device_screensaver_image_display_interval_seconds_){nullptr}
    , decltype(_impl_.device_screensaver_images_){nullptr}
    , decltype(_impl_.device_system_aec_enabled_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_device_policy_refresh_rate()) {
    _this->_impl_.device_policy_refresh_rate_ = new ::enterprise_management::DevicePolicyRefreshRateProto(*from._impl_.device_policy_refresh_rate_);
  }
  if (from._internal_has_user_whitelist()) {
    _this->_impl_.user_whitelist_ = new ::enterprise_management::UserWhitelistProto(*from._impl_.user_whitelist_);
  }
  if (from._internal_has_guest_mode_enabled()) {
    _this->_impl_.guest_mode_enabled_ = new ::enterprise_management::GuestModeEnabledProto(*from._impl_.guest_mode_enabled_);
  }
  if (from._internal_has_device_proxy_settings()) {
    _this->_impl_.device_proxy_settings_ = new ::enterprise_management::OBSOLETE_DeviceProxySettingsProto(*from._impl_.device_proxy_settings_);
  }
  if (from._internal_has_camera_enabled()) {
    _this->_impl_.camera_enabled_ = new ::enterprise_management::CameraEnabledProto(*from._impl_.camera_enabled_);
  }
  if (from._internal_has_show_user_names()) {
    _this->_impl_.show_user_names_ = new ::enterprise_management::ShowUserNamesOnSigninProto(*from._impl_.show_user_names_);
  }
  if (from._internal_has_data_roaming_enabled()) {
    _this->_impl_.data_roaming_enabled_ = new ::enterprise_management::DataRoamingEnabledProto(*from._impl_.data_roaming_enabled_);
  }
  if (from._internal_has_allow_new_users()) {
    _this->_impl_.allow_new_users_ = new ::enterprise_management::AllowNewUsersProto(*from._impl_.allow_new_users_);
  }
  if (from._internal_has_metrics_enabled()) {
    _this->_impl_.metrics_enabled_ = new ::enterprise_management::MetricsEnabledProto(*from._impl_.metrics_enabled_);
  }
  if (from._internal_has_release_channel()) {
    _this->_impl_.release_channel_ = new ::enterprise_management::ReleaseChannelProto(*from._impl_.release_channel_);
  }
  if (from._internal_has_open_network_configuration()) {
    _this->_impl_.open_network_configuration_ = new ::enterprise_management::DeviceOpenNetworkConfigurationProto(*from._impl_.open_network_configuration_);
  }
  if (from._internal_has_device_reporting()) {
    _this->_impl_.device_reporting_ = new ::enterprise_management::DeviceReportingProto(*from._impl_.device_reporting_);
  }
  if (from._internal_has_ephemeral_users_enabled()) {
    _this->_impl_.ephemeral_users_enabled_ = new ::enterprise_management::EphemeralUsersEnabledProto(*from._impl_.ephemeral_users_enabled_);
  }
  if (from._internal_has_app_pack()) {
    _this->_impl_.app_pack_ = new ::enterprise_management::OBSOLETE_AppPackProto(*from._impl_.app_pack_);
  }
  if (from._internal_has_forced_logout_timeouts()) {
    _this->_impl_.forced_logout_timeouts_ = new ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto(*from._impl_.forced_logout_timeouts_);
  }
  if (from._internal_has_login_screen_saver()) {
    _this->_impl_.login_screen_saver_ = new ::enterprise_management::OBSOLETE_ScreenSaverProto(*from._impl_.login_screen_saver_);
  }
  if (from._internal_has_auto_update_settings()) {
    _this->_impl_.auto_update_settings_ = new ::enterprise_management::AutoUpdateSettingsProto(*from._impl_.auto_update_settings_);
  }
  if (from._internal_has_start_up_urls()) {
    _this->_impl_.start_up_urls_ = new ::enterprise_management::OBSOLETE_StartUpUrlsProto(*from._impl_.start_up_urls_);
  }
  if (from._internal_has_pinned_apps()) {
    _this->_impl_.pinned_apps_ = new ::enterprise_management::OBSOLETE_PinnedAppsProto(*from._impl_.pinned_apps_);
  }
  if (from._internal_has_system_timezone()) {
    _this->_impl_.system_timezone_ = new ::enterprise_management::SystemTimezoneProto(*from._impl_.system_timezone_);
  }
  if (from._internal_has_device_local_accounts()) {
    _this->_impl_.device_local_accounts_ = new ::enterprise_management::DeviceLocalAccountsProto(*from._impl_.device_local_accounts_);
  }
  if (from._internal_has_allow_redeem_offers()) {
    _this->_impl_.allow_redeem_offers_ = new ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto(*from._impl_.allow_redeem_offers_);
  }
  if (from._internal_has_feature_flags()) {
    _this->_impl_.feature_flags_ = new ::enterprise_management::FeatureFlagsProto(*from._impl_.feature_flags_);
  }
  if (from._internal_has_uptime_limit()) {
    _this->_impl_.uptime_limit_ = new ::enterprise_management::UptimeLimitProto(*from._impl_.uptime_limit_);
  }
  if (from._internal_has_variations_parameter()) {
    _this->_impl_.variations_parameter_ = new ::enterprise_management::VariationsParameterProto(*from._impl_.variations_parameter_);
  }
  if (from._internal_has_attestation_settings()) {
    _this->_impl_.attestation_settings_ = new ::enterprise_management::AttestationSettingsProto(*from._impl_.attestation_settings_);
  }
  if (from._internal_has_accessibility_settings()) {
    _this->_impl_.accessibility_settings_ = new ::enterprise_management::AccessibilitySettingsProto(*from._impl_.accessibility_settings_);
  }
  if (from._internal_has_supervised_users_settings()) {
    _this->_impl_.supervised_users_settings_ = new ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto(*from._impl_.supervised_users_settings_);
  }
  if (from._internal_has_login_screen_power_management()) {
    _this->_impl_.login_screen_power_management_ = new ::enterprise_management::LoginScreenPowerManagementProto(*from._impl_.login_screen_power_management_);
  }
  if (from._internal_has_use_24hour_clock()) {
    _this->_impl_.use_24hour_clock_ = new ::enterprise_management::SystemUse24HourClockProto(*from._impl_.use_24hour_clock_);
  }
  if (from._internal_has_auto_clean_up_settings()) {
    _this->_impl_.auto_clean_up_settings_ = new ::enterprise_management::AutoCleanupSettigsProto(*from._impl_.auto_clean_up_settings_);
  }
  if (from._internal_has_system_settings()) {
    _this->_impl_.system_settings_ = new ::enterprise_management::SystemSettingsProto(*from._impl_.system_settings_);
  }
  if (from._internal_has_saml_settings()) {
    _this->_impl_.saml_settings_ = new ::enterprise_management::SAMLSettingsProto(*from._impl_.saml_settings_);
  }
  if (from._internal_has_reboot_on_shutdown()) {
    _this->_impl_.reboot_on_shutdown_ = new ::enterprise_management::RebootOnShutdownProto(*from._impl_.reboot_on_shutdown_);
  }
  if (from._internal_has_device_heartbeat_settings()) {
    _this->_impl_.device_heartbeat_settings_ = new ::enterprise_management::DeviceHeartbeatSettingsProto(*from._impl_.device_heartbeat_settings_);
  }
  if (from._internal_has_extension_cache_size()) {
    _this->_impl_.extension_cache_size_ = new ::enterprise_management::ExtensionCacheSizeProto(*from._impl_.extension_cache_size_);
  }
  if (from._internal_has_login_screen_domain_auto_complete()) {
    _this->_impl_.login_screen_domain_auto_complete_ = new ::enterprise_management::LoginScreenDomainAutoCompleteProto(*from._impl_.login_screen_domain_auto_complete_);
  }
  if (from._internal_has_device_log_upload_settings()) {
    _this->_impl_.device_log_upload_settings_ = new ::enterprise_management::DeviceLogUploadSettingsProto(*from._impl_.device_log_upload_settings_);
  }
  if (from._internal_has_display_rotation_default()) {
    _this->_impl_.display_rotation_default_ = new ::enterprise_management::DisplayRotationDefaultProto(*from._impl_.display_rotation_default_);
  }
  if (from._internal_has_allow_kiosk_app_control_chrome_version()) {
    _this->_impl_.allow_kiosk_app_control_chrome_version_ = new ::enterprise_management::AllowKioskAppControlChromeVersionProto(*from._impl_.allow_kiosk_app_control_chrome_version_);
  }
  if (from._internal_has_login_authentication_behavior()) {
    _this->_impl_.login_authentication_behavior_ = new ::enterprise_management::LoginAuthenticationBehaviorProto(*from._impl_.login_authentication_behavior_);
  }
  if (from._internal_has_usb_detachable_whitelist()) {
    _this->_impl_.usb_detachable_whitelist_ = new ::enterprise_management::UsbDetachableWhitelistProto(*from._impl_.usb_detachable_whitelist_);
  }
  if (from._internal_has_allow_bluetooth()) {
    _this->_impl_.allow_bluetooth_ = new ::enterprise_management::AllowBluetoothProto(*from._impl_.allow_bluetooth_);
  }
  if (from._internal_has_quirks_download_enabled()) {
    _this->_impl_.quirks_download_enabled_ = new ::enterprise_management::DeviceQuirksDownloadEnabledProto(*from._impl_.quirks_download_enabled_);
  }
  if (from._internal_has_login_video_capture_allowed_urls()) {
    _this->_impl_.login_video_capture_allowed_urls_ = new ::enterprise_management::LoginVideoCaptureAllowedUrlsProto(*from._impl_.login_video_capture_allowed_urls_);
  }
  if (from._internal_has_device_login_screen_extensions()) {
    _this->_impl_.device_login_screen_extensions_ = new ::enterprise_management::DeviceLoginScreenExtensionsProto(*from._impl_.device_login_screen_extensions_);
  }
  if (from._internal_has_network_throttling()) {
    _this->_impl_.network_throttling_ = new ::enterprise_management::NetworkThrottlingEnabledProto(*from._impl_.network_throttling_);
  }
  if (from._internal_has_device_wallpaper_image()) {
    _this->_impl_.device_wallpaper_image_ = new ::enterprise_management::DeviceWallpaperImageProto(*from._impl_.device_wallpaper_image_);
  }
  if (from._internal_has_login_screen_locales()) {
    _this->_impl_.login_screen_locales_ = new ::enterprise_management::LoginScreenLocalesProto(*from._impl_.login_screen_locales_);
  }
  if (from._internal_has_login_screen_input_methods()) {
    _this->_impl_.login_screen_input_methods_ = new ::enterprise_management::LoginScreenInputMethodsProto(*from._impl_.login_screen_input_methods_);
  }
  if (from._internal_has_device_ecryptfs_migration_strategy()) {
    _this->_impl_.device_ecryptfs_migration_strategy_ = new ::enterprise_management::DeviceEcryptfsMigrationStrategyProto(*from._impl_.device_ecryptfs_migration_strategy_);
  }
  if (from._internal_has_device_second_factor_authentication()) {
    _this->_impl_.device_second_factor_authentication_ = new ::enterprise_management::DeviceSecondFactorAuthenticationProto(*from._impl_.device_second_factor_authentication_);
  }
  if (from._internal_has_cast_receiver_name()) {
    _this->_impl_.cast_receiver_name_ = new ::enterprise_management::CastReceiverNameProto(*from._impl_.cast_receiver_name_);
  }
  if (from._internal_has_device_off_hours()) {
    _this->_impl_.device_off_hours_ = new ::enterprise_management::DeviceOffHoursProto(*from._impl_.device_off_hours_);
  }
  if (from._internal_has_native_device_printers()) {
    _this->_impl_.native_device_printers_ = new ::enterprise_management::DeviceNativePrintersProto(*from._impl_.native_device_printers_);
  }
  if (from._internal_has_native_device_printers_access_mode()) {
    _this->_impl_.native_device_printers_access_mode_ = new ::enterprise_management::DeviceNativePrintersAccessModeProto(*from._impl_.native_device_printers_access_mode_);
  }
  if (from._internal_has_native_device_printers_blacklist()) {
    _this->_impl_.native_device_printers_blacklist_ = new ::enterprise_management::DeviceNativePrintersBlacklistProto(*from._impl_.native_device_printers_blacklist_);
  }
  if (from._internal_has_native_device_printers_whitelist()) {
    _this->_impl_.native_device_printers_whitelist_ = new ::enterprise_management::DeviceNativePrintersWhitelistProto(*from._impl_.native_device_printers_whitelist_);
  }
  if (from._internal_has_tpm_firmware_update_settings()) {
    _this->_impl_.tpm_firmware_update_settings_ = new ::enterprise_management::TPMFirmwareUpdateSettingsProto(*from._impl_.tpm_firmware_update_settings_);
  }
  if (from._internal_has_minimum_required_version()) {
    _this->_impl_.minimum_required_version_ = new ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto(*from._impl_.minimum_required_version_);
  }
  if (from._internal_has_device_login_screen_auto_select_certificate_for_urls()) {
    _this->_impl_.device_login_screen_auto_select_certificate_for_urls_ = new ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls(*from._impl_.device_login_screen_auto_select_certificate_for_urls_);
  }
  if (from._internal_has_unaffiliated_arc_allowed()) {
    _this->_impl_.unaffiliated_arc_allowed_ = new ::enterprise_management::UnaffiliatedArcAllowedProto(*from._impl_.unaffiliated_arc_allowed_);
  }
  if (from._internal_has_network_hostname()) {
    _this->_impl_.network_hostname_ = new ::enterprise_management::NetworkHostnameProto(*from._impl_.network_hostname_);
  }
  if (from._internal_has_device_kerberos_encryption_types()) {
    _this->_impl_.device_kerberos_encryption_types_ = new ::enterprise_management::DeviceKerberosEncryptionTypesProto(*from._impl_.device_kerberos_encryption_types_);
  }
  if (from._internal_has_device_user_policy_loopback_processing_mode()) {
    _this->_impl_.device_user_policy_loopback_processing_mode_ = new ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto(*from._impl_.device_user_policy_loopback_processing_mode_);
  }
  if (from._internal_has_device_login_screen_isolate_origins()) {
    _this->_impl_.device_login_screen_isolate_origins_ = new ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto(*from._impl_.device_login_screen_isolate_origins_);
  }
  if (from._internal_has_device_login_screen_site_per_process()) {
    _this->_impl_.device_login_screen_site_per_process_ = new ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto(*from._impl_.device_login_screen_site_per_process_);
  }
  if (from._internal_has_virtual_machines_allowed()) {
    _this->_impl_.virtual_machines_allowed_ = new ::enterprise_management::VirtualMachinesAllowedProto(*from._impl_.virtual_machines_allowed_);
  }
  if (from._internal_has_device_machine_password_change_rate()) {
    _this->_impl_.device_machine_password_change_rate_ = new ::enterprise_management::DeviceMachinePasswordChangeRateProto(*from._impl_.device_machine_password_change_rate_);
  }
  if (from._internal_has_device_unaffiliated_crostini_allowed()) {
    _this->_impl_.device_unaffiliated_crostini_allowed_ = new ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto(*from._impl_.device_unaffiliated_crostini_allowed_);
  }
  if (from._internal_has_device_wifi_fast_transition_enabled()) {
    _this->_impl_.device_wifi_fast_transition_enabled_ = new ::enterprise_management::DeviceWiFiFastTransitionEnabledProto(*from._impl_.device_wifi_fast_transition_enabled_);
  }
  if (from._internal_has_device_display_resolution()) {
    _this->_impl_.device_display_resolution_ = new ::enterprise_management::DeviceDisplayResolutionProto(*from._impl_.device_display_resolution_);
  }
  if (from._internal_has_plugin_vm_allowed()) {
    _this->_impl_.plugin_vm_allowed_ = new ::enterprise_management::PluginVmAllowedProto(*from._impl_.plugin_vm_allowed_);
  }
  if (from._internal_has_device_gpo_cache_lifetime()) {
    _this->_impl_.device_gpo_cache_lifetime_ = new ::enterprise_management::DeviceGpoCacheLifetimeProto(*from._impl_.device_gpo_cache_lifetime_);
  }
  if (from._internal_has_device_auth_data_cache_lifetime()) {
    _this->_impl_.device_auth_data_cache_lifetime_ = new ::enterprise_management::DeviceAuthDataCacheLifetimeProto(*from._impl_.device_auth_data_cache_lifetime_);
  }
  if (from._internal_has_plugin_vm_license_key()) {
    _this->_impl_.plugin_vm_license_key_ = new ::enterprise_management::PluginVmLicenseKeyProto(*from._impl_.plugin_vm_license_key_);
  }
  if (from._internal_has_device_reboot_on_user_signout()) {
    _this->_impl_.device_reboot_on_user_signout_ = new ::enterprise_management::DeviceRebootOnUserSignoutProto(*from._impl_.device_reboot_on_user_signout_);
  }
  if (from._internal_has_device_wilco_dtc_allowed()) {
    _this->_impl_.device_wilco_dtc_allowed_ = new ::enterprise_management::DeviceWilcoDtcAllowedProto(*from._impl_.device_wilco_dtc_allowed_);
  }
  if (from._internal_has_device_wilco_dtc_configuration()) {
    _this->_impl_.device_wilco_dtc_configuration_ = new ::enterprise_management::DeviceWilcoDtcConfigurationProto(*from._impl_.device_wilco_dtc_configuration_);
  }
  if (from._internal_has_device_wifi_allowed()) {
    _this->_impl_.device_wifi_allowed_ = new ::enterprise_management::DeviceWiFiAllowedProto(*from._impl_.device_wifi_allowed_);
  }
  if (from._internal_has_device_power_peak_shift()) {
    _this->_impl_.device_power_peak_shift_ = new ::enterprise_management::DevicePowerPeakShiftProto(*from._impl_.device_power_peak_shift_);
  }
  if (from._internal_has_device_boot_on_ac()) {
    _this->_impl_.device_boot_on_ac_ = new ::enterprise_management::DeviceBootOnAcProto(*from._impl_.device_boot_on_ac_);
  }
  if (from._internal_has_device_dock_mac_address_source()) {
    _this->_impl_.device_dock_mac_address_source_ = new ::enterprise_management::DeviceDockMacAddressSourceProto(*from._impl_.device_dock_mac_address_source_);
  }
  if (from._internal_has_device_advanced_battery_charge_mode()) {
    _this->_impl_.device_advanced_battery_charge_mode_ = new ::enterprise_management::DeviceAdvancedBatteryChargeModeProto(*from._impl_.device_advanced_battery_charge_mode_);
  }
  if (from._internal_has_device_battery_charge_mode()) {
    _this->_impl_.device_battery_charge_mode_ = new ::enterprise_management::DeviceBatteryChargeModeProto(*from._impl_.device_battery_charge_mode_);
  }
  if (from._internal_has_device_usb_power_share()) {
    _this->_impl_.device_usb_power_share_ = new ::enterprise_management::DeviceUsbPowerShareProto(*from._impl_.device_usb_power_share_);
  }
  if (from._internal_has_device_scheduled_update_check()) {
    _this->_impl_.device_scheduled_update_check_ = new ::enterprise_management::DeviceScheduledUpdateCheckProto(*from._impl_.device_scheduled_update_check_);
  }
  if (from._internal_has_device_powerwash_allowed()) {
    _this->_impl_.device_powerwash_allowed_ = new ::enterprise_management::DevicePowerwashAllowedProto(*from._impl_.device_powerwash_allowed_);
  }
  if (from._internal_has_device_login_screen_webusb_allow_devices_for_urls()) {
    _this->_impl_.device_login_screen_webusb_allow_devices_for_urls_ = new ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto(*from._impl_.device_login_screen_webusb_allow_devices_for_urls_);
  }
  if (from._internal_has_device_login_screen_system_info_enforced()) {
    _this->_impl_.device_login_screen_system_info_enforced_ = new ::enterprise_management::BooleanPolicyProto(*from._impl_.device_login_screen_system_info_enforced_);
  }
  if (from._internal_has_device_web_based_attestation_allowed_urls()) {
    _this->_impl_.device_web_based_attestation_allowed_urls_ = new ::enterprise_management::StringListPolicyProto(*from._impl_.device_web_based_attestation_allowed_urls_);
  }
  if (from._internal_has_device_show_numeric_keyboard_for_password()) {
    _this->_impl_.device_show_numeric_keyboard_for_password_ = new ::enterprise_management::BooleanPolicyProto(*from._impl_.device_show_numeric_keyboard_for_password_);
  }
  if (from._internal_has_login_screen_primary_mouse_button_switch()) {
    _this->_impl_.login_screen_primary_mouse_button_switch_ = new ::enterprise_management::BooleanPolicyProto(*from._impl_.login_screen_primary_mouse_button_switch_);
  }
  if (from._internal_has_device_minimum_version()) {
    _this->_impl_.device_minimum_version_ = new ::enterprise_management::StringPolicyProto(*from._impl_.device_minimum_version_);
  }
  if (from._internal_has_system_proxy_settings()) {
    _this->_impl_.system_proxy_settings_ = new ::enterprise_management::SystemProxySettingsProto(*from._impl_.system_proxy_settings_);
  }
  if (from._internal_has_device_chrome_variations_type()) {
    _this->_impl_.device_chrome_variations_type_ = new ::enterprise_management::IntegerPolicyProto(*from._impl_.device_chrome_variations_type_);
  }
  if (from._internal_has_device_login_screen_privacy_screen_enabled()) {
    _this->_impl_.device_login_screen_privacy_screen_enabled_ = new ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto(*from._impl_.device_login_screen_privacy_screen_enabled_);
  }
  if (from._internal_has_required_client_certificate_for_device()) {
    _this->_impl_.required_client_certificate_for_device_ = new ::enterprise_management::RequiredClientCertificateForDeviceProto(*from._impl_.required_client_certificate_for_device_);
  }
  if (from._internal_has_device_crostini_arc_adb_sideloading_allowed()) {
    _this->_impl_.device_crostini_arc_adb_sideloading_allowed_ = new ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto(*from._impl_.device_crostini_arc_adb_sideloading_allowed_);
  }
  if (from._internal_has_device_minimum_version_aue_message()) {
    _this->_impl_.device_minimum_version_aue_message_ = new ::enterprise_management::StringPolicyProto(*from._impl_.device_minimum_version_aue_message_);
  }
  if (from._internal_has_managed_guest_session_privacy_warnings()) {
    _this->_impl_.managed_guest_session_privacy_warnings_ = new ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto(*from._impl_.managed_guest_session_privacy_warnings_);
  }
  if (from._internal_has_external_print_servers()) {
    _this->_impl_.external_print_servers_ = new ::enterprise_management::DeviceExternalPrintServersProto(*from._impl_.external_print_servers_);
  }
  if (from._internal_has_external_print_servers_allowlist()) {
    _this->_impl_.external_print_servers_allowlist_ = new ::enterprise_management::DeviceExternalPrintServersAllowlistProto(*from._impl_.external_print_servers_allowlist_);
  }
  if (from._internal_has_device_printers_access_mode()) {
    _this->_impl_.device_printers_access_mode_ = new ::enterprise_management::DevicePrintersAccessModeProto(*from._impl_.device_printers_access_mode_);
  }
  if (from._internal_has_device_printers_blocklist()) {
    _this->_impl_.device_printers_blocklist_ = new ::enterprise_management::DevicePrintersBlocklistProto(*from._impl_.device_printers_blocklist_);
  }
  if (from._internal_has_device_printers_allowlist()) {
    _this->_impl_.device_printers_allowlist_ = new ::enterprise_management::DevicePrintersAllowlistProto(*from._impl_.device_printers_allowlist_);
  }
  if (from._internal_has_device_printers()) {
    _this->_impl_.device_printers_ = new ::enterprise_management::DevicePrintersProto(*from._impl_.device_printers_);
  }
  if (from._internal_has_device_show_low_disk_space_notification()) {
    _this->_impl_.device_show_low_disk_space_notification_ = new ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto(*from._impl_.device_show_low_disk_space_notification_);
  }
  if (from._internal_has_user_allowlist()) {
    _this->_impl_.user_allowlist_ = new ::enterprise_management::UserAllowlistProto(*from._impl_.user_allowlist_);
  }
  if (from._internal_has_usb_detachable_allowlist()) {
    _this->_impl_.usb_detachable_allowlist_ = new ::enterprise_management::UsbDetachableAllowlistProto(*from._impl_.usb_detachable_allowlist_);
  }
  if (from._internal_has_family_link_accounts_allowed()) {
    _this->_impl_.family_link_accounts_allowed_ = new ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto(*from._impl_.family_link_accounts_allowed_);
  }
  if (from._internal_has_arc_data_snapshot_hours()) {
    _this->_impl_.arc_data_snapshot_hours_ = new ::enterprise_management::DeviceArcDataSnapshotHoursProto(*from._impl_.arc_data_snapshot_hours_);
  }
  if (from._internal_has_device_allow_mgs_to_store_display_properties()) {
    _this->_impl_.device_allow_mgs_to_store_display_properties_ = new ::enterprise_management::BooleanPolicyProto(*from._impl_.device_allow_mgs_to_store_display_properties_);
  }
  if (from._internal_has_device_system_wide_tracing_enabled()) {
    _this->_impl_.device_system_wide_tracing_enabled_ = new ::enterprise_management::DeviceSystemWideTracingEnabledProto(*from._impl_.device_system_wide_tracing_enabled_);
  }
  if (from._internal_has_device_pci_peripheral_data_access_enabled()) {
    _this->_impl_.device_pci_peripheral_data_access_enabled_ = new ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto(*from._impl_.device_pci_peripheral_data_access_enabled_);
  }
  if (from._internal_has_device_borealis_allowed()) {
    _this->_impl_.device_borealis_allowed_ = new ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto(*from._impl_.device_borealis_allowed_);
  }
  if (from._internal_has_device_allowed_bluetooth_services()) {
    _this->_impl_.device_allowed_bluetooth_services_ = new ::enterprise_management::DeviceAllowedBluetoothServicesProto(*from._impl_.device_allowed_bluetooth_services_);
  }
  if (from._internal_has_device_debug_packet_capture_allowed()) {
    _this->_impl_.device_debug_packet_capture_allowed_ = new ::enterprise_management::DeviceDebugPacketCaptureAllowedProto(*from._impl_.device_debug_packet_capture_allowed_);
  }
  if (from._internal_has_device_scheduled_reboot()) {
    _this->_impl_.device_scheduled_reboot_ = new ::enterprise_management::DeviceScheduledRebootProto(*from._impl_.device_scheduled_reboot_);
  }
  if (from._internal_has_device_pci_peripheral_data_access_enabled_v2()) {
    _this->_impl_.device_pci_peripheral_data_access_enabled_v2_ = new ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2(*from._impl_.device_pci_peripheral_data_access_enabled_v2_);
  }
  if (from._internal_has_device_restricted_managed_guest_session_enabled()) {
    _this->_impl_.device_restricted_managed_guest_session_enabled_ = new ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto(*from._impl_.device_restricted_managed_guest_session_enabled_);
  }
  if (from._internal_has_hostname_user_configurable()) {
    _this->_impl_.hostname_user_configurable_ = new ::enterprise_management::HostnameUserConfigurableProto(*from._impl_.hostname_user_configurable_);
  }
  if (from._internal_has_login_screen_prompt_on_multiple_matching_certificates()) {
    _this->_impl_.login_screen_prompt_on_multiple_matching_certificates_ = new ::enterprise_management::BooleanPolicyProto(*from._impl_.login_screen_prompt_on_multiple_matching_certificates_);
  }
  if (from._internal_has_kiosk_crx_manifest_update_url_ignored()) {
    _this->_impl_.kiosk_crx_manifest_update_url_ignored_ = new ::enterprise_management::BooleanPolicyProto(*from._impl_.kiosk_crx_manifest_update_url_ignored_);
  }
  if (from._internal_has_device_i18n_shortcuts_enabled()) {
    _this->_impl_.device_i18n_shortcuts_enabled_ = new ::enterprise_management::DeviceI18nShortcutsEnabledProto(*from._impl_.device_i18n_shortcuts_enabled_);
  }
  if (from._internal_has_chromad_to_cloud_migration_enabled()) {
    _this->_impl_.chromad_to_cloud_migration_enabled_ = new ::enterprise_management::BooleanPolicyProto(*from._impl_.chromad_to_cloud_migration_enabled_);
  }
  if (from._internal_has_hardware_data_usage_enabled()) {
    _this->_impl_.hardware_data_usage_enabled_ = new ::enterprise_management::RevenDeviceHWDataUsageEnabledProto(*from._impl_.hardware_data_usage_enabled_);
  }
  if (from._internal_has_login_web_ui_lazy_loading()) {
    _this->_impl_.login_web_ui_lazy_loading_ = new ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto(*from._impl_.login_web_ui_lazy_loading_);
  }
  if (from._internal_has_keylocker_for_storage_encryption_enabled()) {
    _this->_impl_.keylocker_for_storage_encryption_enabled_ = new ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto(*from._impl_.keylocker_for_storage_encryption_enabled_);
  }
  if (from._internal_has_device_run_automatic_cleanup_on_login()) {
    _this->_impl_.device_run_automatic_cleanup_on_login_ = new ::enterprise_management::BooleanPolicyProto(*from._impl_.device_run_automatic_cleanup_on_login_);
  }
  if (from._internal_has_device_encrypted_reporting_pipeline_enabled()) {
    _this->_impl_.device_encrypted_reporting_pipeline_enabled_ = new ::enterprise_management::EncryptedReportingPipelineConfigurationProto(*from._impl_.device_encrypted_reporting_pipeline_enabled_);
  }
  if (from._internal_has_saml_username()) {
    _this->_impl_.saml_username_ = new ::enterprise_management::SAMLUsernameProto(*from._impl_.saml_username_);
  }
  if (from._internal_has_device_login_screen_context_aware_access_signals_allowlist()) {
    _this->_impl_.device_login_screen_context_aware_access_signals_allowlist_ = new ::enterprise_management::StringListPolicyProto(*from._impl_.device_login_screen_context_aware_access_signals_allowlist_);
  }
  if (from._internal_has_device_printing_client_name_template()) {
    _this->_impl_.device_printing_client_name_template_ = new ::enterprise_management::StringPolicyProto(*from._impl_.device_printing_client_name_template_);
  }
  if (from._internal_has_device_report_xdr_events()) {
    _this->_impl_.device_report_xdr_events_ = new ::enterprise_management::DeviceReportXDREventsProto(*from._impl_.device_report_xdr_events_);
  }
  if (from._internal_has_keyboard_backlight_color()) {
    _this->_impl_.keyboard_backlight_color_ = new ::enterprise_management::KeyboardBacklightColorProto(*from._impl_.keyboard_backlight_color_);
  }
  if (from._internal_has_device_hindi_inscript_layout_enabled()) {
    _this->_impl_.device_hindi_inscript_layout_enabled_ = new ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto(*from._impl_.device_hindi_inscript_layout_enabled_);
  }
  if (from._internal_has_login_screen_extension_manifest_v2_availability()) {
    _this->_impl_.login_screen_extension_manifest_v2_availability_ = new ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto(*from._impl_.login_screen_extension_manifest_v2_availability_);
  }
  if (from._internal_has_device_screensaver_enabled()) {
    _this->_impl_.device_screensaver_enabled_ = new ::enterprise_management::DeviceScreensaverEnabledProto(*from._impl_.device_screensaver_enabled_);
  }
  if (from._internal_has_device_screensaver_idle_timeout_seconds()) {
    _this->_impl_.device_screensaver_idle_timeout_seconds_ = new ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto(*from._impl_.device_screensaver_idle_timeout_seconds_);
  }
  if (from._internal_has_device_screensaver_image_display_interval_seconds()) {
    _this->_impl_.device_screensaver_image_display_interval_seconds_ = new ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto(*from._impl_.device_screensaver_image_display_interval_seconds_);
  }
  if (from._internal_has_device_screensaver_images()) {
    _this->_impl_.device_screensaver_images_ = new ::enterprise_management::DeviceScreensaverImagesProto(*from._impl_.device_screensaver_images_);
  }
  if (from._internal_has_device_system_aec_enabled()) {
    _this->_impl_.device_system_aec_enabled_ = new ::enterprise_management::DeviceSystemAecEnabledProto(*from._impl_.device_system_aec_enabled_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeDeviceSettingsProto)
}

inline void ChromeDeviceSettingsProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_policy_refresh_rate_){nullptr}
    , decltype(_impl_.user_whitelist_){nullptr}
    , decltype(_impl_.guest_mode_enabled_){nullptr}
    , decltype(_impl_.device_proxy_settings_){nullptr}
    , decltype(_impl_.camera_enabled_){nullptr}
    , decltype(_impl_.show_user_names_){nullptr}
    , decltype(_impl_.data_roaming_enabled_){nullptr}
    , decltype(_impl_.allow_new_users_){nullptr}
    , decltype(_impl_.metrics_enabled_){nullptr}
    , decltype(_impl_.release_channel_){nullptr}
    , decltype(_impl_.open_network_configuration_){nullptr}
    , decltype(_impl_.device_reporting_){nullptr}
    , decltype(_impl_.ephemeral_users_enabled_){nullptr}
    , decltype(_impl_.app_pack_){nullptr}
    , decltype(_impl_.forced_logout_timeouts_){nullptr}
    , decltype(_impl_.login_screen_saver_){nullptr}
    , decltype(_impl_.auto_update_settings_){nullptr}
    , decltype(_impl_.start_up_urls_){nullptr}
    , decltype(_impl_.pinned_apps_){nullptr}
    , decltype(_impl_.system_timezone_){nullptr}
    , decltype(_impl_.device_local_accounts_){nullptr}
    , decltype(_impl_.allow_redeem_offers_){nullptr}
    , decltype(_impl_.feature_flags_){nullptr}
    , decltype(_impl_.uptime_limit_){nullptr}
    , decltype(_impl_.variations_parameter_){nullptr}
    , decltype(_impl_.attestation_settings_){nullptr}
    , decltype(_impl_.accessibility_settings_){nullptr}
    , decltype(_impl_.supervised_users_settings_){nullptr}
    , decltype(_impl_.login_screen_power_management_){nullptr}
    , decltype(_impl_.use_24hour_clock_){nullptr}
    , decltype(_impl_.auto_clean_up_settings_){nullptr}
    , decltype(_impl_.system_settings_){nullptr}
    , decltype(_impl_.saml_settings_){nullptr}
    , decltype(_impl_.reboot_on_shutdown_){nullptr}
    , decltype(_impl_.device_heartbeat_settings_){nullptr}
    , decltype(_impl_.extension_cache_size_){nullptr}
    , decltype(_impl_.login_screen_domain_auto_complete_){nullptr}
    , decltype(_impl_.device_log_upload_settings_){nullptr}
    , decltype(_impl_.display_rotation_default_){nullptr}
    , decltype(_impl_.allow_kiosk_app_control_chrome_version_){nullptr}
    , decltype(_impl_.login_authentication_behavior_){nullptr}
    , decltype(_impl_.usb_detachable_whitelist_){nullptr}
    , decltype(_impl_.allow_bluetooth_){nullptr}
    , decltype(_impl_.quirks_download_enabled_){nullptr}
    , decltype(_impl_.login_video_capture_allowed_urls_){nullptr}
    , decltype(_impl_.device_login_screen_extensions_){nullptr}
    , decltype(_impl_.network_throttling_){nullptr}
    , decltype(_impl_.device_wallpaper_image_){nullptr}
    , decltype(_impl_.login_screen_locales_){nullptr}
    , decltype(_impl_.login_screen_input_methods_){nullptr}
    , decltype(_impl_.device_ecryptfs_migration_strategy_){nullptr}
    , decltype(_impl_.device_second_factor_authentication_){nullptr}
    , decltype(_impl_.cast_receiver_name_){nullptr}
    , decltype(_impl_.device_off_hours_){nullptr}
    , decltype(_impl_.native_device_printers_){nullptr}
    , decltype(_impl_.native_device_printers_access_mode_){nullptr}
    , decltype(_impl_.native_device_printers_blacklist_){nullptr}
    , decltype(_impl_.native_device_printers_whitelist_){nullptr}
    , decltype(_impl_.tpm_firmware_update_settings_){nullptr}
    , decltype(_impl_.minimum_required_version_){nullptr}
    , decltype(_impl_.device_login_screen_auto_select_certificate_for_urls_){nullptr}
    , decltype(_impl_.unaffiliated_arc_allowed_){nullptr}
    , decltype(_impl_.network_hostname_){nullptr}
    , decltype(_impl_.device_kerberos_encryption_types_){nullptr}
    , decltype(_impl_.device_user_policy_loopback_processing_mode_){nullptr}
    , decltype(_impl_.device_login_screen_isolate_origins_){nullptr}
    , decltype(_impl_.device_login_screen_site_per_process_){nullptr}
    , decltype(_impl_.virtual_machines_allowed_){nullptr}
    , decltype(_impl_.device_machine_password_change_rate_){nullptr}
    , decltype(_impl_.device_unaffiliated_crostini_allowed_){nullptr}
    , decltype(_impl_.device_wifi_fast_transition_enabled_){nullptr}
    , decltype(_impl_.device_display_resolution_){nullptr}
    , decltype(_impl_.plugin_vm_allowed_){nullptr}
    , decltype(_impl_.device_gpo_cache_lifetime_){nullptr}
    , decltype(_impl_.device_auth_data_cache_lifetime_){nullptr}
    , decltype(_impl_.plugin_vm_license_key_){nullptr}
    , decltype(_impl_.device_reboot_on_user_signout_){nullptr}
    , decltype(_impl_.device_wilco_dtc_allowed_){nullptr}
    , decltype(_impl_.device_wilco_dtc_configuration_){nullptr}
    , decltype(_impl_.device_wifi_allowed_){nullptr}
    , decltype(_impl_.device_power_peak_shift_){nullptr}
    , decltype(_impl_.device_boot_on_ac_){nullptr}
    , decltype(_impl_.device_dock_mac_address_source_){nullptr}
    , decltype(_impl_.device_advanced_battery_charge_mode_){nullptr}
    , decltype(_impl_.device_battery_charge_mode_){nullptr}
    , decltype(_impl_.device_usb_power_share_){nullptr}
    , decltype(_impl_.device_scheduled_update_check_){nullptr}
    , decltype(_impl_.device_powerwash_allowed_){nullptr}
    , decltype(_impl_.device_login_screen_webusb_allow_devices_for_urls_){nullptr}
    , decltype(_impl_.device_login_screen_system_info_enforced_){nullptr}
    , decltype(_impl_.device_web_based_attestation_allowed_urls_){nullptr}
    , decltype(_impl_.device_show_numeric_keyboard_for_password_){nullptr}
    , decltype(_impl_.login_screen_primary_mouse_button_switch_){nullptr}
    , decltype(_impl_.device_minimum_version_){nullptr}
    , decltype(_impl_.system_proxy_settings_){nullptr}
    , decltype(_impl_.device_chrome_variations_type_){nullptr}
    , decltype(_impl_.device_login_screen_privacy_screen_enabled_){nullptr}
    , decltype(_impl_.required_client_certificate_for_device_){nullptr}
    , decltype(_impl_.device_crostini_arc_adb_sideloading_allowed_){nullptr}
    , decltype(_impl_.device_minimum_version_aue_message_){nullptr}
    , decltype(_impl_.managed_guest_session_privacy_warnings_){nullptr}
    , decltype(_impl_.external_print_servers_){nullptr}
    , decltype(_impl_.external_print_servers_allowlist_){nullptr}
    , decltype(_impl_.device_printers_access_mode_){nullptr}
    , decltype(_impl_.device_printers_blocklist_){nullptr}
    , decltype(_impl_.device_printers_allowlist_){nullptr}
    , decltype(_impl_.device_printers_){nullptr}
    , decltype(_impl_.device_show_low_disk_space_notification_){nullptr}
    , decltype(_impl_.user_allowlist_){nullptr}
    , decltype(_impl_.usb_detachable_allowlist_){nullptr}
    , decltype(_impl_.family_link_accounts_allowed_){nullptr}
    , decltype(_impl_.arc_data_snapshot_hours_){nullptr}
    , decltype(_impl_.device_allow_mgs_to_store_display_properties_){nullptr}
    , decltype(_impl_.device_system_wide_tracing_enabled_){nullptr}
    , decltype(_impl_.device_pci_peripheral_data_access_enabled_){nullptr}
    , decltype(_impl_.device_borealis_allowed_){nullptr}
    , decltype(_impl_.device_allowed_bluetooth_services_){nullptr}
    , decltype(_impl_.device_debug_packet_capture_allowed_){nullptr}
    , decltype(_impl_.device_scheduled_reboot_){nullptr}
    , decltype(_impl_.device_pci_peripheral_data_access_enabled_v2_){nullptr}
    , decltype(_impl_.device_restricted_managed_guest_session_enabled_){nullptr}
    , decltype(_impl_.hostname_user_configurable_){nullptr}
    , decltype(_impl_.login_screen_prompt_on_multiple_matching_certificates_){nullptr}
    , decltype(_impl_.kiosk_crx_manifest_update_url_ignored_){nullptr}
    , decltype(_impl_.device_i18n_shortcuts_enabled_){nullptr}
    , decltype(_impl_.chromad_to_cloud_migration_enabled_){nullptr}
    , decltype(_impl_.hardware_data_usage_enabled_){nullptr}
    , decltype(_impl_.login_web_ui_lazy_loading_){nullptr}
    , decltype(_impl_.keylocker_for_storage_encryption_enabled_){nullptr}
    , decltype(_impl_.device_run_automatic_cleanup_on_login_){nullptr}
    , decltype(_impl_.device_encrypted_reporting_pipeline_enabled_){nullptr}
    , decltype(_impl_.saml_username_){nullptr}
    , decltype(_impl_.device_login_screen_context_aware_access_signals_allowlist_){nullptr}
    , decltype(_impl_.device_printing_client_name_template_){nullptr}
    , decltype(_impl_.device_report_xdr_events_){nullptr}
    , decltype(_impl_.keyboard_backlight_color_){nullptr}
    , decltype(_impl_.device_hindi_inscript_layout_enabled_){nullptr}
    , decltype(_impl_.login_screen_extension_manifest_v2_availability_){nullptr}
    , decltype(_impl_.device_screensaver_enabled_){nullptr}
    , decltype(_impl_.device_screensaver_idle_timeout_seconds_){nullptr}
    , decltype(_impl_.device_screensaver_image_display_interval_seconds_){nullptr}
    , decltype(_impl_.device_screensaver_images_){nullptr}
    , decltype(_impl_.device_system_aec_enabled_){nullptr}
  };
}

ChromeDeviceSettingsProto::~ChromeDeviceSettingsProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeDeviceSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeDeviceSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.device_policy_refresh_rate_;
  if (this != internal_default_instance()) delete _impl_.user_whitelist_;
  if (this != internal_default_instance()) delete _impl_.guest_mode_enabled_;
  if (this != internal_default_instance()) delete _impl_.device_proxy_settings_;
  if (this != internal_default_instance()) delete _impl_.camera_enabled_;
  if (this != internal_default_instance()) delete _impl_.show_user_names_;
  if (this != internal_default_instance()) delete _impl_.data_roaming_enabled_;
  if (this != internal_default_instance()) delete _impl_.allow_new_users_;
  if (this != internal_default_instance()) delete _impl_.metrics_enabled_;
  if (this != internal_default_instance()) delete _impl_.release_channel_;
  if (this != internal_default_instance()) delete _impl_.open_network_configuration_;
  if (this != internal_default_instance()) delete _impl_.device_reporting_;
  if (this != internal_default_instance()) delete _impl_.ephemeral_users_enabled_;
  if (this != internal_default_instance()) delete _impl_.app_pack_;
  if (this != internal_default_instance()) delete _impl_.forced_logout_timeouts_;
  if (this != internal_default_instance()) delete _impl_.login_screen_saver_;
  if (this != internal_default_instance()) delete _impl_.auto_update_settings_;
  if (this != internal_default_instance()) delete _impl_.start_up_urls_;
  if (this != internal_default_instance()) delete _impl_.pinned_apps_;
  if (this != internal_default_instance()) delete _impl_.system_timezone_;
  if (this != internal_default_instance()) delete _impl_.device_local_accounts_;
  if (this != internal_default_instance()) delete _impl_.allow_redeem_offers_;
  if (this != internal_default_instance()) delete _impl_.feature_flags_;
  if (this != internal_default_instance()) delete _impl_.uptime_limit_;
  if (this != internal_default_instance()) delete _impl_.variations_parameter_;
  if (this != internal_default_instance()) delete _impl_.attestation_settings_;
  if (this != internal_default_instance()) delete _impl_.accessibility_settings_;
  if (this != internal_default_instance()) delete _impl_.supervised_users_settings_;
  if (this != internal_default_instance()) delete _impl_.login_screen_power_management_;
  if (this != internal_default_instance()) delete _impl_.use_24hour_clock_;
  if (this != internal_default_instance()) delete _impl_.auto_clean_up_settings_;
  if (this != internal_default_instance()) delete _impl_.system_settings_;
  if (this != internal_default_instance()) delete _impl_.saml_settings_;
  if (this != internal_default_instance()) delete _impl_.reboot_on_shutdown_;
  if (this != internal_default_instance()) delete _impl_.device_heartbeat_settings_;
  if (this != internal_default_instance()) delete _impl_.extension_cache_size_;
  if (this != internal_default_instance()) delete _impl_.login_screen_domain_auto_complete_;
  if (this != internal_default_instance()) delete _impl_.device_log_upload_settings_;
  if (this != internal_default_instance()) delete _impl_.display_rotation_default_;
  if (this != internal_default_instance()) delete _impl_.allow_kiosk_app_control_chrome_version_;
  if (this != internal_default_instance()) delete _impl_.login_authentication_behavior_;
  if (this != internal_default_instance()) delete _impl_.usb_detachable_whitelist_;
  if (this != internal_default_instance()) delete _impl_.allow_bluetooth_;
  if (this != internal_default_instance()) delete _impl_.quirks_download_enabled_;
  if (this != internal_default_instance()) delete _impl_.login_video_capture_allowed_urls_;
  if (this != internal_default_instance()) delete _impl_.device_login_screen_extensions_;
  if (this != internal_default_instance()) delete _impl_.network_throttling_;
  if (this != internal_default_instance()) delete _impl_.device_wallpaper_image_;
  if (this != internal_default_instance()) delete _impl_.login_screen_locales_;
  if (this != internal_default_instance()) delete _impl_.login_screen_input_methods_;
  if (this != internal_default_instance()) delete _impl_.device_ecryptfs_migration_strategy_;
  if (this != internal_default_instance()) delete _impl_.device_second_factor_authentication_;
  if (this != internal_default_instance()) delete _impl_.cast_receiver_name_;
  if (this != internal_default_instance()) delete _impl_.device_off_hours_;
  if (this != internal_default_instance()) delete _impl_.native_device_printers_;
  if (this != internal_default_instance()) delete _impl_.native_device_printers_access_mode_;
  if (this != internal_default_instance()) delete _impl_.native_device_printers_blacklist_;
  if (this != internal_default_instance()) delete _impl_.native_device_printers_whitelist_;
  if (this != internal_default_instance()) delete _impl_.tpm_firmware_update_settings_;
  if (this != internal_default_instance()) delete _impl_.minimum_required_version_;
  if (this != internal_default_instance()) delete _impl_.device_login_screen_auto_select_certificate_for_urls_;
  if (this != internal_default_instance()) delete _impl_.unaffiliated_arc_allowed_;
  if (this != internal_default_instance()) delete _impl_.network_hostname_;
  if (this != internal_default_instance()) delete _impl_.device_kerberos_encryption_types_;
  if (this != internal_default_instance()) delete _impl_.device_user_policy_loopback_processing_mode_;
  if (this != internal_default_instance()) delete _impl_.device_login_screen_isolate_origins_;
  if (this != internal_default_instance()) delete _impl_.device_login_screen_site_per_process_;
  if (this != internal_default_instance()) delete _impl_.virtual_machines_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_machine_password_change_rate_;
  if (this != internal_default_instance()) delete _impl_.device_unaffiliated_crostini_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_wifi_fast_transition_enabled_;
  if (this != internal_default_instance()) delete _impl_.device_display_resolution_;
  if (this != internal_default_instance()) delete _impl_.plugin_vm_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_gpo_cache_lifetime_;
  if (this != internal_default_instance()) delete _impl_.device_auth_data_cache_lifetime_;
  if (this != internal_default_instance()) delete _impl_.plugin_vm_license_key_;
  if (this != internal_default_instance()) delete _impl_.device_reboot_on_user_signout_;
  if (this != internal_default_instance()) delete _impl_.device_wilco_dtc_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_wilco_dtc_configuration_;
  if (this != internal_default_instance()) delete _impl_.device_wifi_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_power_peak_shift_;
  if (this != internal_default_instance()) delete _impl_.device_boot_on_ac_;
  if (this != internal_default_instance()) delete _impl_.device_dock_mac_address_source_;
  if (this != internal_default_instance()) delete _impl_.device_advanced_battery_charge_mode_;
  if (this != internal_default_instance()) delete _impl_.device_battery_charge_mode_;
  if (this != internal_default_instance()) delete _impl_.device_usb_power_share_;
  if (this != internal_default_instance()) delete _impl_.device_scheduled_update_check_;
  if (this != internal_default_instance()) delete _impl_.device_powerwash_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_login_screen_webusb_allow_devices_for_urls_;
  if (this != internal_default_instance()) delete _impl_.device_login_screen_system_info_enforced_;
  if (this != internal_default_instance()) delete _impl_.device_web_based_attestation_allowed_urls_;
  if (this != internal_default_instance()) delete _impl_.device_show_numeric_keyboard_for_password_;
  if (this != internal_default_instance()) delete _impl_.login_screen_primary_mouse_button_switch_;
  if (this != internal_default_instance()) delete _impl_.device_minimum_version_;
  if (this != internal_default_instance()) delete _impl_.system_proxy_settings_;
  if (this != internal_default_instance()) delete _impl_.device_chrome_variations_type_;
  if (this != internal_default_instance()) delete _impl_.device_login_screen_privacy_screen_enabled_;
  if (this != internal_default_instance()) delete _impl_.required_client_certificate_for_device_;
  if (this != internal_default_instance()) delete _impl_.device_crostini_arc_adb_sideloading_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_minimum_version_aue_message_;
  if (this != internal_default_instance()) delete _impl_.managed_guest_session_privacy_warnings_;
  if (this != internal_default_instance()) delete _impl_.external_print_servers_;
  if (this != internal_default_instance()) delete _impl_.external_print_servers_allowlist_;
  if (this != internal_default_instance()) delete _impl_.device_printers_access_mode_;
  if (this != internal_default_instance()) delete _impl_.device_printers_blocklist_;
  if (this != internal_default_instance()) delete _impl_.device_printers_allowlist_;
  if (this != internal_default_instance()) delete _impl_.device_printers_;
  if (this != internal_default_instance()) delete _impl_.device_show_low_disk_space_notification_;
  if (this != internal_default_instance()) delete _impl_.user_allowlist_;
  if (this != internal_default_instance()) delete _impl_.usb_detachable_allowlist_;
  if (this != internal_default_instance()) delete _impl_.family_link_accounts_allowed_;
  if (this != internal_default_instance()) delete _impl_.arc_data_snapshot_hours_;
  if (this != internal_default_instance()) delete _impl_.device_allow_mgs_to_store_display_properties_;
  if (this != internal_default_instance()) delete _impl_.device_system_wide_tracing_enabled_;
  if (this != internal_default_instance()) delete _impl_.device_pci_peripheral_data_access_enabled_;
  if (this != internal_default_instance()) delete _impl_.device_borealis_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_allowed_bluetooth_services_;
  if (this != internal_default_instance()) delete _impl_.device_debug_packet_capture_allowed_;
  if (this != internal_default_instance()) delete _impl_.device_scheduled_reboot_;
  if (this != internal_default_instance()) delete _impl_.device_pci_peripheral_data_access_enabled_v2_;
  if (this != internal_default_instance()) delete _impl_.device_restricted_managed_guest_session_enabled_;
  if (this != internal_default_instance()) delete _impl_.hostname_user_configurable_;
  if (this != internal_default_instance()) delete _impl_.login_screen_prompt_on_multiple_matching_certificates_;
  if (this != internal_default_instance()) delete _impl_.kiosk_crx_manifest_update_url_ignored_;
  if (this != internal_default_instance()) delete _impl_.device_i18n_shortcuts_enabled_;
  if (this != internal_default_instance()) delete _impl_.chromad_to_cloud_migration_enabled_;
  if (this != internal_default_instance()) delete _impl_.hardware_data_usage_enabled_;
  if (this != internal_default_instance()) delete _impl_.login_web_ui_lazy_loading_;
  if (this != internal_default_instance()) delete _impl_.keylocker_for_storage_encryption_enabled_;
  if (this != internal_default_instance()) delete _impl_.device_run_automatic_cleanup_on_login_;
  if (this != internal_default_instance()) delete _impl_.device_encrypted_reporting_pipeline_enabled_;
  if (this != internal_default_instance()) delete _impl_.saml_username_;
  if (this != internal_default_instance()) delete _impl_.device_login_screen_context_aware_access_signals_allowlist_;
  if (this != internal_default_instance()) delete _impl_.device_printing_client_name_template_;
  if (this != internal_default_instance()) delete _impl_.device_report_xdr_events_;
  if (this != internal_default_instance()) delete _impl_.keyboard_backlight_color_;
  if (this != internal_default_instance()) delete _impl_.device_hindi_inscript_layout_enabled_;
  if (this != internal_default_instance()) delete _impl_.login_screen_extension_manifest_v2_availability_;
  if (this != internal_default_instance()) delete _impl_.device_screensaver_enabled_;
  if (this != internal_default_instance()) delete _impl_.device_screensaver_idle_timeout_seconds_;
  if (this != internal_default_instance()) delete _impl_.device_screensaver_image_display_interval_seconds_;
  if (this != internal_default_instance()) delete _impl_.device_screensaver_images_;
  if (this != internal_default_instance()) delete _impl_.device_system_aec_enabled_;
}

void ChromeDeviceSettingsProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeDeviceSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeDeviceSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.device_policy_refresh_rate_ != nullptr);
      _impl_.device_policy_refresh_rate_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.user_whitelist_ != nullptr);
      _impl_.user_whitelist_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.guest_mode_enabled_ != nullptr);
      _impl_.guest_mode_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.device_proxy_settings_ != nullptr);
      _impl_.device_proxy_settings_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.camera_enabled_ != nullptr);
      _impl_.camera_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.show_user_names_ != nullptr);
      _impl_.show_user_names_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.data_roaming_enabled_ != nullptr);
      _impl_.data_roaming_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.allow_new_users_ != nullptr);
      _impl_.allow_new_users_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.metrics_enabled_ != nullptr);
      _impl_.metrics_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.release_channel_ != nullptr);
      _impl_.release_channel_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.open_network_configuration_ != nullptr);
      _impl_.open_network_configuration_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.device_reporting_ != nullptr);
      _impl_.device_reporting_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.ephemeral_users_enabled_ != nullptr);
      _impl_.ephemeral_users_enabled_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.app_pack_ != nullptr);
      _impl_.app_pack_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.forced_logout_timeouts_ != nullptr);
      _impl_.forced_logout_timeouts_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.login_screen_saver_ != nullptr);
      _impl_.login_screen_saver_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.auto_update_settings_ != nullptr);
      _impl_.auto_update_settings_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.start_up_urls_ != nullptr);
      _impl_.start_up_urls_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.pinned_apps_ != nullptr);
      _impl_.pinned_apps_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.system_timezone_ != nullptr);
      _impl_.system_timezone_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.device_local_accounts_ != nullptr);
      _impl_.device_local_accounts_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.allow_redeem_offers_ != nullptr);
      _impl_.allow_redeem_offers_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.feature_flags_ != nullptr);
      _impl_.feature_flags_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.uptime_limit_ != nullptr);
      _impl_.uptime_limit_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(_impl_.variations_parameter_ != nullptr);
      _impl_.variations_parameter_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(_impl_.attestation_settings_ != nullptr);
      _impl_.attestation_settings_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(_impl_.accessibility_settings_ != nullptr);
      _impl_.accessibility_settings_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(_impl_.supervised_users_settings_ != nullptr);
      _impl_.supervised_users_settings_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(_impl_.login_screen_power_management_ != nullptr);
      _impl_.login_screen_power_management_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(_impl_.use_24hour_clock_ != nullptr);
      _impl_.use_24hour_clock_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(_impl_.auto_clean_up_settings_ != nullptr);
      _impl_.auto_clean_up_settings_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(_impl_.system_settings_ != nullptr);
      _impl_.system_settings_->Clear();
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.saml_settings_ != nullptr);
      _impl_.saml_settings_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.reboot_on_shutdown_ != nullptr);
      _impl_.reboot_on_shutdown_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.device_heartbeat_settings_ != nullptr);
      _impl_.device_heartbeat_settings_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.extension_cache_size_ != nullptr);
      _impl_.extension_cache_size_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.login_screen_domain_auto_complete_ != nullptr);
      _impl_.login_screen_domain_auto_complete_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.device_log_upload_settings_ != nullptr);
      _impl_.device_log_upload_settings_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.display_rotation_default_ != nullptr);
      _impl_.display_rotation_default_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.allow_kiosk_app_control_chrome_version_ != nullptr);
      _impl_.allow_kiosk_app_control_chrome_version_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.login_authentication_behavior_ != nullptr);
      _impl_.login_authentication_behavior_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.usb_detachable_whitelist_ != nullptr);
      _impl_.usb_detachable_whitelist_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.allow_bluetooth_ != nullptr);
      _impl_.allow_bluetooth_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.quirks_download_enabled_ != nullptr);
      _impl_.quirks_download_enabled_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.login_video_capture_allowed_urls_ != nullptr);
      _impl_.login_video_capture_allowed_urls_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.device_login_screen_extensions_ != nullptr);
      _impl_.device_login_screen_extensions_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.network_throttling_ != nullptr);
      _impl_.network_throttling_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.device_wallpaper_image_ != nullptr);
      _impl_.device_wallpaper_image_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.login_screen_locales_ != nullptr);
      _impl_.login_screen_locales_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.login_screen_input_methods_ != nullptr);
      _impl_.login_screen_input_methods_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.device_ecryptfs_migration_strategy_ != nullptr);
      _impl_.device_ecryptfs_migration_strategy_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.device_second_factor_authentication_ != nullptr);
      _impl_.device_second_factor_authentication_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.cast_receiver_name_ != nullptr);
      _impl_.cast_receiver_name_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.device_off_hours_ != nullptr);
      _impl_.device_off_hours_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.native_device_printers_ != nullptr);
      _impl_.native_device_printers_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.native_device_printers_access_mode_ != nullptr);
      _impl_.native_device_printers_access_mode_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(_impl_.native_device_printers_blacklist_ != nullptr);
      _impl_.native_device_printers_blacklist_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(_impl_.native_device_printers_whitelist_ != nullptr);
      _impl_.native_device_printers_whitelist_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(_impl_.tpm_firmware_update_settings_ != nullptr);
      _impl_.tpm_firmware_update_settings_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(_impl_.minimum_required_version_ != nullptr);
      _impl_.minimum_required_version_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(_impl_.device_login_screen_auto_select_certificate_for_urls_ != nullptr);
      _impl_.device_login_screen_auto_select_certificate_for_urls_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(_impl_.unaffiliated_arc_allowed_ != nullptr);
      _impl_.unaffiliated_arc_allowed_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(_impl_.network_hostname_ != nullptr);
      _impl_.network_hostname_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(_impl_.device_kerberos_encryption_types_ != nullptr);
      _impl_.device_kerberos_encryption_types_->Clear();
    }
  }
  cached_has_bits = _impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.device_user_policy_loopback_processing_mode_ != nullptr);
      _impl_.device_user_policy_loopback_processing_mode_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.device_login_screen_isolate_origins_ != nullptr);
      _impl_.device_login_screen_isolate_origins_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.device_login_screen_site_per_process_ != nullptr);
      _impl_.device_login_screen_site_per_process_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.virtual_machines_allowed_ != nullptr);
      _impl_.virtual_machines_allowed_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.device_machine_password_change_rate_ != nullptr);
      _impl_.device_machine_password_change_rate_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.device_unaffiliated_crostini_allowed_ != nullptr);
      _impl_.device_unaffiliated_crostini_allowed_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.device_wifi_fast_transition_enabled_ != nullptr);
      _impl_.device_wifi_fast_transition_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.device_display_resolution_ != nullptr);
      _impl_.device_display_resolution_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.plugin_vm_allowed_ != nullptr);
      _impl_.plugin_vm_allowed_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.device_gpo_cache_lifetime_ != nullptr);
      _impl_.device_gpo_cache_lifetime_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.device_auth_data_cache_lifetime_ != nullptr);
      _impl_.device_auth_data_cache_lifetime_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.plugin_vm_license_key_ != nullptr);
      _impl_.plugin_vm_license_key_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.device_reboot_on_user_signout_ != nullptr);
      _impl_.device_reboot_on_user_signout_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.device_wilco_dtc_allowed_ != nullptr);
      _impl_.device_wilco_dtc_allowed_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.device_wilco_dtc_configuration_ != nullptr);
      _impl_.device_wilco_dtc_configuration_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.device_wifi_allowed_ != nullptr);
      _impl_.device_wifi_allowed_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.device_power_peak_shift_ != nullptr);
      _impl_.device_power_peak_shift_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.device_boot_on_ac_ != nullptr);
      _impl_.device_boot_on_ac_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.device_dock_mac_address_source_ != nullptr);
      _impl_.device_dock_mac_address_source_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.device_advanced_battery_charge_mode_ != nullptr);
      _impl_.device_advanced_battery_charge_mode_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.device_battery_charge_mode_ != nullptr);
      _impl_.device_battery_charge_mode_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.device_usb_power_share_ != nullptr);
      _impl_.device_usb_power_share_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.device_scheduled_update_check_ != nullptr);
      _impl_.device_scheduled_update_check_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.device_powerwash_allowed_ != nullptr);
      _impl_.device_powerwash_allowed_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(_impl_.device_login_screen_webusb_allow_devices_for_urls_ != nullptr);
      _impl_.device_login_screen_webusb_allow_devices_for_urls_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(_impl_.device_login_screen_system_info_enforced_ != nullptr);
      _impl_.device_login_screen_system_info_enforced_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(_impl_.device_web_based_attestation_allowed_urls_ != nullptr);
      _impl_.device_web_based_attestation_allowed_urls_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(_impl_.device_show_numeric_keyboard_for_password_ != nullptr);
      _impl_.device_show_numeric_keyboard_for_password_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(_impl_.login_screen_primary_mouse_button_switch_ != nullptr);
      _impl_.login_screen_primary_mouse_button_switch_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(_impl_.device_minimum_version_ != nullptr);
      _impl_.device_minimum_version_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(_impl_.system_proxy_settings_ != nullptr);
      _impl_.system_proxy_settings_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(_impl_.device_chrome_variations_type_ != nullptr);
      _impl_.device_chrome_variations_type_->Clear();
    }
  }
  cached_has_bits = _impl_._has_bits_[3];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.device_login_screen_privacy_screen_enabled_ != nullptr);
      _impl_.device_login_screen_privacy_screen_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.required_client_certificate_for_device_ != nullptr);
      _impl_.required_client_certificate_for_device_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.device_crostini_arc_adb_sideloading_allowed_ != nullptr);
      _impl_.device_crostini_arc_adb_sideloading_allowed_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.device_minimum_version_aue_message_ != nullptr);
      _impl_.device_minimum_version_aue_message_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.managed_guest_session_privacy_warnings_ != nullptr);
      _impl_.managed_guest_session_privacy_warnings_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.external_print_servers_ != nullptr);
      _impl_.external_print_servers_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.external_print_servers_allowlist_ != nullptr);
      _impl_.external_print_servers_allowlist_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.device_printers_access_mode_ != nullptr);
      _impl_.device_printers_access_mode_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.device_printers_blocklist_ != nullptr);
      _impl_.device_printers_blocklist_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.device_printers_allowlist_ != nullptr);
      _impl_.device_printers_allowlist_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.device_printers_ != nullptr);
      _impl_.device_printers_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.device_show_low_disk_space_notification_ != nullptr);
      _impl_.device_show_low_disk_space_notification_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.user_allowlist_ != nullptr);
      _impl_.user_allowlist_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.usb_detachable_allowlist_ != nullptr);
      _impl_.usb_detachable_allowlist_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.family_link_accounts_allowed_ != nullptr);
      _impl_.family_link_accounts_allowed_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.arc_data_snapshot_hours_ != nullptr);
      _impl_.arc_data_snapshot_hours_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.device_allow_mgs_to_store_display_properties_ != nullptr);
      _impl_.device_allow_mgs_to_store_display_properties_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.device_system_wide_tracing_enabled_ != nullptr);
      _impl_.device_system_wide_tracing_enabled_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.device_pci_peripheral_data_access_enabled_ != nullptr);
      _impl_.device_pci_peripheral_data_access_enabled_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.device_borealis_allowed_ != nullptr);
      _impl_.device_borealis_allowed_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.device_allowed_bluetooth_services_ != nullptr);
      _impl_.device_allowed_bluetooth_services_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.device_debug_packet_capture_allowed_ != nullptr);
      _impl_.device_debug_packet_capture_allowed_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.device_scheduled_reboot_ != nullptr);
      _impl_.device_scheduled_reboot_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.device_pci_peripheral_data_access_enabled_v2_ != nullptr);
      _impl_.device_pci_peripheral_data_access_enabled_v2_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(_impl_.device_restricted_managed_guest_session_enabled_ != nullptr);
      _impl_.device_restricted_managed_guest_session_enabled_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(_impl_.hostname_user_configurable_ != nullptr);
      _impl_.hostname_user_configurable_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(_impl_.login_screen_prompt_on_multiple_matching_certificates_ != nullptr);
      _impl_.login_screen_prompt_on_multiple_matching_certificates_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(_impl_.kiosk_crx_manifest_update_url_ignored_ != nullptr);
      _impl_.kiosk_crx_manifest_update_url_ignored_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(_impl_.device_i18n_shortcuts_enabled_ != nullptr);
      _impl_.device_i18n_shortcuts_enabled_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(_impl_.chromad_to_cloud_migration_enabled_ != nullptr);
      _impl_.chromad_to_cloud_migration_enabled_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(_impl_.hardware_data_usage_enabled_ != nullptr);
      _impl_.hardware_data_usage_enabled_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(_impl_.login_web_ui_lazy_loading_ != nullptr);
      _impl_.login_web_ui_lazy_loading_->Clear();
    }
  }
  cached_has_bits = _impl_._has_bits_[4];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.keylocker_for_storage_encryption_enabled_ != nullptr);
      _impl_.keylocker_for_storage_encryption_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.device_run_automatic_cleanup_on_login_ != nullptr);
      _impl_.device_run_automatic_cleanup_on_login_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.device_encrypted_reporting_pipeline_enabled_ != nullptr);
      _impl_.device_encrypted_reporting_pipeline_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.saml_username_ != nullptr);
      _impl_.saml_username_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.device_login_screen_context_aware_access_signals_allowlist_ != nullptr);
      _impl_.device_login_screen_context_aware_access_signals_allowlist_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.device_printing_client_name_template_ != nullptr);
      _impl_.device_printing_client_name_template_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.device_report_xdr_events_ != nullptr);
      _impl_.device_report_xdr_events_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.keyboard_backlight_color_ != nullptr);
      _impl_.keyboard_backlight_color_->Clear();
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.device_hindi_inscript_layout_enabled_ != nullptr);
      _impl_.device_hindi_inscript_layout_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.login_screen_extension_manifest_v2_availability_ != nullptr);
      _impl_.login_screen_extension_manifest_v2_availability_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.device_screensaver_enabled_ != nullptr);
      _impl_.device_screensaver_enabled_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.device_screensaver_idle_timeout_seconds_ != nullptr);
      _impl_.device_screensaver_idle_timeout_seconds_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.device_screensaver_image_display_interval_seconds_ != nullptr);
      _impl_.device_screensaver_image_display_interval_seconds_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.device_screensaver_images_ != nullptr);
      _impl_.device_screensaver_images_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.device_system_aec_enabled_ != nullptr);
      _impl_.device_system_aec_enabled_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeDeviceSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DevicePolicyRefreshRateProto device_policy_refresh_rate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_policy_refresh_rate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.UserWhitelistProto user_whitelist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_whitelist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.GuestModeEnabledProto guest_mode_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_guest_mode_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_DeviceProxySettingsProto device_proxy_settings = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_proxy_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CameraEnabledProto camera_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ShowUserNamesOnSigninProto show_user_names = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_user_names(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DataRoamingEnabledProto data_roaming_enabled = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_data_roaming_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AllowNewUsersProto allow_new_users = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_allow_new_users(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.MetricsEnabledProto metrics_enabled = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_metrics_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ReleaseChannelProto release_channel = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_release_channel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceOpenNetworkConfigurationProto open_network_configuration = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_open_network_configuration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceReportingProto device_reporting = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_reporting(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.EphemeralUsersEnabledProto ephemeral_users_enabled = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_ephemeral_users_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_AppPackProto app_pack = 14 [deprecated = true];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_app_pack(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto forced_logout_timeouts = 15 [deprecated = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_forced_logout_timeouts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_ScreenSaverProto login_screen_saver = 16 [deprecated = true];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_saver(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AutoUpdateSettingsProto auto_update_settings = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_auto_update_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_StartUpUrlsProto start_up_urls = 18 [deprecated = true];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_up_urls(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_PinnedAppsProto pinned_apps = 19 [deprecated = true];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_pinned_apps(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SystemTimezoneProto system_timezone = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_timezone(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceLocalAccountsProto device_local_accounts = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_local_accounts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AllowRedeemChromeOsRegistrationOffersProto allow_redeem_offers = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_allow_redeem_offers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.FeatureFlagsProto feature_flags = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_feature_flags(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.UptimeLimitProto uptime_limit = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_uptime_limit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.VariationsParameterProto variations_parameter = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_variations_parameter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AttestationSettingsProto attestation_settings = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_attestation_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AccessibilitySettingsProto accessibility_settings = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_accessibility_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_SupervisedUsersSettingsProto supervised_users_settings = 28 [deprecated = true];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_supervised_users_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LoginScreenPowerManagementProto login_screen_power_management = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_power_management(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SystemUse24HourClockProto use_24hour_clock = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_use_24hour_clock(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AutoCleanupSettigsProto auto_clean_up_settings = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_auto_clean_up_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SystemSettingsProto system_settings = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SAMLSettingsProto saml_settings = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_saml_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.RebootOnShutdownProto reboot_on_shutdown = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reboot_on_shutdown(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceHeartbeatSettingsProto device_heartbeat_settings = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_heartbeat_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionCacheSizeProto extension_cache_size = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_extension_cache_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LoginScreenDomainAutoCompleteProto login_screen_domain_auto_complete = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_domain_auto_complete(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceLogUploadSettingsProto device_log_upload_settings = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_log_upload_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DisplayRotationDefaultProto display_rotation_default = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_display_rotation_default(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AllowKioskAppControlChromeVersionProto allow_kiosk_app_control_chrome_version = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_allow_kiosk_app_control_chrome_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LoginAuthenticationBehaviorProto login_authentication_behavior = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_authentication_behavior(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.UsbDetachableWhitelistProto usb_detachable_whitelist = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_usb_detachable_whitelist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AllowBluetoothProto allow_bluetooth = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_allow_bluetooth(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceQuirksDownloadEnabledProto quirks_download_enabled = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_quirks_download_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LoginVideoCaptureAllowedUrlsProto login_video_capture_allowed_urls = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_video_capture_allowed_urls(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceLoginScreenExtensionsProto device_login_screen_extensions = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_login_screen_extensions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.NetworkThrottlingEnabledProto network_throttling = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_throttling(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceWallpaperImageProto device_wallpaper_image = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_wallpaper_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LoginScreenLocalesProto login_screen_locales = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_locales(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LoginScreenInputMethodsProto login_screen_input_methods = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_input_methods(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto device_ecryptfs_migration_strategy = 51 [deprecated = true];
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_ecryptfs_migration_strategy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceSecondFactorAuthenticationProto device_second_factor_authentication = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_second_factor_authentication(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CastReceiverNameProto cast_receiver_name = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_cast_receiver_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceOffHoursProto device_off_hours = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_off_hours(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceNativePrintersProto native_device_printers = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_native_device_printers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceNativePrintersAccessModeProto native_device_printers_access_mode = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_native_device_printers_access_mode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceNativePrintersBlacklistProto native_device_printers_blacklist = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_native_device_printers_blacklist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceNativePrintersWhitelistProto native_device_printers_whitelist = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_native_device_printers_whitelist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.TPMFirmwareUpdateSettingsProto tpm_firmware_update_settings = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_tpm_firmware_update_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_MinimumRequiredVersionProto minimum_required_version = 60 [deprecated = true];
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_minimum_required_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls device_login_screen_auto_select_certificate_for_urls = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_login_screen_auto_select_certificate_for_urls(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.UnaffiliatedArcAllowedProto unaffiliated_arc_allowed = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_unaffiliated_arc_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.NetworkHostnameProto network_hostname = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_hostname(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceKerberosEncryptionTypesProto device_kerberos_encryption_types = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_kerberos_encryption_types(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto device_user_policy_loopback_processing_mode = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_user_policy_loopback_processing_mode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto device_login_screen_isolate_origins = 67 [deprecated = true];
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_login_screen_isolate_origins(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto device_login_screen_site_per_process = 68 [deprecated = true];
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_login_screen_site_per_process(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.VirtualMachinesAllowedProto virtual_machines_allowed = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_virtual_machines_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceMachinePasswordChangeRateProto device_machine_password_change_rate = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_machine_password_change_rate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto device_unaffiliated_crostini_allowed = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_unaffiliated_crostini_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceWiFiFastTransitionEnabledProto device_wifi_fast_transition_enabled = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_wifi_fast_transition_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceDisplayResolutionProto device_display_resolution = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_display_resolution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PluginVmAllowedProto plugin_vm_allowed = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_plugin_vm_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceGpoCacheLifetimeProto device_gpo_cache_lifetime = 76;
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_gpo_cache_lifetime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAuthDataCacheLifetimeProto device_auth_data_cache_lifetime = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_auth_data_cache_lifetime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PluginVmLicenseKeyProto plugin_vm_license_key = 78;
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_plugin_vm_license_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRebootOnUserSignoutProto device_reboot_on_user_signout = 79;
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_reboot_on_user_signout(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceWilcoDtcAllowedProto device_wilco_dtc_allowed = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_wilco_dtc_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceWilcoDtcConfigurationProto device_wilco_dtc_configuration = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_wilco_dtc_configuration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceWiFiAllowedProto device_wifi_allowed = 82;
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_wifi_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePowerPeakShiftProto device_power_peak_shift = 83;
      case 83:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_power_peak_shift(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceBootOnAcProto device_boot_on_ac = 84;
      case 84:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_boot_on_ac(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceDockMacAddressSourceProto device_dock_mac_address_source = 85;
      case 85:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_dock_mac_address_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAdvancedBatteryChargeModeProto device_advanced_battery_charge_mode = 86;
      case 86:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_advanced_battery_charge_mode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceBatteryChargeModeProto device_battery_charge_mode = 87;
      case 87:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_battery_charge_mode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceUsbPowerShareProto device_usb_power_share = 88;
      case 88:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_usb_power_share(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceScheduledUpdateCheckProto device_scheduled_update_check = 89;
      case 89:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_scheduled_update_check(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePowerwashAllowedProto device_powerwash_allowed = 91;
      case 91:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_powerwash_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto device_login_screen_webusb_allow_devices_for_urls = 92;
      case 92:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_login_screen_webusb_allow_devices_for_urls(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BooleanPolicyProto device_login_screen_system_info_enforced = 93;
      case 93:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_login_screen_system_info_enforced(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.StringListPolicyProto device_web_based_attestation_allowed_urls = 94;
      case 94:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_web_based_attestation_allowed_urls(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BooleanPolicyProto device_show_numeric_keyboard_for_password = 95;
      case 95:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_show_numeric_keyboard_for_password(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BooleanPolicyProto login_screen_primary_mouse_button_switch = 96;
      case 96:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_primary_mouse_button_switch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.StringPolicyProto device_minimum_version = 97;
      case 97:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_minimum_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SystemProxySettingsProto system_proxy_settings = 98;
      case 98:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_proxy_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.IntegerPolicyProto device_chrome_variations_type = 99;
      case 99:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_chrome_variations_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto device_login_screen_privacy_screen_enabled = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_login_screen_privacy_screen_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.RequiredClientCertificateForDeviceProto required_client_certificate_for_device = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_required_client_certificate_for_device(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto device_crostini_arc_adb_sideloading_allowed = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_crostini_arc_adb_sideloading_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.StringPolicyProto device_minimum_version_aue_message = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_minimum_version_aue_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ManagedGuestSessionPrivacyWarningsProto managed_guest_session_privacy_warnings = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_managed_guest_session_privacy_warnings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceExternalPrintServersProto external_print_servers = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_print_servers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceExternalPrintServersAllowlistProto external_print_servers_allowlist = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_print_servers_allowlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePrintersAccessModeProto device_printers_access_mode = 107;
      case 107:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_printers_access_mode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePrintersBlocklistProto device_printers_blocklist = 108;
      case 108:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_printers_blocklist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePrintersAllowlistProto device_printers_allowlist = 109;
      case 109:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_printers_allowlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePrintersProto device_printers = 110;
      case 110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_printers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceShowLowDiskSpaceNotificationProto device_show_low_disk_space_notification = 111;
      case 111:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_show_low_disk_space_notification(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.UserAllowlistProto user_allowlist = 112;
      case 112:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_allowlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.UsbDetachableAllowlistProto usb_detachable_allowlist = 113;
      case 113:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_usb_detachable_allowlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceFamilyLinkAccountsAllowedProto family_link_accounts_allowed = 114;
      case 114:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_family_link_accounts_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceArcDataSnapshotHoursProto arc_data_snapshot_hours = 115;
      case 115:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_arc_data_snapshot_hours(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BooleanPolicyProto device_allow_mgs_to_store_display_properties = 116;
      case 116:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_allow_mgs_to_store_display_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceSystemWideTracingEnabledProto device_system_wide_tracing_enabled = 117;
      case 117:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_system_wide_tracing_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProto device_pci_peripheral_data_access_enabled = 118;
      case 118:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_pci_peripheral_data_access_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OBSOLETE_DeviceBorealisAllowedProto device_borealis_allowed = 119 [deprecated = true];
      case 119:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_borealis_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAllowedBluetoothServicesProto device_allowed_bluetooth_services = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_allowed_bluetooth_services(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceDebugPacketCaptureAllowedProto device_debug_packet_capture_allowed = 121;
      case 121:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_debug_packet_capture_allowed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceScheduledRebootProto device_scheduled_reboot = 122;
      case 122:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_scheduled_reboot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2 device_pci_peripheral_data_access_enabled_v2 = 123;
      case 123:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_pci_peripheral_data_access_enabled_v2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto device_restricted_managed_guest_session_enabled = 124;
      case 124:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_restricted_managed_guest_session_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.HostnameUserConfigurableProto hostname_user_configurable = 125;
      case 125:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_hostname_user_configurable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BooleanPolicyProto login_screen_prompt_on_multiple_matching_certificates = 126;
      case 126:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_prompt_on_multiple_matching_certificates(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BooleanPolicyProto kiosk_crx_manifest_update_url_ignored = 127;
      case 127:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_kiosk_crx_manifest_update_url_ignored(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceI18nShortcutsEnabledProto device_i18n_shortcuts_enabled = 128;
      case 128:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_i18n_shortcuts_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BooleanPolicyProto chromad_to_cloud_migration_enabled = 129;
      case 129:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chromad_to_cloud_migration_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.RevenDeviceHWDataUsageEnabledProto hardware_data_usage_enabled = 130;
      case 130:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_hardware_data_usage_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceLoginScreenWebUILazyLoadingProto login_web_ui_lazy_loading = 131;
      case 131:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_web_ui_lazy_loading(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto keylocker_for_storage_encryption_enabled = 132;
      case 132:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_keylocker_for_storage_encryption_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BooleanPolicyProto device_run_automatic_cleanup_on_login = 133;
      case 133:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_run_automatic_cleanup_on_login(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.EncryptedReportingPipelineConfigurationProto device_encrypted_reporting_pipeline_enabled = 134;
      case 134:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_encrypted_reporting_pipeline_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SAMLUsernameProto saml_username = 135;
      case 135:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_saml_username(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.StringListPolicyProto device_login_screen_context_aware_access_signals_allowlist = 136;
      case 136:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_login_screen_context_aware_access_signals_allowlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.StringPolicyProto device_printing_client_name_template = 137;
      case 137:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_printing_client_name_template(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceReportXDREventsProto device_report_xdr_events = 138;
      case 138:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_report_xdr_events(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.KeyboardBacklightColorProto keyboard_backlight_color = 139;
      case 139:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_keyboard_backlight_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceHindiInscriptLayoutEnabledProto device_hindi_inscript_layout_enabled = 140;
      case 140:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_hindi_inscript_layout_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto login_screen_extension_manifest_v2_availability = 141;
      case 141:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_screen_extension_manifest_v2_availability(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceScreensaverEnabledProto device_screensaver_enabled = 142;
      case 142:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_screensaver_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto device_screensaver_idle_timeout_seconds = 143;
      case 143:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_screensaver_idle_timeout_seconds(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto device_screensaver_image_display_interval_seconds = 144;
      case 144:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_screensaver_image_display_interval_seconds(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceScreensaverImagesProto device_screensaver_images = 145;
      case 145:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_screensaver_images(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceSystemAecEnabledProto device_system_aec_enabled = 146;
      case 146:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_system_aec_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeDeviceSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeDeviceSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DevicePolicyRefreshRateProto device_policy_refresh_rate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::device_policy_refresh_rate(this),
        _Internal::device_policy_refresh_rate(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.UserWhitelistProto user_whitelist = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::user_whitelist(this),
        _Internal::user_whitelist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.GuestModeEnabledProto guest_mode_enabled = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::guest_mode_enabled(this),
        _Internal::guest_mode_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_DeviceProxySettingsProto device_proxy_settings = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::device_proxy_settings(this),
        _Internal::device_proxy_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CameraEnabledProto camera_enabled = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::camera_enabled(this),
        _Internal::camera_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ShowUserNamesOnSigninProto show_user_names = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::show_user_names(this),
        _Internal::show_user_names(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DataRoamingEnabledProto data_roaming_enabled = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::data_roaming_enabled(this),
        _Internal::data_roaming_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AllowNewUsersProto allow_new_users = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::allow_new_users(this),
        _Internal::allow_new_users(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.MetricsEnabledProto metrics_enabled = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::metrics_enabled(this),
        _Internal::metrics_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ReleaseChannelProto release_channel = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::release_channel(this),
        _Internal::release_channel(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceOpenNetworkConfigurationProto open_network_configuration = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::open_network_configuration(this),
        _Internal::open_network_configuration(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceReportingProto device_reporting = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::device_reporting(this),
        _Internal::device_reporting(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.EphemeralUsersEnabledProto ephemeral_users_enabled = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::ephemeral_users_enabled(this),
        _Internal::ephemeral_users_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_AppPackProto app_pack = 14 [deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::app_pack(this),
        _Internal::app_pack(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto forced_logout_timeouts = 15 [deprecated = true];
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::forced_logout_timeouts(this),
        _Internal::forced_logout_timeouts(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_ScreenSaverProto login_screen_saver = 16 [deprecated = true];
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::login_screen_saver(this),
        _Internal::login_screen_saver(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AutoUpdateSettingsProto auto_update_settings = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::auto_update_settings(this),
        _Internal::auto_update_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_StartUpUrlsProto start_up_urls = 18 [deprecated = true];
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::start_up_urls(this),
        _Internal::start_up_urls(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_PinnedAppsProto pinned_apps = 19 [deprecated = true];
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::pinned_apps(this),
        _Internal::pinned_apps(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SystemTimezoneProto system_timezone = 20;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::system_timezone(this),
        _Internal::system_timezone(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceLocalAccountsProto device_local_accounts = 21;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::device_local_accounts(this),
        _Internal::device_local_accounts(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AllowRedeemChromeOsRegistrationOffersProto allow_redeem_offers = 22;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::allow_redeem_offers(this),
        _Internal::allow_redeem_offers(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.FeatureFlagsProto feature_flags = 23;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::feature_flags(this),
        _Internal::feature_flags(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.UptimeLimitProto uptime_limit = 24;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::uptime_limit(this),
        _Internal::uptime_limit(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.VariationsParameterProto variations_parameter = 25;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::variations_parameter(this),
        _Internal::variations_parameter(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AttestationSettingsProto attestation_settings = 26;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::attestation_settings(this),
        _Internal::attestation_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AccessibilitySettingsProto accessibility_settings = 27;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::accessibility_settings(this),
        _Internal::accessibility_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_SupervisedUsersSettingsProto supervised_users_settings = 28 [deprecated = true];
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::supervised_users_settings(this),
        _Internal::supervised_users_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.LoginScreenPowerManagementProto login_screen_power_management = 29;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::login_screen_power_management(this),
        _Internal::login_screen_power_management(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SystemUse24HourClockProto use_24hour_clock = 30;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::use_24hour_clock(this),
        _Internal::use_24hour_clock(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AutoCleanupSettigsProto auto_clean_up_settings = 31;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::auto_clean_up_settings(this),
        _Internal::auto_clean_up_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SystemSettingsProto system_settings = 32;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::system_settings(this),
        _Internal::system_settings(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional .enterprise_management.SAMLSettingsProto saml_settings = 33;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::saml_settings(this),
        _Internal::saml_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.RebootOnShutdownProto reboot_on_shutdown = 34;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(34, _Internal::reboot_on_shutdown(this),
        _Internal::reboot_on_shutdown(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceHeartbeatSettingsProto device_heartbeat_settings = 35;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::device_heartbeat_settings(this),
        _Internal::device_heartbeat_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ExtensionCacheSizeProto extension_cache_size = 36;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::extension_cache_size(this),
        _Internal::extension_cache_size(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.LoginScreenDomainAutoCompleteProto login_screen_domain_auto_complete = 37;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::login_screen_domain_auto_complete(this),
        _Internal::login_screen_domain_auto_complete(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceLogUploadSettingsProto device_log_upload_settings = 38;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::device_log_upload_settings(this),
        _Internal::device_log_upload_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DisplayRotationDefaultProto display_rotation_default = 39;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::display_rotation_default(this),
        _Internal::display_rotation_default(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AllowKioskAppControlChromeVersionProto allow_kiosk_app_control_chrome_version = 40;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(40, _Internal::allow_kiosk_app_control_chrome_version(this),
        _Internal::allow_kiosk_app_control_chrome_version(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.LoginAuthenticationBehaviorProto login_authentication_behavior = 41;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, _Internal::login_authentication_behavior(this),
        _Internal::login_authentication_behavior(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.UsbDetachableWhitelistProto usb_detachable_whitelist = 42;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(42, _Internal::usb_detachable_whitelist(this),
        _Internal::usb_detachable_whitelist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AllowBluetoothProto allow_bluetooth = 43;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(43, _Internal::allow_bluetooth(this),
        _Internal::allow_bluetooth(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceQuirksDownloadEnabledProto quirks_download_enabled = 44;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(44, _Internal::quirks_download_enabled(this),
        _Internal::quirks_download_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.LoginVideoCaptureAllowedUrlsProto login_video_capture_allowed_urls = 45;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(45, _Internal::login_video_capture_allowed_urls(this),
        _Internal::login_video_capture_allowed_urls(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceLoginScreenExtensionsProto device_login_screen_extensions = 46;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(46, _Internal::device_login_screen_extensions(this),
        _Internal::device_login_screen_extensions(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.NetworkThrottlingEnabledProto network_throttling = 47;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(47, _Internal::network_throttling(this),
        _Internal::network_throttling(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceWallpaperImageProto device_wallpaper_image = 48;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(48, _Internal::device_wallpaper_image(this),
        _Internal::device_wallpaper_image(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.LoginScreenLocalesProto login_screen_locales = 49;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(49, _Internal::login_screen_locales(this),
        _Internal::login_screen_locales(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.LoginScreenInputMethodsProto login_screen_input_methods = 50;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(50, _Internal::login_screen_input_methods(this),
        _Internal::login_screen_input_methods(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto device_ecryptfs_migration_strategy = 51 [deprecated = true];
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(51, _Internal::device_ecryptfs_migration_strategy(this),
        _Internal::device_ecryptfs_migration_strategy(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceSecondFactorAuthenticationProto device_second_factor_authentication = 52;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(52, _Internal::device_second_factor_authentication(this),
        _Internal::device_second_factor_authentication(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CastReceiverNameProto cast_receiver_name = 53;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(53, _Internal::cast_receiver_name(this),
        _Internal::cast_receiver_name(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceOffHoursProto device_off_hours = 54;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(54, _Internal::device_off_hours(this),
        _Internal::device_off_hours(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceNativePrintersProto native_device_printers = 55;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(55, _Internal::native_device_printers(this),
        _Internal::native_device_printers(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceNativePrintersAccessModeProto native_device_printers_access_mode = 56;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(56, _Internal::native_device_printers_access_mode(this),
        _Internal::native_device_printers_access_mode(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceNativePrintersBlacklistProto native_device_printers_blacklist = 57;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(57, _Internal::native_device_printers_blacklist(this),
        _Internal::native_device_printers_blacklist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceNativePrintersWhitelistProto native_device_printers_whitelist = 58;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(58, _Internal::native_device_printers_whitelist(this),
        _Internal::native_device_printers_whitelist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.TPMFirmwareUpdateSettingsProto tpm_firmware_update_settings = 59;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(59, _Internal::tpm_firmware_update_settings(this),
        _Internal::tpm_firmware_update_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_MinimumRequiredVersionProto minimum_required_version = 60 [deprecated = true];
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(60, _Internal::minimum_required_version(this),
        _Internal::minimum_required_version(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls device_login_screen_auto_select_certificate_for_urls = 62;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(62, _Internal::device_login_screen_auto_select_certificate_for_urls(this),
        _Internal::device_login_screen_auto_select_certificate_for_urls(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.UnaffiliatedArcAllowedProto unaffiliated_arc_allowed = 63;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(63, _Internal::unaffiliated_arc_allowed(this),
        _Internal::unaffiliated_arc_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.NetworkHostnameProto network_hostname = 64;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(64, _Internal::network_hostname(this),
        _Internal::network_hostname(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceKerberosEncryptionTypesProto device_kerberos_encryption_types = 65;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(65, _Internal::device_kerberos_encryption_types(this),
        _Internal::device_kerberos_encryption_types(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto device_user_policy_loopback_processing_mode = 66;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(66, _Internal::device_user_policy_loopback_processing_mode(this),
        _Internal::device_user_policy_loopback_processing_mode(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto device_login_screen_isolate_origins = 67 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(67, _Internal::device_login_screen_isolate_origins(this),
        _Internal::device_login_screen_isolate_origins(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto device_login_screen_site_per_process = 68 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(68, _Internal::device_login_screen_site_per_process(this),
        _Internal::device_login_screen_site_per_process(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.VirtualMachinesAllowedProto virtual_machines_allowed = 69;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(69, _Internal::virtual_machines_allowed(this),
        _Internal::virtual_machines_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceMachinePasswordChangeRateProto device_machine_password_change_rate = 70;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(70, _Internal::device_machine_password_change_rate(this),
        _Internal::device_machine_password_change_rate(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto device_unaffiliated_crostini_allowed = 72;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(72, _Internal::device_unaffiliated_crostini_allowed(this),
        _Internal::device_unaffiliated_crostini_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceWiFiFastTransitionEnabledProto device_wifi_fast_transition_enabled = 73;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(73, _Internal::device_wifi_fast_transition_enabled(this),
        _Internal::device_wifi_fast_transition_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceDisplayResolutionProto device_display_resolution = 74;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(74, _Internal::device_display_resolution(this),
        _Internal::device_display_resolution(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.PluginVmAllowedProto plugin_vm_allowed = 75;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(75, _Internal::plugin_vm_allowed(this),
        _Internal::plugin_vm_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceGpoCacheLifetimeProto device_gpo_cache_lifetime = 76;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(76, _Internal::device_gpo_cache_lifetime(this),
        _Internal::device_gpo_cache_lifetime(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAuthDataCacheLifetimeProto device_auth_data_cache_lifetime = 77;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(77, _Internal::device_auth_data_cache_lifetime(this),
        _Internal::device_auth_data_cache_lifetime(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.PluginVmLicenseKeyProto plugin_vm_license_key = 78;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(78, _Internal::plugin_vm_license_key(this),
        _Internal::plugin_vm_license_key(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceRebootOnUserSignoutProto device_reboot_on_user_signout = 79;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(79, _Internal::device_reboot_on_user_signout(this),
        _Internal::device_reboot_on_user_signout(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceWilcoDtcAllowedProto device_wilco_dtc_allowed = 80;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(80, _Internal::device_wilco_dtc_allowed(this),
        _Internal::device_wilco_dtc_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceWilcoDtcConfigurationProto device_wilco_dtc_configuration = 81;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(81, _Internal::device_wilco_dtc_configuration(this),
        _Internal::device_wilco_dtc_configuration(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceWiFiAllowedProto device_wifi_allowed = 82;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(82, _Internal::device_wifi_allowed(this),
        _Internal::device_wifi_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePowerPeakShiftProto device_power_peak_shift = 83;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(83, _Internal::device_power_peak_shift(this),
        _Internal::device_power_peak_shift(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceBootOnAcProto device_boot_on_ac = 84;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(84, _Internal::device_boot_on_ac(this),
        _Internal::device_boot_on_ac(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceDockMacAddressSourceProto device_dock_mac_address_source = 85;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(85, _Internal::device_dock_mac_address_source(this),
        _Internal::device_dock_mac_address_source(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAdvancedBatteryChargeModeProto device_advanced_battery_charge_mode = 86;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(86, _Internal::device_advanced_battery_charge_mode(this),
        _Internal::device_advanced_battery_charge_mode(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceBatteryChargeModeProto device_battery_charge_mode = 87;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(87, _Internal::device_battery_charge_mode(this),
        _Internal::device_battery_charge_mode(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceUsbPowerShareProto device_usb_power_share = 88;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(88, _Internal::device_usb_power_share(this),
        _Internal::device_usb_power_share(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceScheduledUpdateCheckProto device_scheduled_update_check = 89;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(89, _Internal::device_scheduled_update_check(this),
        _Internal::device_scheduled_update_check(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePowerwashAllowedProto device_powerwash_allowed = 91;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(91, _Internal::device_powerwash_allowed(this),
        _Internal::device_powerwash_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto device_login_screen_webusb_allow_devices_for_urls = 92;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(92, _Internal::device_login_screen_webusb_allow_devices_for_urls(this),
        _Internal::device_login_screen_webusb_allow_devices_for_urls(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BooleanPolicyProto device_login_screen_system_info_enforced = 93;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(93, _Internal::device_login_screen_system_info_enforced(this),
        _Internal::device_login_screen_system_info_enforced(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.StringListPolicyProto device_web_based_attestation_allowed_urls = 94;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(94, _Internal::device_web_based_attestation_allowed_urls(this),
        _Internal::device_web_based_attestation_allowed_urls(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BooleanPolicyProto device_show_numeric_keyboard_for_password = 95;
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(95, _Internal::device_show_numeric_keyboard_for_password(this),
        _Internal::device_show_numeric_keyboard_for_password(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BooleanPolicyProto login_screen_primary_mouse_button_switch = 96;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(96, _Internal::login_screen_primary_mouse_button_switch(this),
        _Internal::login_screen_primary_mouse_button_switch(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.StringPolicyProto device_minimum_version = 97;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(97, _Internal::device_minimum_version(this),
        _Internal::device_minimum_version(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SystemProxySettingsProto system_proxy_settings = 98;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(98, _Internal::system_proxy_settings(this),
        _Internal::system_proxy_settings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.IntegerPolicyProto device_chrome_variations_type = 99;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(99, _Internal::device_chrome_variations_type(this),
        _Internal::device_chrome_variations_type(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[3];
  // optional .enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto device_login_screen_privacy_screen_enabled = 100;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(100, _Internal::device_login_screen_privacy_screen_enabled(this),
        _Internal::device_login_screen_privacy_screen_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.RequiredClientCertificateForDeviceProto required_client_certificate_for_device = 101;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(101, _Internal::required_client_certificate_for_device(this),
        _Internal::required_client_certificate_for_device(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto device_crostini_arc_adb_sideloading_allowed = 102;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(102, _Internal::device_crostini_arc_adb_sideloading_allowed(this),
        _Internal::device_crostini_arc_adb_sideloading_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.StringPolicyProto device_minimum_version_aue_message = 103;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(103, _Internal::device_minimum_version_aue_message(this),
        _Internal::device_minimum_version_aue_message(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ManagedGuestSessionPrivacyWarningsProto managed_guest_session_privacy_warnings = 104;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(104, _Internal::managed_guest_session_privacy_warnings(this),
        _Internal::managed_guest_session_privacy_warnings(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceExternalPrintServersProto external_print_servers = 105;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(105, _Internal::external_print_servers(this),
        _Internal::external_print_servers(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceExternalPrintServersAllowlistProto external_print_servers_allowlist = 106;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(106, _Internal::external_print_servers_allowlist(this),
        _Internal::external_print_servers_allowlist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePrintersAccessModeProto device_printers_access_mode = 107;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(107, _Internal::device_printers_access_mode(this),
        _Internal::device_printers_access_mode(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePrintersBlocklistProto device_printers_blocklist = 108;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(108, _Internal::device_printers_blocklist(this),
        _Internal::device_printers_blocklist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePrintersAllowlistProto device_printers_allowlist = 109;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(109, _Internal::device_printers_allowlist(this),
        _Internal::device_printers_allowlist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePrintersProto device_printers = 110;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(110, _Internal::device_printers(this),
        _Internal::device_printers(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceShowLowDiskSpaceNotificationProto device_show_low_disk_space_notification = 111;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(111, _Internal::device_show_low_disk_space_notification(this),
        _Internal::device_show_low_disk_space_notification(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.UserAllowlistProto user_allowlist = 112;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(112, _Internal::user_allowlist(this),
        _Internal::user_allowlist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.UsbDetachableAllowlistProto usb_detachable_allowlist = 113;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(113, _Internal::usb_detachable_allowlist(this),
        _Internal::usb_detachable_allowlist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceFamilyLinkAccountsAllowedProto family_link_accounts_allowed = 114;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(114, _Internal::family_link_accounts_allowed(this),
        _Internal::family_link_accounts_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceArcDataSnapshotHoursProto arc_data_snapshot_hours = 115;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(115, _Internal::arc_data_snapshot_hours(this),
        _Internal::arc_data_snapshot_hours(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BooleanPolicyProto device_allow_mgs_to_store_display_properties = 116;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(116, _Internal::device_allow_mgs_to_store_display_properties(this),
        _Internal::device_allow_mgs_to_store_display_properties(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceSystemWideTracingEnabledProto device_system_wide_tracing_enabled = 117;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(117, _Internal::device_system_wide_tracing_enabled(this),
        _Internal::device_system_wide_tracing_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProto device_pci_peripheral_data_access_enabled = 118;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(118, _Internal::device_pci_peripheral_data_access_enabled(this),
        _Internal::device_pci_peripheral_data_access_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OBSOLETE_DeviceBorealisAllowedProto device_borealis_allowed = 119 [deprecated = true];
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(119, _Internal::device_borealis_allowed(this),
        _Internal::device_borealis_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAllowedBluetoothServicesProto device_allowed_bluetooth_services = 120;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(120, _Internal::device_allowed_bluetooth_services(this),
        _Internal::device_allowed_bluetooth_services(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceDebugPacketCaptureAllowedProto device_debug_packet_capture_allowed = 121;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(121, _Internal::device_debug_packet_capture_allowed(this),
        _Internal::device_debug_packet_capture_allowed(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceScheduledRebootProto device_scheduled_reboot = 122;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(122, _Internal::device_scheduled_reboot(this),
        _Internal::device_scheduled_reboot(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2 device_pci_peripheral_data_access_enabled_v2 = 123;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(123, _Internal::device_pci_peripheral_data_access_enabled_v2(this),
        _Internal::device_pci_peripheral_data_access_enabled_v2(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto device_restricted_managed_guest_session_enabled = 124;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(124, _Internal::device_restricted_managed_guest_session_enabled(this),
        _Internal::device_restricted_managed_guest_session_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.HostnameUserConfigurableProto hostname_user_configurable = 125;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(125, _Internal::hostname_user_configurable(this),
        _Internal::hostname_user_configurable(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BooleanPolicyProto login_screen_prompt_on_multiple_matching_certificates = 126;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(126, _Internal::login_screen_prompt_on_multiple_matching_certificates(this),
        _Internal::login_screen_prompt_on_multiple_matching_certificates(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BooleanPolicyProto kiosk_crx_manifest_update_url_ignored = 127;
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(127, _Internal::kiosk_crx_manifest_update_url_ignored(this),
        _Internal::kiosk_crx_manifest_update_url_ignored(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceI18nShortcutsEnabledProto device_i18n_shortcuts_enabled = 128;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(128, _Internal::device_i18n_shortcuts_enabled(this),
        _Internal::device_i18n_shortcuts_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BooleanPolicyProto chromad_to_cloud_migration_enabled = 129;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(129, _Internal::chromad_to_cloud_migration_enabled(this),
        _Internal::chromad_to_cloud_migration_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.RevenDeviceHWDataUsageEnabledProto hardware_data_usage_enabled = 130;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(130, _Internal::hardware_data_usage_enabled(this),
        _Internal::hardware_data_usage_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceLoginScreenWebUILazyLoadingProto login_web_ui_lazy_loading = 131;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(131, _Internal::login_web_ui_lazy_loading(this),
        _Internal::login_web_ui_lazy_loading(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[4];
  // optional .enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto keylocker_for_storage_encryption_enabled = 132;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(132, _Internal::keylocker_for_storage_encryption_enabled(this),
        _Internal::keylocker_for_storage_encryption_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BooleanPolicyProto device_run_automatic_cleanup_on_login = 133;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(133, _Internal::device_run_automatic_cleanup_on_login(this),
        _Internal::device_run_automatic_cleanup_on_login(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.EncryptedReportingPipelineConfigurationProto device_encrypted_reporting_pipeline_enabled = 134;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(134, _Internal::device_encrypted_reporting_pipeline_enabled(this),
        _Internal::device_encrypted_reporting_pipeline_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SAMLUsernameProto saml_username = 135;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(135, _Internal::saml_username(this),
        _Internal::saml_username(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.StringListPolicyProto device_login_screen_context_aware_access_signals_allowlist = 136;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(136, _Internal::device_login_screen_context_aware_access_signals_allowlist(this),
        _Internal::device_login_screen_context_aware_access_signals_allowlist(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.StringPolicyProto device_printing_client_name_template = 137;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(137, _Internal::device_printing_client_name_template(this),
        _Internal::device_printing_client_name_template(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceReportXDREventsProto device_report_xdr_events = 138;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(138, _Internal::device_report_xdr_events(this),
        _Internal::device_report_xdr_events(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.KeyboardBacklightColorProto keyboard_backlight_color = 139;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(139, _Internal::keyboard_backlight_color(this),
        _Internal::keyboard_backlight_color(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceHindiInscriptLayoutEnabledProto device_hindi_inscript_layout_enabled = 140;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(140, _Internal::device_hindi_inscript_layout_enabled(this),
        _Internal::device_hindi_inscript_layout_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto login_screen_extension_manifest_v2_availability = 141;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(141, _Internal::login_screen_extension_manifest_v2_availability(this),
        _Internal::login_screen_extension_manifest_v2_availability(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceScreensaverEnabledProto device_screensaver_enabled = 142;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(142, _Internal::device_screensaver_enabled(this),
        _Internal::device_screensaver_enabled(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto device_screensaver_idle_timeout_seconds = 143;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(143, _Internal::device_screensaver_idle_timeout_seconds(this),
        _Internal::device_screensaver_idle_timeout_seconds(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto device_screensaver_image_display_interval_seconds = 144;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(144, _Internal::device_screensaver_image_display_interval_seconds(this),
        _Internal::device_screensaver_image_display_interval_seconds(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceScreensaverImagesProto device_screensaver_images = 145;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(145, _Internal::device_screensaver_images(this),
        _Internal::device_screensaver_images(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceSystemAecEnabledProto device_system_aec_enabled = 146;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(146, _Internal::device_system_aec_enabled(this),
        _Internal::device_system_aec_enabled(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeDeviceSettingsProto)
  return target;
}

size_t ChromeDeviceSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeDeviceSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.DevicePolicyRefreshRateProto device_policy_refresh_rate = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_policy_refresh_rate_);
    }

    // optional .enterprise_management.UserWhitelistProto user_whitelist = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_whitelist_);
    }

    // optional .enterprise_management.GuestModeEnabledProto guest_mode_enabled = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.guest_mode_enabled_);
    }

    // optional .enterprise_management.OBSOLETE_DeviceProxySettingsProto device_proxy_settings = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_proxy_settings_);
    }

    // optional .enterprise_management.CameraEnabledProto camera_enabled = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.camera_enabled_);
    }

    // optional .enterprise_management.ShowUserNamesOnSigninProto show_user_names = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.show_user_names_);
    }

    // optional .enterprise_management.DataRoamingEnabledProto data_roaming_enabled = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_roaming_enabled_);
    }

    // optional .enterprise_management.AllowNewUsersProto allow_new_users = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.allow_new_users_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.MetricsEnabledProto metrics_enabled = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metrics_enabled_);
    }

    // optional .enterprise_management.ReleaseChannelProto release_channel = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.release_channel_);
    }

    // optional .enterprise_management.DeviceOpenNetworkConfigurationProto open_network_configuration = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.open_network_configuration_);
    }

    // optional .enterprise_management.DeviceReportingProto device_reporting = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_reporting_);
    }

    // optional .enterprise_management.EphemeralUsersEnabledProto ephemeral_users_enabled = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ephemeral_users_enabled_);
    }

    // optional .enterprise_management.OBSOLETE_AppPackProto app_pack = 14 [deprecated = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.app_pack_);
    }

    // optional .enterprise_management.OBSOLETE_ForcedLogoutTimeoutsProto forced_logout_timeouts = 15 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.forced_logout_timeouts_);
    }

    // optional .enterprise_management.OBSOLETE_ScreenSaverProto login_screen_saver = 16 [deprecated = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_saver_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .enterprise_management.AutoUpdateSettingsProto auto_update_settings = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.auto_update_settings_);
    }

    // optional .enterprise_management.OBSOLETE_StartUpUrlsProto start_up_urls = 18 [deprecated = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_up_urls_);
    }

    // optional .enterprise_management.OBSOLETE_PinnedAppsProto pinned_apps = 19 [deprecated = true];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pinned_apps_);
    }

    // optional .enterprise_management.SystemTimezoneProto system_timezone = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.system_timezone_);
    }

    // optional .enterprise_management.DeviceLocalAccountsProto device_local_accounts = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_local_accounts_);
    }

    // optional .enterprise_management.AllowRedeemChromeOsRegistrationOffersProto allow_redeem_offers = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.allow_redeem_offers_);
    }

    // optional .enterprise_management.FeatureFlagsProto feature_flags = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.feature_flags_);
    }

    // optional .enterprise_management.UptimeLimitProto uptime_limit = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.uptime_limit_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .enterprise_management.VariationsParameterProto variations_parameter = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.variations_parameter_);
    }

    // optional .enterprise_management.AttestationSettingsProto attestation_settings = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attestation_settings_);
    }

    // optional .enterprise_management.AccessibilitySettingsProto accessibility_settings = 27;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.accessibility_settings_);
    }

    // optional .enterprise_management.OBSOLETE_SupervisedUsersSettingsProto supervised_users_settings = 28 [deprecated = true];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.supervised_users_settings_);
    }

    // optional .enterprise_management.LoginScreenPowerManagementProto login_screen_power_management = 29;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_power_management_);
    }

    // optional .enterprise_management.SystemUse24HourClockProto use_24hour_clock = 30;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.use_24hour_clock_);
    }

    // optional .enterprise_management.AutoCleanupSettigsProto auto_clean_up_settings = 31;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.auto_clean_up_settings_);
    }

    // optional .enterprise_management.SystemSettingsProto system_settings = 32;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.system_settings_);
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.SAMLSettingsProto saml_settings = 33;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.saml_settings_);
    }

    // optional .enterprise_management.RebootOnShutdownProto reboot_on_shutdown = 34;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reboot_on_shutdown_);
    }

    // optional .enterprise_management.DeviceHeartbeatSettingsProto device_heartbeat_settings = 35;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_heartbeat_settings_);
    }

    // optional .enterprise_management.ExtensionCacheSizeProto extension_cache_size = 36;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.extension_cache_size_);
    }

    // optional .enterprise_management.LoginScreenDomainAutoCompleteProto login_screen_domain_auto_complete = 37;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_domain_auto_complete_);
    }

    // optional .enterprise_management.DeviceLogUploadSettingsProto device_log_upload_settings = 38;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_log_upload_settings_);
    }

    // optional .enterprise_management.DisplayRotationDefaultProto display_rotation_default = 39;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.display_rotation_default_);
    }

    // optional .enterprise_management.AllowKioskAppControlChromeVersionProto allow_kiosk_app_control_chrome_version = 40;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.allow_kiosk_app_control_chrome_version_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.LoginAuthenticationBehaviorProto login_authentication_behavior = 41;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_authentication_behavior_);
    }

    // optional .enterprise_management.UsbDetachableWhitelistProto usb_detachable_whitelist = 42;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.usb_detachable_whitelist_);
    }

    // optional .enterprise_management.AllowBluetoothProto allow_bluetooth = 43;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.allow_bluetooth_);
    }

    // optional .enterprise_management.DeviceQuirksDownloadEnabledProto quirks_download_enabled = 44;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quirks_download_enabled_);
    }

    // optional .enterprise_management.LoginVideoCaptureAllowedUrlsProto login_video_capture_allowed_urls = 45;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_video_capture_allowed_urls_);
    }

    // optional .enterprise_management.DeviceLoginScreenExtensionsProto device_login_screen_extensions = 46;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_login_screen_extensions_);
    }

    // optional .enterprise_management.NetworkThrottlingEnabledProto network_throttling = 47;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.network_throttling_);
    }

    // optional .enterprise_management.DeviceWallpaperImageProto device_wallpaper_image = 48;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_wallpaper_image_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .enterprise_management.LoginScreenLocalesProto login_screen_locales = 49;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_locales_);
    }

    // optional .enterprise_management.LoginScreenInputMethodsProto login_screen_input_methods = 50;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_input_methods_);
    }

    // optional .enterprise_management.DeviceEcryptfsMigrationStrategyProto device_ecryptfs_migration_strategy = 51 [deprecated = true];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_ecryptfs_migration_strategy_);
    }

    // optional .enterprise_management.DeviceSecondFactorAuthenticationProto device_second_factor_authentication = 52;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_second_factor_authentication_);
    }

    // optional .enterprise_management.CastReceiverNameProto cast_receiver_name = 53;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cast_receiver_name_);
    }

    // optional .enterprise_management.DeviceOffHoursProto device_off_hours = 54;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_off_hours_);
    }

    // optional .enterprise_management.DeviceNativePrintersProto native_device_printers = 55;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.native_device_printers_);
    }

    // optional .enterprise_management.DeviceNativePrintersAccessModeProto native_device_printers_access_mode = 56;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.native_device_printers_access_mode_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .enterprise_management.DeviceNativePrintersBlacklistProto native_device_printers_blacklist = 57;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.native_device_printers_blacklist_);
    }

    // optional .enterprise_management.DeviceNativePrintersWhitelistProto native_device_printers_whitelist = 58;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.native_device_printers_whitelist_);
    }

    // optional .enterprise_management.TPMFirmwareUpdateSettingsProto tpm_firmware_update_settings = 59;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tpm_firmware_update_settings_);
    }

    // optional .enterprise_management.OBSOLETE_MinimumRequiredVersionProto minimum_required_version = 60 [deprecated = true];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.minimum_required_version_);
    }

    // optional .enterprise_management.DeviceLoginScreenAutoSelectCertificateForUrls device_login_screen_auto_select_certificate_for_urls = 62;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_login_screen_auto_select_certificate_for_urls_);
    }

    // optional .enterprise_management.UnaffiliatedArcAllowedProto unaffiliated_arc_allowed = 63;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.unaffiliated_arc_allowed_);
    }

    // optional .enterprise_management.NetworkHostnameProto network_hostname = 64;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.network_hostname_);
    }

    // optional .enterprise_management.DeviceKerberosEncryptionTypesProto device_kerberos_encryption_types = 65;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_kerberos_encryption_types_);
    }

  }
  cached_has_bits = _impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.DeviceUserPolicyLoopbackProcessingModeProto device_user_policy_loopback_processing_mode = 66;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_user_policy_loopback_processing_mode_);
    }

    // optional .enterprise_management.OBSOLETE_DeviceLoginScreenIsolateOriginsProto device_login_screen_isolate_origins = 67 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_login_screen_isolate_origins_);
    }

    // optional .enterprise_management.OBSOLETE_DeviceLoginScreenSitePerProcessProto device_login_screen_site_per_process = 68 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_login_screen_site_per_process_);
    }

    // optional .enterprise_management.VirtualMachinesAllowedProto virtual_machines_allowed = 69;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.virtual_machines_allowed_);
    }

    // optional .enterprise_management.DeviceMachinePasswordChangeRateProto device_machine_password_change_rate = 70;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_machine_password_change_rate_);
    }

    // optional .enterprise_management.DeviceUnaffiliatedCrostiniAllowedProto device_unaffiliated_crostini_allowed = 72;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_unaffiliated_crostini_allowed_);
    }

    // optional .enterprise_management.DeviceWiFiFastTransitionEnabledProto device_wifi_fast_transition_enabled = 73;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_wifi_fast_transition_enabled_);
    }

    // optional .enterprise_management.DeviceDisplayResolutionProto device_display_resolution = 74;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_display_resolution_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.PluginVmAllowedProto plugin_vm_allowed = 75;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.plugin_vm_allowed_);
    }

    // optional .enterprise_management.DeviceGpoCacheLifetimeProto device_gpo_cache_lifetime = 76;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_gpo_cache_lifetime_);
    }

    // optional .enterprise_management.DeviceAuthDataCacheLifetimeProto device_auth_data_cache_lifetime = 77;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_auth_data_cache_lifetime_);
    }

    // optional .enterprise_management.PluginVmLicenseKeyProto plugin_vm_license_key = 78;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.plugin_vm_license_key_);
    }

    // optional .enterprise_management.DeviceRebootOnUserSignoutProto device_reboot_on_user_signout = 79;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_reboot_on_user_signout_);
    }

    // optional .enterprise_management.DeviceWilcoDtcAllowedProto device_wilco_dtc_allowed = 80;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_wilco_dtc_allowed_);
    }

    // optional .enterprise_management.DeviceWilcoDtcConfigurationProto device_wilco_dtc_configuration = 81;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_wilco_dtc_configuration_);
    }

    // optional .enterprise_management.DeviceWiFiAllowedProto device_wifi_allowed = 82;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_wifi_allowed_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .enterprise_management.DevicePowerPeakShiftProto device_power_peak_shift = 83;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_power_peak_shift_);
    }

    // optional .enterprise_management.DeviceBootOnAcProto device_boot_on_ac = 84;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_boot_on_ac_);
    }

    // optional .enterprise_management.DeviceDockMacAddressSourceProto device_dock_mac_address_source = 85;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_dock_mac_address_source_);
    }

    // optional .enterprise_management.DeviceAdvancedBatteryChargeModeProto device_advanced_battery_charge_mode = 86;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_advanced_battery_charge_mode_);
    }

    // optional .enterprise_management.DeviceBatteryChargeModeProto device_battery_charge_mode = 87;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_battery_charge_mode_);
    }

    // optional .enterprise_management.DeviceUsbPowerShareProto device_usb_power_share = 88;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_usb_power_share_);
    }

    // optional .enterprise_management.DeviceScheduledUpdateCheckProto device_scheduled_update_check = 89;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_scheduled_update_check_);
    }

    // optional .enterprise_management.DevicePowerwashAllowedProto device_powerwash_allowed = 91;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_powerwash_allowed_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .enterprise_management.DeviceLoginScreenWebUsbAllowDevicesForUrlsProto device_login_screen_webusb_allow_devices_for_urls = 92;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_login_screen_webusb_allow_devices_for_urls_);
    }

    // optional .enterprise_management.BooleanPolicyProto device_login_screen_system_info_enforced = 93;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_login_screen_system_info_enforced_);
    }

    // optional .enterprise_management.StringListPolicyProto device_web_based_attestation_allowed_urls = 94;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_web_based_attestation_allowed_urls_);
    }

    // optional .enterprise_management.BooleanPolicyProto device_show_numeric_keyboard_for_password = 95;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_show_numeric_keyboard_for_password_);
    }

    // optional .enterprise_management.BooleanPolicyProto login_screen_primary_mouse_button_switch = 96;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_primary_mouse_button_switch_);
    }

    // optional .enterprise_management.StringPolicyProto device_minimum_version = 97;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_minimum_version_);
    }

    // optional .enterprise_management.SystemProxySettingsProto system_proxy_settings = 98;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.system_proxy_settings_);
    }

    // optional .enterprise_management.IntegerPolicyProto device_chrome_variations_type = 99;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_chrome_variations_type_);
    }

  }
  cached_has_bits = _impl_._has_bits_[3];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.DeviceLoginScreenPrivacyScreenEnabledProto device_login_screen_privacy_screen_enabled = 100;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_login_screen_privacy_screen_enabled_);
    }

    // optional .enterprise_management.RequiredClientCertificateForDeviceProto required_client_certificate_for_device = 101;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.required_client_certificate_for_device_);
    }

    // optional .enterprise_management.DeviceCrostiniArcAdbSideloadingAllowedProto device_crostini_arc_adb_sideloading_allowed = 102;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_crostini_arc_adb_sideloading_allowed_);
    }

    // optional .enterprise_management.StringPolicyProto device_minimum_version_aue_message = 103;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_minimum_version_aue_message_);
    }

    // optional .enterprise_management.ManagedGuestSessionPrivacyWarningsProto managed_guest_session_privacy_warnings = 104;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.managed_guest_session_privacy_warnings_);
    }

    // optional .enterprise_management.DeviceExternalPrintServersProto external_print_servers = 105;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.external_print_servers_);
    }

    // optional .enterprise_management.DeviceExternalPrintServersAllowlistProto external_print_servers_allowlist = 106;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.external_print_servers_allowlist_);
    }

    // optional .enterprise_management.DevicePrintersAccessModeProto device_printers_access_mode = 107;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_printers_access_mode_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.DevicePrintersBlocklistProto device_printers_blocklist = 108;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_printers_blocklist_);
    }

    // optional .enterprise_management.DevicePrintersAllowlistProto device_printers_allowlist = 109;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_printers_allowlist_);
    }

    // optional .enterprise_management.DevicePrintersProto device_printers = 110;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_printers_);
    }

    // optional .enterprise_management.DeviceShowLowDiskSpaceNotificationProto device_show_low_disk_space_notification = 111;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_show_low_disk_space_notification_);
    }

    // optional .enterprise_management.UserAllowlistProto user_allowlist = 112;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_allowlist_);
    }

    // optional .enterprise_management.UsbDetachableAllowlistProto usb_detachable_allowlist = 113;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.usb_detachable_allowlist_);
    }

    // optional .enterprise_management.DeviceFamilyLinkAccountsAllowedProto family_link_accounts_allowed = 114;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.family_link_accounts_allowed_);
    }

    // optional .enterprise_management.DeviceArcDataSnapshotHoursProto arc_data_snapshot_hours = 115;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.arc_data_snapshot_hours_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .enterprise_management.BooleanPolicyProto device_allow_mgs_to_store_display_properties = 116;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_allow_mgs_to_store_display_properties_);
    }

    // optional .enterprise_management.DeviceSystemWideTracingEnabledProto device_system_wide_tracing_enabled = 117;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_system_wide_tracing_enabled_);
    }

    // optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProto device_pci_peripheral_data_access_enabled = 118;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_pci_peripheral_data_access_enabled_);
    }

    // optional .enterprise_management.OBSOLETE_DeviceBorealisAllowedProto device_borealis_allowed = 119 [deprecated = true];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_borealis_allowed_);
    }

    // optional .enterprise_management.DeviceAllowedBluetoothServicesProto device_allowed_bluetooth_services = 120;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_allowed_bluetooth_services_);
    }

    // optional .enterprise_management.DeviceDebugPacketCaptureAllowedProto device_debug_packet_capture_allowed = 121;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_debug_packet_capture_allowed_);
    }

    // optional .enterprise_management.DeviceScheduledRebootProto device_scheduled_reboot = 122;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_scheduled_reboot_);
    }

    // optional .enterprise_management.DevicePciPeripheralDataAccessEnabledProtoV2 device_pci_peripheral_data_access_enabled_v2 = 123;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_pci_peripheral_data_access_enabled_v2_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .enterprise_management.DeviceRestrictedManagedGuestSessionEnabledProto device_restricted_managed_guest_session_enabled = 124;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_restricted_managed_guest_session_enabled_);
    }

    // optional .enterprise_management.HostnameUserConfigurableProto hostname_user_configurable = 125;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hostname_user_configurable_);
    }

    // optional .enterprise_management.BooleanPolicyProto login_screen_prompt_on_multiple_matching_certificates = 126;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_prompt_on_multiple_matching_certificates_);
    }

    // optional .enterprise_management.BooleanPolicyProto kiosk_crx_manifest_update_url_ignored = 127;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kiosk_crx_manifest_update_url_ignored_);
    }

    // optional .enterprise_management.DeviceI18nShortcutsEnabledProto device_i18n_shortcuts_enabled = 128;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_i18n_shortcuts_enabled_);
    }

    // optional .enterprise_management.BooleanPolicyProto chromad_to_cloud_migration_enabled = 129;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chromad_to_cloud_migration_enabled_);
    }

    // optional .enterprise_management.RevenDeviceHWDataUsageEnabledProto hardware_data_usage_enabled = 130;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hardware_data_usage_enabled_);
    }

    // optional .enterprise_management.DeviceLoginScreenWebUILazyLoadingProto login_web_ui_lazy_loading = 131;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_web_ui_lazy_loading_);
    }

  }
  cached_has_bits = _impl_._has_bits_[4];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.DeviceKeylockerForStorageEncryptionEnabledProto keylocker_for_storage_encryption_enabled = 132;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.keylocker_for_storage_encryption_enabled_);
    }

    // optional .enterprise_management.BooleanPolicyProto device_run_automatic_cleanup_on_login = 133;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_run_automatic_cleanup_on_login_);
    }

    // optional .enterprise_management.EncryptedReportingPipelineConfigurationProto device_encrypted_reporting_pipeline_enabled = 134;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_encrypted_reporting_pipeline_enabled_);
    }

    // optional .enterprise_management.SAMLUsernameProto saml_username = 135;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.saml_username_);
    }

    // optional .enterprise_management.StringListPolicyProto device_login_screen_context_aware_access_signals_allowlist = 136;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_login_screen_context_aware_access_signals_allowlist_);
    }

    // optional .enterprise_management.StringPolicyProto device_printing_client_name_template = 137;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_printing_client_name_template_);
    }

    // optional .enterprise_management.DeviceReportXDREventsProto device_report_xdr_events = 138;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_report_xdr_events_);
    }

    // optional .enterprise_management.KeyboardBacklightColorProto keyboard_backlight_color = 139;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.keyboard_backlight_color_);
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional .enterprise_management.DeviceHindiInscriptLayoutEnabledProto device_hindi_inscript_layout_enabled = 140;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_hindi_inscript_layout_enabled_);
    }

    // optional .enterprise_management.LoginScreenExtensionManifestV2AvailabilityProto login_screen_extension_manifest_v2_availability = 141;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_screen_extension_manifest_v2_availability_);
    }

    // optional .enterprise_management.DeviceScreensaverEnabledProto device_screensaver_enabled = 142;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_screensaver_enabled_);
    }

    // optional .enterprise_management.DeviceScreensaverIdleTimeoutSecondsProto device_screensaver_idle_timeout_seconds = 143;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_screensaver_idle_timeout_seconds_);
    }

    // optional .enterprise_management.DeviceScreensaverImageDisplayIntervalSecondsProto device_screensaver_image_display_interval_seconds = 144;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_screensaver_image_display_interval_seconds_);
    }

    // optional .enterprise_management.DeviceScreensaverImagesProto device_screensaver_images = 145;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_screensaver_images_);
    }

    // optional .enterprise_management.DeviceSystemAecEnabledProto device_system_aec_enabled = 146;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_system_aec_enabled_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeDeviceSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeDeviceSettingsProto*>(
      &from));
}

void ChromeDeviceSettingsProto::MergeFrom(const ChromeDeviceSettingsProto& from) {
  ChromeDeviceSettingsProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeDeviceSettingsProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_device_policy_refresh_rate()->::enterprise_management::DevicePolicyRefreshRateProto::MergeFrom(
          from._internal_device_policy_refresh_rate());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_user_whitelist()->::enterprise_management::UserWhitelistProto::MergeFrom(
          from._internal_user_whitelist());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_guest_mode_enabled()->::enterprise_management::GuestModeEnabledProto::MergeFrom(
          from._internal_guest_mode_enabled());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_device_proxy_settings()->::enterprise_management::OBSOLETE_DeviceProxySettingsProto::MergeFrom(
          from._internal_device_proxy_settings());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_camera_enabled()->::enterprise_management::CameraEnabledProto::MergeFrom(
          from._internal_camera_enabled());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_show_user_names()->::enterprise_management::ShowUserNamesOnSigninProto::MergeFrom(
          from._internal_show_user_names());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_data_roaming_enabled()->::enterprise_management::DataRoamingEnabledProto::MergeFrom(
          from._internal_data_roaming_enabled());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_allow_new_users()->::enterprise_management::AllowNewUsersProto::MergeFrom(
          from._internal_allow_new_users());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_metrics_enabled()->::enterprise_management::MetricsEnabledProto::MergeFrom(
          from._internal_metrics_enabled());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_release_channel()->::enterprise_management::ReleaseChannelProto::MergeFrom(
          from._internal_release_channel());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_open_network_configuration()->::enterprise_management::DeviceOpenNetworkConfigurationProto::MergeFrom(
          from._internal_open_network_configuration());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_device_reporting()->::enterprise_management::DeviceReportingProto::MergeFrom(
          from._internal_device_reporting());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_ephemeral_users_enabled()->::enterprise_management::EphemeralUsersEnabledProto::MergeFrom(
          from._internal_ephemeral_users_enabled());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_app_pack()->::enterprise_management::OBSOLETE_AppPackProto::MergeFrom(
          from._internal_app_pack());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_forced_logout_timeouts()->::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto::MergeFrom(
          from._internal_forced_logout_timeouts());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_login_screen_saver()->::enterprise_management::OBSOLETE_ScreenSaverProto::MergeFrom(
          from._internal_login_screen_saver());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_auto_update_settings()->::enterprise_management::AutoUpdateSettingsProto::MergeFrom(
          from._internal_auto_update_settings());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_start_up_urls()->::enterprise_management::OBSOLETE_StartUpUrlsProto::MergeFrom(
          from._internal_start_up_urls());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_pinned_apps()->::enterprise_management::OBSOLETE_PinnedAppsProto::MergeFrom(
          from._internal_pinned_apps());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_system_timezone()->::enterprise_management::SystemTimezoneProto::MergeFrom(
          from._internal_system_timezone());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_device_local_accounts()->::enterprise_management::DeviceLocalAccountsProto::MergeFrom(
          from._internal_device_local_accounts());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_allow_redeem_offers()->::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto::MergeFrom(
          from._internal_allow_redeem_offers());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_feature_flags()->::enterprise_management::FeatureFlagsProto::MergeFrom(
          from._internal_feature_flags());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_uptime_limit()->::enterprise_management::UptimeLimitProto::MergeFrom(
          from._internal_uptime_limit());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_variations_parameter()->::enterprise_management::VariationsParameterProto::MergeFrom(
          from._internal_variations_parameter());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_attestation_settings()->::enterprise_management::AttestationSettingsProto::MergeFrom(
          from._internal_attestation_settings());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_accessibility_settings()->::enterprise_management::AccessibilitySettingsProto::MergeFrom(
          from._internal_accessibility_settings());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_supervised_users_settings()->::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto::MergeFrom(
          from._internal_supervised_users_settings());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_login_screen_power_management()->::enterprise_management::LoginScreenPowerManagementProto::MergeFrom(
          from._internal_login_screen_power_management());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_mutable_use_24hour_clock()->::enterprise_management::SystemUse24HourClockProto::MergeFrom(
          from._internal_use_24hour_clock());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_mutable_auto_clean_up_settings()->::enterprise_management::AutoCleanupSettigsProto::MergeFrom(
          from._internal_auto_clean_up_settings());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_mutable_system_settings()->::enterprise_management::SystemSettingsProto::MergeFrom(
          from._internal_system_settings());
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_saml_settings()->::enterprise_management::SAMLSettingsProto::MergeFrom(
          from._internal_saml_settings());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_reboot_on_shutdown()->::enterprise_management::RebootOnShutdownProto::MergeFrom(
          from._internal_reboot_on_shutdown());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_device_heartbeat_settings()->::enterprise_management::DeviceHeartbeatSettingsProto::MergeFrom(
          from._internal_device_heartbeat_settings());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_extension_cache_size()->::enterprise_management::ExtensionCacheSizeProto::MergeFrom(
          from._internal_extension_cache_size());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_login_screen_domain_auto_complete()->::enterprise_management::LoginScreenDomainAutoCompleteProto::MergeFrom(
          from._internal_login_screen_domain_auto_complete());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_device_log_upload_settings()->::enterprise_management::DeviceLogUploadSettingsProto::MergeFrom(
          from._internal_device_log_upload_settings());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_display_rotation_default()->::enterprise_management::DisplayRotationDefaultProto::MergeFrom(
          from._internal_display_rotation_default());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_allow_kiosk_app_control_chrome_version()->::enterprise_management::AllowKioskAppControlChromeVersionProto::MergeFrom(
          from._internal_allow_kiosk_app_control_chrome_version());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_login_authentication_behavior()->::enterprise_management::LoginAuthenticationBehaviorProto::MergeFrom(
          from._internal_login_authentication_behavior());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_usb_detachable_whitelist()->::enterprise_management::UsbDetachableWhitelistProto::MergeFrom(
          from._internal_usb_detachable_whitelist());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_allow_bluetooth()->::enterprise_management::AllowBluetoothProto::MergeFrom(
          from._internal_allow_bluetooth());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_quirks_download_enabled()->::enterprise_management::DeviceQuirksDownloadEnabledProto::MergeFrom(
          from._internal_quirks_download_enabled());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_login_video_capture_allowed_urls()->::enterprise_management::LoginVideoCaptureAllowedUrlsProto::MergeFrom(
          from._internal_login_video_capture_allowed_urls());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_device_login_screen_extensions()->::enterprise_management::DeviceLoginScreenExtensionsProto::MergeFrom(
          from._internal_device_login_screen_extensions());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_network_throttling()->::enterprise_management::NetworkThrottlingEnabledProto::MergeFrom(
          from._internal_network_throttling());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_device_wallpaper_image()->::enterprise_management::DeviceWallpaperImageProto::MergeFrom(
          from._internal_device_wallpaper_image());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_login_screen_locales()->::enterprise_management::LoginScreenLocalesProto::MergeFrom(
          from._internal_login_screen_locales());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_login_screen_input_methods()->::enterprise_management::LoginScreenInputMethodsProto::MergeFrom(
          from._internal_login_screen_input_methods());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_device_ecryptfs_migration_strategy()->::enterprise_management::DeviceEcryptfsMigrationStrategyProto::MergeFrom(
          from._internal_device_ecryptfs_migration_strategy());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_device_second_factor_authentication()->::enterprise_management::DeviceSecondFactorAuthenticationProto::MergeFrom(
          from._internal_device_second_factor_authentication());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_cast_receiver_name()->::enterprise_management::CastReceiverNameProto::MergeFrom(
          from._internal_cast_receiver_name());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_device_off_hours()->::enterprise_management::DeviceOffHoursProto::MergeFrom(
          from._internal_device_off_hours());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_native_device_printers()->::enterprise_management::DeviceNativePrintersProto::MergeFrom(
          from._internal_native_device_printers());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_native_device_printers_access_mode()->::enterprise_management::DeviceNativePrintersAccessModeProto::MergeFrom(
          from._internal_native_device_printers_access_mode());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_native_device_printers_blacklist()->::enterprise_management::DeviceNativePrintersBlacklistProto::MergeFrom(
          from._internal_native_device_printers_blacklist());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_native_device_printers_whitelist()->::enterprise_management::DeviceNativePrintersWhitelistProto::MergeFrom(
          from._internal_native_device_printers_whitelist());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_tpm_firmware_update_settings()->::enterprise_management::TPMFirmwareUpdateSettingsProto::MergeFrom(
          from._internal_tpm_firmware_update_settings());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_minimum_required_version()->::enterprise_management::OBSOLETE_MinimumRequiredVersionProto::MergeFrom(
          from._internal_minimum_required_version());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_device_login_screen_auto_select_certificate_for_urls()->::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls::MergeFrom(
          from._internal_device_login_screen_auto_select_certificate_for_urls());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_mutable_unaffiliated_arc_allowed()->::enterprise_management::UnaffiliatedArcAllowedProto::MergeFrom(
          from._internal_unaffiliated_arc_allowed());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_mutable_network_hostname()->::enterprise_management::NetworkHostnameProto::MergeFrom(
          from._internal_network_hostname());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_mutable_device_kerberos_encryption_types()->::enterprise_management::DeviceKerberosEncryptionTypesProto::MergeFrom(
          from._internal_device_kerberos_encryption_types());
    }
  }
  cached_has_bits = from._impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_device_user_policy_loopback_processing_mode()->::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto::MergeFrom(
          from._internal_device_user_policy_loopback_processing_mode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_device_login_screen_isolate_origins()->::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto::MergeFrom(
          from._internal_device_login_screen_isolate_origins());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_device_login_screen_site_per_process()->::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto::MergeFrom(
          from._internal_device_login_screen_site_per_process());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_virtual_machines_allowed()->::enterprise_management::VirtualMachinesAllowedProto::MergeFrom(
          from._internal_virtual_machines_allowed());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_device_machine_password_change_rate()->::enterprise_management::DeviceMachinePasswordChangeRateProto::MergeFrom(
          from._internal_device_machine_password_change_rate());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_device_unaffiliated_crostini_allowed()->::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto::MergeFrom(
          from._internal_device_unaffiliated_crostini_allowed());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_device_wifi_fast_transition_enabled()->::enterprise_management::DeviceWiFiFastTransitionEnabledProto::MergeFrom(
          from._internal_device_wifi_fast_transition_enabled());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_device_display_resolution()->::enterprise_management::DeviceDisplayResolutionProto::MergeFrom(
          from._internal_device_display_resolution());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_plugin_vm_allowed()->::enterprise_management::PluginVmAllowedProto::MergeFrom(
          from._internal_plugin_vm_allowed());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_device_gpo_cache_lifetime()->::enterprise_management::DeviceGpoCacheLifetimeProto::MergeFrom(
          from._internal_device_gpo_cache_lifetime());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_device_auth_data_cache_lifetime()->::enterprise_management::DeviceAuthDataCacheLifetimeProto::MergeFrom(
          from._internal_device_auth_data_cache_lifetime());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_plugin_vm_license_key()->::enterprise_management::PluginVmLicenseKeyProto::MergeFrom(
          from._internal_plugin_vm_license_key());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_device_reboot_on_user_signout()->::enterprise_management::DeviceRebootOnUserSignoutProto::MergeFrom(
          from._internal_device_reboot_on_user_signout());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_device_wilco_dtc_allowed()->::enterprise_management::DeviceWilcoDtcAllowedProto::MergeFrom(
          from._internal_device_wilco_dtc_allowed());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_device_wilco_dtc_configuration()->::enterprise_management::DeviceWilcoDtcConfigurationProto::MergeFrom(
          from._internal_device_wilco_dtc_configuration());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_device_wifi_allowed()->::enterprise_management::DeviceWiFiAllowedProto::MergeFrom(
          from._internal_device_wifi_allowed());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_device_power_peak_shift()->::enterprise_management::DevicePowerPeakShiftProto::MergeFrom(
          from._internal_device_power_peak_shift());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_device_boot_on_ac()->::enterprise_management::DeviceBootOnAcProto::MergeFrom(
          from._internal_device_boot_on_ac());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_device_dock_mac_address_source()->::enterprise_management::DeviceDockMacAddressSourceProto::MergeFrom(
          from._internal_device_dock_mac_address_source());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_device_advanced_battery_charge_mode()->::enterprise_management::DeviceAdvancedBatteryChargeModeProto::MergeFrom(
          from._internal_device_advanced_battery_charge_mode());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_device_battery_charge_mode()->::enterprise_management::DeviceBatteryChargeModeProto::MergeFrom(
          from._internal_device_battery_charge_mode());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_device_usb_power_share()->::enterprise_management::DeviceUsbPowerShareProto::MergeFrom(
          from._internal_device_usb_power_share());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_device_scheduled_update_check()->::enterprise_management::DeviceScheduledUpdateCheckProto::MergeFrom(
          from._internal_device_scheduled_update_check());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_device_powerwash_allowed()->::enterprise_management::DevicePowerwashAllowedProto::MergeFrom(
          from._internal_device_powerwash_allowed());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_device_login_screen_webusb_allow_devices_for_urls()->::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto::MergeFrom(
          from._internal_device_login_screen_webusb_allow_devices_for_urls());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_device_login_screen_system_info_enforced()->::enterprise_management::BooleanPolicyProto::MergeFrom(
          from._internal_device_login_screen_system_info_enforced());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_device_web_based_attestation_allowed_urls()->::enterprise_management::StringListPolicyProto::MergeFrom(
          from._internal_device_web_based_attestation_allowed_urls());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_device_show_numeric_keyboard_for_password()->::enterprise_management::BooleanPolicyProto::MergeFrom(
          from._internal_device_show_numeric_keyboard_for_password());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_login_screen_primary_mouse_button_switch()->::enterprise_management::BooleanPolicyProto::MergeFrom(
          from._internal_login_screen_primary_mouse_button_switch());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_mutable_device_minimum_version()->::enterprise_management::StringPolicyProto::MergeFrom(
          from._internal_device_minimum_version());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_mutable_system_proxy_settings()->::enterprise_management::SystemProxySettingsProto::MergeFrom(
          from._internal_system_proxy_settings());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_mutable_device_chrome_variations_type()->::enterprise_management::IntegerPolicyProto::MergeFrom(
          from._internal_device_chrome_variations_type());
    }
  }
  cached_has_bits = from._impl_._has_bits_[3];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_device_login_screen_privacy_screen_enabled()->::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto::MergeFrom(
          from._internal_device_login_screen_privacy_screen_enabled());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_required_client_certificate_for_device()->::enterprise_management::RequiredClientCertificateForDeviceProto::MergeFrom(
          from._internal_required_client_certificate_for_device());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_device_crostini_arc_adb_sideloading_allowed()->::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto::MergeFrom(
          from._internal_device_crostini_arc_adb_sideloading_allowed());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_device_minimum_version_aue_message()->::enterprise_management::StringPolicyProto::MergeFrom(
          from._internal_device_minimum_version_aue_message());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_managed_guest_session_privacy_warnings()->::enterprise_management::ManagedGuestSessionPrivacyWarningsProto::MergeFrom(
          from._internal_managed_guest_session_privacy_warnings());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_external_print_servers()->::enterprise_management::DeviceExternalPrintServersProto::MergeFrom(
          from._internal_external_print_servers());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_external_print_servers_allowlist()->::enterprise_management::DeviceExternalPrintServersAllowlistProto::MergeFrom(
          from._internal_external_print_servers_allowlist());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_device_printers_access_mode()->::enterprise_management::DevicePrintersAccessModeProto::MergeFrom(
          from._internal_device_printers_access_mode());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_device_printers_blocklist()->::enterprise_management::DevicePrintersBlocklistProto::MergeFrom(
          from._internal_device_printers_blocklist());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_device_printers_allowlist()->::enterprise_management::DevicePrintersAllowlistProto::MergeFrom(
          from._internal_device_printers_allowlist());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_device_printers()->::enterprise_management::DevicePrintersProto::MergeFrom(
          from._internal_device_printers());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_device_show_low_disk_space_notification()->::enterprise_management::DeviceShowLowDiskSpaceNotificationProto::MergeFrom(
          from._internal_device_show_low_disk_space_notification());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_user_allowlist()->::enterprise_management::UserAllowlistProto::MergeFrom(
          from._internal_user_allowlist());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_usb_detachable_allowlist()->::enterprise_management::UsbDetachableAllowlistProto::MergeFrom(
          from._internal_usb_detachable_allowlist());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_family_link_accounts_allowed()->::enterprise_management::DeviceFamilyLinkAccountsAllowedProto::MergeFrom(
          from._internal_family_link_accounts_allowed());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_arc_data_snapshot_hours()->::enterprise_management::DeviceArcDataSnapshotHoursProto::MergeFrom(
          from._internal_arc_data_snapshot_hours());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_device_allow_mgs_to_store_display_properties()->::enterprise_management::BooleanPolicyProto::MergeFrom(
          from._internal_device_allow_mgs_to_store_display_properties());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_device_system_wide_tracing_enabled()->::enterprise_management::DeviceSystemWideTracingEnabledProto::MergeFrom(
          from._internal_device_system_wide_tracing_enabled());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_device_pci_peripheral_data_access_enabled()->::enterprise_management::DevicePciPeripheralDataAccessEnabledProto::MergeFrom(
          from._internal_device_pci_peripheral_data_access_enabled());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_device_borealis_allowed()->::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto::MergeFrom(
          from._internal_device_borealis_allowed());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_device_allowed_bluetooth_services()->::enterprise_management::DeviceAllowedBluetoothServicesProto::MergeFrom(
          from._internal_device_allowed_bluetooth_services());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_device_debug_packet_capture_allowed()->::enterprise_management::DeviceDebugPacketCaptureAllowedProto::MergeFrom(
          from._internal_device_debug_packet_capture_allowed());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_device_scheduled_reboot()->::enterprise_management::DeviceScheduledRebootProto::MergeFrom(
          from._internal_device_scheduled_reboot());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_device_pci_peripheral_data_access_enabled_v2()->::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2::MergeFrom(
          from._internal_device_pci_peripheral_data_access_enabled_v2());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_device_restricted_managed_guest_session_enabled()->::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto::MergeFrom(
          from._internal_device_restricted_managed_guest_session_enabled());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_hostname_user_configurable()->::enterprise_management::HostnameUserConfigurableProto::MergeFrom(
          from._internal_hostname_user_configurable());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_login_screen_prompt_on_multiple_matching_certificates()->::enterprise_management::BooleanPolicyProto::MergeFrom(
          from._internal_login_screen_prompt_on_multiple_matching_certificates());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_kiosk_crx_manifest_update_url_ignored()->::enterprise_management::BooleanPolicyProto::MergeFrom(
          from._internal_kiosk_crx_manifest_update_url_ignored());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_device_i18n_shortcuts_enabled()->::enterprise_management::DeviceI18nShortcutsEnabledProto::MergeFrom(
          from._internal_device_i18n_shortcuts_enabled());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_mutable_chromad_to_cloud_migration_enabled()->::enterprise_management::BooleanPolicyProto::MergeFrom(
          from._internal_chromad_to_cloud_migration_enabled());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_mutable_hardware_data_usage_enabled()->::enterprise_management::RevenDeviceHWDataUsageEnabledProto::MergeFrom(
          from._internal_hardware_data_usage_enabled());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_mutable_login_web_ui_lazy_loading()->::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto::MergeFrom(
          from._internal_login_web_ui_lazy_loading());
    }
  }
  cached_has_bits = from._impl_._has_bits_[4];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_keylocker_for_storage_encryption_enabled()->::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto::MergeFrom(
          from._internal_keylocker_for_storage_encryption_enabled());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_device_run_automatic_cleanup_on_login()->::enterprise_management::BooleanPolicyProto::MergeFrom(
          from._internal_device_run_automatic_cleanup_on_login());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_device_encrypted_reporting_pipeline_enabled()->::enterprise_management::EncryptedReportingPipelineConfigurationProto::MergeFrom(
          from._internal_device_encrypted_reporting_pipeline_enabled());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_saml_username()->::enterprise_management::SAMLUsernameProto::MergeFrom(
          from._internal_saml_username());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_device_login_screen_context_aware_access_signals_allowlist()->::enterprise_management::StringListPolicyProto::MergeFrom(
          from._internal_device_login_screen_context_aware_access_signals_allowlist());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_device_printing_client_name_template()->::enterprise_management::StringPolicyProto::MergeFrom(
          from._internal_device_printing_client_name_template());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_device_report_xdr_events()->::enterprise_management::DeviceReportXDREventsProto::MergeFrom(
          from._internal_device_report_xdr_events());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_keyboard_backlight_color()->::enterprise_management::KeyboardBacklightColorProto::MergeFrom(
          from._internal_keyboard_backlight_color());
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_device_hindi_inscript_layout_enabled()->::enterprise_management::DeviceHindiInscriptLayoutEnabledProto::MergeFrom(
          from._internal_device_hindi_inscript_layout_enabled());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_login_screen_extension_manifest_v2_availability()->::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto::MergeFrom(
          from._internal_login_screen_extension_manifest_v2_availability());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_device_screensaver_enabled()->::enterprise_management::DeviceScreensaverEnabledProto::MergeFrom(
          from._internal_device_screensaver_enabled());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_device_screensaver_idle_timeout_seconds()->::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto::MergeFrom(
          from._internal_device_screensaver_idle_timeout_seconds());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_device_screensaver_image_display_interval_seconds()->::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto::MergeFrom(
          from._internal_device_screensaver_image_display_interval_seconds());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_device_screensaver_images()->::enterprise_management::DeviceScreensaverImagesProto::MergeFrom(
          from._internal_device_screensaver_images());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_device_system_aec_enabled()->::enterprise_management::DeviceSystemAecEnabledProto::MergeFrom(
          from._internal_device_system_aec_enabled());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeDeviceSettingsProto::CopyFrom(const ChromeDeviceSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeDeviceSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeDeviceSettingsProto::IsInitialized() const {
  return true;
}

void ChromeDeviceSettingsProto::InternalSwap(ChromeDeviceSettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  swap(_impl_._has_bits_[2], other->_impl_._has_bits_[2]);
  swap(_impl_._has_bits_[3], other->_impl_._has_bits_[3]);
  swap(_impl_._has_bits_[4], other->_impl_._has_bits_[4]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChromeDeviceSettingsProto, _impl_.device_system_aec_enabled_)
      + sizeof(ChromeDeviceSettingsProto::_impl_.device_system_aec_enabled_)
      - PROTOBUF_FIELD_OFFSET(ChromeDeviceSettingsProto, _impl_.device_policy_refresh_rate_)>(
          reinterpret_cast<char*>(&_impl_.device_policy_refresh_rate_),
          reinterpret_cast<char*>(&other->_impl_.device_policy_refresh_rate_));
}

std::string ChromeDeviceSettingsProto::GetTypeName() const {
  return "enterprise_management.ChromeDeviceSettingsProto";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace enterprise_management
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePolicyRefreshRateProto*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePolicyRefreshRateProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePolicyRefreshRateProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UserWhitelistProto*
Arena::CreateMaybeMessage< ::enterprise_management::UserWhitelistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UserWhitelistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UserAllowlistProto*
Arena::CreateMaybeMessage< ::enterprise_management::UserAllowlistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UserAllowlistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AllowNewUsersProto*
Arena::CreateMaybeMessage< ::enterprise_management::AllowNewUsersProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AllowNewUsersProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::GuestModeEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::GuestModeEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::GuestModeEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ShowUserNamesOnSigninProto*
Arena::CreateMaybeMessage< ::enterprise_management::ShowUserNamesOnSigninProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ShowUserNamesOnSigninProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DataRoamingEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DataRoamingEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DataRoamingEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_DeviceProxySettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_DeviceProxySettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_DeviceProxySettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CameraEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::CameraEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CameraEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::MetricsEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::MetricsEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::MetricsEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ReleaseChannelProto*
Arena::CreateMaybeMessage< ::enterprise_management::ReleaseChannelProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ReleaseChannelProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceOpenNetworkConfigurationProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceOpenNetworkConfigurationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceOpenNetworkConfigurationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::NetworkHostnameProto*
Arena::CreateMaybeMessage< ::enterprise_management::NetworkHostnameProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::NetworkHostnameProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceHindiInscriptLayoutEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::HostnameUserConfigurableProto*
Arena::CreateMaybeMessage< ::enterprise_management::HostnameUserConfigurableProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::HostnameUserConfigurableProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceReportingProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceReportingProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceReportingProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::EphemeralUsersEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::EphemeralUsersEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::EphemeralUsersEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceKeylockerForStorageEncryptionEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_AppPackEntryProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_AppPackEntryProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_AppPackEntryProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_AppPackProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_AppPackProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_AppPackProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_PinnedAppsProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_PinnedAppsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_PinnedAppsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_ForcedLogoutTimeoutsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_ScreenSaverProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_ScreenSaverProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_ScreenSaverProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AutoUpdateSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::AutoUpdateSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AutoUpdateSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_StartUpUrlsProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_StartUpUrlsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_StartUpUrlsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SystemTimezoneProto*
Arena::CreateMaybeMessage< ::enterprise_management::SystemTimezoneProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SystemTimezoneProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SystemUse24HourClockProto*
Arena::CreateMaybeMessage< ::enterprise_management::SystemUse24HourClockProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SystemUse24HourClockProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::KioskAppInfoProto*
Arena::CreateMaybeMessage< ::enterprise_management::KioskAppInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::KioskAppInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AndroidKioskAppInfoProto*
Arena::CreateMaybeMessage< ::enterprise_management::AndroidKioskAppInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AndroidKioskAppInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::WebKioskAppInfoProto*
Arena::CreateMaybeMessage< ::enterprise_management::WebKioskAppInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::WebKioskAppInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceLocalAccountInfoProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceLocalAccountInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceLocalAccountInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceLocalAccountsProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceLocalAccountsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceLocalAccountsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto*
Arena::CreateMaybeMessage< ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ManagedGuestSessionPrivacyWarningsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto*
Arena::CreateMaybeMessage< ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AllowRedeemChromeOsRegistrationOffersProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::FeatureFlagsProto*
Arena::CreateMaybeMessage< ::enterprise_management::FeatureFlagsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::FeatureFlagsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UptimeLimitProto*
Arena::CreateMaybeMessage< ::enterprise_management::UptimeLimitProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UptimeLimitProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::VariationsParameterProto*
Arena::CreateMaybeMessage< ::enterprise_management::VariationsParameterProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::VariationsParameterProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AttestationSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::AttestationSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AttestationSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AccessibilitySettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::AccessibilitySettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AccessibilitySettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_SupervisedUsersSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LoginScreenPowerManagementProto*
Arena::CreateMaybeMessage< ::enterprise_management::LoginScreenPowerManagementProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LoginScreenPowerManagementProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AutoCleanupSettigsProto*
Arena::CreateMaybeMessage< ::enterprise_management::AutoCleanupSettigsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AutoCleanupSettigsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SystemSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::SystemSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SystemSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SAMLSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::SAMLSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SAMLSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SAMLUsernameProto*
Arena::CreateMaybeMessage< ::enterprise_management::SAMLUsernameProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SAMLUsernameProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RebootOnShutdownProto*
Arena::CreateMaybeMessage< ::enterprise_management::RebootOnShutdownProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RebootOnShutdownProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceHeartbeatSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceHeartbeatSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceHeartbeatSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ExtensionCacheSizeProto*
Arena::CreateMaybeMessage< ::enterprise_management::ExtensionCacheSizeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ExtensionCacheSizeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LoginScreenDomainAutoCompleteProto*
Arena::CreateMaybeMessage< ::enterprise_management::LoginScreenDomainAutoCompleteProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LoginScreenDomainAutoCompleteProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceLogUploadSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceLogUploadSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceLogUploadSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DisplayRotationDefaultProto*
Arena::CreateMaybeMessage< ::enterprise_management::DisplayRotationDefaultProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DisplayRotationDefaultProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceLoginScreenPrivacyScreenEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceDisplayResolutionProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceDisplayResolutionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceDisplayResolutionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AllowKioskAppControlChromeVersionProto*
Arena::CreateMaybeMessage< ::enterprise_management::AllowKioskAppControlChromeVersionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AllowKioskAppControlChromeVersionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LoginAuthenticationBehaviorProto*
Arena::CreateMaybeMessage< ::enterprise_management::LoginAuthenticationBehaviorProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LoginAuthenticationBehaviorProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UsbDeviceIdProto*
Arena::CreateMaybeMessage< ::enterprise_management::UsbDeviceIdProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UsbDeviceIdProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UsbDetachableWhitelistProto*
Arena::CreateMaybeMessage< ::enterprise_management::UsbDetachableWhitelistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UsbDetachableWhitelistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UsbDeviceIdInclusiveProto*
Arena::CreateMaybeMessage< ::enterprise_management::UsbDeviceIdInclusiveProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UsbDeviceIdInclusiveProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UsbDetachableAllowlistProto*
Arena::CreateMaybeMessage< ::enterprise_management::UsbDetachableAllowlistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UsbDetachableAllowlistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AllowBluetoothProto*
Arena::CreateMaybeMessage< ::enterprise_management::AllowBluetoothProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AllowBluetoothProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceWiFiAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceWiFiAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceWiFiAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceQuirksDownloadEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceQuirksDownloadEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceQuirksDownloadEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LoginVideoCaptureAllowedUrlsProto*
Arena::CreateMaybeMessage< ::enterprise_management::LoginVideoCaptureAllowedUrlsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LoginVideoCaptureAllowedUrlsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceWiFiFastTransitionEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceWiFiFastTransitionEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceWiFiFastTransitionEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::NetworkThrottlingEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::NetworkThrottlingEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::NetworkThrottlingEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceLoginScreenExtensionsProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceLoginScreenExtensionsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceLoginScreenExtensionsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto*
Arena::CreateMaybeMessage< ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LoginScreenExtensionManifestV2AvailabilityProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LoginScreenLocalesProto*
Arena::CreateMaybeMessage< ::enterprise_management::LoginScreenLocalesProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LoginScreenLocalesProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LoginScreenInputMethodsProto*
Arena::CreateMaybeMessage< ::enterprise_management::LoginScreenInputMethodsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LoginScreenInputMethodsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceWallpaperImageProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceWallpaperImageProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceWallpaperImageProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceScreensaverIdleTimeoutSecondsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceScreensaverImageDisplayIntervalSecondsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceScreensaverImagesProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceScreensaverImagesProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceScreensaverImagesProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceSystemAecEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceSystemAecEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceSystemAecEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceScreensaverEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceScreensaverEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceScreensaverEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceEcryptfsMigrationStrategyProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceEcryptfsMigrationStrategyProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceEcryptfsMigrationStrategyProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceSecondFactorAuthenticationProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceSecondFactorAuthenticationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceSecondFactorAuthenticationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CastReceiverNameProto*
Arena::CreateMaybeMessage< ::enterprise_management::CastReceiverNameProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CastReceiverNameProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::WeeklyTimeProto*
Arena::CreateMaybeMessage< ::enterprise_management::WeeklyTimeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::WeeklyTimeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::WeeklyTimeIntervalProto*
Arena::CreateMaybeMessage< ::enterprise_management::WeeklyTimeIntervalProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::WeeklyTimeIntervalProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceOffHoursProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceOffHoursProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceOffHoursProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceNativePrintersProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceNativePrintersProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceNativePrintersProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceNativePrintersAccessModeProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceNativePrintersAccessModeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceNativePrintersAccessModeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceNativePrintersBlacklistProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceNativePrintersBlacklistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceNativePrintersBlacklistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceNativePrintersWhitelistProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceNativePrintersWhitelistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceNativePrintersWhitelistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePrintersProto*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePrintersProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePrintersProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePrintersAccessModeProto*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePrintersAccessModeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePrintersAccessModeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePrintersBlocklistProto*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePrintersBlocklistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePrintersBlocklistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePrintersAllowlistProto*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePrintersAllowlistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePrintersAllowlistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceExternalPrintServersProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceExternalPrintServersProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceExternalPrintServersProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceExternalPrintServersAllowlistProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceExternalPrintServersAllowlistProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceExternalPrintServersAllowlistProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::TPMFirmwareUpdateSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::TPMFirmwareUpdateSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::TPMFirmwareUpdateSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_MinimumRequiredVersionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceLoginScreenAutoSelectCertificateForUrls >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UnaffiliatedArcAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::UnaffiliatedArcAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UnaffiliatedArcAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceKerberosEncryptionTypesProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceKerberosEncryptionTypesProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceKerberosEncryptionTypesProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::KeyboardBacklightColorProto*
Arena::CreateMaybeMessage< ::enterprise_management::KeyboardBacklightColorProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::KeyboardBacklightColorProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceUserPolicyLoopbackProcessingModeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_DeviceLoginScreenIsolateOriginsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_DeviceLoginScreenSitePerProcessProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::VirtualMachinesAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::VirtualMachinesAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::VirtualMachinesAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceMachinePasswordChangeRateProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceMachinePasswordChangeRateProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceMachinePasswordChangeRateProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceGpoCacheLifetimeProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceGpoCacheLifetimeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceGpoCacheLifetimeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAuthDataCacheLifetimeProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAuthDataCacheLifetimeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAuthDataCacheLifetimeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceUnaffiliatedCrostiniAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PluginVmAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::PluginVmAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PluginVmAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PluginVmLicenseKeyProto*
Arena::CreateMaybeMessage< ::enterprise_management::PluginVmLicenseKeyProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PluginVmLicenseKeyProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceRebootOnUserSignoutProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceRebootOnUserSignoutProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceRebootOnUserSignoutProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceWilcoDtcAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceWilcoDtcAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceWilcoDtcAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceWilcoDtcConfigurationProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceWilcoDtcConfigurationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceWilcoDtcConfigurationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePowerPeakShiftProto*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePowerPeakShiftProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePowerPeakShiftProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceBootOnAcProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceBootOnAcProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceBootOnAcProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceDockMacAddressSourceProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceDockMacAddressSourceProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceDockMacAddressSourceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAdvancedBatteryChargeModeProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAdvancedBatteryChargeModeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAdvancedBatteryChargeModeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceBatteryChargeModeProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceBatteryChargeModeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceBatteryChargeModeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceUsbPowerShareProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceUsbPowerShareProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceUsbPowerShareProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceScheduledUpdateCheckProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceScheduledUpdateCheckProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceScheduledUpdateCheckProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePowerwashAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePowerwashAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePowerwashAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceLoginScreenWebUsbAllowDevicesForUrlsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SystemProxySettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::SystemProxySettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SystemProxySettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RequiredClientCertificateForDeviceProto*
Arena::CreateMaybeMessage< ::enterprise_management::RequiredClientCertificateForDeviceProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RequiredClientCertificateForDeviceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceCrostiniArcAdbSideloadingAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceShowLowDiskSpaceNotificationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceFamilyLinkAccountsAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceArcDataSnapshotHoursProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceArcDataSnapshotHoursProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceArcDataSnapshotHoursProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceSystemWideTracingEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceSystemWideTracingEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceSystemWideTracingEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePciPeripheralDataAccessEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePciPeripheralDataAccessEnabledProtoV2 >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OBSOLETE_DeviceBorealisAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAllowedBluetoothServicesProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAllowedBluetoothServicesProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAllowedBluetoothServicesProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceDebugPacketCaptureAllowedProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceDebugPacketCaptureAllowedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceDebugPacketCaptureAllowedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceScheduledRebootProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceScheduledRebootProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceScheduledRebootProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceRestrictedManagedGuestSessionEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceI18nShortcutsEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceI18nShortcutsEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceI18nShortcutsEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RevenDeviceHWDataUsageEnabledProto*
Arena::CreateMaybeMessage< ::enterprise_management::RevenDeviceHWDataUsageEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RevenDeviceHWDataUsageEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceLoginScreenWebUILazyLoadingProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::EncryptedReportingPipelineConfigurationProto*
Arena::CreateMaybeMessage< ::enterprise_management::EncryptedReportingPipelineConfigurationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::EncryptedReportingPipelineConfigurationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceReportXDREventsProto*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceReportXDREventsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceReportXDREventsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeDeviceSettingsProto*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeDeviceSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeDeviceSettingsProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
